<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-22T12:03:33.483Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随笔-2020-03-22-3</title>
    <link href="https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22-3/"/>
    <id>https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22-3/</id>
    <published>2020-03-22T12:02:39.000Z</published>
    <updated>2020-03-22T12:03:33.483Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="00ac6db7bfe3778cd0abf95a4d8f7a7be56d653d00110a58c968a77f15a10658">0267ec72f19b8c198697a4f72870a3a8e079571dd153910a3b8a7777eb6dc1eaeae43280319e51b16e957573ae9472ac6e32750b09ef1ec64ca90e00f22e8b1322a49e17140d4b82674bb4beecb4d1f5d0a288607100e1877cc84efeee4035f45ee144d1efe75c3c6d379b85fb5ee20ebaa988388e8a003fc0c1a18e5ff798ce0b1570c979a85e8f400f6e7119f6dbab91101f3216efeff6bef96dbf099fe26dfb83be1fea19a8f60d6c987f30bcceb99a12443f9f37b6e0f46e92a3927b410134140f251e7c13af68b3bca39a9ea2c19fa63140daf36bc4f355a560e4736f609945b872283a58f67ce7e77c249f3d2a05d9685c373e4fdda7e787900ee006741d9e2ba9a603e8e906d9b5bb8a39d9c0f7ac8daf6a001c8a2a135c52edcd377af71edbf3d13a29b124cf4021d395087fafff5405d0738f23364c2d810bec21e6b311565711eecfd2ff970e6b4b5787792235ab755b8a60a0589ac5d29df3e33e6da55cc1e26e1e188beec21532cfe668aa09dccb492cd8c84dc36d390ce5756811f9904bd54aaa725139bd5f1f8065f17261958d7606818d8c0b1e274f229b0388dbbd0f4095e80c3aa2a985dcd7c1e07ddd9fd36a8213589fdc8cdf81319cde5979f91d3a1c1eb16c3cc3cb4b6acb82983bef40884354e3badc0351d01683c347fa6bc330c866cf1a4c0acdcb93a809d63c81889a075c2e9c19b610bfe0c692fba461faae93e669f5f93980c0bbc7454d82238c2bcf4d93c48c0ce0fa59ba2ff33699afde03070b2a84f3ec5d0589fcb1fdcb9a5b786ca92fd8c958fe7bd49d58557fc92d26e5faaf4138e37b0d8de08b19ae6b1d6c8ccde13219e65f6f4ad10cd6e46a6bc4a36d98ab212dcf903cc8262f921ad540b99e042b9fe8d9140fd110f158e5ae972f732b5ce05c14e3b6224c11fde78c6e6f0c8411a40f292c45843836c38a731a1702764d8ec08689ae40a45080940a89702a4642231ee58dd27d05493e6f1fda1a4123b55351f26f869439424588586749946dad83dc247f4b8c442a2e3f2f4f0482ab00c6b0284db2029e2f60f605cff4a3677103fc99c7e302f3edf3e0f3612a90983ddc480b2357cbb96b8c83dc9132978d886a370481b63d173d08c842a70752574791959f23695219bd3c54b6afcfb723ca721e6871a649971fdf382acf4fa3684c45398c6860364d874165bb81d2e2c78a9a397b4fd6dd50e33ce3ceeb1562503946ac7cfe630d17dc1f4b3f3eb818a69b757ef0ae981d</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="无" scheme="https://unit-serow.github.io/tags/%E6%97%A0/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-22-2</title>
    <link href="https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22-2/"/>
    <id>https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22-2/</id>
    <published>2020-03-22T12:01:10.000Z</published>
    <updated>2020-03-22T12:05:07.352Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 22 2020 20:05:11 GMT+0800 (中国标准时间) --><center><strong>至此</strong></center><a id="more"></a><center><strong>问题一</strong></center><center><strong>已解决</strong></center><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 22 2020 20:05:11 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;至此&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="无" scheme="https://unit-serow.github.io/tags/%E6%97%A0/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-22-1</title>
    <link href="https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22-1/"/>
    <id>https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22-1/</id>
    <published>2020-03-22T11:59:14.000Z</published>
    <updated>2020-03-22T17:59:55.516Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="95eefa9c8fb4d4edf656adecce666342c02db8626ac225aa745fcdaf7ffce3fe">0267ec72f19b8c198697a4f72870a3a81c3dce918bdc1764d9b7d3b83fab37b9b52b78b64981513159cdee517c0690b8fcbd0575b3b0430e076b3755ca98c77a78c5500a4961198fe233eb48f639bd00de77b4c295b06ab99580f4a72319753455ee9e6dea1bdb75899f9ac6a59a07849956220d45c78005ae76edb8cb691ae6ed3dc2192a7c44fec1bfe3715a0f5b0c73ccd60a44a03b13c6c3a5f0e0209d6976c8756aac2da04df932c4655e0b71008d49f322be7e1ae82d88b17c0f61000ae2ffa1c0eba7877eb7d4750f90125ee5ce36955b873fba6ba2fbeea1d7e60295568b2caf860b1b98914f9619191c6dfedc4dfd074fbf0f0fc4fb80fc190163a09dae4721eb7a6805040b1cecaa64f34db736d495daf16c7cdca78973229eaf28123cc103832a32c793aacf30c2bef53a894ccce55582fec0eac9abe38afd236bdc12c2cf24d8f518125f0c78b752e15f6ac3b0fd9b92de3c1b70ec9f3b492a943292bf498d4f95067c678871e2e4680fc3ab851351052b5e26f8498e19dd1321e059764b9292f69822d9bdf63ca62eda44b2a9a9f88efc00af35449e8859db295000c67bbc747c4083e8919960ef947e11b58cfd0dcb6b8ca0892331663e7595565157046949f16258be7225c0af2607dc82533b58677617ca037fe5a9da772738947cb769ca451b45d5980c5071b656d26baafb4865fb584ec99db4371f5a10e4011de1c305dab262218666d7e874bf01bb93ceca7b7c8b5a7706016fee71ff8a8996069650827e7eb5ce9a8196c506b01cf9cbdc540333a1d5ffb22e16ebfa66c82cb1eb61fbe70c38973118be072d50ddb941cf4f7e93e821914b78e1d5f999ab054427a69d43d1bd94cc7a1486332f8eb8235e37a27b3007c39f12978e18b64121c102b7fe5afa70b675e7f36cefb8868899327269af74af08d547202006c40213d4af9c9f32847d247f6899d4e8d55518354b7cf17abe918408857d57c26b81a228b827033ef712e6569bcd530bd690dc30d6c60322f2781a6ff6ef2c1d0469992d80c33e4ddcdf22c3ea4c955694f8a0563123e29e332182bca3216f3b16162a30583f2878cb772ffb3f039ca9fe712a8a16a653b74ce711cb4542b1b9a7a1728c874e285b3d19ff4ee97e300200dd1dfb73330ca6a4bf6813d50064435ab4036373b57859258b08c8d8eb2dfe119a07aacd7981c965f3ce7c34705ed8b042b228871a03522e099580532dd16e70001e3c5071596b4c00b62dd388237e0ea03f3dd53bfd43624b0408690a0394d2660634d0563c5f45a2f9add5a4f48ab7102488fbb406cde0426430029937db9153aa53bb644bf8cc4e6340ae14776eccfe4c826fdf3b0f37d1c2002f4e80be7244d26c869e53212021d322c7ca72cca2e799910d723d5231f17858b834f887700a0855bb6f640f415fa917a243fd0de7915498bf4c5edea77428bcffe45b8aefb4824b3349ebc55cc9ca70277f4ad00550d4cd1ff22ead6df8cb85373829db08986e0e173610f8cb710b7e7f6c10f169efe3e11a69b426dc2bd2d945be92537125a6de9764721c2fcdac66c83cd03e1840fbec3d493e5552d0da0497f02f8b3f94569f173acda2179b799c565467f7dd61e7630c800e4f8c49aee6bbb5a568effdefa61472e53a6ca77d07d879fe5266406af16c616fe194b932c70d9671684af625a8d87db5297c36cb70896494d28334c1ee57c19ab9be3b40fd817ae60b1c3e1b1fc8cf2398080807741fcc1504c3cb6344f1f3dd269c896a9b78cf69ef0c78801d2334f36da7b9db0520513568b50dda9518a6bae01f84785261f14629477ba2bb6eb944680589bfe6e36cc52341992ef2e4913e90f56e0def9ef2dd501ca87192370112340c09980001620fee75be6f7c4d388a1980445066ac055dc6667fb89e75da97644cf5594e0e1ae0f9eb94bd016420565219a4b8e5edd8744507d374236f6d3bec93b0e81f33afa46013b74cac119996c1ba3b06b6b2709d03a1f64d07c243ca7c29853e3da0752f6d286ea9637513c2654d35a571d49ad208b3c17a4a81c04fa84b13f8c049c92594b6a0a3a88977c6f6e42cf0678d36621231972ebe5b662d1f301b08e080575cf3bfcd4dfb36d08867cd7d3d2cecd1c2176683bd9817cfe2db57e7d7d1dc2bbdcf4a94ef5bc48f4e270da57cf79a82fb0e0b3494c598ddf48e805329f34f30a6f51cc630981e86298d1812a4be4f59edda265e70e96e5e9866269ea95991dffd89522337a3d65956b11fc790a3551f39abebcaf409895989d5243809b17fe108058e79bf30722a84327da67f80509559113be2bef526c43e36663d01c97a7d00b42508210007ab93b424b7a396cb14d8b80b54f4e3e29a0a9111d9d5bfbae99170943008d71be08888b5b4c1af7abc3ce04371c95dbdf502c4ba2688c0fbc903a0190895bb285d2a3ee786d435030b55d80199c615dfe6359e67bd1fa023dffa23e0c7df8d149d44844a95702edb09c1fa2ea0e1802952c8119a06adee5c46023493cb7baea0cca6974d9675cbbf253130473d6fc321d7c1daeb3c52afb0ae11cc44d46614647afde8dd21878f65ff522d13aa4bad93d0a0e0ff31677575c8f5d77e60760ffb031ca277ca2377dbea94e05baa46199b9aceffca1a41ae45750ac4d3d8817def40a554ea0964bfe8a7115bdf0e377366f917257c4ee745220f0f64977da1650ee59b37ec3549ecc86b355c44ad01fa3829b95a7013c9473544ddd97681e83d0fad95b3c2647321e837eaadc241d768e5e9fc20c9763daaef7f6678f4393c09098395167c5b11a94496c01bd8a3fe095f549082bb1171ed135398b527ce53a0711480e1ff585591d157bb1322e321beea5a04f0a933ee1fbd4f2ea03c8129566aaf6f1f77ce60e6fae69eee23ec44e79c615088102a56a47b55719acf2bee977f56563ea1797d7a251ec7fe3c99d7f5e415fa2651f983e8be225cebf5bdebce8a51c07a879161aff7e852b3bafbb007dfef4aa48e6882efabb347c94773c0236360c88929343311f1158f308c06168e73d9ec7475324c9e27bec8a70a9c991c5422bfc1920346e5386bb9bbe224a7ed92d105eeaaccf479be9224a3bbbffb381397f469f3df1399f44778de12ff98399a5350710c79a99ef892b064394e851daf07ef73ecdd46878f28f5b67a58b5958b6e49b7c2e670b814bcd0f8fadbf693efa7ce3bb04448e3e0e89e4f6e50578613969c2df5bdde7d1dd1f406ef73ca880ca6e5fa3675bc0e311877fe1cfe5464e7267103b6dab09c636c32b87254dee3c5f08b48b7da77fa78fbc1f5d5df984f9ef6e21d697fbfaea836054007434b887246161e5a2bc2cd54a6961ce8fdb42e7c1665ad8e6bd7a8b8d07b01222dff70d430863c3e82bea6d73d7cc5eb775f2c2c71bfc522fb2576a3f5e8fd5add558dd5d2278670b79d0c76de6da20e09567cf06083ead7ae35655cb6814ffd2d276188c940dde7b0c1fa5829ad122df66704952469bbc454dd982562cbfc87fbe41995ffb9eb6c3d8955e2694abd6f7c33191f6f3b5661d001775bfed9cd33fc951a2511600119709df28bca5b8e7442b916a457cffb167fb61d326cb243a80a1da938469953988e32cee3efc04cd01a7825cb4c77b1d723696b0bae416fdfb61426400fd53db152572d664270c31599b9be22304ebed4efaf5839ae92c83847ae36d4230e751bae12888350653be15b4caf28b986c848aedf15151659de0078d3c5b440818c9a2a8db641539b1afa43ac90d1d44b82ebb341b361db67a5c08c253bec922551a9b963cef2c716235c6185fc239c5fde4f48aacaddc6856c89cc0f0beadd1ca030c358e52ff9181db57c1f9b5175bc706fb3f4567bf9f622a6b2995a333b2a9a6cc3332c8743f6d10c4dca4750f48ed190f5cf87a9624ba0233319f178f99cd9cb6ef28994585497d32c3e07855bc9f720fa0581a911736c05e63917fd9312c445b638fe8041b52ce8fda4d180f3d8bcf0b78db6bfcb440d70280c96b94e633bb060878d4df9b54d4874c5f551d3d4ddb5cd2b5ee52463751f55b6712ebef8842b34f369ba20c6dc49ce1e5dab1055e1a0d7d4cb2eae14877896fdc4250b2071b4f0360e99b85815c8966eb0f3d0d784d961b52ebc6da8616586835b2d7fdec593afe2273a147bf382158a01a5b875b59c8dfd1a96120afa09f921e5b45b597c33f471faee24224a7763c0e9dc4aa3a172d643b77b1367889d881bb2ac3eb233039b7e3710ea12c97213855acbcaad38bd16fa5740c90ac17c32bfdcfa32c82f3c3ee7c8e67871048e6e64ef7e0f3bae7da0d584a2008335f9e49f9944f324d7faa273ace531e8d13c5b2be4067c8fbd5ee1a4e026c190e60c18fb707dcafd2a4adf109493c91c550a115bf61fbc4bc63814ff86da575b65a85f79d87013689eac42b5e7a5166f6ea72dc73cfe86ae1a7fa59f026d5df95ebb5a8a4b2fdcf7198ad003f2f93ade248e45caf2761240b64bb7abbbc78cf7aa6eb95d5bf754dd5d41312132744e7e0f5895e81a69233d7174d3cbb4c9f89f1c35d4ee2885707d4d04532e74fbe4a43d8bcf1b0260daf13b9f0c2e8979f79a1f175b11e24a42d9554a44ffe6e4af3050183baa782f05634d4614cdccabef7ab8c7a0e823a08823bfe62c7746cd7d37aa09d9a1417acc4a68521324cd2113ee3c99ee7180b749b336b331354beba86486fd44e95f3584cd700e531f800f2130a3cfc23eeeb995dd0b11a00985b2d07e19cf9f75fe0f4554ff306a2a6e1b5764d2108ef8e78c4211def457da92a64b8a2909d2356ac05ed359a0961607ec1e9067b4893a1d2838da33af3ca987bd5bf7bf17e0a3dbc300fa2abc1ea16e222475e04599267a1fb746184ba4faf44773277ad7670c69d9b57b493c7964adb5248935e0928548b66b21b8249e2a14c288b233b702615dde9ebeeb7a02f740afe77f63af4c3b71624c470d19cccd7c0d4912afead655f87efcce4dbb1e30b07a5faec20b97e7af5f035b2f42eabaab476a9d7dc91c14b756eab201963c995571807ffbf03d8cda31a2647252c4fb838cbfc8995b9b1cc4acd79d1828dd1159a4162695d95b0cfaa3f546f77082d48cb40a908d2ac124347cd5a18be125251b72dfdae9e9f6f77ddbd77e6fa1ec8416e2adc9da754e3d60be18848a09dcc85eea5442c73989aaac5b6b5b3860a31a781ffd8e8bed7d8a72425c93b6b6ca741b0dc1a1bc36a4aa69dccf9af1be70889f32cf626d0066deaf3b736ef9e2f2c6a994614434469fcddfbbc7fce4e3d1bc4787a6c18fea55c3d917d11e98d9834099246c648662c0be2ea5fffdcfa63d401a32df5734d7be14fef8e470670ea02abca700bf7814402f811dea8197101dfe33532cd01dbc7f84ed05a7ad3000d12f8ac39232eb70665f4fb35ce49cd3f9416d454c8675c51c12511f42df62c4123ed838783ec35b65c262a70c158479a8847329728ae853476636a821669464a6f722b5cf19387791511721fd3655ff7e6448afc4706b4288c74414660299eb922966750626b8ae7303a8a867199228f586d21d731c80f41aeb796ce5a08afc9ade643e5b066b6e8465dfbc9983624304593742beb4a25de83630617332e4c5869ee39f6f6f3e1e1a3ad25fd832f60a0c406ba8b1b646fcf6da9545d2c9520eb4f1151687d7a7a899b21a25766b22e7280c5642e5057e539b1fc21193e9081316b741f9995a9e5b59cefdc02dbe475ce877c1d824407a933ef3d7f9429218f2bd1b9c7e6da808c3b1331dc0e704c58253554a981b748008fac9c18bf3bf3c2edabbde54649f1345ba1f7a0fc46e1bd407db6a24952b7555a6435543c14f797107ad36b95550d147b16465a11cfd584066c71d6e9808ce004934f32a91991ec70bb552cd91c9268ffc0bce97a93e2b8dd9f8b34534c2b631148b87647ae1b2f5cc39cd9e490d5a21fe7d48a91d1c65a2c97da1cebcbd23968495760865b9102b5753740f2e1f7f83e36ff2c9d6368b87041a79637ac3c4522adeae40f5d685db6527240ecb4e8d7163fcd1b908e2791c07da0d9655cef73158f110be7b74c097f4b201c70d9e33ff0fe4bc4c1829ea34d596437c015455af13502bfcff31dda65d81f54169e1ca4c1128f137686001ada222cd73296f63ed8fe61f66766f68730828f66f8c1b555a31d058c5958ef11a0796f9127c90c8a836efdbce6a13b98aef8f27dd5a20594c167c5470239f844acfd136dfa4179fe89027918b1da1d4a66c022e7270c25669f8630601405633387ffdfda83661dd500d25679fbf0662208dd555c4821818373da376bf754820877206aa3ea38c3b58670cc8e7d4d5c8fbd27279f1de3196d1d532338ac4edab829042a6ece5b7a1cc351320fd9211eb0d41cbd5effa86cd29787b516f0afebf1a39444549459ff3ddecaff4307f5843b021c6eea27ca4da4f0ac217d60d053c4b4ce34f57427d0971611e7c34b9c735ef38c424eb1b5da6db6e61f6ee3d7f7b658f3fd9e4852121d0e6bd1b1b1606b9c7baa6c6258b984d4bc90e3899d17345983064b1fb6a503a45eb486bfe025ff1b8300e8cb9c13a824fe1a4c882472c81f574da98627af47b1d950018a78db7015379a7ec20367d76384edf42308732d256ccfa2925bd731fcdbd396a6491dfb637dd8e03bcec192a86574d6f2295f16764f0c4be57359f8a7b6469e4fe59f3a72f67aa528496e01fb0cc6080382c06179614c84079b601cfdfd90bdf361ad41ff6095c3d1f487f8bd01b7a302afc1eaaca09d990dfb7436f9cf936bfd159a87053b5f29a85028c645d51c724e265ed4297894422cfeb0213097f04592925d22ea7786fecc270345e2e6efe8d33031e7cdf7738546f4c5456570d3e50ba67a1c702aa4f9f67f97eb0315d94be86ac5ee2381a7b5606e15ff3f081a1f412a7037b46f9913ddb41b0f44fe2607273a9e1c3a0c5a20461ab66f6687f06ce4da9df92fa70d0a33242d6c6bb7fdce4eb469d070668fc19fedbae758ba93f057c04e75ea33995968050bb4ff8c13f0a224696136d9f09a512eddb5a0ab06bebec79bb9e465d5130c996a541f0568f5c3a5709c800c0263c5941f78623b0a11bcf77299c073e67d6557053c4ad8374a5fdcf6393be5599f8249201ba92eac7fcde64498616886ed8c683e366a038bacb27d043cd6caa0cd69769d1bb3b9bb6c8c84fe5471791c24f943df753802cf3a687ccec31146ca0040ac792d1c4a5438e88b5b0aad85fb8b1adfc0ed2c868dff2e823098e55fadd94777e01f878fbfa793ba72dfd6181d6888ffb05f077eddbb3fb5dfeb3eb859a5072949b810249442463ac775af1a1f2ba05bfc431302efcd5cd1e920cbd10368a60e5e74adf311f78e35104196d193ed33a814515e7e400cdcda2e904c1e1d28a2631473725c93b2cdcd1f7ee5c7e019a0f20c753f4dc36c61f9da297b4c32d9bffd9eeae503ff4a4a0f0a8868493fc8aceb36825853b66a57bb5ee30a3228a1d7347d57b73f161ba428463ac53a4f387845f14e5855c9d85a51addcb65b6f950bef2b9a302791cea740a8e733a849c15e8394e65f57cd3c2967595c9bbe3c93be63b4da40c625cd88cc6660d923167ae7124f05c2552995048a1d6f8c437d9553705166a3fd0e2cd69bfc4f4c87aa0f637fd759f749e94760d70cf58f969e0df4c0eca8a7e92a21c912a2abc63659d0af083f37372648178b42c1ec0e970c724a7ede62d04136e80f7efebda822d0bb0df435856c513230ff30beab8b02189c61c4f814748f22b02a4ee7eeb48f2590f571f004212ab54f9af31ab1b8e050869b41e1049bd4843cdb996909781b833c369fd4641eaf6b7608e0954dc667c0eff6e80eff9eae7ad2e62b110880f9d4853570184e2f156f7ba5a66f7164a89c82bd6e8bc11619325f08a9b5833029505a6c12dc54dd9a473cad436ca8b92618754111761c01cb1954b0593f5bd828a695d89918c317fda9fc8e9b9a8e58ba404473f779bced739d816d1b95c8341332fb6286c09bdf5a63e8a9911f9bb55f06af8fbfe44f2373d2993021d9bdb5c235f2841dbed9683ad5e395d4f00f5f2679316d8401183e9f15ac14bc79bc5627636b38d68f73b761e79f84a4adf60a96bd4165aa94bd64145107f034450719c2c821d637fff493ec0935cde30f15982ace426dae42446a13703ac1cf1439d559b580ed192d55fd7eeb75a8aba8fff63a1afe1b54c4381c1ff4db383f1d9896e59739b7acddbc8c78c59d35a8832b58ede3af6b03fd1a0e3e6644c61c85861e661c4d1e383139036bf9c1e004cc05fbba76746a3761b04d854aa01e58aae8a3c10f4c8c4345e2008f90358341f8b192096a90c6641637d346c5fc17a7b18b213d123e2612d6aeace41ff31496c3ab98c1b969e2516775ff307cda9dfad1008e5980732595b069142c50a00f5add9e77ac9a780166901f8265260a50188103f25611efb6739d9282beaf6e5f4acdae828cf9f4bdbc187f77b9555214d7416867240712d4a27a9fd72a9ff93f7f36f2c9a019d731c70146f06ffc87d35c6322b33afcc37c49f9def9b4f7a4d0876e9dc16bc76a3c94f648070922ea894943e9a17cba3fe3d17a2ce29edf2fe106307fb02d5ab9592a9fde3a27721e11b0c63289e53ff2438982786500e73fa5243e61ab02154a41b6553ee83e4186a68c4cf39e687672cf969e4663a2ac2e0cd37fdc54381214fb05316559f9be0b17180fe70c31543dfc417c20551827bdfe22014441ed8f2dc9165119d4e1c86b753234bc455b67afd2c71454d65009c28f78a0948375abe930b894d7ecfee49d79a1d90efc6df4b62bde7914334feee82b0dba072a50996bf086a76fbce89cdd21be0674b49e036cbb07143a3c43698e35d87758d266121ef331aa08af23789f7d66a26a6c31491ca6a61ffa00ebd7286fc3efdde3c18ad835826ef27a2b16cad524713027e80df315ab48d19f285f959464bd4a3919ae8086236121d4f47f0e6a3f3087da578e184dcd47203a17918595485bd217894923c771a56f49eb473a015c1f373d6065ed4e68095272e77e786d42fed0cf9cb68c0d0fbfa8a7d4f2d0d88c530e27cdecda63dfb3642ba1e1b5ab438f8e6d443b8662f4094de8d3ea5fb241f57d38f587e61dd587f1f00cceb4921371736c13fdbcfe0784bfb39ca991bf7b9e2fc58c7a99704f471d585f566b34fcd2cf02e0ebdebc9056e0c2ca03d0b09f813218dfb3d8e38e10da8ee70ca0f9ae0280ae6d85c0a86b059f7f9a8e18930420a2732b9446277fb3b35d9504b031527785df6103a00142c5220d2f8f6be959a6b4fef715fb71dacf50c1258a6d613ed830543ce70f0f283c7bb3be83424f78c6b8d2f96787628d325eaa5011d29972f20a13f1328cb8e12553334d9ec54721ac15a24fc1cc4e3bd928817140414ba1bed6a5699de1917ce2a0a120be2744983efe74da14d2539e91f0ce5605aa3dd506c2c38888f016271e0e6b166c60da09407f785f300b3bfdd9166c452efaff25654e6c21215109795e74817dfaa30162cb7638ffdf3d0d993abd82e63772e27a49ecf448e7baa71845f5e6595e447e97eb64c7c6ee84ae4f2225d84519d14809f3323f23e48fe3bd1972b6b1c8585eaafeaf7ad42779837e79d9bf4803d2a4605f7f448987fcf8cbe140376664ed84707dc7ed98e164d28ff16efa2a16d28af5b57481759c2cf38d17f3f0aa4fddf570146a2f8901ee4da2a848b97d1bde4f22a137fa9c8a63db5abd149d7c0b2730c4130b75d0c3be6170a95c19f91b0a0f6953702326b78cd94cddf052aa605073d815c73ad5fe7f56f9f872ee59c6b5d3c2c6dfc457615547014ff806fbd6c8b0ca81305f68852b070dbf432bc5a4a26d5601f5afd4cae0ce3824c39f42237c27e971eb033a534f366c03ba56d80fa1ec18f8a564b7a2adb84b82c48d66276991246f470f09c6fc9ff5c6d650d266631b619a7b82b6471b2200cab0f</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="无" scheme="https://unit-serow.github.io/tags/%E6%97%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-10</title>
    <link href="https://unit-serow.github.io/2020/03/22/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-10/"/>
    <id>https://unit-serow.github.io/2020/03/22/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-10/</id>
    <published>2020-03-21T18:58:59.000Z</published>
    <updated>2020-03-21T19:04:25.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 22 2020 03:04:31 GMT+0800 (中国标准时间) --><center><strong>数据类型-数组类型&指针类型</strong></center><a id="more"></a><h2 id="数据类型-10"><a href="#数据类型-10" class="headerlink" title="数据类型-10"></a>数据类型-10</h2><hr><h2 id="数组-amp-指针"><a href="#数组-amp-指针" class="headerlink" title="数组&amp;指针"></a>数组&amp;指针</h2><p><strong>相关内容:</strong></p><ul><li>static关键字</li><li>一元运算符: <code>&amp;</code>，<code>*</code></li><li>数组基础概念刨析(泛用概念之一)</li><li>指针，指针和数组的关系</li><li>函数对于数组的处理</li><li>二维数组~多维数组</li></ul><p><strong>相关介绍:</strong></p><ul><li>当在当前程序中需要处理大量相关数据时，通常使用数组能高效便捷地处理这种数据</li><li>同时可以函数把模块化编程的优势应用到数组，并且数组与指针的关系非常密切</li></ul><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组-基本概念"><a href="#数组-基本概念" class="headerlink" title="数组-基本概念"></a>数组-基本概念</h3><p><strong>概述:</strong></p><ul><li><p>数组由数据类型相同的一系列元素组成</p><blockquote><p>需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型<br>编译器根据这些信息正确地创建数组<br>普通变量可以使用的类型，数组元素都可以用</p></blockquote></li><li><p>通常情况下，使用方括号([])来表明数组，方括号中的数字表明数组中的元素个数，方括号前则为对数组的命名，即为内存标识符</p><blockquote><p>要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素<br>数组元素的编号从0开始，所以xxx[0]表示xxx数组的第1个元素</p></blockquote></li></ul><hr><p><strong>关于初始化数组:</strong></p><ul><li><p>数组通常被用来储存程序需要的数据</p><blockquote><p>例如一个内含12个整数元素的 数组可以储存12个月的天数<br>在这种情况下，在程序一开始就初始化数组比较好</p></blockquote></li><li><p>只储存单个值的变量有时也称为标量变量(scalar variable)</p><blockquote><p>初始化这种变量即为给变量赋值，将右值通过赋值符号赋给左值</p></blockquote></li><li><p>ANSI C 初始化数组的基本语法:</p><blockquote><p><code>int unit[7] = {1,2,3,4,5,6,7,}</code></p></blockquote></li><li><p>用以逗号分隔的值列表(用花括号括起来)来初始化数组， 各值之间用逗号分隔</p><blockquote><p>在逗号和值之间可以使用空格<br>根据上面的初始化， 把1赋给数组的首元素(powers[0])，以此类推<br>不支持ANSI的编译器会把这种形式的初始化识别为语法错误<br>在数组声明前加上关键字static可解决此问题</p></blockquote></li><li><p>还可以给数组内的存储容量，也就是放括号内的数组用#define设置为符号常量</p><blockquote><p>比如: #define serow 10~int unit[serow] = {1,2,3,4…,10};<br>如果要需要将10换一个其它的字符，子需要修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方</p></blockquote></li><li><p>关于使用const声明数组</p><blockquote><p>有时需要把数组设置为只读<br>这样，程序只能从数组中检索值，不能把新值写入数组<br>要创建只读数组，应该用const声明和初始化数组<br>因此可以将其写为: const int unit[serow] = {1,2,3,4…,10};</p></blockquote></li><li><p>这样修改后，程序在运行过程中就不能修改该数组中的内容</p><blockquote><p>和普通变量一样，应该使用声明来初始化const数据<br>因为一旦声明为const，便不能再给它赋值<br>明确了这一点，就可以在其它的代码块中使用const了</p></blockquote></li></ul><p><strong>关于初始化数组失败:</strong></p><ul><li>使用数组前必须先初始化它<blockquote><p>与普通变量类似，在使用数组元素之前， 必须先给它们赋初值<br>因为编译器使用的值是内存相应位置上的现有值</p></blockquote></li></ul><p><strong>关于存储类别警告:</strong></p><ul><li><p>数组和其他变量类似，可以把数组创建成不同的存储类别(storageclass)</p><blockquote><p>关于存储类别的相关内容这里不做过多赘述<br>多数的数组都属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static<br>多数的变量和数组都是自动存储类别</p></blockquote></li><li><p>不同的存储类别有不同的属性，除此之外还有其它的存储类别</p><blockquote><p>对于一些其它存储类别的变量和数组，如果在声明时未初始化<br>编译器会自动把它们的值设置为0</p></blockquote></li></ul><p><strong>关于初始化列表中的项数应与数组的大小不一致问题:</strong></p><ul><li><p>假如有此种情况: #define SIZE 4~int some_data[SIZE] = {1,2};</p><blockquote><p>当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0<br>也就是说，如果不初始化数组， 数组元素和未初始化的普通变量一样，其中储存的都是垃圾值<br>但是，如果部分初始化数组，剩余的元素就会被初始化为0<br>如果初始化列表的项数多于数组元素个数，编译器则会将其视为错误</p></blockquote></li><li><p>同时还可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数</p><blockquote><p>类似于: <code>int days[] = {1,2,3,4};</code><br>使用此类方法时要注意以下两点<br>如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小<br>整个数组的大小除以单个元素的 大小就是数组元素的个数</p></blockquote></li><li><p>这里写一个程序用作示例:</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">int</span> days[] = &#123; <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span> &#125;;</span><br><span class="line"><span class="built_in">int</span> index;</span><br><span class="line"><span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; sizeof days / sizeof days[<span class="number">0</span>]; index++)</span><br><span class="line">printf(<span class="string">"Month %2 has %d days.\n"</span>, index + <span class="number">1</span>, days[index]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关于该程序需要注意以下两点:</p><blockquote><p>如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小<br>注意for循环中的测试条件<br>由于人工计算容易出错，所以让计算机来计算数组的大小<br>sizeof运算符给出它的运算对象的大小(以字节为单 位)<br>所以sizeof days是整个数组的大小(以字节为单位)，sizeof day[0]是数组中一个元素的大小(以字节为单位)<br>整个数组的大小除以单个元素的大小就是数组元素的个数</p></blockquote></li><li><p>下面是该程序的输出:</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Month <span class="number">1</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">2</span> has <span class="number">28</span> days.</span><br><span class="line">Month <span class="number">3</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">4</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">5</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">6</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">7</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">8</span> has <span class="number">31</span> days.</span><br><span class="line">Month <span class="number">9</span> has <span class="number">30</span> days.</span><br><span class="line">Month <span class="number">10</span> has <span class="number">31</span> days.</span><br></pre></td></tr></table></figure><ul><li><p>这里1的本意是防止初始化值的个数超过数组的大小，让程序找出数组大小</p><blockquote><p>程序中初始化时用了10个值，结果就只打印了10个值<br>这就是自动计数的弊端，即为无法察觉初始化列表中的项数有误</p></blockquote></li><li><p>还有一种初始化数组的方法，但这种方法仅限于初始化字符数组</p><blockquote><p>这里先不做过多赘述</p></blockquote></li><li><p>所谓的初始化，用一种不是太严谨的方法来描述的话就是给其变量赋值，只不过是第一次对其赋值</p></li></ul><hr><p><strong>关于指定初始化器/C 99:</strong></p><ul><li><p>C99 增加了一个新特性: 指定初始化器(designated initializer)</p><blockquote><p>利用该特性可以初始化指定的数组元素<br>例如，只初始化数组中的最后一个元素<br>对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素， 才能初始化它:<br><code>int arr[6] = {0,0,0,0,0,212}; // 传统的语法</code><br>而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素:<br><code>int arr[6] = {[5] = 212}; // 把arr[5]初始化为212</code><br>对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0</p></blockquote></li><li><p>以此程序进行示例说明:</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define MONTHS <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> days[MONTHS] = &#123; <span class="number">31</span>, <span class="number">28</span>, [<span class="number">4</span>] = <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, [<span class="number">1</span>] = <span class="number">29</span>&#125;;</span><br><span class="line"><span class="built_in">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MONTHS; i++)</span><br><span class="line">printf(<span class="string">"%2d %d\n"</span>, i + <span class="number">1</span>, days[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>待补充</strong></p><hr><ul><li>数组类型前面关于数据类型的文章有所提及</li><li>关于 C 数组&amp;指针在后面的文章内会进行补充性质的刨析(尤其是针对于指针)</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 22 2020 03:04:31 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-数组类型&amp;指针类型&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-22</title>
    <link href="https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22/"/>
    <id>https://unit-serow.github.io/2020/03/22/%E9%9A%8F%E7%AC%94-2020-03-22/</id>
    <published>2020-03-21T17:09:21.000Z</published>
    <updated>2020-03-21T19:00:37.305Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5901854c92694570f2c17f4387ad308db1fd2fd638ab71f2a7d013872b3ce44f">0267ec72f19b8c198697a4f72870a3a8e079571dd153910a3b8a7777eb6dc1ea0140923101c5c0487ad36a9e39aca996fe27db1957163ef65ef4afe1a4b89bfd3bbfa7ae8b7cbb16bfac8de89a46bf587962bdcbd80f5c3989c02913230c85a5050ae5227b97027ec35f608451f3ece6f5af1641572480b9cbd29ac1f41d39a29e87d6604a405b28c895485029553fb9adec877363b89be9a534b1e4518bdde63f9b70d366443adf07a78b56402ababca54a6f089424771e782ac0763957ff2fb4d7d114d0c63746dc05f77b23f8638ab2f3e9f78aa365978630379793b4bd2350e35e6240a51b1c46732605deb2979d5dcac481a56194a4025e5413f87acdf3f0b22d03be32c50fce6dd1d7a19eb0f20d45326b0928a30fd240e9269716153a77a525ff66e0088cb6bfcc3e188e7876998170325d15d767262de6bcbec0cc6ad262fda638eb44258b59a8e280d7de1d561f187f96415f80ee0a67e813407677ed400c57fcd8f65a0223b3a5d7cf2d1b798031c9a9f1db358feaed16783b4ed468d44aa086fa86e21d9b36b04967c94c09a5328f584398a951992ccbf4b4ba12d2c5103c2bcceec58d23d2d3ae295023cd12ae509867b7899aa86689c2cd430fcc913d2f9295763e095713d0b8119e0331c74c2c7c001584062cda36cb2ca163404f5e38ae3fd532d90572da679c477a2d2744669beedc1f1b1f269a316ee76819619a4316d336fc1747c118666af2035a63b542f207216747e6db1ff4361e6d6071136fb300331891c8ae46e6f2293cb638ccee172d94cfe840b35c23ba3ab360c5768dd26a84855b33535de4355f14b9a839621e0abab1206b62858d3348d62aaa7e71c2caee774303940d9ae0bb5bde410bcc5e90252fc2fb2aebf4ad8bd9ab3addd3a3b73335efad7e3f90ec6fc04cda21441a344c171d90c058c034168a975c5dbfe2a3dd11b89df0c60d55ca6e521260b1670f65ffb15b7a22a7c0b48180592e9b9c09ed6225282726300c2dcfa272802b7bf84121af4c90853fb35d0c3d24d08189861b16e2e2933b13b1f4b1264e0089565095c955cc01e084d63e2d70824ab084fc194b3b157fb66e251d312ca902f3a4c000430665dcddbe177223842351f2257966bcd9560ee43599b49f284f0bf6b6f292a397c8f68e79b5871034baa3f791b66928c7b704bb94cbdfefd32c1c2ae84e88c9c02684f5ce7e24fe878823b8f04341792bf3ab719fb8df90142496be6a86e273f4cefe84a53c0dfc7e67be685899de451104a1ed9c3e4c019d7747edfb8621b3d8b12fb71a2cc715bda750d78899dd8cacaf5db14b569f3792eea430549a7a8498ba951250f35035252e10189a2192130eb0043a4c7f336c2d2aa6a6d002dba234f58047dcbbd5d3ae0bda263fa3414a018963ca56d311cf689918bbbd5f4941b75595160cd7dadae5573074dbbe2b5ca74a8151b8274963fc05d12609d31071b00c9e7f153cc279b8634c0fe2f9a6eeb8ef771e829b55ddb94cd5a8ae8c2c75fc553df59b59c1120574361cb893436b70740fefb8ab43ad17dd87a3ece0e4c8eef279b9f3aaeb034bfedb86b2fa8f4cba6431712d260c59b824fd6dd3265062cac936c165cab4713c3581b08255172202e761f2ceccddb909a2f9930c566c866f04c4eacbcd3bb2fee375f8db7e24908b7a8a1e56f431dcb6d61785e3077916b085841deee630fe1f8344de2ec9f82629241044f2a051bb331698761eef7695485c49b3a87ff7137e602dd03b084675864575f0824b25b7aeefff4804476e1e323043b4fdda631a8ba3229fe0377ae48fc47c2c1ed9961ad2b9a9ee13e2fa8af98274a9d2a8d6ee1f90cfcf59e6f2257c1f53e0b8bb7232522c923cf4eaddaa98a7f0f0f972a23a44b4305906e60cfb514d4b80185d302afced7a645a27a4ae3178bf909f359c9af267b2e1a4dfafc2bf43af3a4edbb11061b1fbdab40c999905a8e599f3a3ba4b785e4690bf7b19af24181f82779b0b20f17a4614778fc17656727eac4c210f372e0372def226279b8e686fac4ac9e6b7b3bfbca50d85923a39bec79a4668dc75b3def95a7c20b142320269a02f5dc5a1dc6ea92abdd5106f451f76a03418f5d90f51d37988a07b7621465ccafc47a9503bae46b460336059e00165d515d07996f30368ed5bff667aaa2cd06c8c1a763332eed66821ca783fe0dab44a505ff99c2707ac437c730266619ab703ce58681642171dac8720f40c448f774aba3c3e4b3e813103cdae3c2f139868befb0a1cca851e6f4802e5bc37d9b003761d4a6f5ec5a65f883376cfb437b494c180baa7b657cf5809a336217e2170a74f3e8f77dfae63b3f7f6edd30b1a10bf71459cf0056c6459f2279ba9d61b469d5b99631b0a74fa765a9b4f02d3ade81f6c48bd2fa6f96d364a1bfe5129cd7f3edef79fd500da64bafdc05a78380c916970fd99ecdd5afc96615329cc9507e878372fe97be5a609adf89545c56a3c72c1077f6853fc92be81d692e3a6b099f23173efdcf89f82979ac07deb869a0b9f9d5eeabd38f7a786514d8cb6d1012fcf02f02d25432416903034ce105b3139c7a7bf99f23ec8fb1fb63505581f21ddc295741e433ad502052f6186f37a948587f55f264e5c7f6413b4e6dd6612898639209d9269e60295b4a3f37f519d93e61840a654c54b45427ddadf81dde0ca8133d6dc87610bc186a2bcb69225de2e3ff2103af6c7961d485648fe5b83f30b2830e9833d632e8c079994367cfa1875f8af41246af31b4d49a0627ae40a1c0c1baddc1b745eeec0f6e9b98f7fa095125c3ecb3df2d597013e6e335222c6e31de9bafaf222bdd548b221403710085fa06ff881423c10aff43a2f56e9581ab92a00636b71e2ea7b12caef9a884e2b41e5e79b15c6300604871ffd8fbc3e4f17b642707b0bf06a76b542f97a8e9f42fae94f3bb6efd02111f114b056f8d59f6dabaa88a944755a478520004c68c30a6b522b39fe2a5708264cf7e6f059d02bbc64d1188a021807d74eaf89b241a13c2eafc9eaac717aac458d376cae34d74b6ff3e1bdf21f75eb9f3194c8088437e18edce7bd162b7b77a654f0e2617aa2a0ccba3cfd2b26525933b6b4d46696bfa0e34becb7c7d5cb6f02d77ccae3bee5a89894fad8fbc4de4c302f917e4be9f6dc111b8d6b3bb2cba75e8ca5b660e752a3837124d7b91efe2f40a51913f00224d120263043456f84f2132c0e479b2f810ab06a416542238d4ce1039ac4fb3beb035de4c38c50b72e6a09287739d88616d38c830131c0b8d854bb3a8334173b8e2b5c89207ddcf80c98570b828ecd8c9f2071b47f838df8e4d514415a00e8bab7cbb99092c49e2b795894c9e32bb5b4c786f736b10d54fbbb17c6a2ba63baa29bfc8693cd1a2154816fc19c1880720d8817efdb30a3faed5a5a5d2b590302e5fa3e77d3e504d3bd16a255fbe15a168caee193993eb79b4caf13cd9ed4feaa131b4fbcf3dd7507e7d3f4e49cc3a2151fcd4df42ed51538af80fe48f42a3ca1eb5888744809f39dbaa352678adef6bc1d6c4765b8ba9f6a85267026730dc792d43d83b0a92b07e3f4b874a840ada58fc219283bcfa2b5bfb72c901d7f90f7c79ddd8f31b3a02838f2fcc2225e16e27ac6c642badf3b6aa8b3a0d210b1d3f2f2c6f9c3bfca9eb95ec42799555d396541945517c4f6f9accec2639f77c6aeb60e10a79ffd31232e51540096df2abe8c971cf1ced733bcfba9268ce3343de52fd362d9b5957ffaa45c31dd9e4b542af21bcd01f3324e8accdaeaa84575ed3b3e2b532a5a527c0775a12f28568f281555f9edcb9ff6f5cfe224b5c0d6d9a689434116f29156caba68b4dcc4df97cc1f1643ec470424a88d20c621df2950839440258bc111bc66f5db73f06adce8bc65e4068cf477926f8326b7eccfc3b0b2f79b5ccb00e0077e12d29f0579342086fd6918de60b1f62b947a06af1ff09a9b9c47e02388e6873c116eaaae0a80be1069a07353ea713691c72120ced0458c652a8775e3d70ef8ff2fdc22dace1b93d89be1fac235f0698800f811419e78285e13eb22174cfb22dca6ebfdd2b38c7de60bcdc85f63bd49ffd7248f7380536e86ab6a36daeb9066f3ff8d873fce52370d8368639588777fa211d41038a1b6c9a9845c1288812fb0be13a1ea7f07320f1341a7721a98ce7f635adef4da14e47afafea3d66b12764a3c3390bca18136cb3a042f00260361684028cf514ddd755e07233455562ddbd40ad48793327a8f5bb6dbe15073d01e3220e0efb4762ae4cded7967b807626234da01f594911cad21ef8882f427559539dbe1eb5f26406bcc092f6c49c96bb143563a67df6e97bba8becd297b11314d02aad1fc42255e4da633b7c3ff89addf53993dbcd9c854fcd209c4ac908434a1a2c1736864fa3e7543b9e78d2865769cab280d41f00efd931be1af915a1aacb6ab0619c6726a81cfb79120f89f2b22891f12fc21a1f3b104ee7ee066219e556b69f26842ac4b6a35e71f64fd08bb5038bed9d274494c278c549e6a62e19a439a45a0c3bb4d9abd5000a5dc9377e1d9f7e689bed714913ab92cd143423fee5324b553a00cc2d9dc08eaba4c38853f491a0b730afdafb30d3e85a0a54cfa34357888a434d8534d3c677bdd895850b0718d10260044e9ebc1ab909f6880490e65d3141f34512e10b19e0cb75611b6bf9e9a2b3be61c17bbd955c4f88af041ccc3d6dcde3758a897de871d1c823f2233f68b2f4969da64376dab38a24b8864f0c115faa547f407ff19916dd56149c651b01debfdee428b1cc99ec91c8616caebe3b46c03b43f1646f3ef85ce4ad581499d2afa7b2dc94f28bb6025342d31115cd2dd23566e96586768b689b418f77c17203fcce9d492a3240e2ee946fbc305ef768f39d2ec399aa7daf18910b8037c84396958a1ecf2c3585f6da178eca25193689f5678dabbfc6b8dc0702d97500bd8033e4e57a1356c33c418b861abdbd22ae85b42a555f5cf771ee4c046f9319c22a3a8a0ee3bb8e5bd14cc8f47f8434c73c8eebdc144e11fec13f3d445afe3f250e87f888901a9076e625a90f1fa64602d10eb670a86d1f73d263725301efc4096017f7d6ade1419560dd6a58c5337b96ea3abef5dea1b588f7ad906086c61c59a8f241b6b52b54515ac69abc6f2e2cecd9de993555662d69099f28676d354a45f4a5d8eaefdedc5a2b5b894812bfc9da36b31db23b80ebb6a7fb1961f8035a2259ad7639e4bc5152857fa8a016b7c22cced6e640a8b5b3afeaa36df8518a0e86e94cc061d84e021e0a273f60a57e29c54bb6225ecbcb2f51999241e48bf37ab4382b272ff9693de2934cb356e66dc49c81457352f619444f3d54c2bd8b9cd8757ad1b6ac21dd1b901bc79fa43d584a2cb899d29e6b8fe9798a20e2cc857251f6947d3b9c0e59eddb7b1c4991fd0a10509972be458f7d0313907bddf700755faaa18f083343837d7ee11db91daeae795a20118388585c912f1d4f10188c417f233e52e0ce3690c0b5b8c30d7c1eca2142b954d39f25fbd00d698061d72c1710f4d5468c586e4eb0769c0e313d945ad76f3a1efc843fd71b283e17d1828f794eea8be534ccd05e60590c390623511ea666bf8d291b84ae62e0c479de8a25e462ceb62cac2ac7538e2c0f831bd03997c41297837ff713239d207fe4c7f05f6bfc59566e4cb39247e9272699ed356aa4f69eba37dbf016f973e74a4a6ddaaff4949c1b746cb3f30ff684b601980308483b1be064d04805f3bd07b3472bcd596d929031e80080a3180280fc5648ffc98141b78b5ad5bb9efd9d6d5b7ab8a1c9a3ffb49c42d1b0add69f513358682c836f0bb8eb1b3e5aecf645a2da83c958949222c25343b832b9cb943266076a67093077e4b5234e4d34bf4cfe693f3dfd33d6a7e4c2b4c029ea620a8e692b4e77e1801ffba5056595ce9927a875ff70fe721c1d577e71d3102e55be6569fa5a8f1242665b7b44030e110288f882cb30966de3fa4fd781e3305d592c2ab8a398d30ad460cc535d35b3293c4693245199298008a1e98ae6a764c60637d27ff5e0e148d9e9417b344c218e314678b26fe887fdb1f346cde28bc705da9b9aa1e71330988ef7af8d8a55855523a1a9328aa8ea107e1da8413b9e1bf040c4acefb322f648d967c2beb73e4f4e135327273ddd7d94a8fb4e74f5b329f4c5eae9cc0b66cb1a197ad50f3779420b548e2f6368b9e9bb474c14b9f7e7f8a79aefe6afb7073a64f18ee269ec85712d6482ace825e5ac2afa6383bc35fe985c6edbf07485c7fcc1deb6b6a3f0554274b0367b8762f9ab226030dcf40f8d30e8747338e5caf9e1ff0da8d8b4a34fb3bc9cf2dfc39987d62baef31527e0335c804a16bed87a5b500f7b0b7d7c32f64491e2313f4333804d93b7c1e523455e53b6e3fb2fcfacaa63a779f7ebf3b2332e6f2534e0b3a2ff4ee0788a8dffa14f5ba48301157fb4b6af4ee37974035f511860a9d6ac5d0375188d84d2ecf38bfa527755eb31c9bda0c1f27cac78cc14f30c39ccbb6c6a9cca1e40e734c4d2a4a20b0997bd883adb0b1de9d0d068da5b174d2bb2dbc76fa831abebbee55d1af378498a836708a8ea42edc07b2ec38b777781ef352251d3ef6fccd17547009a2f151dcbae32e009e3bd2139c5644581f37aa668b58b70b2bbd043b9508fdb0cccc838fa43c52d16d57bfeb0ed7d312f266bbd9d769f7dcef5d33ae665c29160fe812d2f54d34d92cd331e5bd68b3ccdb7f45d1242ec99838d954a4f6544a10f941eff010ca6763d66796da02009030add5ea9e0011ace6b8d962a7965e25e745f92838f3cc391afa0d290c19cc25ba5f6df4cd65193a20b1c538eb2fed5ae92713f966d7a4915b26f107ce3f2caa9de5136cf8f420d3f2d6fb456456e42ef4d1aa400deab68e646074cf0d1b5350c530d4422733f9c0e324636bd8a0e3f28d66e0511531c4248a52e4c2f26053f584ce8cfa3527a434e0e881fe62846fe46fca9faf392eeffedae678f3a0531220ff007009e6885380fa744392f6d3abfc7645e7d7f31575276ca7e9fb460d706273d4a3aa596d0b2f908de49bd6505e46966e6ef2856c86fd9adb1fd682e2e4ded8a3ec7579f250aeec4d38b0890c8fcbb74360dab0926ac29e8bc4aee074de81b9b8324cc3824134877a252ceab50786aa0e3f4e7b2240c3235de332431bba6f7186754ba0039e1443f4cc8a3ec759009a7820beda5fde46c26df3632d2d7ec391c1573ef5aaa0d8c4f7f16704a44e0e58fb57ebadea9042423ee63847f4b478a8bff429c00e6aac7ef7146823c213f82fc59ddfd5cde9cc9e88a1dd7350508bc6c603e2ae5fa30eba822762f8695b1510e973c66bba110ec98bae537595f4bac7f4ea42ca4b9124cb22db16c32ec054f8fe67f22f91d80e3841d880c0d843b577cb312e2cb8f2f8d563e2e095c5c881cae40e9d7f7e9768bd4b6d937a97439e81b9b76e810fad1b79f2b3c410e847f9e0ebe954220007a07bd9052cb9199c93cb3046b93f799cb03e2d586e7f5dc73129e969e423b017c8cc2bc7de5ddca424c763e5c3a8fde06a841e5892dcfa5e950d5b6a49cd0723412af8a3132b2dcf5e787ee0215d549ec86004e35a33d0c7382edc103df91aa36f0246159d6cf47a73e3e5822dd493351d6477e50879ca0188f9d0d12ecb35151b70cdcf4b84a5ce32ef31384698f8dc08c392bdc83d3237cdf040312c5615091d47aad5e50a0033cfe49228d9244c525ee74f132f01cb849c9ce717ffa5035d7cf9cc60ab1af676e8dd1ff24610f1b791e89292eb325c3109eb48a90671dd9ac39e59a88420441519f15f4ca3055ee642a557913a84d9b89a13444be7112923ce81b0523a276799fa5206d56864bf17f5a5f4a65c84d5492ebf3d888fb1410fc26dcd592840316ea719f45e9a4618b180e284c07da1ba8825531d19822c99b5b9ebd589ada23321f66c70704691dfe727248eeb0076bd2c518ccec47455b1a8124932fe19ff9fce254b25baab3ac7066f5ea5b7d8fad9fc1b249d27856a09a6a7fb6eb9dc4fa4c81c93a9786d1a29eb7ec82108f0c7a5cb2f9849f0fbf04ba00a73a11b3b56ecf2437bd63487ac77ac5eb577d87803d74a3a6e708f1e26b1861728e51da448369c4a12bc0bd01d0a9278beeff6b4291eb16de4a5f307531c5bdd8ada9acb8f4b50b41f7499e8fc9f8c57026964c914857ca2cc8ef4ab33343356a02d387c1167ae4cc578da5820ba712e92edee8f015fc50b4ff0094d3b060eae9f00cccce546831f91c36a4ee8ece62cb8d6f013ccf11c84f48690947e2844c6c4368bbc253f7ba48c68a5568eac4d9bf69c5b9da672d3cccb91be945f67bf20a689a891333861aa2b2bcbc69f435a66819681f7146d06b896567de19c24578386478460357da0dc82fba01655ba8462f7e1133e317cddd951dfb525ca2bd5e40787b8fc338bf1f12b8600d305b5c1a5ce7b434e5f7dae1743e3823ab6ec6089555faa9c6079e547abb4bd607755dc6b31aa8a3aa87f91e76e1f97684efa6644bc7b56c2e0eee17bb02e5cb77912a6e8cab7fb0574bd0d5230988c677911b67863d9ed07d19a6b85f801e6ce2bf17fd270b1b4afb9d199111be7c2d3a8eb59eef64199e5028b9704a3eca7fbbb5cc434cfd7936cd16cefdce2b7daf6d8947808085a46edf16010ed8ea98b80474efae63d3459d611c2f4d2fc85ae6e25212d21a07f0f774a5a2bab0f4c4f6267f527615da9f5bdaeb6c1c648a67a11ed7811b6b13aae22a55c6459e9b403ae033a126104f38cabd6c5f1d92d9fea1477bc2d1b35ebad72af4b10b83f5db1d172bc6f74abf495c381e7affa965e8d302ce951a134a04dfdbb5a76202b00dd66cb275a15feb0204c8cfcd606e7134a76f2572bca2ec2f2382b72b2cd89b8bb6b8801f0c40c52b40b999e4c4caebb8f523d9ae847a32e22883de2d8e96a828ef397225c41ac3b4113ae02b3a3bcbc5452c668a8421dd8865683c50d5472d22bd9213e0a197628f42082acc348517ec9bb5999967800f3cfe215169dd5c2d9a8878ef1b16aee6b10c013df02e2a622b38a3cd259bb15f8ff455e395a879126c823b0f745e4be7592dcedbd1471a8a5a31b066724338e30190c8623cdf6848abdfe1974d53357088d12f7e587cf3a84a4aff631d120973e3d61b9ff54a1db0410bc832497f0ceb16d095448b9ad609d3aa00f54eca343370668dc13147a4710d1690c1dc1b90a84aa966184c699a1cd8169037d8e81d89f188882da83a7f595e912a094b1eefbec7a349923ba90a2a37e078e995f8c3607691a6ba38f1b76c569151aa72d363e975842b7d1bf83381d41dc1b8c0f1201a7ed13964fde9beaad7fc686d5bd17615b05396c887e36af9ed21e8fb9595b61ff9582fd92085a3b422549081228e34e969a29f6766281cc519b67623da7152aab45857d6bac19a1f480601d76e962e79baca42c21b8476ee8b2362379483665d5a2bcba49ebb6ed47c96b8e96c848a668ae0b00ad991271c1d0d7cde0d862037d3473beebc863a0f4b7eab12ac125253e77cdfe606839544b327c62b60b1957d5198bb3b0d4ce5a9670194d5065eca543f94161ac6e790f14c8c3311c49fd9f88353ae47604330eb4067c0261c4baf1869455288b01e331d4e7c7e319045ad95d295cc9185c3d297829d312a4b46fa83aa64d852efb3110262814e005599b68dc6d737c7a689a0f13589aa737728507a04a0d2b93198b2051f440259bca26ab4fbafceae05126e704ccdb5eed319f7fd9acc5372aed0c56ba92d147488589244d49d1a566146eb30c4bbf1e560c1f05dc482e179f7c952fdb699a73268151d0e009bf7eb4f665863869ae77d8658c9ca0a0395abdc452e7e1d4dcac62b6c71c4265ce1a08f062ed0340620fe764ceb9ab7d09ae19b2a36abd0de66c227ffa98080f6a95d808e91259b0ff83323f3972736620a963715d4c4341ea32a3b7e1289d1de9dd17376a77066851539732f5d81b49c181cd8d8bf1782662054558deda9ffa56e4bf5f9f808246b863b2a72ff79116bc4b1d9779d1242dc5ea9e2f6f3a133697c2c469bed830e64c49cc638f401c28e1256854f5bf4b1dd77814169060ce0ddc7fbd247e4e95b7c26b6075db9259818c4befdb351c73321b18f19dabaf29c1c56e04271f958cbfe6aedebdc3f50f40b793e4f5194e053ee022f01ef73c5bfaa3d054212c7776c78525b12aab0221a0d2ccb459a300f8a5d7e358f12a74c82befb90549de750aac2a362f4701d2629cbe0d63c273ebd3e56592b37b679fa913a4d9ea3904c449db122f920e6626c354e7f0916346ca76e639d73a149df6bcdc68b1256cec79bed129b1e1566645b4349518c67cee83ab50e0f9b475939a30e33afdb237bf4ef7232fd9531eee72f9068268f1f44b10a94154ffa80f3d18209d837bb0e0b995ef2fabbf0cfa350da12eaba17e026e0f6848efb9e4f4d378923fd0285040e40a6e683da599fd742707dbf3b13338117aefebe0e45e1103ee18803af0</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="无" scheme="https://unit-serow.github.io/tags/%E6%97%A0/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-20</title>
    <link href="https://unit-serow.github.io/2020/03/20/%E9%9A%8F%E7%AC%94-2020-03-20/"/>
    <id>https://unit-serow.github.io/2020/03/20/%E9%9A%8F%E7%AC%94-2020-03-20/</id>
    <published>2020-03-20T13:41:31.000Z</published>
    <updated>2020-03-21T13:49:14.873Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="fe88de0515840702d31f1bf2ee677b3806ca405368635fa82c2772355591d8d9">0267ec72f19b8c198697a4f72870a3a892568fc41050576f7df5c59cf64da7c1b56ad644726ade540842c9ec49a82a50a71782c8309591eee91499bbd5643fa647c2c33b3fbb0016fbc9c9c53951160320c89e5c3b187cad694c76b51b3099ed264213721740e4651eb64e142669e870c2fce1528b9e9da6704276d0e6777fbaf9f2cae7e7ce32f72026b4cc73d93aa725261fd97250333ab700f15cb4cb717e646e6f696319655939bf7976012a918a61723d0f6a0b36a1541be8096b86eec0aeea3a965147b27a6e3d1695650f99548a587305fc753b9d37cb7553cc38ab408f8a90a0afe2c3aa53bdf24ac68329365e973b0ed438e93c22b3773ec7433885b743c74cda05e8132dd4a59e2784e296d9f19767a7fa0359a652344993514f38b0fd367aa9d9564db7b01a0dde1fb48578722dac0accfcaa14cc126cd08d7db9b43b0ec73d35f54e8200a536351b87974358b61b556bb84319da1b55374a2a0706e89b8f9b4f0eca4e51ac8cc508a503fdc9151d035659eb83992085aada0c26b076b56e0cca22bf42cbcab8b6ca1ada62e59417d065c1370c8b5ebe63439abc002c6ae67f2c6da36588921bbbdb0551149a6989b34761d41569f9d126f599bc3b0ee454d9132ac556648402712f8d4636dd65c896d6f257338b6ed5dc28646b5f4636c6a5878667f30a2b994e62f8827f14dbc9e6112366a8b06913ebefeab273b3eb5b98da8b4dc87da3ee088ac5613331b3ac4777aea2447d968b57e463cde035cf5f3461881140cfc211fc10b776eb7d368beb52ba83a222b317853e9b625ff3620c1f07b17c1da55bc5e4c056f612f4e98e35771f88fc1f4e68c036707ecc3e9bc9438232b8306ee49045144f4f139536781a6e8e025ad86fd7c21b117bf491ab83c562432a0b7ccef58cec83cc2dbd5961a76ef1be8b3de1d6398bfb6a2dd3afab4ba5efc9e40a23400cce444e50e164b4bc63689074aca5dd33d2a9821785680202e41cd25f421aadb0981c0561576c95e773d1fe3ce2b83f3f2d4529eb01c8ec2c16c95b2732c488e4b24245e08cb43f0ac059756fabb0aac5a0c95f1ba2125399a1b2f9f16708b7ada29c1c5a765677ba6083be057a44d422ef947e722d0b25c0b1159456f62ff56748f99f7799b5401a16e7a6e8e25350b0b724d2ffa687a1b4535b1a18cb9caa321e7a89a01bd86c9ac0f69b6ad6759c4a00ff86e2e2eb8e389b6e56eabce3c7ca10d6d33f47cad1c81d5a5a890c0997bde6d5b5b44fa1b6d9af22bde4bcdd7dbed2d4f7343c5015b86ec6507faa0c5c1300f90c7cb3c2060389bdd607a7c0c4eca7f868904b29d6dbd8eb68c37da260931ac56daa8ab64dfcfb3440243536377f6e056f1b8312b1748f1eb612d562fa316d550e4fdc043788acfdf0cc2e368d813502c8ddd020be0dcebc3ba087a5f5e507f46043e49f78ec2caf6fa7f37354b29bba8961fb7a335028c68c2235765c9727689746fdc942382f2c847fc8b941aa95a582a1ec79b268ecb7b1a1a0f1808f88b36338c8d7e64f3a768b8c0a8f74faf5a89b671405d30bdeab7b6cc350063ef8312667d9ed6768379554796e776b5adbf04ccf2842a5b0fdc2c2e206b24bae7154fdb249377f6d878932c0068ce185ed9f657aabc8627400d491e794d6e7ea53ef1e1133cbbf21f7fe6e05a84f5166ee1e8a9c186cc84616f465b639528a51d4b2cf18dd5d758ad830345585c0f6cc6ca7a30572b73fe356a9b5ccbcd60f46270101effae642cd24f0ac8554ecea3bd273c89547fef5e2368c2bf8968d7b1eb41f8b02abddc8d9aea4aa8a73381ba8123ee9223845e1e63614f28a88a621b4eb23962e83a57b9c07eab6b40690e2d408a16eff2cbd4df1db6160bce556f841c1a8f860c87747bc74d7bcaf5e55ba29ee64467294df289b6a00421f30499f6fae1c8f188f5e2f5f714f0652cb7d8fd6901a9e7841ac0c48648857d6323479d76cd5ca060963037807d6196ae01fe380cac5dbe1bac77a09e66849fb5078d0212b781996dde557cd90a6040e2d2eda191518817a6d86125c75241f896642634a97c3cef1b73739c442f817e9361467da9df13c78a9a1534fae6dd93b1e54abbe5ab9f0a9c6ca165894255b344ee57e6cfc51b336cdaa01c4b0c5ea3e3e50e0b46a69d8e17f64f5e3b3ae7de4e57385b476eb13005237b990e6d9bba9b2389f1386ffb38a41776d3af0baafb1de4e691941670d54c14944859490316045e5d4afaeeaf14fee3019a4660910251e92c46c5f733a462bb26b9bccb10a5286e4d7af3f7fe9437c093dad3ac46c782919c639738ea187cbc67d3c93f81703a3cccc488b6e0601463bd4b19eff0bde11f0d2b46402d16803c47442436d9bc011229105f830c377e2cee3d990d2cacddd6a5c4e559c04d4f50edb15aa2fa4ed69a059857e4d28d5b7084e1fa7aeb67dd267447b20f6023b029874cc4f620003e4df9a6de316da87628c5c3b0a411c28bef3a9807c5abc31da6de161af8bed88f9f9c09803c111bf2ff5b5097672d767e8258e0e1c74c5402b61c067482d6e35ffcdf0a96a4fb2fb74343860c4923a75fb79b1c18abb858436ff9892418c4e16c934cf7dedb15a60b3e628cd5bc7451a05482f1446e8ff57d265592ebc5f19a1c4c02ce9b0381142430c0289d139319ccd978407cb348b65b8293a16dd542af699b5b30c5023d5508bb110289ec148ec722f17f7ff9cbfeaa818c5fbeb5b0f334b7d9b75a0b04283fcd65b0da954fe8f309470dcafc15953f684f9d76ff6724164599225e57d58ebbe12775cfa3e1783fffc82492a5fe525cbb346a66982f7db8acf73df3ec2f0556fcf19c17c27344f148a4eb63c0ef5c562082619908f7f9dcf241f3e8cebb3017446d45a0c0cdfe00a120c1ca0da7d54bc948a1dae157341470abaf7f22817f3c43ee8e3ff08366990304712efe669b1ac7c6d92ced709c7c9fa7a6aa460c6bb1959def2f153e7770769b71167f26fe7ade7d10ab73a1efd21e22b8efbe75c133d5acc1a827dab5e53404acd4bb639512341b26cb249b62b8f24cdafd0cc5b64239401f5d9eea3ca48bedcee56f7c7e46d0003ffa0aa6a497b1a96bf0955855e5beb5f8d1616db4a48541cd520ed483902397f5ae5237ec43d346051a97a133bdd4b85f2370390468ccb35f4ec434b72f52dff05929553b64ec6fd776ec8fc49358e063715e4a79d57179041be4dfe6acdbc3016cf9c741d2cd3041598d46e7a0811ad91b6424625674692f5aba21d7346523bfb4088d899ca0dc48a813c3be2dd592d00b4bb70e397946994cc7559b4037f56cff78751390cfe6bc6b7ff79fc91585d1f2b6bd9bf42655201fe4906228ff39b56af54e0897c9957bbb01a1298809259ed3b32e572140eba46b0227d9bf0a8a18cfd054b394f0e3425eed0c14959fa4b9b14cbb1eed6c3ecf8ad79b783f113b4a194df9a40d405408b4491c4d596a2600a25c0b4132856431b214f7e7ab51a5cef514831ab142542afb99c1797d7beae919b68f37f7be86067c5894ec0481abab96b2aca1c2ce8b4b95b45ba67e5bb80858b25f43151996f77efe33c797c58a437910d9803a4c6b019cdd72343ddf52621adc540efac384331a240fdb611e5ef3e63302776c4b8514cfa040cc3376d88213344e2558da92a8e9b4357413d0d18d15eb0c7d2fccf3a44c79628524c96d49c9b72cd5be217740d8de61766f1984638ff10d0aac855b362942f796e93560d8ea262ec4a2ff329ed15ec08105b85078762a9fe99b89fe525420e58c3fa4642025cb90041071b34852426d4cfbbea955bb4e7ac6e83ee652c0e1d94e3dcfc67139ff831ca2954ca0bdd902d49dfe6504c94e39bf3976e6e65f554da1384f4529639d85a09f47d45004ba3d3cbf45a599e181bf87b96f6fc7241bbcca5cc81a4225f557ea630ec6f029e68e4195b4e571b1cee4a4c4a6b229239e48e47da317651dd3b88a5a06db4559b5f64e314bf7a8f3dfb86dc2baceadf3f237576c6ae872b2dcfa2134ff7780da8c2b374693f0329a2cf594603f5e0daee4ec9830cb75e7571af124c54ecdbd5b6ba6d7c75d44419fe2588bec5ccf3fec18ced3051163bcfb140ad60cc43c198acf3a16e14313f218ff771fbcea6ac7a249b7eabb74676fa1826c6974609066b737a8dd6ea727f8e4cd79a60ed998f7209e403c5c4e5e9c1be9c553f9a4ba371a23a262bd753d401addbc3259b34960473fd6757757552340ceb82fec99a5864132699c681bc424a1ed5931ede0e117829c7dcd9e814a95f9fd8274c5fc836a16424eb703ac2c5e9ad925a4b1c8edb28b99afdeb1421e29b54325b22bc05b662289d7cc45ba847330321d180b93ad2ee9f8348c1d5b1c06384f21864e0b84299c71813f5b736207f4d761724e7c3c1fe367114d7f87e5db624d45b3b9d800f6a8f53e1292e50f7b9f89f2e90a5f993c6723f8872fbd428712ca907f19647980c49bea7e84e1e16955dc1212aa6edcffc7987c460cc06d4ecb1980bc830dbc4d8515b0fd91adc8e578a563e0763c8142a3d900b8da99b1d646425569522cb1acaf53fc7aaf55191df4d4222efabad766a8bad85b6b76d455d92134b087a0fd19427e2639eddcedf138e7ad2fd7c945aecf187268d6f7ac7451547406cde0d1bfec3bc5509d87f3102d97659234d5acd3bbc384576710cc17220fe845b319ab32b01ff191056b5ff0371ec763d5de65cc066a84372bcb8cbe89e4a15e1ddfbf5173003030c6b4dd5ee3ca54604416d3d074c95a7e6871a979a32949ee5c37054c6be657301f4a58576965b6c592c1614a67341999bfef9235b1ed31c24804fcf6b6c4d806bab47f7b350f0127e42b9686341381bcc4fd046b2074472bf1105a42fe68cadb0fa1e34a13b4ef68fd648caa4528b20a26e85362a0c805770b23719351e9b67b6efe4dfd7ae285d2677f43373f5c4bbdb73e10d7e8a20f67c3e4035b628d2f3d546ee5aa25987390ac9e0f65e4c6dba5db885386646ae3f0a4031bd9266e4fccbcec3a99be3117dd15893b8f78a180e414f10f1d0519e5a99bd3c1909df8acd6b17aae122c040eb4d730e3fd5ed2ad7aaed0162b0af207239f8919fd34ce2a0f7dfbfcb883f75d639b6104d186f862ba861f5e6aaa6553998f62f1f3e9429084ef6037d3c97037983d88ddb0d24c5d71e1a6e07db03b99ba64c9b98a4ba33eb8ee636033aaa39966e58b56f4438579b413e3e5a672399942c9977381ff43c2cac8fd1043a036b0527d48115695e67606a360776d86f63d783aac8fe43f718bc88102be1d15a8b404dfd84cd22ed5370ffd0850b1ab7fbb72068458302552ac76a170a3761d4a8427669acc6a3c95d1553c1d2150eee95d7393e672f1862ee1115147c1ba0c5e3b0305032393f35bf0cef7d72b53a7b2a5aa33631d32c9000774b707aea14df51789c8436ec53cbcde88f4ad8cce29cb86f1ba994397aeacebfd9f26bfa4df9d3749be05cd944471e8674223be5a313c07a98b71d142bb2e239d21fe6170aa628ed22899a4d30232db9f13a141387eb06cd338340b5853728d4439dae5e3b321ab1ceb081405100d5b7fa8c6d3acdb1b1e18419bd1d36e9b1dba842d87d5f0bc85f52e4426456619454f152a57d3a2e4a924ece9496f2617f64e7ac914d8584bc68967496d900d05cabb5afb3db71ad85abc11b2fb53d2eaa0059653b540af8851acfcc4f676ed6ddf0b7c017e997071afcbe2ed17c8b574bda82a5ea1d588fe92b88c9ae183737a0141c41ce1e6744dbb330fa65c2df5be1b52667884ac181c70f8a6c16853c6fe1cad2fd022f535300b500491d1336b61a02f9b9e576b00e11cb970462e1abe5e23663fe0e596c99b0f12eee1be63baa81a3066f6e113e9f1219b52f5caaba02dce747aebbe819cb86c64aa08bd2010822c701b508819a094d5061444f216be309633494b5e20fdc58454724bb00f647ba98ed257df07b725d7994fc58d3d42094baf02f60b9ab70ecfb9298765d79858acff014cc92a78144d82f1efd150391744d16325ac171d8bd0e039cacb2a58e40d5a80e6493547825848525a3043a5fdd5d193d5a41ba0d39cb142c437d5d747e0083d570c3ccee323aac715b38e11f9c417f41c6f11994326dc58d55f0cd121770d8d498e68848263b496ef42b6ab2b59396d3ecaf1188c5f257e0b645966857769278d7d3b10ae5bb95941b5e17f4a5abd30ce6e2dafa1d5777c7311235532c6178afa8c4fa9abba28d32736731c59399d0188a5a87e9608b4eaf6c2d111fece36d5cf10c7d07f33ba479c483143fbf816fb516b049d208515b725c789fafacb0e11382b0f7ff92740c4dd5631be121af71cdc740c54cc1160036b54191f26b5f6e83fd42d84a4d806cc269abe892f6cda1a5d460291c7318fcc12d3caf6a90d4a808ae5ceec7f1c253c4fe0a2a3ff11b6b98dbf0d8ddef301551e7c6c1adfda88ff970097fe4890a277d6767a2a95ac430b9f9acf46683d6687ee60d15341dc87647cbd5cbe15bbcb3e4912833314a41a0d0e6bc0685c5939f55521488981c6120f600451962ca7ac8b0571172c76b6e919fca0fc93b7dee38e3418847894a726d037c1c56a62fc2f7b33dfe989b652d1ea20799c347cfe20b5c5c19caa2e194008d4ab571ae01c35fee890aabe7382c68f4e5fc2d7cb6919f8d3828368a18b8065c0c6a69daa48a6a3b877bde180e8f3b54a0d052c8803dd33804f1218fd695b1db0d716474037ccd97a1f9a9688bc5ad03a1ce77e20672fa0a8d08c5228b08bb46505d709bacfaebb2699dbee8830baf4bcc90b0b84180c148451bcfad53c8d1344c2a318ecbfa61e7a77082b0ebbb59f4fdf46e5f347997e7efe538f4bbb9a8e8c62773a1ef64c5c42a67d86f12beb4564602b5e1d57b35355a9144b08e1ae93b20351d08891b4499a17782367f81a692a0af0906cac1c932d2b0242812e924cf2f244afa33f7a3de1e8161564a9a6d95f9297b5d43edd353a1e1da5cd0ec7ca33932b666a9455f52b6c3e06ae3c14cd4a896be6a7bfbc78ad883256e3fc4b1f566fac991a7dc968ede39e968fc7c6af10e88c37f9d892d7a0ae157e9f589fcdd84c77dd1a0e26fceea47bb57e0dae5cd623b4d46e35f78839cb5e9cc5ea914e11f4f94b7b9643eadc86b6c1a37313fc7e5ca2181c0b68e7de8f64475b70f2a6f24735b45877df81d9f16ca7e328e507fd5c525603d01832db9a2453a72d38ccde8f5be10c8e4830fa3a161cae8ad41cb1e17755015790187d299e3c4e710a2cf9da5f7f8734728a43b1bb1d25e87d8d4b733620f57cd69b610802ef45535fdf6ade9c325708a91c509ca3a74922e7852e96ab11f8ac146120498589eff4926b0f38f0d7ed4b25929c6881743ffa06f008752302786f64a7d1ec9e0c182991b6d30cb9654b11d87ee736773e3d038e6e816f2bb3f0b071df9a8abbe4423698ae08249acde142cff265463b98a372f88a5866437abed13b15df804be67ff51b972256eb109de39e97a8a8bfe52c5d8db0df13e54c4d52a83ee01c9efaadd8ea4a623a9c7415bb0dd9f4aa8a4d485ac1f0f91652c7a409c31361de4706684455af56390598a6fcdd718394ff60b408dba660229251ef7c9de11b375de58277b6160a0ca3c00eabb85f2fe5beab8f6deabdcecade46e6d1a47b38cf2f62c1ded2a36117c9071d29ee70f550bd9cf881c3212887a46d187aeb76751d503406e6abbd463be993d6bf50f465a7ac24647a3171abfba332994f1b9f1e6a0fd120014b106ee22084253691b3b84db5975f0c7b9a5b74e583447d356cde35e1a2eff6e247fe4349845c3ed954c0a15e1e8ac69af8e0eba1fb4fdf72655a19adf85f753dd6ffa8808611bdebf20a8587c02c1f9fd872a0ebcf3c26d4b2d379cf8542bdaf48c6ca42ecb5f13b71e1f3ff70ccdf1b48ecbaca900267de8e9e76e9c1d8a1227039860475dd7d726b4e9b4945f541dba56609549aa917b65f24ffd4dc277123505cdfcd617f48c05b2e6edcff9f52f01503838be50024b2546e12e5fe27883a0aebca5d609ff465296eb78dc707cb081e8772b1535bae808acc3f20a1053621f4085a8227c98b8e5b398fbb59ea1c701d2b3babe2a9d8d435f6e5e91f9d7623a25ed10902d1253606481f5bdd4f46f31af08fbd876b3b7d5d804e0fc5c68ace36a8dcb66289e8a94e6fedede2c44058b7ffbb74d022765ac5bf90377e81d488db7565b64385063951cb37ba5b72306f7f43bcc1d4fe9e8e7257544569c8107824645ff99a60b8dea1b94b8893ca428bd8c909c0b4c85d88eb8f292896e69b346972d840690bbf1afa33a176647571f152335e8e05ab10e79290216379a851300bc480c283ce8f0cf9891ff701f16604a16d99e17a54b5945d85d06a3f7cc0226334a9bd9442a47a56674e75405d233cd055d481488b40659953f1c8b8dbc63680c04689571fe57d5ec0b45f764b22b28320c568e1d39d61f0120eeb8f901f1e5dc6f51f687730d104957a28daa13cbf9ee9ba211e6a87de3de671ffc3a439f2e1d1fe35f540e1d32d40f62e3a220e83a3e9856a5c37f68f4526e6153cbf82845d667416921752a23a4ab1039070c53d8bdd1b526ecd9ebc122bf9d7c1280c2e65c224cc0b07738a494ddaa027f3f109362318a59fe6a9372141df94366cb5895b7e75b97beb5ea96dd3cd9376796a57ad8a2c87a3c39a0d7c258bfbb684554480e778ec75a8e25d8103273ff49b84bc049192abc716e12dd9c5f20a86e8f762f1b82233335a38e45e85cf92084b13be2ead2dd6cfa52136d5f0e4043b602a23e16d9d367e445ad84bf679b76b20e99dba8bdb2772743a95347ae34f1502dcfbfc0baf59e2b1e835d090f80e0c6274e2d18eed870c0b219621e00f2c87a2ddf0cb669256356c53ea39df2854688a09ec4e50498675bfc283405541bd457b71e1a597b436e5ced0f2f945dbbb43e5357e5d054dfd7989b403eeb76df3ff00dcf232993ac6ea58402446ebd2b124f882dd6242ee8336e00bb650b63d41d8f8dda750cefc8038bbe0a0145761283c5c7ec3dd8250f88ad6d6bb0a2a420232173db070983d6d40e8b5680c5e79787bc30e89f37d21be5bd1ae40a14b9a70d9be0a4002a48323e8e51aa6eef32209259576f19be18892691aa66f9234c484264f9d334d5cdf605a94e97d1e546f361fa062b0f9487f5fde354fedd586c424a9805fd442d5192f0b651473dff8c6c92eb610c5561ff594322bd3ff1e8c27fcaaef16a54996a09e6710d2158e80b36864c2057e3e344f08db2c42313b6a38b161570547319773de0247ae0ff97df257e9e9f11f5d2b01cc7a49b3ebbb1a2f3c11222469802d094719f92f8d51d7d4a59e81e391b2838ede4c95e58e3b2fd761f7b4c2f04534518f43134ff2568fd908643c2d2</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="无" scheme="https://unit-serow.github.io/tags/%E6%97%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-9.1</title>
    <link href="https://unit-serow.github.io/2020/03/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-9-1/"/>
    <id>https://unit-serow.github.io/2020/03/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-9-1/</id>
    <published>2020-03-19T13:15:38.000Z</published>
    <updated>2020-03-19T13:16:33.388Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 21:18:32 GMT+0800 (中国标准时间) --><center><strong>数据类型-函数-1</strong></center><a id="more"></a><h3 id="数据类型-9-1"><a href="#数据类型-9-1" class="headerlink" title="数据类型-9.1"></a>数据类型-9.1</h3><ul><li>函数-基本概念</li></ul><hr><h3 id="函数-基本概念"><a href="#函数-基本概念" class="headerlink" title="函数-基本概念"></a>函数-基本概念</h3><p><strong>涉及概念:</strong></p><ul><li>return关键字</li><li>一元运算符</li><li>方法的类型，定义，参数，及其返回值</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>函数参数内对指针类型变量的调用</li><li>ANSI C 原型</li><li>递归</li></ul><hr><p><strong>结构化组织程序:</strong></p><ul><li>C 的设计思想<blockquote><p>在 C 内，函数用作构件块，而所谓的程序即为由代码块拼接而成<br>至今为止所涉及的C 标准库的函数有如: printf()，scanf()，getchar()，putchar()和strlen()<br>C 内还允许创建函数</p></blockquote></li></ul><hr><p><strong>关于函数:</strong></p><ul><li><p>函数(function)是完成特定任务的独立程序代码单元</p><blockquote><p>语法规则定义了函数的结构和使用方式<br>虽然C中的函数和其他语言中的函数，子程序，过程作用相同，但是细节上略有不同<br>一些函数执行某些动作，如printf()把数据打印到屏幕上<br>一些函数找出一个值供程序使用， 如strlen()把指定字符串的长度返回给程序<br>一般而言，函数可以同时具备以上两种功能</p></blockquote></li><li><p>关于使用函数:</p><blockquote><p>使用函数可以省去编写重复代码的苦差<br>如果程序要多次完成某项任务，那么只需编写一个合适的函数<br>就可以在需要时使用这个函数，或者在不同的程序中使用该函数<br>就像许多程序中使用putchar()一样<br>其次，即使程序只完成某项任务一次，也值得使用函数<br>因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改并完善</p></blockquote></li><li><p>这里假设已经定义了若干个函数声明，并于主函数mian()内进行了符合逻辑的功能性调用</p><blockquote><p>接下来要做事就是将这若干个函数声明进行定义补充，还称其为为其进行细节描述<br>描述性的函数名能清楚地表达函数的用途和组织结构<br>然后，单独设计和测试每个函数，直到函数都能正常完成任务<br>如果这些函数够通用，还可以用于其他程序</p></blockquote></li></ul><p><strong>其它内容:</strong></p><ul><li><p>许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的”黑盒”</p><blockquote><p>如果不是自己编写函数，根本不用关心黑盒的内部行为<br>例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及printf()生成的输出<br>无需了解 printf()的内部代码<br>以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上<br>因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务， 以及函数和程序整体的关系</p></blockquote></li><li><p>为了解函数而需要做到的基本理解: 正确地定义函数，如何调用函数和如何建立函数间的通信</p></li></ul><hr><h3 id="函数-基本使用"><a href="#函数-基本使用" class="headerlink" title="函数-基本使用"></a>函数-基本使用</h3><ul><li><p>以下的说明都基于该程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"GIGATHINK, INC."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">"101 Megabuck Plaza"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">"Megapolis, CA 94904"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">starbar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, NAME);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ADDRESS);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, PLACE);</span><br><span class="line">starbar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= WIDTH; count++)</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其输出结果为:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line">GIGATHINK, INC.</span><br><span class="line">101 Megabuck Plaza</span><br><span class="line">Megapolis, CA 94904</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>程序分析:</strong></p><ul><li><p>程序在三处使用了starbar标识符: 函数原型(function prototype)告诉编译器函数starbar()的类型</p><blockquote><p>函数调用(function call)表明在此处执行函数<br>函数定义(function definition)明确地指定了函数要做什么</p></blockquote></li><li><p>函数和变量一样，有多种类型</p><blockquote><p>任何程序在使用函数之前都要声明该函数的类型<br>因此，在main()函数定义的前面出现了下面的ANSI C风格的函数</p></blockquote></li><li><p>原型：</p><blockquote><p><code>void starbar(void);</code><br>圆括号表明starbar是一个函数名<br>第1个void是函数类型，void类型表明函数没有返回值<br>第2个void(在圆括号中)表明该函数不带参数<br>分号表明这是在声明函数，不是定义函数<br>也就是说，这行声明了程序将使用一个名为starbar()，没有返回值，没有参数的函数，并告诉编译器在别处查找该函数的定义</p></blockquote></li><li><p>对于不识别ANSI C风格原型的编译器，只需声明函数的类 型，如下所示：</p><blockquote><p><code>void starbar();</code><br>注意，一些老版本的编译器甚至连void都识别不了<br>如果使用这种编译器，就要把没有返回值的函数声明为int类型<br>当然，最好还是换一个新的编译器</p></blockquote></li><li><p>一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型</p><blockquote><p>这些信息称为该函数的签名(signature)<br>对于starbar()函数而言，其签名是该函数没有返回值，没有参数<br>程序把 starbar()原型置于 main()的前面<br>当然，也可以放在main()里面的声明变量处，放在哪个位置都可以</p></blockquote></li><li><p>在main()中，执行到下面的语句时调用了starbar()函数：</p><blockquote><p><code>starbar();</code><br>这是调用void类型函数的一种形式<br>当计算机执行到starbar();语句时， 会找到该函数的定义并执行其中的内容<br>执行完starbar()中的代码后，计算机返回主调函数(calling function)继续执行下一行(本例中，主调函数是main())<br>更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码</p></blockquote></li><li><p>程序中strarbar()和main()的定义形式相同</p><blockquote><p>首先函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以右花括号结束<br>注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()<br>而不是调用函数或声明函数原型</p></blockquote></li><li><p>程序把starbar()和main()放在一个文件中</p><blockquote><p>当然，也可以把它们分别放在两个文件中<br>把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数<br>如果把函数放在一个单独的文件中，要把#define和#include指令也放入该文件<br>稍后会讨论使用多个文件的情况<br>现在，先把所有的函数都放在一个文件中<br>main()的右花括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器starbar()是一个函数</p></blockquote></li></ul><hr><p><strong>图解说明:</strong></p><ul><li>以上程序所属的程序流:</li></ul><img src="/images/数据类型-9/函数-基本流程-1.png" width="40%" height="40%"><ul><li>一个简单函数的结构:</li></ul><img src="/images/数据类型-9/一个简单函数的结构-1.png" width="40%" height="40%"><ul><li><p>starbar()函数中的变量count是局部变量(local variable)</p><blockquote><p>意思是该变量只属于starbar()函数<br>可以在程序中的其他地方(包括main()中)使用 count，这不会引起名称冲突，它们是同名的不同变量<br>如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号<br>不用给该函数提供任何输入，因为调用它不需要其他信息<br>而且，它没有返回值，所以也不给 main()提供(或返回)任何信息<br>简而言之，starbar()不需要与主调函数通信</p></blockquote></li><li><p>关于函数间的通信稍后进行阐述</p></li></ul><hr><p><strong>待补充</strong></p><hr><p>561~640/79</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 21:18:32 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-函数-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-19</title>
    <link href="https://unit-serow.github.io/2020/03/19/%E9%9A%8F%E7%AC%94-2020-03-19/"/>
    <id>https://unit-serow.github.io/2020/03/19/%E9%9A%8F%E7%AC%94-2020-03-19/</id>
    <published>2020-03-19T06:17:55.000Z</published>
    <updated>2020-03-20T08:48:19.372Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="418f0297e0011794e7f54ade7d2909d9de9b9fa5fcc77f9a2be0f9d6cfbdf465">0267ec72f19b8c198697a4f72870a3a8076f26d3dae1e3b600bc2b0ef7b9973f2ce977d4ada5f2280a8c63f96e586fc30c6085492f6cc4e886afa21e499aef57cc629ff3ac5ee227d01d3848925f26505443b70b77b913d568225c84e637cfd87251c533c3a987929a9161f935080aef52b25b052db597d93e3f162d83f162538bcdc1b4cf96cb4a6b7f0dbe142552de20c0ef2f989ec53a13cd0f984d9b23a3859210b2c013da054f6dd3aba7d8201f2dc26eefc55ca18a92e2005788b3fc8258ef82812a434b51c701cf3a4668eb159d2634f60b11671a2810a74b78406b3708dd3145ebf4657cd34f9122d0903c60c9fb2801eaf201971fe8afad5c9a9fd9ebced4c1352f35d6e5f07ba4ffa5794f9fb547fa12b2c79436fd12484485b4964597e5ef78713b222131968f4708653193ce07243c012417416cfba73e4c94d0c9c593d894af187427ec593868adb10dd472d32ec1d2434b25d69b82a0726640de955f3f671fff392cd948d4d8abe9a52583cb4ad1e37b46b785bf8c818350ef4180c5db834ad55ef2c40632e66ac0dacc76eba4ca42a7b0eca1744b668eb60ca4e03f949b484fc4e0626eb0d3d8d11f4e33d44e10a75ed82315eae49bfbe0f87a533fe5783eb69a30e9c3699d36fd087b019eac32f3f5e7344b460749e360dc4ee079fb1cd43c347b31fb83231dab101a51a4064647f8bfb74c3aa4f3d50430550fc43a1fe256af1b050437fa59f426259bd22e7a5ed817093139fdec45cab70dfec28d5bec1acd087ccddd33d6d14a1c428c0d837a3b921e228a70a4c18fc5a9fd71e9979e6cbaf185962628e65d4edeef9b66e0eb3c0201081a62ef48e03e069d0ff12415390852f8edc5889ee92a5d7bbad32547f2e8f95de01386782c07bf02455ee10f52163f05f9bbe6c1e64d00c5f5f5a53d8d525aa174da67b4ac5afb481cbd78293d3d9e1cb0a30df812371d254ca2bbe7bb764e86bc2c58ced41c4f255d3cbde24942a1a109886091d5958f630e6487ad673b13cabe5bcbb4331e719260704f7a3569952b25606a33cb7b56bfe01827f28ffd7b59942030ae5afd74a395572993cd47a62f3ac88af7a9ed7ffdcf5540450ef6fc09021c1fd416d9521fbfd1efd6b95143f2942c172223bfe04aa4897b428f126366023be0ff80401b81e4808899e93bed9662ba0b0608458370e3952df8bedc01448f97af409573629f69a256895dd83ccf752be287f16a9d9033ebe56a36fab7473d2252fbc1754999eb0e8a8c318ee11966acd0241fa816c6373c4629091e13dae4fa5952fbb23d3f1b0bc200e535c0bdee799713b36a08b871cbc4bc6b9c37bb96e83bf8f3e04c052abfd3d75ab480ff4f4c6fe489ec7caf69741d64b1ce2c48e00ec6257589c6df9111dde8d9bd5214255a41ffa964beaa0c285e4b3c15e2073b3f4eebe4a070cde825018c6658e7ac33354b34ac5c1e0b2f8f19a910dbf3caafb332c7d03b40ab48e695a0a176506ce0b466ce39e36da446965f6fae9d292bf0f5c3420ec10395705b25fc7b28e049fc5586cfdc14b906a38069cdfa4fd0445b461195accdacc15f24e384a2233850d686fac2b81e48bb19c65183e49dae4fad9bb65d72882e438cb45f63e120e602613cc5ad50ef3acd594334ac2b584325a6ceb43ddcd84c9c115fae597789852ba73e665f55528e30b0d5ea37e05532300bf4af09825e9c85ce5f72dd96d29d8e9f0915553b09c6935594cf359c9676f421bbf2396917fecea9088c388729c711f11e37a724d86e02f0257fcd8d455b693d05285590ae810b4368ec756564da4288c4c964ffc00b0b7fa2ec5be260d3f7871fdd66d05a60cacf403954a5830aa1523f50a9f759a9e9585f6df9f7b9ac414f5c75d746a493796b8c420cf8783846bfd71cb232eac33c702176b032c5c554e0a7662a9fb1b362d8a17645de725a36d3a451eaee07df725329b3a25a7f01877f2bfedd5dea5f75405ec5bbfd42f0aadcb435828f6a93b1450c4561832d529d1120a2adc2a18418f5e1cf582407539ddf6cdc6d5d2c5ac9e1dab973aed9992831e1e4b54ec56898e8e8a52dd696be0dc8169610beabe2f3def435063a19f3dee8b6edb76adb094721b7a1926c11f6d79aee5a82e8084842da3e5953ee19e3e3533a6c82c2620d24d2d074d2f4aa709ddff4ea2d55b64d839a67006577dcba332f19192edaf7121b5f51996b31f7ba09b05439e0ffc4f431b4cb40ff95e948b850f70b90d54e2590c27668ce75e36e2835726abb0c143ca4abbd5ce3819da5c93187c768ac40fa9c7af7aa5a84af0dff06baa8b64da7a407bd304f52626b79d46d794c0c6b1e47274b47893c9492e46c03a9ab1a896da13a9c25581f7b2d7848ef7b09a5da7322c6ab60e9a1fb2122656479e43e4fa81bacf158edd5e9d0224465fb754e91a175aa4e05ec9aa236695e483f5f433bf7f39a51828eb8b2c26b0280ecb786800c0d86032f49d92ca21a64f17b9a1786191af7273d0705fa38a44f5baf7176f02bad5c51724020686e2037ccfa2742ab644b88d5b5337f5f70394bbdef1530b1dca1eb2c1949a936508786081e1312a8fdb85d95929b6a4af9c20a7d805f94641cf474476be9315ddd317420dbc0ff0cb8b0697b236bc8adea06664e2b119ffb3dc752a831ec34e8ac607deefeeb0500475dc600c99150d216f2dbe2932e499e9fd085a4a2208e841387ff0cc6f0002663b5a89e567dbcfbc5ee5741f8124cb8c8d3dbb6ac97e57ad83b1ee006a98716fdb8f9c6309a59a4662b18da19e7fbdcb0d0ac410b8eb2f4055d461004d55d09febae38eb6195069c179b450752ea2a83edb51661d3c9cb120a8badebd05fcac37931edcd7f66b3de5e6ed23339960e5cb53dfe248faabd941843a2abf0c42ec0b127cb6e0e47bd0a782dc4c9748de59ef5316c5c91efddfa9ccc9073e7d23118f52244d6d63dc2b88634fa11646d2dd993d1366e635b4638ddb3ea3e571c30a71277d0a23813e72b27fd3c4f9cf98e68dcf027015e9ff4f55e93bc53427f22777c9f5fa62911c026728e1c1b2f9f927e570344c1849f47913fc2d314822d8927a2a21db0c221580365fb23bc63de54daa99ada81c62e5b6b306b75ec9df52a2da36e6ae1f046a7a7f0b5a267309b5b4245e72c193a4fb3ff00a2474b4cf1534757fa1839fea7aff1ee61a7c8a6c0bb6bb450e4d7e528d755d981a64f3e4262e99e27328467cf8c91728e110d81e08559d9f599c2ed35faf4a9d7093382ca93f59083ae69012420c165efebc11928fea15b2970d105d25ac38ff80d8ccec10769c1316b86109afd4463d36a821479c0008ac0db1bfe1acbbb7b452f7af5806fc06c0cf4a95c7291f03f2039b658aadb900fd0ff9a928dbe3208d32477c7f91f4909f825187de94b0ee3d57c4d464fd03e9d8f297a92022cafc5c03edb1d728ecaddd06b863e8b1b3f1d801d0cc41c99a0cd770d9725b6e6d7eb5d6a3829a459cd6417888b4708024f3cbfc10c6559e7ad958956be0d8424151fc3e13af41ce6470763ed79538e8cad02ed01512aace25ca397649defb1c1d4d1d78de8dc4f14067f55ebbae4ccbac197bcf546278cf21399af5c694c5e54be717efad41ab4fa4ead29a5e838b852468d4fde17b05a4be3069641d64045da02ce47f7e62293c0f034d1089d13723cff634b3594f2283ce768c84b36047838b25bf729c0700a00a303e04144f87565b53af34789f9bc3ff868c36d2cfbc3f1b690eaa1d8785c0870b96177a8c340d7a8058790814ccbc30a5c8ab588726735310f9c72f4a97ee92a79481c4cd3c35eb54b5ee37097678fb13068ded7d276e39af404645b37741e0064cb7f6a7015049e6252fc9a89a8d081df2c3a1b7515fe55ffd97c67059207fe1395fd0515bac81e2200759527cdf43b2ea571528a5e1fb6f721924a27f02126de8b463201f6104b37e83bb32e5d60ba7bc5f5a507b17f8448f4b1ffa9f052a48d895940f27f526deccf2cbeeb6f456a0c241495ee4bbec98b9663a26e776393a6a11d7d7f3fe1368c1e31abf15ad1c83c8d7ce743dd4bc5db22d724cecd343f3a64aa4c40aebadb5bc7e09c9536177f0be863be6720660282d7a0ee7e34f4ce4caef6e90044ec5fcf40feb61644978eaaa009da69ad3a4ef3bc5189f0db8ebb7adc5c9d0512cc76ee790bacd684e47a9b8a67233306bdd3fd5adbf398a4a20846b026021ee5eac6067e53d0aa4b8a426ba137df8c28ab38cdec2cc7abd415e66b3683035188cc87ebfbd78ff0a4aea64dcd604a180004a85ee8a231c65524e5acc31e449c0d22354238a94e31bb33d9f4b133623e46ddd4a3e49b74fd12346bb4ebc8a1928496ae7d6797b6fa5e77b1f583158436f29b5a9dfb82c670a6c0af5ba97a62d245c7f10b7432258f3fefdf87fda7c3126763eaa22313df8a5cce530246ab7d23616ff21440da2dbfc4d0293d7009d4795e6067fc403993ff66521cea69088d6cf2e36896d31fd65918c8cbfe7b84c57e101e967a833fa7e775928df9b864ffcce4400ca3ce6709c2c08087726bf4af855a91c3dfe713c3cebc301cfa76405eeb830b7b16c5df607a3d7ada487645e6d34352174ddd034f858489dd7d8f476f219e162b809ff4d73768b40f5c385d7f99b7192d086a9026bed1cdad71985065ad36751bf602d36d37d3720b94343df01d40a3cae06702020c7f05b8be30f49b34e158b56bb84c8e640c2fc0b2c246a8be21894b153d514c71e48e7e3c412c632dae7ecfeed54131a16079d85128f17750a4b3667bdb02441d8e960e69d520a129f6e3d3e617933aea5b3323925180ddd68bb5ef60bf597b1ca2b48fa73d645ea0d25f1c54d5db08f908ecc9e3f416094a6c1318f49cfb2d1795e2eee99e061be258e424a73597bf8f8c1de882d8db0d4529e79ecbe1bcd09dd58356a65c902d4ce7b518829834f1cfac2296343458af4a9a5620c89e9d3896bedc9ab17472f20f336df30e84007a7f2ebe5d8270e98253f4480ac3e78b64599f9c7d69a085ad82d579ad860722654d3dc30f1d85622f40e6cba7fc6bd387d83c2999626e6f5f2311cde51a33a5afbd76b95a2b7467977d84bb10810a6d863882d297fcdfd4e629af27dd2c384d042f12a8477ac5ad293caac8d7caaafda586194e00ad933dfa9a482fbd934f332d7e24bf2c44ed13ba2c35843da0c7d8937cf59d6747c8eb4aadff348129720a1f3bb2d9dc4decf35715933e3ac7df19f4815d2dfaf2d16b4625fee41aa62fde8598304e008e0878f1fd10eb1a357ed4bcc3451897e15b5861ef060aac006f986938cfc86be468776510fd7331b478cee3d444046829c077d42270165a8dd3dd065f33b9cc37b74327dd52358e0f42d4c22636dd3a4754477e7c5c134c45db791a4ded1ad75ba58cd08a0b4969e544aabae1c65ade1210ee1f19752e7de59a9999fd41ce90b80cb8a423cfb3acbb63747dcca4f73572e1c8eadfdb3fdcc96415bd1c93b7aa76b3dadf1f81d86a39a22dc4c7b726a7dea8b08e68e72a7719435718ed8792111adc28b85dc5ef422b69367ca53253638b99f8e7815b400d1769c96572f70e357509a7d9e77ad2e931223e68083b19dfef2edadcf735688b6f72930659574c9d13bd00429f63061a19539daa1dd172bcccb3f684d24c81c86091266381d0b16b6f436cc42c00388c46eb6c9b189fe1cf8f8f3db9745f5590e265408682ee44e67d0dae7c815af1f5a383574ec2042ea00de202e3f6858c63d75c0e03e7d582fda4702e6f642c4a8687ba3bf66a744fcddfd212bd5c5107ba115dcf19c8c3a4e53454a45766011f7267c36a5682a4a827ee15d486bfadce87278d8e2454a25214eb37cb489d84a0f398cafe848fea1407b3b2b8b4c953f8233644aedaebcce01bdd3b5c52bbfdd543e09bb9badb79b5b7af96d7d0561c1678b0fc3a22e8b57a78dadd8fe688f1f03d34edb30832e4dcd692d10466a480ea845d34a98341d35812150727426b13b025a85d73f1022cf47e3125659f9e1b0269cc0fcf6aec25eff4343d28f784798f8eca25ffcdb4cd509f0f533c10e208257087315cf32a45de40b5bf78d3f201febb55a828361b4551eddbffa763091bebbad39bdcfda0eb9a93100f3faddbe36d097263378c6e327d0bf68de2a66acc25ca5ee7e0818da6248cb3bd62342cf14c8cd887118b92b3b268abf6c6a4b2706e87d757c555a5bb353e845cfbf6917ecdd16e22e41fc4278ce2818fe31d8746163fb8bbb55e707a920a67ff8320eb07c8fc057701898bccd9892aeef2cae07f78c7da8a43583bd6d97369822bc5a742696d460a0144546ce6914d4f14af806d73a65587de41fac39a097e6bea8ffc2f995a0dca388aad1468ada0b9c61695d5f65a86eb372c7b8c4dd52f57df10ef6ac3e802074dad806e0bc681fb28d1ef242c56f02bb0a772ebb381779ad8afbbeaa0cb0e52519c46f5a0328051e9f443feb673fb4a232fc62ee83704d311a3e397851c6d327d09dac411b631295325d14a6253ee2702c8988b814eb7b10d77b1745e47471d1d8c41fc08953e7a04816cfcde6820c023d4a3e42f764356282156f43a95451e28dc16114386d62519c1d5adedd634cad2488a03c8ee3b488fb399f28e622ce77ef39c1e661e6ea12aec37cf94a8019f19a071478a025c51e8e6684a2d937eb7c07a942ce7c93dcb7f6ddc16e71eb5f37da68ae1e86a79e0c11e40b42a8f20c80fb87c9c7b7fb6e20c79a083421f0a3d31a90557be1b5ae2622f3c4fa193b50d548988f0d62863b2de3cd6c33d6e2af00b171867ca6a9f279ea764fb1669545512133c24406cf6fe73be2c06e85fade9d26099de71feb8ee3149dadc74dcdba0e630ad5cce8f98c648c919ccdce8e2ceb8dabf744d8354d12c19947fe85ee385a14c09899219ffb56e3dad0279c8c9215d1b51970fd7e9ec151c75c8eb45ce3d35d29bd1e0f075c18d9e853c6dac0dbbe6a3ffafcfc5ace3a173699579d42a6b8b2194d39e5bd113214cdc0d880cab20edccf6e859d28077a35b1e8acc6d63a013528176604be4e05ad0cacb3bb94158c121065e3cfba8c6cdbbd2d1b26946241f885a50c2d06607de5e593d2976f93540e50bcf9b8b5f8734943c8852208b4d893aa2f9f0de022621c7ee9b07bf0e432e2f789d72d11fd17408ad2ffe47900a96a16c9e98bb2952b895c849dfd766d032d21f6396843d962303743bf311f29018375de65f41765836e79aad0d7ba33e3bce350abe631e542a000baba7c42648a0a6dc1c19f68b0627d251ea346587108230cb345a4eb03aecceec4442f17231b2539bfeb7338b5e2ffa148310923f3749034de4f791b97636e386233e48b61bfe4e88cb4e32c14ff22b4263658e629ff5910204ce6b7f7f525ae7dca554c63902c6255e7f9c8c78b34d1338a62614bb35931a0bfffbf99baddf71f58c490dd6a5d41ef04fddce49ca27785b25ec5d43445083e485b786cf525094df8742d3924fc122781952f5153b5f07ddc3ca3e821be348654c4fa2607ba118b91ac38005254f07927cae305969b6b869db3ce0f32cf9755e334d18796cbade000dfcb066e7a9dab6f8d9a603dfb005a6eb8728018256ac3904e747699b702e22abd82ce8b9dde668c73d8e461049fcb245bda19e9868e253dc8780ef2b3c0a7a148f5a3b5dd7675cfcf0d7a8a64f7eba79091f7687dd92314d47c5c8682098d9d04cfc0214297b7a90ffc637282a89c0aac514a4e309f23e425dffed5f48b29c8c14686a027ef972c9cdaae9e46f5f277cb26f5c06955ab02f108a4bfd79e1e8723ae6bfa6919ca03c55b1f55e8681310ff3d70877af0a5f15a5e9524d83d117243ca49d39e5c8ae6d48ab4887a01556cd93bba50c8c0bdee76b2c5abd5be72addf16179da7fa3c5e0484142c03207ad6dd71b350f9f27b70ae23def08536384141dc7a16977fd14b431feb1535a0b99c59e81c4a0fe37abda422e4add11544836cb1e41d9d52574469e1e8b562528a2f300cf52744b356682b33d6e1e2518e68be0853f030a31c97c094e011d37b6c54f99e2954f34f0bbfe76fb90223b63ef55ee3392bf8609ddbaa66998977c84d56b6219589386d77ce4eb7d679f3b368921772388971e1594b4f0d8fe17dd6568fb2f5bfe7b6da20da49afb370584d543da92844facfe77c587e8ce948b266ef875259bb81d427d901d3347bab2e2499000628b96cd18043ca670311a31e0a3c76db4755b3bfaf4937bd653a792a4de45c9a9f47c3f9d83f3ecfd18afc147a85dea2561ba4ece65e4b8c24ea0739f2f889665a7dc1f9fb52717c18e312f575f2abe5655826e1d1cbfaeb7d6768880aa04058e48654e344ffb752e03df87a8778ba3b9a1af6425fabf61e44bd29a5db8d2508c66bdebf85c99ea4b22663caf8924a016f97cf3225126e830d96fb68de785da32607672707d2da104460a38f43053bdc71a9b71de1a0c56145e7e04eebe48a3a4632f107ec043f5aa5247db93e66709df3f3138fcdae5d430c0503de36d47557f8dc1222558ae8e06ab167bb087cea88a801d5c7a89a9f98904bf7c455fea766db2327bbe8cbf93b307cfdec98f6bfd32a3f8b7d80fc423f74b1daed1ab7fd21ba9cd44c5276c413ceba413a33d0d5b4107afec9bc99670dee6480d5f2e31f49568e150d9699cab2f42b374e95d4494459f111ca5bc1b2c5b28d5f6489f350bdeff0800be6c5bb6fa4a4f50a7b9df0fbfa91d4c5a04f6197a589b2f6b881f0f4e2c12a7c9dd78407ac0be9343460a2590e93e6f6ab663dc510973afbcbc893c91617dfbf8f2cf385cd9c22581cbfeabe7659eff853792924f1da69d5e79d29e49c07365269df115514f1e8a69dd3f08a4f2e4e2869c6a9423c4c7e18903fb25f5e1452f5f2ce0940bb0bf20560d82db7001a7e3674eab19a162e6bc94e985cc2f4497f18b1f004de352b3e846e3fd0617b4144c0be69b5812aa3179b93f537c672afcdda8243bbfa1ced5d3608251014edc92b07980f2eee642aacbe790700b01940961b3cb12b70be9a1f3d6eb28c16d30499f9dcbb04fc4f747030ffac7d38a1325069989edcbfeb8518d138114b9d219f4e3fa01e34c59d3aa2cb608060caaef7aefbc155a104de0840f4fa22e14bd43d19f00069aeb89025307041c866eca345aa7426e79fdc1c9cc3181f22146cc5baa63abcc5fc2148cec7be59c700d373365744e16bbf9c7aea25d8faba6e2e0c612b96b8c78ecf6e3e04ac65d3d5b1080a49a13c49a5f6754645264bc2ba12e019bceb4f09958f8e3d00655c03cd7ca51516fa1efe494dd69819235ae556c803da7acfbf3ae4fe32a7b7bd0e5e657884b6edfc37b8d8285622060ccf03b8bfdfce140db9de4565046314de83afa3d6f4ca8659f5b1a41b148a2c84e09786559a336d3a6e3972bf5e7033003413b07772c719b7c9c989f2833b6f92939c78fbfdfb54cbbc5c48ed5ec97833d666b35ad1f35781427a412545f508cd9e488e5d67799538a343c5bd84ebd9feaf11b841d79d6e581c16bf2159e43edcfffdf2b0d3212411abf17926f58a41559610cc0e129a9ae2b705046d1cbaf03004cd91b59e1095e9c09a0952d783a67ad50487ff29431cb85c86af77bfe49252fa77c5fe76261caf8cfb90532d37aefa917747138b17f69aade7896a9885daa60d4f3cebef783a10d35cb0abbb259f8c59af3281b9bf210a43d616bfb0ca201c11cd5e5001e4441891443f1a81b617fad91b19e8123b0b89269fbefe63e8397ba502454c5b6e5578ce90b379c6bd44731fdd37826f378bc761ae3951c79e477bb0401caecab2d3b80f5ce89d2c6fb18e3310dfdf659490c400480453f77159c1c77a5e574df1c3471e9e873346b42141e941905c49e82153685cf83b8da7dc2594b63ec3b7743ca13f165f5131e1791202c1e412eeb857de46d74436e37b58f6b4e9185b186a456d9542cd0439a7c10c12bc929afd25358669371cde79c2935155c03035ee54fa0416f56302ed4094eab8774aabfac79f7164d751e59c83cc058201f84c71ba4023ed86c42cb01322da6101a2f42df35d1fa6a45ccb2104f91477b91ada546191057694f0ec5dca138b1bc616ba23eb831fddacdbf5be5c39485d1f25884bd56a30d76f6cd20e9d36a727ffb7c90062d0c72c9db89d8baac2dc4ef3731f8e0d1f0d7b7650655f1c15b3af5d29a27387080886e00859de003bcfcdc6f4c6a760579d31f27213e37e74789ebf9481e3da8d5d98450e4e293965e74afc3c67a441be331b3e5ec95c299fc8a389752452f1c1481b58b26e1a5ebcd34558977be377f2ba9d27ea5d6a464beb1ae201931f3d455e4b27385ff0490e7a00f633499a76113c629f777305a532d71b1ac834d9b6229930989fb85aac05562f2b55db71b462c22c7459aec75cd45c9788f15e309c622bee2ee2e10147d71db5f07ba6c5365da920fa96f526ef9c6fa815dd99d14e0576e9b18a11e87f20796931c1de5a875b2f9c14a4c4055b87045a7c99c638a0c0946631d1d86c7855f855f80e17ba979b41d4f7dfdcf79a853d3d426666dd20bc290108774decf73aeabaf99e4153863aa8bdc3c76395e18f9b16eb9ebcab2bbc8a54ab56c2f23a8d9b2336671264eaa2d61ec66fde5e6193ebff41135a61f25153a2cd3026a15a502abf5af44b6e137c95a0a0b17aadd560205e13e43f15b3d32c6329d5e30736303cf78599cd2da007dab7219a5db281d057d7cb87e713363ca1dda1d2e0bfd711ac3bffd3fe6d4ef3bc8fc5954a3d6cefe6f0577b7157a9dd6cf9f8a12d196ec217c025e3e8ba1fce3fc900c048671bb4fb9ddfb7c6b6daff073c9a5170ebccafb5183e3de948f3c0f40b823eca232ca0b1cd46dd50421f0096fdf1dfbe4beb0b63e1af43894972517c47811e96d55e3e03cdc9fe496a58c36dee050522ba529cef454956d2916dec59f862234ac9471c2d452146222e92a1ce2672385eaaf23194da6f1db1b562915ef45e19d89882fd20d9c6889d1cfd9ceddbd8bb67f1ee700faf8f0b2309c4f64209fcc3090d216d49a2b3dc500083cba46de9678f7a45265a73eef5c7b1bf21ef3cb6a8c24a7d2af45ff39f70d54d90e408613984b29c6c168c29fdfa35b86bd32ea5a5f5911e80b1cd7967948c181215344750e1482409d9e09a9d3a76eb939cd3edbf8a54765b801add048b0ddb9369acb6490824f09a5f959c6605c3d6feb33d2eecedf113d95a1e9cdb1ab96ac4a0b85d79d5089fa2cd58cde2cae1e6db4dd85c44fca44291de0b9f903194303b342a5073be3a4b65d94a684031ac965b2877d1ca2f308ce729402f31050a0d01c1b1f1a38a98876d7587b0f14922bc93d842aebf83f95ac280f1fc0f268b1bf5b9fd525031340bd0ec2b0b1eea649a80ee301ec6e1b97d81a5f79f67633bc01cfb433958c60ed5a89a1a12edb9bfa552d52ef137260ffe155d04c5acd9747d88e48c7d1e1cf7dc00b670cd93da741d9d95c9f03883733c4cf2c66863c93c429189d7c770ce7d4f891df160cae57691f372b701460fb44ddd7702560993b89d4a6a10fcaecbce64e0ab479db3ff4ca6309ab16e18777db44311ad5f87a7d8e7db658c2fae587857611c7f53c764918427e6ac0d2ea72ed78d0d5bf4610f456e0919363b723672f7398e7abdf8954e3e378c61a6346c5c23d8416150458f392daa998fba857c3f151b77bb0af204fb3dbb73efe2b3378b54e804de3f73cee84e2dc38e4e27ad8fe2521a1b271d7cbe48536f6dfb1286ebe30fd8e1004a0f9808fbd7d8d66819552e6a3c6efa660d4f0e436491003a8c035ff4e7dd99a48d248e3c75d4547bb254da4b60de5c918be54cd24cbcbaa4e4ff350e0c1f8470348879b2519d6d09f5e3f09bbcb5517442d32776e630c255a0f4136493b40bf0fde4a25dea0a090afabe3a2f4726705a58ad2c63dec7c1e10627be0abd404d5b044e7a473cae077690715f30d4a60b2426131227ce6da6bf381bac089088b06e3aea99f4ee2b4e7e98113e5efe759380aac150a6677965d176e41b776936312412df4d42c588b719844a5c695e606140fa3aab9f51096ccd1fe82d838536641fffcc7c44bb8fdace30da2f6dcea7e6502c173f78846d715a20be857a8065f6232fac2f57944028d54822b8259bcfaee52c443cbe554f963b79d98d49f7833a1e2f463d7dbff356f28dbe370b9379ec3da866865a83b54e98cc924f7c0aa75775ce985a46593767d932dc8cc17feec5b49e4ade067d073be09c932442f541d1dd4072b600f62302c91081ad618702ecd0ac3a978e21ab0812e3ac18b5e59b71026da3308d6ec92bf8ba415a0f95ee341e5d227a46329e0ede74ef266640d370ae63a7f99a35ea0d9c8eeba04d825eafd7cfef564de4ccab299558406f87c50931ccf05c299449373947db2f48b503022a08c5f59dfc5b5f5490210a644b92ca517c0c526c3002fda22c6b9f51341cd6939917b633bb8fce20a600035de6c84a64d206b8070d14d942292c3bbeeff233a79bee08c5dfc1556bc9cc9204bccb5af492e08b467457f631e7eca99de9fc416e7ba9ed7850531708b7d1c0c3735b44cebddaf0c3ac0f8de4adaaccf8870eb6b3303e224c1a1a78cbd330e9b478d7d4ff9860929468aae9f2cb4c7cae5ec172939a360a426fbbde4ecf16c3d31f761b14c6ae62f74498a396f64496ff402925981103cd67aa8158dd56ab14f5eabeb99418f5954fb4ed2946e7694a35830085027a2bc9d344e7d269725f077bd59fffa9ef3d57a43167f58039ce1b7e67dffa3c825c02ab5356481179528242ab402e7bcb6249bed975dddadb8f4b9e1f5f6f94ba6a5d9ab60d210b73902e0b92db9516b752bb0107539e861e9f9e1c0f5d08fefc5453d2d8c48a937574c2d1d379c9c1ab7521c25081cf144811f9936a2ab69ba4bea5dafc25e58042f10aaaa0f7959becab4b9389d5fdc827d858964435814ce1fd785341e91bdea3db8baf7ed1cf207dc9241881369bc410ec9222e1e8c8f5ad1f82c31382366d1625dacfd701ddb784776cdcccf188ec58b42ee175885edf189ad5be6e1e6ab31a8b9c5ba28419f3f7eea14bf9aaf1d9ced8cc9ac5f3fc3d34c5de9fb4181652a1c9c6390f4110ac085e2a53dda8e2cadeab403e99a3d5ae1f25a0c7ea738377e548f696c7e6c8114daf8029e7bdd778267560c21154ca2523b3075227b90738ab21f3a64c2221a686c1bfb1687d24f36424519f910dcd00c0469b7eab7d749e17acbdcb5a86751f2bb3726f13d0656cab37e453c8bd5ccdc5bbf2a9812e37a789a0e5ce28082e2ebbc946774997e3a54b99ebeb096c8308aff4db03d0eb9f1d88d489517775621d647d017853ef8bee80c5884c5fbfd32751808b635c93fb131fe8cdda09f92c14236674c0651e8c71dac680a9019e97d0c8361bc9a4cf9c861774897cc9732b97b8d624b59cf2e14ca9f307a82e3a349ed79a442ceb1ff15f5a89576f7c9e1c3cf9645f610f9c97b984544124c38c3df4fa876e6ed51cc89f918823056a302acc0f642a3a8e3f92f3606f1b65fe60473c24539625807ed32456bb3169628c7519c2a3be7163005e5ab3b5a9dd406491184dcba8e6912d91eefb9e</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-16</title>
    <link href="https://unit-serow.github.io/2020/03/17/%E9%9A%8F%E7%AC%94-2020-03-16/"/>
    <id>https://unit-serow.github.io/2020/03/17/%E9%9A%8F%E7%AC%94-2020-03-16/</id>
    <published>2020-03-17T10:45:31.000Z</published>
    <updated>2020-03-18T16:17:04.739Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="8116ac38fab485852be3541712d96fb071694491cde8fb6671ff5b03488be843">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e5bfc96044c62cf099706e61fd2bb0de2b982aeaa6c1addf26bccbf89281d3e351d52c977096fa17fee498a72ba24e0be01a31b030642292984296ef84aab71f8bac934e9a0daf69751f6902a5a21cec00187c54153ec988ea220a53a52e9118eaa1942200abbc64c18f8c99fd3a35c59cb7ff48f6372a22b933802dd98674a37855039e56238b0ebdfc40e5c698735cf529835538443eff6b3996440ceb726308da3fb383d7ab4cbef54e79c6ef2be1fdcebc890109a8e637b5ffa693f26154cbd348a6d2476ec7ca186a99a39dc28378f8da0459b7247c06adabf1dd8c6aca8929f5ef644715104cf60d2c7ff1178430de8561f830e7233b628b98fda9bf06cc4603bf6ab5768a18036df6bbe72cb5357d4dbe8a8cf7951901e910d1321af69776eef93d88d10d575aaa38296d1622fcc2620efc9b2b0f719e3dd0f940ac4d9777b1842ed886aaad91af685c89e11b7f4d8048c43d23bf69a15c30ad03e38b0bc995813f7772a24b61e6bae96a3a13d3237004de98067d849db58417e2dbe64e2aae62caec2eacf579d3e62173dbbc84b7bb179a2bd8ceb095a396bafecd19831c09ee7159ce60d20f59c54596271a650bf0a790e42f3e698b6afbf25ca4711915046796ef297ca8d0dddb3d9ba3fb6883ac9a6ad5150d93a6f7aa9c8e458f461f4e6d7edbe305cf4a0ea86ff5853bde6d298188077929c9041df84c68a206e1c794df2fb0ce1392d5d29cf3ae33ec7f1eeb08fd2e6c6756c508369e78ef97f90dbdab38cc2f2d02e19ccf7ec05759c672c0f6cc22bc6da45592f9a739649635aab55b39f6e8677fc6dd03b1996c1be41adc7fa8bd18fdb75b7ffdf58a3162e293dba7d71a922886bdd7d64cf83c16fc0544cf613a43c3ff9f635e4b14c2852068443af955229402d163ca7090512ecf5567ee96b9c4d3084154f2997937046a634de6a27d362a572d2d448fb11f7859df7ee3181448049a825cf38e647a0e8be7e51e64d226eba59e0a77638ce7d9e69266fad3a52fa7351ac1096f4d2a59644ee233429173a3bf51940151eb7799c790d83976ae41e05bcfeec5ad50a9f26726306c9a435be85ffff5c446ef0ca5d1c02aee74d1a167a757ead55b213fcf00df86379453419c145bbdc4152bb13ad9c45ad3d2cbd5c412ca37aafd8915bf084b59b99c449ba4339bc6a55b7d464b0ac5f583b62ad5d7196ab12459071c4fd19e75dde1f4077b2fa8eccdbf73433515587ca030a7082f66ef2d3b27a7a9e79fd93d3135858aca7b7f4468b8db37a1427f03ea492fecaf4f3916491347a5d53c0c5ffd0c18ad546de46ebe75cd93eb88c56b50ec04a95f83053fde26444b8efddfa4f5c8bcce6c24cbc7c2dfc052e0ee2e9e66f4ee29f3f1c50832f333fdd836e6413e42c7e434ecd8923332dc378d744a91d02020781d398a0ccfb525d2da04f79990c174c4509b5d200d03f674d7a156d9f6caf93d3644672f82805adbb42be38f49ebc4790a5d46ff0a32b56f32f72f852be6bb3463bcd141d0504ff4c431e1b30e932449ad5612bd9e2e6889c8ffbf2618ca46cfa7d886e24278acbbc3f56ee34fccf746df4dd3ac8132f0d8a3a0738800d5cc9dcdb01c46ae966359decf04da1d9d6bab874e568bcdf285d2961cd7d88ed548cd05b78673299dc590a73969fbaa61b13b31fc5be218d01eb7366cb51868b7c3e2d366b897c661e55def3d48c0247385c3eddbdd18e7c45b87a1570187d2da7514b0c81c3c44dbfc7675f920f5d5f0cca3242641cab7bc72c352850133c7bf87677d8fd00e65b560a9002939576532eefbea69ba2ce5c734ff93ab85679645e5a3287f10cffc0f853e0c347f38fcd2258f563822af89e8825507531d1acd62d5829d23a1a37cd7bba0c74b7e8fa2bd622a3a7540f6c4cf203fdba7f17cab641c6b5a2b34d1fc1511288d6bf30ca328e6d50db66c1c614ab1d801ab8116329ae2e4a377d73e2d65b6b63ec11f9d72f720dc7ec111048f300d398cbebd700de996abffb899214d2a2a4b45c529ca77262b26c15882b8e6098a12e794fdf7d6d01d3c4a1464b48213a10cc3be2d53524f8ab91e7176e70c94c79f82bb1af883784a8eb1724c779b822c9d73a94a5aae5cc6c6c7fd5d289ae1dfd9a6aa7c403267b2d6acb1eab8799a91a6073462b51d71bdd7cfce278445857584a75e197415467f89be59462d256f30d89c82755d79f349b1c792d2532f2b1ae727ff644286836825b8dd815a904c862ef3b82b3fa564c525c5168d89859903c299acdc78c757ca06be161ecb1ed03a04b13b714c58900932354c645e3bf1926381909003bc8469373e1f252bceedd93e289a571e3c81bad99663af1700a0a21a948f670798b1f5e8723430c6d37b48227cddeef79d4d7e5c4863acf84ecbbf6063b4f943a9b2a34d64116469bda91007288cdeb8dff16927748fa2e44ca8cece21dfe71ebf2f577f3363ff72f2122bbdf9a9a1ac1b8eea4740b19d7980f6b33b934e9823191b75e36a208ad850de8b95aa5e8fb2ffa9a6ef004737ffc26e5381053b4168280a039991277f79b411b4d960c474b2acebfd952f2784cf3052d0e7b43279732cb94f00f75111bf59dd4beda0f47da6eb29e8dd53733420bd15011fd5ef01753b4f9c2449be37a5a543379dbee6644f415450411ced99072b2330f0b1a9b2316d27df0d959c29536c40e909786a22ca7bc1b148c5745e83ac1a9e99eb71f53307c709a755d0b1c809113f23c6362f77cef6c7ce06b77b1d7bb99367221e061f7807c219b2d3b025f921cb42573284b72f0afc55dd79dd5aa10d064f2d7f8939f90c236244a73f79dc1f77c6c0f811c956e38ea33a7e2ecd3a6cd4478312375b10f27764d08f6903dbe9cad4fd91482bb3361c2443aca87dea4c1b3b4afa0ae9babdc1795f42b473b0726c8408bccf35fcee36d7f94e06f71a4205fbb5bee8f1393b88e1a71ff47c31e7685b7a145f2ddb09d54bb8770dafa4814611899ea9e923e1e6d30bb58befa17cce9220c853b43ebd019f468d2150cefd8cc4bc055f953e1312a3793042be5a4663a65019e6ee111b067b3871fc87a43e8a2c83b36d6263d430c0b75e293bd2eb99e48245b1368b6716df2c3ad650c9aa613a767f8fd6f43c2a073f45f20bed7cabff1639273ebf107a233c76177f60d3e714b05d6e0817d4c5ba00e192bdac3585979b226f21be6e3a63e6549ed9259f1ab38125025936ae5fa7b3af9975ba6137162f0b46dee92f337c89a33968b90fcfb6d47363f222e56a1af9dfa2c2cda604f77f624bf1851e3810215336cbe10d5807f0c9f60ddea69db7cbf27744d179a69445f1e00bbd24c8a5432bfe5d172a0eafeab45b99b1f232b9764ea564a102d50833dc3923ece25c930ce61a78204b24c7b367a1d2db63624d04fad7f81ef0ded59eece6345da2610013c7a118407f2fa28c4db3e357bcd9346cab6b8c9e7499fb312714d278c089f352c4ced492eaa501127f381b214dc9ae061ae87d811fcc5b1f59060d2b87db95ca51d3b311906daf9aadee3d68b0db6f3485503ba0448d2cb07167d72da46005469c32de88fdd570e4e08bf618e52af07eccd52dad20e9ba30338dba15b4001182d00906b4c05ab038b357623b2583c32883e64448e0e0c95c8155baaeb6235d295588c1af7adb710d0e48f28621873424d26f4f529f36511781549d6669d2283b1bedb4b90cb5d9f8a19d4dc63e269ce225763f3b08a07e4cf44e714ec354a5640fa79197468101e1690b976db61da459ac42df68f33f45a35b50ba54038d7168096574004e95257f36781a663dbcaf6cacc07c941e66dc2380a6f5b3cc5fa000029745a6225176d6f6eb5e4f2104f260e640af8a7fb888462e3693ef198e2fd84e66cde5ae9adff5e7273f8407d1b42faf12c2feaf8e33c1b0d5bec23ee79abc8dfc8e1e3ebae1743cf2da990542410c448c062537acaa965c08511306c2bb3845a821076a93fbee14fa51d7f542a3d960d0b405144d5ac962efa4f367a07e97f384198afafe7931253e2221048330da4902a040c6a74136de037ab9376a68f5ab51a57e22d57f423a1c3fe12dddfc43b5866608b7aaae9ad0aede8068574cbe584f55d1761c7c4bcbe1520b0070bb816cb4470faf80ba3b8fd5a1e38bc32bf1d21cf0687a9586a1b90bc16689d49534c8cd6c7bb59cb65f5d8ba12524459f5c8bc92791750fef4aaef955bd7f04f84762e32c28cdad25f14716bdc5567be350420f31449aa692dfc196a65ef2aa7e780c6e0ddc14bf01f629d9bad66dd1cab2f39b17bc7d1301eae625fc696cfd7baf968504f7d209b31e763f61e927ea5e0e7b1e56296b5a0f7865e08c05e4e32aa8cc72e313324ec2acca7a5d167a9d9396048bf280e5f3aec5a91d212b9b6acfef5a41f0f0a3feeaa41fbb23c7f84cef838efdfb153c226ebf489eb5ad779b7b0f6ee8298db560f4d4e9bcfe903a7680319bc5631f71b30ed1f722d200a8837e81bc424ebf62d7d80aa6e868b08c5ef062ddd214607a0932234792afeb8e4aa7eb83c32c9b757d731542ba93d1f4771ce20652eb79810563a6409822f3f748e1282551649d1593589ac63e4669de6812f6a0ac9a63eb7fc00a094bbd8b8e878150813ee86c2f3711be8b31d4e923d03cb85daf338a78b2be80a6810de7513ce0ffa9450851ad93c086ddcf035118894709c75c3a5eea868a7c3d5ec20b934cb79309b5fc886ca76518365491a91e93b1e9d3f3bbe614fb74d55a1c4929eecc6284ab8ecf3b3afa9b8df6b589068fa2d4d4a499b122978ffe7fadfd87e6847afaba65528d5831c4d67064cfd17c4600e2112227a0b8591eb14da3feb67900d2d9f436f1ade8d5562b677a6a6849d3381a6496baadf3460f51bd58d572db226236d88ea841ec3a3edad8856f4634db97e538c1ba4c47a5af2f5df94bc2343a1566d8044ebe392dcad144b1dfe8e9e9c3f416e74b15eb35b7c1b5ff6a30a87fcfb64a2d5bc25ee8c60cb2af07b882ffdd20e703dc909c72ab24bb0545f50aa597a5687795da2b727ce4d866fe302270203b141aea2acf79a71a067d0864e225b6c1342a58fcd8d44277e794f0814ecd54f0c409440d6a83188cf39875e61b761b60d7c436030f75a82012c377d89b016d22d8ac6c750ff001c4d645936c0cfef3b1c5bc2be465a8321c67b9eb337688c471e4b3d476fc3d0c7ecefb0f00b7c8b9993561bc2a71f8f290f8fb7e21a0f500994d961a52ebc24e4d2c09049c7f7237c811b5bfbceae553e624ce17de5278a35b66ba805b9e26b1c70940725cec2532dda387d52d0eec699b8d84734646cf40086eed0fd14124f336191068b044e31c5862927e58e8593cdce0d64693f725cdd4bf8890d17ec04dcc1fe06afafbab639e0839ef3c2ddba0abf1a7f474be4860e99a008dc73137484a95158bdc95c0a160fb8452e20f3d5b928b482f29f154058a0b85b8a71bf2c6bf803c23e53a83faa22ccc39ca8ba8a2eaea2d41636e9cbe55173a1362f8c491a936928d2e57c58dbf6db5ea46681dbfffab5656d6ad9f88cc96846be19f595754c0aa4e71359d1e1b41f23c515d5b9cf5f7e66367e06e21cbc39778c2b149227f0939c91cf7161c46a176cc9213d0315d014e137d77ca16812f1fc382e3b7a5bf19ba39602cf40c6a457a03a8356f4f164a3001f825774b4852d4b59b775ac1d11456f76c7561662b74ea328d5a543b5d376a59d1c6c541031ad8adabda8ce12fd6259cad61614441b15262a0dcb22878ec50970324eacc41bc7d16887e01ff133d41dd4190ef625d98d88cf11f7f3072738544d6e0d3127e6dbe1fe6657a079fedbeb0958bafb3f189f8906637238f0007cb84d772ca6bba5b72ada30c686fe865c043a97ca0e3dccaf89e98200b6b9805499a14e4649b7dcd7ea56c24ee757e516a4e45305ac85e6115bc9e81485226be2a808ae616f4ad91bfd719bc86967ce56e1c812edbab6e375ee80a478c68a5c035c9013094f7857113cdc0d68e7e7dc56bc0ddc007f5a89f8257d3e078f34bad8eadb71a60b4a892ff1e02804fae0562b7dcff1159f294a07b5986ff63ae1c473ca58d60f5826df209a9dfbde253484ed11a73776c4dc0c330be34fe681ba3919d83dcbc9ea177edc20457900bc9407184d5f4789cafb4b3c11399d4ec6ff533a2322c4b5cfdb3bb137fbe7c58375f5fae959ed450c86a87f89b4b0f25e72285b6f94f1089e1ef3fb6f3bd0f1b2a2efb9a9d298337badf7adc3f704f1435b9e9f9f090bc3c086c24c314a34648431d00e5e32bfcc59c922ea04f3b9c9504c08917301ba1a2987841a1d1ff82b2f5d6ffc6111bca2c8daae5d76c370329840d2a7093693be3ee367e886d132b1b9c4f55ffd247ab746954f593c22898a772618965e7cef8f20b3972d903e237828d885a87e7c99bd28849816634f4890ba07f6851567d080acbc5935f45421348d8f370a9f332e8bdc9c43dcc906b981ce6a3e39b3774e380bd28f328aac7e5017722c1c1332b6d70040c529a46ad2c5089ff0a74ac73376d8685d4cc0a307bfc6cdb235e4ab2734d73f0bf802f7c0cb39e4e3fc467ebdfcaa0bde8605d06bf471e717fcee3ff0fd201c5667e836960361725226dc425159c1b44ae1ac8d22ee6560c9a79052ff23ee62738cde361ecae61e2d84875e0ccd7cedd734b501c3cbc6e7a2de7d70d68a0451bb35c0a9d7aadb89012eac860edfe2a69b31b3279a669138a73a9309b1869370dc2dedf162838433e00e16a9153636a1440e2262626dc3f0746e4c24b6809f76d6f726070e5a0f511c7ba4bc6c6632edcf5c7acd1367006a356933547a95dac2a1d48d3229885a3906ec453e84c00e86cee24adef55a29af33b9c48f7d5a34bfd7892b7775db85bc03202d2a561640c5afbd2505dd9ce8babca2170b0414aac08463c0cd67aed4a4a904cd045bb2a16a5d5f94987c1c6b97053403cbc64e52ed4f535399926e3324eaf42692fb849dd47603f74c595bd351167079e2a0b1f644426f63c76f288816cb14a7ad6451e768eddd0a700a412ed40be2653f658882a0b92b7fd33bfb689fdd2ab881fdaaf4712486d4e6c70695266b87f5e2807cad1d4e4fe166ce2eebf9005dd471f9aad276bc69af8a5b66bbf00f23b7d67a3f11d0caae019aaa1b21bbca2128d35648b698adb1badd968c7a2d6c2dbf1faa0492b691eec6ef2fbe6087813b6f5429d2e83511a16e8a1e1e4d46bd07c09fe37299f139362e57051fbfd55454ed6b3be8f258d442465e5afa230857fd6d470833b7a2ac27def375fc754164aeb5dd03f3971ed2f37e09f76474daf7bb739ab5b1b06cbc55374de05340502a9769865f6314267d3f95fcc00536a89853f2759865b426b633057ce185ebd01206433ff293434889e95289efa72999ef2ac3ba4d2c4b53071a34604fb0d56b13dbadf07d1f5f357d9c07056628f990c5ae95cf1f2369742c00afd11e44fc1eea8160934bbfeab9ab40de71c038a1aadb45ba39ef0fa61b97a37b33e083c6de5e25c4e18f900377db5d9cb52aee997c6804f6d2430dda69db53bbabd58479c3cfbd96cd5fce0521ef631971324ef5d29a35fa72738ed9d108208a82d474dfeef540fa76ec7a462fa4c6905b4bc2f846644473372cb6ac925dba750d0e9a041347ee70cda23808aa8922fcb003156a43533fcbfe7a7d4be6437a8a759b1eef1aeb033d746f565bd8a2af38d8f4c52d296df2e6aa1ad45d252afe4f4b4bdf3e1d8c63fbc54a86a4e8582581743f96c74eea6a9a1d3b74ea62bfdf07d73e029f56f7776beff8df09f97a2ddb7c302de0b4915f4fa27e9e4dffad3af961533a27df2d0bf36b0cf3d4f1b11c3c2895ef0ce84b17fd446c11d8165e1fd27d70eb678f38ee2132fae852bbe70de4b4dbddb65a273b5cd1a8b23bfcd265a809f2e3fc700dcfa415446a952974a6729fe3ee7ce11a487123b7622939521fd63eb5596bdb352ce8298ede76c7762d7925a3c3c41875d6e74cad5030702c1a92194fc359f15dc30013290d93149a8733d222a333598d082a04b406b535883c5caf65a39decf52b381afe43db342127021ebde09908d7ee6c0b08344a1c04c596b78c52865ac34ba4f6d9fe4585e79c3612b8e8fbb4c3e31827458dd7c3c8ce3c52a4044809ac4a73b8a8eb6a4c9fe040be5910fa709f7f8007b88372fdc756f5a4998fe7f7df3e2cd602be2fecb49d1e6efbd31d6322701fd8703bbb075200fd4887d9728693dd5434ebc423b2d8222fb8710dfc7662661cec791edd63ad56207372ad046c5683c2b4ee45b6689087293152f92326551cae944450bd8cce98a958985fe133d311f3e87b7f319320fb0f3afd800223279dd936906112dd395f4a13b66e54d8cb599eb4b403313f7952f53544163a703886d19cbee4a0051f84d4baba8c7360dd52270b68df2463e064bb96e21fa9d0fa0afa4d4a2ae8733a38df359f946df9ce6daefd5a9892483250cd981b5e77b0e6559d2317a571df6fcfcbbd43e2a84602b121cb13968f935b2888f2cf137f822d69544fd31f93af081778a8b1bbb6c3120ccec13bb66adbc484053991a4441ea73704e226c15093fe427944d3c70e94f83abe6e0755a157572a42618cf4b9c431379b52639708f1bf034cd69f78ce67fdec9e9146bc1ee514c9cce427c6e58032ca7dce411f781c4b6b3d111eea9ff18d32395bf6dcad26a0cfc5a5a10ac73cfdcef0c1edfe739dfc440999c98f5c6be84bf2d31268f1f5b370adfcb81350ec9c214ce9f2f196c42a7834a298c362e5ff52fcd94bf9aee62419dea906da6f4b4a5dd2e17fc60eadef3f9d5ae13514a8ff1d664fe22dc61a668aa55d1d75c4771027aba203795230bc31d1ca1b3690a75da2db046336bade5782764f8d0c0956a07f975ca2ecd513dc44556fd421adb651db9fc29486896d1b78364834bf054f0c012c24ad8ffe578f32a06795c134d262de549d284f75bbea3590946a8dd7ffc205d9c2ae0c42ecab0191ae3ac6c3a2bd6d4a6ad1397878a8ceeb5c5b3d7eb1de1b08af6edabfdb885f20d063b59bc828b5815cee27bc919076615068e2b609e49a55ca02a6c5c6185b72131a3d2260af77c0bf23bf447ab77d8ba8690c71e5864c3be35ba874ee2972f9ef76a8572cd98ed8dc6413caf73de283fca430ef656b61bba821d88e35332447a04bb344dcd2b0e0e555f1fb5e7653ed077798fbbe1232434e881006189223fb0e3089f6a4ed4a50f7f8b347bffceb7773b4c75231d89f9e2f6b95a72ff8b0610c674855e114794ad16ba212e6da2aece95bdc3a654b60e9a0fce920998b725cbe01a2c0e102f9b267eedbc03d91e974fbdd21645e751c78aa72b0972cca113e2496e1f06fd8a8fa98a7c1bf4093106196902c8efe841a7b88b0361497839bd13ba1c63d84c1dd471d89038e56a4b48777bd93f007000e</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-8</title>
    <link href="https://unit-serow.github.io/2020/03/17/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8/"/>
    <id>https://unit-serow.github.io/2020/03/17/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8/</id>
    <published>2020-03-17T03:41:51.000Z</published>
    <updated>2020-03-19T09:01:00.042Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 17:01:07 GMT+0800 (中国标准时间) --><center><strong>数据类型-I/O-1</strong></center><a id="more"></a><h3 id="数据类型-8"><a href="#数据类型-8" class="headerlink" title="数据类型-8"></a>数据类型-8</h3><ul><li>C I/O 原理解析-1</li></ul><hr><h3 id="字符输入-输出与输入验证"><a href="#字符输入-输出与输入验证" class="headerlink" title="字符输入/输出与输入验证"></a>字符输入/输出与输入验证</h3><hr><p><strong>相关内容:</strong></p><ul><li>输入，输出以及缓冲输入和无缓冲输入的区别</li><li>通过键盘模拟文件结尾条件</li><li>使用重定向将程序与文件相连接</li><li>创建更完善的用户界面</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>输入(input)&amp;输出(output)</li><li>常见的输入和输出设备<blockquote><p>包括如键盘，U盘，扫描仪和激光打印机等</p></blockquote></li><li>如何处理输入数据和输出数据</li><li>执行输入和输出任务的函数<blockquote><p>即用于输入和输出的函数(简称I/O函数)</p></blockquote></li><li>I/O函数(如printf()，scanf()，getchar()，putchar()等)<blockquote><p>其负责将信息传送到程序中<br>I/O函数的基本概念解析</p></blockquote></li><li>关于设计与用户交互的界面</li></ul><hr><p><strong>关于C 的 I/O 函数</strong></p><ul><li>最初，输入/输出函数不是C定义的一部分<blockquote><p>C把开发这些函数的任务留给编译器的实现者来完成<br>在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型<br>ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些极为常用的<br>由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性<br>因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数<br>其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面<br>这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序<br>这里所提及的 I/O函数 是所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统<br>处理文件输入/输出 的程序也可以使用这些函数<br>许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配，此时则需要输入验证相关的问题和解决方案</p></blockquote></li></ul><hr><h3 id="单字符I-O"><a href="#单字符I-O" class="headerlink" title="单字符I/O"></a>单字符I/O</h3><ul><li><p>即为getchar()和putchar()</p><blockquote><p>getchar()和putchar()每次只处理一个字符<br>虽然效率对于人为编写与阅读的不佳，但这种方法很适合计算机<br>并且这是绝大多数文本(即，普通文字)处理程序所用的核心方法<br>这里会提到有关这些函数的工作方式</p></blockquote></li><li><p>自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联</p><blockquote><p>这就是为什么程序中要包含这个头文件的原因<br>实际上getchar()和putchar()都不是真正的函数，它们被定义为供预处理器使用的宏</p></blockquote></li><li><p>如果在程序中同时使用了getchar()和putchar()函数</p><blockquote><p>在运行程序后，getchar()函数会将用户以键盘输入的值传递至程序中的putchar()函数<br>然后putchar()函数会将值直接显示/输出在/至屏幕上<br>其涉及概念即为关于C的键盘输入处理，缓冲和标准输入文件</p></blockquote></li></ul><hr><h3 id="C-缓冲区"><a href="#C-缓冲区" class="headerlink" title="C 缓冲区"></a>C 缓冲区</h3><ul><li><p>在老式操作系统中运行getchar()函数的输入循环并以putchar()进行输出</p><blockquote><p>其系统在回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入<br>即正在等待的程序可立即使用输入的字符<br>而现在的大部分系统在用户按下Enter键之前不会重复打印刚输入的字符<br>这种输入形式属于缓冲输入</p></blockquote></li><li><p>此时用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区</p><blockquote><p>按下Enter键后，程序才可使用用户输入的字符</p></blockquote></li><li><p>以下图片比较了这两种输入:</p></li><li><p>缓冲输入和无缓冲输入:</p></li></ul><img src="/images/数据类型-8/缓冲输入和无缓冲输入-1.png" width="40%" height="40%"><hr><p><strong>关于缓冲区的存在意义:</strong></p><ul><li><p>首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间</p><blockquote><p>其次，如果用户打错字符，可以直接通过键盘修正错误<br>即当最后按下Enter键时，传输的是正确的输入</p></blockquote></li><li><p>虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入</p><blockquote><p>例如在游戏中，玩家通常希望按下一个键就执行相应的指令<br>因此，缓冲输入和无缓冲输入都有用武之地</p></blockquote></li><li><p>缓冲分为两类: 完全缓冲I/O和行缓冲I/O</p></li><li><p>完全缓冲 I/O</p><blockquote><p>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)<br>其通常出现在文件输入中<br>缓冲区的大小取决于系统，常见的大小是512字节和4096字节</p></blockquote></li><li><p>行缓冲 I/O</p><blockquote><p>行缓冲I/O指的是在出现换行符时刷新缓冲区<br>键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区</p></blockquote></li></ul><p><strong>关于使用缓冲输入还是无缓冲输入</strong></p><ul><li>ANSI C和后续的C标准都规定输入是缓冲的<blockquote><p>不过最初K&amp;R把这个决定权交给了编译器的编写者<br>ANSI C决定把缓冲输入作为标准的原因是: 一些计算机不允许无缓冲输入<br>如果当前使用的计算机允许无缓冲输入，那么当前所用的C编译器很可能会提供一个无缓冲输入的选项<br>例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数<br>其原型都在conio.h头文件中<br>这些函数包 括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数(回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击 键后对应的字符不显示)<br>UNIX系统使用另一种不同的方式控制缓冲<br>在UNIX系统中，可以使用ioctl()函数(该函数属于UNIX库，但是不属于C标准)指定待输入的类型，然后用getchar()执行相应的操作<br>在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用<br>总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统<br>这里假设所有的输入都是缓冲输入，即不会涉及无缓冲输入</p></blockquote></li></ul><hr><p><strong>有关结束键盘输入</strong></p><ul><li>在某些程序中，只要输入的字符中不含#，那么程序在读到#时才会结束<blockquote><p>同时#也是一个普通的字符，有时在程序中不免会用到<br>所以应该用一个文本中用不到的字符来标记输入完成<br>此时就实现了让这样的字符不会无意间出现在输入中，即在不希望结束程序的时候终止程序时</p></blockquote></li></ul><hr><h3 id="文件-amp-流-amp-键盘-输入"><a href="#文件-amp-流-amp-键盘-输入" class="headerlink" title="文件&amp;流&amp;键盘-输入"></a>文件&amp;流&amp;键盘-输入</h3><p><strong>文件输入:</strong></p><ul><li><p>文件(file)是存储器中储存信息的区域</p><blockquote><p>通常，文件都保存在某种永久存储器中(如，硬盘，U盘或DVD等)<br>毫无疑问，文件对于计算机系统 相当重要<br>例如编写的C程序就保存在文件中，同时用来编译C程序的程序也保存在文件中<br>后者说明，某些程序需要访问指定的文件<br>当编译储存在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容<br>当编译器处理完后，会关闭该文件<br>其他程序，例如文字处理器，不仅要打开，读取和关闭文件，还要把数据写入文件</p></blockquote></li><li><p>C 是一门强大且灵活的语言，有许多用于打开，读取，写入和关闭文件的库函数</p><blockquote><p>从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件<br>这些直接调用操作系统的函数被称为底层 I/O (low-level I/O)<br>由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做<br>然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件<br>这涉及创建用于处理文件的标准模型和一套标准I/O函数<br>在这一层面上，具体的C实现负责处理不同系统的差 异，以便用户使用统一的界面</p></blockquote></li></ul><p><strong>有关 I/O 的差异问题:</strong></p><ul><li><p>例如，不同的系统储存文件的方式不同</p><blockquote><p>有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处<br>而有些系统在文件中创建一份文件描述</p></blockquote></li><li><p>在处理文件方面</p><blockquote><p>有些系统使用单个换行符标记行末尾<br>而其他系统可能使用回车符和换行符的组合来表示行末尾</p></blockquote></li><li><p>文件大小方面</p><blockquote><p>有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量</p></blockquote></li><li><p>如果使用标准I/O包，就不用考虑这些差异</p><blockquote><p>此时可以使用<code>if(ch == &#39;\n&#39;)</code>来检查换行符<br>即使用系统实际用的是回车符和换行符的组合来标记行末尾<br>I/O函数会在两种表达式法之间相互转换</p></blockquote></li><li><p>从概念上看，C程序处理的是流而不是直接处理文件</p><blockquote><p>流(stream)是一个实际输入或输出映射的理想化数据流<br>这意味着不同属性和不同种类的输入，由属性更统一的流来表示<br>于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成</p></blockquote></li><li><p>这里着重理解 C 把输入和输出设备视为存储设备上的普通文件</p><blockquote><p>尤其是把键盘和显示设备视为每个C程序自动打开的文件<br>有关对于文件的深入讨论这里不做多余赘述</p></blockquote></li><li><p>stdin流表示键盘输入，stdout流表示屏幕输出</p><blockquote><p>getchar()，putchar()，printf()和scanf()函数都是标准I/O包的成员，负责处理这两个流<br>以上的内容则说明了可以用处理文件的方式来处理键盘输入<br>例如， 程序读文件时要能检测文件的末尾才知道应在何处停止<br>因此，C 的输入函数内置了文件结尾检测器<br>既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入<br>下面会从文件开始讨论如何结束文件</p></blockquote></li></ul><hr><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><ul><li><p>计算机操作系统要以某种方式判断文件的开始和结束</p><blockquote><p>检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾<br>CP/M，IBMDOS和MS-DOS的文本文件曾经用过这种方法<br>如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾<br>这曾经是操作系统使用的唯一标记， 不过现在有一些其他的选择，例如记录文件的大小<br>所以现代的文本文件不 一定有嵌入的Ctrl+Z<br>但是如果有，该操作系统会将其视为一个文件结尾标记</p></blockquote></li><li><p>以下图片演示了这种方法:</p></li><li><p>带文件结尾标记的文件:</p></li></ul><img src="/images/数据类型-8/带文件结尾标记的文件-1.png" width="40%" height="40%"><hr><ul><li><p>操作系统使用的另一种方法是储存文件大小的信息</p><blockquote><p>如果文件有3000字节，程序在读到3000字节时便达到文件的末尾<br>MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z<br>新版的DOS也使用这种方法处理文本文件<br>UNIX使用这种方法处理所有的文件<br>无论操作系统实际使用何种方法检测文件结尾<br>在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值<br>即EOF(end of file的缩写)<br>scanf()函数检测到文件结尾时也返回EOF<br>通常， EOF定义在stdio.h文件中:<br><code>#define EOF (-1)</code></p></blockquote></li><li><p>为什么是-1?</p><blockquote><p>因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集<br>但是，如果系统能识别扩展字符集，该函数的返回值可能在 0～255之间<br>无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 文件结尾<br>某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同<br>如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题<br>这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号</p></blockquote></li></ul><p><strong>关于如何在程序中使用EOF</strong></p><ul><li><p>把getchar()的返回值和EOF作比较</p><blockquote><p>如果两值不同，就说明没有到达文件结尾<br>也就是说，可以使用下面这样的表达式:<br><code>while ((ch = getchar()) != EOF)</code><br>如果正在读取的是键盘输入不是文件的情况:<br>绝大部分系统(不是全部)都有办法通过键盘模拟文件结尾条件</p></blockquote></li><li><p>这里以该程序举例(echo_eof.c):</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在使用EOF时需要注意下面几点:</li></ul><ol><li>不用定义EOF，因为stdio.h中已经定义过了</li><li>不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值</li><li>变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数<blockquote><p>但是EOF的值是-1<br>还好，getchar()函数实际返回值的类型是 int，所以它可以读取EOF字符<br>如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式</p></blockquote></li><li>由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据<blockquote><p>ch是整数不会影响putchar()，该函数仍然会打印等价的字符<br>使用该程序进行键盘输入，要设法输入EOF字符<br>不能只输入字符 EOF，也不能只输入-1(输入-1会传送两个字符: 一个连字符和一个数字 1)</p></blockquote></li><li>正确的方法是，必须找出当前系统的要求<blockquote><p>例如，在大多数UNIX和 Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号<br>许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号<br>一些系统把任意位置 的Ctrl+Z解释成文件结尾信号</p></blockquote></li></ol><ul><li><p>下面是在UNIX系统下运行echo_eof.c程序的缓冲示例:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Lord　<span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">Lord　</span><span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">[Ctrl+D]</span></span><br></pre></td></tr></table></figure></li><li><p>每次按下Enter键，系统便会处理缓冲区中储存的字符</p><blockquote><p>并在下一行打印该输入行的副本<br>这个过程一直持续到以UNIX风格模拟文件结尾(按下Ctrl+D)<br>在PC中，要按下Ctrl+Z</p></blockquote></li><li><p>既然<code>echo_eof.c</code>程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么</p><blockquote><p>假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止<br>或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据<br>用<code>echo_eof.c</code>来储存在文件中输入的内容<br>假设同时使用这两种方法: 把输入从一个文件定向到<code>echo_eof.c</code>中，并把输出发送至另一个文件<br>然后便可以使用<code>echo_eof.c</code>来拷贝文件<br>这个小程序有查看文件内容，创建一个新文件，拷贝文件的潜力<br>关键是要控制输入流和输出流</p></blockquote></li><li><p>注意模拟EOF和图形界面</p><blockquote><p>模拟EOF的概念是在使用文本界面的命令行环境中产生的<br>在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号<br>但是在一些实际应用中，却不能很好地转换成图形界面(如Windows和Macintosh)<br>这些用户界面包含更复杂的鼠标移动和按钮点击<br>程序要模拟EOF的行为依赖于编译器和项目类型<br>例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的 设置</p></blockquote></li></ul><hr><p><strong>待补充</strong></p><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><hr><h3 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h3><ul><li><p>输入和输出涉及函数，数据和设备</p><blockquote><p>例如，假设某一个程序内使用输入函数getchar()用作被设定内容的输出方法<br>输出设备这里将其假设为键盘，输入数据流由字符组成</p></blockquote></li><li><p>假设此时希望输入函数和数据类型不变，仅改变程序查找数据的位置</p></li><li><p>程序判断查找输入的位置的方法与逻辑:</p><blockquote><p>在默认情况下，C程序使用标准I/O包查找标准输入作为输入源<br>即为stdin流，它是把数据读入计算机的常用方式<br>它可以是一个过时的设备，如磁带，穿孔卡或电传打印机<br>或者(假设)是键盘，甚至是一 些先进技术，如语音输入<br>然而，现代计算机非常灵活，可以让它到别处查找输入<br>尤其是，可以让一个程序从文件中查找输入，而不是从键盘</p></blockquote></li><li><p>程序可以通过两种方式使用文件</p><blockquote><p>第一种方法:<br>显式使用特定的函数打开文件，关闭文件，读取文件，写入文件，诸如此类，这里不对此种方法进行过多赘述<br>第二种方法:<br>设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出<br>换言之，把stdin流重新赋给文件<br>继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么 位置获取数据<br>虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，一般会用于普通的文件处理技术<br>重定向的一个主要问题与操作系统有关，与C无关<br>尽管如此，许多C 环境中(包括UNIX，Linux和Windows命令提示模式)都有重定向特性<br>而且一些C实现还在某些缺乏重定向特性的系统中模拟它<br>在UNIX上运行苹果 OS X，可以用UNIX命令行模式启动Terminal应用程序</p></blockquote></li></ul><hr><h3 id="UNIX-amp-Linux-amp-Windows-重定向"><a href="#UNIX-amp-Linux-amp-Windows-重定向" class="headerlink" title="UNIX&amp;Linux&amp;Windows-重定向"></a>UNIX&amp;Linux&amp;Windows-重定向</h3><p><strong>UNIX</strong></p><ul><li>UNIX(运行命令行模式时)，Linux(ditto)和Window命令行提示(模仿旧式DOS命令行环境)都能重定向输入，输出<blockquote><p>重定向输入让程序使用文件而不是键盘来输入<br>重定向输出让程序输出至文件而不是屏幕</p></blockquote></li></ul><ol><li>重定向输入</li></ol><ul><li><p>假设已经编译了<code>echo_eof.c</code>程序，并把可执行版本放入一个名为<code>echo_eof</code>(或者在Windows系统中名为<code>echo_eof.exe</code>)的文件中</p><blockquote><p>运行该程序，输入可执行文件名: <code>echo_eof</code><br>该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入<br>现在，假设要用该程序处理名为words的文本文件<br>文本文件(text file)是内含文本的文件，其中储存的数据是人类可识别的字符<br>文件的内容可以是 一篇散文或者C程序<br>内含机器语言指令的文件(如储存可执行程序的文 件)不是文本文件<br>由于该程序的操作对象是字符，所以要使用文本文件<br>只需用此命令代替上面的命令即可: <code>echo_eof &lt; words</code><br>符号是UNIX和DOS/Windows的重定向运算符<br>该运算符使words文件与stdin流相关联，把文件中的内容导入<code>echo_eof</code>程序<br><code>echo_eof</code>程序本身并不知道(或不关心)输入的内容是来自文件还是键盘<br>它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾<br>因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备</p></blockquote></li><li><p>重定向需要注意的几点</p><blockquote><p>对于UNIX，Linux和Windows命令提示，&lt;两侧的空格是可选的<br>一些系统，如AmigaDOS(那些喜欢怀旧的人使用的系统)，支持重定向<br>但是在重定向符号和文件名之间不允许有空格</p></blockquote></li><li><p>下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示符</p><blockquote><p>在Windows/DOS系统中见到的DOS提示可能是A&gt;或C&gt;</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo_eof &lt; <span class="built_in">words</span></span><br><span class="line">The world <span class="keyword">is</span> too much <span class="keyword">with</span> us: late <span class="keyword">and</span> soon,</span><br><span class="line">Getting <span class="keyword">and</span> spending, we lay waste our powers:</span><br><span class="line">Little we see <span class="keyword">in</span> Nature <span class="keyword">that</span> <span class="keyword">is</span> ours;</span><br><span class="line">We have <span class="keyword">given</span> our hearts away, a sordid boon!</span><br><span class="line">$</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li>重定向输出</li></ol><ul><li>现在假设要用<code>echo_eof</code>把键盘输入的内容发送到名为mywords的文件中<blockquote><p>然后，输入以下命令并开始输入:<br><code>echo_eof &gt; mywords</code></p><blockquote><p>符号是第2个重定向运算符<br>? 它创建了一个名为mywords的新文件，然后把<code>echo_eof</code>的输出(即为人为去输入字符的副本)重定向至该文件中<br>重定向把stdout从显示设备(即为显示器)赋给mywords文件<br>如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容(但是，许多操作系统有保护现有文件的选项，使其成为只读文件)<br>所有出现在屏幕的字母都是人为进行输入的，其副本储存在文件中<br>在下一行的开始处按下Ctrl+D(UNIX)或Ctrl+Z(DOS)即可结束该程序<br>还有一点就是必须在每行的末尾单击Enter键才能把缓冲区的内容发送给程序</p></blockquote></blockquote></li></ul><hr><ol start="3"><li>组合重定向</li></ol><ul><li><p>现在假设希望制作一份mywords文件的副本，并命名为savewords</p><blockquote><p>只需输入以下命令即可:<br><code>echo_eof &lt; mywords &gt; savewords</code><br>下面的命令也起作用，因为命令与重定向运算符的顺序无关:<br><code>echo_eof &gt; savewords &lt; mywords</code><br>注意: 在一条命令中，输入文件名和输出文件名不能相同<br><code>echo_eof &lt; mywords &gt; mywords....&lt;--错误</code><br>原因是&gt; mywords在输入之前已导致原mywords的长度被截断为0</p></blockquote></li><li><p>总之，在UNIX，Linux或Windows/DOS系统中使用两个重定向运算符(&lt;和&gt;)时，要遵循以下原则:</p><blockquote><p>重定向运算符连接一个可执行程序(包括标准操作系统命令)和一个数据文件<br>不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序<br>使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件<br>通常，文件名和运算符之间的空格不是必须的<br>除非是偶尔在UNIX shell，Linux shell或Windows命令行提示模式中使用的有特殊含义的字符<br>例如刚才的<code>echo_eof&lt;words</code></p></blockquote></li><li><p>以上介绍的都是正确的例子，下面来看一下错误的例子:</p><blockquote><p>addup和count 是两个可执行程序，fish和beets是两个文本文件:</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fish &gt; <span class="keyword">beets</span>←违反第<span class="number">1</span>条规则</span><br><span class="line"><span class="keyword">addup </span>&lt; <span class="built_in">count</span>←违反第<span class="number">1</span>条规则</span><br><span class="line"><span class="keyword">addup </span>&lt; fish &lt; <span class="keyword">beets</span>←违反第<span class="number">2</span>条规则</span><br><span class="line"><span class="built_in">count</span> &gt; <span class="keyword">beets </span>fish←违反第<span class="number">2</span>条规则</span><br></pre></td></tr></table></figure></li><li><p>UNIX，Linux或Windows/DOS还有&gt;&gt;运算符，该运算符可以把数据添加到现有文件的末尾</p><blockquote><p>而 | 运算符能把一个文件的输出连接到另一个文件的输入<br>其它更加深入的内容可参考书籍: UNIX Primer Plus，Third Edition(Wilson，Pierce和Wessler合著)</p></blockquote></li></ul><p><strong>其它内容:</strong></p><ul><li><p>绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序</p><blockquote><p>或只在C编译器允许的情况下重定向C程序<br>假设prog是可执行程序名，file1和file2是文件名</p></blockquote></li><li><p>把输出重定向至文件: &gt;</p><blockquote><p><code>prog &gt;file1</code></p></blockquote></li><li><p>把输入重定向至文件: &lt;</p><blockquote><p><code>prog &lt;file2</code></p></blockquote></li><li><p>组合重定向:</p><blockquote><p><code>prog　&lt;file2　&gt;file1</code><br><code>prog　&gt;file1　&lt;file2</code></p></blockquote></li><li><p>这两种形式都是把file2作为输入，file1作为输出</p></li><li><p>一些系统要求重定向运算符左侧有一个空格，右侧没有空格</p><blockquote><p>而其他系 统(如UNIX)允许在重定位运算符两侧有空格或没有空格</p></blockquote></li></ul><hr><p><strong>关于创建更友好的用户界面:</strong></p><ul><li>大部分人偶尔会写一些中看不中用的程序<blockquote><p>还好，C提供了大量工具让输入更顺畅，处理过程更顺利<br>不过，学习这些工具会导致新的问题<br>最基本的要求是让交互数据输 入更方便<br>并且减少错误输入的影响</p></blockquote></li></ul><hr><p><strong>关于使用缓冲输入:</strong></p><ul><li>缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入<blockquote><p>但是，在使用输入的字符时，它也会给程序员带来麻烦<br>一般的缓冲输入会要求用户按下Enter键发送输入<br>但同时这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符</p></blockquote></li></ul><hr><p><strong>关于混合数值和字符输入:</strong></p><ul><li><p>假设程序要求用getchar()处理字符输入，用scanf()处理数值输入</p><blockquote><p>这两个函数都能很好地完成任务，但是不能把它们混用<br>因为getchar()读取每个字符，包括空格，制表符和换行符<br>而scanf()在读取数字时则会跳过空格，制表符和换行符</p></blockquote></li><li><p>要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格</p><blockquote><p>另外，如果该程序不在getchar()测试时<br>而在scanf()阶段终止程序会更好</p></blockquote></li></ul><hr><p><strong>关于输入验证:</strong></p><ul><li>在实际应用中，用户不一定会按照程序的指令行事<blockquote><p>用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败<br>作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误<br>这样才能编写出能检测并处理这些问题的程序</p></blockquote></li></ul><hr><h3 id="输入流和数字"><a href="#输入流和数字" class="headerlink" title="输入流和数字"></a>输入流和数字</h3><ul><li><p>在编写处理错误输入的代码时应该很清楚C是如何处理输入的</p></li><li><p>考虑下面的输入:</p><blockquote><p><code>is 28 12.4</code><br>在人类的眼中，它就像是一个由字符，整数和浮点数组成的字符串<br>但是对 C 程序而言，这是一个字节流<br>第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等<br>所以，如果<code>get_long()</code>函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字<br>因为这些数字只是该输入行中的其他字符:</p></blockquote><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while ((<span class="name">ch</span> = getchar()) != '\n')</span><br><span class="line">putchar(<span class="name">ch</span>)<span class="comment">; // 处理错误的输入</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值</p></blockquote></li><li><p>例如，考虑下面的输入:</p><blockquote><p><code>42</code><br>如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中<br>如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中<br>如果使用%d转换说明，scanf()同样会读取两个字符<br>但是随后会计算出它们对应的整数值: 4×10+2，即42，然后将 表示该整数的二进制数储存在int类型的变量中<br>如果使用%f转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0<br>用内部的浮点表示法表示该值，并将结果储存在float类型的变量中</p></blockquote></li><li><p>简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值</p><blockquote><p>使用转换说明(如%d或%f)限制了可接受输入的字符类型<br>而getchar()和使用%c的scanf()接受所有的字符</p></blockquote></li></ul><hr><p><strong>关于菜单浏览:</strong></p><ul><li><p>许多计算机程序都把菜单作为用户界面的一部分</p><blockquote><p>菜单给用户提供方便的同时，却给程序员带来了一些麻烦</p></blockquote></li><li><p>将会涉及的问题:</p></li><li><p>菜单给用户提供了一份响应程序的选项</p><blockquote><p>假设有下面一个例子:</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter the letter of your choice:</span><br><span class="line">a. advice <span class="keyword">b. </span><span class="keyword">bell</span></span><br><span class="line"><span class="keyword">c. </span><span class="built_in">count</span> q. quit</span><br></pre></td></tr></table></figure></li><li><p>理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务</p><blockquote><p>作为一名程序员，自然希望这一过程能顺利进行<br>因此，第1个目标是: 当用户遵循指令时程序顺利运行<br>第2个目标是: 当用户没有遵循指令时，程序也能顺利运行<br>显而易见，要实现第2个目标难度较大，因为很难预料用户在使用程序时的所有错误情况<br>现在的应用程序通常使用图形界面，可以点击按钮，查看对话框，触摸图标<br>而不是示例中的命令行模式<br>但是，两者的处理过程大致相同: 给用户提供选项，检查并执行用户的响应，保护程序不受误操作的影响<br>除了界面不同，它们底层的程序结构也几乎相同<br>但是，使用图形界面更容易通过限制选项控制输入</p></blockquote></li></ul><hr><p><strong>关于任务</strong></p><ul><li>这里将更具体地分析一个菜单程序需要执行哪些任务</li><li>它要获取用户的响应，根据响应选择要执行的动作<blockquote><p>另外，程序应该提供返回菜单的选项</p></blockquote></li><li>C 的switch语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签<blockquote><p>使用while语句可以实现重复访问菜单的功能<br>因此写出以下伪代码:<br>获取选项<br>当选项不是’q’时<br>转至相应的选项并执行<br>获取下一个选项</p></blockquote></li></ul><hr><p><strong>关于让使执行更顺利</strong></p><ul><li><p>当决定实现某个程序时</p><blockquote><p>就要开始考虑如何让程序顺利运行(顺利运 行指的是，处理正确输入和错误输入时都能顺利运行)<br>例如，能做的是让”获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch<br>这表明需要为输入过程提供一个只返回正确响应的函数</p></blockquote></li><li><p>混合字符和数值输入会产生一些问题，创建菜单也有这样的问题</p></li><li><p>还要注意在处理较复杂的任务时，如何让函数把任务委派给另一个函数</p><blockquote><p>这样让程序更模块化</p></blockquote></li></ul><hr><p><strong>关键概念:</strong></p><ul><li><p>C程序把输入作为传入的字节流</p><blockquote><p>getchar()函数把每个字符解释成一个字符编码<br>scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值<br>许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出</p></blockquote></li><li><p>程序通常接受特殊形式的输入</p><blockquote><p>可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况<br>让程序更强健更友好</p></blockquote></li><li><p>对于一个小型程序，输入验证可能是代码中最复杂的部分</p><blockquote><p>处理这类问题有多种方案<br>例如，如果用户输入错误类型的信息，可以终止程序<br>也可以给用户提供有限次或无限次机会重新输入</p></blockquote></li></ul><hr><p><strong>本章小结:</strong></p><ul><li><p>许多程序使用 getchar()逐字符读取输入</p><blockquote><p>通常，系统使用行缓冲输入， 即当用户按下Enter键后输入才被传送给程序<br>按下Enter键也传送了一个换行符，编程时要注意处理这个换行符<br>ANSI C把缓冲输入作为标准</p></blockquote></li><li><p>通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同文件形式，是C语言的特性之一</p><blockquote><p>getchar()和scanf()函数也属于这一系列<br>当检测到文件结尾时，这两个函数都返回EOF(被定义在stdio.h头文件中)<br>在不同系统中模拟文件结尾条件的方式稍有不同<br>在UNIX系统中，在一行开始处按下Ctrl+D可以模拟文件结尾条件<br>而在DOS系统中则使用Ctrl+Z</p></blockquote></li><li><p>许多操作系统(包括UNIX和DOS)都有重定向的特性，因此可以用文件代替键盘和屏幕进行输入和输出</p><blockquote><p>读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号，或者用于重定向文件<br>混合使用getchar()和scanf()时，如果在调用getchar()之前，scanf()在输 入行留下一个换行符会导致一些问题<br>不过，意识到这个问题就可以在程序中妥善处理</p></blockquote></li><li><p>编写程序时，要认真设计用户界面</p><blockquote><p>事先预料一些用户可能会犯的错误<br>然后设计程序妥善处理这些错误情况</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 17:01:07 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-I/O-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>时间-1</title>
    <link href="https://unit-serow.github.io/2020/03/15/%E6%97%B6%E9%97%B4-1/"/>
    <id>https://unit-serow.github.io/2020/03/15/%E6%97%B6%E9%97%B4-1/</id>
    <published>2020-03-15T15:46:16.000Z</published>
    <updated>2020-03-15T15:53:03.583Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="1e21f81d830478451ab63f438cd662ef35255d39e958191606f76d01fb97b0ea">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98a62b73e77af59b9cd3454122c1346448074168c988fe0e33b625d06400df3f78fc4a87f846afa70aefd1c403d0e13605c4bce5de651a0842f943d7167d9920047b4de52c3b7581d3d85a379edd6972074d02a2db031f367601791f4a6f0aff711c83caa86aa5b637945d3df6a6b317e392d0db246bbacb41987b5b1741c9c37a26ce7bb04077c07d1fa590e516919d0c06582b3c087b57819f8324be3ebdd5fb6e6b3508685652df38c4c9522ecdf2638a622fc55920b7fb0d843ba6591b627ea878b1200a6ff3e981e96416b4d8b1a283b9172e1bfb6d102aec191174f884fe13baa17de3c1d3201dea6daee52744e83ee0c518aeaaba3bab81213e65f37121130908d356a7dddf857467b315e90609472cb6d6d2493bf110ed74f1feacba2131a35282dabb80a4d3f159b84c84eaf63336736c8cab3e8fa2995590ca481c16e2178530e751ca08c3018645328317c2d03237c5f4b577cb5941d691363e7dcaaf8597ef2a29560b515e8e18aa8be404ba96ae3a1c12017fb4cdca58f27c751032033d4ec14886ad25ffce845cdc8fd726c9230b3b54a8f0aece6fb8da3d8190a605acdf2feb3846882425d1c2126f8bcaea1c2743afbdc2e30a182ffcc5552ee9afbd354ca05fc38bb79beb51ffa5b9d27f42ae7f47dad62631f84bc72fdd9bf6947f80506599265e47ae180b01196d470230bb207c1db4f0702827b1d8009367689418b9fcff526b30a25ce3e434cd92e3ee2267e27585130bd51542e7acaad36f95087be2a85fefac1be66e087028565cb322d7086ac7bd6da0a62c600933324f1a336103ef0b25eefbf3904c79ace1ec1c471527c86db545e288db84639f321a3008621f37500488bf7651353536cd420512862f75a4703ddd2120b452658a7b05a22f499ba084e916cdd3a3919c6eea5e5d9f77db126aeca194ee5f1d635cf0aa790c3872863e0e10a06dc29d5b45295c70e2a6b42ff246de3bdec7016881851d3b2c6255eb4c3516f8aeade02abca9917eea16e791f78540adcebd874bb6f3d2d869aa6fc4199202acee7f4a90352b5567334824aae1a350b5659cbb0b33807419e5b493d6b903f4d7460fe305f8dbb1e9431df9cb8976064af6866696411d151f809ac84fef89afdbbca3d2456f950d82a2b8455e401e1a0b0b9d9f6f864b750c56e0453719f23cc6fd6e7e74883e8b23c164058417fd3ad2cf8e8f18379ed70cfd0dfcc40670fa268d67d5b98bf427259983610c2df8a61bad29fa51e62899a249752bddf7ecfb577980cc684a7fad0ffc7bd186835aa078375fac0f12024abdf3103943227c4bc33d1d39d02dd27f2d0a09da4eb9e16283741f522fb5a79ecc1c05f99d188e7152d20cd8dbd0c431f42d2768dc4b38861d3826116b8dbb31bb62d8cf7518a8836e6adf23935cacac4c17f1062cfaf1f3183d1c5aa49ae96f5fb5c43e87ddb25e0bb816b5a57d0713c5a7d6aea43796d317f4cfa8c06418ad8f2b3a953186b0a491572f1bffc1e03ad2378f5116d5c9ce8e56777e719e4502230eff0b495c97c0a6cf7b0452be3107566d480edd8ca2131cb3ce24d654d4cf460d175ca0afaac313aab64d179e709a9ea75e52fa35f6d3631f7312cccc9f33299288e7de015737f57288c089cf1ccf721f7f41f1aaa88acbd5fe4ca658f44ae61e8698cbb3794bf34b8a3ee88f39bd935a5ee5caf724878588d1e77ae1ae49250295cd5ce2fdabcd39aec45f01442a72a4d55f8ed956c534a117bc32a47702523fc0320c90159ea6433d6a8ecf22a77355fe32a2bb46c83864cd4825551bf2cf86202484e20bba6b927e94b9bd74a25d011b15491f45c98880a5f99ce26fcf1bf9297c54595159c824f6825b7e9de0c53477b2232b32a4e5daecd8021aa40dc345f9a8cb5b104bcdbfed98db6d032f4d0e797a01ab068cfe535f7bacc1f8d1e874f69d51e3e787f10344834cc927cfa6b71002baf7d584bfc7d2d2d6463255af4ce2e10331e8fb2a91efa83569e528b80ce51063e5a7961dd4218dbe0a5dd22a73e8186f0d905ae90e5743bf16066ebd89e1488782d3a445457dd2b01cdede2d6167c21ed678faf35d63af7a271cc1f463203aee772e0d758a954859c8f7640e25f2cd072444ff2c340f5b637b16178580f3288ddcce18c3c6b86ad50ad7aa9903a3e1298769665b3fbf35832632198b49a3f5ed3ed779ce21a211731f6360531bfed46cab66052c43d4bd2964aa23bcfe4a639a6e097a1b1d25b7bea177e20590a0fc161fbb232b2f9fb7fe85bb00aa8266e3b566030ea564dc306757853ad2a54fbae5b99ae05248ca8c374c228a9e33f0b2fd221d49b6fd4b81db238c95dc62c272fe822d30fbe596b1ae12b7c07f3f79cfad05f41dd9ff08aa22549b469ed355be74e421e20bf850797544e19a93c2d8f69e2e644079758977f4f9a6bd428c0cda664351e455e03dab299b03717bb718d3db985feac86eba29bc908cb7fc788ab2c1aa80506ffd616d302e7a5eb3e60f3e472802abe96ac1f3fab556ec796628c75893de11239055f929e01e789b2cf6e4e5314ff13c045be12c3ca8ebf0fc6684873bb4697bfc9424f911f035ea4eebe49369c514dc11e363151cba68e08a9616caef0821146e4bc04cbc634976e6809374478601f8c10d206dc45300f494bd2037a93e2d31b8476792a29ee3e9d7cbda8c8cb5bd71d32475b97c9c0ada122f4f88826e4614a21fd35f19c059b3c2c75b73ad9bfe137471a64fa2422216e080aa466352b269ca08d02e20052ab66fcd34ce8b5f162755a228dffc13126a0a39fabd56d93a72952d80eda1ea0b055034eb769f5f3d73cd67154dcbfbe8a20dd63ada28dd958d07e07ffa59c1009b26afe841f4370d4fa0b31bdc68b0927976fadd68f894dd04361bb7784a958458f09b66cb356eb8c4587a1de4b30e6fc3a6ef16d71e2df8bcd26ec0c7224cae2caecc8262a0a313fdecd785ab73e382c69105bd582a24631b9c55b4b753897b1a639aba323b7ced8a59d1bb708dda908b442226dca9ed8fa40bd6fbd840a80b75962d95b54b995ff5319da730675ba3f92431a7c0641684f188c1ba04f94b29f27cf0f824538e534fcea62efb459af42c29030c7429fef17b719a5ed97bb3edfd70f090069ddd2eccfa38644dd4fafb2d008d72b93f39386812383494b1d68de06647ccac4388bb72c50f0ac36d852b413a621c36b306203087c0073b012ea4e2bda3b8beace60282f10af11164172ef204eb1a95136e1092c74b5466ef08063cac36478183b6a991cbcd30cd6ca572598f8db2488909cabe77cd21c6adb87f0385c221ba5a4e09662facd5af79050dd93c86fb6d7ed49b24152f4f03ee669540c52b714fd95905135639b9dc8c9353c02b2cf75d6c6e0a789641c26c4d9b0e00713c0669049c3886b95b26bfbfdc84ce253368f48d0e88ba27188f5096da3d919db51e906069bc4b1cb800ca534a2396f245ff1877500e3201a0d6b0bca76104a3298961a57f22c27d690ccaa56e8a1aee1fbd3a705218dc0159d5cf755010077aa5be7c87957632b2fbf1c8a5080985ef02ba89a0703f8ee4b2da5f986e78d30be0e348e0690118e8151e44e41700b6bb2cf178099ccba10cfd40ef90dd9bda9e4ea9256ae559447e2a09111e06a83970e08df7fdc0f4cabc1b83efc742eb38d789281afd290d372518127055c256696b901326e58f2fc48b3c2c85d83061ee10199087d2e9458a954b3cb126156a2ad562ef52cba8a3e02f8e4ceb38c62f73f287b149f86957eaf56eb3c6b81c7d560b89d9f72bfbae15db3ac0f326876543e20658f40f1a80acac9d8185a0f6791ebbbe2b4be599a34aa61c831c4f0749097c0e54c1e6aca28849cf274e3937ee5bb8cd12a923e518a03188d32ce895ea8821adcba9abcc1390d3f519ff912dfe1ab7b01ac18457cad6d7cd4bbe2afe91450f6675db19e67b08537be530febd23f046ed35aeb1c09059ab186bd293671d6e333ac6429a2f7472e388c535b03917156073d25280e729b9945067f0798c3137ad7197df179670f6be5f1146e906b10cc0708dffd633b31b1e9e5456f6112551ce7b0668fb290e91b8979d680551f9414332f46c4d77ce122a12be465c612d5926f7e06386516921fbf22b5619505b38cf3e75218049e136980fd51fa0a74c1978a735dda2abb868c73686ac5</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-永驻</title>
    <link href="https://unit-serow.github.io/2020/03/15/%E9%9A%8F%E7%AC%94-%E6%B0%B8%E9%A9%BB/"/>
    <id>https://unit-serow.github.io/2020/03/15/%E9%9A%8F%E7%AC%94-%E6%B0%B8%E9%A9%BB/</id>
    <published>2020-03-15T10:01:20.000Z</published>
    <updated>2020-03-15T10:07:09.524Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="e1e9d050c57dc6aed9cb50b87a6af810eeb46ece5014e353c9866f4059545448">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e4b111f26008856c0c71c2ee88709c9d3fca2aa2ef07e8647af39698611e12a42d264395d4770391c21c34c0a0db83d500093e747a2396d36a455924b65eea808fef3e1845a1d53ecc278a5af52b7de8f30a783f6fb2b1a670a2e367d804075451f848830bd63fccd36e7f238aa298cc8438b2feb96270df88f9e038a3ca63f240ade0670624cb0dddb8639d87ac0e1dc526ed9db7472e8581a5656d088db7511a8248f2443b6403699af9a699b7947a35ccc2ca4df8a41a2bb7d3b8609dc069d7710ed11c25c526add731c1dce2a0b481c65a317b791f0cf8984ffa072a41e8da1a97455d9a3238b343a0d89e114e88bb8c8ba976cebe32602453685993472d64a3efc51132f77e51b1120d50541854eee2861c5a7b88e6cdf1fdeeee5844ffe52e7aba36e36bfb84e63ed8fc1cf0053b8579859a29fdf93bb7de80d9dac5bd41d4955605bf1f386426a2141b52219655503f1f199284081e551b0d1f1bc3304429b5e339a3e7790043c36e97aefc640021935f364ee237c7310bde415fe4f8a5bba43fb17537ce3dc83d2806be5bce554486e02d5e1a54807d2da36273877eb081b8ab2d1e0df267042555a365c16b9335dccceaea1d333597ad41bdbceb908c72540f9abad51342d398e84b512a45d2155fffeaf568da892e8f857f536cd87a3af6ea3b21bb5b40371f48b9f0abad76a5632eb2601f7de16c9d6b95699ee444a2eb2b5bf397d33f0349427a4be52fcf37c598a5305720cf3e5031eabe2c10f99b75ee51c7902d1bfc89871e3c52ebed6ddb0a5a3d84028835b00d30a290ec893f0e55ea1ed9d92b2daa353a28865fb24e49d091e4a53093989127a6cf12175de6f9da26e40d82a460dd501831e5466023434fbb6f888fd24b91f40fdd0b08d7c403d8d25fe76c6842422dda27c9abfeb7f1b7724fb6d238d248a3d964dd93da7f69a77bd518b99f58ddc30fbaa68be55111fdc90f171258d4793da1b6422074d2a52bb03ec506df54aad9b99326816ada7431b2f44879cb41397fbf89cabb63cd9e0db420c249d3713e3cdaf117cbe5b87c95e1fa1734fd1e00c04b617e38044e302531905ff3c286678399eb7031a9a27cbc6a23f90ee7a07bdd87e67b17f3edfbdd611222997c54c0979b205b8850ff4764ecbe9102d041d8547fbb726534e66a3a7a2f8ca09e65bb307871450a7b15c9448852a41dec6fbbb09e926bdd63ec32bcc6f0fb12baa9d30000166ba2d2afd67c69dc3c49c1b67f2c00a15cb03f07a59aaf4d9a67620897603705d634de329a95ebabdc687fb5d41621f11d201ae70fba0af13ef8fad52a45dcc382208478642c3612198e4013f89f419822c1686a09c6a17dddbc35e6b5f420a029a92988bae4792d5798a7aba727b1251852ebc7e48883a5d6170bc6c6d76878b3be1ab6d8c630a4ab7a48016df086a56e3b5fb1c72e366380cd6d831dbfbfe69a470578e77c9e47946fa1e5eebbb2470d686d44d2493c3cbad54b3d478b6bf6a4f6e4920d117f13b621f0436018d727dd5c195abb5343c2030c13606c68bc55ad6c6d981c0ffc526858e9239e3080f11013c3b2c785b433857ff1030041ad02d5ece7793d06d9149536474dde8a4370479fe3d0cc62e1d20f1e1165715d77abba2463483648e0dc04f7a4cda3cc021b8fde2088bd5a80d68b504de94e02ac26a74d431890e7afcc1683a1651beb82af5edf387362300cac61a3a1202e8da019daaf10356dc760bd7be59209d6e8dca6da7e34d72327bff05e8b3fca73bb2da86d98d9fda452caf7d8bfbb8bd0c41d3673e5f51e3de13f1e00fb7ca0c4c07f9f16099dd31e5876bcda0dca3400846508e03e75b50676b8cd0adee37f70c6bd5d1b2fc9a08fc868a12a8571a2eb96f5014f8d55a331bb110a74e98ef9b055015e3203b24a5cf9eff64d46395b7112e46a614eee5db4092560328040c2bda6aecb48bebad830e500e6e3c8cdb56a3a337fac42d4e477a168a4e5da642dd7d86d1f2d64e63e9a5bcf21ae25cfc6bd6c0edeeb6769ab093e26a77df6c40980cebfd67d9b59514f8ccd4714dff7769e92a5e302b3c9ea01b0b1bc4b1f5529327599509e119c421184dde32fbda898bd8eaf0dda8952821a2171518b9e97dfddd652889e9063d99b87a7be00e24e8cbe934ba7c80dd47d8ef4f2a0ea095dc5442f45df0d6d14924a667131203f55cd4c4338ada69a43af9924d34185d8c2e46493ef9187b60c00fc9bfd135dfe902bab31c495b46f23a77f80f3234ef4a9be073b1a9a4b549c7aad37b908be7c9ee9b3de0239274ff67a11de70378d1cede10b8239203f87e85a59d9cfd4d3c9c200db1f22d8178e5595d03b5d92aa39945e2f032687b7852b720abc9a81c02a6fadaa16ce0c6153ac3295d842bbd75dad08affd10511f30044044505ed20704df8f3268e33dff8015a46755a3be119d6162f7d25236a7130bc58aa5d4f8d4c886e1763e795c3378756a1aeeda4656053b862781eeef56854caa35b0f46a7e7d63f3a0775d2d353348b13585fb7abed8a2d58726f011ad5e05fc96c3c9e3c05db482d26a0b87469e062ec72394c7190e0e6ee67a124dee888</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Coding-1</title>
    <link href="https://unit-serow.github.io/2020/03/15/coding-1/"/>
    <id>https://unit-serow.github.io/2020/03/15/coding-1/</id>
    <published>2020-03-15T08:43:22.000Z</published>
    <updated>2020-03-15T08:44:56.956Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>ASCII-1</strong></center><a id="more"></a><h3 id="编码-coding-1"><a href="#编码-coding-1" class="headerlink" title="编码(coding)-1"></a>编码(coding)-1</h3><ul><li>ASCII (American Standard Code for Information Interchange)</li><li>美国信息交换标准代码</li><li>美国标准信息交换代码是由美国国家标准学会 (American National Standard Institute/可简称为ANSI)所制定的标准</li><li>是一种标准的单字节字符编码方案，用于基于文本的数据</li><li>后来它被国际标准化组织 (International Organization for Standardization)，可简称为ISO，定为国际标准，称为ISO 646标准</li><li>适用于所有拉丁文字字母</li><li>ASCII标准表可参考下方文献</li><li>其存在的目的是为统一计算机领域的所有编码规则</li></ul><p><strong>编码</strong></p><ul><li>在计算机中，所有的数据在存储和运算时都要使用二进制数表示(因为计算机用高电平和低电平分别表示1和0)</li><li>例如，像a，b，c，d这样的52个字母(包括大写)以及0，1等数字还有一些常用的符号(例如<code>*</code>，<code>#</code>，<code>@</code>等)在计算机中存储时也要使用二进制数来表示</li><li>而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套，即为编码</li></ul><hr><ul><li>ASCII码使用指定的7位或8位的二进制组合来表示128或256种可能的字符</li><li>标准ASCII码也叫基础ASCII码，使用7位二进制数(剩下的1位二进制为0)来表示所有的大写和小写字母，数字0到9，标点符号，以及在美式英语中使用的特殊控制字符</li><li>按照指定的格式与规则给输入输出的信息进行指定的编码，本质就是将计算机内一切的数据和信息转换为二进制代码的不同组合，以便给予机器并让机器执行相应的指令</li></ul><hr><p><strong>ASCII码的基本规律:</strong></p><ul><li><p>0～31及127(共33个)是控制字符或通信专用字符(其余为可显示字符)，如控制符: LF(换行),CR(回车),FF(换页),DEL(删除),BS(退格),BEL(响铃)等</p><blockquote><p>通信专用字符: SOH(文头),EOT(文尾),ACK(确认)等<br>ASCII值为8,9,10和13分别转换为退格，制表，换行和回车字符<br>它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响</p></blockquote></li><li><p>32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字</p></li><li><p>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号，运算符号等</p></li><li><p>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位</p><blockquote><p>所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种<br>奇校验规定: 正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1<br>偶校验规定: 正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1</p></blockquote></li><li><p>后128个称为扩展ASCII码</p><blockquote><p>许多基于x86的系统都支持使用扩展(或”高”)ASCII<br>扩展ASCII码允许将每个字符的第8位用于确定附加的128个特殊符号字符，外来语字母和图形符号</p></blockquote></li></ul><hr><p><strong>涉及概念:</strong></p><ul><li>点阵</li><li>字库</li><li>点阵字库/字模(数据)</li><li>格式问题(UCS-2等)</li><li>码点</li><li>编码</li><li>Little endian/Big endian</li></ul><hr><p><strong>其它的编码系统</strong></p><ul><li>非ASCII编码</li><li>Unicode</li><li>UTF-8</li><li>中文编码</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>中文维基</strong></p><ul><li>ASCII<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/ASCII</code></p></blockquote></li><li>分类:字符集<a href="https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86</code></p></blockquote></li><li>分类: 编码<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>字符编码<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>晶体结构<a href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84</code></p></blockquote></li></ul><p><strong>百度百科</strong></p><blockquote><p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/ASCII/309296?fr=aladdin</code><br><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin</code></p></blockquote><p><strong>CSDN</strong></p><blockquote><p><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/exbob/article/details/6532772?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code><br><a href="https://blog.csdn.net/yuanwofei/article/details/12846331" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/yuanwofei/article/details/12846331</code><br><a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/Deft_MKJing/article/details/79460485</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;ASCII-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Coding" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Coding/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>学习</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E5%AD%A6%E4%B9%A0/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-14T14:41:41.000Z</published>
    <updated>2020-03-14T14:46:48.594Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>主观-学习</strong></center><a id="more"></a><h3 id="开放性随笔"><a href="#开放性随笔" class="headerlink" title="开放性随笔"></a>开放性随笔</h3><ul><li>所谓的智商来源于学识</li><li>而智慧来源于环境，世界，精力/经验其次是学识</li><li>然而所谓的智商，只不过是给予懒惰者的万千个借口之一而已</li><li>只是强者给予弱者的某一个心里安慰或者是弱者自己寻求的理由而已</li><li>学习不仅要勤奋，还要明志，指向明确，方向稳定</li><li>明确自己的定位，明确自己所能接受的范围，明确自己当前的能力限制</li><li>在步步为营的前提下，去进行逻辑性的累积</li><li>利用绝对的理智去找对方向与指明道路，珍惜时间，时刻行动</li></ul><hr><ul><li>学习的本质只不过就是机械化的练习，记忆，理解与实践</li><li>伴随机械化记忆而形成的是对所学概念或知识的通透性理解</li><li>而学习和练习即为行动</li></ul><hr><ul><li>哲学不是存在于现实的，或称不是存在于现代的<blockquote><p>或称存在于现实间的哲学，对于现代人类最基本的生存，生命与现实存在的保证而言(生存的本能)，没有任何意义和相关性</p></blockquote></li><li>纯粹的哲学家可能早就被饿死了</li><li>任何学识和智慧都要提现和实现在现实层面之上</li><li>最基本的条件是需要保证自己于现实间的实际存在</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;主观-学习&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-14</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E9%9A%8F%E7%AC%94-2020-03-14/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E9%9A%8F%E7%AC%94-2020-03-14/</id>
    <published>2020-03-14T08:01:16.000Z</published>
    <updated>2020-03-16T12:20:59.824Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="d6d6a2999ed2b5806014791837ffd7465230f852ec5d4ebaab6339cf199c34d1">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e7c1bd18033e860c02eae01ececb3cd90765749322ebace55430fcdf86104656899641018d61d7c738eee3315f3be6f5bcda46abf4f67eed4014492852823871d04c14858b500be819800797f0ffd35f33e86e9a02faf22bf82cfa4998da57edc9abd6547de34d4889ce4dffe79deca01b8e7d19961098027ebce9fa9f30321922b5de21615aa2ae48b2b354ff85dcfac34a467874dc0c77e076023051c964ed04e0a28417e0eeebb4d8b2c6ff45a140ac241e61f66bc7f88fc899f01991974a321b5a718e1cc83fd8b3bc746de619290652a9becf6f6a15dee17bb9009cc44155f90959279d4e8418d95e07232a5f76d9cbff17b3a0eb812055cde658353ae85cf192921c5066144493f5aedbee028d67efa32d109bb36b661e059e669b82d4cb2f7e7609ea1eaff6d1650da272b20e31150365be5aebc6a91444d237496da72b14c9b3a74d039ed982fba1564e4b9151451cf28c329939298e79f0fcb976306c0421f65e1ade0aa0fc32a79057f4fbdf78795c4cb9cda5de6d515d630f89c0500c38d84aa0c0bb4f20c9a9f09640ef6bdd1f99c49846b5c2b6dd82e0b23ad34ac68cbad3d40824b61a14c0a73d7b1d45afb5218cd3366217ca4479eb16586f7a547a059d2fa3e571cb8bd7f9285d2198886106e1893a25bf7b40a9ccaa00cf82a9fbcbbcc494f5ac4a8ec66de44f9dd54a2fdf3dbad0975bf90f6ebd9aa72458c80c362ded2941b429ca5c9886b3680169ee73513610e37ded3c07f5090bc6c8d5c89d8bea22382dbadbf7bdb2cdc6f7bdbec4d29243433a12f450d3bd3dc4b8caf3ce76b6249b9b063953add3808846786103b8b46d36ff52e13b15820ed164204b9fff3d2f17d1f696c6d5f6bbe2ed194f3fa6bc5b4ca84409f17b8355829a3e8a3a810aa5a7bf3c98a566f13c152ed4fb254e8d554ec5f0f360946555c306966b7255a00a76044cf602a664ab3853560547c6aeaeeacf2694fab24b796f2575feb56808366fe64894f1f87d5222aca955f97f962d69a237d129769621e059bfe4344b8a916f02978a93d456073f11753ebd0d1945408b8c1858288bf4aafab7a401ed3db9eefca5bd5b15b777050d4783846199934e03ec6720517db4bef0ecb1f802ec95c6a7b6a18acb79a90e62b2bbc3976a8abaccb5d74f93c3b786c5c00fe30aefb0d068ef7e2927ecb1eff7e0aefffd9a186a71c4a059d903965188a260d43c126fd3dc216a3a43db44caed7ab7594042605801c137c7092607eb0e06483a8ebf4c289de5ad3aca59a65e1e017d142f2ac16fedce88c338be7eb8386dae658097a758462d79c12e70d6efdf0ee7095769694fe46a90468cec81bbb9192ab37edd8361311eedecc140b87ccabe5d3ce4809b480776026a4d01d1220ea5a3ac34c9ad8eb3d035e9b08fc21ec98254647fed9c1e375af4d3def8d2d4a12cefea87dc469b1bdb1902f24dbf496e0e4c849ab2960a5c752f4d8a73ee6d74793d4a220716a3c28ada255e652468f3d1801fb0d3ac3ea869748790fa0581e2c784d6a0b24a23487ec4a007516360acf3a28daa251de513786b563b3359d20f1ec6126fa273876eaa235b0b2ae29472ec1448bf779e2418e8fd2128ecfbcc1371308ef32189d843cbd1be887772535790857da9e4ebc1a3dce9ed15d98f5d7247b7529ebdae751ec78e14ecd3a212954c26a8d61f8aca239dd007a2be2db8ac0cdc80a9be8e91c6560045aa2d8435e35fe1b414d26488e18eb3e6b5b4395fff563a265829bc9e1211d10810222c72f543092641455d704f2acf720c84092f98268c0beef25e240addece76a3d71691adef5201104a797b56993251baee23e158521545d2faf5f417b44125e19b8b3d46accca96e100650bd87a7223115b49b01c79a0e15db0d14b2f141d4b728cf5708fbdc4394ea42808d9ebf1ec1c7066a58acffe051e5b3c29a95891fc2aff9ede45d1a6139cf73c2cc9a68db8893122044eb494dfe3514b9ee11efa4f4e11013a66c16f6697961adebeb40648bdf5a4fdec417bf9163a75234e5bf8a9b42a3c02babefea5db0ba5b2f191466d32e7e4ab5e27937799217a78cc448ac541ac0d749532deffc3ef1056537388385ef9f6ae990a676b90347f5cfd1a34563057cb5f6589d0831ae25b7dace6b0b430b036a9f3a232f22615fcfa4c551be41e74b669b673230c93f334367494e28e65fbb640c62c0ab7e397fb635bd79a3c01de83edbad58f97b1e59cccec2d751aac2636004bf17411567a281a4fc8e09ccd9b3ceecd83b6b9273d01fe726c09f6f0487d56f9348fc1d819031c30eb2934f63b515e26164ef8a12513941c8ad9c836b52af580595bdd2c9957185aa32ab8aac9bf9a6fd19d2ac93e68cc66acfa5178fc86db07c9647c50c249b251d01cf8bcc150dd3a4a34940ef8928ab7bd528e687fc0e0354d126d168b6856f0ed2b592d662ff6bf140b778589ad9be5a81f762125ed29c09b62e863648234ec8f7ff30e9c366a40092db26aba448f8a479a198d472710740f1b4b1df3a2ab6c493275d399c4741a1d31eade77e65c2b0728472affcd5e0618ad6477db6cd1f15062c5ce1a4c2aa4ca904ead3b860738c1e2b29f763aeb2b6578b7421b2e68130f54e832f9e96b0b6204d49866730eed03b719883b909fbe0f06a874a90d9613448663039cd193dbe350f50de5a90ace20943b9afcd22ce342bf4c67844ff1f7a7a6cd8553cc1fffe44644fa920c030c3ad2f5e22c86739ae1342702da1c320d9b47bd71af4ca2774f9b015f5fcb632c08f0307892064bd1ee4c3534ae54f6fbb92fb37bb72d732fcec27b65abb6aa46cc83daf689f29ea01523fca6c902ef24af7d1a76c2a15bbc69c6b1d7ff1ae2bd32d79194c07bbeb7db5fff99131e3d876a5fc4cfdd8df35473decd070daac2407a93b8d3b4506871ec47cf8f7a58258f46300104daae5e0f0cf920cd65f5f10f263f64c0f5093c1159ef15b9b25740c82fd1543289eed0c20365a5ce91033d38cbcb9b9211f3e1d0b62a5200f7b743526c798aef1cc80e76e85ff1dce92b2d8f5291d13a97980afb60181a2f4cb8216dad717033d36eee33a0a4ce7147db670895dc5bce0ec2a2bc841764cdc42346b57f4d9c18736af69b9dc132302839a22d860c32850e747845b69606863c648636bc878587009937d8e5ace14fc8bfe6f4401236aaade9e33a83ecb30aa8ee9e9271cbc45f67f632069c94bb947c067fddd9389b06bcfe004bec45e9207b2d3c359749f9cf1ce68de5805bc2abae97e88b364868e94a9a6186404aa9f7cc87f22d0d814b48fb953ad4bacac43f83fb9add41df57406931b89dd6f28b381ee1de31e57d7ecbe06b15abbf1c3bdea008d9b1aaeeb7e89618004025bef857938d877cfe3c1294291c1b586b319bbb9ab302cee0a1e292e104674074a5e700ed5d4fb378c095a08dd346f57b12c73e61ac5ba30cae5d0cc3a60654162f6a1cdb4d39f9b8cadae9b6031a4f8c364a448375fb9a7ed5fda8570d9053c0b1c3fb8574011ce08837a4b92e0fada1093528e3fe1029606f64bb81c0ad321995cf6578cf4776889bc3d9821ca728fbe3ebe4f8fe0c98fa9f6c8587b14636a964b708ffec2b4e13e0cbf79fd08a53128f188a096c5b3a0a7587f6e0cf6985e819e3a5d2f636b0e24e3ba9d031bcc128e8ee4470d7e47093597656fd6037ffd17e857a91b9eae408e330f65c6e02d0b97696a4e1c35b524c823124f2d6e3e03eb6cb35947c33466f2a9b6997f2e879347a2a00032059d1774158cbbc5a31ad87884796369837ead4aa71e27104db350d2f17d2de3ba597b98a174d3b2097ea4d87ed9f9330c170b4409bf53dc3daaf9e0561629c9f4ce674eff08651240d64c310662d29ea4be0c8130a5165361a5e83cc1e6c40743faa53a14f6bc3dd160b1c01be385b8031efe5dfb2bd155be1883cb57ff1574a48d9c162861381e48164529af8dbd76f2677d4fbf578fc83d46e89d402bb2965a8bcd17f48dcfbe5e442134c5617c342de0bcabdd96cf3f0fc1cd401beeb0312912d151469d4bc2362d77806aa2188092fccf965b36fe9f6723e361be063d00370ed72aa675be221c817d89e1f6ef41526e4c79a90f5991bbeaaf04155ab545838d36f7f67ec4bac0400569610cb07019768e67684f8493d2bc82aa1c91f019c534440136345a4961caffb68915036ba49b124bfde72a159f1b72ace04456009f3a19f0b0d6ffb8459f303e5080888ecfb9a687d41b7468c8ce4e4d49826742e44132a18d7d22841d49fc20e69639268af08e082cc4c3d35e2b04fce958465da2a6ad1aa69fd3c700d2de53718483479ddf72e07e0f737ec76b32dcf8835825a9b17bb0e69e9334ce95990e0eac7199c0968dcd497f71a613f7f06caada3b7ee924f315721eb4d49caed338c17ff91938a55eb9462f03030f132981b88bfa811763077d79da52d37098aa740a1e4bd4850231f11b2ffa6553ca3e17f6f5c293d174ffa2cf5ac283c7ea3014df95589fd12a87b325f96d11a450dcbad52a5d5ab2c1d3003212c08dc68a08fff9eabc6cfd9c6add9c24a07253334b58f904670fbb1a09129a51b8337ab6e3c23201aef303ca1d38e211aa2e0058987f55b4d8e6fcf9691265ffe6eaa52ddcbf2402e2b673a1fcdd0c4b4bef0f6d30fb3a797142521c522de1a2ce415e091c05f85f4e98ba7b315a9e49ec5c51627d0967f924ed6d799872465e1b0b4a9d0031d0345c7a637c28e0c385138344e30ea23b5b0cc071dcd167e49f325b35e6a0448e0d9bc0031a7a9693954a6112c2b5b3f8e56625c0de9da2dc4b728024f3708b8402fbf8c2cca16ac636d654abf1119b12e92f32c5b4de307b2f564cfd6105c8a7c5cc7e24a065e64edf0f489b227ca3f1ffaf6696a59fbbcb6cc576973e3972f6d6e902d3b5262dd557f21a71d1867ac428fc3fd4c741be3b5865287b458ddbae5d7e3899ac0735a36410c2205b93acb59c611628dc9833dc06800cece57367e2dbffafd5c8de7382cf8a3c063f0b02867597db5084aa6ec0033b5153b9b3e2402f2740e9f9157392c3cc0061ad06384602e5c52719bdbf09f9cc679040f155517001ac652f46fc6490b5397305b3e5362427b09ff90bae761f93b0900b20f863b1834dc651096890059c529c89526d8e69362e131d73ee26357ce41552e6b0fd15af0927573d696d5c3ab5f7166da04f732473c1cfe7302e704c976c371a0ec32485deb236605852484d07102412ff9ee499b00a9e151748c7026fe60313129df71c2949b76ec903e99baaadbceb25674d57a7308bee0082322ff75815d4fb465af930584df2546d6157bae11e03d32d5a1a5ed9c7a82373dcc5b69368dc6fb2da8f4cf8c6fb78b21b6d770bfb0650eefdfa1b23d7e1f1c0e6592de9694219735c259a7ae7a6578fe6707df768fb43f4e534fb03919637ce49d98371a0f3ae0addfb4edbe0b28960c4034e10ae6b1b9982636d4b527b86c0c48779fecc7e4f3a5816b7df129305bd796d3964fd0458ff722209bc25a6308a7f04d8a62a104dd1b1cc85337916fea7443640291a047f3c5a98266ace00da5cdc968fb9cfecf7824f1e5efcd719e21a8f8b83eb29d363d92f31d9f1f39449f83b52764d5ebe436f3c225bb757363f5d6f45da1022b43e37f23b7a3103d38feb4ed0f4ed7a9fecc8d16214a9418772797b6b1c180ff4e075a8169ae55654aaf8041e3fa8dd46da750d1d7ba62b84ed59612f87e2346aa92200314ae6b978ee235b26a142326c2281dff214e4a69c6e7a5473270e5acff21409fafc16881fd4885dac12cb46c121bae6beb0dece6c2b7b48f18576dd2b08c1a4ea48569fd4aabf64e30e60292c71c671c63693e461d9f4267d507c2cee92768b854b00db18cbd3f42cc3d4d884837313a1e4335c1c4485614d1faf3912a6a27787a21ed9b26bcfab03c4311473116374f8f45892c4820a3711f2ef28b68ea0e5c68d981fc280eb099ff112b71e3bb41a4107755bbfa577a8edec3d4f4cbcc1363aaa41bfb8f9d6534badfb61862f6608a12f68530e79b042926558459a892b8b7ecc29b9cbe993f94b70a806cb2fa4f4f22976aa39ca1cf52f19e0a317017a22607063ae372f989a699cdb547aea5df6918969187cb7d78c479142f6bcf9f757ed8b329b10754cda69406a9a0e4f6b15d2c64446ebafc88323cfd92f95b7296613189a63dbe64be88675a7d58b2aa009c193a898ebf7e73be922201ea18ba9a64a7de959e05efcd01724c1ca745deead261094d40be899eba86bf7000422a350dc63f37f3d9cf8f4447502654852c01dfca5e4dd1da56a604cfc54f739b76870ad6c5a4fc699f7d9edc205ee0e416a7bee69f8827aa75c6900bb77d34e3e607ab363ddc7bb51f20a0c10569f7ad7f8d5c9c1ffb36578b75adb072603846e76e706b951a8d4d0eb6d1dfd57ec4703bef88d8cf635aa3b91f057a2302b9c86f35f3844568bea69ce84aa3497c9d72319583de3b8b2ed7b9058ffd88ac77a8b3c0b48dd326b0a686cafdb13aab124124452fcf2a2f476033c0a782691befd9023e8b3f714f9f379845cbb11636c4bd019ef53a4bc0305947a9964687d309d859c01116719fadfbed62a500ce041a68e5f20d1d61e751772e70ef6ad489000798e43db3b2cc60392f49fa4352ad54fb908dad7e4f22aea69bf64d66cac629605503f95a2804601f3e5ab7e5b817152b7f4c642707f00a9bbe65efa360312b262aab7d7c2ec908db32e4e61155eb84b962b9c8b6ce9d42704e86456137891a1776889bd51a55a1dfbb28fa4b46ee529bd211ee938a0fd77c98769428767bbfb1ecac2958fbd463cbff122a95bc2a6d37e47b733bf32cb66d9b3b84a2a818fcdee7b6ce7c6a9f018ec548baf688c37fd9594b0ac91a1e50d43c8531ee580c46642ddfb1be8bb275f38c4e7b65eee63fe9787320186ce326e21c7442ca86e3e67b3bc1b33bc0688d68fdc85a5ade9939df24f61491c6dbe27c15e3c145f127848ea746a21cf5e0ea99f6a6b8b0c3ff52c1f378b28cb49a4ff6e6c99b5f00acc457441cb364fae88cbd419fea3c9ef67df9926621abaa54fd20af094c354f1aa32728dc5bc9f97833e9e46079f8c80861ab4791d8e711400a6989fd748a961362db091caf2788e68d41e9a9836a79909b8b42dd3456eeb91456edd731769c7d80c6dc28f8dee02166bb7041aac8660131319d266b2a91a2a2bbab5585b39ffd0402dfda0f8d6efe8f4440b7ad1455a3487c2759322ca8d3220b48be770d89193111865562d31ad164f8c25202474e0a67270dd45ae97bd4a24730779bfeed07d6147d3d13cec84061f8357a5d606acffa7002512938408eaf33e139fae011546c465fc657d39174add1da4152e74b44bf48548701e8c86b9e16145a2915e802402db5def51b45888eba32d5337a256269c4c388ae5fc6af68226ffa96f06807a52191c7247a6abe7757c0d6339abb6e479f5bdca1e70973fcdd4c2b344e15eadb6766b93cab35afefa31fa2be9b0a59a804c01c4423b1f5c704d676b513292ba3f9f6e4f87a205590114119c7d3f9ab720c65d7ad49dda7d0d4b9bf62ef76935f93debb63a8ddcddfd91ac3476b388ffe5900610ce78b06a54b006bc3c6689445b8b4fc3b647be5cffcb54db672705aab637b3a979b75aa701e37266cdb8980c2b09d54d4b89a9ab37e0d477f13a7ded50f36e34ceb46c51af6f5a185c48fba822e8d6a6a0f77b38687b51e54220505bd708a80558a588fa2fd76a3041b206fa0808fddaf351735a983b587501cfe51800d001b6a21f27ec2d642a4183090b4409d1dc27b1c8ba07607341a63438247f624b833bb6822cc5cfd6db4e18299ae3cd4516b9fee0beec10b9937d49d0877158bfb009acdfeb4498859029757a04bde37b7c9491f6d5cff66c3b2ff11f26dabebab62607ca127b0c66cedf439d1cb38ae3b0c2551dd732fe2ce7eb57ce59dc116bdc55aa083bb14b38cedff78bb0b9b1f20920a23db1f7a5aa0a8f084cc4d4e4941b47e6e71518f176087e02fd019d7e29bf035007775b207d2fc0833ccd533cdb214109b0f8bbc36d7b38f02ac087cb98d7ae9e51058f5468f136257c199001402ac44cf684884b6aec6d76ed5fc8d99a8f2de6e5450bd305a4ade1079f4f7e0686190629a559dc9ccb034b8e42c2947d9e8332e55a21167a8d56ddb476ab20be3a9d52787e609377c558950c30590f24b597d88a5daf80ff634fafa093fc5b90e045aac8a2f96027468eb384c721155c48e9e671ae6f0e26189ea3c59d6a88935e5e5200a4dab33afb41c5894b912481fc64e749a97dba0134eb3917078b440240772e0ecad9ced634476ea62b7adc3fdd8e36b3596f4e28daacc0f9d1499cb4338a263ccabb6aa78d6e1d9862a6ac31b34c10db3f02fbedfb3ec24907f8742b7efa826a3ef2fe9ffa7c9e790633d89609be3e43c07e61cc6333ecb8f16740714e4406bc49945489adcff2fc650a32cef271e938d417c7944c1a60fdf5890b7f9b6bb1ffdd29d9dcbd2efd9a206482002fcf7ecb27f8a140be3fb98dd3cd218b0d9eb9bc3d6bcb76f56d55b463b4b96669a7fdb0e7f707381a2e8f3e8106499bbdea8d6979cce9ba9a4fda0779ffbb17cb2074d8804b121bdb5681b9fce23d82afbc17d30a04faba584e8aa3dc64b96d2eb47a7e4e687e68e3a5de81504e5b07def923b63d38ed1fd537bfba17d0c99225085c66a79996695b0e28d94a40437f72fa18b1b796ed9b6cb9967464a57070ec48f75c939688fe2e88a38a80e423fc983915710db19f4f76adaadbc185a9cedb89f734c3d7fabd30db37ec51da9912ac0b60c1676bd650e4bacb28d08c1bf95a096acb64f71b05701270f22fe1377b8e1614648e507128bc8b4d0e812a46d6d35ae8cb8dcc10c53b80fc8ede09473fe62be9723bd5eb61d09f9cb944c0346edf31ef743c7b3da53c3e34ad217a1430fcdbd3ca85843ab92a06c1cce9a5d95ed2eb09f79994dadd5dc52ace2e894b761f09e5b7e2feba75bfefd82deee1ca69838ffc6cb217c73b6e6b14b91d9c4cb373a67191b3935645c5953783af1027789686d0b48842a773a24c4c8fe590118e626157be3214ed211e47271785132dc9de500860f8b6008f087fbe75647000c2bef330516ba6dc9ac50f535266b012ba863b4325fb6f575c0da8640e69c35f9c3a038e50eafbd04d7c91456626c9d727899fdeb85ce2fb40f2c8673576722c37709d4abedb9e7e28b6cc6cd3beae9d42a382483c7e1a8b009acc5d99fcbf804413859ec535f80792d76e515c01996acd1af1c829276ec8270f2bde5cec8a272d704e3ef0b6f46be3a93a60169d8bf07bf53c06699a58cb38221c59cf460535435560c2148be12a2aeca8071bfa1457d563e913a41ea28e5a7ceab2330b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-7</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7/</id>
    <published>2020-03-14T03:55:04.000Z</published>
    <updated>2020-03-16T17:21:04.634Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-3</strong></center><a id="more"></a><h3 id="数据类型-7"><a href="#数据类型-7" class="headerlink" title="数据类型-7"></a>数据类型-7</h3><ul><li><p>条件选择语句(控制语句)</p><blockquote><p>if，if…else，else…if，switch，switch…break，switch…if…else语句<br>continue…break<br>goto</p></blockquote></li><li><p>头文件及函数</p><blockquote><p>ctype.h，iso646.h<br>getchar()，putchar()</p></blockquote></li><li><p>其它概念</p></li></ul><hr><p><strong>涉及内容:</strong></p><ul><li>条件选择语句-if/if…else</li><li>getchar()与putchar()方法</li><li>ctype.h头文件/iso646.h头文件</li><li>多重选择语句-else…if</li><li>选择语句配对规则</li><li>逻辑运算符及其优先级，求值顺序与范围</li><li>条件运算符-?:</li><li>循环辅助: continue语句和break语句</li><li>多重选择: switch语句和break语句</li><li>多重标签: switch语句和if…else语句</li><li>跳转标识符: goto</li><li>其它内容(补充内容/关键概念梳理/文章内涉及概念总结)</li><li>有可能会在数据结构-8内进行补充</li></ul><hr><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><ul><li><p>IF语句</p></li><li><p>if语句被称为分支语句(branching statement)或选择语句(selection statement)</p><blockquote><p>因为它相当于一个交叉点，程序要在两条分支中选择一条执行</p></blockquote></li><li><p>if语句的通用形式如下:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( <span class="name">expression</span> )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>如果对expression求值为真(非0)，则执行statement</p><blockquote><p>否则，跳过statement</p></blockquote></li><li><p>与while循环一样，statement可以是一条简单语句或复合语句</p></li><li><p>if语句的结构和while语句很相似</p><blockquote><p>它们的主要区别是: 如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次</p></blockquote></li><li><p>通常，expression是关系表达式</p><blockquote><p>即比较两个量的大小(如，表达式 x &gt; y 或 c == 6)<br>如果expression为真(即x大于y，或c == 6)，则执行statement<br>否则，忽略statement</p></blockquote></li><li><p>概括地说，可以使用任意表达式，表达式的值为0则为假</p></li><li><p>statement部分可以是一条简单语句或者是一条用花括号括起来的复合语句(或块)</p></li></ul><hr><h3 id="IF…ELSE"><a href="#IF…ELSE" class="headerlink" title="IF…ELSE"></a>IF…ELSE</h3><ul><li><p>简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句</p></li><li><p>C 还提供了if else形式，可以在两条语句之间作选择</p></li><li><p>if else语句的通用形式是：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">( expression )</span></span><br><span class="line">   stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">   stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure></li><li><p>如果expression为真(非0)，则执行statement1</p><blockquote><p>如果expression为假或 0，则执行else后面的statement2<br>statement1和statement2可以是一条简单语句或复合语句<br>C并不要求一定要缩进，但这是标准风格<br>缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然</p></blockquote></li><li><p>如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块</p><blockquote><p>下面的代码结构违反了C语法，因为在if和else之间只允许有一 条语句(简单语句或复合语句):</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line"><span class="keyword">else</span>　　　<span class="comment">// 将产生一个错误</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句</p><blockquote><p>它不是if语句的一部分<br>然后，编译器发现else并没有所属的if，这是错误的</p></blockquote></li><li><p>上面的代码应该这样写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择</p></li><li><p>if语句和if else语句的执行逻辑示意图</p></li></ul><img src="/images/数据类型-7/IF语句1.png" width="30%" height="30%"> <img src="/images/数据类型-7/IF...ELSE语句-1.png" width="30%" height="30%"><hr><p><strong>未完成</strong></p><hr><h3 id="getchar-putchar"><a href="#getchar-putchar" class="headerlink" title="getchar()/putchar()"></a>getchar()/putchar()</h3><ul><li>字符输入/输出函数getchar()和putchar()<blockquote><p>同样可用作输入/输出的函数还有scanf()和printf()根据%c转换说明来进行对字符的读写</p></blockquote></li></ul><p><strong>getchar()</strong></p><ul><li><p>getchar()函数不带任何参数，它从输入队列中返回下一个字符</p><blockquote><p>例如: ch=getchar();，它与scanf(“%c”, &amp;ch);的作用相同</p></blockquote></li><li><p>putchar()函数用于打印它的参数</p><blockquote><p>例如: putchar(ch);，该语句用于将之前赋给ch的值作为字符打印出来<br>该语句与printf(“%c”, ch);相同</p></blockquote></li><li><p>由于这些函数只用于处理字符，所以它们比通用的scanf()和printf()函数更快，更简介</p><blockquote><p>而且还有一点，getchar()和putchar()函数不需要进行转换说明，因为它们只处理字符<br>这两个函数通常定义在stdio.h头文件中(而且它们通常是预处理宏，而不是真正在宏观意义上的函数，这里先不对类似于宏的函数进行深入赘述)</p></blockquote></li><li><p>语句putchar(ch + 1);</p><blockquote><p>表示了字符实际上是作为整数而存储于内存之中的<br>为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()<br>该函数只根据最后一个字节确定显示哪个字符</p></blockquote></li></ul><hr><h3 id="ctype-h系列的字符函数"><a href="#ctype-h系列的字符函数" class="headerlink" title="ctype.h系列的字符函数"></a>ctype.h系列的字符函数</h3><ul><li><p>斜杠字符对应的ASCII码比点号的ASCII码多1</p><blockquote><p>如果程序 只转换字母，保留所有的非字母字符(不只是空格)会更好</p></blockquote></li><li><p>C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型</p><blockquote><p>这些函数接受一个字符作为参数，如果该字符属于某特殊的类 别，就返回一个非零值(真)<br>否则，返回0(假)<br>例如，如果isalpha()函数的参数是一个字母，则返回一个非零值</p></blockquote></li><li><p>有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具(例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为 123,45)</p><blockquote><p>注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值</p></blockquote></li><li><p>ctype.h头文件中的字符测试函数列表和头文件中的字符映射函数这里不做赘述</p></li></ul><hr><p><strong>多重选择else…if</strong></p><ul><li>else if 是 if else 语句的变式</li><li>else部分包含另一个if else语 句，该if else语句的else部分又包含另一个if else语句<blockquote><p>第2个if else语句嵌套 在第 1个if else语句中<br>第3个if else语句嵌套在第2个if else语句中</p></blockquote></li><li>对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌</li></ul><hr><p><strong>else…if的配对机制</strong></p><ul><li>规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来</li></ul><p><strong>图片说明:</strong></p><ul><li>if else匹配的规则:</li></ul><img src="/images/数据类型-7/if else匹配的规则-1.png" width="40%" height="40%"> <img src="/images/数据类型-7/if else匹配的规则-2.png" width="40%" height="40%"><ul><li>注意: 要缩进”语句”，”语句”可以是一条简单语句或复合语句</li></ul><hr><p><strong>多层嵌套的if语句</strong></p><ul><li>if…else if…else序列是嵌套if的一种形式，从一系列选项中选 择一个执行<blockquote><p>有时，选择一个特定选项后又引出其他选择，这种情况可以使 用另一种嵌套if</p></blockquote></li></ul><hr><ul><li><p>小结：用if语句进行选择</p><blockquote><p>关键字：if，else</p></blockquote></li><li><p>一般注解:</p><blockquote><p>下面各形式中，statement可以是一条简单语句或复合语句<br>表达式为真说明其值是非零值</p></blockquote></li><li><p>形式1:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，则执行statement部分</p></blockquote></li><li><p>形式2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，执行statement1部分<br>否则，执行statement2部分</p></blockquote></li><li><p>形式3:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression1)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else <span class="keyword">if</span> <span class="comment">(expression2)</span></span><br><span class="line">stateme<span class="symbol">nt2</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt3</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果expression1为真，执行statement1部分<br>如果expression2为真，执行 statement2部分<br>否则，执行statement3部分</p></blockquote><ul><li>示例:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (legs == <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It might be a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (legs &gt; <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It is not a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span>　　 <span class="comment">// 如果legs &lt; 4 </span></span><br><span class="line">&#123;</span><br><span class="line">   legs++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Now it has one more leg.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p>if语句和while语句通常使用关系表达式作为测试条件</p><blockquote><p>有时则需要将多个关系表示组合起来用，此时则需要使用逻辑运算符，并使用点符号<code>&#39;.&#39;</code>来标识句子的末尾</p></blockquote></li><li><p>逻辑运算符两侧的条件必须都为真，整个表达式才为真</p><blockquote><p>逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号</p></blockquote></li><li><p>C 内有三种逻辑运算符，如下表图片:</p></li><li><p>三种逻辑运算符:</p></li></ul><img src="/images/数据类型-7补充图片/三种逻辑运算符-1.png" width="40%" height="40%"><hr><ul><li>举例说明:</li><li>假设exp1和exp2是两个简单的关系表达式(如car &gt; rat或debt == 1000)<blockquote><p>那么:<br>当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真<br>如果exp1或exp2为真，则exp1 || exp2为真<br>如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假</p></blockquote></li></ul><hr><p><strong>iso646.h头文件</strong></p><ul><li><p>C 是在美国用标准美式键盘开发的语言，但在世界各地，并非所有键盘都有和美式键盘一样的符号</p><blockquote><p>因此，C99标准增加了可代替逻辑运算符的拼写，并且将其定义于iso646.h头文件中<br>如果在程序中包含该头文件，便 可用and代替&amp;&amp;、or代替||、not代替!</p></blockquote></li><li><p>逻辑运算符对应的拼写如下表图片:</p></li><li><p>逻辑运算符的备选拼写:</p></li></ul><img src="/images/数据类型-7补充图片/逻辑运算符的备选拼写-1.png" width="40%" height="40%"><ul><li><p>在新增的C99和C11的标准ANSI C库内列出了一些其它运算符的备选拼写</p></li><li><p>!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低</p></li><li><p>&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高</p><blockquote><p>因此，表达式a &gt; b &amp;&amp; b &gt; c || b &gt; d相当于((a &gt; b) &amp;&amp; (b &gt; c)) || (b &gt; d)<br>也就是说，b介于a和c之间，或者b大于d<br>尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第2种写法<br>这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚</p></blockquote></li></ul><hr><p><strong>有关求值顺序</strong></p><ul><li><p>除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值</p></li><li><p>例如下面的语句，可能先对表达式5+3求值，也可能先对表达式9+6求值:</p><blockquote><p><code>apples = (5 + 3) * (9 + 6);</code></p></blockquote></li><li><p>C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计</p><blockquote><p>但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右<br>&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效<br>而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值<br>正是由于有这些规定，才能写出这样结构的代码:<br><code>while ((c = getchar()) != &#39; &#39; &amp;&amp; c != &#39;\n&#39;)</code><br>如上代码所示，读取字符直至遇到第1个空格或换行符<br>第1 个子表达 式把读取的值赋给c，后面的子表达式会用到c的值<br>如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值</p></blockquote></li><li><p>这里还有一个例子:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">number</span> != <span class="number">0</span> <span class="symbol">&amp;&amp;</span> <span class="number">12</span>/number == <span class="number">2</span>)</span><br><span class="line">printf(<span class="string">"The number is 5 or 6.\n"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值<br>这样避免了把0作为除数<br>许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件</p></blockquote></li><li><p>最后，考虑这个例子：</p><blockquote><p><code>while ( x++ &lt; 10 &amp;&amp; x + y &lt; 20)</code><br>实际上，&amp;&amp;是一个序列点，这保证了在对&amp;&amp;右侧的表达式求值之前已经递增了x</p></blockquote></li></ul><hr><p><strong>内容简述:</strong></p><ul><li><p>逻辑表达式:</p><blockquote><p>当且仅当expression1和expression2都为真，expression1 &amp;&amp; expression2才为真<br>如果 expression1 或 expression2 为真，expression1 || expression2 为 真<br>如果expression为假，!expression则为真，反之亦然</p></blockquote></li><li><p>求值顺序:</p></li><li><p>逻辑表达式的求值顺序是从左往右</p><blockquote><p>一旦发现有使整个表达式为假的因 素，立即停止求值</p></blockquote></li><li><p>示例：</p><blockquote><p><code>6 &gt; 2 &amp;&amp; 3 == 3</code> 真<br><code>!(6 &gt; 2 &amp;&amp; 3 == 3)</code> 假<br><code>x != 0 &amp;&amp; (20 / x) &lt; 5</code> 只有当x不等于0时，才会对第2个表达式求值</p></blockquote></li><li><p>有关范围问题:</p><blockquote><p>&amp;&amp;运算符与islower()函数可用于测试范围</p></blockquote></li></ul><hr><h3 id="条件运算符-三元运算符"><a href="#条件运算符-三元运算符" class="headerlink" title="条件运算符/三元运算符"></a>条件运算符/三元运算符</h3><ul><li><p>C 提供条件表达式(conditional expression)作为表达if else语句的一种便捷方式</p></li><li><p>该表达式使用<code>? :</code>条件运算符</p><blockquote><p>该运算符分为两部分，需要三个运算对象<br>带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符<br>以此类推，带三个运算对象的运算符称为三元运算符<br>条件运算符是 C 中唯一的三元运算符</p></blockquote></li><li><p>条件表达式的通用形式如下:</p><blockquote><p><code>expression1 ? expression2 : expression3</code><br>如果 expression1 为真(非 0)，那么整个条件表达式的值与 expression2 的值相同<br>如果expression1为假(0)，那么整个条件表达式的值与 expression3的值相同</p></blockquote></li><li><p>需要把两个值中的一个赋给变量时，就可以用条件表达式</p><blockquote><p>典型的例子是，把两个值中的最大值赋给变量:<br><code>max = (a &gt; b) ? a : b;</code><br>如果a大于b，那么将max设置为a<br>否则，设置为b<br>通常，条件运算符完成的任务用 if else 语句也可以完成<br>但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码</p></blockquote></li></ul><hr><h3 id="循环辅助-continue-amp-break"><a href="#循环辅助-continue-amp-break" class="headerlink" title="循环辅助-continue&amp;break"></a>循环辅助-continue&amp;break</h3><ul><li>一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句</li><li>而continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环</li></ul><p><strong>continue语句</strong></p><ul><li><p>3种循环都可以使用continue语句</p><blockquote><p>执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代<br>如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环</p></blockquote></li><li><p>有两种方法可以避免使用continue</p><blockquote><p>一是省略continue，即为把剩余部分放在一个else块中<br>这种情况下，使用continue的好处是减少主语句组中的一级缩进<br>当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性<br>另一种方式是把if的测试条件的关系反过来便可避免使用continue<br>需要根据程序的实际情况而定</p></blockquote></li><li><p>continue还可用作占位符</p><blockquote><p>例如将循环读取并丢弃输入的数据， 直至读到行末尾<br>当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便<br>问题是，一般很难注意到一个单独的分号<br>如果使用continue，可读性会更高<br>如果用了continue没有简化代码反而让代码更复杂，就不要使用continue</p></blockquote></li><li><p>从何处开始继续循环:</p><blockquote><p>以上介绍了continue语句让程序跳过循环体的余下部分<br>对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值</p></blockquote></li></ul><p><strong>break语句</strong></p><ul><li><p>程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段</p><blockquote><p>但如果break语句位于嵌套循环内，它只会影响包含它的当前循环</p></blockquote></li><li><p>以下两张图片比较了break和continue</p></li></ul><img src="/images/数据类型-7补充图片/break和continue-1.png" width="40%" height="40%"> <img src="/images/数据类型-7补充图片/break和continue-2.png" width="40%" height="40%"><ul><li>break还可用于因其他原因退出循环的情况</li><li>和continue一样，如果用了break代码反而更复杂，就不要使用break</li><li>break语句对于稍后讨论的switch语句而言至关重要<blockquote><p>在for循环中的break和continue的情况不同<br>执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过<br>嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break</p></blockquote></li></ul><hr><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><ul><li>使用条件运算符和 if else 语句很容易编写二选一的程序<blockquote><p>然而，有时程序需要在多个选项中进行选择<br>可以用if else if…else来完成<br>但是大多数情况下使用switch语句更方便</p></blockquote></li></ul><p><strong>switch的工作原理分析</strong></p><ul><li><p>要对紧跟在关键字 switch 后圆括号中的表达式求值</p><blockquote><p>break语句让程序离开switch语句，跳至switch语 句后面的下一条语句<br>如果没有break语句，就会从匹配标签开始执行到switch末尾</p></blockquote></li><li><p>break语句可用于循环和switch语句中，但是continue只能用于循环中</p><blockquote><p>尽管如此，如果switch语句在一个循环中，continue便可作为 switch语句的一部分<br>这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分</p></blockquote></li><li><p>switch语句和Pascal的case语句类似</p><blockquote><p>它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句<br>另外，C 的case一般都指定一个值，不能使用一个范围</p></blockquote></li><li><p>switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)</p></li><li><p>case标签必须是整数类型(包括char类型)的常量或整型常量表达式(即表达式中只包含整型常量)</p><blockquote><p>不能用变量作为case标签</p></blockquote></li><li><p>switch的构造如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch ( 整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句&lt;--可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句&lt;--可选</span><br><span class="line">default :&lt;--可选</span><br><span class="line">语句&lt;--可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于程序只读每行的首字符的情况这里不做多余赘述</p></li></ul><hr><p><strong>有关多重标签</strong></p><ul><li>可以在switch语句中使用多重case标签</li><li>如果使用ctype.h系列的toupper()函数可以避免 使用多重标签</li></ul><hr><p><strong>有关switch和if else</strong></p><ul><li>关于何时使用switch与何时使用if else<blockquote><p>如果是根据浮 点类型的变量或表达式来选择，就无法使用 switch<br>如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦<br>这种情况用if就很方便:<br><code>if (integer &lt; 1000 &amp;&amp; integer &gt; 2)</code></p></blockquote></li><li>使用switch要涵盖以上范围，需要为每个整数(3～999)设置case标签<blockquote><p>但是，如果使用switch，程序通常运行快一些，生成的代码少一些</p></blockquote></li></ul><hr><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><ul><li><p>早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用</p><blockquote><p>但 是C和其他两种语言不同，没有goto语句C程序也能运行良好<br>Kernighan和 Ritchie提到goto语句”易被滥用”，并建议”谨慎使用，或者根本不用”</p></blockquote></li><li><p>goto语句有两部分: goto和标签名</p></li><li><p>标签的命名遵循变量命名规则如下所示:</p><blockquote><p><code>goto part2;</code></p></blockquote></li><li><p>要让这条语句正常工作，函数还必须包含另一条标为part2的语句</p><blockquote><p>该语句以标签名后紧跟一个冒号开始:<br><code>part2: printf(&quot;Refined analysis:\n&quot;);</code></p></blockquote></li></ul><p><strong>避免使用goto</strong></p><ul><li><p>原则上，根本不用在C程序中使用goto语句</p><blockquote><p>但在FORTRAN或BASIC内，goto对这两种语言而言都必不可少，而且还会依赖用goto来编程<br>对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if<br>不能使用块或复合语句</p></blockquote></li><li><p>跳转至循环末尾，并开始下一轮迭代</p><blockquote><p>C使用continue语句代替跳出循环</p></blockquote></li><li><p>C使用break语句</p><blockquote><p>实际上，break和continue是goto的特殊形式<br>使用break和continue的好处是: 其名称已经表明它们的用法，而且这些语句不使用标签<br>所以不用担心把标签放错位置导致的危险<br>胡乱跳转至程序的不同部分</p></blockquote></li><li><p>但是，C程序员可以接受一种goto的用法: 出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)</p></li><li><p>不去使用goto的多个理由:</p><blockquote><p>程序中使用其他形式比使用goto的条理更清晰<br>当多种情况混在一起时，这种差异更加明显<br>哪些goto语句可以帮助if 语句? 哪些可以模仿if else? 哪些控制循环?<br>哪些是因为程序无路可走才不得已放在那里?<br>过度地使用goto语句，会让程序错综复杂<br>如果不熟悉goto语句，就不要使用它<br>如果已经习惯使用goto语句，试着改掉这个毛病<br>讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用<br>因为 C允许在标签中使用描述性的单词而不是数字</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>CN/PDF-C Primer Plus【第6版】</p><blockquote><p>[美] Stephen Prata | 著/姜佑 | 译<br>截止至原书第七章末尾-496页(一共1635页)<br>C 控制语句: 分支和跳转-7.10/7.12</p></blockquote></li><li><p>数据类型-1~数据类型-7</p><blockquote><p>C11/ANSI C/ISO C</p></blockquote></li></ul><hr><ul><li>接下来的内容会以 C 冠名</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-3&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-6</title>
    <link href="https://unit-serow.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6/"/>
    <id>https://unit-serow.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6/</id>
    <published>2020-03-13T05:13:26.000Z</published>
    <updated>2020-03-13T05:15:52.575Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-2</strong></center><a id="more"></a><h2 id="数据类型-6"><a href="#数据类型-6" class="headerlink" title="数据类型-6"></a>数据类型-6</h2><ul><li>循环结构内容补充(控制结构)<blockquote><p>for循环<br>do while循环<br>数组与循环<br>函数与循环<br>其它赋值运算符</p></blockquote></li></ul><hr><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul><li><p>for循环将循环语句最基本的三种行为(初始化，测试和更新)组合在一处</p><blockquote><p>其基本的语法格式为: <code>for (xxx;xxx;xxx){}</code></p></blockquote></li><li><p>关键字for后面的圆括号中的若干个表达式用分号相隔，一般在圆括号中会有至少三个表达式</p></li><li><p>即为初始化表达式，测试条件表达式，更新执行表达式</p><blockquote><p>还可将其称之为包含了循环所需的所有信息: 所选变量的初值，所选变量的终值，所选变量的循环条件(条件表达式或为自增或自减)</p></blockquote></li><li><p>在花括号内可以添加简单语句和复合语句</p></li><li><p>测试表达式的值为真时则继续循环，为假时则停止循环，其它关于的循环基本概念在<a href="http://unit-serow.com/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/#more" target="_blank" rel="noopener">数据类型-5</a>内有详细介绍</p></li><li><p>还可以将for语句圆括号内的表达式称之为控制表达式，它们都是完整的表达式，所以每个表达式的副作用(例如递增变量之类的)都发生在对下一个表达式求值之前</p></li></ul><p><strong>for循环的结构图示</strong></p><ul><li>for循环的结构:</li></ul><img src="/images/数据结构-6/for循环的结构-1.png" width="40%" height="40%"><hr><p><strong>利用C 内 for的灵活性</strong></p><ul><li><p>虽然for循环看上去和FORTRAN的DO循环，Pascal的FOR循环，ASIC 的FOR…NEXT循环类似</p><blockquote><p>但是for循环比这些循环灵活<br>这些灵活性源于如何使用for循环中的3个表达式<br>即为: 1-初始值(变量经由初始化得到的值)，2-条件表达式，3-返回类型所需要执行的某种方法(或称其为每次迭代需要执行的条件)<br>第3个表达式可以使用任意合法的表达式<br>无论是什么表达式，每次迭代都会更新该表达式的值<br>for循环中的3个表达式可以是不同的变量(注意，虽然该例可以正常运行，但是编程风格不太好，如果不在更新部分加入代数计算，程序会更加清楚)<br>可以省略一个或多个表达式(但是不能省略分号)，只要在循环中包含能结束循环的语句即可<br>这句话的意思就是，可以不在圆括号内写条件的表达式，而在for()代码行下对for语句进行说明，此时被进行说明的语句必须带有结束表示分号<br>有没有花括号无所谓，添加花括号的理由是为了让代码更整洁且直观<br>这样使用for循环确实很像其他语言的循环<br>除此之外，C 的for循环还有其他9种用法</p></blockquote></li><li><p>需要注意的要点-1: 在执行循环的其他部分之前，只对第一个表达式求值一次或执行一次</p></li><li><p>同时对于循环体中的行为可以改变循环头中的表达式，此时需要用到if语句与选择语句的概念，即为在for语句中添加复合语句，该复合语句用于执行if等条件选择语句，也可称该复合语句为代码块</p></li><li><p>for语句的一般形式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( initialize; test; <span class="keyword">update</span> )</span><br><span class="line"><span class="keyword">statement</span></span><br></pre></td></tr></table></figure><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例语句:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="built_in">n</span> = <span class="number">0</span>; <span class="built_in">n</span> &lt; <span class="number">10</span> ; <span class="built_in">n</span>++)</span><br><span class="line">printf(<span class="string">" %d %d\n"</span>, <span class="built_in">n</span>, <span class="number">2</span> * <span class="built_in">n</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="其它赋值运算符"><a href="#其它赋值运算符" class="headerlink" title="其它赋值运算符"></a>其它赋值运算符</h2><ul><li><p>包括<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code></p></li><li><p>C有许多赋值运算符</p><blockquote><p>最基本，最常用的是=，它把右侧表达式的值赋给左侧的变量<br>其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式<br>赋给变量的新值是根据右侧表达式的值调整后的值<br>而确切的调整方案取决于具体的运算符</p></blockquote></li><li><p>例如:</p><blockquote><p><code>scores += 20</code> 与 <code>scores = scores + 20</code> 相同<br><code>dimes -= 2</code> 与 <code>dimes = dimes - 2</code> 相同<br><code>bunnies *= 2</code> 与 <code>bunnies = bunnies * 2</code> 相同<br><code>time /= 2.73</code> 与 <code>time = time / 2.73</code> 相同<br><code>reduce %= 3</code> 与 <code>reduce = reduce % 3</code> 相同</p></blockquote></li><li><p>上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式</p></li><li><p>例如：</p><blockquote><p><code>x *= 3 * y + 12 与 x = x * (3 * y + 12)</code> 相同</p></blockquote></li><li><p>以上提到的赋值运算符与<code>=</code>的优先级相同，即比<code>+</code>或<code>*</code>优先级低</p><blockquote><p>上面最后一个例子也反映了赋值运算符的优先级，<code>3 * y</code>先与<code>12</code>相加，再把计算结果与<code>x</code>相乘，最后再把乘积赋给x<br>并非一定要使用这些组合形式的赋值运算符<br>但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效<br>当需要在<code>for</code>循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用</p></blockquote></li><li><p>通常在for的循环头内就能完成大量的工作</p></li></ul><hr><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><ul><li><p>逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式</p></li><li><p>基本使用语法:</p><blockquote><p><code>for (ounces = 1, cost = FIRST_OZ; ounces &lt;= 16; counces++,cost += NEXT_OZ)</code><br>这里的<code>FIRST_OZ</code>和<code>NEXT_OZ</code>是常量数据类型，<code>NEXT_O</code>的值是20<br>在初始化表达式中使用了逗号来对ounces和cost都进行了初始化<br>同时也在更新表达式中使用逗号来表示每次执行迭代时ounces递增1与cost递增20(因为<code>NEXT_Z</code>的值是20)</p></blockquote></li><li><p>逗号运算符的作用就是在同一个表达式区块内进行多组条件的声明</p><blockquote><p>比如在初始化表达式区块中，同时对两个变量进行初始化，或者在更新表达式中声明两个不同的变量在迭代时使用的规则与条件</p></blockquote></li><li><p>逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方</p><blockquote><p>逗号运算符有两个其他性质<br>首先，它保证了被它分隔的表达式从左往右求值(换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生)<br>因此，ounces在cost之前被初始化<br>在该例中， 顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要<br>例如，假设有下面的表达式:<br><code>ounces++, cost = ounces * FIRST_OZ</code><br>在该表达式中，先递增ounce，然后在第2个子表达式中使用ounce的新值<br>作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生</p></blockquote></li><li><p>其次，整个逗号表达式的值是右侧项的值</p></li></ul><p><strong>图解说明逗号表达式的执行逻辑</strong></p><ul><li>逗号运算符和for循环:</li></ul><img src="/images/数据结构-6/逗号运算符和for循环-1.png" width="40%" height="40%"><ul><li>在进行复杂的计算之前，可以先看看数学上是否有简单的方法可用</li></ul><hr><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><ul><li><p>出口条件循环</p></li><li><p>while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所有有可能根本不执行循环体中的内容</p></li><li><p>C 中的出口条件循环(exit-condition loop)的作用是在循环的每次迭代后检查测试条件，以保证至少执行循环体中的内容以此，这种循环被称为do while循环</p></li><li><p>do while循环的通用形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">statement</span></span><br><span class="line"><span class="keyword">while</span> ( expression );</span><br></pre></td></tr></table></figure></li><li><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例程序:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">scanf(<span class="string">"%d"</span>,　&amp;<span class="built_in">number</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span>　(<span class="built_in">number</span>　!=　<span class="number">20</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>statement可以是一条简单语句或复合语句</p><blockquote><p>注意，do while循环以分号结尾<br>do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次<br>而for循环或while循环都是在执行循环体之前先执行测试条件<br>dowhile循环适用于那些至少要迭代一次的循环<br>例如，对用户输入的密码进行测试的程序</p></blockquote></li><li><p>do while循环的结构示意图:</p></li></ul><img src="/images/数据类型-6/do while循环结构-1.png" width="40%" height="40%"><ul><li>其它注解:</li><li>do while语句创建一个循环，在expression为假或0之前重复执行循环体中的内容<blockquote><p>do while语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环<br>因此，该循环至少必须执行一次<br>statement部分可是一条简单语句或复合语句</p></blockquote></li></ul><hr><h3 id="关于对循环的选择"><a href="#关于对循环的选择" class="headerlink" title="关于对循环的选择"></a>关于对循环的选择</h3><ul><li><p>首选需要确定是需要入口条件循环还是出口条件循环</p></li><li><p>通常，入口条件循环用的比较多</p></li><li><p>有几个原因:</p><blockquote><p>其一，一般原则是在执行循环之前测试条件比较好<br>其二，测试放在循环的开头，程序的可读性更高<br>另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环<br>那么，假设需要一个入口条件循环，用for循环还是while循环取决于个人喜好，因为二者皆可</p></blockquote></li><li><p>要让for循环看起来像while循环，可以省略第1个和第3个表达式</p><blockquote><p><code>for ( ; test ; )</code>与此的while效果相同: <code>while ( test )</code></p></blockquote></li><li><p>要让while循环看起来像for循环，可以在while循环的前面初始化变量， 并在while循环体中包含更新语句</p></li><li><p>例如:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化;</span><br><span class="line"><span class="keyword">while</span> ( 测试 )</span><br><span class="line">&#123;</span><br><span class="line">其他语句</span><br><span class="line">更新语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与下面的for循环效果相同:</p><blockquote><p><code>for ( 初始化 ;测试 ; 更新 )</code></p></blockquote></li></ul><p><strong>其他语句:</strong></p><ul><li>一般而言，当循环涉及初始化和更新变量时，用for循环比较合适<blockquote><p>而在其他情况下用while循环更好</p></blockquote></li><li>对于下面这种条件，用while循环就很合 适：<blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1)</code></p></blockquote></li><li>对于涉及索引计数的循环，用for循环更适合</li><li>例如:<blockquote><p><code>for (count = 1; count &lt;= 100; count++)</code></p></blockquote></li></ul><hr><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><ul><li><p>嵌套循环(nested loop)指在一个循环内包含另一个循环</p><blockquote><p>嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行</p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHARS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">for</span> (row=<span class="number">0</span>;row&lt;ROWS;row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ch=<span class="string">'A'</span>;ch&lt;(<span class="string">'A'</span>+CHARS);ch++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br></pre></td></tr></table></figure></li><li><p>程序分析:</p><blockquote><p>第10行开始的for循环被称为外层循环(outer loop)<br>第12行开始的for循环被称为内层循环(inner loop)<br>外层循环从row为0开始循环，到row为6时结束<br>因此，外层循环要执行6次，row的值从0变为5<br>每次迭代要执行的第1条语句是内层的for循环，该循环要执行10次，在同一行打印字符A～J<br>第2条语句是外层循环的printf(“\n”);<br>该语句的效果是另起一行，这样在 下一次运行内层循环时，将在下一行打印的字符<br>注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环<br>在程序中，内层循环一行打印10个字符，外层循环创建6行</p></blockquote></li><li><p>此实例中，内层循环和外层循环所做的事情相同</p></li><li><p>可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务</p><blockquote><p>比如可以根据上面的程序来修改内层循环条件<br>比如让row和A相加，而因为ch是char类型的，所以每次迭代所带来的结果就是将其初始化为不同的字符，所以程序每次对字符的打印数量都会比上一行少一个，如果没有改变测试条件，每行依旧会以F结尾<br>还可称其为依赖外部循环的嵌套循环，只不过不应该存在这种说法，因为这只是最基本的线性逻辑</p></blockquote></li></ul><hr><h3 id="关于在循环中使用数组"><a href="#关于在循环中使用数组" class="headerlink" title="关于在循环中使用数组"></a>关于在循环中使用数组</h3><ul><li><p>因为循环内经常需要用到数组，这里先对数组进行简单的说明</p><blockquote><p>数组可以作为一种存储多个相关项的便利方式</p></blockquote></li><li><p>数组(array)是按顺序存储一系列类型相同的值，如10个char类型的字符或15个int类型的值</p><blockquote><p>整个数组有一个数组明，通过整数下标来访问数组中单独的项或元素(element)</p></blockquote></li><li><p>以下是对数组进行声明的基本语法格式:</p><blockquote><p>float debts[20];</p></blockquote></li><li><p>声明debts是一个内含20个元素的数组，每个元素都可以存储float类型的值</p><blockquote><p>数组的第一个元素是debts[0]，第二个元素是debts[1]，以此类推，直到debts[19]<br>这里需要进行注意的一点就是，数组元素的编号从0开始，而非1<br>此时可以给每个元素赋float类型的值</p></blockquote></li><li><p>赋值的基本语法格式:</p><blockquote><p>debt[6] = 32.49;<br>debt[7] = 1.2e+21;</p></blockquote></li><li><p>实际上，使用数组元素和使用同类型的变量意义</p><blockquote><p>例如，可以这样把值读入指定的元素之中:<br>scanf(“%f”, &amp;debts[4]);</p></blockquote></li><li><p>这里要注意个潜在的陷阱，考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确</p><blockquote><p>所以千万不要书写和使用数组中不存在的元素，因为编译器不会查找这样的错误<br>当运行程序时，这种情况会导致数据被放在在已被其它数据占用的地方，可能会破坏程序的结果甚至导致程序因异常而中断</p></blockquote></li><li><p>数组的类型可以是任意的数据类型</p><blockquote><p>int nannies[22];<br>char actors[26];<br>long big[500];</p></blockquote></li><li><p>可以把字符串存储在char类型的数组中(一般而言，char类型数组的所有元素都存储char类型的值)</p><blockquote><p>如果char类型的数组末尾包含了一个表示字符串末尾的空字符\0，则该数组的内容就构成了一个字符串</p></blockquote></li><li><p>图解字符串数组和字符串:</p></li></ul><img src="/images/数据类型-6/字符串和字符串数组.png" width="40%" height="40%"><ul><li><p>用于识别数组元素的数字被称为下标(subscript)，索引(indice)或偏移量(offset)</p><blockquote><p>下标必须是整数，而且要从0开始计数<br>数组内的元素依次被存储在内存中相邻的为止</p></blockquote></li><li><p>图解内存中的char和int类型的数组:</p></li></ul><img src="/images/数据类型-6/内存中的char和int类型的数组.png" width="40%" height="40%"><ul><li><p>在for循环中可以使用数组，也就是使用循环来处理数组</p></li><li><p>在调整循环语句的逻辑描述时，要时刻遵守模块化(modularity)原则</p><blockquote><p>模块化原则的思想就是: 应把程序划分为一些独立的单元，每个单元执行一个任务<br>这样做能够提升程序的可读性<br>最重要的是，模块化使程序的不同部分彼此独立，方便以后更新或修改程序<br>还可以将每个执行任务的单元放进函数中，提高程序的模块化</p></blockquote></li></ul><hr><ul><li>在循环内使用函数的返回值</li><li>使用带返回值的函数</li><li>此部分可能会被补充</li></ul><hr><h3 id="概念归纳"><a href="#概念归纳" class="headerlink" title="概念归纳"></a>概念归纳</h3><ul><li>循环是一个强大的编程工具<blockquote><p>在创建循环时，要特别注意以下3个方面:</p></blockquote></li></ul><ol><li>注意循环的测试条件要能使循环结束</li><li>确保循环测试中的值在首次使用之前已初始化</li><li>确保循环在每次迭代都更新测试的值</li></ol><ul><li><p>C通过求值来处理测试条件，结果为0表示假，非0表示真</p><blockquote><p>带关系运算符的表达式常用于循环测试，它们有些特殊<br>如果关系表达式为真，其值为 1<br>如果为假，其值为0<br>这与新类型<code>_Bool</code>的值保持一致</p></blockquote></li><li><p>数组由相邻的内存位置组成，只储存相同类型的数据</p><blockquote><p>记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少1<br>C编 译器不会检查数组下标值是否有效，自己要多留心</p></blockquote></li><li><p>使用函数涉及3个步骤:</p></li></ul><ol><li>通过函数原型声明函数</li><li>在程序中通过函数调用使用函数</li><li>定义函数</li></ol><ul><li>函数原型是为了方便编译器查看程序中使用的函数是否正确<blockquote><p>函数定义描述了函数如何工作<br>现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义<br>接口部分描述了如何使用一个特性，也就是函数原型所做的<br>实现部分描述了具体的行为，这正是函数定义所做的</p></blockquote></li></ul><hr><ul><li>在便于理解的前提下，对代码的总体大小进行优化<blockquote><p>易于理解和维护的代码才是好代码<br>没必要去理解或书写一些逻辑严谨到夸张的地步和使用一大片符号类型的代码<br>可以将一句逻辑严谨的代码写成两句或三句便于理解的代码，当然是在保持美观的前提下<br>即模块化原则</p></blockquote></li></ul><hr><p><strong>内容来自原书第六章节</strong></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-2&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C-资源整合目录</title>
    <link href="https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/"/>
    <id>https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/</id>
    <published>2020-03-12T15:55:11.000Z</published>
    <updated>2020-03-13T10:03:35.204Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>C-资源整合目录</strong></center><a id="more"></a><h3 id="C-资源整合目录"><a href="#C-资源整合目录" class="headerlink" title="C 资源整合目录"></a>C 资源整合目录</h3><ul><li>电子书籍</li><li>URL地址</li><li>参考资料</li></ul><hr><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><ul><li>EN-C Primer Plus</li><li>CN-C 程序设计语言</li><li>CN-数据结构与算法分析-C 语言实现</li><li>CN-C Primer Plus (第六版)<blockquote><p>C11标准<br>作者: Stephen Prata<br>译者: 姜佑</p></blockquote></li></ul><hr><p><strong>书籍目录:</strong></p><ul><li>第一章/第二章-基本概念与书籍介绍</li><li>第三章-数据和C</li><li>第四章-字符串和格式化输入/输出</li><li>第五章-运算符，表达式和语句</li><li>第六章-C控制语句：循环</li><li>第七章-C控制语句：分支和跳转</li><li>第八章-字符输入/输出和输入验证</li><li>第九章-函数</li><li>第十章-数组和指针</li><li>第十一章-字符串和字符串函数</li><li>第十二章-存储类别，链接和内存管理</li><li>第十三章-文件输入/输出</li><li>第十四章-结构和其它数据形式</li><li>第十五章-位操作</li><li>第十六章-C预处理器和C库</li><li>第十七章-高级数据表示</li></ul><p><strong>笔记归纳:</strong></p><ul><li>第一/二/三章被归纳于数据类型-1/2内</li><li>第四章被归纳于数据类型-3/4内</li><li>第五章被归纳于数据类型-5内</li><li>第六章被归纳于数据类型-6内</li><li></li></ul><hr><ul><li>本书一共十七个章节，预计使用最多50个笔记文本进行刨析归纳<blockquote><p><code>17*2+16=50</code></p></blockquote></li></ul><hr><ul><li><p>相关资源整合包</p></li><li><p><a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">百度网盘地址</a>:</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA</a><br>提取码: 0ez0</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;C-资源整合目录&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-5</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/</id>
    <published>2020-03-12T11:14:12.000Z</published>
    <updated>2020-03-12T11:16:20.592Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-1</strong></center><a id="more"></a><h2 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型-5"></a>数据类型-5</h2><ul><li>语句与表达式-1<blockquote><p>C-控制语句/循环-While<br>C-控制语句/选择<br>关系运算及其关系运算符<br>条件表达式<br>真与假的概念<br>循环逻辑概念与原理</p></blockquote></li></ul><hr><ul><li>通常一门语言应该提供以下三种形式的程序流<blockquote><p>执行语句序列(即为线性的执行逻辑)<br>如果满足某些条件就进行重复执行的语句序列(循环)<br>通过测试选择执行哪一个语句序列(分支/控制)</p></blockquote></li></ul><hr><h2 id="C-控制语句-循环"><a href="#C-控制语句-循环" class="headerlink" title="C 控制语句-循环"></a>C 控制语句-循环</h2><h3 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h3><ul><li><p>while循环是入口条件循环</p><blockquote><p>或称其为while循环是使用入口条件的有条件循环<br>所谓的有条件指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)<br>该表达式是一个入口条件(entry condition)，因为必须满足条件才能进入循环体<br>如果条件一开始就为假，则绝对不会进入循环体，则跳过循环体代码块</p></blockquote></li><li><p>可以把下面的伪代码作为while循环的标准格式:</p></li></ul><p>1.利用循环外的语句对循环内的变量进行值传递<br>2. 获得第1个用于测试的值 (while (循环条件))<br>3. 当测试为真时<br>4. 处理值 (根据循环条件)<br>5. 获取下一个值 scanf()</p><ul><li><p>当被输入的值传递进循环并可以保证条件为真时，开始第一轮循环</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>); <span class="comment">/* 定义被输入值的变量 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">status</span> == <span class="number">1</span>) <span class="comment">/* 定义循环条件 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>);  <span class="comment">/* 定义循环行为，即接受被输入的值，当接受的值可以满足循环条件时则为真，开始迭代 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以写为</p><blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1){/* 循环行为 */}</code></p></blockquote></li><li><p>while循环的通用形式如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( expression )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>其中statement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句</p></li><li><p>在大部分的程序内，expression部分都使用关系表达式</p><blockquote><p>也就是说，expression是值之间的比较，可以使用任何表达式<br>如果expression为真(或者更一般地说，非零)，则执行statement部分一次，然后再次判断expression<br>在expression为假(0)之前，循环的判断和执行一直重复进行<br>每次循环都被称为一次迭代/循环一轮(iteration)</p></blockquote></li><li><p>while循环结构示意图:</p></li></ul><img src="/images/数据类型-5/C-循环语句-1.png" width="30%" height="30%"><ul><li><p>while循环有一点非常重要: 在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假</p><blockquote><p>否则，循环就不会终止(可以使用 break和if语句来终止循环)</p></blockquote></li><li><p>最大正值加一一般 会得到一个负值，类似地，最小负值减一一般会得到最大正值</p></li></ul><hr><h3 id="while的语法要点"><a href="#while的语法要点" class="headerlink" title="while的语法要点"></a>while的语法要点</h3><ul><li><p>使用while时，要牢记一点: 只有在测试条件后面的单独语句(简单语句或符合语句)才是循环部分</p><blockquote><p>while循环语句的格式应为while(){}，而绝非{while()}，陷入无限循环(infinite loop)是最常见的情况</p></blockquote></li><li><p>还有一点就是，即便while语句本身使用符合语句，while的本质依旧是一条单独的语句(或称为在语句构成上)</p><blockquote><p>该语句从while开始执行，到第一个分号结束，在使用复合语句的情况下，到右花括号结束，还需要注意分号的为止，一定要在语句结束时再写分号</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li><li><p>在使用while语句时，可以直接将分号写在条件表达式后面，即可以让程序直接进入下一个迭代，因为一个单独的分号被视为一条语句</p></li><li><p>如果在测试条件(条件表达式)的代码后面直接添加单独的分号</p><blockquote><p>此分号则代表为一个空语句(null statement)，它什么也不做<br>在 C 中，单独的分号表示空语句，而处理空语句最好的方法是使用continue语句</p></blockquote></li></ul><hr><h3 id="关系运算符与表达式"><a href="#关系运算符与表达式" class="headerlink" title="关系运算符与表达式"></a>关系运算符与表达式</h3><ul><li><p>用关系运算符和表达式来比较大小</p></li><li><p>以下关于关系表达式与关系运算符的概念在所有的循环类语句概念中都通用，这里的通用泛指计算机上所有的程序语言</p></li><li><p>while循环经常依赖测试表达式来作比较，这样的表达式被称之为关系表达式(relational expression)</p></li><li><p>而出现在关系表达式中间的运算符叫做关系运算符(relational operator)</p></li><li><p>以下表图片内列出了 C 的所有关系运算符，同时该表也涵盖了所有的数值关系</p></li><li><p>关系运算符:</p></li></ul><img src="/images/数据类型-5/关系运算符-1.png" width="30%" height="30%"><ul><li><p>PS: 数字之间的关系再复杂也没有人与人之间的关系复杂-来自原书</p></li><li><p>关系运算符常用于构造while语句和其他C语句中用到的关系表达式</p><blockquote><p>这些语句都会检查关系表达式为真还是为假</p></blockquote></li><li><p>所谓关系运算符，存在的意义就是对人为所描述的表达式的值进行确定，确定的结果只有0和1，即真与假</p></li><li><p>而在确定的过程中，最常见的确定方法就是与人为所规定的值进行字符的比较</p></li><li><p>如果要对浮点数进行比较，尽量要去只是用&lt;和&gt;，因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等</p></li><li><p>为了避免此类型错误的发生，C 内拥有fabs()函数，该函数声明在math.h头文件中</p><blockquote><p>使用该函数可以较为方便的比较浮点数，该函数返回一个浮点的绝对值(即为没有代数符号的值)</p></blockquote></li></ul><hr><p><strong>fabs()函数使用示范:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">double</span> response;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"What is the value of pi?\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"lf"</span>, &amp;response);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Try again!\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Close enough!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差 0.0001：</p></li><li><p>输出结果:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">is</span> the value of pi?</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">Try again!</span><br><span class="line"><span class="number">3.1416</span></span><br><span class="line">Close enough!</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="何为真"><a href="#何为真" class="headerlink" title="何为真"></a>何为真</h3><ul><li><p>这是一个古老的问题，但是对C而言还不算难、</p></li><li><p>在C中，表达式一定有 一个值，关系表达式也不例外</p></li><li><p>可以使用并输出两条简单的比较语句，比如说 <code>true_val=(10&gt;2);</code>和<code>false_val(10==2);</code>，前者为真，后者为假</p><blockquote><p>则输出的结果必定是true=1，而false=0</p></blockquote></li><li><p>所以说，对 C 而言，表达式为真的值为1，表达式为假的值为0</p></li><li><p>当 C 程序的循环结构的判断结果一直为真(即为1)时，则反复且永远进行条件及语句的迭代</p></li><li><p>所以一些C程序使用下面的结构，由于1为真，所以该循环会一直进行</p><blockquote><p><code>while (1){...}</code></p></blockquote></li></ul><p><strong>关于其它的真值:</strong></p><ul><li><p>在 C 中，所有的非零值都被视为真，只有0被视为假</p><blockquote><p>也就是说，只要测试条件的值为非零，就会执行while循环</p></blockquote></li><li><p>这是从数值方面而不是从真/假方面来看测试条件</p><blockquote><p>还有需要进行牢记的一点就是，关系表达式为真，求值得一，关系表达式为假，求值得零<br>因此，这些表达式实际上相当于数值，所以必须要去充分利用测试条件的这一特性<br>比如，用while(goats)替换while(goats !=0)，因为表达式goats !=0和goats都只有在goats的值为0时才为0或假，所以再增加一个不等于(!=)的比较运算符的毫无意义的<br>这里利用了 C 内自动判断真值与假值的性质，或称其为默认值与自然选择</p></blockquote></li><li><p>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编译代码，从而使代码更加整洁与美观</p></li><li><p>这个特点既为好处，也为坏处，C 由于对真的约束太少，会带来一些麻烦</p><blockquote><p>当循环的条件表达式中没有定义==1，而定义了=1时，此时的条件表达式中的变量的值为一<br>而且，整个赋值表达式的值就是赋值运算符左侧的值，所以变量=1的值也是1，既while(变量=1)实际上就相当于while(1)<br>也就是说，循环不会退出，此时如果人为的输入其它的符号，从而让变量的值归于0，但是循环的测试条件又把改变量重置为1，从而又进入了下一次迭代<br>此时程序中的循环一直运行着，用户在输如符号后完全没有机会输入，如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，以供下一次读取<br>当scanf()把输入的符号(这里的符号可以为任何不属于数字的数据类型)作为整数读取失败了，他将会把字符留下<br>在下一次循环时，scanf()从上次读取失败的地方(被输入字符)开始读取，scanf()把该输入的字符再次作为整数读取，然后又失败了<br>以此，就造成了一个无限的循环，而且还是失败的</p></blockquote></li><li><p>所以这里千万需要注意的一点就是，千万别把关系相等运算符==和赋值运算符=给弄错了</p></li><li><p>因为 C 不允许给常量赋值</p><blockquote><p>而且编译器会把赋值运算符的这种用法作为语法错误标记出来<br>可以在构建比较是否相等的表达式时，把常量放在左侧，比如<code>6 = canoes;</code></p></blockquote></li><li><p>好在计算机察觉不出来，因为对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样-来自原文</p></li><li><p>总之，关系运算符用于构成关系表达式</p><blockquote><p>关系表达式为真时值为1，为假时值为0<br>通常用关系表达式作为测试条件的语句(如while和if)可以使用任何表达式作为测试条件<br>即非零为真，零为假</p></blockquote></li><li><p>以类似于<code>while (条件表达式)</code>这样的格式为变量进行命名可以让while循环的测试变得简单易懂</p></li></ul><hr><h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a><code>_Bool</code>类型</h3><ul><li><p>在 C 中，一直用int类型的变量表示真/假值</p></li><li><p>C99专门针对这种类型 的变量新增了<code>_Bool</code>类型</p><blockquote><p>该类型是以英国数学家George Boole的名字命名 的，他开发了用代数表示逻辑和解决逻辑问题<br>在编程中，表示真或假的变量被称为布尔变量(Boolean variable)，所以<code>_Bool</code>是 C 中布尔变量的类型名<br>其中<code>_Bool</code>类型的变量只能储存1(真)或0(假)<br>如果把其他非零数值赋给<code>_Bool</code>类型的变量，该变量会被设置为1<br>这反映了C把所有的非零值都视为真<br>给布尔变量取一个能表示真或假值的变量名是一种常见的做法</p></blockquote></li><li><p>C99提供了<code>stdbool.h</code>头文件，该头文件让<code>bool</code>成为<code>_Bool</code>的别名</p><blockquote><p>而且还把true和false分别定义为1和0的符号常量<br>包含该头文件后，写出的代码可以与C++兼容<br>因为C++把bool，true和false定义为关键字<br>如果系统不支持<code>_Bool</code>类型，导致无法运行该程序<br>可以把<code>_Bool</code>替换成 int即可</p></blockquote></li></ul><hr><h3 id="优先级和关系运算符"><a href="#优先级和关系运算符" class="headerlink" title="优先级和关系运算符"></a>优先级和关系运算符</h3><ul><li><p>关系运算符的优先级比算术运算符(包括+和-)要更低，而比赋值运算符要高</p></li><li><p>关系运算符之间有两种不同的优先级。</p><blockquote><p>高优先级组: &lt;&lt;= &gt;&gt;=<br>低优先级组: == !=</p></blockquote></li><li><p>与其他大多数运算符一样，关系运算符的结合律也是从左往右</p></li><li><p>以下图片列表列出了常用的关系运算符优先级关系，具体可以参考-[C 运算符]，其中列出了全部运算符的完整优先级列表</p></li><li><p>运算符优先级:</p></li></ul><img src="/images/数据类型-5/C-关系运算符优先级-1.png" width="30%" height="30%"><hr><h3 id="关于不确定循环和计数循环"><a href="#关于不确定循环和计数循环" class="headerlink" title="关于不确定循环和计数循环"></a>关于不确定循环和计数循环</h3><ul><li><p>一些while循环是不确定循环(indefinite loop)</p><blockquote><p>所谓不确定循环，指 在测试表达式为假之前，预先不知道要执行多少次循环</p></blockquote></li><li><p>还有一类是计数循环(counting loop)</p><blockquote><p>这类循环在执行循环之前就知道要重复执行多少次</p></blockquote></li><li><p>在创建一个重复执行固定次数的循环中涉及了3个行为:</p></li></ul><p>1.必须初始化计数器<br>2.计数器与有限的值作比较<br>3.每次循环时递增计数器</p><ul><li>while循环的测试条件执行比较，递增运算符执行递增<blockquote><p>如果递增发生在循环的末尾，即可以防止不小心漏掉递增<br>因此，这样做比将测试和更新组合放在一起要好，但是计数器的初始化放在循环外，就有可能忘记初始化<br>此时可以用for循环来避免这种情况的发生</p></blockquote></li></ul><hr><p><strong>其它内容:</strong></p><ul><li>赋值运算符 用于将右值赋给左值，而左值通常为变量</li><li>赋值表达式</li><li>关系运算符 用于对左值和右值进行比较</li><li>条件运算符</li></ul><hr><h3 id="伪代码-pseudocode"><a href="#伪代码-pseudocode" class="headerlink" title="伪代码(pseudocode)"></a>伪代码(pseudocode)</h3><ul><li>是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应</li><li>伪代码有助于涉及程序的逻辑</li><li>确定程序的逻辑无误后，再把伪代码翻译成实际的代码</li><li>使用为伪代码的好处之一是，可以把注意力集中再程序的组织和逻辑上，不用在设计程序时还要分心去想如何用编程语言来表达自己的想法</li><li>例如可以用缩进来代表一块代码，不用考虑 C 的语法要用花括号把部分代码括起来</li></ul><hr><h3 id="其它理解"><a href="#其它理解" class="headerlink" title="其它理解"></a>其它理解</h3><hr><ul><li><p>程序按照序列逻辑进行线性执行</p></li><li><p>由主函数mian()开始</p><blockquote><p>然后线性执行主函数内所调用的函数和语句<br>而其它的函数也是相同的原理，函数内的任何语句都是根据线性逻辑来逐一执行<br>至于循环语句与控制语句也是由线性逻辑来执行的，即执行完该语句上面的所有语句，再进行对循环或控制语句的执行<br>各种基本数据对象根据逻辑构成语句(数据对象可以包括变量，数组，指针，运算符，关键字或对于其它函数的调用等等)</p></blockquote></li><li><p>语句构成函数</p></li><li><p>函数构成程序</p></li><li><p>在计算机内，构成任何数据对象的逻辑都是线性的，即逐一执行</p></li></ul><hr><ul><li>预处理器(对于头文件的处理方法，通常是在程序编译之前就已经将头文件中的内容处理完毕，处理的对象即为对于所指头文件内函数的对应调用)</li><li>头文件(给当前的程序本身提供外部函数的支持，即对于当前语言标准库的支持)</li></ul><ol><li>定义常量</li><li>定义全局变量</li><li>函数声明</li></ol><ul><li>主函数<code>main(){包括了对于其它函数的调用以及线性逻辑执行}</code><blockquote><p>对于其它函数的补充</p></blockquote></li></ul><hr><ul><li><p>声明函数的基本格式为: <code>void funtion_name (void) {函数内容}</code></p><blockquote><p>圆括号内所声明的参数可称其为形式参数，即为没有值，但有数据类型的变量数据类型<br>前者的void为函数本身的数据类型，最常用的是整形类型或长整型类型<br>函数的类型用于声明让函数实现的功能模块</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li><p>每个函数或每个花括号都可以被称为是代码块</p></li><li><p>写程序的大体逻辑</p></li></ul><ol><li>先将常量和全局变量声明完毕</li><li>进行函数声明</li><li>然后先写上主函数</li><li>再对函数进行补充，以实现其对应功能</li><li>最后再主函数中的内容进行补充(通常就是对已存在的函数进行进行逐一调用)</li><li>编译源代码并执行程序</li></ol><ul><li>在计算机内，一切的执行逻辑都是线性的</li></ul><hr><ul><li><p>条件表达式与条件语句的本质就是判断值的真假或称其为0或1，用更大的范围去描述则是0与任何实数，即0就是假，或称其为无，其它的任何数都是真，或称其为有</p></li><li><p>无论是循环语句，选择语句还是任何的控制语句(流程控制语句)，它们存在(或称其为存在)的意义都是为了对所选条件表达式的值进行判断，而判断的结果只有两个，即为0与1</p></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编写代码，从而使代码更加整洁与美观</li><li>千万不要忘了伪代码的概念，一般的思路梳理就是对所谓伪代码的实现</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-4</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/</id>
    <published>2020-03-12T01:55:21.000Z</published>
    <updated>2020-03-12T11:17:45.381Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-运算符与表达式-1</strong></center><a id="more"></a><h2 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型-4"></a>数据类型-4</h2><ul><li>重点为运算符与表达式</li></ul><hr><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p><strong>涉及概念:</strong></p><ul><li>一元运算符</li><li>二元运算符</li><li>左值与右值</li><li>表达式和语句</li><li>基本循环及其符合语句</li><li>副作用与序列点</li></ul><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p><strong>右值</strong></p><ul><li><p>右值(rvale)，通常只能是字面常量</p><blockquote><p>而字面常量不能常量赋值，因为常量本身就是它的值<br>因此，在使用赋值运算符=时，左侧的项必须是一个变量名<br>实际上，赋值运算符左侧必须引用一个存储位置，而最简单方法就是使用变量名<br>不过指针也可用于指向一个存储位置<br>概括地说，C 使用可修改的左值(modifiable lvalue)标记那些可赋值的实体(物理内存)</p></blockquote></li><li><p>术语概览: 数值对象，左值，右值和运算符</p></li><li><p>赋值表达式语句的目的是把值存储到内存位置上</p></li><li><p>用于存储值的数据存储区域被称之为对象(data object)</p></li><li><p>C 标准中只有提到赋值的概念时，才有可能涉及到对象这个术语</p></li><li><p>使用变量名是表示对象的唯一方法，除此之外还有其它的方法，例如指定数组的元素，结构的成员，或者使用指针表达式(指针中存储的是它所指对象的地址)</p></li><li><p>相关的具体细节这里不做过多阐述</p></li></ul><p><strong>左值</strong></p><ul><li><p>左值(lvalue)是C的术语，用于表示特定数据对象的名称或表达式</p><blockquote><p>因此，对象指的是实际的数据存储，而左值是用于表示或定位存储位置的标签</p></blockquote></li><li><p>对于早期的C，左值所涉及的意义:</p></li></ul><ol><li>它指定一个对象，所以引用内存中的地址</li><li>它可以在赋值运算符的左侧，左值(lvalue)中的l源自left</li></ol><ul><li>但后来的C标准中新增了const限定符，用const创建的变量为只读变量，即为不可修改<blockquote><p>因此，const标识符可以满足上面的第一项，而无法满足第二项<br>一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧<br>有些左值不能用于赋值运算符的左侧，因此，标准对左值的定义已经不能满足当前的状况<br>为此，C标准新定义了一个术语: 可修改的左值(modifable lvalue)，此方法用于标识可修改的对象<br>所以，赋值运算符的左侧应该是可修改的值，当前标准建议，使用术语对象定位值(object locator value)更好</p></blockquote></li></ul><hr><p><strong>右值</strong></p><ul><li><p>右值(rvalue)指的是能赋值给可修改左值的量，且本身不是左值</p><blockquote><p>右值中的r源自right</p></blockquote></li><li><p>右值可以是常量，变量或其它可求值的表达式(如，函数调用)</p><blockquote><p>实际上，当前标准在描述这一概念时使用的是表达式的值(value of an expression)，而非右值<br>右值示例: bmw = 2002;，此时的2002则为右值</p></blockquote></li><li><p>左值就是用于引用某指定内存位置的标识符，而右值即为存储于该内存位置的值</p></li><li><p>在名称学习时，被称为”项”(如，赋值运算符左侧的项)的就是运算符对象(operand)</p><blockquote><p>运算对象指的就是运算符操作的对象<br>还可以类似的将”=运算符的左侧对象”称之为是”应该是可修改的左值”</p></blockquote></li></ul><hr><h2 id="基本的算术运算符-一元-二元运算符"><a href="#基本的算术运算符-一元-二元运算符" class="headerlink" title="基本的算术运算符-一元/二元运算符"></a>基本的算术运算符-一元/二元运算符</h2><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul><li>二元运算符最基本的定义是运算对象至少是两个值</li><li>最基本的二元运算符是四则运算标识符</li></ul><p><strong>加法运算符</strong></p><ul><li>加法运算符(addition operator)用于加法运算，使其两侧的值相加<blockquote><p>而相加的值(运算对象)可以是对象，也可以是常量<br>比如 icome = salary + bribes;，计算机会查看加法运算符右侧的两个变量，即为右值，将其相加，然后将相加的和(返回的结果)赋值给变量income<br>这里需要注意的一点是，income，salary，bribes都是可修改的左值，因为每个变量都标识了一个可被赋值的数据对象<br>但是，表达式salary + brives是一个右值</p></blockquote></li></ul><p><strong>减法运算符</strong></p><ul><li>减法运算符(subtraction operator)用于减法运算，使其左侧的数减去右侧的数<blockquote><p>例如，下面的语句把200.0赋给takehome：<br>takehome = 224.00 – 24.00;<br>+和-运算符都被称为二元运算符(binary operator)，即这些运算符需要两个运算对象才能完成操作</p></blockquote></li></ul><hr><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul><li>一元运算符(unary operator)</li><li>一元运算符就是符号运算符，即仅需要运算一个运算对象的运算符<blockquote><p>类似于赋值运算符=，数值标识符-，+(正值与负值)，指针标识符&amp;和*等等</p></blockquote></li></ul><p><strong>符号运算符:-和+</strong></p><ul><li><p>减号还可用于标明或改变一个值的代数符号</p><blockquote><p>rocky = -12;，以这种方式使用的负号被称之为一元运算符</p></blockquote></li><li><p>在C90标准中新增了一元+运算符，它不会改变运算对象的值或符号</p><blockquote><p>只能这样使用: dozen = +12;<br>此时编译器不会报错，但是在以前，这样做是不被允许的</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>二元运算符和一元运算符:</li></ul><img src="/images/数据类型-4/运算符-1.png" width="30%" height="30%"><hr><p><strong>乘法运算符</strong></p><ul><li>符号*表示乘法<blockquote><p><code>cm = 2.56 * inch;</code>，该语句就是用2.56乘以inch，并将结果赋值给cm<br>因为C 内没有平方函数与指数函数，所以只能用循环语句来实现平方与其它指数级增长</p></blockquote></li></ul><p><strong>除法运算符</strong></p><ul><li><p>C使用符号/来表示除法</p></li><li><p>符号/左侧的值是被除数，右侧的值是除数</p><blockquote><p>例如，此表达式中four的值是<code>4.0: four = 12.0/3.0;</code></p></blockquote></li><li><p>整数除法和浮点数除法不同</p><blockquote><p>浮点数除法的结果是浮点数，而整数除法的结果是整数<br>整数是没有小数部分的数<br>这使得5除以3很让人头痛，因为实际结果有小数部分</p></blockquote></li><li><p>在C语言中，整数除法结果的小数部分被丢弃</p><blockquote><p>这一过程被称为截断(truncation)</p></blockquote></li><li><p>一般情况下最好避免混合类型的出现，即同一个除法表达式内同时出现整数与浮点数</p><blockquote><p>因为计算机不能真正的使用浮点数去除以整数，所以编译器会把两个运算对象转换成相同的类型<br>即在进行出发运算之前，将整数转换为浮点数，或将浮点数转换为整数</p></blockquote></li><li><p>在C99标准以前，C语言给语言的实现者留有一些空间</p><blockquote><p>让他们来决定如何进行负数的整数除法<br>一种方法是，舍入过程采用小于或等于浮点数的最大整数<br>当然，对于<code>3.8</code>而言，处理后的3符合这一描述<br>但是当需要处理<code>-3.8</code>时，该方法建议四舍五入为<code>-4</code><br>因为<code>-4</code> 小于<code>-3.8</code><br>但是，另一种舍入方法是直接丢弃小数部分<br>这种方法被称为”趋零截断”，即把<code>-3.8</code>转换成<code>-3</code><br>在C99以前， 不同的实现采用不同的方法<br>但是C99规定使用趋零截断<br>所以，应把-<code>3.8</code>转换成<code>-3</code></p></blockquote></li></ul><hr><ul><li>当同一个表达式内出现了多种不同种类的运算符时，运算符会出现优先级限制</li></ul><p><strong>图片说明:</strong></p><ul><li>目前为止文章内涉及的运算符优先级(从低至高):</li></ul><img src="/images/数据类型-4/运算符优先级-1.png" width="30%" height="30%"><ul><li>优先级和求值顺序<blockquote><p>运算符的优先级为表达式中的求值顺序提供了重要的依据，但是并没有规定所有的顺序<br>所以 C 给实现者留出了选择的余地</p></blockquote></li></ul><hr><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><ul><li>C 中有大约40个运算符，有些运算符比其它运算符常用的多<blockquote><p>这里只对最常用的运算符进行讨论</p></blockquote></li></ul><p><strong>sizefo运算符与其相关类型</strong></p><ol><li>sizeof运算符和<code>size_t</code>类型<blockquote><p>sizeof运算符以字节为单位返回运算对象的大小(在C中，1字节定义为char类型占用的空间大小)<br>过去，1字节通常是8位，但是一些字符集可能使用更大的字节<br>运算对象可以是具体的数据对象(如，变量名)或类型<br>如果运算对象是类型(如， float)，则必须用圆括号将其括起来</p></blockquote></li></ol><ul><li>C 规定，sizeof返回<code>size_t</code>类型的值<blockquote><p>这是一个无符号整数类型， 但它不是新类型</p></blockquote></li><li><code>size_t</code>是语言定义的标准类型<blockquote><p>C 有一个typedef机制<br>允许程序员为现有类型创建别名<br>例如:<br><code>typedef double real;</code><br>这样，real就是double的别名</p></blockquote></li><li>现在，可以声明一个real类型的变量:<blockquote><p><code>real deal; // 使用typedef</code><br>编译器查看real时会发现，在typedef声明中real已成为double的别名<br>于是把deal创建为double 类型的变量<br>类似地，C 头文件系统可以使用typedef把<code>size_t</code>作为<code>unsigned int</code>或<code>unsigned long</code>的别名<br>这样，在使用<code>size_t</code>类型时，编译器会根据不同的系统替换标准类型</p></blockquote></li><li>C99 做了进一步调整，新增了<code>%zd</code>转换说明用于<code>printf()</code>显示<code>size_t</code>类型的值<blockquote><p>如果系统不支持<code>%zd</code>，可使用<code>%u</code>或<code>%lu</code>代替<code>%zd</code></p></blockquote></li></ul><hr><p><strong>求模运算符</strong></p><ol start="2"><li>求模运算符(modulus operator): <code>%</code></li></ol><ul><li><p>用于整数运算</p></li><li><p>求模运算符给出其左侧整数除以右侧整数的余数(remainder)</p><blockquote><p>例如，<code>13 % 5</code>(读作”13求模5”)得3，因为13比5的两倍多3，即13除以5的余数是3<br>求模运算符只能用于整数，不能用于浮点数</p></blockquote></li><li><p>求模运算符常用于控制程序流</p><blockquote><p>例如，假设此时正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用<br>这种情况可以在程序中对月份求 模3(即，month % 3)，并检查结果是否为0<br>如果为0，便加进额外的费用</p></blockquote></li><li><p>求模运算符作得出的结果就是所谓的取余运算所得出的结果</p></li><li><p>负数也可以进行求模运算，于C99开始支持了趋零截断</p></li></ul><hr><p><strong>递增运算符</strong></p><ul><li><p>递增运算符(increment operator)-即为’++’</p></li><li><p>用于执行简单的任务，将其运算对象递增1</p><blockquote><p>该运算符以两种方式出现<br>第1种方式，++出现在其作用的变量前面， 这是前缀模式<br>第2种方式，++出现在其作用的变量后面，这是后缀模式<br>两种模式的区别在于递增行为发生的时间不同</p></blockquote></li></ul><hr><p><strong>while循环的执行逻辑</strong></p><ul><li>根据所规定条件，对条件进行循环执行</li><li>例如规定了一个条件为<code>shoe &lt; 18</code>，并且每执行一次就进行一次递加(++)的表达式<blockquote><p>执行的逻辑是shoe的值递增1，然后和18进行比较，如果递增后的值小于18，则再次执行所规定的循环条件(即为所在花括号内的所有语句)<br>然后，shoe的值再递增1，以此重复刚才的不做，知道shoe的值不小于18为止</p></blockquote></li></ul><p><strong>图解示意:</strong></p><ul><li>执行一次循环:</li></ul><img src="/images/数据类型-4//images/while循环-1.png" width="30%" height="30%"><hr><p><strong>关于前缀递增和后缀递增</strong></p><ul><li><p>这里举一个例子:</p><blockquote><p><code>q = 2*++a;</code>，此语句为前缀形式递增，首先，a递增1，然后，2乘以a，并将结果赋给q<br><code>q =2*a++;</code>，此语句为后缀形式递增，首先，2乘以a，并将结果赋给q，然后，a递增1</p></blockquote></li><li><p>单独使用递增运算符时(如，ego++;)，使用哪种形式都没关系</p><blockquote><p>但是，当运算符和运算对象是更复杂表达式的一部分时(如上面的示例)<br>使用前缀或后缀的效果不同</p></blockquote></li></ul><hr><p><strong>递减运算符</strong></p><ul><li><p>每种形式的递增运算符都有一个递减运算符(decrement operator)与之对应</p></li><li><p>用–代替++即可:</p><blockquote><p><code>--count; // 前缀形式的递减运算符</code><br><code>count--; // 后缀形式的递减运算符</code></p></blockquote></li><li><p><code>&gt;</code>运算符表示”大于”，<code>&lt;</code>运算符表示”小于”，它们都是关系运算符(relational operator)</p></li></ul><hr><p><strong>递增运算符的优先级问题</strong></p><ul><li>递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高<blockquote><p>因此，<code>x*y++</code>表示的是<code>(x)*(y++)</code>，而不是<code>(x+y)++</code><br>不过后者无效，因为递增和递减运算符只能影响一个变量(或者更普遍地说，只能影响一个可修改的左值)<br>而组合<code>x*y</code>本身不是可修改的左值</p></blockquote></li></ul><hr><p><strong>不要自作聪明</strong></p><ul><li>如果一次用太多递增运算符，自己都会糊涂-CN-C Primer Plus-第5.3.6章节</li></ul><hr><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>术语: 表达式(expression)和语句(statement)</li><li>C 的基本程序步骤由语句组成，而大多数语句都由表达式构成</li></ul><p><strong>表达式:</strong></p><ul><li><p>表达式(expression)由运算符和运算对象组成(运算对象是运算符操作的对象)</p><blockquote><p>最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式</p></blockquote></li><li><p>运算对象可以是常量，变量或二者的组合</p><blockquote><p>一些表达式由子表达式(subexpression)组成(子表达式即较小的表达式)</p></blockquote></li><li><p>每个表达式都有一个值</p><blockquote><p>C 表达式的一个最重要的特性是，每个表达式都有一个值<br>要获得这个值，必须根据运算符优先级规定的顺序来执行操作<br>关于表达式的值的具体描述这里不做赘述，因为它是一个范围极大的纯粹性概念<br>计算机中表达式的概念与数学中的表达式相同，值即为表达式的结果</p></blockquote></li></ul><hr><p><strong>语句</strong></p><ul><li><p>语句(statement)是C程序的基本构建块</p><blockquote><p>一条语句相当于一条完整的计算机指令<br>在C中，大部分语句都以分号<code>&#39;;&#39;</code>结尾</p></blockquote></li><li><p>声明创建了名称和类型，并为其分配内存位置</p><blockquote><p>注意，声明不是表达式语句<br>也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值:<br><code>int port /* 不是表达式，没有值 */</code></p></blockquote></li><li><p>赋值表达式语句在程序中很常用: 它为变量分配一个值</p><blockquote><p>赋值表达式语句的结构是: 一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾<br>注意，在while循环中有一个赋值表达式语句<br>赋值表达式 语句是表达式语句的一个示例</p></blockquote></li><li><p>函数表达式语句会引起函数调用</p><blockquote><p>在该例中，调用printf()函数打印结果<br>while语句有3个不同的部分: 首先是关键字while，然后圆括号中是待测试的条件，最后如果测试条件为真，则执行while循环体中的语句<br>多条语句需要用花括号括起来</p></blockquote></li><li><p>图片-简单的while循环结构:</p></li></ul><img src="/images/数据类型-4/while循环-2.png" width="30%" height="30%"><ul><li>这种语句是复合语句<blockquote><p>该例的while循环中只有一条语句<br>可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句<br>while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂</p></blockquote></li></ul><hr><p><strong>关于副作用与序列点:</strong></p><ul><li>类似于while之类的迭代循环语句通常还会有副作用(side effect)和序列点(sequence point)等概念，这里不做过多赘述<blockquote><p>所谓的副作用，就是对于变量的赋值结果(此间的赋值结果由右值的表达式决定)<br>或称其为经由人工定义所得出的等式结果<br>所谓的序列点，就是程序执行的点，再该点上，所有的副作用都在进入下一步之前发生<br>C 中的语句用分号<code>&#39;;&#39;</code>来标记若干个序列点<br>其寓意就是在一个语句中，赋值运算符，递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成<br>还有一点就是，任何一个完整表达式的结束也是一个序列点</p></blockquote></li></ul><p><strong>关于完型表达式:</strong></p><ul><li>完整表达式(full expression)<blockquote><p>就是指这个表 达式不是另一个更大表达式的子表达式<br>例如，表达式语句中的表达式和while循环中的作为测试条件的表达式<br>都是完整表达式<br>序列点有助于分析后缀递增何时发生<br>千万要避免写出带有模棱两可逻辑的语句</p></blockquote></li></ul><p><strong>关于复合语句(块)</strong></p><ul><li><p>复合语句(compound statement)是用花括号括起来的一条或多条语句</p><blockquote><p>或称之为复合语句(或块)由花括号括起来的一条或多条语句组成<br>复合语句也称为块(block)<br>任何的程序都可以使用块以让while语句包含多条语句<br>在声明与描述复合语句的构成时，需要注意书写风格，其中最重要的是对于代码缩进的掌控</p></blockquote></li><li><p>图片-带有符合语句的while循环</p></li></ul><img src="/images/数据类型-4/while循环-3.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>一般函数的形式: void xxx(void)<br>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参<br>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)<br>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p><p>关于实参和形参的其它说明:</p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p>关于函数的调用:</p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-1-1"><a href="#补充内容-1-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p>一般函数的形式: void xxx(void)</p><blockquote><p>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p></blockquote></li><li><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参</p><blockquote><p>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p></blockquote></li><li><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)</p><blockquote><p>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p></blockquote></li></ul><p><strong>关于实参和形参的其它说明:</strong></p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p><strong>关于函数的调用:</strong></p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-2"><a href="#补充内容-2" class="headerlink" title="补充内容-2"></a>补充内容-2</h3><ul><li>C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符<blockquote><p>一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值<br>只需要一个 运算对象的运算符(如负号和sizeof)称为一元运算符，需要两个运算对象的运算符(如加法运算符和乘法运算符)称为二元运算符</p></blockquote></li><li>表达式由运算符和运算对象组成<blockquote><p>在C语言中，每个表达式都有一个 值，包括赋值表达式和比较表达式<br>运算符优先级规则决定了表达式中各项 的求值顺序<br>当两个运算符共享一个运算对象时，先进行优先级高的运算<br>如果运算符的优先级相等，由结合律(从左往右或从右往左)决定求值顺序</p></blockquote></li><li>大部分语句都以分号结尾<blockquote><p>最常用的语句是表达式语句</p></blockquote></li><li>用花括号括起 来的一条或多条语句构成了复合语句(或称为块)</li><li>while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句</li><li>在C语言中，许多类型转换都是自动进行的<blockquote><p>当char和short类型出现在 表达式里或作为函数的参数(函数原型除外)时，都会被升级为int类型<br>float类型在函数参数中时，会被升级为double类型<br>在K&amp;R C(不是ANSI C)下，表达式中的float也会被升级为double类型<br>当把一种类型的值赋给 另一种类型的变量时，值将被转换成与变量的类型相同<br>当把较大类型转换 成较小类型时(如，long转换成short，或 double 转换成 float)，可能会丢失数据<br>根据之前介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型</p></blockquote></li><li>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数<blockquote><p>然后，在函数调用中传入的值会被赋给这个变量<br>这样，在函数中 就可以使用该值了</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-运算符与表达式-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
</feed>
