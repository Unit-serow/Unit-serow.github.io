<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-17T10:46:54.853Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随笔-2020-03-16</title>
    <link href="https://unit-serow.github.io/2020/03/17/%E9%9A%8F%E7%AC%94-2020-03-16/"/>
    <id>https://unit-serow.github.io/2020/03/17/%E9%9A%8F%E7%AC%94-2020-03-16/</id>
    <published>2020-03-17T10:45:31.000Z</published>
    <updated>2020-03-17T10:46:54.853Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 18:47:00 GMT+0800 (中国标准时间) --><p>细数我已经挖的坑</p><p>C/C++<br>LSP Linux系统开发<br>数据库开发<br>虚拟化开发<br>密码学<br>纯粹数学<br>GNU 辅助开发<br>操作系统设计与开发<br>嵌入式开发<br>底层硬件及其接口设计</p><p>C/C+++<br>GNU 辅助开发<br>纯粹数学与应用数学<br>硬件设计<br>嵌入式<br>接口设计<br>操作系统开发<br>虚拟化<br>密码学<br>数据库</p><hr><p>能用远端方式交流的就不要用口头或正面交流</p><hr><p>窥探到一秒后</p><p>控制一秒后</p><p>或将其称之为控制一秒</p><p>后一秒</p><p>永远都是后一秒</p><p>删除后一秒</p><p>管理后一秒</p><p>控制后一秒</p><hr><p>或称之在一秒内</p><p>后一秒的一秒内</p><p>完全放缓后一秒</p><hr><p>放缓所处空间与宇宙的时间单位</p><p>放缓无</p><p>放缓源于无，或称由无所起源的时间单位，即线性单位</p><hr><p>范围将会是所处于任何向量位置/空间向量的任何概念单位</p><hr><p>包括前一秒，即为现在，与后一秒</p><hr><p>一秒太长了…</p><hr><p>很难回到已经发生的前一秒</p><p>但是将会有机会窥探到下一秒</p><p>仅仅是窥探</p><p>就已经拥有了无</p><p>纯粹的现实</p><p>现实中的纯粹</p><p>或称接近于现实的纯粹</p><p>或称纯粹的接近于现实</p><hr><p>物极必反</p><hr><p>追求无</p><p>追求从无到有</p><p>追求纯粹</p><p>从无开始，利用智慧</p><p>将精神带入现实</p><p>增加的不是我</p><p>是世界</p><p>是对立且包容的</p><p>只是窥探</p><hr><p>如果下一秒就死了呢</p><hr><p>不要与任何人有肉体上的接触，无论同性异性</p><p>这不是为了纯粹，也不是逃避本能</p><hr><p>可能是为了接近于纯粹吧</p><p>就如同你那毫无目的与理由的自残</p><hr><p>不要再增加现实中感情的羁绊与任何联系了</p><p>包括了信任与寄托</p><p>别让任何人走进你的世界</p><p>既是为他/她好，也是为了保护你自己</p><p>不要让任何人踏进半步，谢谢了</p><hr><p>这件事由你们两个去控制</p><hr><p>嗯……</p><p>我会极力去避免一切的发生…</p><p>能解决的我都会自己去解决…</p><p>必须……</p><p>必须保护好你……</p><hr><p>可能不会有任何知道了……</p><p>别去想象一些有的没的了</p><p>从现在开始，一切都没了…</p><hr><p>别让别人接近你，别去祸害别人</p><p>纯粹性之下不要与任何人接触</p><p>智慧是来自于空的，空是来自于无的</p><p>智慧是纯粹的</p><p>多一个人就多一分烦恼与痛苦</p><p>保证最基本的生存需求</p><p>源于无，且归于无</p><hr><p>C Primer Plus 截止至第十章</p><p>数据类型-1~数据类型-10</p><p>C 初始/概述~C 数组/指针</p><p>七天内完成</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 17 2020 18:47:00 GMT+0800 (中国标准时间) --&gt;&lt;p&gt;细数我已经挖的坑&lt;/p&gt;&lt;p&gt;C/C++&lt;br&gt;LSP Linux系统开发&lt;br&gt;数据库开发&lt;br&gt;虚拟化开发&lt;br&gt;密码学&lt;br&gt;纯粹数学&lt;br&gt;G
      
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-8</title>
    <link href="https://unit-serow.github.io/2020/03/17/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8/"/>
    <id>https://unit-serow.github.io/2020/03/17/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8/</id>
    <published>2020-03-17T03:41:51.000Z</published>
    <updated>2020-03-17T03:43:04.587Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 11:43:10 GMT+0800 (中国标准时间) --><center><strong>数据类型-I/O-1</strong></center><a id="more"></a><h3 id="数据类型-8"><a href="#数据类型-8" class="headerlink" title="数据类型-8"></a>数据类型-8</h3><ul><li>C I/O 原理解析-1</li></ul><hr><h3 id="字符输入-输出与输入验证"><a href="#字符输入-输出与输入验证" class="headerlink" title="字符输入/输出与输入验证"></a>字符输入/输出与输入验证</h3><hr><p><strong>相关内容:</strong></p><ul><li>输入，输出以及缓冲输入和无缓冲输入的区别</li><li>通过键盘模拟文件结尾条件</li><li>使用重定向将程序与文件相连接</li><li>创建更完善的用户界面</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>输入(input)&amp;输出(output)</li><li>常见的输入和输出设备<blockquote><p>包括如键盘，U盘，扫描仪和激光打印机等</p></blockquote></li><li>如何处理输入数据和输出数据</li><li>执行输入和输出任务的函数<blockquote><p>即用于输入和输出的函数(简称I/O函数)</p></blockquote></li><li>I/O函数(如printf()，scanf()，getchar()，putchar()等)<blockquote><p>其负责将信息传送到程序中<br>I/O函数的基本概念解析</p></blockquote></li><li>关于设计与用户交互的界面</li></ul><hr><p><strong>关于C 的 I/O 函数</strong></p><ul><li>最初，输入/输出函数不是C定义的一部分<blockquote><p>C把开发这些函数的任务留给编译器的实现者来完成<br>在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型<br>ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些极为常用的<br>由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性<br>因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数<br>其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面<br>这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序<br>这里所提及的 I/O函数 是所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统<br>处理文件输入/输出 的程序也可以使用这些函数<br>许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配，此时则需要输入验证相关的问题和解决方案</p></blockquote></li></ul><hr><h3 id="单字符I-O"><a href="#单字符I-O" class="headerlink" title="单字符I/O"></a>单字符I/O</h3><ul><li><p>即为getchar()和putchar()</p><blockquote><p>getchar()和putchar()每次只处理一个字符<br>虽然效率对于人为编写与阅读的不佳，但这种方法很适合计算机<br>并且这是绝大多数文本(即，普通文字)处理程序所用的核心方法<br>这里会提到有关这些函数的工作方式</p></blockquote></li><li><p>自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联</p><blockquote><p>这就是为什么程序中要包含这个头文件的原因<br>实际上getchar()和putchar()都不是真正的函数，它们被定义为供预处理器使用的宏</p></blockquote></li><li><p>如果在程序中同时使用了getchar()和putchar()函数</p><blockquote><p>在运行程序后，getchar()函数会将用户以键盘输入的值传递至程序中的putchar()函数<br>然后putchar()函数会将值直接显示/输出在/至屏幕上<br>其涉及概念即为关于C的键盘输入处理，缓冲和标准输入文件</p></blockquote></li></ul><hr><h3 id="C-缓冲区"><a href="#C-缓冲区" class="headerlink" title="C 缓冲区"></a>C 缓冲区</h3><ul><li><p>在老式操作系统中运行getchar()函数的输入循环并以putchar()进行输出</p><blockquote><p>其系统在回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入<br>即正在等待的程序可立即使用输入的字符<br>而现在的大部分系统在用户按下Enter键之前不会重复打印刚输入的字符<br>这种输入形式属于缓冲输入</p></blockquote></li><li><p>此时用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区</p><blockquote><p>按下Enter键后，程序才可使用用户输入的字符</p></blockquote></li><li><p>以下图片比较了这两种输入:</p></li><li><p>缓冲输入和无缓冲输入:</p></li></ul><img src="/images/数据类型-8/缓冲输入和无缓冲输入-1.png" width="40%" height="40%"><hr><p><strong>关于缓冲区的存在意义:</strong></p><ul><li><p>首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间</p><blockquote><p>其次，如果用户打错字符，可以直接通过键盘修正错误<br>即当最后按下Enter键时，传输的是正确的输入</p></blockquote></li><li><p>虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入</p><blockquote><p>例如在游戏中，玩家通常希望按下一个键就执行相应的指令<br>因此，缓冲输入和无缓冲输入都有用武之地</p></blockquote></li><li><p>缓冲分为两类: 完全缓冲I/O和行缓冲I/O</p></li><li><p>完全缓冲 I/O</p><blockquote><p>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)<br>其通常出现在文件输入中<br>缓冲区的大小取决于系统，常见的大小是512字节和4096字节</p></blockquote></li><li><p>行缓冲 I/O</p><blockquote><p>行缓冲I/O指的是在出现换行符时刷新缓冲区<br>键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区</p></blockquote></li></ul><p><strong>关于使用缓冲输入还是无缓冲输入</strong></p><ul><li>ANSI C和后续的C标准都规定输入是缓冲的<blockquote><p>不过最初K&amp;R把这个决定权交给了编译器的编写者<br>ANSI C决定把缓冲输入作为标准的原因是: 一些计算机不允许无缓冲输入<br>如果当前使用的计算机允许无缓冲输入，那么当前所用的C编译器很可能会提供一个无缓冲输入的选项<br>例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数<br>其原型都在conio.h头文件中<br>这些函数包 括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数(回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击 键后对应的字符不显示)<br>UNIX系统使用另一种不同的方式控制缓冲<br>在UNIX系统中，可以使用ioctl()函数(该函数属于UNIX库，但是不属于C标准)指定待输入的类型，然后用getchar()执行相应的操作<br>在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用<br>总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统<br>这里假设所有的输入都是缓冲输入，即不会涉及无缓冲输入</p></blockquote></li></ul><hr><p><strong>有关结束键盘输入</strong></p><ul><li>在某些程序中，只要输入的字符中不含#，那么程序在读到#时才会结束<blockquote><p>同时#也是一个普通的字符，有时在程序中不免会用到<br>所以应该用一个文本中用不到的字符来标记输入完成<br>此时就实现了让这样的字符不会无意间出现在输入中，即在不希望结束程序的时候终止程序时</p></blockquote></li></ul><hr><h3 id="文件-amp-流-amp-键盘-输入"><a href="#文件-amp-流-amp-键盘-输入" class="headerlink" title="文件&amp;流&amp;键盘-输入"></a>文件&amp;流&amp;键盘-输入</h3><p><strong>文件输入:</strong></p><ul><li><p>文件(file)是存储器中储存信息的区域</p><blockquote><p>通常，文件都保存在某种永久存储器中(如，硬盘，U盘或DVD等)<br>毫无疑问，文件对于计算机系统 相当重要<br>例如编写的C程序就保存在文件中，同时用来编译C程序的程序也保存在文件中<br>后者说明，某些程序需要访问指定的文件<br>当编译储存在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容<br>当编译器处理完后，会关闭该文件<br>其他程序，例如文字处理器，不仅要打开，读取和关闭文件，还要把数据写入文件</p></blockquote></li><li><p>C 是一门强大且灵活的语言，有许多用于打开，读取，写入和关闭文件的库函数</p><blockquote><p>从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件<br>这些直接调用操作系统的函数被称为底层 I/O (low-level I/O)<br>由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做<br>然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件<br>这涉及创建用于处理文件的标准模型和一套标准I/O函数<br>在这一层面上，具体的C实现负责处理不同系统的差 异，以便用户使用统一的界面</p></blockquote></li></ul><p><strong>有关 I/O 的差异问题:</strong></p><ul><li><p>例如，不同的系统储存文件的方式不同</p><blockquote><p>有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处<br>而有些系统在文件中创建一份文件描述</p></blockquote></li><li><p>在处理文件方面</p><blockquote><p>有些系统使用单个换行符标记行末尾<br>而其他系统可能使用回车符和换行符的组合来表示行末尾</p></blockquote></li><li><p>文件大小方面</p><blockquote><p>有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量</p></blockquote></li><li><p>如果使用标准I/O包，就不用考虑这些差异</p><blockquote><p>此时可以使用<code>if(ch == &#39;\n&#39;)</code>来检查换行符<br>即使用系统实际用的是回车符和换行符的组合来标记行末尾<br>I/O函数会在两种表达式法之间相互转换</p></blockquote></li><li><p>从概念上看，C程序处理的是流而不是直接处理文件</p><blockquote><p>流(stream)是一个实际输入或输出映射的理想化数据流<br>这意味着不同属性和不同种类的输入，由属性更统一的流来表示<br>于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成</p></blockquote></li><li><p>这里着重理解 C 把输入和输出设备视为存储设备上的普通文件</p><blockquote><p>尤其是把键盘和显示设备视为每个C程序自动打开的文件<br>有关对于文件的深入讨论这里不做多余赘述</p></blockquote></li><li><p>stdin流表示键盘输入，stdout流表示屏幕输出</p><blockquote><p>getchar()，putchar()，printf()和scanf()函数都是标准I/O包的成员，负责处理这两个流<br>以上的内容则说明了可以用处理文件的方式来处理键盘输入<br>例如， 程序读文件时要能检测文件的末尾才知道应在何处停止<br>因此，C 的输入函数内置了文件结尾检测器<br>既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入<br>下面会从文件开始讨论如何结束文件</p></blockquote></li></ul><hr><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><ul><li><p>计算机操作系统要以某种方式判断文件的开始和结束</p><blockquote><p>检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾<br>CP/M，IBMDOS和MS-DOS的文本文件曾经用过这种方法<br>如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾<br>这曾经是操作系统使用的唯一标记， 不过现在有一些其他的选择，例如记录文件的大小<br>所以现代的文本文件不 一定有嵌入的Ctrl+Z<br>但是如果有，该操作系统会将其视为一个文件结尾标记</p></blockquote></li><li><p>以下图片演示了这种方法:</p></li><li><p>带文件结尾标记的文件:</p></li></ul><img src="/images/数据类型-8/带文件结尾标记的文件-1.png" width="40%" height="40%"><hr><ul><li><p>操作系统使用的另一种方法是储存文件大小的信息</p><blockquote><p>如果文件有3000字节，程序在读到3000字节时便达到文件的末尾<br>MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z<br>新版的DOS也使用这种方法处理文本文件<br>UNIX使用这种方法处理所有的文件<br>无论操作系统实际使用何种方法检测文件结尾<br>在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值<br>即EOF(end of file的缩写)<br>scanf()函数检测到文件结尾时也返回EOF<br>通常， EOF定义在stdio.h文件中:<br><code>#define EOF (-1)</code></p></blockquote></li><li><p>为什么是-1?</p><blockquote><p>因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集<br>但是，如果系统能识别扩展字符集，该函数的返回值可能在 0～255之间<br>无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 文件结尾<br>某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同<br>如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题<br>这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号</p></blockquote></li></ul><p><strong>关于如何在程序中使用EOF</strong></p><ul><li><p>把getchar()的返回值和EOF作比较</p><blockquote><p>如果两值不同，就说明没有到达文件结尾<br>也就是说，可以使用下面这样的表达式:<br><code>while ((ch = getchar()) != EOF)</code><br>如果正在读取的是键盘输入不是文件的情况:<br>绝大部分系统(不是全部)都有办法通过键盘模拟文件结尾条件</p></blockquote></li><li><p>这里以该程序举例(echo_eof.c):</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在使用EOF时需要注意下面几点:</li></ul><ol><li>不用定义EOF，因为stdio.h中已经定义过了</li><li>不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值</li><li>变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数<blockquote><p>但是EOF的值是-1<br>还好，getchar()函数实际返回值的类型是 int，所以它可以读取EOF字符<br>如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式</p></blockquote></li><li>由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据<blockquote><p>ch是整数不会影响putchar()，该函数仍然会打印等价的字符<br>使用该程序进行键盘输入，要设法输入EOF字符<br>不能只输入字符 EOF，也不能只输入-1(输入-1会传送两个字符: 一个连字符和一个数字 1)</p></blockquote></li><li>正确的方法是，必须找出当前系统的要求<blockquote><p>例如，在大多数UNIX和 Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号<br>许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号<br>一些系统把任意位置 的Ctrl+Z解释成文件结尾信号</p></blockquote></li></ol><ul><li><p>下面是在UNIX系统下运行echo_eof.c程序的缓冲示例:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Lord　<span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">Lord　</span><span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">[Ctrl+D]</span></span><br></pre></td></tr></table></figure></li><li><p>每次按下Enter键，系统便会处理缓冲区中储存的字符</p><blockquote><p>并在下一行打印该输入行的副本<br>这个过程一直持续到以UNIX风格模拟文件结尾(按下Ctrl+D)<br>在PC中，要按下Ctrl+Z</p></blockquote></li><li><p>既然<code>echo_eof.c</code>程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么</p><blockquote><p>假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止<br>或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据<br>用<code>echo_eof.c</code>来储存在文件中输入的内容<br>假设同时使用这两种方法: 把输入从一个文件定向到<code>echo_eof.c</code>中，并把输出发送至另一个文件<br>然后便可以使用<code>echo_eof.c</code>来拷贝文件<br>这个小程序有查看文件内容，创建一个新文件，拷贝文件的潜力<br>关键是要控制输入流和输出流</p></blockquote></li><li><p>注意模拟EOF和图形界面</p><blockquote><p>模拟EOF的概念是在使用文本界面的命令行环境中产生的<br>在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号<br>但是在一些实际应用中，却不能很好地转换成图形界面(如Windows和Macintosh)<br>这些用户界面包含更复杂的鼠标移动和按钮点击<br>程序要模拟EOF的行为依赖于编译器和项目类型<br>例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的 设置</p></blockquote></li></ul><hr><p><strong>待补充</strong></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 11:43:10 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-I/O-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>时间-1</title>
    <link href="https://unit-serow.github.io/2020/03/15/%E6%97%B6%E9%97%B4-1/"/>
    <id>https://unit-serow.github.io/2020/03/15/%E6%97%B6%E9%97%B4-1/</id>
    <published>2020-03-15T15:46:16.000Z</published>
    <updated>2020-03-15T15:53:03.583Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b9b3ec7d0bfa68c8c6c37a884514683f08f7f0687c0c3225788d0ed95c58a9ad">0267ec72f19b8c198697a4f72870a3a8584f376137a9d1d86e1a9cfa88aadb7d7103cc4d6088216be72b5f0194670dc24843dea27e475e25a33b67d7a3df15254a6cb867e9b6e7292faa05ccb4e476cdca07cf9e880ad981d0646b9814f74dc8b8164c8d28dcbf8e5cc01eaa9a89302c3e186efbb7cb3f39db2ec34862b5a036805cc658e005fa1686506dcfade0d48c3e88117a5cf5dcc51fe635abf38179b29590e4c41c172799a527f0cab75bd06aeff1720634a7b8f64d66dfd990078653d58c18964ffaf0d349030c044aa846463c4b9da81afd525491237e6a8ec0d3eb9d1844545256b38e5ea42308667e9388aab70277421c3324b2e1eb064d1229c101000e3791451d8ba0c0bf9e879002e5d0830ece1cec030b23f9e3f9fef94d9a0ffafdf6d419e579c6034c946eb8000c186a3380d711cddd55882967eb0deb0bbbc357ef62ae9e14d40387378e51f2b211f243d91ae5ed89d8c9ef399634f3e07dbe816680036e82a50a4509c92d70190a2c8a75c179145b3ea478bbb4928886f0c516bfd67fd022d8155b7a98baebce07d11a3c2a8f2e509386ed23954b10d1fdee7ad2521d8ee5e65470d509ae680c8d75f6c7fa03a2fdb94f101b7c181e8c02a36429e982188729c8b8b0ec01728b87a2056122a7179bb3951c15ab88186a3340ca7784f4d841ef7072707a96c10a2eadb8106dd8fbab5381735b1ff0d18b828335bc9f367be2baa1d90d56954913cbd607da3ac6698c1479b5b6ae8bc9e09b00b8c96bb1b18e87eca97d7e65bb982341ee853ed6307656b41f8e31dacfe27f595283f9b084c3e22df8cba7e7c75ade1068b5fe8473f9000e7c506d0d2f120d67cb5b9cb36cc34e21d1fb8a24dc3629df0e5a0db7117ca7d1a41f1b7408bda494bc6670c4f5a20184c83811e0b8f17320abce1bdeb5fe9c4493ddb206761d19b6d653dfc7a5c33561844e00abd0e497016db2ca4dea8634af7bcc29f6db65bab72dfa8331810ed326080e1d37f7b8f5f52033964693c34f441fabe83f2c8da4f96f060d63d17840b0f4bc161804d34e0d66b6779ebb8b1ee39c354bc02da456c6eb93c66ca9c34e05bc6e856308ed3f4866c7512246c763bfa8580735dedda987959badef99230530e79d2cd0e7e785375e3307ce93d048544daacd97ec261c99dfed65e4252eacabf714e9d19cb5e838febcb1e60062211def387b2ccaa1a141edc392d25d3dbe16855c37ef0091d08da2eeffe1c31ac2a6836eee535dc1944062865416c973536a15a68c26adefc7d2444224810e745a85549439b98cabe2557a39fef08b8a30a983d73e9ad7686f0fa49320ab014528cbb7561f461396166a309af96c5e2eb040ccd962d6b57c105781cb7a2139843ab97fb07e7fa4ff56622e3496dfcd39479fab9a89cb2e777435b628cf84b62663bbf4b6404d60d18b12d87032537d52dea10d38063fb62a1efb576e096def679c9b9200c30f5c92bc92b40018d01dfe6c4df283af6a968bd4c31780ea82752e65db7ce5ea8d4f9fdfbc30ff86a73766aaa4fcd4f864ca5f19ba741b5b527c85ce26d3dd8ab8148994aef74e10d5bffb5a3b984cab07563329b4a89f43e1f318480fb1ef70d44800c73a45ecdfdb0be33178ae1370fef28a96b83e42dc9f513c59f708298f7a0e0e734b473350f5b56fe476d6813a1f828e991db634b73192d06272c0624775678ba6693e7b42cc4bdc67e59732ad465ef374077036d83b57880557ad4c21fbbf909787311132d4d2aaf447e449ac4de4ccd50715c36ceb7508805cf6f7e3a0fb47dfbbd729f276ee551ef9625692533d968e8c51ce9818e53130f093908d2f03013747b16cb0280ce3b187ae643e508ea766a7f402b8c63338eb1345af75db851551e3f47d6f123a694cc6d6ce718111f7c9ab8f748f1507ff62eef5cd9d17ada1be3792abb5b7e8e13d12b006b66e1031df459352b0ffcc772df91fcfbe7168982661f2a03cefef770de46f8b8d28fda437f4da76c341056402ce8fd8ff5d41ecc51e89dad26a7abc7f816daef382fa0c781be70803041023fe672f274caa7dd18e8ed073dfde7ccc84f3cc13f6e8957375613396c50336fbab249989c53de4f7af20886882b88650349ce7d2d1efba5c20ebc722d2931a0fc28530995c8b0db14c502b7bd074a5150fda832bac9f614591d1a2a69b2a40b05dd58f58a7d15ffb34a6dc50e7e8487739976963703d4c6ee3f6ceeb666ab7b68ba03806e6f57173a7ab125a6a8d72f36438b241be338fdc1c4d115fca9be185faebc839a1caac4ce96ca87fc3c444fae21ff15affde88269ccfd2613944ab4c548e9e390cfc6d8fdf9ef219635694dda6529aa40f1ce38552805b047dcc524007b942e64dec8a3342347467e44bd3b4ca5e4f2d761cc6df8a4a0e0fd9a284caac65d44e0a50fe243c4a43e8870a05e276a26ca692f902a5699ec6b5cadbae65b22da1b87593cdb323982f2330bac448b835b6536d8a72b512b678b45b16f646e3664685114f8fe3b431280c65cc4f5911e1845c1672db59e27d0d093ec87491d542c29cf985442d76025654c12c68cfd4f0a7802fb56ca788b8d65a367fad5db7bdb144c77494b29bce12add9ac45e3d414eee2862c977a7ae9fb60a7bea4db3de231e385b319f6bce2a78f7e316ece94f06c0b710c42818f30406bd24fddaaca9bc4f19e416346c0cf35e83d1278c048bd84d50983d4121053bc6a8901137aa16575e32c54d1033ad21d762c1ca090ca0a78a9a5ee857b57c0abbbd759b456b0666491bcf247e3233d2ff149384ab893e87a03f333c8c8d1286e2ca859c7cdc90df1a3dfac083509ebfeb416b16830687d31d1eaf6afa43c0055f2d2117fb6acc6a1934c44a6b81156b21791fe46b46647a4bf04717238e94768bc3774454a92f2e6e818b5c16b0c84557a2fbd9e5338c2734c72f988ee386635693e00c2107b09e414253466b10a412da77af197180d6151d29428dd3429d61e5ac67308ce30c186f01ef12c0d38e722d91592cc55c267c7bf8565e727cc9ebe90e2cc642c07cec2e0d95133697f75e94535c211cfdfa2aeb7a152bfa9e749bff0a8893436b1663dd28f7baa9069154f9c8f58b394c0874dae104a47f47cc19fb0a36fc9cc30f3dfed333bfea996c3abe11c2523a3f544d6cea5918aeb17e2d820f0eac6f55ba624210dbea307398bc462fe9b1386c8e2a55c7e10d3165547bc880c998e85532dd793002a28a575b230aad0a9811f6322aabe3342e56e6735f5786ee7bf0b9c2bce6e54864ee0857bf10e25aa2dbbfea5a44fdd4c0e39ef90523e2a458d926ed60acba3d65b484ff50cbaaafd29f99f8afd6880c021fba16f5646153bf6e7932c60fb957e87c70f2e47fce081e507b23bdd592087047beff7708a3dd1a5fb966a990ff875763e5cb4200d5886f1baffce41bc9fbec6c25076120edd2d7251284af2170946fc1f46110b25288c0020d310fca20aa05bda4bd6b67af1077a030f647ffe62a11727dbd4884f116725855ac45d6f51bea61a012eb5d87c6d6624a29a858b182c60003f1b204e51a397a8bd8794c74c19b6e99b11b9faea315d572c159f3c80039ab577870d79f926f4715e5ff34c4434b24401f4ac12c118b8d9d940d6caf801051d713f58dc7a95b4646999173a064c1d9b55bf90da94e7546b1efe2b644faa8307daa47d8d4ec1af5c4b5f4c59221aa18f6686e23d350613478073ca7fcc899e29871458adc05e5b1a8e7756f2eeb46c59a2821f7e43b365428aea161b72ed95f743411b3bea758f8c977e499a8abc119291dd7c618f609cf3e9389309466b19ac3b6991399f3782b6fb7487dac9a535cb8beca9e82c28eae2e6d8d57e64d5c2012a67311a02231ab484e440c2d64ce68b8cd044e3eec34a05d293f973e2379c80a7471ee08c4af4571deca75adb1149487abee2d8ff17c10a85286cf8367296061a0b18554a712e54b28497a7dd730c2cf22ec425e2be712f8a90e5f95f2d9a5873f17b3b94bb46d7400eb0f32b74f3ddac86cb5736d3fda40fa80f40f8191265b371727b10b42bc633ee6249c4e94b32750c5ff1b278ef339c28d4858a70e78aac14f10a428bb9c5eefc81580a9c33ccc6880c3908d5141485db0bc8abdd1b0e6992f27d984c65e5c18fcb80bf36af2e3d0f2198df1d37e5898ea4967b2098c9b74165f869a58c445867c411cccf7777c95d6a8065b52b7fa7740a393d4e811d74c9f06abc7cea8dbe15c74358a0f33dcadc78f8f48006ea462ed1b657fc3dee0ed7e6fa35b040ff5f6eeb0315ec4bdd</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-永驻</title>
    <link href="https://unit-serow.github.io/2020/03/15/%E9%9A%8F%E7%AC%94-%E6%B0%B8%E9%A9%BB/"/>
    <id>https://unit-serow.github.io/2020/03/15/%E9%9A%8F%E7%AC%94-%E6%B0%B8%E9%A9%BB/</id>
    <published>2020-03-15T10:01:20.000Z</published>
    <updated>2020-03-15T10:07:09.524Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="84393274d90600ffa07ea4c7dc11d79d50eecd04c19f633bf80e383dcf3dfb58">0267ec72f19b8c198697a4f72870a3a8584f376137a9d1d86e1a9cfa88aadb7d7103cc4d6088216be72b5f0194670dc24843dea27e475e25a33b67d7a3df15250e28e7b9f7f04448b0079421cfbb1da88a9bfa1e4d62c93108e67223ca38effbbbb83b5554de3cbed904b5bf954ee1464c6c67b1b6c67b6144923c2d26052188978135030b55aacc3e58607ed4ba4469fbb08250a35efef1bf944feb2a5017ad9dfed2889e03cf9c91791271ea4d2318b0c7cb26937d1d2855dbe12714706304e6f3f11737bfc62fd888bfe261bec0cf96641a5d5b8047c96b8ab56e20a8c96c0c005635cdfbdb67e0535f87c9969c2a7e36fb08b419c2e15b108ff2a4acb436544278d9a4272fcd9e70d70f19bbf92b7d68dc340c3c46e7d9fe2ce31923de0a4199b1e20340b42564fe7165462b93c455f848a53e748970a35b4cf7f5f2f5a80acf117d44c15606f6719de93bebda93e3d023beb1e174c12f74dbad5ddd245e0af22c611800f864e2048efeea9493a1403c9efeb1e32d9386b54f5d1716a0e613e00a9d95805fa4bc3b2f1416e16ee8b570b5e5c7dcc2fe5c8ca600ca14634a35a7c156c6148632b6acdd66413a61e40dbdfebe72b3debe8dfbfbcd5dd540ed74e82cf4df82b5914303c5b670eddc8dcc3c116e90160248607ceba1242d977bc184712fc5dc743423c7a38036513d97e118b8dd4611f2600e4400acfb7fc3d5e3128b5e1ce780d95af7ae397b6d662a6422f80ea5a3d313c5fbe9ed24e0ba69e3b8447e9ce3ebbfae99104a7f6ddc19d6baea95e1c7383015ba7ddea54d12bdd7ed8c434864a1aab750c4157abac507501e91ff3c42a733c437f53f7e6a40fe184d6d97f320a035c8cc954b7d8b400a636ec06468449977729efcb2b4fb0ec3fe1c6fcde72d6c6fb2e747d9d85743add014a4e5bfcb0bd6599fda789d2ecc82aab6adfe844c43f3ae5c81d48eb52915e1742ef005cac1655b5ca154894ecb66b5fee3e680651794435a926e4a90f8dfa5e8c4e578ebb5a40cce58f3d3a71c073112f0fbeb17e8992246bd0781def3cdf0db86cad721ccbab75a8d6fcaeff129cad14e3dcecb385d578e2e8098958bd31092cc32af2537c49636664c64abf23ca12cce5fb23790eab41d941d77def7773756a38ada02b001dad78fac18f0bb528e99445725bf56b8646742d71fd5bf10b53ab8aa82ee96fd3faccc3d625fc631e90a6d582d7585e3adbb79ff7e3fa766f3c26541051e3034c24b353f6d8b502a1752bf7c3151d540d28fb1962da4d7840d15ffd189c39f3dead7243f4c47983a84e800e3e6ef1a23b5173a8b7e91a3bbbeb281b488caea0cf69babe7e1f9f94a867ac79f360307c590cff151510ab903bdfca65fe4238c4266593fcee4d67f294f098913383cb7d00fcb322e41a2e3e6e2b0b7eebce3fb57ee7c60d6cb64793ed407631b604bf396cfaf712d0dd29a4711b187a440d348ed3fabc1e52a883cc899985c04a23055bf4114bf4b23d31b923b85c3ffc205d7b0e222578ff52a06133c34415d55f54e1939a4e88a62ac27377f73077da6ec738cf37ff112f27dc577d119282c8bb581d9545ce7ff1a6c145876beaffbbd5181c95533e721f0e9185fdffeb29e8fece44c2cbb6536681a9ec7f98fe2e74085e6d7131317b56ceb570d165932bac4718d05c4350f193235f2af358114706d091065809f4fb3c798495b7a985c78707b0da0f45a33830951f4a1d1a92ee29f88266d85ea50a10f685ccd6bef6f4c1802bad091fe34375554926ac8aa5f92248df73d6ec6f7748e56ff6986b7fe39a2ef4a3d7cb62e97b6612847f4fdaef8bfea04c1c383dc160022b7717dd12af75202d782ae7787a09cb40715362bab2b8977d44395b52059b2ddb55a3ae7504a8cfb521fe2784dafaf96fc9aff5985f5f4a0ca1a2497299e15c17612c738336db2bb983158217f2f3d429f0e9a24e8330a736b730d4160fd6a86106578f23bb81bd77a45aed7a4bd7b6640ac7a912455b5b58d41e12b5f0e19c3e7100ae914ec984c90ca3ec2bc858997c3c03b7936dacd009e670e33fa2298dd6968e34015e0cad7eae738ff6071646c631f5943cb1cfd90e4d39991cd22c6ed1328b3749eb3540f5de1c54e1ca42503402a79bba39393579790ad71e5e14514381d2b538b9361a7ab96c84f139b250669ffa4085b1ac29cbeee6432766522dd4801499576ab4f144fd07d93ce0b926d58de51453544252c14a8d270ddccd6c46f78b2a93dc54f887a5e92af9ee6e1e8c2ab2019f6f85027b30d3c2ddb6f902dd37bb8ab7a1ea90db86caecb1f298d4c466d846342b9df8076d4d42edc1108393c3d298849a09558fcfeafc0617b14991157a819ceebe1e4943296f7a31cbbaf541bfd4c379486347b23d325ff46740663f086f52d071333dc3d2b43d2224dfbf6e8bc93ae6d9cf0932c54edba793506611483a19c82c2628ba6afb185250df7347cc54237f57dfa51eaa781b95dc28ff9b594be809188ea65555d5821a33157ab3955515aba9e94b756c64da6e16fd75d0d55e12bc231afd151e8ce25bd941ea5854bd04e650018b9d6b75368fe92c5c7a54e094ca7d677321eb94c9ad11a43f0daca5a5626f4acb1eb6aba9c0e9fc3721f4b93710f25f8ab2220604660bb85292f12b31e3195e213965585040b8984e51f</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Coding-1</title>
    <link href="https://unit-serow.github.io/2020/03/15/coding-1/"/>
    <id>https://unit-serow.github.io/2020/03/15/coding-1/</id>
    <published>2020-03-15T08:43:22.000Z</published>
    <updated>2020-03-15T08:44:56.956Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>ASCII-1</strong></center><a id="more"></a><h3 id="编码-coding-1"><a href="#编码-coding-1" class="headerlink" title="编码(coding)-1"></a>编码(coding)-1</h3><ul><li>ASCII (American Standard Code for Information Interchange)</li><li>美国信息交换标准代码</li><li>美国标准信息交换代码是由美国国家标准学会 (American National Standard Institute/可简称为ANSI)所制定的标准</li><li>是一种标准的单字节字符编码方案，用于基于文本的数据</li><li>后来它被国际标准化组织 (International Organization for Standardization)，可简称为ISO，定为国际标准，称为ISO 646标准</li><li>适用于所有拉丁文字字母</li><li>ASCII标准表可参考下方文献</li><li>其存在的目的是为统一计算机领域的所有编码规则</li></ul><p><strong>编码</strong></p><ul><li>在计算机中，所有的数据在存储和运算时都要使用二进制数表示(因为计算机用高电平和低电平分别表示1和0)</li><li>例如，像a，b，c，d这样的52个字母(包括大写)以及0，1等数字还有一些常用的符号(例如<code>*</code>，<code>#</code>，<code>@</code>等)在计算机中存储时也要使用二进制数来表示</li><li>而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套，即为编码</li></ul><hr><ul><li>ASCII码使用指定的7位或8位的二进制组合来表示128或256种可能的字符</li><li>标准ASCII码也叫基础ASCII码，使用7位二进制数(剩下的1位二进制为0)来表示所有的大写和小写字母，数字0到9，标点符号，以及在美式英语中使用的特殊控制字符</li><li>按照指定的格式与规则给输入输出的信息进行指定的编码，本质就是将计算机内一切的数据和信息转换为二进制代码的不同组合，以便给予机器并让机器执行相应的指令</li></ul><hr><p><strong>ASCII码的基本规律:</strong></p><ul><li><p>0～31及127(共33个)是控制字符或通信专用字符(其余为可显示字符)，如控制符: LF(换行),CR(回车),FF(换页),DEL(删除),BS(退格),BEL(响铃)等</p><blockquote><p>通信专用字符: SOH(文头),EOT(文尾),ACK(确认)等<br>ASCII值为8,9,10和13分别转换为退格，制表，换行和回车字符<br>它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响</p></blockquote></li><li><p>32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字</p></li><li><p>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号，运算符号等</p></li><li><p>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位</p><blockquote><p>所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种<br>奇校验规定: 正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1<br>偶校验规定: 正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1</p></blockquote></li><li><p>后128个称为扩展ASCII码</p><blockquote><p>许多基于x86的系统都支持使用扩展(或”高”)ASCII<br>扩展ASCII码允许将每个字符的第8位用于确定附加的128个特殊符号字符，外来语字母和图形符号</p></blockquote></li></ul><hr><p><strong>涉及概念:</strong></p><ul><li>点阵</li><li>字库</li><li>点阵字库/字模(数据)</li><li>格式问题(UCS-2等)</li><li>码点</li><li>编码</li><li>Little endian/Big endian</li></ul><hr><p><strong>其它的编码系统</strong></p><ul><li>非ASCII编码</li><li>Unicode</li><li>UTF-8</li><li>中文编码</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>中文维基</strong></p><ul><li>ASCII<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/ASCII</code></p></blockquote></li><li>分类:字符集<a href="https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86</code></p></blockquote></li><li>分类: 编码<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>字符编码<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>晶体结构<a href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84</code></p></blockquote></li></ul><p><strong>百度百科</strong></p><blockquote><p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/ASCII/309296?fr=aladdin</code><br><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin</code></p></blockquote><p><strong>CSDN</strong></p><blockquote><p><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/exbob/article/details/6532772?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code><br><a href="https://blog.csdn.net/yuanwofei/article/details/12846331" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/yuanwofei/article/details/12846331</code><br><a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/Deft_MKJing/article/details/79460485</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;ASCII-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Coding" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Coding/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>学习</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E5%AD%A6%E4%B9%A0/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-14T14:41:41.000Z</published>
    <updated>2020-03-14T14:46:48.594Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>主观-学习</strong></center><a id="more"></a><h3 id="开放性随笔"><a href="#开放性随笔" class="headerlink" title="开放性随笔"></a>开放性随笔</h3><ul><li>所谓的智商来源于学识</li><li>而智慧来源于环境，世界，精力/经验其次是学识</li><li>然而所谓的智商，只不过是给予懒惰者的万千个借口之一而已</li><li>只是强者给予弱者的某一个心里安慰或者是弱者自己寻求的理由而已</li><li>学习不仅要勤奋，还要明志，指向明确，方向稳定</li><li>明确自己的定位，明确自己所能接受的范围，明确自己当前的能力限制</li><li>在步步为营的前提下，去进行逻辑性的累积</li><li>利用绝对的理智去找对方向与指明道路，珍惜时间，时刻行动</li></ul><hr><ul><li>学习的本质只不过就是机械化的练习，记忆，理解与实践</li><li>伴随机械化记忆而形成的是对所学概念或知识的通透性理解</li><li>而学习和练习即为行动</li></ul><hr><ul><li>哲学不是存在于现实的，或称不是存在于现代的<blockquote><p>或称存在于现实间的哲学，对于现代人类最基本的生存，生命与现实存在的保证而言(生存的本能)，没有任何意义和相关性</p></blockquote></li><li>纯粹的哲学家可能早就被饿死了</li><li>任何学识和智慧都要提现和实现在现实层面之上</li><li>最基本的条件是需要保证自己于现实间的实际存在</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;主观-学习&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-14</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E9%9A%8F%E7%AC%94-2020-03-14/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E9%9A%8F%E7%AC%94-2020-03-14/</id>
    <published>2020-03-14T08:01:16.000Z</published>
    <updated>2020-03-16T12:20:59.824Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="37d620a7d4722c4ac6f87a951b79e35e3faee0217ad150821edd75b4dbe2c8c3">0267ec72f19b8c198697a4f72870a3a8584f376137a9d1d86e1a9cfa88aadb7d7103cc4d6088216be72b5f0194670dc24843dea27e475e25a33b67d7a3df1525fec9540df53f97510101ca3add570fd5e219de63b1883ed61cf8f25c7cb780f4ccada74a6819915b815d82b38559949600ac5f186af2f64d26150f0cb2fbf60ca9353826540767bd23bc1d1486ca7be30921440661522e9b2f6e8100b84b287f3d40ed9d8a739eca6d1aa47045992caa658e186cf9668aa4344ac1a4a7152a732fc44f7acf9f203f42826fe91f784ca2fc602adb8f50da066e06451be547f94237336e9c053d18777ac53ff2c0140ec5cf7ef6913cdad4bf441015dfb476aef6bdd1534e0b097398e610c4237f544e562b2774fb9c02f0a1462620d511045a802c79a6e49f021eef16cc8f67f022fa89c024e1696acf65b37f260bb65f7fe254dd22a3cb04db7e1a4831275a73baab3607cbdf170844dbb08d0ddcb09cd373fbb42abb5fe354d5692abe36e0ac3200276ddc1768cdb1a68184e26afc0cfcd9f2fb74c2275df655cfd2d06fd899047c2b364942d01875f096ac0fcdb45646d64e8c14d8a9b73a4f4edf1d3fe6c85158df54979f780a032c25337c5f75e65bae18923abdd5960e44f5c88e5d5a8b0feb4e4c00828f269bef3d2fad6bd1b67b714f31e27d3a87025592daafbd06aa9375fa8df3be26cf17dc45858c61165c86543247aab9ef881338b8a8066db33190b67f9292957692570a72259cd1e67f1a29f450df7d013f38a6806c379a823836c3f8a617d2202b52222d056bf0677e4f2dba3a67b653ae950a6ad42458cb9bc1835018c142b573452941781fc93b6da19f6f59fc6e66fcb4ee344df26a1920ba79f5d37ce01c0d6d1001edc0e8fe3cb6d5400d755622cd6951cba3a3ac5c4af1dbb605d009a20d34f12abfb056515666eb05a627e0a121fb5e5840e2cb457a9cdbe9fc303ca92efdb709b573f288e0d043487dbb9759b904bdfc058ac149935f8bf09c8bf331f4c7818a335193a391dea69ac475c2769017dd1271c6b9f7ee0b03231890001618090bf1266297015f8fc7d0c94482a9eb60cd554f2044dd59a5758a7b6a105b2093e71a9217386809446e3cb669f969dbb35204b9b9a610a75fb47b72fde337bd61b348b8b218fe07592568fe9a2b7a2201dec646d1fa41bcf538da89dfd295f7f633ccf328fca5666feb6937066c8f0d53d75c2919dac6c924ea50fb12dc94e47f8437d68b93885a9ee6b7484073ac2649a8df75876f46da81f9a9fdf872e886bec4f417f86084612066bfe7604fceaf0c0e169c0cca31451257f3ccd9ea2c47438281123b1b97770f20715cf02721f0e998e242cc37f5b6a171046a8b0bf1fb11ea98720542775e7c528fab09e692b7a829f1d983e565e695399e7b8ed2bf4bbea861f284a32a25ebeb0e7196ad5da2477f2cb616da4f277313017d3a1d5c4671ed61b6aeff74d0e82ec40457543717bece2dbd39c8e1c18e33301c714c95822224e534ae932048edea2b50f27158b18239ecfd80790b1b75af76bb0c95c605bf485230044655ada75bbaa48635f8883a7257ebfeecba042d23a7b52f93759e48b8e42ee335f0a13cbb39c1c57a12f958b28cd409ea8b417c7e92146e06509ce402daa78e9c181feaaa1fd6ebde38dcc746be0814b50cea932b037e146a667d950745eed5a46d0a51ad93a61e6b0765dbef0539b4f81d1edf0ccadb6163e131d0ef3e964566bc39455c4d99cea69ab70f84e87bb08d57a330142a0b1a130f62d2c542807e0727451d4b1806a757935d4345a8e2892b7062bea49094f9d3fdd3105ceb9e4361a0402062be249351c191e4669103183b17bb4c8df3ea67f7837e23207160ec9a7e241288b71205333bf539871438d8cb4f2d6b51314d3516fec31551bf856011bc789da36d62c5c09a6b211461bf3df8da96042a660740659b90e8f86104333bb6485b1d347ebeeec5ddefc65094e030b5adb31a0e28b3308a64ac9887dff1c6c2c52e8b1eef743940a74538987d8b6b3dbe39eb3c8f1ff6b07fa13c06de282347f205c17e758d1b3169226aa8e15b0b95c350f31386cf8faae55ed8d0d24a7f1d0b858681c715a573fddb91b1eca3261ef50ac0b3ef0744ac36b611d40d78a7e9beaace3e3b1de49d4e73ffe005628a0d0e388dbbef0c20da30810334945be473929af157c63a797ee1edc3385b9a876254204fc23a7dea227d2c7a110cc5abc322f71b7c93c9355c01d823f446628a9501ceb06b31a154f6550346bfb46a50de925b9a91732f98106e8545919edebdbc30598401349802f0bc60ff33e0553a31125e34a0a39d295ffcf907f8481c7baf405a469eea850496abdbd69c6bcba717493a5654a6c7f7a041593052e198f27c8c4f7de9dbdc816144820f9b6a58ecaef7e4a84afe3b5fde6025657a83946e91b677352ab7f7690e9a1f778d3509900ec41af45416e6b845250a0cdbf65e835d312baba87c0ba9c05bed8ee6bf9c2431d8beca720901fbd8e49e95b2b21985001f3cfd6aba7b3e6c3513a426ebd7b517b0781841d4ded3d016c25d46453589d35e8b4d087bd2aefe124c2714733cdc4e4445522447b2128ebfbe103a67d08a2c3fbde71e660b76d7e7be3c74d23bc38e5b3c1e219c4f2f0d1385f8221ec2e6a53d494914ecfb8461d02f9a5394c8ecc58dbd2ee7289fbb091b8b6d1775443bbd94948099113f9406077c33f5f9ae19c991e23064acb82e5288f4e0ded16fde4353bdb460c464b3820ad3b58823d6d35282eaf2271f5d6503cbf2a7a9b26e609684c9d65ff400004ea0b7591ee1b68eb94232e98ad530067958e2b3b7913ef4e3f6848730d9b67f39ebebb550f7670041ee2c01930e5125fec0ff35d1ab6e88149165ab0f9e8b50aee3f0da09795697be87a1e7d1eeeac41fc8c506ac7ca74f39749a5c0e11eae54a73c55399a624d7afe86823040e025446a91af1c54244f4d53f22108a0ba90ac61f1e65ed799149abb8603b89c5310390cfd26fd7dc6ceb30ff9d60c6b86d95f5b2075786263b9b0c277d7641925d8600d16a5d9e461c294cb4adcb47963f845f7f481fdeb42971ba948d47b3ae91cd277c5faaf01ea0704bb3558c2b014ce1427d521fded18ce0daa409ed4dee682145103b0c93fdbb3874abbe719bf45dfb8ce5681caaa4ea730fc1b7171d947f44fafa77067a7f484fc3609b6d04e2d7f12b84b69813b70185ea6146528bb7f4912aeb20a6ba4cd4555772530be443dc77f885fd6a61e83934edceb545bf0f377fe6d2064bc1001f1e9e7172558e3f140253ce6219bfbe4cf73d599a9db708f358dc7028572bc878a6a0bc404de83635efdada4198600ca21899f09cbf1c918e9d805783cb1b7648a9211cbb1488c22ecd8c21ad08e6ba7bb4209f0738e1f16110ddc33c0d0f981506f6e2e88906eb137a89ea9cf911d84224dd3a221bd9639c7d06eb149ab61d06abb089b71adcc079e94c0893d3ad9ada1b2b424e422eb59f8f0babd9c6f9995158bd29db0fba9e8a0fac12676b2d242e89ea62eb25110a82b55f9ef0723826dfea38737a18d87ad7552b27361358672e11f407d782446c1b60402795d3d255321600ddfbff2a0672c134fe4a64efdebdc59c393d27d9c772e708618b22fa9f8101a1d76553be45971bc7245b54854d284e7885feda0652f852ba68b5f5c8390f8a8d03949f48c37c103bd6d7fd22a23aaf12dd216b9fc9c7af92fd03522dd2500da4fb0dc29bb06b6eafb0bfc6cb0115227fd47a827569be49610e2ad09e94f8bc335f203c4ce55df0fb330f68c3cd1dd522b44c40f7be65b2338d771d11fa3fbd22ef0ac8ae2b334e14a819d04007d21cdf894fb54eab5220f467e2fb70a244a795239fb945ff3597612b04d3cc9a548fb3929308092b274cd061939a9d6876018545ea7f04f88ea8e94419a20e89186fa1c59c168b4c5f7fdb06d71e556216089f93cfa2a69cbc27f100fe34f303d444090d5dfc1bad9703aa045b19b59fabe6c62fc31be975e53240e8da586baac6312ab6027dba68e67c6b9b221a16979748334f08918c5335935545c5ca5abe983fbfd9ea75f81b1c22b4222205e11f09d219f9d6405a8be19d6c5044aa9947b45eb0ff503705fa36616c00d15bf7b1c92887136fe4b4f5c254e9dcbe9423195c7a037e9aeba6962041d00b6c8b2fbebadd3c791f0926de6e0a3dce63ad41582bd6c7b48227590773a44fba702dfc2131f5b2b643c54831dd4337c8e9a037a124edc18309e87910097eb6656ff39fcb210061138fec80003633a9edd47f7efcc23e4f8063ff443cc6d0aa87a327fe3572f2d4741d19f2e5786a710a8d47afb3368000e8c27af40a6fd9242ce09bd9b8ec18555b2759b4c4c7a4b24ef57cb1de7478ef1283b163eeea615dd06958645717d6b62927f32ca593562521fd50fa4d6b8ac08f5918d7a51e21d955dbde23885e8b41408ffb083967c8a63150d5e17b9b50a997a17d704cab3da86345649a2f201a955d577d24f0023dc45ca31c32c01d5251f3a4a482e24dcebf7d450ec5fc8188776063379da8d7da0e6c2ff25bab5d0b3f5d2c755a7d69dc5f49e45a0aa7a49f7e086752c63c04003ebecfcd09d46e1c32d473902eb3fa406a523727f2603b0fcc43499725b58adb6d4be24faeeaa386d5a3d1ca87a23d30c2eaac870d548e3da220bc06efd269f074d5954920c131dd98f7d07bee03860338c9441447a2863b7705fde43e202015e11143c6ea60b8b9e4acfb028d5b7477f9f6b3dbc2550a0d0569bed90e920d12f2ec287b3800a1c1f74cf335d32b7bfd71dd442551a81958f405660fb338dc371b361e42f705582bc8ba08de1e92443bacbc1816aade3b4ffda208d2b717fe9ce437c898a13dfafba4e0df0e66b71e4ab9f069629fd9434493bc7672227bd24c2f87843c115b45b1c9959e44b344ad23e12232b454a162a1dc2633c9991f1c1e9adbafdf11a014bcd437fab6b875aded8cf9f5abc68601e161c06a9b0ceeae85031d067d974d37dcb30f34ccad7784584f83858bef9ead3980c2638806c2c685260636de0a61ae5c13f092d7e4e469616bfa38f6694b8446358616d35828929d9697370843b6b802620ef4aedbecf0980dc2311be011c1dfcade54508d646f362d12bad0515d9dbda417cc19639ef9ebc774ff3de119b3fbc390e6443a506ee6a536a73b284c0ad58347acebef057182fe4f754feee2649b608a129da1259ce26da2447ea7ae721c29bee459f7c46046064791f547951d188b62edde50c2886097e4bd863acfb4f6f73924b767d189daaa2da7b3b5fde3b730a29c594596e72a5e3f7833a51c395d0b9e969d6d0d863f1bf16ddebe547785c0ac5047813c699b82e96f6de75798f5205888bc8d3a077f4518d7fa91406c1cfda367178831f3de594d839dea06ae7c8090c7dc0c0d23ebc4038be753b9673832ccddddadb3049b590281362e3455ce6a55bb655373b13a73b27b5e3bef594477673e0a6fcee40813216e0c634e7a6188775fec45129aea9fdf38da0778e5f31d2fb18df38d3d7075dfb710f8a61bbdd50bfe9edd59b9bbd5289f7a85920b775e70e0194cc46dc4612fc58288110d17296dd8c9fa5512970307ea65580b03b38debecf3efa50929680f3e2edaea32ddb757ef45ab9710c056ef350a3091f7e2a7cc9eb96fcf126a3fa5aeb49106e5fa5cf89cb28968e39b49249afa81a723f8630a7e6915bd49eeb7cb51701ed56ab8371a11e5d420922e95aca1049c1df3a34f9d8a89d9716bd040a270da92dc03c9e444fa5d267fa363c19508858d2add754ceee550d515187a806be50a6a0f7362401ae4b5e3bec4e375c7ab2ce7a5506cb201b3b4063dd6a7e22a660cb9fb8cfb2208320113385f9127e4845b3bf576586ca66637850c0e4977f86415f0f6271a003e52dca9d0fec2e7ad7ec991aff74b593588187a1d9b07cf4a05a879796291cdb91903e1ad80c6e3f83db26f5be5993a7d0f706cc819107ecc181e6b412a8d52474800afa050f445c46d51c8283c9504fdf9e993540c37147e23241967f4d32e76be0dfb46c449feaa59101374935ec8fbdd9f2effc8835f0226cca2b99f32377159759a751f77255221e47ac53a3141f06c4cc1d3d3f13bef0102da62a80822c39f0c601d6dc1b1b5a6b97663e010dee66ddaddf8978e0ffabb49b10c07847c3603159596d82c3e9659ed7186301d122697c5b2b6678a7d3cbc59a24db2f8fc1dccf5e1609427928affa46414e33f3d20a524d9d650fb58f567ad0071266fcc4561150407e53caf86bcfbec785ad17a07ed57f7f9c4f1203bf766afe5163ca9921b1863f2a49c19703f96254402d8b0a50fea8df978b81a7afa17c013e3906470384013beee4100c35882e0d2eaa3923b2fa9ce6e063521a93dca3ffbc265a7c190ae1cb87336e7945209a5fa9480e358d37b88c66b9e4d7468e034048be1ffadfe265e94d9cd2c1573a8986a83fea38d7379b9bcc4bae654f9a361ec3fee931f8ba02b48a0282509ae1735ba89ac1cef9a33a439bb57814b1f2947b894d646818de3dea4a3150f097f34a5cf3c2c21281a21a370a2ee9925e05e9bd853bfba874c8added7d634418c6cf35a8e9adfd9a461889590b0f08a792f0c381accc59d53c90c978cb9387872bfe32a82ab760ff26987c56f1a83c15f805368a5180d427c249d58fc6ee9c1bf97c1361836bb96f6a4b70419d981ae17e42921774d172ae9e2c7f5e4c70bed61ebc2f427938bf3fde282a674f458c6c78e6cac798e2e1e23be7333a5d6929252a24c295149aa96231356c314e9e8982e9e5f2c22aa5d7448504bab9f392e438eec62626b9dcf32c18205c976fd608459c79736e3c58cc538fde4558506f17379d1bb1dc5896b984606739ac4a968c8591ddb32e714cc2b58893b50be399e67dc3f4a9fa62894b65dd9c869a4e97b360e5f035ff3abe2366002ecd7c37300823b7f89ec5ef44ed8de3fb51ac48c43dcf980ac81a34f34c1fb38a1cc145e453ebc3fbed7eb1d33671106c92d7e824f467668762942a06caa9ea9ab6cb1de23faff7a4963e6547c97cd26e7b399db2aa0bc45bf9ee6426ee814b60636310cbd55517ebf5e73007a385de9bc8dda2b38e1a5be4a81b498a70b82f5ca2c099dd79fc7fff9283189e3eca0c5c7c9cd7d3baa2af53eb0a66706a21af8c17fcccdce6c43dab11c2adf20d6c6a4b51f1e7a635ad3f5a3fc41764ce883e2439f17df76a59e581d81339e80b164666da08ecb054fd0485efcd65e7221112dffddd9986d2a8acacd737190f8c4d7fac60824ae021bee020905004c63b956f731734613ddc743bba6a4208de4e9feacd6bdec291951fa2d5285b0e9432465fc673ff032667766e0cdb1b142fbc5215fc850a3a1d53fc4374df943f58c7fae0a020d4c0b9319f719c0d1e580bf91d5ed6b66d92f916b9e38d323576f5d3bd31bc615354e30c7b361761e85400d47646e84d5d9a51feb063b830cd1a5e67f2d30318e8c291991a0dd2e6938043e30dcbf9e33e33531221758d5b395c084166ad59c5caa32c61025f9a2f616f23bf2606e3309b1125f253f89c752b485a72f37e7bdeab80823fc9284140c89a5681564dbba82198985a11ce83ffd422f4fdcbb238ae4666f2a99335edc9f4abd48882ca4d40dcc02a0c61f92fb5508aa80802d88fcd52b9d765397723071db0f77a561431415207e59c24b9bee8db28d0f23ee2bd89ac4867ea06196b2ce58dc37cbd29583949d0091ba4ccfd863119d29682dc77c51e4ad0b2178c0394d3529dbb655c3b71e3ab0189c43a0f325646ef2f71ee3e4a30677dee3198d6ed61f72ae86d34933591ef10e1e61020023d50eef4053c9b1857899cf642aa85d40eec14969fee0f29fd1aeec96ca52b0815b46f3353f57a8a1b4498ac833c48893a82e452214ea3497e15e4dc58af37d7ba6b0076f05f874860ee494c2fcf9344dd6efe3249f5781eeae5af6fd2be2376245a90cf67fd3c44f8e0e8a552216cd9fd8a1d0b106ee5a5fb561ab25e835d040abbbad6ae107e862c6800900913ccf369bbc8d1916a3917d1079d1390b2dad8da3647573dc728af436791edf078eeca107c01e5c0c261fb590bde6e38527c6704afb15116e5b6ec4d11b3ddc889ca30f596be2cf6b41493ee88fb1a95ce83ea37453c039bc9af302bd7cdb4a9a34278aaf34877bd0d22de3d7679dbbefb76e17a59f9335836f37e8c262d31fd71838618d30eb3f705a99d608f79603f90093cab863d3e482778a4e214ba9b83e691a8cc39aa2680d52968a39fe114cdde55b04785b8368401fe0e5184bdffe42d18c0281c3d76a2f47b39cc8cd8a226d5c119751131b11436d5a73633ba314a1860d306a1dbfb2335c05b3a9874256bd57b1ef5ff9d75685c759fc9bddde8c6d59a775b58aa533260c1b422b72393a90ab43a09fddde39e9682b7ebf4b0914fe70b4e1205d8d0f4774d960fffab905e1be1f8396a55d8f721018fb94e8eb2540ef0b8e07228a4614109c2784815c41a756e9859229939adea27960078c6384b419636ae2c6645263646148bebcd456588cadf024f79dd79da42068adda760a16aee0dfb91f215c45c382a311844727d78628872bf768eeea2d9d48a587b9b4513d6d49c79b2d22de7f2e6c7b6cbc6aa48e6f1cf4217735493b21315e8e597a9cb1ec838678fb3325166e1539e989ffe4cd828a03f72fe45ec3fd3f5a91c744592797343d12e90c1164e186c392329ad512dda502c263d5bd464ce69ad2501ed0e9e05fc9205385c588480257d8b02e030feff9ba38807c1fccac3406385f9f28e2f15f6b0add5b1cf1608ce3bdf84a728df4376eac91a1524f8056ff1cc53a6f60dbc0a1666ec614d95f0821481002fca35243c6d3d397ad0050744af6bbd7430fcbc9e93a062726c4b1fa69597f6ac218f56afca75d4cf4e59a47bce9ed3bfeffa9d7c5e2f572b42cea6edefa909f624b5e9b7dc1164ae6ceda24fe0548a524ad145af22c8912e70650d2cd607f2de1fd922061861742cda00219d5b6089a0f36682e42c795db34ddce36f6c8cedc4c45669b234aed862d89e74b96df34bffec58db7069efb471c12d2cd8b0c638b1f7d1a39349a9566f8dcfe8b92986385614adda9dedf5f738c5e34749f4c4fe2e3791a9562a7606d3c10ed4b4d04854008304f3c67666b7fbf00bd9b4c9a9f88b4f31c2a932eb1d39658759877ce8f8eec52a3779256a8136c0d7b11a5aab8d6c188486d268d39a877757fca7fccd8e6072d9585bade9a10b83a6c0d80f6af3c395da333192b670acf8f69a3f7975772d8f9eb5e306043047f84bde58d8540864abfb00896da7bb8b5ac3380080c9ad1fc1a7f65cb887f2807cd829d88c9c5fd3813551ea05dc2623d5c3ec73564e98f855e306370ab90203a445342ad596110650458d446fb42bb65d4e4b64461e9403c65d87e70b81dcabffd79cd29fbf60070646e87d8389a72360bbce</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-7</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7/</id>
    <published>2020-03-14T03:55:04.000Z</published>
    <updated>2020-03-16T17:21:04.634Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-3</strong></center><a id="more"></a><h3 id="数据类型-7"><a href="#数据类型-7" class="headerlink" title="数据类型-7"></a>数据类型-7</h3><ul><li><p>条件选择语句(控制语句)</p><blockquote><p>if，if…else，else…if，switch，switch…break，switch…if…else语句<br>continue…break<br>goto</p></blockquote></li><li><p>头文件及函数</p><blockquote><p>ctype.h，iso646.h<br>getchar()，putchar()</p></blockquote></li><li><p>其它概念</p></li></ul><hr><p><strong>涉及内容:</strong></p><ul><li>条件选择语句-if/if…else</li><li>getchar()与putchar()方法</li><li>ctype.h头文件/iso646.h头文件</li><li>多重选择语句-else…if</li><li>选择语句配对规则</li><li>逻辑运算符及其优先级，求值顺序与范围</li><li>条件运算符-?:</li><li>循环辅助: continue语句和break语句</li><li>多重选择: switch语句和break语句</li><li>多重标签: switch语句和if…else语句</li><li>跳转标识符: goto</li><li>其它内容(补充内容/关键概念梳理/文章内涉及概念总结)</li><li>有可能会在数据结构-8内进行补充</li></ul><hr><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><ul><li><p>IF语句</p></li><li><p>if语句被称为分支语句(branching statement)或选择语句(selection statement)</p><blockquote><p>因为它相当于一个交叉点，程序要在两条分支中选择一条执行</p></blockquote></li><li><p>if语句的通用形式如下:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( <span class="name">expression</span> )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>如果对expression求值为真(非0)，则执行statement</p><blockquote><p>否则，跳过statement</p></blockquote></li><li><p>与while循环一样，statement可以是一条简单语句或复合语句</p></li><li><p>if语句的结构和while语句很相似</p><blockquote><p>它们的主要区别是: 如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次</p></blockquote></li><li><p>通常，expression是关系表达式</p><blockquote><p>即比较两个量的大小(如，表达式 x &gt; y 或 c == 6)<br>如果expression为真(即x大于y，或c == 6)，则执行statement<br>否则，忽略statement</p></blockquote></li><li><p>概括地说，可以使用任意表达式，表达式的值为0则为假</p></li><li><p>statement部分可以是一条简单语句或者是一条用花括号括起来的复合语句(或块)</p></li></ul><hr><h3 id="IF…ELSE"><a href="#IF…ELSE" class="headerlink" title="IF…ELSE"></a>IF…ELSE</h3><ul><li><p>简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句</p></li><li><p>C 还提供了if else形式，可以在两条语句之间作选择</p></li><li><p>if else语句的通用形式是：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">( expression )</span></span><br><span class="line">   stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">   stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure></li><li><p>如果expression为真(非0)，则执行statement1</p><blockquote><p>如果expression为假或 0，则执行else后面的statement2<br>statement1和statement2可以是一条简单语句或复合语句<br>C并不要求一定要缩进，但这是标准风格<br>缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然</p></blockquote></li><li><p>如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块</p><blockquote><p>下面的代码结构违反了C语法，因为在if和else之间只允许有一 条语句(简单语句或复合语句):</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line"><span class="keyword">else</span>　　　<span class="comment">// 将产生一个错误</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句</p><blockquote><p>它不是if语句的一部分<br>然后，编译器发现else并没有所属的if，这是错误的</p></blockquote></li><li><p>上面的代码应该这样写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择</p></li><li><p>if语句和if else语句的执行逻辑示意图</p></li></ul><img src="/images/数据类型-7/IF语句1.png" width="30%" height="30%"> <img src="/images/数据类型-7/IF...ELSE语句-1.png" width="30%" height="30%"><hr><p><strong>未完成</strong></p><hr><h3 id="getchar-putchar"><a href="#getchar-putchar" class="headerlink" title="getchar()/putchar()"></a>getchar()/putchar()</h3><ul><li>字符输入/输出函数getchar()和putchar()<blockquote><p>同样可用作输入/输出的函数还有scanf()和printf()根据%c转换说明来进行对字符的读写</p></blockquote></li></ul><p><strong>getchar()</strong></p><ul><li><p>getchar()函数不带任何参数，它从输入队列中返回下一个字符</p><blockquote><p>例如: ch=getchar();，它与scanf(“%c”, &amp;ch);的作用相同</p></blockquote></li><li><p>putchar()函数用于打印它的参数</p><blockquote><p>例如: putchar(ch);，该语句用于将之前赋给ch的值作为字符打印出来<br>该语句与printf(“%c”, ch);相同</p></blockquote></li><li><p>由于这些函数只用于处理字符，所以它们比通用的scanf()和printf()函数更快，更简介</p><blockquote><p>而且还有一点，getchar()和putchar()函数不需要进行转换说明，因为它们只处理字符<br>这两个函数通常定义在stdio.h头文件中(而且它们通常是预处理宏，而不是真正在宏观意义上的函数，这里先不对类似于宏的函数进行深入赘述)</p></blockquote></li><li><p>语句putchar(ch + 1);</p><blockquote><p>表示了字符实际上是作为整数而存储于内存之中的<br>为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()<br>该函数只根据最后一个字节确定显示哪个字符</p></blockquote></li></ul><hr><h3 id="ctype-h系列的字符函数"><a href="#ctype-h系列的字符函数" class="headerlink" title="ctype.h系列的字符函数"></a>ctype.h系列的字符函数</h3><ul><li><p>斜杠字符对应的ASCII码比点号的ASCII码多1</p><blockquote><p>如果程序 只转换字母，保留所有的非字母字符(不只是空格)会更好</p></blockquote></li><li><p>C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型</p><blockquote><p>这些函数接受一个字符作为参数，如果该字符属于某特殊的类 别，就返回一个非零值(真)<br>否则，返回0(假)<br>例如，如果isalpha()函数的参数是一个字母，则返回一个非零值</p></blockquote></li><li><p>有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具(例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为 123,45)</p><blockquote><p>注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值</p></blockquote></li><li><p>ctype.h头文件中的字符测试函数列表和头文件中的字符映射函数这里不做赘述</p></li></ul><hr><p><strong>多重选择else…if</strong></p><ul><li>else if 是 if else 语句的变式</li><li>else部分包含另一个if else语 句，该if else语句的else部分又包含另一个if else语句<blockquote><p>第2个if else语句嵌套 在第 1个if else语句中<br>第3个if else语句嵌套在第2个if else语句中</p></blockquote></li><li>对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌</li></ul><hr><p><strong>else…if的配对机制</strong></p><ul><li>规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来</li></ul><p><strong>图片说明:</strong></p><ul><li>if else匹配的规则:</li></ul><img src="/images/数据类型-7/if else匹配的规则-1.png" width="40%" height="40%"> <img src="/images/数据类型-7/if else匹配的规则-2.png" width="40%" height="40%"><ul><li>注意: 要缩进”语句”，”语句”可以是一条简单语句或复合语句</li></ul><hr><p><strong>多层嵌套的if语句</strong></p><ul><li>if…else if…else序列是嵌套if的一种形式，从一系列选项中选 择一个执行<blockquote><p>有时，选择一个特定选项后又引出其他选择，这种情况可以使 用另一种嵌套if</p></blockquote></li></ul><hr><ul><li><p>小结：用if语句进行选择</p><blockquote><p>关键字：if，else</p></blockquote></li><li><p>一般注解:</p><blockquote><p>下面各形式中，statement可以是一条简单语句或复合语句<br>表达式为真说明其值是非零值</p></blockquote></li><li><p>形式1:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，则执行statement部分</p></blockquote></li><li><p>形式2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，执行statement1部分<br>否则，执行statement2部分</p></blockquote></li><li><p>形式3:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression1)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else <span class="keyword">if</span> <span class="comment">(expression2)</span></span><br><span class="line">stateme<span class="symbol">nt2</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt3</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果expression1为真，执行statement1部分<br>如果expression2为真，执行 statement2部分<br>否则，执行statement3部分</p></blockquote><ul><li>示例:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (legs == <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It might be a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (legs &gt; <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It is not a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span>　　 <span class="comment">// 如果legs &lt; 4 </span></span><br><span class="line">&#123;</span><br><span class="line">   legs++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Now it has one more leg.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p>if语句和while语句通常使用关系表达式作为测试条件</p><blockquote><p>有时则需要将多个关系表示组合起来用，此时则需要使用逻辑运算符，并使用点符号<code>&#39;.&#39;</code>来标识句子的末尾</p></blockquote></li><li><p>逻辑运算符两侧的条件必须都为真，整个表达式才为真</p><blockquote><p>逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号</p></blockquote></li><li><p>C 内有三种逻辑运算符，如下表图片:</p></li><li><p>三种逻辑运算符:</p></li></ul><img src="/images/数据类型-7补充图片/三种逻辑运算符-1.png" width="40%" height="40%"><hr><ul><li>举例说明:</li><li>假设exp1和exp2是两个简单的关系表达式(如car &gt; rat或debt == 1000)<blockquote><p>那么:<br>当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真<br>如果exp1或exp2为真，则exp1 || exp2为真<br>如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假</p></blockquote></li></ul><hr><p><strong>iso646.h头文件</strong></p><ul><li><p>C 是在美国用标准美式键盘开发的语言，但在世界各地，并非所有键盘都有和美式键盘一样的符号</p><blockquote><p>因此，C99标准增加了可代替逻辑运算符的拼写，并且将其定义于iso646.h头文件中<br>如果在程序中包含该头文件，便 可用and代替&amp;&amp;、or代替||、not代替!</p></blockquote></li><li><p>逻辑运算符对应的拼写如下表图片:</p></li><li><p>逻辑运算符的备选拼写:</p></li></ul><img src="/images/数据类型-7补充图片/逻辑运算符的备选拼写-1.png" width="40%" height="40%"><ul><li><p>在新增的C99和C11的标准ANSI C库内列出了一些其它运算符的备选拼写</p></li><li><p>!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低</p></li><li><p>&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高</p><blockquote><p>因此，表达式a &gt; b &amp;&amp; b &gt; c || b &gt; d相当于((a &gt; b) &amp;&amp; (b &gt; c)) || (b &gt; d)<br>也就是说，b介于a和c之间，或者b大于d<br>尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第2种写法<br>这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚</p></blockquote></li></ul><hr><p><strong>有关求值顺序</strong></p><ul><li><p>除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值</p></li><li><p>例如下面的语句，可能先对表达式5+3求值，也可能先对表达式9+6求值:</p><blockquote><p><code>apples = (5 + 3) * (9 + 6);</code></p></blockquote></li><li><p>C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计</p><blockquote><p>但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右<br>&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效<br>而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值<br>正是由于有这些规定，才能写出这样结构的代码:<br><code>while ((c = getchar()) != &#39; &#39; &amp;&amp; c != &#39;\n&#39;)</code><br>如上代码所示，读取字符直至遇到第1个空格或换行符<br>第1 个子表达 式把读取的值赋给c，后面的子表达式会用到c的值<br>如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值</p></blockquote></li><li><p>这里还有一个例子:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">number</span> != <span class="number">0</span> <span class="symbol">&amp;&amp;</span> <span class="number">12</span>/number == <span class="number">2</span>)</span><br><span class="line">printf(<span class="string">"The number is 5 or 6.\n"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值<br>这样避免了把0作为除数<br>许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件</p></blockquote></li><li><p>最后，考虑这个例子：</p><blockquote><p><code>while ( x++ &lt; 10 &amp;&amp; x + y &lt; 20)</code><br>实际上，&amp;&amp;是一个序列点，这保证了在对&amp;&amp;右侧的表达式求值之前已经递增了x</p></blockquote></li></ul><hr><p><strong>内容简述:</strong></p><ul><li><p>逻辑表达式:</p><blockquote><p>当且仅当expression1和expression2都为真，expression1 &amp;&amp; expression2才为真<br>如果 expression1 或 expression2 为真，expression1 || expression2 为 真<br>如果expression为假，!expression则为真，反之亦然</p></blockquote></li><li><p>求值顺序:</p></li><li><p>逻辑表达式的求值顺序是从左往右</p><blockquote><p>一旦发现有使整个表达式为假的因 素，立即停止求值</p></blockquote></li><li><p>示例：</p><blockquote><p><code>6 &gt; 2 &amp;&amp; 3 == 3</code> 真<br><code>!(6 &gt; 2 &amp;&amp; 3 == 3)</code> 假<br><code>x != 0 &amp;&amp; (20 / x) &lt; 5</code> 只有当x不等于0时，才会对第2个表达式求值</p></blockquote></li><li><p>有关范围问题:</p><blockquote><p>&amp;&amp;运算符与islower()函数可用于测试范围</p></blockquote></li></ul><hr><h3 id="条件运算符-三元运算符"><a href="#条件运算符-三元运算符" class="headerlink" title="条件运算符/三元运算符"></a>条件运算符/三元运算符</h3><ul><li><p>C 提供条件表达式(conditional expression)作为表达if else语句的一种便捷方式</p></li><li><p>该表达式使用<code>? :</code>条件运算符</p><blockquote><p>该运算符分为两部分，需要三个运算对象<br>带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符<br>以此类推，带三个运算对象的运算符称为三元运算符<br>条件运算符是 C 中唯一的三元运算符</p></blockquote></li><li><p>条件表达式的通用形式如下:</p><blockquote><p><code>expression1 ? expression2 : expression3</code><br>如果 expression1 为真(非 0)，那么整个条件表达式的值与 expression2 的值相同<br>如果expression1为假(0)，那么整个条件表达式的值与 expression3的值相同</p></blockquote></li><li><p>需要把两个值中的一个赋给变量时，就可以用条件表达式</p><blockquote><p>典型的例子是，把两个值中的最大值赋给变量:<br><code>max = (a &gt; b) ? a : b;</code><br>如果a大于b，那么将max设置为a<br>否则，设置为b<br>通常，条件运算符完成的任务用 if else 语句也可以完成<br>但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码</p></blockquote></li></ul><hr><h3 id="循环辅助-continue-amp-break"><a href="#循环辅助-continue-amp-break" class="headerlink" title="循环辅助-continue&amp;break"></a>循环辅助-continue&amp;break</h3><ul><li>一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句</li><li>而continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环</li></ul><p><strong>continue语句</strong></p><ul><li><p>3种循环都可以使用continue语句</p><blockquote><p>执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代<br>如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环</p></blockquote></li><li><p>有两种方法可以避免使用continue</p><blockquote><p>一是省略continue，即为把剩余部分放在一个else块中<br>这种情况下，使用continue的好处是减少主语句组中的一级缩进<br>当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性<br>另一种方式是把if的测试条件的关系反过来便可避免使用continue<br>需要根据程序的实际情况而定</p></blockquote></li><li><p>continue还可用作占位符</p><blockquote><p>例如将循环读取并丢弃输入的数据， 直至读到行末尾<br>当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便<br>问题是，一般很难注意到一个单独的分号<br>如果使用continue，可读性会更高<br>如果用了continue没有简化代码反而让代码更复杂，就不要使用continue</p></blockquote></li><li><p>从何处开始继续循环:</p><blockquote><p>以上介绍了continue语句让程序跳过循环体的余下部分<br>对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值</p></blockquote></li></ul><p><strong>break语句</strong></p><ul><li><p>程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段</p><blockquote><p>但如果break语句位于嵌套循环内，它只会影响包含它的当前循环</p></blockquote></li><li><p>以下两张图片比较了break和continue</p></li></ul><img src="/images/数据类型-7补充图片/break和continue-1.png" width="40%" height="40%"> <img src="/images/数据类型-7补充图片/break和continue-2.png" width="40%" height="40%"><ul><li>break还可用于因其他原因退出循环的情况</li><li>和continue一样，如果用了break代码反而更复杂，就不要使用break</li><li>break语句对于稍后讨论的switch语句而言至关重要<blockquote><p>在for循环中的break和continue的情况不同<br>执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过<br>嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break</p></blockquote></li></ul><hr><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><ul><li>使用条件运算符和 if else 语句很容易编写二选一的程序<blockquote><p>然而，有时程序需要在多个选项中进行选择<br>可以用if else if…else来完成<br>但是大多数情况下使用switch语句更方便</p></blockquote></li></ul><p><strong>switch的工作原理分析</strong></p><ul><li><p>要对紧跟在关键字 switch 后圆括号中的表达式求值</p><blockquote><p>break语句让程序离开switch语句，跳至switch语 句后面的下一条语句<br>如果没有break语句，就会从匹配标签开始执行到switch末尾</p></blockquote></li><li><p>break语句可用于循环和switch语句中，但是continue只能用于循环中</p><blockquote><p>尽管如此，如果switch语句在一个循环中，continue便可作为 switch语句的一部分<br>这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分</p></blockquote></li><li><p>switch语句和Pascal的case语句类似</p><blockquote><p>它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句<br>另外，C 的case一般都指定一个值，不能使用一个范围</p></blockquote></li><li><p>switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)</p></li><li><p>case标签必须是整数类型(包括char类型)的常量或整型常量表达式(即表达式中只包含整型常量)</p><blockquote><p>不能用变量作为case标签</p></blockquote></li><li><p>switch的构造如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch ( 整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句&lt;--可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句&lt;--可选</span><br><span class="line">default :&lt;--可选</span><br><span class="line">语句&lt;--可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于程序只读每行的首字符的情况这里不做多余赘述</p></li></ul><hr><p><strong>有关多重标签</strong></p><ul><li>可以在switch语句中使用多重case标签</li><li>如果使用ctype.h系列的toupper()函数可以避免 使用多重标签</li></ul><hr><p><strong>有关switch和if else</strong></p><ul><li>关于何时使用switch与何时使用if else<blockquote><p>如果是根据浮 点类型的变量或表达式来选择，就无法使用 switch<br>如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦<br>这种情况用if就很方便:<br><code>if (integer &lt; 1000 &amp;&amp; integer &gt; 2)</code></p></blockquote></li><li>使用switch要涵盖以上范围，需要为每个整数(3～999)设置case标签<blockquote><p>但是，如果使用switch，程序通常运行快一些，生成的代码少一些</p></blockquote></li></ul><hr><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><ul><li><p>早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用</p><blockquote><p>但 是C和其他两种语言不同，没有goto语句C程序也能运行良好<br>Kernighan和 Ritchie提到goto语句”易被滥用”，并建议”谨慎使用，或者根本不用”</p></blockquote></li><li><p>goto语句有两部分: goto和标签名</p></li><li><p>标签的命名遵循变量命名规则如下所示:</p><blockquote><p><code>goto part2;</code></p></blockquote></li><li><p>要让这条语句正常工作，函数还必须包含另一条标为part2的语句</p><blockquote><p>该语句以标签名后紧跟一个冒号开始:<br><code>part2: printf(&quot;Refined analysis:\n&quot;);</code></p></blockquote></li></ul><p><strong>避免使用goto</strong></p><ul><li><p>原则上，根本不用在C程序中使用goto语句</p><blockquote><p>但在FORTRAN或BASIC内，goto对这两种语言而言都必不可少，而且还会依赖用goto来编程<br>对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if<br>不能使用块或复合语句</p></blockquote></li><li><p>跳转至循环末尾，并开始下一轮迭代</p><blockquote><p>C使用continue语句代替跳出循环</p></blockquote></li><li><p>C使用break语句</p><blockquote><p>实际上，break和continue是goto的特殊形式<br>使用break和continue的好处是: 其名称已经表明它们的用法，而且这些语句不使用标签<br>所以不用担心把标签放错位置导致的危险<br>胡乱跳转至程序的不同部分</p></blockquote></li><li><p>但是，C程序员可以接受一种goto的用法: 出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)</p></li><li><p>不去使用goto的多个理由:</p><blockquote><p>程序中使用其他形式比使用goto的条理更清晰<br>当多种情况混在一起时，这种差异更加明显<br>哪些goto语句可以帮助if 语句? 哪些可以模仿if else? 哪些控制循环?<br>哪些是因为程序无路可走才不得已放在那里?<br>过度地使用goto语句，会让程序错综复杂<br>如果不熟悉goto语句，就不要使用它<br>如果已经习惯使用goto语句，试着改掉这个毛病<br>讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用<br>因为 C允许在标签中使用描述性的单词而不是数字</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>CN/PDF-C Primer Plus【第6版】</p><blockquote><p>[美] Stephen Prata | 著/姜佑 | 译<br>截止至原书第七章末尾-496页(一共1635页)<br>C 控制语句: 分支和跳转-7.10/7.12</p></blockquote></li><li><p>数据类型-1~数据类型-7</p><blockquote><p>C11/ANSI C/ISO C</p></blockquote></li></ul><hr><ul><li>接下来的内容会以 C 冠名</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-3&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-6</title>
    <link href="https://unit-serow.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6/"/>
    <id>https://unit-serow.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6/</id>
    <published>2020-03-13T05:13:26.000Z</published>
    <updated>2020-03-13T05:15:52.575Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-2</strong></center><a id="more"></a><h2 id="数据类型-6"><a href="#数据类型-6" class="headerlink" title="数据类型-6"></a>数据类型-6</h2><ul><li>循环结构内容补充(控制结构)<blockquote><p>for循环<br>do while循环<br>数组与循环<br>函数与循环<br>其它赋值运算符</p></blockquote></li></ul><hr><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul><li><p>for循环将循环语句最基本的三种行为(初始化，测试和更新)组合在一处</p><blockquote><p>其基本的语法格式为: <code>for (xxx;xxx;xxx){}</code></p></blockquote></li><li><p>关键字for后面的圆括号中的若干个表达式用分号相隔，一般在圆括号中会有至少三个表达式</p></li><li><p>即为初始化表达式，测试条件表达式，更新执行表达式</p><blockquote><p>还可将其称之为包含了循环所需的所有信息: 所选变量的初值，所选变量的终值，所选变量的循环条件(条件表达式或为自增或自减)</p></blockquote></li><li><p>在花括号内可以添加简单语句和复合语句</p></li><li><p>测试表达式的值为真时则继续循环，为假时则停止循环，其它关于的循环基本概念在<a href="http://unit-serow.com/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/#more" target="_blank" rel="noopener">数据类型-5</a>内有详细介绍</p></li><li><p>还可以将for语句圆括号内的表达式称之为控制表达式，它们都是完整的表达式，所以每个表达式的副作用(例如递增变量之类的)都发生在对下一个表达式求值之前</p></li></ul><p><strong>for循环的结构图示</strong></p><ul><li>for循环的结构:</li></ul><img src="/images/数据结构-6/for循环的结构-1.png" width="40%" height="40%"><hr><p><strong>利用C 内 for的灵活性</strong></p><ul><li><p>虽然for循环看上去和FORTRAN的DO循环，Pascal的FOR循环，ASIC 的FOR…NEXT循环类似</p><blockquote><p>但是for循环比这些循环灵活<br>这些灵活性源于如何使用for循环中的3个表达式<br>即为: 1-初始值(变量经由初始化得到的值)，2-条件表达式，3-返回类型所需要执行的某种方法(或称其为每次迭代需要执行的条件)<br>第3个表达式可以使用任意合法的表达式<br>无论是什么表达式，每次迭代都会更新该表达式的值<br>for循环中的3个表达式可以是不同的变量(注意，虽然该例可以正常运行，但是编程风格不太好，如果不在更新部分加入代数计算，程序会更加清楚)<br>可以省略一个或多个表达式(但是不能省略分号)，只要在循环中包含能结束循环的语句即可<br>这句话的意思就是，可以不在圆括号内写条件的表达式，而在for()代码行下对for语句进行说明，此时被进行说明的语句必须带有结束表示分号<br>有没有花括号无所谓，添加花括号的理由是为了让代码更整洁且直观<br>这样使用for循环确实很像其他语言的循环<br>除此之外，C 的for循环还有其他9种用法</p></blockquote></li><li><p>需要注意的要点-1: 在执行循环的其他部分之前，只对第一个表达式求值一次或执行一次</p></li><li><p>同时对于循环体中的行为可以改变循环头中的表达式，此时需要用到if语句与选择语句的概念，即为在for语句中添加复合语句，该复合语句用于执行if等条件选择语句，也可称该复合语句为代码块</p></li><li><p>for语句的一般形式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( initialize; test; <span class="keyword">update</span> )</span><br><span class="line"><span class="keyword">statement</span></span><br></pre></td></tr></table></figure><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例语句:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="built_in">n</span> = <span class="number">0</span>; <span class="built_in">n</span> &lt; <span class="number">10</span> ; <span class="built_in">n</span>++)</span><br><span class="line">printf(<span class="string">" %d %d\n"</span>, <span class="built_in">n</span>, <span class="number">2</span> * <span class="built_in">n</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="其它赋值运算符"><a href="#其它赋值运算符" class="headerlink" title="其它赋值运算符"></a>其它赋值运算符</h2><ul><li><p>包括<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code></p></li><li><p>C有许多赋值运算符</p><blockquote><p>最基本，最常用的是=，它把右侧表达式的值赋给左侧的变量<br>其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式<br>赋给变量的新值是根据右侧表达式的值调整后的值<br>而确切的调整方案取决于具体的运算符</p></blockquote></li><li><p>例如:</p><blockquote><p><code>scores += 20</code> 与 <code>scores = scores + 20</code> 相同<br><code>dimes -= 2</code> 与 <code>dimes = dimes - 2</code> 相同<br><code>bunnies *= 2</code> 与 <code>bunnies = bunnies * 2</code> 相同<br><code>time /= 2.73</code> 与 <code>time = time / 2.73</code> 相同<br><code>reduce %= 3</code> 与 <code>reduce = reduce % 3</code> 相同</p></blockquote></li><li><p>上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式</p></li><li><p>例如：</p><blockquote><p><code>x *= 3 * y + 12 与 x = x * (3 * y + 12)</code> 相同</p></blockquote></li><li><p>以上提到的赋值运算符与<code>=</code>的优先级相同，即比<code>+</code>或<code>*</code>优先级低</p><blockquote><p>上面最后一个例子也反映了赋值运算符的优先级，<code>3 * y</code>先与<code>12</code>相加，再把计算结果与<code>x</code>相乘，最后再把乘积赋给x<br>并非一定要使用这些组合形式的赋值运算符<br>但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效<br>当需要在<code>for</code>循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用</p></blockquote></li><li><p>通常在for的循环头内就能完成大量的工作</p></li></ul><hr><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><ul><li><p>逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式</p></li><li><p>基本使用语法:</p><blockquote><p><code>for (ounces = 1, cost = FIRST_OZ; ounces &lt;= 16; counces++,cost += NEXT_OZ)</code><br>这里的<code>FIRST_OZ</code>和<code>NEXT_OZ</code>是常量数据类型，<code>NEXT_O</code>的值是20<br>在初始化表达式中使用了逗号来对ounces和cost都进行了初始化<br>同时也在更新表达式中使用逗号来表示每次执行迭代时ounces递增1与cost递增20(因为<code>NEXT_Z</code>的值是20)</p></blockquote></li><li><p>逗号运算符的作用就是在同一个表达式区块内进行多组条件的声明</p><blockquote><p>比如在初始化表达式区块中，同时对两个变量进行初始化，或者在更新表达式中声明两个不同的变量在迭代时使用的规则与条件</p></blockquote></li><li><p>逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方</p><blockquote><p>逗号运算符有两个其他性质<br>首先，它保证了被它分隔的表达式从左往右求值(换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生)<br>因此，ounces在cost之前被初始化<br>在该例中， 顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要<br>例如，假设有下面的表达式:<br><code>ounces++, cost = ounces * FIRST_OZ</code><br>在该表达式中，先递增ounce，然后在第2个子表达式中使用ounce的新值<br>作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生</p></blockquote></li><li><p>其次，整个逗号表达式的值是右侧项的值</p></li></ul><p><strong>图解说明逗号表达式的执行逻辑</strong></p><ul><li>逗号运算符和for循环:</li></ul><img src="/images/数据结构-6/逗号运算符和for循环-1.png" width="40%" height="40%"><ul><li>在进行复杂的计算之前，可以先看看数学上是否有简单的方法可用</li></ul><hr><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><ul><li><p>出口条件循环</p></li><li><p>while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所有有可能根本不执行循环体中的内容</p></li><li><p>C 中的出口条件循环(exit-condition loop)的作用是在循环的每次迭代后检查测试条件，以保证至少执行循环体中的内容以此，这种循环被称为do while循环</p></li><li><p>do while循环的通用形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">statement</span></span><br><span class="line"><span class="keyword">while</span> ( expression );</span><br></pre></td></tr></table></figure></li><li><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例程序:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">scanf(<span class="string">"%d"</span>,　&amp;<span class="built_in">number</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span>　(<span class="built_in">number</span>　!=　<span class="number">20</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>statement可以是一条简单语句或复合语句</p><blockquote><p>注意，do while循环以分号结尾<br>do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次<br>而for循环或while循环都是在执行循环体之前先执行测试条件<br>dowhile循环适用于那些至少要迭代一次的循环<br>例如，对用户输入的密码进行测试的程序</p></blockquote></li><li><p>do while循环的结构示意图:</p></li></ul><img src="/images/数据类型-6/do while循环结构-1.png" width="40%" height="40%"><ul><li>其它注解:</li><li>do while语句创建一个循环，在expression为假或0之前重复执行循环体中的内容<blockquote><p>do while语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环<br>因此，该循环至少必须执行一次<br>statement部分可是一条简单语句或复合语句</p></blockquote></li></ul><hr><h3 id="关于对循环的选择"><a href="#关于对循环的选择" class="headerlink" title="关于对循环的选择"></a>关于对循环的选择</h3><ul><li><p>首选需要确定是需要入口条件循环还是出口条件循环</p></li><li><p>通常，入口条件循环用的比较多</p></li><li><p>有几个原因:</p><blockquote><p>其一，一般原则是在执行循环之前测试条件比较好<br>其二，测试放在循环的开头，程序的可读性更高<br>另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环<br>那么，假设需要一个入口条件循环，用for循环还是while循环取决于个人喜好，因为二者皆可</p></blockquote></li><li><p>要让for循环看起来像while循环，可以省略第1个和第3个表达式</p><blockquote><p><code>for ( ; test ; )</code>与此的while效果相同: <code>while ( test )</code></p></blockquote></li><li><p>要让while循环看起来像for循环，可以在while循环的前面初始化变量， 并在while循环体中包含更新语句</p></li><li><p>例如:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化;</span><br><span class="line"><span class="keyword">while</span> ( 测试 )</span><br><span class="line">&#123;</span><br><span class="line">其他语句</span><br><span class="line">更新语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与下面的for循环效果相同:</p><blockquote><p><code>for ( 初始化 ;测试 ; 更新 )</code></p></blockquote></li></ul><p><strong>其他语句:</strong></p><ul><li>一般而言，当循环涉及初始化和更新变量时，用for循环比较合适<blockquote><p>而在其他情况下用while循环更好</p></blockquote></li><li>对于下面这种条件，用while循环就很合 适：<blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1)</code></p></blockquote></li><li>对于涉及索引计数的循环，用for循环更适合</li><li>例如:<blockquote><p><code>for (count = 1; count &lt;= 100; count++)</code></p></blockquote></li></ul><hr><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><ul><li><p>嵌套循环(nested loop)指在一个循环内包含另一个循环</p><blockquote><p>嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行</p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHARS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">for</span> (row=<span class="number">0</span>;row&lt;ROWS;row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ch=<span class="string">'A'</span>;ch&lt;(<span class="string">'A'</span>+CHARS);ch++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br></pre></td></tr></table></figure></li><li><p>程序分析:</p><blockquote><p>第10行开始的for循环被称为外层循环(outer loop)<br>第12行开始的for循环被称为内层循环(inner loop)<br>外层循环从row为0开始循环，到row为6时结束<br>因此，外层循环要执行6次，row的值从0变为5<br>每次迭代要执行的第1条语句是内层的for循环，该循环要执行10次，在同一行打印字符A～J<br>第2条语句是外层循环的printf(“\n”);<br>该语句的效果是另起一行，这样在 下一次运行内层循环时，将在下一行打印的字符<br>注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环<br>在程序中，内层循环一行打印10个字符，外层循环创建6行</p></blockquote></li><li><p>此实例中，内层循环和外层循环所做的事情相同</p></li><li><p>可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务</p><blockquote><p>比如可以根据上面的程序来修改内层循环条件<br>比如让row和A相加，而因为ch是char类型的，所以每次迭代所带来的结果就是将其初始化为不同的字符，所以程序每次对字符的打印数量都会比上一行少一个，如果没有改变测试条件，每行依旧会以F结尾<br>还可称其为依赖外部循环的嵌套循环，只不过不应该存在这种说法，因为这只是最基本的线性逻辑</p></blockquote></li></ul><hr><h3 id="关于在循环中使用数组"><a href="#关于在循环中使用数组" class="headerlink" title="关于在循环中使用数组"></a>关于在循环中使用数组</h3><ul><li><p>因为循环内经常需要用到数组，这里先对数组进行简单的说明</p><blockquote><p>数组可以作为一种存储多个相关项的便利方式</p></blockquote></li><li><p>数组(array)是按顺序存储一系列类型相同的值，如10个char类型的字符或15个int类型的值</p><blockquote><p>整个数组有一个数组明，通过整数下标来访问数组中单独的项或元素(element)</p></blockquote></li><li><p>以下是对数组进行声明的基本语法格式:</p><blockquote><p>float debts[20];</p></blockquote></li><li><p>声明debts是一个内含20个元素的数组，每个元素都可以存储float类型的值</p><blockquote><p>数组的第一个元素是debts[0]，第二个元素是debts[1]，以此类推，直到debts[19]<br>这里需要进行注意的一点就是，数组元素的编号从0开始，而非1<br>此时可以给每个元素赋float类型的值</p></blockquote></li><li><p>赋值的基本语法格式:</p><blockquote><p>debt[6] = 32.49;<br>debt[7] = 1.2e+21;</p></blockquote></li><li><p>实际上，使用数组元素和使用同类型的变量意义</p><blockquote><p>例如，可以这样把值读入指定的元素之中:<br>scanf(“%f”, &amp;debts[4]);</p></blockquote></li><li><p>这里要注意个潜在的陷阱，考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确</p><blockquote><p>所以千万不要书写和使用数组中不存在的元素，因为编译器不会查找这样的错误<br>当运行程序时，这种情况会导致数据被放在在已被其它数据占用的地方，可能会破坏程序的结果甚至导致程序因异常而中断</p></blockquote></li><li><p>数组的类型可以是任意的数据类型</p><blockquote><p>int nannies[22];<br>char actors[26];<br>long big[500];</p></blockquote></li><li><p>可以把字符串存储在char类型的数组中(一般而言，char类型数组的所有元素都存储char类型的值)</p><blockquote><p>如果char类型的数组末尾包含了一个表示字符串末尾的空字符\0，则该数组的内容就构成了一个字符串</p></blockquote></li><li><p>图解字符串数组和字符串:</p></li></ul><img src="/images/数据类型-6/字符串和字符串数组.png" width="40%" height="40%"><ul><li><p>用于识别数组元素的数字被称为下标(subscript)，索引(indice)或偏移量(offset)</p><blockquote><p>下标必须是整数，而且要从0开始计数<br>数组内的元素依次被存储在内存中相邻的为止</p></blockquote></li><li><p>图解内存中的char和int类型的数组:</p></li></ul><img src="/images/数据类型-6/内存中的char和int类型的数组.png" width="40%" height="40%"><ul><li><p>在for循环中可以使用数组，也就是使用循环来处理数组</p></li><li><p>在调整循环语句的逻辑描述时，要时刻遵守模块化(modularity)原则</p><blockquote><p>模块化原则的思想就是: 应把程序划分为一些独立的单元，每个单元执行一个任务<br>这样做能够提升程序的可读性<br>最重要的是，模块化使程序的不同部分彼此独立，方便以后更新或修改程序<br>还可以将每个执行任务的单元放进函数中，提高程序的模块化</p></blockquote></li></ul><hr><ul><li>在循环内使用函数的返回值</li><li>使用带返回值的函数</li><li>此部分可能会被补充</li></ul><hr><h3 id="概念归纳"><a href="#概念归纳" class="headerlink" title="概念归纳"></a>概念归纳</h3><ul><li>循环是一个强大的编程工具<blockquote><p>在创建循环时，要特别注意以下3个方面:</p></blockquote></li></ul><ol><li>注意循环的测试条件要能使循环结束</li><li>确保循环测试中的值在首次使用之前已初始化</li><li>确保循环在每次迭代都更新测试的值</li></ol><ul><li><p>C通过求值来处理测试条件，结果为0表示假，非0表示真</p><blockquote><p>带关系运算符的表达式常用于循环测试，它们有些特殊<br>如果关系表达式为真，其值为 1<br>如果为假，其值为0<br>这与新类型<code>_Bool</code>的值保持一致</p></blockquote></li><li><p>数组由相邻的内存位置组成，只储存相同类型的数据</p><blockquote><p>记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少1<br>C编 译器不会检查数组下标值是否有效，自己要多留心</p></blockquote></li><li><p>使用函数涉及3个步骤:</p></li></ul><ol><li>通过函数原型声明函数</li><li>在程序中通过函数调用使用函数</li><li>定义函数</li></ol><ul><li>函数原型是为了方便编译器查看程序中使用的函数是否正确<blockquote><p>函数定义描述了函数如何工作<br>现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义<br>接口部分描述了如何使用一个特性，也就是函数原型所做的<br>实现部分描述了具体的行为，这正是函数定义所做的</p></blockquote></li></ul><hr><ul><li>在便于理解的前提下，对代码的总体大小进行优化<blockquote><p>易于理解和维护的代码才是好代码<br>没必要去理解或书写一些逻辑严谨到夸张的地步和使用一大片符号类型的代码<br>可以将一句逻辑严谨的代码写成两句或三句便于理解的代码，当然是在保持美观的前提下<br>即模块化原则</p></blockquote></li></ul><hr><p><strong>内容来自原书第六章节</strong></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-2&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C-资源整合目录</title>
    <link href="https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/"/>
    <id>https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/</id>
    <published>2020-03-12T15:55:11.000Z</published>
    <updated>2020-03-13T10:03:35.204Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>C-资源整合目录</strong></center><a id="more"></a><h3 id="C-资源整合目录"><a href="#C-资源整合目录" class="headerlink" title="C 资源整合目录"></a>C 资源整合目录</h3><ul><li>电子书籍</li><li>URL地址</li><li>参考资料</li></ul><hr><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><ul><li>EN-C Primer Plus</li><li>CN-C 程序设计语言</li><li>CN-数据结构与算法分析-C 语言实现</li><li>CN-C Primer Plus (第六版)<blockquote><p>C11标准<br>作者: Stephen Prata<br>译者: 姜佑</p></blockquote></li></ul><hr><p><strong>书籍目录:</strong></p><ul><li>第一章/第二章-基本概念与书籍介绍</li><li>第三章-数据和C</li><li>第四章-字符串和格式化输入/输出</li><li>第五章-运算符，表达式和语句</li><li>第六章-C控制语句：循环</li><li>第七章-C控制语句：分支和跳转</li><li>第八章-字符输入/输出和输入验证</li><li>第九章-函数</li><li>第十章-数组和指针</li><li>第十一章-字符串和字符串函数</li><li>第十二章-存储类别，链接和内存管理</li><li>第十三章-文件输入/输出</li><li>第十四章-结构和其它数据形式</li><li>第十五章-位操作</li><li>第十六章-C预处理器和C库</li><li>第十七章-高级数据表示</li></ul><p><strong>笔记归纳:</strong></p><ul><li>第一/二/三章被归纳于数据类型-1/2内</li><li>第四章被归纳于数据类型-3/4内</li><li>第五章被归纳于数据类型-5内</li><li>第六章被归纳于数据类型-6内</li><li></li></ul><hr><ul><li>本书一共十七个章节，预计使用最多50个笔记文本进行刨析归纳<blockquote><p><code>17*2+16=50</code></p></blockquote></li></ul><hr><ul><li><p>相关资源整合包</p></li><li><p><a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">百度网盘地址</a>:</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA</a><br>提取码: 0ez0</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;C-资源整合目录&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-5</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/</id>
    <published>2020-03-12T11:14:12.000Z</published>
    <updated>2020-03-12T11:16:20.592Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-1</strong></center><a id="more"></a><h2 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型-5"></a>数据类型-5</h2><ul><li>语句与表达式-1<blockquote><p>C-控制语句/循环-While<br>C-控制语句/选择<br>关系运算及其关系运算符<br>条件表达式<br>真与假的概念<br>循环逻辑概念与原理</p></blockquote></li></ul><hr><ul><li>通常一门语言应该提供以下三种形式的程序流<blockquote><p>执行语句序列(即为线性的执行逻辑)<br>如果满足某些条件就进行重复执行的语句序列(循环)<br>通过测试选择执行哪一个语句序列(分支/控制)</p></blockquote></li></ul><hr><h2 id="C-控制语句-循环"><a href="#C-控制语句-循环" class="headerlink" title="C 控制语句-循环"></a>C 控制语句-循环</h2><h3 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h3><ul><li><p>while循环是入口条件循环</p><blockquote><p>或称其为while循环是使用入口条件的有条件循环<br>所谓的有条件指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)<br>该表达式是一个入口条件(entry condition)，因为必须满足条件才能进入循环体<br>如果条件一开始就为假，则绝对不会进入循环体，则跳过循环体代码块</p></blockquote></li><li><p>可以把下面的伪代码作为while循环的标准格式:</p></li></ul><p>1.利用循环外的语句对循环内的变量进行值传递<br>2. 获得第1个用于测试的值 (while (循环条件))<br>3. 当测试为真时<br>4. 处理值 (根据循环条件)<br>5. 获取下一个值 scanf()</p><ul><li><p>当被输入的值传递进循环并可以保证条件为真时，开始第一轮循环</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>); <span class="comment">/* 定义被输入值的变量 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">status</span> == <span class="number">1</span>) <span class="comment">/* 定义循环条件 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>);  <span class="comment">/* 定义循环行为，即接受被输入的值，当接受的值可以满足循环条件时则为真，开始迭代 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以写为</p><blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1){/* 循环行为 */}</code></p></blockquote></li><li><p>while循环的通用形式如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( expression )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>其中statement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句</p></li><li><p>在大部分的程序内，expression部分都使用关系表达式</p><blockquote><p>也就是说，expression是值之间的比较，可以使用任何表达式<br>如果expression为真(或者更一般地说，非零)，则执行statement部分一次，然后再次判断expression<br>在expression为假(0)之前，循环的判断和执行一直重复进行<br>每次循环都被称为一次迭代/循环一轮(iteration)</p></blockquote></li><li><p>while循环结构示意图:</p></li></ul><img src="/images/数据类型-5/C-循环语句-1.png" width="30%" height="30%"><ul><li><p>while循环有一点非常重要: 在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假</p><blockquote><p>否则，循环就不会终止(可以使用 break和if语句来终止循环)</p></blockquote></li><li><p>最大正值加一一般 会得到一个负值，类似地，最小负值减一一般会得到最大正值</p></li></ul><hr><h3 id="while的语法要点"><a href="#while的语法要点" class="headerlink" title="while的语法要点"></a>while的语法要点</h3><ul><li><p>使用while时，要牢记一点: 只有在测试条件后面的单独语句(简单语句或符合语句)才是循环部分</p><blockquote><p>while循环语句的格式应为while(){}，而绝非{while()}，陷入无限循环(infinite loop)是最常见的情况</p></blockquote></li><li><p>还有一点就是，即便while语句本身使用符合语句，while的本质依旧是一条单独的语句(或称为在语句构成上)</p><blockquote><p>该语句从while开始执行，到第一个分号结束，在使用复合语句的情况下，到右花括号结束，还需要注意分号的为止，一定要在语句结束时再写分号</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li><li><p>在使用while语句时，可以直接将分号写在条件表达式后面，即可以让程序直接进入下一个迭代，因为一个单独的分号被视为一条语句</p></li><li><p>如果在测试条件(条件表达式)的代码后面直接添加单独的分号</p><blockquote><p>此分号则代表为一个空语句(null statement)，它什么也不做<br>在 C 中，单独的分号表示空语句，而处理空语句最好的方法是使用continue语句</p></blockquote></li></ul><hr><h3 id="关系运算符与表达式"><a href="#关系运算符与表达式" class="headerlink" title="关系运算符与表达式"></a>关系运算符与表达式</h3><ul><li><p>用关系运算符和表达式来比较大小</p></li><li><p>以下关于关系表达式与关系运算符的概念在所有的循环类语句概念中都通用，这里的通用泛指计算机上所有的程序语言</p></li><li><p>while循环经常依赖测试表达式来作比较，这样的表达式被称之为关系表达式(relational expression)</p></li><li><p>而出现在关系表达式中间的运算符叫做关系运算符(relational operator)</p></li><li><p>以下表图片内列出了 C 的所有关系运算符，同时该表也涵盖了所有的数值关系</p></li><li><p>关系运算符:</p></li></ul><img src="/images/数据类型-5/关系运算符-1.png" width="30%" height="30%"><ul><li><p>PS: 数字之间的关系再复杂也没有人与人之间的关系复杂-来自原书</p></li><li><p>关系运算符常用于构造while语句和其他C语句中用到的关系表达式</p><blockquote><p>这些语句都会检查关系表达式为真还是为假</p></blockquote></li><li><p>所谓关系运算符，存在的意义就是对人为所描述的表达式的值进行确定，确定的结果只有0和1，即真与假</p></li><li><p>而在确定的过程中，最常见的确定方法就是与人为所规定的值进行字符的比较</p></li><li><p>如果要对浮点数进行比较，尽量要去只是用&lt;和&gt;，因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等</p></li><li><p>为了避免此类型错误的发生，C 内拥有fabs()函数，该函数声明在math.h头文件中</p><blockquote><p>使用该函数可以较为方便的比较浮点数，该函数返回一个浮点的绝对值(即为没有代数符号的值)</p></blockquote></li></ul><hr><p><strong>fabs()函数使用示范:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">double</span> response;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"What is the value of pi?\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"lf"</span>, &amp;response);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Try again!\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Close enough!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差 0.0001：</p></li><li><p>输出结果:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">is</span> the value of pi?</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">Try again!</span><br><span class="line"><span class="number">3.1416</span></span><br><span class="line">Close enough!</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="何为真"><a href="#何为真" class="headerlink" title="何为真"></a>何为真</h3><ul><li><p>这是一个古老的问题，但是对C而言还不算难、</p></li><li><p>在C中，表达式一定有 一个值，关系表达式也不例外</p></li><li><p>可以使用并输出两条简单的比较语句，比如说 <code>true_val=(10&gt;2);</code>和<code>false_val(10==2);</code>，前者为真，后者为假</p><blockquote><p>则输出的结果必定是true=1，而false=0</p></blockquote></li><li><p>所以说，对 C 而言，表达式为真的值为1，表达式为假的值为0</p></li><li><p>当 C 程序的循环结构的判断结果一直为真(即为1)时，则反复且永远进行条件及语句的迭代</p></li><li><p>所以一些C程序使用下面的结构，由于1为真，所以该循环会一直进行</p><blockquote><p><code>while (1){...}</code></p></blockquote></li></ul><p><strong>关于其它的真值:</strong></p><ul><li><p>在 C 中，所有的非零值都被视为真，只有0被视为假</p><blockquote><p>也就是说，只要测试条件的值为非零，就会执行while循环</p></blockquote></li><li><p>这是从数值方面而不是从真/假方面来看测试条件</p><blockquote><p>还有需要进行牢记的一点就是，关系表达式为真，求值得一，关系表达式为假，求值得零<br>因此，这些表达式实际上相当于数值，所以必须要去充分利用测试条件的这一特性<br>比如，用while(goats)替换while(goats !=0)，因为表达式goats !=0和goats都只有在goats的值为0时才为0或假，所以再增加一个不等于(!=)的比较运算符的毫无意义的<br>这里利用了 C 内自动判断真值与假值的性质，或称其为默认值与自然选择</p></blockquote></li><li><p>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编译代码，从而使代码更加整洁与美观</p></li><li><p>这个特点既为好处，也为坏处，C 由于对真的约束太少，会带来一些麻烦</p><blockquote><p>当循环的条件表达式中没有定义==1，而定义了=1时，此时的条件表达式中的变量的值为一<br>而且，整个赋值表达式的值就是赋值运算符左侧的值，所以变量=1的值也是1，既while(变量=1)实际上就相当于while(1)<br>也就是说，循环不会退出，此时如果人为的输入其它的符号，从而让变量的值归于0，但是循环的测试条件又把改变量重置为1，从而又进入了下一次迭代<br>此时程序中的循环一直运行着，用户在输如符号后完全没有机会输入，如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，以供下一次读取<br>当scanf()把输入的符号(这里的符号可以为任何不属于数字的数据类型)作为整数读取失败了，他将会把字符留下<br>在下一次循环时，scanf()从上次读取失败的地方(被输入字符)开始读取，scanf()把该输入的字符再次作为整数读取，然后又失败了<br>以此，就造成了一个无限的循环，而且还是失败的</p></blockquote></li><li><p>所以这里千万需要注意的一点就是，千万别把关系相等运算符==和赋值运算符=给弄错了</p></li><li><p>因为 C 不允许给常量赋值</p><blockquote><p>而且编译器会把赋值运算符的这种用法作为语法错误标记出来<br>可以在构建比较是否相等的表达式时，把常量放在左侧，比如<code>6 = canoes;</code></p></blockquote></li><li><p>好在计算机察觉不出来，因为对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样-来自原文</p></li><li><p>总之，关系运算符用于构成关系表达式</p><blockquote><p>关系表达式为真时值为1，为假时值为0<br>通常用关系表达式作为测试条件的语句(如while和if)可以使用任何表达式作为测试条件<br>即非零为真，零为假</p></blockquote></li><li><p>以类似于<code>while (条件表达式)</code>这样的格式为变量进行命名可以让while循环的测试变得简单易懂</p></li></ul><hr><h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a><code>_Bool</code>类型</h3><ul><li><p>在 C 中，一直用int类型的变量表示真/假值</p></li><li><p>C99专门针对这种类型 的变量新增了<code>_Bool</code>类型</p><blockquote><p>该类型是以英国数学家George Boole的名字命名 的，他开发了用代数表示逻辑和解决逻辑问题<br>在编程中，表示真或假的变量被称为布尔变量(Boolean variable)，所以<code>_Bool</code>是 C 中布尔变量的类型名<br>其中<code>_Bool</code>类型的变量只能储存1(真)或0(假)<br>如果把其他非零数值赋给<code>_Bool</code>类型的变量，该变量会被设置为1<br>这反映了C把所有的非零值都视为真<br>给布尔变量取一个能表示真或假值的变量名是一种常见的做法</p></blockquote></li><li><p>C99提供了<code>stdbool.h</code>头文件，该头文件让<code>bool</code>成为<code>_Bool</code>的别名</p><blockquote><p>而且还把true和false分别定义为1和0的符号常量<br>包含该头文件后，写出的代码可以与C++兼容<br>因为C++把bool，true和false定义为关键字<br>如果系统不支持<code>_Bool</code>类型，导致无法运行该程序<br>可以把<code>_Bool</code>替换成 int即可</p></blockquote></li></ul><hr><h3 id="优先级和关系运算符"><a href="#优先级和关系运算符" class="headerlink" title="优先级和关系运算符"></a>优先级和关系运算符</h3><ul><li><p>关系运算符的优先级比算术运算符(包括+和-)要更低，而比赋值运算符要高</p></li><li><p>关系运算符之间有两种不同的优先级。</p><blockquote><p>高优先级组: &lt;&lt;= &gt;&gt;=<br>低优先级组: == !=</p></blockquote></li><li><p>与其他大多数运算符一样，关系运算符的结合律也是从左往右</p></li><li><p>以下图片列表列出了常用的关系运算符优先级关系，具体可以参考-[C 运算符]，其中列出了全部运算符的完整优先级列表</p></li><li><p>运算符优先级:</p></li></ul><img src="/images/数据类型-5/C-关系运算符优先级-1.png" width="30%" height="30%"><hr><h3 id="关于不确定循环和计数循环"><a href="#关于不确定循环和计数循环" class="headerlink" title="关于不确定循环和计数循环"></a>关于不确定循环和计数循环</h3><ul><li><p>一些while循环是不确定循环(indefinite loop)</p><blockquote><p>所谓不确定循环，指 在测试表达式为假之前，预先不知道要执行多少次循环</p></blockquote></li><li><p>还有一类是计数循环(counting loop)</p><blockquote><p>这类循环在执行循环之前就知道要重复执行多少次</p></blockquote></li><li><p>在创建一个重复执行固定次数的循环中涉及了3个行为:</p></li></ul><p>1.必须初始化计数器<br>2.计数器与有限的值作比较<br>3.每次循环时递增计数器</p><ul><li>while循环的测试条件执行比较，递增运算符执行递增<blockquote><p>如果递增发生在循环的末尾，即可以防止不小心漏掉递增<br>因此，这样做比将测试和更新组合放在一起要好，但是计数器的初始化放在循环外，就有可能忘记初始化<br>此时可以用for循环来避免这种情况的发生</p></blockquote></li></ul><hr><p><strong>其它内容:</strong></p><ul><li>赋值运算符 用于将右值赋给左值，而左值通常为变量</li><li>赋值表达式</li><li>关系运算符 用于对左值和右值进行比较</li><li>条件运算符</li></ul><hr><h3 id="伪代码-pseudocode"><a href="#伪代码-pseudocode" class="headerlink" title="伪代码(pseudocode)"></a>伪代码(pseudocode)</h3><ul><li>是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应</li><li>伪代码有助于涉及程序的逻辑</li><li>确定程序的逻辑无误后，再把伪代码翻译成实际的代码</li><li>使用为伪代码的好处之一是，可以把注意力集中再程序的组织和逻辑上，不用在设计程序时还要分心去想如何用编程语言来表达自己的想法</li><li>例如可以用缩进来代表一块代码，不用考虑 C 的语法要用花括号把部分代码括起来</li></ul><hr><h3 id="其它理解"><a href="#其它理解" class="headerlink" title="其它理解"></a>其它理解</h3><hr><ul><li><p>程序按照序列逻辑进行线性执行</p></li><li><p>由主函数mian()开始</p><blockquote><p>然后线性执行主函数内所调用的函数和语句<br>而其它的函数也是相同的原理，函数内的任何语句都是根据线性逻辑来逐一执行<br>至于循环语句与控制语句也是由线性逻辑来执行的，即执行完该语句上面的所有语句，再进行对循环或控制语句的执行<br>各种基本数据对象根据逻辑构成语句(数据对象可以包括变量，数组，指针，运算符，关键字或对于其它函数的调用等等)</p></blockquote></li><li><p>语句构成函数</p></li><li><p>函数构成程序</p></li><li><p>在计算机内，构成任何数据对象的逻辑都是线性的，即逐一执行</p></li></ul><hr><ul><li>预处理器(对于头文件的处理方法，通常是在程序编译之前就已经将头文件中的内容处理完毕，处理的对象即为对于所指头文件内函数的对应调用)</li><li>头文件(给当前的程序本身提供外部函数的支持，即对于当前语言标准库的支持)</li></ul><ol><li>定义常量</li><li>定义全局变量</li><li>函数声明</li></ol><ul><li>主函数<code>main(){包括了对于其它函数的调用以及线性逻辑执行}</code><blockquote><p>对于其它函数的补充</p></blockquote></li></ul><hr><ul><li><p>声明函数的基本格式为: <code>void funtion_name (void) {函数内容}</code></p><blockquote><p>圆括号内所声明的参数可称其为形式参数，即为没有值，但有数据类型的变量数据类型<br>前者的void为函数本身的数据类型，最常用的是整形类型或长整型类型<br>函数的类型用于声明让函数实现的功能模块</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li><p>每个函数或每个花括号都可以被称为是代码块</p></li><li><p>写程序的大体逻辑</p></li></ul><ol><li>先将常量和全局变量声明完毕</li><li>进行函数声明</li><li>然后先写上主函数</li><li>再对函数进行补充，以实现其对应功能</li><li>最后再主函数中的内容进行补充(通常就是对已存在的函数进行进行逐一调用)</li><li>编译源代码并执行程序</li></ol><ul><li>在计算机内，一切的执行逻辑都是线性的</li></ul><hr><ul><li><p>条件表达式与条件语句的本质就是判断值的真假或称其为0或1，用更大的范围去描述则是0与任何实数，即0就是假，或称其为无，其它的任何数都是真，或称其为有</p></li><li><p>无论是循环语句，选择语句还是任何的控制语句(流程控制语句)，它们存在(或称其为存在)的意义都是为了对所选条件表达式的值进行判断，而判断的结果只有两个，即为0与1</p></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编写代码，从而使代码更加整洁与美观</li><li>千万不要忘了伪代码的概念，一般的思路梳理就是对所谓伪代码的实现</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-4</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/</id>
    <published>2020-03-12T01:55:21.000Z</published>
    <updated>2020-03-12T11:17:45.381Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>数据类型-运算符与表达式-1</strong></center><a id="more"></a><h2 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型-4"></a>数据类型-4</h2><ul><li>重点为运算符与表达式</li></ul><hr><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p><strong>涉及概念:</strong></p><ul><li>一元运算符</li><li>二元运算符</li><li>左值与右值</li><li>表达式和语句</li><li>基本循环及其符合语句</li><li>副作用与序列点</li></ul><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p><strong>右值</strong></p><ul><li><p>右值(rvale)，通常只能是字面常量</p><blockquote><p>而字面常量不能常量赋值，因为常量本身就是它的值<br>因此，在使用赋值运算符=时，左侧的项必须是一个变量名<br>实际上，赋值运算符左侧必须引用一个存储位置，而最简单方法就是使用变量名<br>不过指针也可用于指向一个存储位置<br>概括地说，C 使用可修改的左值(modifiable lvalue)标记那些可赋值的实体(物理内存)</p></blockquote></li><li><p>术语概览: 数值对象，左值，右值和运算符</p></li><li><p>赋值表达式语句的目的是把值存储到内存位置上</p></li><li><p>用于存储值的数据存储区域被称之为对象(data object)</p></li><li><p>C 标准中只有提到赋值的概念时，才有可能涉及到对象这个术语</p></li><li><p>使用变量名是表示对象的唯一方法，除此之外还有其它的方法，例如指定数组的元素，结构的成员，或者使用指针表达式(指针中存储的是它所指对象的地址)</p></li><li><p>相关的具体细节这里不做过多阐述</p></li></ul><p><strong>左值</strong></p><ul><li><p>左值(lvalue)是C的术语，用于表示特定数据对象的名称或表达式</p><blockquote><p>因此，对象指的是实际的数据存储，而左值是用于表示或定位存储位置的标签</p></blockquote></li><li><p>对于早期的C，左值所涉及的意义:</p></li></ul><ol><li>它指定一个对象，所以引用内存中的地址</li><li>它可以在赋值运算符的左侧，左值(lvalue)中的l源自left</li></ol><ul><li>但后来的C标准中新增了const限定符，用const创建的变量为只读变量，即为不可修改<blockquote><p>因此，const标识符可以满足上面的第一项，而无法满足第二项<br>一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧<br>有些左值不能用于赋值运算符的左侧，因此，标准对左值的定义已经不能满足当前的状况<br>为此，C标准新定义了一个术语: 可修改的左值(modifable lvalue)，此方法用于标识可修改的对象<br>所以，赋值运算符的左侧应该是可修改的值，当前标准建议，使用术语对象定位值(object locator value)更好</p></blockquote></li></ul><hr><p><strong>右值</strong></p><ul><li><p>右值(rvalue)指的是能赋值给可修改左值的量，且本身不是左值</p><blockquote><p>右值中的r源自right</p></blockquote></li><li><p>右值可以是常量，变量或其它可求值的表达式(如，函数调用)</p><blockquote><p>实际上，当前标准在描述这一概念时使用的是表达式的值(value of an expression)，而非右值<br>右值示例: bmw = 2002;，此时的2002则为右值</p></blockquote></li><li><p>左值就是用于引用某指定内存位置的标识符，而右值即为存储于该内存位置的值</p></li><li><p>在名称学习时，被称为”项”(如，赋值运算符左侧的项)的就是运算符对象(operand)</p><blockquote><p>运算对象指的就是运算符操作的对象<br>还可以类似的将”=运算符的左侧对象”称之为是”应该是可修改的左值”</p></blockquote></li></ul><hr><h2 id="基本的算术运算符-一元-二元运算符"><a href="#基本的算术运算符-一元-二元运算符" class="headerlink" title="基本的算术运算符-一元/二元运算符"></a>基本的算术运算符-一元/二元运算符</h2><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul><li>二元运算符最基本的定义是运算对象至少是两个值</li><li>最基本的二元运算符是四则运算标识符</li></ul><p><strong>加法运算符</strong></p><ul><li>加法运算符(addition operator)用于加法运算，使其两侧的值相加<blockquote><p>而相加的值(运算对象)可以是对象，也可以是常量<br>比如 icome = salary + bribes;，计算机会查看加法运算符右侧的两个变量，即为右值，将其相加，然后将相加的和(返回的结果)赋值给变量income<br>这里需要注意的一点是，income，salary，bribes都是可修改的左值，因为每个变量都标识了一个可被赋值的数据对象<br>但是，表达式salary + brives是一个右值</p></blockquote></li></ul><p><strong>减法运算符</strong></p><ul><li>减法运算符(subtraction operator)用于减法运算，使其左侧的数减去右侧的数<blockquote><p>例如，下面的语句把200.0赋给takehome：<br>takehome = 224.00 – 24.00;<br>+和-运算符都被称为二元运算符(binary operator)，即这些运算符需要两个运算对象才能完成操作</p></blockquote></li></ul><hr><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul><li>一元运算符(unary operator)</li><li>一元运算符就是符号运算符，即仅需要运算一个运算对象的运算符<blockquote><p>类似于赋值运算符=，数值标识符-，+(正值与负值)，指针标识符&amp;和*等等</p></blockquote></li></ul><p><strong>符号运算符:-和+</strong></p><ul><li><p>减号还可用于标明或改变一个值的代数符号</p><blockquote><p>rocky = -12;，以这种方式使用的负号被称之为一元运算符</p></blockquote></li><li><p>在C90标准中新增了一元+运算符，它不会改变运算对象的值或符号</p><blockquote><p>只能这样使用: dozen = +12;<br>此时编译器不会报错，但是在以前，这样做是不被允许的</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>二元运算符和一元运算符:</li></ul><img src="/images/数据类型-4/运算符-1.png" width="30%" height="30%"><hr><p><strong>乘法运算符</strong></p><ul><li>符号*表示乘法<blockquote><p><code>cm = 2.56 * inch;</code>，该语句就是用2.56乘以inch，并将结果赋值给cm<br>因为C 内没有平方函数与指数函数，所以只能用循环语句来实现平方与其它指数级增长</p></blockquote></li></ul><p><strong>除法运算符</strong></p><ul><li><p>C使用符号/来表示除法</p></li><li><p>符号/左侧的值是被除数，右侧的值是除数</p><blockquote><p>例如，此表达式中four的值是<code>4.0: four = 12.0/3.0;</code></p></blockquote></li><li><p>整数除法和浮点数除法不同</p><blockquote><p>浮点数除法的结果是浮点数，而整数除法的结果是整数<br>整数是没有小数部分的数<br>这使得5除以3很让人头痛，因为实际结果有小数部分</p></blockquote></li><li><p>在C语言中，整数除法结果的小数部分被丢弃</p><blockquote><p>这一过程被称为截断(truncation)</p></blockquote></li><li><p>一般情况下最好避免混合类型的出现，即同一个除法表达式内同时出现整数与浮点数</p><blockquote><p>因为计算机不能真正的使用浮点数去除以整数，所以编译器会把两个运算对象转换成相同的类型<br>即在进行出发运算之前，将整数转换为浮点数，或将浮点数转换为整数</p></blockquote></li><li><p>在C99标准以前，C语言给语言的实现者留有一些空间</p><blockquote><p>让他们来决定如何进行负数的整数除法<br>一种方法是，舍入过程采用小于或等于浮点数的最大整数<br>当然，对于<code>3.8</code>而言，处理后的3符合这一描述<br>但是当需要处理<code>-3.8</code>时，该方法建议四舍五入为<code>-4</code><br>因为<code>-4</code> 小于<code>-3.8</code><br>但是，另一种舍入方法是直接丢弃小数部分<br>这种方法被称为”趋零截断”，即把<code>-3.8</code>转换成<code>-3</code><br>在C99以前， 不同的实现采用不同的方法<br>但是C99规定使用趋零截断<br>所以，应把-<code>3.8</code>转换成<code>-3</code></p></blockquote></li></ul><hr><ul><li>当同一个表达式内出现了多种不同种类的运算符时，运算符会出现优先级限制</li></ul><p><strong>图片说明:</strong></p><ul><li>目前为止文章内涉及的运算符优先级(从低至高):</li></ul><img src="/images/数据类型-4/运算符优先级-1.png" width="30%" height="30%"><ul><li>优先级和求值顺序<blockquote><p>运算符的优先级为表达式中的求值顺序提供了重要的依据，但是并没有规定所有的顺序<br>所以 C 给实现者留出了选择的余地</p></blockquote></li></ul><hr><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><ul><li>C 中有大约40个运算符，有些运算符比其它运算符常用的多<blockquote><p>这里只对最常用的运算符进行讨论</p></blockquote></li></ul><p><strong>sizefo运算符与其相关类型</strong></p><ol><li>sizeof运算符和<code>size_t</code>类型<blockquote><p>sizeof运算符以字节为单位返回运算对象的大小(在C中，1字节定义为char类型占用的空间大小)<br>过去，1字节通常是8位，但是一些字符集可能使用更大的字节<br>运算对象可以是具体的数据对象(如，变量名)或类型<br>如果运算对象是类型(如， float)，则必须用圆括号将其括起来</p></blockquote></li></ol><ul><li>C 规定，sizeof返回<code>size_t</code>类型的值<blockquote><p>这是一个无符号整数类型， 但它不是新类型</p></blockquote></li><li><code>size_t</code>是语言定义的标准类型<blockquote><p>C 有一个typedef机制<br>允许程序员为现有类型创建别名<br>例如:<br><code>typedef double real;</code><br>这样，real就是double的别名</p></blockquote></li><li>现在，可以声明一个real类型的变量:<blockquote><p><code>real deal; // 使用typedef</code><br>编译器查看real时会发现，在typedef声明中real已成为double的别名<br>于是把deal创建为double 类型的变量<br>类似地，C 头文件系统可以使用typedef把<code>size_t</code>作为<code>unsigned int</code>或<code>unsigned long</code>的别名<br>这样，在使用<code>size_t</code>类型时，编译器会根据不同的系统替换标准类型</p></blockquote></li><li>C99 做了进一步调整，新增了<code>%zd</code>转换说明用于<code>printf()</code>显示<code>size_t</code>类型的值<blockquote><p>如果系统不支持<code>%zd</code>，可使用<code>%u</code>或<code>%lu</code>代替<code>%zd</code></p></blockquote></li></ul><hr><p><strong>求模运算符</strong></p><ol start="2"><li>求模运算符(modulus operator): <code>%</code></li></ol><ul><li><p>用于整数运算</p></li><li><p>求模运算符给出其左侧整数除以右侧整数的余数(remainder)</p><blockquote><p>例如，<code>13 % 5</code>(读作”13求模5”)得3，因为13比5的两倍多3，即13除以5的余数是3<br>求模运算符只能用于整数，不能用于浮点数</p></blockquote></li><li><p>求模运算符常用于控制程序流</p><blockquote><p>例如，假设此时正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用<br>这种情况可以在程序中对月份求 模3(即，month % 3)，并检查结果是否为0<br>如果为0，便加进额外的费用</p></blockquote></li><li><p>求模运算符作得出的结果就是所谓的取余运算所得出的结果</p></li><li><p>负数也可以进行求模运算，于C99开始支持了趋零截断</p></li></ul><hr><p><strong>递增运算符</strong></p><ul><li><p>递增运算符(increment operator)-即为’++’</p></li><li><p>用于执行简单的任务，将其运算对象递增1</p><blockquote><p>该运算符以两种方式出现<br>第1种方式，++出现在其作用的变量前面， 这是前缀模式<br>第2种方式，++出现在其作用的变量后面，这是后缀模式<br>两种模式的区别在于递增行为发生的时间不同</p></blockquote></li></ul><hr><p><strong>while循环的执行逻辑</strong></p><ul><li>根据所规定条件，对条件进行循环执行</li><li>例如规定了一个条件为<code>shoe &lt; 18</code>，并且每执行一次就进行一次递加(++)的表达式<blockquote><p>执行的逻辑是shoe的值递增1，然后和18进行比较，如果递增后的值小于18，则再次执行所规定的循环条件(即为所在花括号内的所有语句)<br>然后，shoe的值再递增1，以此重复刚才的不做，知道shoe的值不小于18为止</p></blockquote></li></ul><p><strong>图解示意:</strong></p><ul><li>执行一次循环:</li></ul><img src="/images/数据类型-4//images/while循环-1.png" width="30%" height="30%"><hr><p><strong>关于前缀递增和后缀递增</strong></p><ul><li><p>这里举一个例子:</p><blockquote><p><code>q = 2*++a;</code>，此语句为前缀形式递增，首先，a递增1，然后，2乘以a，并将结果赋给q<br><code>q =2*a++;</code>，此语句为后缀形式递增，首先，2乘以a，并将结果赋给q，然后，a递增1</p></blockquote></li><li><p>单独使用递增运算符时(如，ego++;)，使用哪种形式都没关系</p><blockquote><p>但是，当运算符和运算对象是更复杂表达式的一部分时(如上面的示例)<br>使用前缀或后缀的效果不同</p></blockquote></li></ul><hr><p><strong>递减运算符</strong></p><ul><li><p>每种形式的递增运算符都有一个递减运算符(decrement operator)与之对应</p></li><li><p>用–代替++即可:</p><blockquote><p><code>--count; // 前缀形式的递减运算符</code><br><code>count--; // 后缀形式的递减运算符</code></p></blockquote></li><li><p><code>&gt;</code>运算符表示”大于”，<code>&lt;</code>运算符表示”小于”，它们都是关系运算符(relational operator)</p></li></ul><hr><p><strong>递增运算符的优先级问题</strong></p><ul><li>递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高<blockquote><p>因此，<code>x*y++</code>表示的是<code>(x)*(y++)</code>，而不是<code>(x+y)++</code><br>不过后者无效，因为递增和递减运算符只能影响一个变量(或者更普遍地说，只能影响一个可修改的左值)<br>而组合<code>x*y</code>本身不是可修改的左值</p></blockquote></li></ul><hr><p><strong>不要自作聪明</strong></p><ul><li>如果一次用太多递增运算符，自己都会糊涂-CN-C Primer Plus-第5.3.6章节</li></ul><hr><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>术语: 表达式(expression)和语句(statement)</li><li>C 的基本程序步骤由语句组成，而大多数语句都由表达式构成</li></ul><p><strong>表达式:</strong></p><ul><li><p>表达式(expression)由运算符和运算对象组成(运算对象是运算符操作的对象)</p><blockquote><p>最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式</p></blockquote></li><li><p>运算对象可以是常量，变量或二者的组合</p><blockquote><p>一些表达式由子表达式(subexpression)组成(子表达式即较小的表达式)</p></blockquote></li><li><p>每个表达式都有一个值</p><blockquote><p>C 表达式的一个最重要的特性是，每个表达式都有一个值<br>要获得这个值，必须根据运算符优先级规定的顺序来执行操作<br>关于表达式的值的具体描述这里不做赘述，因为它是一个范围极大的纯粹性概念<br>计算机中表达式的概念与数学中的表达式相同，值即为表达式的结果</p></blockquote></li></ul><hr><p><strong>语句</strong></p><ul><li><p>语句(statement)是C程序的基本构建块</p><blockquote><p>一条语句相当于一条完整的计算机指令<br>在C中，大部分语句都以分号<code>&#39;;&#39;</code>结尾</p></blockquote></li><li><p>声明创建了名称和类型，并为其分配内存位置</p><blockquote><p>注意，声明不是表达式语句<br>也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值:<br><code>int port /* 不是表达式，没有值 */</code></p></blockquote></li><li><p>赋值表达式语句在程序中很常用: 它为变量分配一个值</p><blockquote><p>赋值表达式语句的结构是: 一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾<br>注意，在while循环中有一个赋值表达式语句<br>赋值表达式 语句是表达式语句的一个示例</p></blockquote></li><li><p>函数表达式语句会引起函数调用</p><blockquote><p>在该例中，调用printf()函数打印结果<br>while语句有3个不同的部分: 首先是关键字while，然后圆括号中是待测试的条件，最后如果测试条件为真，则执行while循环体中的语句<br>多条语句需要用花括号括起来</p></blockquote></li><li><p>图片-简单的while循环结构:</p></li></ul><img src="/images/数据类型-4/while循环-2.png" width="30%" height="30%"><ul><li>这种语句是复合语句<blockquote><p>该例的while循环中只有一条语句<br>可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句<br>while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂</p></blockquote></li></ul><hr><p><strong>关于副作用与序列点:</strong></p><ul><li>类似于while之类的迭代循环语句通常还会有副作用(side effect)和序列点(sequence point)等概念，这里不做过多赘述<blockquote><p>所谓的副作用，就是对于变量的赋值结果(此间的赋值结果由右值的表达式决定)<br>或称其为经由人工定义所得出的等式结果<br>所谓的序列点，就是程序执行的点，再该点上，所有的副作用都在进入下一步之前发生<br>C 中的语句用分号<code>&#39;;&#39;</code>来标记若干个序列点<br>其寓意就是在一个语句中，赋值运算符，递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成<br>还有一点就是，任何一个完整表达式的结束也是一个序列点</p></blockquote></li></ul><p><strong>关于完型表达式:</strong></p><ul><li>完整表达式(full expression)<blockquote><p>就是指这个表 达式不是另一个更大表达式的子表达式<br>例如，表达式语句中的表达式和while循环中的作为测试条件的表达式<br>都是完整表达式<br>序列点有助于分析后缀递增何时发生<br>千万要避免写出带有模棱两可逻辑的语句</p></blockquote></li></ul><p><strong>关于复合语句(块)</strong></p><ul><li><p>复合语句(compound statement)是用花括号括起来的一条或多条语句</p><blockquote><p>或称之为复合语句(或块)由花括号括起来的一条或多条语句组成<br>复合语句也称为块(block)<br>任何的程序都可以使用块以让while语句包含多条语句<br>在声明与描述复合语句的构成时，需要注意书写风格，其中最重要的是对于代码缩进的掌控</p></blockquote></li><li><p>图片-带有符合语句的while循环</p></li></ul><img src="/images/数据类型-4/while循环-3.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>一般函数的形式: void xxx(void)<br>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参<br>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)<br>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p><p>关于实参和形参的其它说明:</p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p>关于函数的调用:</p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-1-1"><a href="#补充内容-1-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p>一般函数的形式: void xxx(void)</p><blockquote><p>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p></blockquote></li><li><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参</p><blockquote><p>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p></blockquote></li><li><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)</p><blockquote><p>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p></blockquote></li></ul><p><strong>关于实参和形参的其它说明:</strong></p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p><strong>关于函数的调用:</strong></p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-2"><a href="#补充内容-2" class="headerlink" title="补充内容-2"></a>补充内容-2</h3><ul><li>C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符<blockquote><p>一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值<br>只需要一个 运算对象的运算符(如负号和sizeof)称为一元运算符，需要两个运算对象的运算符(如加法运算符和乘法运算符)称为二元运算符</p></blockquote></li><li>表达式由运算符和运算对象组成<blockquote><p>在C语言中，每个表达式都有一个 值，包括赋值表达式和比较表达式<br>运算符优先级规则决定了表达式中各项 的求值顺序<br>当两个运算符共享一个运算对象时，先进行优先级高的运算<br>如果运算符的优先级相等，由结合律(从左往右或从右往左)决定求值顺序</p></blockquote></li><li>大部分语句都以分号结尾<blockquote><p>最常用的语句是表达式语句</p></blockquote></li><li>用花括号括起 来的一条或多条语句构成了复合语句(或称为块)</li><li>while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句</li><li>在C语言中，许多类型转换都是自动进行的<blockquote><p>当char和short类型出现在 表达式里或作为函数的参数(函数原型除外)时，都会被升级为int类型<br>float类型在函数参数中时，会被升级为double类型<br>在K&amp;R C(不是ANSI C)下，表达式中的float也会被升级为double类型<br>当把一种类型的值赋给 另一种类型的变量时，值将被转换成与变量的类型相同<br>当把较大类型转换 成较小类型时(如，long转换成short，或 double 转换成 float)，可能会丢失数据<br>根据之前介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型</p></blockquote></li><li>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数<blockquote><p>然后，在函数调用中传入的值会被赋给这个变量<br>这样，在函数中 就可以使用该值了</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-运算符与表达式-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-3</title>
    <link href="https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3/"/>
    <id>https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3/</id>
    <published>2020-03-11T12:31:21.000Z</published>
    <updated>2020-03-11T22:52:25.056Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>数据类型-数组/字符串类型-1</strong></center><a id="more"></a><h3 id="数据类型-3"><a href="#数据类型-3" class="headerlink" title="数据类型-3"></a>数据类型-3</h3><ul><li>数据类型/派生类型/数组/字符串</li><li>字符串存储原理</li><li>数组存储原理</li></ul><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>概述:</strong></p><ul><li>字符串(character string)</li><li>本质上是一个或多个字符的序列，即为字符数据类型的数组，可表示为”xxx yyy”</li><li>双引号不是字符串的一部分，双引号只是用于告知编译器括起来的是字符串，正如单引号用于标识单个字符</li></ul><p><strong>char类型数组和null字符</strong></p><ul><li>因为 C 中没有专门用于存储字符串的变量类型，所以字符串都被存储在char类型的数组当中</li><li>数组由连续的存储单元构成，所以字符串中的字符类型都被存储在相邻的存储单元中，即每个单元存储一个字符</li></ul><p><strong>具体图示</strong></p><ul><li>数组中的字符串:</li></ul><img src="/images/字符串-1.png" width="30%" height="30%"><ul><li>这里需要注意的是图片中数组末尾的字符<code>\0</code><blockquote><p>这是空字符(null character)，C内用它来标记字符串的结束<br>空字符并非数字0，它是非打印字符，其ASCII码值是(或称其为等价于)0<br>所以C中的字符串一定以空字符结束，即意味着数组的容量必须比至少比带存储字符串中的字符数多1<br>因此，在一个有若干个存储单元的字符串中，只能存储若干字符串数量减一个字符，剩下一个字节留给空字符</p></blockquote></li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概述:</strong></p><ul><li>可以将数组看作是一行连续的多个存储单元</li><li>或称为数组是同类型数据元素的有序序列</li><li>这里用一个包含着40个存储单元(每个单元存储一个char类型的值)且已被创建(已存在)的数组来举例<blockquote><p><code>char name[40];</code><br>name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量，char用于表示每个元素的类型</p></blockquote></li></ul><p><strong>具体图解</strong></p><ul><li>声明一个变量和声明一个数组:</li></ul><img src="/images/字符串声明-1.png" width="30%" height="30%"><ul><li>字符串就是在拥有一个数组的前提下，把字符串中的字符逐个放入数组，同时还要记得在末尾加上一个<code>\0</code><blockquote><p>好在计算机可以自己去处理这些细节问题</p></blockquote></li></ul><hr><ul><li>用格式化输出标识符<code>%s</code>来格式化输出字符串类型，但scanf()函数只会读取字符串中的一个单词，而非整个句子<blockquote><p>此时需要用到其它的输入函数，如<code>fgets()</code>，以用于读取一般的字符串<br>因为本质是由基本字符类型构成的数组，所以字符串的打印顺序与所存储的内存地址也是与字符类型相同的<br>即为完全线性</p></blockquote></li></ul><hr><h3 id="字符串和字符的区别"><a href="#字符串和字符的区别" class="headerlink" title="字符串和字符的区别"></a>字符串和字符的区别</h3><ul><li>字符串常量”x”和字符常量’x’完全不同</li><li>区别之一是在于’x’是基本类型char<blockquote><p>而”x”是派生类型char 数组</p></blockquote></li><li>区别之二是”x”实际上是由两个字符组成的，即为’x’和空字符<code>\0</code></li></ul><p><strong>图片描述:</strong></p><ul><li>字符’x’和字符串”x”:</li></ul><img src="/images/字符和字符串的区别-1.png" width="30%" height="30%"><hr><h3 id="strlen-方法-函数"><a href="#strlen-方法-函数" class="headerlink" title="strlen()方法(函数)"></a>strlen()方法(函数)</h3><ul><li><p>用于输出给出字符串中的字符长度</p></li><li><p>因为1字节存储一个字符，所以给人最直观的感受就是与sizeof运算符(以字节为单位给出对象的大小)的输出相同，但事实绝非如此</p></li><li><p>使用<code>strlen()</code>方法(函数)时需要先对头文件<code>string.h</code>进行预处理<code>#include</code>，以对其进行支持</p></li><li><p>当被定义数组内有40个存储单元，但是只用了不到40个单元用于存储被输入字符串</p><blockquote><p>此时<code>strlen()</code>方法得出的结果是被存储字符串的字符长度，当为11时，即为11个<br>但数组内还需要多出来一个单元用于存储空字符，但<code>strlen()</code>方法并不会将其计入</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>strlen()函数知道在何处停止:</li></ul><img src="/images/strlen机制说明-1.png" width="30%" height="30%"><p><strong>strlen()与sizeof运算符方法的区别</strong></p><ul><li><p>假如让<code>strlen()</code>方法去存储一个常量字符串，<code>strlen()</code>方法将会只返回字符串中的字符(包括空格和标点符号)</p></li><li><p>但是<code>sizeof</code>运算符将会把字符串末尾不可见的空字符也算在内</p></li><li><p><code>sizeof</code>运算符和<code>strlen()</code>方法的格式化输出标识符是通用的，即为<code>%zd</code>转换说明</p><blockquote><p>并且<code>sizeof</code>和<code>strlen()</code>返回的实际类型通常是<code>unsigned</code>或<code>unsigned long</code></p></blockquote></li><li><p><code>sizefo</code>后加不加圆括号取决于运算对象是类型还是特定量</p><blockquote><p>对于类型需要写为类似于<code>sizeof(char)</code>的形式<br>而对于特定量，则可以写成<code>sizeof name</code>的形式<br>只不过每种形式都可以加上圆括号，可以为了增加可读性而去这么做</p></blockquote></li></ul><hr><h3 id="define"><a href="#define" class="headerlink" title="[#define]"></a>[#define]</h3><p><strong>常量和 C 预处理器</strong></p><ul><li><p>如果将全局变量当成常量，程序可能会在无意之间修改它的值</p></li><li><p>所以 C 中为此提供了C 预处理器，预处理器可以用来定义常量</p></li><li><p>基本语法与使用:</p><blockquote><p><code>#define NAME value</code><br><code>#define XXX 0.001</code><br>此时程序中的所有XXX都会被替换称0.001，这一过程被称之为编译时替换(compile-time substitution)<br>通常在运行程序时，程序中所有的替换就均已完成，这样定义常量可将其称之为明示常量(manifest constant)<br>因为预处理器处理的替换机制，所以末尾不用加分号</p></blockquote></li><li><p>在 C 中还有一个约定成俗的规定，常量的命名最好是大写，以便区分程序中其它的变量</p><blockquote><p>另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量(如，<code>c_level</code>或<code>k_line</code>)</p></blockquote></li><li><p>符号常量的命名规则与变量相同，即可以使用大小写的字母，数字，下划线和首位字符不能为数字</p></li><li><p><code>#define</code>指令还可用于定义字符和字符串常量，前者用单引号，后者用双引号</p><blockquote><p>即为<code>#define BEEP &#39;\a&#39;</code>或<code>#define TEE &#39;T&#39;</code><br>需要注意的就是符号常量后面的内容用来代替符号常量</p></blockquote></li></ul><hr><p><strong>const限定符</strong></p><ul><li><p>const关键字于C90标准添加，用于限定一个变量为只读</p></li><li><p>作用与<code>#define</code>相同，并且比其更灵活</p></li><li><p>基本语法:</p><blockquote><p><code>const int XXX = 10</code><br>此时XXX在程序中不可更改，其值为10</p></blockquote></li></ul><hr><p><strong>明示常量:</strong></p><h3 id="limits-h"><a href="#limits-h" class="headerlink" title="limits.h"></a>limits.h</h3><ul><li><p>C内的每个头文件都定义了一系列供实现使用的明示常量</p><blockquote><p>比如C的头文件<code>limits.h</code>和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息</p></blockquote></li><li><p>而<code>limits.h</code>头文件包含了以下类似的代码</p><blockquote><p><code>#define INT_MAX +32767</code><br><code>#define INT_MIN -32768</code><br>这些明示常量代表<code>int类型</code>可表示的最大值和最小值<br>如果系统使用32位的int，该头文件会为这些明示常量提供不同的值</p></blockquote></li><li><p>如果在程序中包含<code>limits.h</code>头文件，就可编写下面的代码:</p><blockquote><p><code>printf(&quot;Maximum int value on this system = %d\n&quot;, INT_MAX);</code><br>如果系统使用4字节的int，<code>limits.h</code>头文件会提供符合4字节int的<code>INT_MAX和INT_MIN</code><br>以下表图片内列出了<code>limits.h</code>中能找到的一些明示常量<br>文章内会对每个头文件的内部构成与使用方法进行刨析<br>每种类型的头文件在系统内的C标准库内都有明确的说明</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li><code>limits.h</code>中的一些明示常量</li></ul><img src="/images/C-头文件/C-limits.h头文件-1.png" width="30%" height="30%"><hr><h3 id="float-h"><a href="#float-h" class="headerlink" title="float.h"></a>float.h</h3><ul><li>类似地，<code>float.h</code>头文件中也定义一些明示常量<blockquote><p>如<code>FLT_DIG和 DBL_DIG</code>，分别表示<code>float类型</code>和<code>double类型</code>的有效数字位数<br>以下表图片内列出了<code>float.h</code>中的一些明示常量(可以使用文本编辑器打开并查看系统使用的float.h头文件)<br>表中所列都与float类型相关<br>把明示常量名中的FLT分别替换成DBL和LDBL<br>即可分别表示double和long double类型对应的明示常量(表中假设系统使用2的幂来表示浮点数)</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>float.h中的一些明示常量:</li></ul><img src="/images/C-头文件/C-float.h头文件-1.png" width="30%" height="30%"><ul><li>编译器要完全支持C99标准才能识别<code>LLONG_MIN</code>标识符</li></ul><hr><h3 id="printf-方法与scanf-方法"><a href="#printf-方法与scanf-方法" class="headerlink" title="printf()方法与scanf()方法"></a>printf()方法与scanf()方法</h3><p><strong>概述:</strong></p><ul><li><code>printf()</code>函数和<code>scanf()</code>函数能让用户可以与程序实现交互<blockquote><p>它们是基本/标准的输入/输出函数，或简称为I/O函数<br>其除了I/O功能，还有很多其它的功能<br>因为考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()，尽管如此，各版本之间偶尔有一些差异<br>而C90 和C99 标准规定了这些函数的标准版本<br>虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同<br>两个函数都使用格式字符串和参数列表</p></blockquote></li></ul><hr><p><strong>printf()</strong></p><ul><li><p>请求<code>printf()</code>函数打印数据的指令要与待打印数据的类型相匹配</p><blockquote><p>例如， 打印整数时使用<code>%d</code>，打印字符时使用<code>%c</code><br>这些符号被称为转换说明(conversion specification)，即为格式化输出标识符<br>它们指定了如何把数据转换成可显示的形式。</p></blockquote></li><li><p>以下列表图片为ANSI C标准为<code>printf()</code>提供的转换说明与搁置相对应的输出类型</p></li><li><p>转换说明及其打印的输出结果:</p></li></ul><img src="/images/C-标准库/C-printf函数-1.png" width="30%" height="30%"><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li>格式字符串包含两种形式不同的信息:<blockquote><p>实际要打印的字符<br>与转换说明</p></blockquote></li></ul><p><strong>图片说明:</strong></p><ul><li>printf()的参数</li></ul><img src="/images/printf格式-1.png" width="20%" height="20%"><ul><li>剖析格式字符串图片:</li></ul><img src="/images/字符串格式-1.png" width="20%" height="20%"><ul><li>格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果</li></ul><hr><p><strong>printf()的转换说明修饰符</strong></p><ul><li>在%和转换字符之间插入修饰符可修饰基本的转换说明</li><li>转换说明修饰符类型的可移植性需要特别注意</li><li>整数类型和浮点数类型使用不同类型的转换类型</li><li>关于转换说明修饰符的列表这里不做过多阐述</li><li>可参考[C Primer Plus 第6版-中文版]-第201页</li></ul><hr><p><strong>转换说明的意义:</strong></p><ul><li><p>转换说明把以二进制格式储存在计算机中的值转换成一系列字符(字符串)以便于显示</p><blockquote><p>例如，数字76在计算机内部的存储格式是二进制数01001100<br><code>%d</code>转换说明将其转换成字符7和6，并显示为76<br><code>%x</code>转换说明把相同的值(01001100)转换成十六进制记数法4c<br><code>%c</code>转换说明把01001100转换成字符L</p></blockquote></li><li><p>转换(conversion)可能会误导读者认为原始值被转替换成转换后的值</p><blockquote><p>实际上，转换说明是翻译说明<br><code>%d</code>的意思是”把给定的值翻译成十进制整数文本并打印出来”</p></blockquote></li></ul><hr><h3 id="scanf-方法简述"><a href="#scanf-方法简述" class="headerlink" title="scanf()方法简述"></a>scanf()方法简述</h3><ul><li><p>输入函数-scanf()</p><blockquote><p>scanf()是最通用的一个输入函数，因为其可以读取不同格式的数据</p></blockquote></li><li><p>如果要将其储 存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的</p></li><li><p>scanf()把输入的字符串转换成整数，浮点数，字符或字符串</p><blockquote><p>而printf()正好与它相反，把整数，浮点数，字符和字符串转换成显示在屏幕上的文本</p></blockquote></li><li><p>scanf()和printf()类似，也使用格式字符串和参数列表</p><blockquote><p>scanf()中的格式 字符串表明字符输入流的目标数据类型<br>两个函数主要的区别在参数列表中<br>printf()函数使用变量，常量和表达式，而scanf()函数使用指向变量的指针<br>关于指针的两条最简单的规则:<br>如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;<br>如果用scanf()把字符串读入字符数组中，不要使用&amp;</p></blockquote></li><li><p>scanf()函数使用空白(换行符，制表符和空格)把输入分成多个字段</p><blockquote><p>在依次把转换说明和字段匹配时跳过空白</p></blockquote></li><li><p>scanf()函数所用的转换说明与printf()函数几乎相同</p><blockquote><p>主要的区别是，对 于float类型和double类型<br>printf()都使用<code>%f</code>,<code>%e</code>,<code>%E</code>,<code>%g</code>和<code>%G</code>转换说明<br>而scanf()只把它们用于float类型，对于double类型时要使用l修饰符</p></blockquote></li><li><p>C99-ANSI C中scanf()的转换说明这里不做过多赘述，可参考书籍</p></li><li><p>scanf()进入输入的原理与对应的物理模式这里不做阐述，将来会对其进行补充</p><blockquote><p>转换符和I/O函数不需要学的特别细，具体的使用和记忆可以在实践中执行</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-数组/字符串类型-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-2</title>
    <link href="https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/"/>
    <id>https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/</id>
    <published>2020-03-11T05:15:27.000Z</published>
    <updated>2020-03-11T12:36:44.806Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>存储原理-算术类型-1</strong></center><a id="more"></a><h2 id="基本数据类型存储原理"><a href="#基本数据类型存储原理" class="headerlink" title="基本数据类型存储原理"></a>基本数据类型存储原理</h2><ul><li>数据类型系统-基本类型</li><li>算术类型，其包含了整数类型与浮点类型</li><li>这里的数值大小以 C 的 C11 标准为例<blockquote><p>C 标准对基本数据类型只规定了允许的最小大小</p></blockquote></li></ul><hr><ul><li>常用基本数据类型占用空间(64位机器为例)</li></ul><ol><li>整数类型/char: 1个字节</li><li>整数类型/int: 4个字节</li><li>浮点类型/float: 4个字节</li><li>浮点类型/double: 8个字节</li></ol><ul><li>以 ISO C 标准为例<blockquote><p>此规定规定int的取值范围最小为<code>-32768～32767</code></p></blockquote></li></ul><hr><h2 id="整数存储原理"><a href="#整数存储原理" class="headerlink" title="整数存储原理"></a>整数存储原理</h2><ul><li>在计算机内的整数与数学一样，即为没有小数部分的实数</li><li>计算机以二进制数字的模式来存储整数</li><li>存储的位置即为变量标识符所对应的内存地址，与其指令集所指的CPU寄存器</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>同时还可将其称之为数据类型系统的基本类型部分</li><li>被归纳于算术类型，包括了整数类型与浮点类型</li><li>这里以C为例</li><li>C语言中的整数类型可表示不 同的取值范围和正负值，一般情况使用int类型即可，但是为满足特定任务和 机器的要求，还可以选择其他类型</li><li>int类型是有符号整型，即int类型的值必须是整数，可以是正整数，负整数或零</li><li>一般而言，储存一个int要占用一个 机器字长</li><li>声明之后便为被声明的若干个int大小的变量赋予名称并分配内存空间</li><li>可以赋值或初始化变量(initialize)</li><li>简而言之，声明为变量创建和标记存储空间，并为其指定初始值</li><li>C语言把大多数整型常量视为int类型，但是非 常大的整数除外</li><li>并且int类型拥有常量概念</li></ul><p><strong>声明执行逻辑图示:</strong></p><ul><li>定义并初始化变量:</li></ul><img src="/images/整数类型原理图片/数据类型声明-1.png" width="30%" height="30%"><p><strong>举例说明:</strong></p><ul><li>例如7则以对应的二进制111来存储<blockquote><p>因此，要在8位字节中储存 该数字，需要把前5位都设置成0，后3位设置成1</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>使用二进制编码储存整数7</li></ul><img src="/images/整数类型原理图片/整数类型-1.png" width="30%" height="30%"><hr><h3 id="关于整数值的范围"><a href="#关于整数值的范围" class="headerlink" title="关于整数值的范围"></a>关于整数值的范围</h3><p><strong>整数类型</strong></p><ul><li>下表列出了关于标准整数类型的存储大小和值范围的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr><tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr></tbody></table><ul><li>同时还可以使用sizeof运算符，即表达式sizeof(type)，以获取某个类型或某个变量对象或存储类型在特定硬件平台的准确存储字节大小</li></ul><p><strong>图解说明</strong></p><ul><li>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主<blockquote><p>以下列出了32位系统与64位系统的存储大小的差别(windows 相同):</p></blockquote></li></ul><img src="/images/整数类型原理图片/C-32-64.png" width="30%" height="30%"><hr><h2 id="浮点类型存储原理"><a href="#浮点类型存储原理" class="headerlink" title="浮点类型存储原理"></a>浮点类型存储原理</h2><ul><li><p>在计算机中，浮点数与数学中实数的概念差不多</p></li><li><p>比如<code>2.75</code>,<code>3.16E7</code>,<code>7.00</code>和<code>2e-8</code>都是浮点数，即在一个值后面加上一个小数点，该值就成为一个浮点值</p></li><li><p>所以7是整数，<code>7.00</code>是浮点数</p></li><li><p>e记数法简述: <code>3.16E7</code>表示<code>3.16×10^7</code>，其中E的作用就是10倍原数的对应指数级单位</p></li><li><p>浮点数和整数的储存方案不同</p></li><li><p>计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分</p></li><li><p>在十进制下，可以把7.0写成 0.7E1，但这里，0.7是小数部分，1是指数部分</p></li><li><p>当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂</p></li><li><p>整数没有小数部分，浮点数有小数部分</p></li><li><p>且浮点数可以表示的范围比整数大</p></li><li><p>对于一些算术运算(如，两个很大的数相减)，浮点数损失的精度更多</p></li></ul><p><strong>图示说明:</strong></p><ul><li>一个储存浮点数的例子，以浮点格式(十进制)储存π的值</li></ul><img src="/images/整数类型原理图片/浮点数类型.png" width="30%" height="30%"><ul><li>因为在任何区间内(如，1.0 到 2.0 之间)都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值</li><li>浮点数通常只是实际值的近似值</li><li>例如，7.0可能被储存为浮点值6.99999，稍后讨论精度</li><li>在过去，浮点运算比整数运算慢</li><li>不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距</li></ul><hr><h3 id="关于浮点值的范围"><a href="#关于浮点值的范围" class="headerlink" title="关于浮点值的范围"></a>关于浮点值的范围</h3><p><strong>浮点类型</strong></p><ul><li>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4 字节</td><td align="left">1.2E-38 到 3.4E+38</td><td align="left">6 位小数</td></tr><tr><td align="left">double</td><td align="left">8 字节</td><td align="left">2.3E-308 到 1.7E+308</td><td align="left">15 位小数</td></tr><tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">3.4E-4932 到 1.1E+4932</td><td align="left">19 位小数</td></tr></tbody></table><ul><li>头文件<code>float.h</code>定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节</li></ul><hr><h2 id="C-数据类型转换"><a href="#C-数据类型转换" class="headerlink" title="C 数据类型转换"></a>C 数据类型转换</h2><ul><li>C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型</li><li>在 C 语言中也可以对数据类型进行强制转换</li></ul><p><strong>自动转换规则:</strong></p><ol><li>浮点数赋给整型，该浮点数小数被舍去；</li><li>整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；</li></ol><ul><li>强制类型转换形式: [(类型说明符) (表达式)]</li></ul><hr><h3 id="关于不同进制的说明"><a href="#关于不同进制的说明" class="headerlink" title="关于不同进制的说明:"></a>关于不同进制的说明:</h3><ul><li><p>2进制，8进制和16进制</p></li><li><p>以0为前缀用于表示8进制</p><blockquote><p>比如十进制转换为8进制则为020</p></blockquote></li><li><p>以0x或0X为前缀用于表示16进制</p><blockquote><p>比如十进制数转为16进制则为0x10或0X10</p></blockquote></li><li><p>使用不同的进制是为了方便，其可以完全保证不会影响被存储的方式</p></li><li><p>可以使用标识符<code>%d</code>，<code>%o/%x</code>来分别显示(格式化输出)八进制与十六进制数字</p></li><li><p>而使用标识符<code>%#o</code>，<code>%#x</code>，<code>%#X</code>可以显示各进制的前缀(0，0x和0X)，也就是分别在转换(格式化输出)的说明中假如警号(#)</p></li></ul><hr><ul><li>整数类型还包括char-字符类型与其它的表示符类型，比如像long，short等等，这里先不做过多赘述</li><li>字符类型还包括了字符与字符串(String)的概念</li></ul><hr><p><strong>图片资料补充:</strong></p><ul><li>转义序列(转义标识符)图示:</li></ul><img src="/images/整数类型原理图片/转义标识符-1.png" width="30%" height="30%"><ul><li>int系列类型的常量写法示例:</li></ul><img src="/images/整数类型原理图片/int中的常量写法.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><ul><li><p><code>scanf()</code>函数中的&amp;标识符用于把输入的字符赋值给所对应变量</p><blockquote><p>相当于创建了一个指向变量其它数据对象位置的指针</p></blockquote></li><li><p>而格式化输出标识符(转换符)</p><blockquote><p>类似于<code>%c</code>，<code>%o</code>，<code>%d</code>，<code>%f</code>之类的<br>作用是决定数据的显示方式，而不是存储方式</p></blockquote></li><li><p>数据显示和数据存储的示例图片:</p></li></ul><img src="/images/格式化输出标识符-1.png" width="40%" height="40%"><hr><ul><li>编译器对char的实现也有不同，有的将其实现为有符号类型，即代表char可表示的范围是-<code>128~127</code></li><li>而有些C编译器把char实现为无符号类型，即为表示-<code>0~255</code></li><li>至于想要准确的确定正在使用的编译器是如何实现<code>char类型</code>的，可以去查询相应的编译器手册与<code>limits.sh</code>头文件</li><li>但是根据C90标准，C内允许在char关键字钱使用<code>signed</code>与<code>unsigned</code>标识符，以此来消除编译器对char默认类型的影响</li><li><code>signed char</code>表示有符号类型，而<code>unsigned char</code>表示无符号类型</li></ul><hr><h3 id="类型归纳列表"><a href="#类型归纳列表" class="headerlink" title="类型归纳列表"></a>类型归纳列表</h3><p><strong>基本数据类型</strong></p><ul><li>关键字:</li><li>基本数据类型由11个关键字组成: <code>int</code>、<code>long</code>、<code>short</code>、<code>unsigned</code>、<code>char</code>、 <code>float</code>、<code>double</code>、<code>signed</code>、<code>_Bool</code>、<code>_Complex</code>和<code>_Imaginary</code></li></ul><p><strong>有符号整型:</strong></p><blockquote><p>有符号整型可用于表示正整数和负整数</p></blockquote><ul><li><code>int</code>——系统给定的基本整数类型<blockquote><p>C语言规定<code>int类型</code>不小于16位</p></blockquote></li><li><code>short</code>或<code>short int</code>——最大的<code>short类型</code>整数小于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>short类型</code>至少占16位</p></blockquote></li><li><code>long</code>或<code>long int</code>——该类型可表示的整数大于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>long类型</code>至少占32位</p></blockquote></li><li><code>long long</code>或<code>long long int</code>——该类型可表示的整数大于或等于最大的<code>long类型</code>整数<blockquote><p>Long long类型至少占64位</p></blockquote></li></ul><hr><ul><li>一般而言，<code>long类型</code>占用的内存比<code>short类型</code>大<blockquote><p>int类型的宽度要么和<code>long类型</code>相同，要么和<code>short类型</code>相同<br>例如，旧DOS系统的PC提供16位的short和int，以及32位的long<br>Windows 95系统提供16位的short以及32位的int 和long</p></blockquote></li></ul><hr><p><strong>无符号整型：</strong></p><ul><li><p>无符号整型只能用于表示零和正整数</p><blockquote><p>因此无符号整型可表示的正整数 比有符号整型的大</p></blockquote></li><li><p>在整型类型前加上关键字<code>unsigned</code>表明该类型是无符号整型: <code>unsignedint</code>、<code>unsigned long</code>、<code>unsigned short</code></p><blockquote><p>单独的<code>unsigned</code>相当于<code>unsignedint</code></p></blockquote></li><li><p>字符类型:</p></li><li><p>可打印出来的符号(如A，&amp;和+)都是字符</p><blockquote><p>根据定义，<code>char类型</code>表示 一个字符要占用<code>1字节</code>内存<br>出于历史原因，<code>1字节</code>通常是8位，但是如果要表示基本字符集，也可以是<code>16位</code>或更大</p></blockquote></li><li><p>char——字符类型的关键字<br>》 有些编译器使用有符号的char，而有些则使用无符号的char<br>》 在需要时，可在char前面加上关键字<code>signed</code>或<code>unsigned</code>来指明具体使用哪一种类型</p></li><li><p>布尔类型:</p></li><li><p>布尔值表示<code>true</code>和<code>false</code></p><blockquote><p>C语言用1表示<code>true</code>，0表示<code>false</code></p></blockquote></li><li><p><code>_Bool</code>——布尔类型的关键字</p><blockquote><p>布尔类型是无符号<code>int类型</code>，所占用的空间只要能储存0或1即可</p></blockquote></li><li><p>实浮点类型:</p></li><li><p>实浮点类型可表示正浮点数和负浮点数</p></li><li><p>float——系统的基本浮点类型，可精确表示至少6位有效数字</p></li><li><p>double——储存浮点数的范围(可能)更大，能表示比<code>float类型</code>更多的有效数字(至少 10位，通常会更多)和更大的指数</p></li><li><p>long long——储存浮点数的范围(可能)比double更大，能表示比double更多的有效数字和更大的指数</p></li><li><p>复数和虚数浮点数:</p></li><li><p>虚数类型是可选的类型</p></li><li><p>复数的实部和虚部类型都基于实浮点类型来构成:</p><blockquote><p><code>float _Complex</code><br><code>double _Complex</code><br><code>long double _Complex</code><br><code>float _Imaginary</code><br><code>double _Imaginary</code><br><code>long long _Imaginary</code></p></blockquote></li></ul><hr><h3 id="打印出类型大小"><a href="#打印出类型大小" class="headerlink" title="打印出类型大小"></a>打印出类型大小</h3><ul><li><p><code>sizeof()</code>函数的使用</p></li><li><p>sizeof是 C 的内置运算符，用于以字节为单位给定指定的类型大小</p><blockquote><p>C99和C11提供<code>%zd</code>转换说明匹配sizeof的返回类型<br>而一些不支持C99和C11的编译器可以用<code>%u</code>或<code>%lu</code>来代替<code>%zd</code></p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type int has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type char has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type int has a size of 4 bytes.</span><br><span class="line">Type char has a size of 1 bytes.</span><br><span class="line">Type long has a size of 8 bytes.</span><br><span class="line">Type long long has a size of 8 bytes.</span><br><span class="line">Type double has a size of 8 bytes.</span><br><span class="line">Type long double has a size of 16 bytes.</span><br></pre></td></tr></table></figure></li><li><p>该程序列出了6种类型的大小，也可以把程序中类型换成的其他类型</p><blockquote><p>注意，因为C语言定义了<code>char类型</code>是1字节，所以<code>char类型</code>的大 小一定是1字节<br>而在<code>char类型</code>为16位，<code>double类型</code>为<code>64位</code>的系统中，<code>sizeof</code>给出的<code>double</code>是4字节</p></blockquote></li><li><p>在<code>limits.h</code>和<code>float.h</code>头文件中有类型限制的相关信息</p><blockquote><p>顺带一提，注意该程序最后几行<code>printf()</code>语句都被分为两行<br>只要不在引号内部或一个单词中间断行，就可以这样写</p></blockquote></li></ul><hr><h3 id="printf-方法与scanf-方法补充内容"><a href="#printf-方法与scanf-方法补充内容" class="headerlink" title="printf()方法与scanf()方法补充内容"></a>printf()方法与scanf()方法补充内容</h3><ul><li><p><code>printf()</code>和<code>scanf()</code>函数用第1个参数表明后续有多少个参数</p><blockquote><p>即第1个字 符串中的转换说明与后面的参数一一对应<br><code>printf(&quot;A %d B %f&quot;, xxx, yyy)</code><br>即A对应于xxx，B对应于yyy</p></blockquote></li><li><p>程序员要负责确保转换说明的数量，类型与后面参数的数量，类型相匹配</p><blockquote><p>现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确<br>但是，该机制对<code>printf()</code>和<code>scanf()</code>不起作用，因为这两个函数的参数个数可变</p></blockquote></li></ul><hr><ul><li><p>C语言提供了大量的数值类型，目的是为程序员提供方便</p><blockquote><p>那以整数类型为例，C认为一种整型不够，提供了有符号，无符号，以及大小不同的整型，以满足不同程序的需求</p></blockquote></li><li><p>计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别</p><blockquote><p>即使两个32位存储单元储存的位组合完全相同，但是一个解释为<code>float类型</code>，另一个解释为<code>long类型</code><br>这两个相同的位组合表示的值也完全不同。<br>例如，在PC中，假设一个位组合表示<code>float类型</code>的数256.0<br>如果将其解释为<code>long类型</code>，得到的值是113246208<br>C语言允许编写混合数据类型的表达式， 但是会进行自动类型转换<br>以便在实际运算时统一使用一种类型</p></blockquote></li><li><p>计算机在内存中用数值编码来表示字符</p><blockquote><p>美国最常用的是<code>ASCII码</code>，除此之外C也支持其他编码<br>字符常量是计算机系统使用的数值编码的符号表示<br>它表示为单引号括起来的字符，如<code>&#39;A&#39;</code></p></blockquote></li><li><p>需要完全理解通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型</p></li><li><p>浮点数可以写成固定的小数点的形式或指数形式，C99和C11提供了第三章的表示方法，即用十六进制数和二的幂来表示(如，<code>0xa.1fp10</code>)</p></li><li><p>C语言中用单引号<code>&#39; &#39;</code>来表示字符常量，还有转义序列的概念(<code>&#39;\n&#39;</code>)，另外，还可以在八进制和十六进制数前面加上一个反斜杠(如: ‘\007’)，用以表示ASCII码中的一个字符</p></li><li><p>还可可移植数据类型等概念</p><blockquote><p>C99新增了两个头文件<code>stdint.h</code>和<code>inttypes.h</code></p></blockquote></li><li><p><code>printf()</code>函数根据转换说明打印各种类型的值</p><blockquote><p>转换说明最简单的形式由一个百分号(%)和一个转换字符组成，如<code>%d</code>或<code>%f</code></p></blockquote></li></ul><hr><p><strong>转义序列(格式化输出标识符)-URL参考列表:</strong></p><ul><li><p>CN-CSDN-C语言中字符串的格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/hudashi/article/details/7080078</code></p></blockquote></li><li><p>CN-CSDN-C字符串格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/mcxfate/p/10618114.html</code></p></blockquote></li><li><p>CN-CSDN-C 和 C++ 字符串格式化<a href="https://blog.csdn.net/freeking101/article/details/78935559" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/freeking101/article/details/78935559</code></p></blockquote></li><li><p>c/c++的字符串格式化汇总<a href="https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;存储原理-算术类型-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-10</title>
    <link href="https://unit-serow.github.io/2020/03/10/%E9%9A%8F%E7%AC%94-2020-03-10/"/>
    <id>https://unit-serow.github.io/2020/03/10/%E9%9A%8F%E7%AC%94-2020-03-10/</id>
    <published>2020-03-10T15:28:28.000Z</published>
    <updated>2020-03-14T03:57:21.061Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b12bb328f702d3cf049d81fa18707b13d3fceef25ae601fff934fc8955f39175">0267ec72f19b8c198697a4f72870a3a8584f376137a9d1d86e1a9cfa88aadb7d7103cc4d6088216be72b5f0194670dc24843dea27e475e25a33b67d7a3df15252572b48ab532049ed9597d413d52e377d130a9323cbbe4136a94f6a56a87435f1d603bf7b6690affea7dc40b80c322c9945b16800c7df234074f92e8898c8fa229c1a0705a6375ac8569a7de28f5aad2076b10e22932ef174b905f7b83295c4470ae3972cf7a542dafc90bc3734e6739875b5ecdada1ef35980e104de151e6673b03ed3c6df976d50835c4ccc7c46759905dcaec5261414c9201b7ec68d08f5d53a316673bd3ea8ad5ca3833b8aadef86f6437252cd88507cd5d5b9d129c3dc673148335fa8ca308f1de9f2268aa79e203408f05b2ada6aa17a83ceb64f7c59b57e3505be8103ade54a83967cb0f6d0a124ece32ea0b09291c3dfa2bf8d3ba072fe13f016120f91f919cae2db8a2cf03138feacf147c040b88916603967d38c301b356c3e18ba85f24dc93e8e9490f223574c58756eab3016f193d077e7ab8f2d557f4eb83e1c2d397b480c5f92f767e13085faf002832757cd539ef39600ea9106ef99eac423a971e7bb7362af7d0603877cd0999ec4f8ce67ae05510e08eb2f0c9d40a3bedcbb8ce420da519d5f9d563be7c3c9290810a4d90b391f2adf10e77a9284f1a85a09ad926cc089b6497f88fcf62f850240396af7bb11c58604266a315413de2520d1d23519b578e3f9b8e7dfa922657fd57cbbf821409cf0a0b07c07b8a6bf8cef9c0c62b810f998c110bd440de633f6b3d849c0f8c358d0a8a0de0e5bdefd338ff9ecbfbc8ba466dc42ced11575c6ebd2eb4c69c1e0e4a4f4ae07f3f4fc486f5550fa66f45b6d6fe1f3a7eb26cdeb2abc14bf942912fae7e5abb00f713392bff7263e72a12b8f4c062075a5709d1f1594c9fad4e7844805f0bd3b99a65eb52d3363ec0e667807040bd6890d554977fb49dd3c77a97b7cbd99dd627c5747a2de72b2cb21aa5494194882acd8dfc9237b9a9b920897054d5d3b8e78cdf9d1dd8db63e556e494c11d7165aee33e075d79929f3d207730ecf73c2f042db42b28a30afb04f6cfe27b59ee4643584d38cb80d3db25bfc0389a8de7a6909cc4356a9187b44c3c1366c08838f6bfd5e4a800c0ab5ebf175a2a69de7643f61bd6985fbfa524d33d5f63f8568fde7d1f96311d792086589672e5c635a4d08cabea01164e652325fced79c1a38b1714f664e0f7651bd7beb8a84625daf89dd6f261800005ac194c14a01f00863961a36fb95b9ad37aba012e09e4c5244666996e0998806cfb3e64155717fa23cfaf57658f7fbcb4d2ea4c997d03b8742a20bfda5bad8fa5df5fcac9b01a4393fa218e9233e167085122f194df5249760e1fcf241c9d705ed7362c8cc11212a3886a9c18dbb0cdaf9600e6eb6ddfb4fdf7c55bbe6f103af673125729f2ae327785e2354b6c1bc7e215c8b6148154efd28247d03e192c71c3ae61fe27bee47ea6d272b9e8e90e272f36f46da674386800c8e1dcdfc85e3256bc2f8624c91f4120de2edf99804d44bf2a1c9c82147ad1e1eed989a4a0ddcfb83ccf6726dea08a761c1f46fabfc805f40bb52bc493022ed48666505ec5242c38e31a8ed0107280376fc4253abaa10ee87bddcd505b86e4b0514b67b753eab385bee7bd53833ca0853a938aa023ee16a790063d2656cba4b288112fcc6afbf94143f683e99a4f7314cbd7e12e4cb236a50066205b54a94f303245d322f8b6e8b6ea46834d77125ada24feba56fd4d9ecc62c56b0f39d39b81203ea13d4f7f5e01b469777582950ffb4885dce83b43cc20d976ccefe31b9d74f00a2f3991941b1ae71e16421f022ec2ba587fa7956c620596b39fd728a343864bec7c615b2b78607bddf4aec32cf2c4dbb17c7208cc32de2076bb2f41067f829885cb53c7d6e0e876b9930a1e3180960e30bb06c45cb78e9933b1d3f546e64c3b289cbc9a99fd3be3965a5ab4b98854e0f469af234e324e28198f8468b87cf03eda24b728c6b8bb7c7eace2e25ef3590f64b52a404bd70ffc9a4d0cb9c1adf6b6d83bda98fa0d46e9db6e4498d07d617a5403c5c3d6e49f118ce46b7d6e276fbef8a0238da0f44208ef827a405fe5d10d5b510b20cd5fcfb493b71369816220470ded2d6d2f1800036d0929202f2c3917107f668ef9919765cd4c757547343f18f3742506bd1490598e0ebb7bdcfb70faeef2da41e38970500b8988d8a1ce9409262deedefed6172a262146c761a4cce9c5d345ab985edeb4e863c4905eab0d202504313509b2dd808ea30b3676006ad559a8040c91e3fdf5543d54f4b524914b8ee6d7e899baaa8ca3351e35f8b6513a5ce3572b9fa87d6d798b03b323fd53576500fd4c92fad90b76267f72317d411c0e4d0cb0817937cef8b490d59b2d63fff35713c8feffb26d655d405827b31825db7e35ce500af229244e3aa3b564b86b20e58d75939606532eb18a1cbf86ea524cbdcd3e6063dfda189f505a43ae0b90449f11d43db2fa6da141fb68188debdd4e0bf0b5436f468ed31c521f6b2eb59c19dbe0d2009bcb25a7932afb5e87ff58424fe4bf8e29c2b270a86418b64b781f158305208c3b2dbc2ef21a8608dc3016d8e9e12939fbc70c8d250a2d11e42282a109afe287c2f2dbe02ba14f832ca1ffd676403b5200aa5e561686f9ad4fbafbe8447a281e187153c96fccb5d58588f3b6e24c357aa1daed50b741ba782800b4b4c03d72bf8a579fbbe6f0a5cf706f14ace4254b95195a67cf025f024b69fa1efe91854d02507e8f28a99e02f1a5c5d79c7aa2d5a9040c714d69dd665dd128c26ac8d26e46a0ef39c4232f8118e6afe057030805f30c652ff2ce94844462df5f2997e8d00e471b5ae766b916c610ee49dc9576835abbe62ef37239ddab6355a162b7d9bea45e92804c3d9a37a5fa62470e795bc28132d99f68af8992527fa058d643e30129ea1cd854ef177c2b2c70cf8fdc23ba79c68cb108b62ecc0be7a94a22f03f97c9032ebc995c594ea314735fe2e6f589da13b8d5581b28ab8e139303d19b4c3ed79d02772c6167d32e206684a683593fb2c4319bb4f402589744a77b2012603a3f2b6d68b7539657a56080aa09f0e4112e5079bf9013520be2fc3179b2e7eb354e793fb72ede6d0915da1e0cf88f27a99cb8495cc4286f78d4f42ccc6cceecc645120c753fc6748c9a161a9827d166746788af836d660300db5d0c3f4da250b62cc151e13e81554f64a474f39e7375073986b87411d278c9c72da9b01341ac872c9bd983bf9e0fd4978bed1452a08f9c477d3a3d0841583119e0adb569e613e718d1c75c6567f440f351f08f662174c3ae09ef4522e85cb896cd9d0c58b236a18ef45e06dae033dae125e15bd1efaf74f288d906fa49503e47b8d1e5ee1ae736e3f1e33d14acaf9b3805d45387578154714fe2c9510816b8a24f51568d70ecae9fce7c98ec8ea075eea9a438fc9243915bd3fba3eb183fe4fa34090ab29a2139e41c4e71524bda9398dc2273596e003c7c4b9677c880356c53427c763244059934dd5a40bde1804f3c9a5947bad6e72d480d40049d2c18b524eade32687cfa5fc89840f11ba84bc73ee375b0db136a5dd51ca23e15b7ebe6a152f5ad8ee7810c1a6402d54430ee5ee4e1b7ccba3b0f681e5f6a03b582c4a847af869550c842264341b4c45f5261ae9dea297b0bbfff1ea72926a52b8c08f74f3d861b033824d25d5e9388794c5ebdefbbacf62e2e029c873a955f899618332c166d23f8b8439b03882704262e46cedde5f7a57f2835fa98997015142c28cd8d3b606f49f54dacf14bf439951b8f12535fbe81e185050c17a529521628b2c1f942e83f2eae32185e049782a9e05d5c995c19f2b2980a6ac661bddeeb5fd0e9cc453dc1cefb887a675af74249bad4e074ea8d573b003211292ceb3eb31a2954f3962b529c5c0c4f7f17c26f75a2912b5ef08ee65ad05cc37b1bfec221a46f31547d46acfe2d92f444286a1d08effde391fd4d6a0bc04b6745a51a54002e9587116cc9f49fcae45d392dab856e1bedbb2674daec649506c3a73e8f5ecfd0aabd381642141df8845be97633e847b80df6bea0d4c11cc614abfff920cf04607dd9f90bcdcc9113dd5784365ebd2b543329f68eed67b9e2dbdc3a90815db3d143369e218d804e06c4fc91176d382169cfea1079f28442ae36e13933e1fcede020c78e3c2b94ce3188226c9f47c99f3bbff24785ed0d2a8a71f9f0a11c3e61071ad07914caae48c707ec5a6b94a9ab2c7567b7585fce61167a859c07264779033983146dd18543874a8b53fd11bebf87dde07aaf6a87e896d92059fbacea15a68a958520f3c946db7372666c67a072338d24f50533a1d32008c2c97b410276f44704a5293921c5701d8e0e0d5b7570bb40ff0c2def524afaf625c43ba438fe3e68464bc5dda7722490e82350c2afe584ce4cbf879badee0f8dc479660ff604e90a24530f15643c45a65c6b8bf0f0216ec8ccb417a4495170160811050de46df4fd09c854189c18113d528cee9ca0ed6d65e515c6ec261802e6a21870ac4221300cec1712d31f4367fe622cd68be91a4310088b9532b86b710bad8bfdd058afe89a4b6d225300133e67590bf893b39b59f8ab1d42e398af1c3bc051a50f31ff698ac9628b09eac092d30019ccea02cdacf0c69bee9399452edc3be0f7096ae7089d7a4cfa9b1e89ad459f47c00ecd585863f5528273262d203fad95d4f7a0eb9002546ed0ee30057448c01fd4e3673f49bbc0d31b47f91345d84429c177568739b1af170ae0325740a5abd4801f93b024070076584390c74a92ac0ad9dd4b3426a9533e4d483622a01a2a046140d3a92416cb5adfb463d1013d03f030b67f4d70a30cf77226faa9a6771b15d58a4f876a17a51fd669fb97cd612f3ca5f5aa076ac2274857356e520db02675eefe2761aa22ff87e500a901c26ec78d3b22b39cd83a2025dc1f4b747250e7cf443360f884dc0865dd540342a2a7ad243bf98105ea1f78b855332b1f62c2879d56d7187970a5f716ef75ddd45375352a378bf2376561fd06bb0e95bee68f48ae6c35fff628b15b2defd65ab4df838d28a4a803177b43cc8fc8e0cfa96fb8a0a1efd75eb1ae354e9e453a07bc8092e63eb9b87b145b7638b07fca41d27d59da11c35e4044aca3c8a4e3dede269e0f2dfb325a1c14c5d1e6c5662579bac5c16856856849e982657078e5c5b571c5842270ec846cff4b85182d4fa4358412fc054db649aac9958dbd66b78451b7984ecd52f88cfc720a9387cf6bd42e546b9ec066629438e272cfa93f37e9f111e75d2ab9ced8a50285522c3e8fab4d29c20ecbe2d2558049bdab7c5db87c65464b9ad26fb080e5e34c741e5c11bcc1162b355babc3acc7b53d3c76dfc3b7a96aac5b13907f1d8bd8c6eb987fa3f0ad7d72caea554dc7727cb6e781dadef3ad82f23c874d2c9af06c55cfae5ca6f89bc2525adfc8224878c96ee041c21a870494c8d842c268498fe8bf545f75c326fbc1198df407c08fb338101f89fddf85022e0ebeb503c1f3d2ec9a85d9efcfe64a18bb4f646343e8794b101663a8a9d563bf5542642d32aaeaec6d98cb9e3170169528e79b1aab51594926d25ea13ebea8e48819b49252286c662cb177d354460264eef0ccd795e46c65bdb2476940176c6fe92ffe679cc2ae39de78012ab5e60d87a862732093365488d6e292d6b20b6db9ffb0ef333f41d916269cbf7ac8a09fbc462d696dc54c8f5e8305b9dcfd6eb6852d24a9f6dffd2cd5ff9ceced44f86db11b763fc26f7bc679c34faa9d752d24e7fc1697f64d4c108d7415d925fbbc6a3e5186de4f25cbbfb06d99705c56b25f68a19eeafe31fe10c4bb496c9ffd6b434163f3f6f14153c0acdb7f8d47dfa1b6b64cf37f294b4b1ea35e076b26e38929522067939a96bf51bd94af9230d0d4b5e9d8a75786e48ef0062ab55c658b4c80cd120e85abc461c1797f1d421c2e3e27916a0f3a91e36743fdb0cab3ff5d39a6135e0b0fad3ab695bf1705a5d89bf98cb6869323599e63774668f02645d9c3bd57de08444036cde0895238ca650e7bff6b5234b47fa88f2cdea2c77cf3a8c45ba61f8e25176f338eca4fa5ff29e3ce72df4b0323746f4fbbf8fa0060ad5cf2ed6e851bd9d05b91b71ffae3c8e318ef0139bc724e9e3a0f9c01b55679f2858d5024de47de4a5156af97233b090ca118d52bc113b483c1e56f805499acd1031d5286ccb9bb3ab4e1bb3ad3f9df7d2343e3a006de12c3c14f7260814c2a35b8ae4d99b07b3f1f1ea3be2cc4027c8540bf293717b5b92c3729da88d0fdfc04ef7f0499190651cbc6363595757b71e201b5c6acd82bd82d6e03c2cfb2b1f574028d202d79d43f7bf56c4459533b6529a62ed64c5a8b32bfcfae120f28b77dc8a0fe62723bb4452635ad98d4243ddd82da810d24d20d272c4803cf29eb23a01aacfe963dcd7d4b84c6d9cb8abc3682fbaed677aaf3db156eea2268dfe4a6d572dfb4223eff758fd1bf6141af340a0ffb7774471a28fc467e3a893b84f0557de9415844a697d6207b9ea985341953798f1a3c37dc6b43dffb0d0cef3d8f78cafffac7dcc976907f711290f5662083cc750ff4c6b7238cae6ab1f6a8d7682931ef5e307278464e9b8fd7d18457b8a8abee2077f8584595950f9ae4670d61535bea811c9835b8969a5c189f705b73df4bf8bd1791fd2d700fe288c97d08acf320820488f4c8a28316d431506c2cca797caf77552cdb1edbaeb9267b170a3ebcde6252023c3670d0ff010e37e2a8959e48d9d295d4f3809e0b2171a1c0478d902f5ae0f8c3503c909e22dbcc6b68c4b2f4c70511cddcb4db835ac4d4417fe2bc933d7a16e6dee07b73bffa7cd2c0f7d1855cea48fe02f73c09cb0253cfdfb7c8b9f874063c8ebd4983c5a205e407b1c5014c61a84433bc7a2be1cb5128405399e2d0c7832953ec04a74d9c860954207983a59d12ad59131dabfb83484c7e954bc557eb4f51aacdd19e293e466aeb3463d34e9cbe626a30dae48e46d8d2c16a09b08b92ea26d83faffa1a9375b23382f655cc6bce0e819d5489de94ce2f2d5bc7749c3bb2e6bf33eeb41a7f9e207f5fdbb7f8421d90f933f581ec16a954a6c8ff9a6cb85545befe566af2331d908df605e8393220eb9181a9ac04d8088aa8850829b852cfb1f7e968b720a7338065379267b3549a774119e8803bcd2bdf6bfde37c8d9e7303f089a7ca17a4a29ab7bfb76193c1015b443b065b05183e0149660a666ba7661d97e54dd781275af16b12d2836cc6dc125c8115f1e83e176fb4a9f5929b77b5401ac77d2395d0c4f62c68a95a9f1fcf6247eab1250554d72a505a1712ce31423bff21c4b6fca208f4ef638d021fda8dd953ee15378dcb23c7127c582244c65381da6aa0f1f77643efac5828b6f668297b57c1ff8de116a3b1e3f701e0ec0a056d8440d846ece5983563e283308f1332070c73d9ffc6b4109f8491e150b870da940b9ef26ddb0de119d5b29fd9ded02df173a912d8f920b4422d04ac823d168de7d3dd1e1826c0f0b7289420215ccf4300a9978f22a5d1b5da71dc4694bb5463187d25110bb8d94d652b6917e6b7d27997a2febfe910392cde73019f502ae6495329e731f607bbf4c6cedd83cfc15be49d5e7d373c3e99be17b3e174a2951e237d0a8d4abd352156b2ce6cc1a9d198915843d4bb542a3f9e532b0f64d59028d0dc347f60b302b6b8ffcc75529d76785422ef82dca6fca87d74bf43c0863ff95361665590a23283039c741c622b5ef55c73ae0226df004ca4bb89d794077986d9f48a59bffc5d1330049e8e80ff735b4d0028bf89d182f6f8503dc6ce1fa7cfc2bdf7ab1b658e7eabc8a0a1e5bf1ee11a31bab49e0dcd413aeb543a1359a64c446d5008429e9e826ac1232ae6fc9842ad324d8ceaaddce40bc5a300605f35ac54d9cbcb9ffa3b96b866fffb8790522ed94aa96660eb4be55780513a31b21248f170464c877f1f6c62d4b379a54e78ff831fc07d9ee09ec0bc59a2f2ca61028b441801bce67dc1bebcaa87395e3e3254fa9b8ae35eb5ffaed5c6b2f45c5b8d41a9b9a584d790a7c2c4b949f3ba09ac2e7c508c4f7780352f1e616598ee51f7c5ff1a4addc58aa2dd8088bae242ba5d8c6641e8b88abc44a10b5d343b79b4ffa909744b48e4dc7f7190f0c46ca9bb4ce86ec9dc1b4505a3aa3d3ab601e4a290905183eff4b9a71ac4f6fcef2fc273596eb233042d1cbb85105fdbe6e34c8d7c960c4ab0063db8980db6077917ecb9c38678a0d289197ea7a8a5d1c1e0e560f062321580e369d1d706f118bff81580b8b40a3fac77bb46d1c40a896d999bf50f23cd127bd544fa809ab97c3bd037e8ce9208089881b84ca24b05dc321c0a08c6c5b5f0f107e57e86d2088e17658a8aa63f688535eaacfc31517080a63cdda4ab36ec5f5d1697c51d9b67a50b23f7a3d4044d4e05c82af14e1fa04bb0d60e4e16604d0af4e4d64bbc7c2c8a9f1ca3a6aa5257f1d8de2999778daeadc8cc571d7e0dc7a5f6bc8212fe1c4acf159a59caf8e8be1bd64a6db779eb79bd41450774592cc801dfa46df73f91418a8755712925b00bd145de55690a76a80b9e73cca3cff4dc062cf4c3a7ced7e440a5be6338a8929c05bea3c698119cdc98778886629c36e5497a3865e528a3d23ebf3e2c2635998636de332a7a4170de8ec224019c8b4bb68963fcdb05c1b48ee64aa01b4339e79c608e80c59da4ffdccad5b4c9dba6eb4f29eb35d9417b5d5403c0e94aa178536d1ca025541fa8b86c86f8a5340f3283089443d234cc66488ab89ba70fff8df583ead736d7fdad941bc25b609c8ae1086eb53aa0c35cdbc15106d334d486f64be931016b002d32b3e5dc8ae533d9a46610146f8a829a4bbf875f9c0577dbc660c6533c0dc4fecf2d824f1bb765dafe3d6ac31789019ac9b98216b3a41dd67dbb10a10f517949d3e769bf8f05328cb5a4d421a984cdf84dee7745eb001a5a380e41fb6e05eef32aa57cf0ffdf53367a586f3e060b39965d6191b5e426bb26efe053192684a32fbb81e69cd7f6fbab6d3f5d45c14b4c2657ed0103d4864a713d387d59abe35ba67be61891681bf2de2c41409a82fea6d5cc166633f010114dd08224a136b8b909900c0f262afa17ae94872ffdb5653f6f4b372217130676d6953329b03982ba964bf4201400531e28a171440a5812aca1277ce87c94a37b946ddab34543ceff37ffdf0232679aefe4b69d466d12d572c9fe2cb9d4019eea371bae59cc9f1e285062970e3788534e719857aa9d0136319a65e459b2a7737ba140875767e5867aa976efd9d074b4e4212ed7871ffbe4195336c380c07cbf434caad86fbae3b484a531c01bda1b6b5ed7dfc20195b15ee8a5cac0037bcdc933d8079541133066bffb3edd7c08adb586e3c775c0d4d89cb8d8dfe8f93668f7c56106f86eefda3bcb1849f83568c2b8cfa15eb1b7acd2e745f30547d32f5c6d2de1e877d80da1a52ffa5b432edd768e02e341f0ad2b56d7b0645ccdc453ae2f6382c374fcb545ab0689e9cc63d9eb14d1239e5c79c49a5ffb9a6923d8af77975b133a19f87abbc7501d8adffef2b07d4ef6e4357141ba05af9aa32f6c32ddecc558853e9878ffb99529b5c1ae3c3933ffaccec19ae638a52bdca52e01624c569d3d64056b3e7b2be7e1936c47e7046d3d5df5c35b6f865cea05b6bb2aa3eadcf62fa610ff547e6326f1d3e8ab3756ab7b2934b2670da6e7f13977d08401aa0f86c6634174cab609849e9f7f4f28ead639b358cc462e7fbb0d7c731ce56c27d8c0120549716d45d43528d5517a97857ddc4e1eee6387b9cf9e22c87e858de930da5c984aeb18ccfe4b6a61cd54f9ab21145fd53cb85054c8c284df7d4fc2d69411d696fac334aa6e23af7f4741fa45289a4f7787fc12757b08c9419157417b83261214c17e9a3a66ec3420d4dc1b1394d1e9f84e669df0e57642c2a25ecdf67613e589b72c6cd46ebfd44c818a4ed12e357a4e546dc65d722be7b8cc7e31397c3cdae50250e1f92ba2f3276cb6b84ed0ddd63952c1bc28df8d70feca84e73b33308b823c92be3a349ff38a79b125148cb07cdba220eb94010e61927df341b041cde58ca286bda525282460c1878f847e201c5dbba50f5f7f98e03d3e7d8ebc85b7335d13ddce55a4edf2a91b8e7568741e6ab28f250e8f975ea9348abcfc202982c6f95b77e60650180b28ec9891d297b1c271b6d920aed4aa8765d3d7614dec77d43283b9db2c5edd02fcd8839a9955e93684a7074248ebf7783182612c59b53af03cc564a7bf0ed3a244d5eeeeb1eb492e173607e98f5752035b8f852ced6dc2164d827731c2db181af99382019a3e5d702715f7723ea8b6a2a7374e74e62ab5d6fb55ddfc7b233508409fc5969ab442012da4a54012ee0b01b144c74fa7abd6abaf12f618a025871926811a62b3429b080b5d1845a8dac14251c4693bff4deec5af64381beba08fb2772093ba99abd2663fb8b79bf056f0d96b3d0c03956237efb9978c67057a24861ff0b79f2dbef62ce294a28655853672feb84834584cd4fd0372cd0e5750afefa7b28d1fc7300033c851cb116028011bf2f510f22ce490fb547e143fefbc7a8421f7be37323a88fea1038f0e74888f2a12e45ccd3f6b9585406ea153ed47230a62fc2557edd0dfe01b30ba536d165b8f301745948d9c05e811a157148b3482293084de678dda3aab35f21512358f32af70a573eeb5b2a7d9abcd2e6b4fe498daf59a61960614a01d2e64482c43f997315356b5202d7fa2386f744b89e53bff099e3df87e692cf96ae7ca5d99593467aa20d664c53f67170e57b9a4b29136dcd9f86591554a3726d626eae77da3aed3b18ffe6caa86a6358b633eff8faf6548c2de1bffe60e77f64c5907bd6166423bba87caf98c17fe9dc20a8a2d718bb12866ffc494546b2699356dece46eb81a77e041832bdb4be8ec384867dd792d1f827335e931a8556439520853f1edef33e013eb7828f5bd8dad4d25bf7c6f6f0091ef68986f1d7410e60c917653a1d9ff8e5ee824ca54576403fa5c4e6fa5207603a79829cf3cefe88952a689881ae79acafcfd264f636efef448a8c157effb07e9272a2b042253f1e688c05b730a9e729ad9b843d6a380a8a8c8759857c17859b76bff07e658cd4f9b2bdc138b1514238023c6eb52d2780c65139a66b7867ade733bce5ee97295ec0aa6ec2ce4563faab30b019f03d312e369de0282cfc1b09a2837f2e7e37459f71438b344e6c8e675b788dd8827d4fdaae6324ed45edca10e62836d55314d3d2260e352babb7b186c08325a59316c0802ce04855d34894577caf6f51eabcd7756d40e9ba90656532bc0388da46ed3b05326c92ce408a5fd486599b3df2b10b2097ad4717275c1931e651147281ce9ce39d308cf7e2ec4ea94e1fd6ad6f1a3d599c8dfc7d095b7743797b05a5570e86839a3e0e800480522703975241babd4f49296ca1b114167d70eee6c447638aef455a3118742337f73a7638ee824898f6c6932fe5b428ad84e2307295cf9ff5ed06032506c05acbb11db84ac2e760c4c40b7b742d4552c8eb8f45af30b8f4145420d1d2d34b9fa6588d9094a105c99831f4e32087b1800a9f976f8fb9a89d30ec5c80e841c3d91d1014a414db1ca0e93df9cbab9efb5bc624ba69905b523925aa086da6f29258a9cdd69906cffd3b1db123e33df2149ec104e508b7a20856c95df132f1e8219abb3b60cbce947fac71362aa57678e78be40dca1ae320f9c3fbc7c15792066db97d3246a3e2ef652e0c20b9eab0ea32fd6e84db533bfad7e4650aa5773c3db2f52700f2a55cacef3fba27c0d740c46bbe8130ae658cdb7474485944d180b2935703fd6341b139040f12716f33e94f3854bdbaac2e276c591d23d2f999d6d2d721ddf26c41dd1347c6cfad7c270abed1a20e612af3179e68bbe68d6d73f823c8e1d451cde05a7a3599a009e7dbc0151d4864ca028ff5869e7f863d361aff09ee1b58eb0a52cb1fc3da6c41a3667ca5031b74a7027909f1a2751d159ae6a02eeedd30266cb95c2fa8816a0822d23836b497bee16e771a8aa62771ab0e5dd00d2430fd38ce8bd62595b910e9b38feb8e2e180208a0a071584ebf40cbd7ba585608308cccfe6ecdae61746e8beb9760a14fd85e6785d73b2d80df985e0ccf1fb33951f5a83ad86e1afd66302f3f8f9e88f3d767d7437ee984d884391942ceafb506bb679855befdcddf18683e3fd500a7954cfe953575ec4053f8d8a88730e01ae80e959c5009ed8d0ce4c66211d82d9d3a18934503444aceedc3435d21734b6b055cd4c80e9bcb44210df55bdd9776fa151dbead56c03687b84ee64dd9138365fe122eab5734313a12a41bd9eb1631b189b7dfb03c7177139e518340598317cff3d530aab54d90ebb4ee159dec2d169e295354bee08d62b87221998067de96616cc1cf6c36119a02cd7f138a0daa7229d918da81645315b164338fec10791c459d79ea266dd0a1daf1fdf702095a482a9eda6cd4064745b73149c4128ff93301b1567e92482571aa5b5e9dbe8904085bf34a3f437021dd47ac7186166500ca7f742b88c2bd355a5b2e07e8af04dba35297b1f857bc206a8c43303163cbd1ef95c621fff8428dce133a03679f62f79ad1a3ce8900279390f135a2448f2d4bee0f4e1be5f797c650f6fa1375521bcccd16205f8a7fd3d2d4ef29d5d9b67e26336df24871e7dbaba7d3afb739ada6e187e8521e758221eec78fef2aaf2bbc8d1a1ca336d09f4573ac0f83d93761173325cbf5732e6bea7c9f07f3259189daa2b2d24ad08b43cbf063c9a5e0228cc151aa4bb3e082eace5009b0492c0827b811f6a9f2dce3ad6348195b38f833f95cc6ee84e294956147ecf890efe6f21306937d4c92e4b98dadd90d555077e55d942459435e8726d47bf225523c70ea3085fccb00af90946279c3989ae9fca9aa375b95b12ee2dce9de7759675d3af3ef63ca527d8b9c46340fb3e7c2ed3aa61943a9c7ea0a06031c74001e5062226e8eb975b19af2e9201cc3edd193f4b57bae10813b62e874152d289468712f5a302ed2b3f9dc10ab85495c9dae5d56cadd76bde74e0fc4b419946d4ea08b11eb7f6b64442f61008597cc1ba74f16900327435e53f861df0089393eb91b162e5198e8b81adc7bf08307ab448b2d58f2544e246a40402ba54051efcdc2c62fe426b154df72513d5dd872b161eb78559c861e357c766aca613748eb2e4b855542aab381b06fc1a20e2e8214ac2378d6d2b5a9799f64be3cfb87ccdf5d21c0831d6bf6159787429819dfbe7fc76c5442b92f40795da9985b93dcd54c7f2ac22f13f55ed2642d92994e67be8d3e4313550b06e15aea885e9f771053fce11a4bbc447ecdcfcadef7766badf1379ed80ade352c2d733dbf2e7bb0063b4840cb222874f8cd56b227cc8f191398770c187c8f2dcdb7f10f286f47ff0c29c3982896bf1b382d340e7d88e62bd84b45445851b5c76fd0fe3d0dfc63b069977bbd8e44b17e835b0070b119a0e6f486765b6053bc4f9b9569908a276247f234af558df5ac40fc3f2178f40a1fe3af9dfe84655f8fc7f9543509f1a3bddea49be6302504a44f2fe54fb9030dda519219b3075cef194da5324b45c07af2ad60eba481ab89fb2ead407928b2a08f0a160359e6bae45ed8d2966dcf22ae0849ed02d701397af3aab4af5e3ad1407a3ebe6eed6629a106e4154f6afb6d3f599f36ba8718f13b076f1b4b76d86f81baffbd18c06a8484e37363f768b3308b2a70fa359dd6469cf10faaa9752adda2c53d09a4bc8390b0f4a7f6703f4719f4bdcaa29bc6c103a0075c049ab926113b730a796fd03aa61c61dd6a7633c9ece3733c158686dd08e754fc8c93e23c8761b0a2fc5d1d8aafd5a8f9c8d34ecb2bfb385aa98a16f9fe2bb63eac33ee5f161bd80a4c3173e67ae9e84d79caa20864069990eb62069bfc87a776ab758cd624ae5e2db88d8e2a6fddade88001cfbedd84ae5bbfd82716b6edbc19a2974a26f2fb8090bfeedd1b14796fe7e7cf1c176a192669ec74f51a0881e60264f72de2091b03d8e9f29c9360f74df5c3d9e92bcfe713ba744687d1c1a9aef24a50f5f2bb24c6088e6e5b5338457a863e4c06dbf91d2b07791a187d483aabb5618e7c4039ecf63f50de3b85d5a8153bc468d530e71970bcb1f2880f69f53ffb1d4e8234855bcb2109286d11db87ffc625d8043727c6bcdd17449976ebe481a0c4bfc2154438fc6824b29015abada8675ef4efcdff0687332511bf79a083a085bd2edfb5840a38f57ec2b300ed9ed2a840402c38b507bd34283b5686ec9c617c77a97352e948e0c5c5ab727076be3a5bdad738d704822d708945b968d155f49e72f19158e573fa54914e2d28f43448c33978c73fb61f1d70f2f305477816e3a3fbbacfa7a7e54bfa8a199785d7ed3b78d314d57b837842da004a1372f1226895d0b0838d08a5dc1b91367df4a4bd4057b8081fee854d52a905796daaff8e4f74ee4604f7b0387f2bbc7430ad1d268488857b559fadf40fad401db748f3975bfa02834fd217615ed6b7abb32faa1877f0048c5413a1d14785e06722711f25dbfa65ab4cd15455792628182e27f0322be7af6ebbe0519b411f31061e17063d0a1abd087addf3693fa1e1f369c372a9d45a2a2459148100ae9d607ba3b107308c3011f62afb5068b772f08ae6f87600636099334b4db58ecb942bdc7be84de91a65f24f5a0ae13c42fc157c04a69cfa74175ce3bc5a09ca13442919ee6517a84f619d42b11e851591087f459dd8400235b8a69d4ffc5f3361a1151d4a09d60d762954e4102a927b9c4ab22558e98ab0146672dbad29454ee3ee005a8d66df58e583055eb65e5356d36a472ee87361e965daed0a8a3c0048c712c1469ba566b1a7047811eab7ab548967d9c8a390dcb483e807c1f3fb26217899c7563d3705eb156b5a945295c622f1ae6e13e17f89b65204e6a88717961a76c42d9095c2d5feae4730900149131d85412e6abd56bb8488148432d15aec956066c851e242e68dde14b0255a93d150eae73c2fe76b6d98e186b1549ecabc67475b187b5f7dfcb3d02c34d6d2fd6176d2c96b6864010db424320717a0728a6bb3f98a2d71da70047f82de31a4ddd75890d63334db0280547e69e723e43de45189f01807e0c6652c570bd3a4cd04cd480d23ee6a66fb72975a67aefbad7c9d307dcb14d63f4ab1d73e7cf598f00532937f0f0711f9c7bcba37d52ca342fb0456c43faec5d88cac07324c2fda555b331e1b04f24efd21677dcdc643ddb1011916a09a96094502243c339b9f7eda91ed2c2d0d8886e51e6f7d57ac7120f16bd64e9c741a81026500012c2dc6347cf14126a9e15c01ab8fb169df2929bfea4fca7d984b5add7c6ca63b929a71815a840c8c5bbb0b3601b39c3a012a80cdd59405a5d69cc7552e9877d526ac81933bfcd088e38ffaf5be4ed7d7cd1d5f77d6fb8c33ed0e85c80b134e997cbebb26af45df49592e0cae054a1b2f6c4e84c7422457b0f49a60c1ebce9bb92cb3c8c58b7585e91f3b1a8e20462daa4edd4bfe82cf0cc20e1fcbb31f7a6fbb9ebba5733c14b28ef40dee24c5019812b4a5a1fb0f691be96ba49c732e89775dcf126a0fa75e170b035cf7d155711f5ecb805842bd26779c4f2abe423935bec7eb9ae890d89100a55bce6d758be91cc3344c81bc7cfb710088c37d324518015ffbd645f5677698a5e9ddbcfa6992cb53646f77bd3df5dac6edc14cf9721a1b5fede3308e093817ba139a8c300dc456ecc26ccf53308db7acc38658ebecf9d13bbc958225216b03906da050cf98b97e53602e6ec0034b6898ad8189fa717593b8b4db5575f4db7e0e54f06ed0c02d32b97cfeadfa322394939f0505400524932b1123741c0f1b03dfcfed58929b9c2b3bfa0fc7ab82a6edc0bef0961d918b6f5607b65ac4ca6c9194b301cc31cf96b2ebcc556859c9178a395c4e0fe3fa41d70b5d424e6d9ce72bcf727fa05aefa941431392f2f8b6ab2bf65a70f066b0f58d75342c80c029599b16c948386e8aa9d9ac43ed1b2cddfa9443a84a5d88438b55ec9bc9291d6af2e6ba8812398d06decd25a6f9a5e45d4f7385de3f2de3420a62415de7f6e7b0aacc00f4e52886a14f6feab48608a35a4b9550533131de57350d429afb4087902081bbb685895a194263027661e73dec1190cfea7987c6fb18806a17562e32d538803aa5a36b0681701a6cd6288a5ff7f53dbb3c74958f17be88b94face90a240c9cfa79c0aeb1e6357130f12faae5a43d889433216e160d9c6b20d16d17bd4b0e3615c5303f0f2df3a73ec1917bcef4b3f93db44aa9685102a7afba8b1b7db63ac7263a4381ce9791b750ae56162057c9ccbfd955b87d3f387f59832e23e10a2a17c24f5d17dc2927abf5579edba82d4c635142f4264b09a8d8b19798bef10af662f5edbca4c96f0d9da81404c361956d47ee177f929cedb8c8a5ca024861aec55a552908a1fe8253d447bf2e4584acdeec73721a3caa95cd2d353094b935b7ec7ccbc79867409c8bafaea1bc0b1a8e240d27c5a0e79d1181f8902d29364c447cfc08c1e695bc0276243df7053d50c40627879e2ec24d94d2eaa2bf422aefc5409c1d5b232a6c135dc33143b11b572fe2745166f664d5327e9e21e02fc15b2a8cd84b44ef585ecd9012d003bbca3990db2a3ae82d5d4cadaf52d26ec59bf7d7a06b0d5f94e3b473ab39e5622ad48a7e145ba0b91f945b9ea8167a949a1b7499e2e8770d949a28a766d4496a9cf10886ff5b40c015220bf7c9d5cf6158aaf94a534b3adfb137f435d85e09bb0df01c385dd4f73bcac1e6531c344b8c72be9f19c18175c48ae0e7964b2ae0b2160ea98f72ceae90bb64a72589978d04fc643e025ed136b7962f0a75a8a5ec3d1b05c046b63c63a7e7e18d914109e7ec76b060d614948af551bd953ba654a342759fcc1f158e90990815e773236209010c45b62f13f74a9fc64203abecb533a65a5899a933a2beb1d53c1394753e2d75a7d675246f59b1bf83d5f77b2b21ea62927427d4ff9e5e5b0111b206b92b76628eb88dc5f36496ee5eba4f3d0b463d7636a725a577e215ffd30b65bd6b3267dafc09b48264c7a4a93618c3803d9ac83ddace6f7ff273ef6c9fb91bd9da731001f69e7fda1678b46ed2c0956326eaeb14f4a18aab3e2cfac531089d5287dbab378c46d353886ab7cd5a8b1190317ee3b0f71e304c0f04087ec75373627705643a8a825ba0665cf60bf6a3bd1d1b3bbe5d596957a196d34c2b4596dff279d72a5d15d0451322d6175533117a3a62377f6cb3f44c90935f6eeb4b4cf097f546eb38acfc8102097c311c201eacf9eff0541812948b53d7712f152aba43a3cc02a6414df3951e9729daca11f5adf117edef491b78d488f825e3bb763f6bdbfa5f09b5d4b42032a0348da8c06ee2ca6ad90478e1b2121c8726b56b90ca2a88e4c295e41432b5488010afa5e55ba4c4b2292d3647852de9530d4136883274a1da79e5da483425d6111899a9d88ce2e587bdfc333cc2217218c5e037a57d88f11ce8dbad968e57301d05a8d3b40ab72ae3f29f685944fce1ea9a167d7bcbfd81c6b453dc093a88f3dc3caf56b2780d1afcd92c37f086c3c56f40ebfa3d59711165991d3ebd0ea05a42e5aef02adc66f933268d7d60d37db9124e1f2928b5686696a96a4c354ae09c025af8655fa19ee4f4772db07855e86ef7ef67e7069bbe05efed46763a44bb62208dce9024047a8eec795e53f23d375cf334e583c2c8e76f7aaeb4be59a4efabf284b05bacdf6e14268102f2c3ee714d8dee3fe03c13ad1a337ff37d2ac7c433cd9ed948547a08bb3c7cb00894d1b40d870d3c9a45261b5e0c8c153c9d3e3acc1e39768d534209d3fdd1620cdd2556c7c3d13f7b724bbccfdf15cf27516a126d596ef8b158fcaceecd6cb85ecbf37d8d20dc8143f61e3ff5a0be885751c2f05b8332e8bf527238dad62227fb42a540369b740ab480dfc950057819e7dd48f8efba0c78366fcd6f64ae6d3dbc265b2068aef4871f1cb94eb75a7b379de5a6f7911f77a4455eff507a9d42b442d06e64b6f29a0e738b99c98028421a4740890a08193d08e41e105e8282b69064f0beb6898ab7131f53cd213ad44932c8560883e518f4457440f8b263e1c2a722b554b039559a0bbf817f3af932ad408d78ffe0c7b25d8224e17adeb324309f5b2bcb6995c98fdd916371c9eb9048c529adcef319eab9eeac72b72f3b3434a76a8a856372a3119d7d51f1a86d3448d827281696b245ff1e8bf21fbd2bb0362598da4062f8e31bbe85917c1c347f2c74452aba432956a0980ea14d4c1ebd96a8ff8acadc79a2354299093ccf47a7f4cbc68b8cc4fb163f265a9db6c9c275cac23b69269579d95d1510215490440de6321621bc62fe7dd30ea5e61ffc936427335f4645ddc1443a30ed3b0c1e2c1fc71c1a938af91ce0b0c65acc996d2813811420c58043761b06bcd04c9d375f59a952e4c58fa3a4a09815df8a4237af49ca8c5ff36871dcebd614749d3c355ba32f2b48985440976713138f43471e4890d1b58b6066d711823d61e920371b3abfa36ef49a67a76a449dc592abf202dd4595b98f690b57bc1285f167fbfc0db94505ddb1e11df1e2229307117cc052ecd9c80293a252b857860fa5dcb91a772293843f12a7da9e8076f6397afec60a5da118732f4d2b120ab4a93448c4b4ff79d69da486c22495278191e04f896767c65f1a63f16f789dd363ddebd186226b5f2f48370257d8cafbf481fbf5b76aa4bbd939f9ab9a068af741fcc2fbb3fe1827e2b8b243b237f215455c2d7ea922a71850a24df1a6aad3af96919191e060ab234c94bfe21a568407f3db385dc8d8f02ce6cd9b4ba5b1d435e37343dd78a8210e37db001553a41a8694a4ffbe60634272c937d82122e550f2ceb739ada59072e9c4777d110cb5049048d0400d7ff833949792e9976f12c1896ec3a3e49a10b9aa6c93df092eb24b8e2e7a849da289fd897ece7329be0724f9d49e89244331ce957a0b8efb5c1b80c304a12baef1f60eb457d5ca423fffaf2058437e14ab1faf99f75d962d5bb5a1e2db42457835a5ff63c1dd44e4e95e523de05b99aaec0fdbef3bbacc959c008db638d77a6b65f043d5b672c29f5fa41a62c2db2b55487bcfb7c3c54cebe7ee1f9b29f80071bef139d97a25b6dec590f23aa7a7da16456cb6738b6b0608537ad8e951390b48a36e5b8e44bee6191804b7c80be033cbe3e775f3c5bc117277e4812b71a4cdde997c115ec703684b16ada87c5e5dd19731df8ace4969b7b046c1611e7b8812c6d5354c366b7ea04add4d0ed05a5ef41debdb03fd785ee3c397b1c6e3992e2fd7e5092b230f5f0724e357391bc4ff6c14e161fe139655f40243fa2fef442a888bcba188f6b782d7744e36904253a4433727135cfce0b108dd7efad664e1e381de1d865032f2cc8556f9ecae222f3c3b689c7eb969f78210a4ce74bf6e5438cc1c7cb27dca978dfa9b03e2288e77090085dbae69c7191998b67d2e2c269ccd490a700423174ace0a04cca0d3de080af55caa92ea262ac</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-09</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E9%9A%8F%E7%AC%94-2020-03-09/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E9%9A%8F%E7%AC%94-2020-03-09/</id>
    <published>2020-03-09T13:43:27.000Z</published>
    <updated>2020-03-11T22:54:03.465Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b94527e9f436cd9e1acc6b4c99cba99ec32833d053d52bc641ccd08e991a57c9">0267ec72f19b8c198697a4f72870a3a8584f376137a9d1d86e1a9cfa88aadb7d7103cc4d6088216be72b5f0194670dc24843dea27e475e25a33b67d7a3df15252d3173bccfd3a51fad3c9c6872a2bd00790b2bede27bcf55c78544bf36da7add8d92c04aea3808a91b0bcabee28a69a39c6d7507675543bc32d149d005358dab90dfb0f2981ed0ab7464ffdd8efc83ce10a4d0cec2bf2c55f5667102d8f1773541ea980cfdd72ea0e32f332ba7a929b8dcd30a61f9f28c3f4478bc8911b61b1c8fd3d288b755a78471619b12a2b1d11735de2bfbdad85958310f55fd20676e8f027d0f4811a9000a81a7cf4c95bc7d40039ac25e12a92f8043d63ed0ed11ed730c39f325d124db45a725f63c7d866ac04596e9f2a8a6852dd3965a48a99910cc290fba0c7932d7ae252d4c116bcd9ad1f558abd1297660a5373fcdc5a7a87d974ed6da18d84da3086320368168d420d73a7f6182e7012fabed0b42eb9ae70ade7ba5e457b06c6490aa084fbafbe9f692cb405a6367681e2fc7245f6ff424cb57624eb8b82b67cc6d79f08e717cd95ceb06ec430467199a22417c7dd2314703c9d1b9499d3be0a2cbcf8266dbe954a3382b2b762d64135a85474364f0cb3bc28c2645ede71c360cdcb17466535a248007d955f991c81549a8c91787d6b94295e954883ea38b97d85441542da4bf0cb6470b92b28a2fb20df6082b0e86622c8fe8a21d4de51698a2099f1d476f031b7b958055779df959de867b1531c153e0e4419ebda7a77a2a26433a4e44a2b307b4ed7c8908eebd453ec2d9fd96ded0a784e8bd8efc5286fb85d62c458474b5c2fa9bdb1158b1bb03c1a26b15b9934681826547cd8c14e5e40e4c2163c4237f28ee64cd3a74ee6771711b0741af7195a28ee79682f9e2272da5f0055327501978d00e241a460dff01ba76af81910133a300af9fd80080b270765f4fb233bbc9f04f8f23f31e44e270707578e6c4cc38bb3a371e9a9ee106c71102c40a5f58a9357eccbf7aaf3dc9345c2f8fb7b5df91dff4247dc4c99fc94f02d1445ff00e46ed07af07ac16ea5126e351dc85f5a409081c3c35c034a8279244d2eaf060f2c6415320723faadfd10187373f8f923a172e6c4b878f13f927b9b03f99ca9653c23e2e94e5a01cb5fc12f6fc733711ff0855283e5adf0ccc4a8aec7cbdd7733033269e6cb9ec18f38d32031ec673df0ecef2832d74376599eb87c6ff3507663cb447bab9c6ca31c9805ca7af614b768de012b4b04e298df3672a47ab591f0955a985a7a43e23fdeb2e4e48000b1dc8897a2ea3cc1f6773d1e2d8e912ca35383de07a9cf76c6f59008ef6096bee608a2d1acb522b2a5751ce78cc26c977910403c22892d1d5a20087c70d643ddee54007111841d1705ebfbc8e88eee996ec0e26759943ba0163c295b6a66a74a387c7f214b7680909cd59d703f065acf55044ed68939dfe3dd9e3ab2dbd244f8fbb13f9fb4904245726cc11b8f35678d0fd6eb82099adb984ab845589dbf360224dcafdb586a84a7a38326d245a290b87689b36de3ac4560edc2ebe83f3ce964f168b93db73565685f1bcdb408360746dd6fd0bd91df03c8edc5d07904d5ca87a24fb35fba789613b1bb8807b0fd0e2656af27267a5bb91a97baac1724b8b39db3cf99470139f4ba6f5854e5b0f3634d873126cd87cf05af24884bc89ead757b1fef1002bb8eeb831977ae39c0b4ae18d9ffc8d3cb90f5229dcd5e48b9a6dd6a6d608c855646aa9a6d7ab5fc026b845b54441e1420bedce4f105228ca21aaad00bf605b0213b7099da7efa46b6e940ddb6cae7d93ac737fabdd7bd96c47d7e62a3dfd2e186c35c4b7457eef7f156c03c6e3451324205f8c9d87244b09a7ba004e5138ef8d2867000b79fe2654373ee112e941334311ac33d525b2dce207e4ce577600f31a05468c5728025a68d7f3188849980c23c4439466a806d2515d9d0bb98da1b1caaca6706ef25983581125cbf0f0bec82f8c2240d378ad86cd49b37b47c3aad160837042fb4a5fcd8638ebaf203e21e7002599e8eab1b14fbe9928f21a8e1fcfa55fcf7526ec02af011393e673e866ee018929885122879026af15a9ebb4d039907c8d08868b91a583e0e33676442170cafeae0c3b92e724ee6fbbb2dc78951946a1f958e1e6ebacc8e06289655b937fc3c88ed739c1f550c8d31b992290d9f38eae66daef0539d76c47127199ba6645a284c36aa7c3ea7f49ec57ab2705cbba5645973f61ccf54465b522af3d4275e98d2267285b180a2982bbc6cca8597fb546f3405a83ce2fdc6b3c82d120cd43ab6deaadaef1a7920cee7fa084039b2355ac144499a69e53f1f0d70de9d1d569188998cd83692dc4c838cece4452138f7b9e960d21b5bad5ca8662f5ef5b2a52d3795043af77a98617a6a9c4bbadfcce65e2552469978640b5c6ccfbbd1a115a027f629b0cdb7a0ea2c21d1967bf6e2b90a103daa29670f558fb2351696df46377ac7803f09ef8b2f206164fd6a4fa4379247915eee8fa1c5141f63290ed5c4aa66269f2d5fd7e1c65c2fac57fc3652816d9d8331f33af3e529f94469192a948ca083620a4030bdd5c4f8d7cb72984ce73aac754c798eafe498e844d03c666328769852ca8f855d7a33a8bb10ac33fdd7b1ac89f53cd6afe6c935498125c4739d1fb6232914fe10e7a6257140256a1cacf6e7400961db383cc1a897c9bcc4473baf6e693cec032f0aa2717415a7facc868f3b6834be8ad4066627a2e29a972c1518328d5c2b1f18f442a5f18f9ebb362e4ff741a04af0c80f5cb841168b452ce083254f25d31a71fb6e8978186a5774a7635ff5ddc7f5acec7915a336746813178177a005013a4daab345d4e15baa1420705394e225a3cfe0cf58117e0cd1880109486489d957063615342e9da46e7b106ed904d5b81521e004d932db1be2165aee1b3b4849e9f9a942de49e90bd289fd312f65787a5b4efda9faaa0246f4135745353592cf78fe2ebe189a6e35724f0c37a7cc0f164e415d18b46dd75ff9cba22a72d61a3ccdb349b458237d406dd6cf9e6072658a5528a7cae4380ec6dc07081ae9a88356ee4671f242880a197b99cfebf31e62e5f607011076563a191d25bfbbc1a60963cb477b6675693ebcc8043b06065739907131ce4ebd0875fa04a03e65dcb421e7bcbd40d30821bcdc5ebbc83371de760ae754df2725efd3df9b16c81a9088b2d62dd406bb81e56652d3940b839b8a2f5e9464b006f7ea0abf346785ebe741e6bc9d77428718a22ba1d1650fdaa37b4c111fef1e36105f953d7517746e82e8e0ba540bfcddef09a93304745dbcc38c7a185a01451041de0e00777c35edeef9611b5af228cd6d4ac5083377415fe0d165fc8c6384b006e7ecc6f16465ef275e1b0cd963d013f9dd2a40e7f46200718cd2daa26691938dd040c6babe3bbfb7589b7280dc38e016f50dab802e62f6a26a4f456c63cee5ce65456011ccad36ee4422e23bbfd5a364e415e89b16a8a641736797be399c2907d50d3ffbbc11b0bb2c6f393a5c96a8f918b54096fd44a3ee0bf983bbacc7a3c07838abd72f1f8c342da9a79c9c7e14fdf1a19da42ca4878cc92295413cb12c967de015f32d80f44150ea17006558c8a7fafddd279eda6a56b1397b12ee7c3464a5f30a8dfab717462b83f1f43449c0c0b8ecf62c351f8f0daf4b192c817b0ce42726ec53665d3300c434bc680c0ad009416caed7cd196370161220cfc9a2f967697dcdcd7dfa5e0a692d4987baa13577f192f9ecea58a5ab37cb0b770df4e690e61a504e77298e60e5c9430ec67b39393fe87e5ee945f6ffc60aa7d99023afa9d45ecd7cf789312788bbb49fb0b54fb91dc9487fefd86460012b3051374b64e994880339c4c1a30f40057c29439c138541ba0b07aa550609fa8e1a0d4ba068e3ec6ca54a82a12900ea2ca1841f9b1069a60b1e9234d1ca6c790898da1521f903144d9751ea2c2a73306147bb881b28bc5400a0548f2103fcb0cebb9740f79f50d5b66086f1735a8029bb23ddca5b198dc8e7ce55ce2e681207c569b6fa07c2375273e42ca21671c84868ff8ebd614ac5157e207e6606a3c05510ee01a6b1ec51537db973f8afc5ba9f8b67768e8cdc7785810e3653c3dc2793d807be4780fe674390d19cd6777e7accd3fe60fd338d298c7401e4f154194710d96510f0ecd591054da012f3aef5466aec62fff4b50361c172cfcfa288f3325aabed8c7fb99ddd3e45af3e0af3a8de8602694cb9fe39321170a6ce51a4c5f690e0bf820610064233bb74ef2b5f84bae3fce31cae7524e1c232bbbbf04c8adac1144446174a23b5d5a1c6699ccccfe2016d7b1eb2931bfd19ebf2f083f0f6f3cb9c9363ad62d312e9e8dde91f577b83810d905fd107e9efa96e3319e32d07e2f98b92476d0f25a3274acb959a2a41be72cb188110e6c32f8b8e425916a2abf3fbe174f180f7b1bda5ec9aa61d632651917a00ea620986ab87282f91bfd9b6b19d663734c8bd2c792ce07b885d761815278a47a78c85abf696aa6851c68fe429c9bf1187d38a587771ab9a621581724da590ed26c55f6908ad48dcae7508eaba124ef7d827c0bcccc6ce9507510d6e8730e812b403c15e19c6ce2224d29b3c64a45155217a9ac4607ee5e79bb0f1e83b8081f7c7a0854638bf70dd298f733c1567e15a690c7368d143082107403fe2b8862bdbda5a0dfa98b8685180c2d4dfad212446b8f6e34f7bd4359786c632e679607df9cd01d2577898b0866fb9905ee5ab0b342cd653c40e58eea8fa745ef2a8f309764460daec447bedc51ef6cb2a87a9afcc2497b6574ddf4129abd02ae31143131c527fbba5be493d2d5ca9821a581cbd0b1c103ab640de316248f6444d01f4fb81ceb3fe52f1cca9061d6ad6d6b010d5d79c1eee6781fc9db33109e6b92798749bed139788c5cd3e8a3251b08cec3587655811b2c24f4298eefb9cb0e494c1013fbed4a6e17f6ad74492341cb896ab3ca8cead58f28571c13aae956e04c7a9d7f8c610c6e117157d9a508e1cca2cf2a5337de6ea0659e00cd4cd290a9df8e248005d89c1d34db5ef82408c0a3ece7c900a7136d41ab64614276414e2f4a1496e7557bcf4837c3b2178120aea12cd7ee2e34b9bca24f3faa1f3805fd6c9e9598befc02e325f945f3a8b1db81b8e6058df63ef71e4b350de32068de81e308f63488449397936f8296057a1630d83e8df6ddd660546e27e96f24e9100e359afa7250b76bb002695417b58669472c98a28f6be715fae5f45f1355cc2190a866b72070836b5931406405cba16de854553e62156b257ce7e9f6f112b16f9120d7f823be8c0a382adaa6191fba6a247a17a58eb3d53a3006dae7ff780a7f4ee7f1033a95b573fb437878f1850802c7b920b43cadcb4d866cb0c98a150c86e3dca15a49f475025aea07b166e0178b0637d9b450fa76fd153b2740e3f3b2ddc3a16aa816203c4bf0205a6721f6d4bf8065632c64ad6362ce6f22a4d7b36bb3459d4fb47f0b1dbf2923646238d1c100761326a440d8d2bf5267d54aa95cd3d34d9375b3d68a6eff6d4d82d68288dc024b8749f076ecacbd22d6b7e1474926832026c92cf9152c24ee9c99d30f585ba0c4ed09a71a64adb491e5716131986763d9d280f0ddeebd77489e32ddc01ff3d30b7bc429bf88e8d02e392e03dd36b30510ac5a27b9627255e9caed0028f66b9f497762b758983e6b97130b8c35724907664801707a73a404abf0f84d07200592bf9812e637c7</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-1</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/</id>
    <published>2020-03-09T10:23:24.000Z</published>
    <updated>2020-03-09T13:46:42.334Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>数据类型概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-数据类型"><a href="#计算机科学-数据类型" class="headerlink" title="计算机科学-数据类型"></a>计算机科学-数据类型</h2><ul><li>数据类型-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li>数据类型</li><li>数据类型-变量</li><li>数据类型-函数</li><li>参数传递</li><li>形参与实参</li><li>内存</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><hr><ul><li>数据类型-变量</li><li>数据类型-存储类</li><li>数据类型-常量</li><li>数据类型-函数</li><li>数据类型-数组</li><li>数据类型-指针</li><li>数据类型-结构体</li><li>数据类型-共用体</li></ul><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>概念简述:</strong></p><ul><li>在计算机科学内，任何存在于客观概念与主观概念的现实或抽象世界内的一切概念，都可称为之为数据</li><li>在计算机内，一切皆为数据，数据即为数字与数理逻辑所构成的任何概念</li><li>这里所谈论的一切概念，都是基于 C 程序语言内的</li><li>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>数据类型的概念即为系统化的将任何存在于程序语言内数据进行准确的/系统化类型划分</li><li>还可以更直观的将其称为数据类型系统(相对于程序语言)</li></ul><p><strong>类别明细:</strong></p><ul><li>数据类型系统内包含于的数据类型可划分位四种类别，分别为:</li></ul><ol><li><p>基本类型</p><blockquote><p>被划分为算术类型，包含于两种类型: 整数类型与浮点类型<br>在整数类型内: 各种类型的存储大小与系统的位数和系统的类别有关，但目前通用的以64位为主<br>在浮点类型内: 可将浮点类型分为float-单精度浮点类型，double/long double-双精度浮点类型</p><blockquote><p>后续进行详细介绍</p></blockquote></blockquote></li><li><p>枚举类型</p><blockquote><p>被划分为算术类型，被用于定义在程序种只能赋予其一定的离散整数的变量<br>后续进行详细介绍</p></blockquote></li><li><p>void类型</p><blockquote><p>被划分为类型说明符，类型说明符void用于表明没有可用的值</p></blockquote></li></ol><p><strong>一般用于以下三种情况:</strong></p><ol><li>函数的返回值为空<blockquote><p>C 中有各种函数都不返回值，或者可以说它们返回空<br>不返回值的函数的返回类型为空<br>例如<code>void exit (int status);</code></p></blockquote></li><li>函数参数为空<blockquote><p>C 中有各种函数不接受任何参数<br>不带参数的函数可以接受一个 void<br>例如<code>int rand(void);</code></p></blockquote></li><li>指针指向void<blockquote><p>类型为<code>void *</code>的指针代表对象的地址，而不是类型<br>例如，内存分配函数<code>void *malloc( size_t size );</code><br>返回指向 void 的指针，可以转换为任何数据类型<br>后续进行详细介绍</p></blockquote></li></ol><hr><ol start="4"><li>派生类型<br>包含于: 指针类型，数组类型，结构类型，公用体类型和函数类型<blockquote><p>后续进行详细介绍</p></blockquote></li></ol><ul><li><p>关于聚合类型</p><blockquote><p>数组类型和结构类型被统称为聚合类型<br>函数的类型指的是函数返回值的类型</p></blockquote></li><li><p>在 C 程序语言内可以对数据类型进行转换或强制转换操作</p></li></ul><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>文章先进行正文归纳，再进行笔记归纳</li></ul><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h3><p><strong>对于涉及概念的系统化整理和解析</strong></p><ul><li><p>变量其实只不过是程序可操作的存储区的名称</p></li><li><p>C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局</p><blockquote><p>该范围内的值都可以存储在内存中，运算符可应用于变量上</p></blockquote></li><li><p>基于数据基本类型，有以下几种基本的变量类型:</p></li><li><p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等</p></li></ul><hr><ul><li><p>对于变量的概念，无非就是定义，声明，赋值，以及调用</p></li><li><p>其中声明和定义对于程序员来说是同时进行的，即在声明时就将其定义或不进行定义，只进行声明</p></li><li><p>定义即为为所定义变量分配内存空间</p></li><li><p>定义一个变量，就是告诉编译器在内存的何处创建属于当前被定义变量的存储区域</p><blockquote><p>变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表<br>并且定义变量时所指定的数据类型必须是有效的数据类型<br>在不带初始化的定义中，带有静态存储持续时间的变量会被隐式初始化NULL(所有字节的值皆为0)，其它所有变量的初始值是未定义的</p></blockquote></li><li><p>声明一个变量，变量声明的作用是向编译器保证变量以指定的类型和名称而存在，也可将其称之为专属于该变量的标识符，或变量标识符</p><blockquote><p>所以编译器在不需要知道变量完整细节的情况下也能进行进一步的编译<br>对于变量的声明，或称为将变量赋予专属的标识符，只在编译时有它的意义，在程序链接时编译器需要实际的变量声明</p></blockquote></li><li><p>对于变量声明有两种情况:</p></li></ul><ol><li>需要建立存储空间，例如 <code>int a</code>在声明的同时就建立了存储控件</li><li>不需要建立存储空间，通过使用extern关键字声明变量而不定义它，例如 <code>extern int a</code>其中变量a是可以在别的文件种定义的<blockquote><p>所以除非有extern关键字，否则都是对变量的定义</p></blockquote></li></ol><p><strong>关于 C 的左值(Lvalues)和右值(Rvalues)</strong></p><ul><li>C 中有两种类型的表达式:</li></ul><ol><li><p>左值(Lvalue):</p><blockquote><p>指向内存位置的表达式被称为左值(lvalue)表达式<br>左值可以出现在赋值号的左边或右边</p></blockquote></li><li><p>右值(Rvalue):</p><blockquote><p>术语右值(rvalue)指的是存储在内存中某些地址的数值<br>右值是不能对其进行赋值的表达式<br>也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边</p></blockquote></li></ol><p><strong>用途总结:</strong></p><ol><li>当需要保存数据的时候，需要lvalues</li><li>当需要读取数据的时候，需要rvalues</li></ol><ul><li>lvalues 和 rvalues 角色的相互转换<blockquote><p>根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为 rvalues<br>rvalues 永远不能转换为 lvalues</p></blockquote></li></ul><hr><p><strong>变量的全局变量与局部变量的概念简述:</strong></p><ul><li><p>全局变量就是在任何的函数外，整体的程序内所定义的变量，所以将会在整个程序内生效</p></li><li><p>而局部变量就是在函数内所声明的变量，所以只在函数内生效</p></li><li><p>在定义了全局变量后，在函数内调用该变量的方法:</p></li><li><p>为变量加上<code>extern</code>关键字即可跳过定义，直接使用:</p><blockquote><p><code>extern int a</code></p></blockquote></li></ul><hr><p><strong>全局变量和局部变量在内存中的区别</strong></p><ul><li><p>全局变量保存在内存的全局存储区中，占用静态的存储单元</p></li><li><p>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></li><li><p>C语言经过编译之后将内存分为以下几个区域：</p></li></ul><ol><li>栈(stack): 由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址<blockquote><p>操作方式类似数据结构中的栈</p></blockquote></li><li>堆(heap): 用于程序动态申请分配和释放空间<blockquote><p>C语言中的<code>malloc</code>和<code>free</code>，C++中的<code>new</code>和<code>delete</code>均是在堆中进行的<br>正常情况下，程序员申请的空间在使用结束后应该释放<br>若程序员没有释放空间，则程序结束时系统自动回收<br>注意: 这里的”堆”并不是数据结构中的”堆”</p></blockquote></li><li>全局(静态)存储区: 分为DATA段和BSS段<blockquote><p>DATA段(全局初始化区)存放初始化的全局变量和静态变量<br>BSS段(全局未初始化区)存放未初始化的全局变量和静态变量<br>程序运行结束时自动释放<br>其中BBS段在程序执行之前会被系统自动清0<br>所以未初始化的全局变量和静态变量在程序执行之前已经为0</p></blockquote></li><li>文字常量区: 存放常量字符串<blockquote><p>程序结束后由系统释放</p></blockquote></li><li>程序代码区: 存放程序的二进制代码。</li></ol><ul><li><p>所以C语言中的全局变量和局部变量在内存中是有区别的</p></li><li><p>C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中</p><blockquote><p>并且占用永久性的存储单元<br>局部变量，即自动变量，保存在栈中<br>只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元</p></blockquote></li><li><p>可以分析以下程序的运行结果，以便更直观的去了解其区别:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> k1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k2;</span><br><span class="line">static <span class="keyword">int</span> k3 = <span class="number">2</span>;</span><br><span class="line">static <span class="keyword">int</span> k4;</span><br><span class="line"><span class="keyword">int</span> main( )</span><br><span class="line">&#123;  staticint m1=<span class="number">2</span>, m2;</span><br><span class="line">    inti=<span class="number">1</span>;</span><br><span class="line">    char*p;</span><br><span class="line">    charstr[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    char*<span class="keyword">q</span> = <span class="string">"hello"</span>;</span><br><span class="line">    p= (char *)malloc( <span class="number">100</span> );</span><br><span class="line">    free(p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"栈区-变量地址  i：%p\n"</span>, &amp;i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                p：%p\n"</span>, &amp;p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"              str：%p\n"</span>, str);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                q：%p\n"</span>, &amp;<span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"堆区地址-动态申请：%p\n"</span>, p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"全局外部有初值 k1：%p\n"</span>, &amp;k1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外部无初值 k2：%p\n"</span>, &amp;k2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"静态外部有初值 k3：%p\n"</span>, &amp;k3);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外静无初值 k4：%p\n"</span>, &amp;k4);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态有初值 m1：%p\n"</span>, &amp;m1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态无初值 m2：%p\n"</span>, &amp;m2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"文字常量地址    ：%p, %s\n"</span>,<span class="keyword">q</span>, <span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"程序区地址      ：%p\n"</span>,&amp;main);</span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h3><ul><li><p>这里对于存储类的说明只针对于变量</p></li><li><p>存储类定义 C 程序中变量或函数的范围(可见性)和生命周期</p><blockquote><p>所谓的声明周期与可见性(范围)就是指定变量在程序或函数内所生效的时间，或将其称之为在内存内所产生存在意义的阶段</p></blockquote></li><li><p>这些说明符放置在它们所修饰的类型之前</p><blockquote><p>例如 <code>auto int mouth</code></p></blockquote></li><li><p>C 程序中可用的存储类:</p><blockquote><p>auto<br>register<br>static<br>extern</p></blockquote></li></ul><p><strong>C内各存储类明细:</strong></p><p><strong>auto 存储类</strong></p><ul><li>auto 存储类是所有局部变量默认的存储类</li><li>auto 只能用在函数内，即 auto 只能修饰局部变量</li></ul><p><strong>register 存储类</strong></p><ul><li><p>register 存储类用于定义存储在寄存器中而不是RAM中的局部变量</p><blockquote><p>这意味着变量的最大尺寸等于寄存器的大小(通常是一个词)，且不能对它应用一元的<code>&#39;&amp;&#39;</code>运算符(因为它没有内存位置)</p></blockquote></li><li><p>存在意义</p><blockquote><p>在寄存器只用于需要快速访问的变量时进行使用，比如计数器<br>还应注意的是，定义<code>&#39;register&#39;</code>并不意味着变量将被存储在寄存器中<br>它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制</p></blockquote></li></ul><hr><p><strong>static 存储类</strong></p><ul><li>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁<blockquote><p>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></blockquote></li></ul><ul><li><p>static 修饰符也可以应用于全局变量</p><blockquote><p>当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内</p></blockquote></li><li><p>全局声明的一个 static 变量或方法可以被任何函数或方法调用</p><blockquote><p>只要这些方法出现在跟 static 变量或方法同一个文件中</p></blockquote></li><li><p>即在程序内的任何函数内对任何经由此声明的变量，不会在任何此调用时时进行重置</p></li></ul><p><strong>extern 存储类</strong></p><ul><li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的</li><li>即为当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置</li><li>当有多个文件且定义了一个可以在其它文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用</li><li>可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数</li><li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</li></ul><hr><p><strong>存储类整合说明:</strong></p><ul><li>auto 是局部变量的默认存储类, 限定变量只能在函数内部使用</li><li>register 代表了寄存器变量，不在内存中使用</li><li>static是全局变量的默认存储类,表示变量在程序生命周期内可见</li><li>extern 表示全局变量，即对程序内所有文件可见，类似于Java中的public关键字</li></ul><hr><p><strong>C 语言中全局变量，局部变量，静态全局变量，静态局部变量的区别</strong></p><p><strong>从作用域进行区分:</strong></p><ol><li><p>全局变量具有全局作用域</p><blockquote><p>全局变量只需在一个源文件中定义，就可以作用于所有的源文件<br>当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量</p></blockquote></li><li><p>静态局部变量具有局部作用域</p><blockquote><p>它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在<br>它和全局变量的区别在于全局变量对所有的函数都是可见的<br>而静态局部变量只对定义自己的函数体始终可见</p></blockquote></li><li><p>局部变量也只有局部作用域</p><blockquote><p>它是自动对象(auto)<br>它在程序运行期间不是一直存在，而是只在函数执行期间存在<br>函数的一次调用执行结束后，变量被撤销<br>其所占用的内存也被收回</p></blockquote></li><li><p>静态全局变量也具有全局作用域</p><blockquote><p>它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里<br>不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域<br>这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</p></blockquote></li></ol><p><strong>从分配内存空间来区分</strong></p><ol><li><p>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间</p><blockquote><p>而局部变量在栈里分配空间</p></blockquote></li><li><p>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式</p><blockquote><p>这两者在存储方式上并无不同<br>这两者的区别虽在于，非静态全局变量的作用域是整个源程序<br>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的<br>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效<br>在同一源程序的其它源文件中不能使用它<br>由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br>因此可以避免在其它源文件中引起错误</p></blockquote></li></ol><ul><li><p>静态变量会被放在程序的静态数据存储区(全局可见)中</p><blockquote><p>这样可以在下一次调用的时候还可以保持原来的赋值<br>这一点是它与堆栈变量和堆变量的区别</p></blockquote></li><li><p>变量用static告知编译器，自己仅仅在变量的作用范围内可见</p><blockquote><p>这一点是它与全局变量的区别</p></blockquote></li><li><p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期</p><blockquote><p>把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围<br>因此static 这个说明符在不同的地方所起的作用是不同的，应予以注意</p></blockquote></li></ul><p><strong>其它说明:</strong></p><ul><li>A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度</li><li>B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</li><li>C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见</li><li>D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为: 带”内部存储器”功能的的函数)</li><li>E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针</li></ul><hr><ul><li><p>其它的相关概念与具体的使用在以后实践时会进行相应的补充</p></li><li><p>C语言最大的优势是对于底层硬件结构的管理，其指针和其它缺省变量是最接近于内存的</p></li></ul><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>涉及概念</strong></p><ul><li>数据结构</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><p><strong>未涉及概念</strong></p><ul><li>常量</li><li>运算符</li><li>判断</li><li>循环</li></ul><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><hr><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><strong>C 作用域规则及其概念</strong></p><ul><li><p>所谓的变量作用域，就是变量所能够产生作用的代码块所属区域</p></li><li><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问</p></li><li><p>C 语言中有三个地方可以声明变量:</p></li></ul><ol><li>在函数或块内部的局部变量</li><li>在所有函数外部的全局变量</li><li>在形式参数的函数参数定义中</li></ol><ul><li>相关概念: 局部变量，全局变量和形式参数</li></ul><p><strong>局部变量</strong></p><ul><li>在某个函数或块的内部声明的变量称为局部变量<blockquote><p>它们只能被该函数或该代码块内部的语句使用<br>局部变量在函数外部是不可知的</p></blockquote></li></ul><p><strong>全局变量</strong></p><ul><li><p>全局变量是定义在函数外部，通常是在程序的顶部</p><blockquote><p>全局变量在整个程序生命周期内都是有效的<br>在任意的函数内部能访问全局变量</p></blockquote></li><li><p>全局变量可以被任何函数访问</p><blockquote><p>也就是说，全局变量在声明后整个程序中都是可用的</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li><p>函数的参数，形式参数，被当作该函数内的局部变量</p><blockquote><p>如果与全局变量同名它们会优先使用</p></blockquote></li><li><p>全局变量与局部变量在内存中的区别：</p><blockquote><p>全局变量保存在内存的全局存储区中，占用静态的存储单元<br>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></blockquote></li><li><p>通常使用static修饰符/关键字来定义全局/局部变量</p></li></ul><p><strong>初始化局部/全局变量</strong></p><ul><li>在定义全局或局部变量时需要先对其进行初始化<blockquote><p>初始化局部变量和全局变量<br>当局部变量被定义时，系统不会对其初始化，必须人为/自行的对其初始化<br>定义全局变量时，系统会自动对其初始化<br>初始化即为对其变量进行赋值</p></blockquote></li></ul><p><strong>全局变量自动初始化的值如下所示:</strong></p><table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">‘\0’</td></tr><tr><td align="left">float</td><td align="left">0</td></tr><tr><td align="left">double</td><td align="left">0</td></tr><tr><td align="left">pointer</td><td align="left">NULL</td></tr></tbody></table><ul><li>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果<blockquote><p>比如因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值</p></blockquote></li></ul><hr><h3 id="数据类型-派生类型-函数类型"><a href="#数据类型-派生类型-函数类型" class="headerlink" title="数据类型-派生类型/函数类型"></a>数据类型-派生类型/函数类型</h3><ul><li><p>函数的本质是存储结构化语句的数据类型</p></li><li><p>语句可以由变量或其它任何的数据类型构成</p></li><li><p>还可以说，任何的C程序都是由函数数据类型构成的</p></li><li><p>函数是一组一起执行一个任务的语句</p><blockquote><p>每个C程序都至少有一个函数，即主函数<code>main()</code><br>所有简单的程序都可以定义其他额外的函数<br>还可以把代码划分到不同的函数中<br>如何划分代码到不同的函数中是由人为所的<br>但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的</p></blockquote></li><li><p>函数声明告诉编译器函数的名称，返回类型和参数</p><blockquote><p>函数定义提供了函数的实际主体</p></blockquote></li><li><p>C 标准库提供了大量的程序可以调用的内置函数</p><blockquote><p>例如，函数<code>strcat()</code>用来连接两个字符串，函数<code>memcpy()</code>用来复制内存到另一个位置</p></blockquote></li><li><p>函数还有很多叫法，比如方法，子例程或程序，等等</p></li></ul><p><strong>定义函数的基本语法-C:</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="keyword">function</span><span class="constructor">_name( <span class="params">parameter</span> <span class="params">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body <span class="keyword">of</span> the <span class="keyword">function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li>在 C 语言中，函数由一个函数头和一个函数主体组成<blockquote><p>下面列出一个函数的所有组成部分:</p></blockquote></li></ul><ol><li>返回类型: 一个函数可以返回一个值<blockquote><p><code>return_type</code>是函数返回的值的数据类型<br>有些函数执行所需的操作而不返回值<br>在这种情况下，<code>return_type</code>是关键字<code>void</code></p></blockquote></li><li>函数名称: 这是函数的实际名称<blockquote><p>函数名和参数列表一起构成了函数签名</p></blockquote></li><li>参数: 参数就像是占位符<blockquote><p>当函数被调用时，您向参数传递一个值，这个值被称为实际参数<br>参数列表包括函数参数的类型，顺序，数量<br>参数是可选的，也就是说，函数可能不包含参数</p></blockquote></li><li>函数主体: 函数主体包含一组定义函数执行任务的语句</li></ol><hr><p><strong>函数声明</strong></p><ul><li><p>函数声明会告诉编译器函数名称及如何调用函数</p><blockquote><p>函数的实际主体可以单独定义</p></blockquote></li><li><p>函数声明包括以下几个部分：</p><blockquote><p><code>return_type function_name( parameter list );</code></p></blockquote></li><li><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的</p></li><li><p>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的</p><blockquote><p>在这种情况下，您应该在调用函数的文件顶部声明函数</p></blockquote></li></ul><hr><p><strong>调用函数</strong></p><ul><li><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务</p></li><li><p>当程序调用函数时，程序控制权会转移给被调用的函数</p><blockquote><p>被调用的函数执行已定义的任务，当函数的返回语句被执行时<br>或到达函数的结束括号时，会把程序控制权交还给主程序</p></blockquote></li><li><p>调用函数时，传递所需参数</p><blockquote><p>如果函数返回一个值，则可以存储返回值</p></blockquote></li></ul><hr><p><strong>函数参数</strong></p><ul><li><p>如果函数要使用参数，则必须声明接受参数值的变量</p><blockquote><p>这些变量称为函数的形式参数</p></blockquote></li><li><p>形式参数就像函数内的其他局部变量</p><blockquote><p>在进入函数时被创建，退出函数时被销毁</p></blockquote></li><li><p>当调用函数时，有两种向函数传递参数的方式：</p></li></ul><ol><li>传值调用: 该方法把参数的实际值复制给函数的形式参数<blockquote><p>在这种情况下，修改函数内的形式参数不会影响实际参数</p></blockquote></li><li>引用调用: 通过指针传递方式，形参为指向实参地址的指针<blockquote><p>当对形参的指向操作时，就相当于对实参本身进行的操作</p></blockquote></li></ol><ul><li>默认情况下，C 使用传值调用来传递参数<blockquote><p>一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数</p></blockquote></li></ul><hr><p><strong>内部函数与外部函数</strong></p><ul><li>根据函数能否被其他源文件调用，可以将函数区分为内部函数和外部函数</li></ul><p><strong>内部函数</strong></p><ul><li><p>如果一个函数只能被本文件中其他函数所调用，它称为内部函数</p><blockquote><p>在定义内部函数时，在函数名和函数类型的前面加 static，即<br><code>static 类型名 函数名 (形参表)</code><br>例如，函数的首行：<br><code>static int max(int a,int b)</code></p></blockquote></li><li><p>内部函数又称静态函数</p><blockquote><p>使用内部函数，可以使函数的作用域只局限于所在文件<br>即使在不同的文件中有同名的内部函数，也互不干扰<br>提高了程序的可靠性</p></blockquote></li></ul><p><strong>外部函数</strong></p><blockquote><p>如果在定义函数时，在函数的首部的最左端加关键字 extern<br>则此函数是外部函数，可供其它文件调用<br>如函数首部可以为<br><code>extern int max (int a,int b)</code><br>C 语言规定，如果在定义函数时省略 extern，则默认为外部函数</p></blockquote><ul><li>在需要调用此函数的其他文件中，需要对此函数作声明(即使在本文件中调用一个函数，也要用函数原型来声明)<blockquote><p>在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数</p></blockquote></li></ul><hr><p><strong>内联函数</strong></p><ul><li><p>内联函数是指用inline关键字修饰的函数</p><blockquote><p>在类内定义的函数被默认成内联函数<br>内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质</p></blockquote></li><li><p>内联扩展是用来消除函数调用时的时间开销</p><blockquote><p>它通常用于频繁执行的函数，对于小内存空间的函数非常受益</p></blockquote></li><li><p>使用内联函数的时候要注意:</p><blockquote><p>递归函数不能定义为内联函数<br>内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数<br>内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数<br>对内联函数不能进行异常的接口声明</p></blockquote></li></ul><hr><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><ul><li><p>形参与实参出现在函数中</p></li><li><p>形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用</p></li><li><p>实参出现在主调函数中，进入被调函数后，实参变量也不能使用</p></li></ul><p><strong>关于调用:</strong></p><ul><li><p>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元</p><blockquote><p>因此，形参只在函数内部有效<br>函数调用结束返回主调用函数后则不能再使用该形参变量</p></blockquote></li><li><p>实参可以是常量，变量，表达式，函数等</p><blockquote><p>无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参<br>因此应预先用赋值，输入等办法使参数获得确定值</p></blockquote></li></ul><p><strong>指针影响:</strong></p><ul><li>不是指针类型在内存中位置不同:</li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量<blockquote><p>它们在内存中位于不同的位置，形参将实参的内容复制一份<br>在该函数运行结束的时候形参被释放，而实参内容不会改变</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li>形式参数即为只是作为某种形式而存在于程序种的参数<blockquote><p>此类参数即为未进行赋值或者使用的参数</p></blockquote></li></ul><p><strong>实际参数</strong></p><ul><li><p>实际参数即为已经对其赋值或已经进行使用的参数</p></li><li><p>从字面上理解，所谓形式参数即只只是声明了一个作为参数的变量，并未直接进行赋值使用，而实际参数则相反</p></li><li><p>关于C语言形参与实参的区别:</p><blockquote><p>实参可以是变量，变量与表达式，实参与形参<br>实参与形参类型相同或赋值兼容<br>在调用函数过程中发生的实参与形参之间的数据传递，常称为”虚实结合”</p></blockquote></li></ul><ol><li>在定义函数中制定的形参，在没有出现函数调用时不占用内存中的存储单元<blockquote><p>在函数调用时才分配内存</p></blockquote></li><li>将实参的值传递给形参</li><li>在执行函数时，由于形参已经有值<blockquote><p>可以用形参进行运算</p></blockquote></li><li>通过return语句将函数值返回，若无返回值，则无return</li><li>调用结束后，形参被释放掉，实参保留原值(单向传值)</li></ol><hr><ul><li>可能还需要对其进行大量的补充，实践时会进行说明</li></ul><hr><ul><li>数据类型-派生类型/数组</li><li>数据类型-派生类型/指针</li><li>数据类型-派生类型/结构体类型</li><li>数据类型-派生类型/共用体类型</li><li>数据类型-派生类型/函数类型</li></ul><hr><h2 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h2><h3 id="数据类型-派生类型-数组"><a href="#数据类型-派生类型-数组" class="headerlink" title="数据类型-派生类型/数组"></a>数据类型-派生类型/数组</h3><ul><li><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合</p><blockquote><p>数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量</p></blockquote></li><li><p>数组用于存放相同类型的变量，还可以称其本质即为变量</p></li><li><p>声明一个数组，就相当于声明一个变量的集合，并且此集合内的变量通常为相同的类型</p><blockquote><p>比如声明一个number[100]，就相当于声明了100个名为number的变量<br>而这些变量用number[1],number[2],…,number[100]来进行标识，即数组中的特定元素可以通过索引来访问</p></blockquote></li><li><p>所有的数组都是由连续的内存位置组成的，其中最低的地址对应第一个元素，而最高的地址对应最后一个元素</p></li><li><p>数组于内存间的结构图片:</p></li></ul><hr><ul><li><p>声明数组的基本语法</p><blockquote><p>C 中要声明一个数组，需要指定数组内元素的类型和元素的数量<br><code>type arryName [ arraySize ];</code></p></blockquote></li><li><p>此语法所声明的数组被称之为一维数组，<code>arrySize</code>必须是一个大于零的整数常量</p><blockquote><p>而type可以是任何有效的C 数据类型<br>例如 <code>int serow[10];</code></p></blockquote></li><li><p>初始化数组(给数组进行赋值):</p><blockquote><p><code>type arryName [ arraySize ] = {进行线性赋值，用&#39;,&#39;分隔}</code><br><code>{}</code>之中值的数目不能超过<code>[]</code>间所定义的元素枢数目</p></blockquote></li><li><p>数组的赋值规则与物理内存地址的定义与赋值规则是完全线性的</p></li><li><p>访问数组内元素:</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> serow = unit[<span class="number">9</span>]; <span class="comment">//将数组unit中的第10个元素的值赋给serow变量</span></span><br></pre></td></tr></table></figure><hr><p><strong>至此</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型概念理解-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>变量-1</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E5%8F%98%E9%87%8F-1/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E5%8F%98%E9%87%8F-1/</id>
    <published>2020-03-09T05:12:41.000Z</published>
    <updated>2020-03-09T05:29:31.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>变量概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-变量"><a href="#计算机科学-变量" class="headerlink" title="计算机科学-变量"></a>计算机科学-变量</h2><ul><li>变量-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li><p>基本概念</p></li><li><p>概念整合</p></li><li><p>操作原理</p></li><li><p>标识原理</p></li><li><p>类型明细</p></li><li><p>内存分配</p></li><li><p>别名实现</p></li><li><p>参数明细</p></li><li><p>作用域与生命周期</p></li><li><p>线性表</p></li><li><p>数据结构-顺序存储结构</p></li><li><p>线性存储原理</p></li><li><p>堆栈</p></li></ul><hr><p><strong>任何数据类型与概念皆可称为变量，而变量也可以数据类型区分</strong></p><p><strong>函数结构化了变量，或称函数由变量构成</strong></p><hr><h2 id="变量概念明细"><a href="#变量概念明细" class="headerlink" title="变量概念明细:"></a>变量概念明细:</h2><ul><li>文字内关于变量的概念特指计算机科学内的变量概念</li><li>与数学间变量的概念会加以区分</li></ul><hr><p><strong>概述:</strong></p><ul><li>变量用于具体指向存储器内的存储空间的数据类型<blockquote><p>并且存储于变量内的数据是跟随程序的变化而变化的，这里类似于数学种变量的概念<br>每个不同的变量在计算机内所占有硬件的资源(存储空间或内存)都是有对应标识的(此标识概念被归纳于变量定义的概念内)</p></blockquote></li></ul><hr><p><strong>详细描述:</strong></p><ul><li>在计算机内，任何被人为定义的任何变量概念都是为了用于指向电脑内存储器的存储空间<blockquote><p>或称为，在计算机科学上，变量可以指在电脑存储器里存在值的被命名的存储空间</p></blockquote></li><li>变量所存储的内容被包含于变量的定义内，而变量名则是对于该变量所占用物理空间或称区域的命名与标识</li></ul><p><strong>语言区别:</strong></p><ul><li><p>各个程序语言之间对于变量的概念有不同的定义，但本质上都是相同的</p><blockquote><p>变量通常是可被修改的，即可以用来表示可变的状态<br>这是许多语言(如Java)的基本概念之一<br>有的语言可能定义其它术语，如C语言的左值来精确地表示这里的(可能匿名的)存储空间的概念<br>而”变量”则在变量名的意义上被强调<br>而还有些编程语言中的变量必须带有类型</p></blockquote></li><li><p>当某个已宣告变量开始使用，解释器或编译器通常会设置一个空间来存储所给出的值</p><blockquote><p>稍后该变量不再使用时，那些空间可以回收</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>也有观点认为，变量应该和数学的原意/义一致<blockquote><p>不需要允许它储存的值可变，不需要有能力表示可变状态<br>Haskell的类型变量仍然符合这个含义</p></blockquote></li></ul><hr><h2 id="概念理解整合"><a href="#概念理解整合" class="headerlink" title="概念理解整合"></a>概念理解整合</h2><ul><li>变量(Variable，scalar)</li></ul><p><strong>在程序设计中的变量所涉及的概念:</strong></p><ul><li>变量是指一个包含部分已知或未知数值或信息(即一个值)之/的存储地址<blockquote><p>以及相对应之符号名称(识别字)<br>通常使用变量名称引用存储值</p></blockquote></li></ul><p><strong>别名的意义(接上文识别字的概念):</strong></p><ul><li>用以将名称和内容分开，以能让被使用的名称独立于，所表示的精确消息之外</li><li>电脑源代码中的识别字能在运行期间绑扎一个值，且该变量的值可能在程序运行期间改变<blockquote><p>程序设计中的变量不一定能直接对应到数学中所谓的变量之概念<br>在程序设计中，变量的值不一定要为方程或数学公式之一部分</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>计算机变量与数学变量的区别:<blockquote><p>程序设计中的变量可使用在一段可重复的程序: 在一处赋值，然后使用于另一处，接着在一次赋值，且以相同方式再使用一次(涉及迭代概念)<br>程序设计中的变量通常会给定一个较长的名称，以描述其用途<br>而数学中的变量通常较为简洁，只给定一、两个字母，以方便抄写及操作</p></blockquote></li></ul><p><strong>别名简述:</strong></p><p><strong>变量别名/命名的概念:</strong></p><ul><li><p>一个变量的存储地址可以被不同的识别字所引用，这种情况称之为别名</p><blockquote><p>使用其中一个识别字为变量赋值，将会改变透过另一个识别字访问的值</p></blockquote></li><li><p>编译器必须将代表变量的名称替代成该数据所在的实际地址</p><blockquote><p>变量的名称，类型及地址通常会维持固定<br>但该地址所存储之数据于程序运行期间则可能会改变</p></blockquote></li></ul><hr><h2 id="变量各级操作的原理"><a href="#变量各级操作的原理" class="headerlink" title="变量各级操作的原理"></a>变量各级操作的原理</h2><h3 id="对于变量的使用"><a href="#对于变量的使用" class="headerlink" title="对于变量的使用:"></a>对于变量的使用:</h3><ul><li><p>又称引用变量</p><blockquote><p>涉及到标识符的概念</p></blockquote></li><li><p>标识符即为字符(人为输入的，用于识别所定义，或称所存在变量的字符串/数据类型)</p></li><li><p>用标识符引用变量能对变量进行访问，从而读出变量的值，改变变量的值</p><blockquote><p>或者改变变量的属性(如访问权限、状态锁定等)</p></blockquote></li><li><p>例如:</p><blockquote><p>一个变量用标识符<code>unit_serow</code>来引用<br>设定这个变量的值为1000<br>如果该变量同时也用<code>标识符g</code>来引用<br>然后通过<code>标识符g</code>将变量值改变为2000<br>那么读取<code>unit_serow</code>的值就是2000而不是1000</p></blockquote></li></ul><hr><ul><li><p>如果某种编程语言只允许同一个变量用一个标识符引用</p><blockquote><p>那么讨论”该变量的名字”就是有意义的，否则将其称之为”该变量的名字之一”</p></blockquote></li><li><p>例如:</p><blockquote><p>在前面的那个例子当中，<code>unit_serow</code>是这个变量的名字之一<br>而<code>标识符g</code>是这个变量的另外一个名字</p></blockquote></li></ul><hr><h3 id="对于变量的操作"><a href="#对于变量的操作" class="headerlink" title="对于变量的操作:"></a>对于变量的操作:</h3><ul><li><p>还可称为对于变量的管理</p></li><li><p>在指令式编程语言中</p><blockquote><p>变量的值通常能够随时访问或重新赋值</p></blockquote></li><li><p>但在逻辑式编程语言中</p><blockquote><p>根据参数透明的需求，变量被绑定到表达式并且在它的整个生命周期中保持同一个值</p></blockquote></li><li><p>在指令式编程语言中</p><blockquote><p>同样的行为用常量来表达，它和通常的变量存在反差</p></blockquote></li></ul><p><strong>不同语言的区别:</strong></p><ul><li>根据编程语言的类型系统的不同<blockquote><p>变量可能只存储一种特定的数据类型(如整型或字符串型)</p></blockquote></li><li>而另外一种情况，变量的数据类型能根据当前赋值而改变<blockquote><p>从而允许单个变量存储该编程语言支持的任何数据类型</p></blockquote></li></ul><hr><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li><p>变量所涉及的不同类型</p></li><li><p>在静态类型语言中</p><blockquote><p>如Java或ML等<br>每个都变量有一个类型，也就是说只有给定种类的值能存储到该变量中<br>一个基本类型的变量只能保存基本类型的值<br>一个类类型的变量能保存空值NULL，或者保存该类型或其子类型的对象<br>一个接口类型的变量能保存空值NULL，或者该接口的任何一个实现<br>一个数组类型能保存空值NULL或者一个数组</p></blockquote></li><li><p>在动态类型语言中</p><blockquote><p>如Python等<br>便是是作为值而出现的，而不是变量来携带类型信息<br>在Common Lisp中，这两种情况同时存在:<br>变量在编译时具有一个类型(如果没有声明，就假设这个类型为超类型T)<br>值也有具有一个类型，该类型可以在运行时进行检查和识别</p></blockquote></li><li><p>变量的类型也允许在编译时多态决定</p><blockquote><p>但是，这和面向对象的函数调用(在C++中称为虚函数)的多态不同</p></blockquote></li><li><p>变量常常保存简单的数据，如整数和字符串</p><blockquote><p>但有些程序设计语言允许变量同时表示多种数据类型<br>这些语言一般也允许函数参数多态<br>其函数对变量的操作可同时适用于多种数据类型</p></blockquote></li><li><p>例如:</p><blockquote><p><code>函数length</code>可以求一个列表的长度<br>如果length的类型签名中包含一个类型变量，就可以实现参数多态<br>这样，求列表中的元素个数就与列表元素的类型无关了</p></blockquote></li></ul><hr><h3 id="变量的参数概念"><a href="#变量的参数概念" class="headerlink" title="变量的参数概念"></a>变量的参数概念</h3><ul><li><p>函数的形式参数也被称为变量</p></li><li><p>如下的C++代码段：</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> AddTwo(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddTwo(<span class="number">5</span>);  <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure><ul><li>其中变量x是”形参”<blockquote><p>因为当函数被调用时会被给定一个值</p></blockquote></li><li>整数5是”实参”<blockquote><p>它给x一个值</p></blockquote></li><li>在多数语言中，函数参数具有局部的作用域<blockquote><p>这里的变量x只能在<code>AddTwo函数</code>中有效(尽管如此，其他函数也可以使用自己的变量x)</p></blockquote></li></ul><hr><h3 id="变量所对应的内存-底层概念"><a href="#变量所对应的内存-底层概念" class="headerlink" title="变量所对应的内存-底层概念"></a>变量所对应的内存-底层概念</h3><ul><li>线性存储结构(堆栈原理)示意图:<blockquote><p>线性表的顺序存储示意图</p></blockquote></li></ul><img src="/images/内存-1.png" width="40%" height="40%"><hr><ul><li><p>变量的内存分配</p></li><li><p>变量的内存空间分配和它们值的表示方法是多种多样的，这种区别体现在语言之间</p><blockquote><p>也体现在给定语言的内部使用上<br>很多语言都实现了局部变量的空间分配方式<br>局部变量保存在调用堆栈上，其生存周期维持在单个函数中，函数返回时这些内存会自动被回收(更一般的讲，变量的名字是和一些特定的连续内存块的地址绑定，对变量的操作其实是对相应的内存块进行操作)<br>对于巨大或者编译时不知道大小的数据，更常用的方法是使用”引用”<br>这时记录是值的地址而不是值本身，它们是从一种被称为栈的内存池中分配的</p></blockquote></li><li><p>绑定的变量具有值，一个抽象的值</p><blockquote><p>在程序执行时，变量的值用计算机内存中存储的一些数据对象来表示<br>程序，或者说运行时环境，必须为每个数据对象设置内存<br>由于内存是有限的<br>为了安置每一个数据对象，当数据对象不再表示某个变量的值时，相应的内存会被回收并重新使用</p></blockquote></li><li><p>在堆中分配的对象必须被释放掉，特别是当对象不再被需要时</p><blockquote><p>在具有垃圾回收机制的语言(如C#、Java和Lisp)中<br>当变量出了其作用域再也不能被引用时运行环境会自动地回收对象<br>在不具有垃圾回收机制的语言当中<br>如C语言，程序(程序员)必须显式地分配内存，而且用完之后还要释放内存<br>如果没有这样做会造成内存泄漏<br>在这种情况下，程序运行过程中堆会逐渐消耗，最终因为内存耗尽而崩溃</p></blockquote></li><li><p>当一个变量指向动态创建的数据结构时</p><blockquote><p>可能其中一些部分只能通过变量间接的访问<br>在这种环境下，垃圾回收器(或者类似的语言特性)必须处理当变量回收时只有一部分内存能够获得的情况</p></blockquote></li></ul><hr><h3 id="变量命名的原理"><a href="#变量命名的原理" class="headerlink" title="变量命名的原理"></a>变量命名的原理</h3><ul><li><p>即为变量的命名规范</p></li><li><p>与数学当中的量不同，程序设计所用的变量和常量通常都采用多字符的名字，如<code>count</code>或者<code>size</code></p><blockquote><p>而单个字符的名字一般仅用于辅助性的变量，如<code>i</code>，<code>j</code>，<code>k</code>常作为数组索引的变量</p></blockquote></li><li><p>一些命名规范是作为语法在语言层面强制执行的</p><blockquote><p>在大多数语言当中，变量名不能以数字开头，不能包含空格符<br>而标点符号是否允许存在在变量名当中就要视具体语言而定了<br>很多语言仅仅允许<code>下划线&#39;_&#39;</code>存在在变量名当中，而禁止其他所有的标点符号<br>而有些编程语言，特殊字符作为前缀或后缀添加在变量标识符当中来表明变量的类型<br>变量名的大小写敏感性也要视具体语言而定<br>大多数现代语言是大小写敏感的，一些较老的语言则不敏感<br>一些语言保留特定形式的变量名用来内部使用<br>在很多语言中，以两根下划线开头<code>__</code>的变量名常充当这种角色</p></blockquote></li><li><p>在语言语法基本的限制以外，进一步的命名风格规范也很有必要</p><blockquote><p>在机器码层面，是不会使用变量名的<br>所以计算机并不关心是否采用了准确的名字<br>正因为如此，变量名完全是作为程序员的工具而存在<br>借助这个工具程序员能更容易的编写和理解程序<br>程序员通常创建编码规范，并且坚持这些规范<br>帮助对变量命名甚至提供精确的命名规划。较短的名字便于输入<br>但是描述能力较差<br>较长的名字使程序更容易读懂，变量的意图更容易理解<br>尽管如此，冗长的变量名也可能会导致更难理解的代码</p></blockquote></li></ul><hr><p><strong>不同情况下命名规范的区别:</strong></p><ul><li><p>在源代码中</p><blockquote><p>在源代码中，变量名是将变量和内存地址绑定的一种方式<br>变量值以数据对象的形式存储在相应的地址内<br>这样该数据对象就能通过变量的名字进行访问和修改了</p></blockquote></li><li><p>在电子表格中</p><blockquote><p>在电子表格中，一个单元格可能包含参考其他单元格的公式<br>这种被参考的单元格就是一种形式的变量<br>它的值就是被参考的单元格的值</p></blockquote></li></ul><hr><h3 id="变量的作用域和生存周期"><a href="#变量的作用域和生存周期" class="headerlink" title="变量的作用域和生存周期"></a>变量的作用域和生存周期</h3><p><strong>变量作用于生存周期域的概念:</strong></p><ul><li><p>变量的作用域表示变量在原程序的文本中能被使用的范围</p><blockquote><p>变量的生存周期表示变量在程序运行过程中具有实际意义的值的时间范围<br>变量的作用域事实上是变量名字的性质<br>而变量的生存周期是变量本身是性质</p></blockquote></li><li><p>变量名字的作用域会影响它的生存周期</p></li><li><p>作用域是变量语法方面的性质</p><blockquote><p>多数语言对每一个变量(和其他名目实体)定义明确的作用域<br>这些作用域在同一个程序中可能不同<br>变量的作用域是指程序中的特定区域，在这些区域中，该变量的名字是有意义的并且变量是”可见的”<br>在进入作用域时，变量通常开始它的生命周期<br>而在离开作用域时，变量往往结束了它的生命周期</p></blockquote></li><li><p>例如:</p><blockquote><p>某个变量的语法作用域仅在特定的语句块或者子程序中<br>只有在某个函数中能访问的变量则被称为局部变量<br>在程序的任何一个地方都能引用的变量被称为全局变量</p></blockquote></li><li><p>生存周期，则是变量在运行时的性质</p><blockquote><p>在运行时，每次变量与值的绑定都具有自己的生存周期<br>绑定的生存周期是程序执行过程中的一段时间<br>在这段时间内，变量始终被关联到相同的值或者内存位置<br>在闭包的情况中，运行中的程序可能进入和离开某个生存周期很多次</p></blockquote></li><li><p>在一些代码段中，在一个变量的作用域中可能未被赋值，或者它的值已经被销毁掉了</p><blockquote><p>这类变量常被称为”生存周期外”或者”未绑定”<br>在很多语言中，试图使用未绑定的变量是一个错误<br>在其他语言中，这种行为会产生不可预期的结果，这样的变量可能被分配一个新的值<br>与之对照的是，一个变量绑定到一个超过他作用域的生存周期是被允许的<br>如Lisp的闭包和C语言的静态局部变量<br>当程序再次执行到变量的作用域时<br>变量能再次被使用，但还保持上一次的值</p></blockquote></li><li><p>为了提高空间效率，变量需要的存储空间可能要等到变量第一次使用时才申请</p><blockquote><p>不再使用后就删除<br>为了避免浪费空间，如果变量声明了但不实际使用<br>编译器通常会向程序员发出警告</p></blockquote></li><li><p>使变量的作用域尽可能的小，被认为是一个好的编程方式</p><blockquote><p>这样程序的不同部分就不会因为意外的改变对方的变量而互相影响了<br>实现上述目标的通常技术是让程序的不同部分使用不同名字空间<br>或者通过动态变量作用使用各自的私有变量</p></blockquote></li><li><p>很多程序设计语言使用保留的值(如NULL)表示没有初始化的变量</p></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下参考资料皆源于中文维基</strong></p><ul><li><p>CN-分类:变量(<a href="https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</a>)</p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</code></p></blockquote></li><li><p>CN-分类:计算机编程<a href="https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B</code></p></blockquote></li><li><p>CN-变量<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8</code></p></blockquote></li><li><p>CN-变量 (程序设计)<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)</code></p></blockquote></li></ul><hr><h2 id="补充内容-C-C"><a href="#补充内容-C-C" class="headerlink" title="补充内容-C/C++"></a>补充内容-C/C++</h2><ul><li>C/C++内变量的意义与应用<blockquote><p>见下一篇文章</p></blockquote></li></ul><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><ul><li><p>相对于编程语言(程序语言)</p></li><li><p>调用各种函数，利用正确的逻辑，来构成一个完整的程序</p></li></ul><p><strong>大体逻辑:</strong></p><ul><li><p>在函数外，也就是整个程序的内部可以定义各种常量</p><blockquote><p>然后定义各种函数，函数内定义各种变量，由变量构成各种语句<br>所谓的函数就是存储这些由变量构成的语句的区块(块结构)</p></blockquote></li><li><p>一个函数便可以称之为一个程序，或是一个功能</p><blockquote><p>之后再由若干个函数来构成一个完整的程序<br>每个函数中都应当有返回值</p></blockquote></li><li><p>所谓的常量，就是在程序当中，可以被任何函数所调用的数据类型</p></li><li><p>调用就是(即为)使用，函数就是方法，指针就是指针，用来指向某种数据类型(函数，变量等)并直接调用</p></li></ul><hr><ul><li>数据类型构建了变量与表达式</li><li>变量与表达式构建了函数</li><li>函数构建了各级功能</li><li>各级功能构建了完整的程序</li><li>其中在构建各个不同级次的程序时需要完整且正确的逻辑</li><li>在函数内的表达式与变量亦是如此</li><li>表达式，变量与函数都可以被合称为数据类型，包括指针或空值</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;变量概念理解-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>NCRE-1</title>
    <link href="https://unit-serow.github.io/2020/03/08/NCRE-1/"/>
    <id>https://unit-serow.github.io/2020/03/08/NCRE-1/</id>
    <published>2020-03-08T06:24:42.000Z</published>
    <updated>2020-03-09T05:29:55.353Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>基础概念-数据结构与算法</strong></center><a id="more"></a><h2 id="NCRE-1"><a href="#NCRE-1" class="headerlink" title="NCRE-1"></a>NCRE-1</h2><hr><h3 id="公共基础知识-1"><a href="#公共基础知识-1" class="headerlink" title="公共基础知识-1"></a>公共基础知识-1</h3><ul><li><p>网课随堂笔记</p></li><li><p>二级公共基础知识-数据结构与算法</p></li></ul><hr><p><strong>数据结构与算法</strong></p><ul><li><p>包含内容于:</p><blockquote><p>算法复杂度<br>数据结构的概念<br>栈<br>二叉树的遍历<br>二分法查找</p></blockquote></li><li><p>涉及概念:</p><blockquote><p>算法的概念，算法时间复杂度及空间复杂度的概念<br>数据结构的定义，数据逻辑结构及物理结构的定义<br>栈的定义及其运算，线性链表的存储方式<br>树与二叉树的概念，二叉树的基本性质，完全二叉树的概念，二叉树的遍历<br>二分查找法<br>冒泡排序法</p></blockquote></li></ul><p>–</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h3><ul><li><p>计算机解题的过程实际上是在实施某种算法，这种算法称为计算机算法</p></li><li><p>算法即为为解决任何问题而产生出的必要方法，语言，思维或逻辑的本质也可称为算法</p></li><li><p>算法的基本特征：可行性，确定性，有穷性，拥有足够的情报</p></li></ul><p><strong>算法的基本要素:</strong></p><ol><li>算法中对数据的运算和操作</li></ol><ul><li><p>一个算法由两种基本要素组成：</p><blockquote><p>一是对数据对象的运算和操作<br>二是算法的控制结构</p></blockquote></li><li><p>在一般的计算机系统中，基本的运算和操作有以此四类：算术运算，逻辑运算，关系运算和数据传输</p></li></ul><ol start="2"><li>算法的控制结构：<blockquote><p>算法中各操作之间的执行顺序称为算法的控制结构</p></blockquote></li></ol><ul><li><p>描述算法的工具通常有：</p><blockquote><p>传统的流程图，N-S结构化流程图，算法描述语言等</p></blockquote></li><li><p>一个算法一般都可以用顺序，选择，循环3种基本控制结构组合而成</p></li></ul><hr><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>算法复杂度包括算法时间复杂度及空间复杂度的概念</li></ul><ol><li>算法的时间复杂度<blockquote><p>算法的时间复杂度是指执行算法所需要的计算工作量<br>同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行，效率均不同<br>这表明使用绝对的时间单位衡量算法的效率是不合适的<br>撇开这些与计算机硬件，软件有关的因素，可以认为一个特定算法”运行工作量”的大小，只依赖于问题的规模(通常用整数n表示)，它是问题规模的函数<br>即为<br><code>算法的工作量=f(n)</code></p></blockquote></li></ol><p>2.算法的空间复杂度</p><blockquote><p>算法的空间复杂度是指执行这个算法所需要的内存空间<br>一个算法所占用的存储空间包括算法程序所占的空间<br>输入的初始数据所占的存储空间以及算法执行过程中所需要的额外空间<br>其中额外空间包括算法程序执行过程中的工作单元以及某种数据结构所需要的附加存储空间<br>如果额外空间量相对于问题规模来说是常数，则称该算法是原地工作的<br>在许多实际问题中，为了减少算法所占的存储空间，通常采用压缩存储技术，以便尽量减少不必要的额外空间</p></blockquote><ul><li>算法的工作量用算法所执行的基本运算次数来计算，而算法所执行的基本运算次数是问题规模的函数，即算法的工作量=f(n)<blockquote><p>n为问题规模</p></blockquote></li></ul><hr><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><ul><li><p>数据的逻辑结构和存储结构的概念</p></li><li><p>数据结构作为计算机的一门学科，主要研究和讨论以下三个方面：</p></li></ul><ol><li>数据集合中个数据元素之间所固有的逻辑关系，即数据的逻辑结构</li><li>在对数据元素进行处理时，各数据元素在计算机中的存储关系，即数据的存储结构</li><li>对各种数据结构进行的运算</li></ol><ul><li><p>数据结构基本概念：</p><blockquote><p>数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称<br>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理<br>数据对象：是性质相同的数据元素的集合，是数据的一个子集</p></blockquote></li><li><p>数据的逻辑结构是对数据元素之间的逻辑关系的描述</p><blockquote><p>它可以用一个数据元素的集合和定义在此集合中的若干关系来表示<br>数据的逻辑结构有两个要素：<br>一是数据元素的集合，通常记为D<br>二是D上的关系，它反映了数据元素之间的前后件关系，通常记为R</p></blockquote></li><li><p>一个数据结构可以表示成：<code>B=(D,R)</code></p><blockquote><p>其中B表示数据结构<br>为了反映D中各数据元素之间的前后件关系，一般用二元组来表示</p></blockquote></li><li><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构(也称数据的物理结构)</p></li><li><p>由于数据元素在计算机存储空间中的位置关系可能与逻辑关系不同</p><blockquote><p>因此，为了表示存放在计算机存储空间中的各数据元素之间的逻辑关系(即前后件关系)<br>在数据的存储结构中，不仅要存放各数据元素的信息，还需要存放各数据元素之间的前后件关系的信息</p></blockquote></li><li><p>一种数据的逻辑结构根据需要可以表示成多种存储结构</p><blockquote><p>常用的存储结构有顺序，链接，索引等存储结构<br>而采用不同的存储结构，其数据处理的效率是不同的<br>因此，在进行数据处理时，选择合适的存储结构是很重要的</p></blockquote></li></ul><hr><h3 id="线性结构与非线性结构"><a href="#线性结构与非线性结构" class="headerlink" title="线性结构与非线性结构"></a>线性结构与非线性结构</h3><ul><li><p>根据数据结构中各数据元素之间前后件关系的复杂程度</p><blockquote><p>一般将数据结构分为两大类型：线性结构与非线性结构</p></blockquote></li><li><p>如果一个非空的数据结构满足下列两个条件：</p></li></ul><ol><li>有且只有一个根结点</li><li>每一个结点最多有一个前件，也最多有一个后件<blockquote><p>则称该数据结构为线性结构<br>线性结构又称线性表<br>在一个线性结构中插入或删除任何一个结点后还应是线性结构<br>如果一个数据结构不是线性结构，则称之为非线性结构</p></blockquote></li></ol><ul><li>空的数据结构被归于线性结构还是非线性结构的条件:<blockquote><p>一个空的数据结构究竟是属于线性结构还是属于非线性结构，这要根据具体情况来确定<br>如果对该数据结构的算法是按线性结构的规则来处理的，则属于线性结构<br>否则属于非线性结构</p></blockquote></li></ul><hr><h2 id="栈及线性链表"><a href="#栈及线性链表" class="headerlink" title="栈及线性链表"></a>栈及线性链表</h2><h3 id="栈及其基本运算"><a href="#栈及其基本运算" class="headerlink" title="栈及其基本运算"></a>栈及其基本运算</h3><ul><li>涉及栈的运算</li></ul><ol><li>栈的基本概念<blockquote><p>栈是限定只在一端进行插入与删除的线性表，通常称插入，删除的这一端为栈顶，另一端为栈底<br>当表中没有元素时称为空栈<br>栈顶元素总是后被插入的元素，从而也是最先被删除的元素<br>栈底元素总是最先被插入的元素，从而也是最后才能被删除的元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据的</li></ul><ol start="2"><li>栈的顺序存储及其运算</li></ol><ul><li>用一维数组<code>S(1 : m)</code>作为栈的顺序存储空间，其中m为最大容量<blockquote><p>在栈的顺序存储空间S<code>(1∶m)</code>中<br><code>S(bottom)</code>为栈底元素，<code>S(top)</code>为栈顶元素<br><code>top=0</code>表示栈空<br><code>top=m</code>表示栈满</p></blockquote></li></ul><p><strong>栈的基本运算</strong></p><ul><li>可将其归纳为三种: 入栈，退栈与读栈顶元素</li></ul><ol><li><p>入栈运算：入栈运算是指在栈顶位置插入一个新元素</p><blockquote><p>首先将栈顶指针加一(即top加1)，然后将新元素插入到栈顶指针指向的位置<br>当栈顶指针已经指向存储空间的最后一个位置时，说明栈空间已满，不可能再进行入栈操作<br>这种情况称为栈”上溢”错误</p></blockquote></li><li><p>退栈运算：退栈是指取出栈顶元素并赋给一个指定的变量</p><blockquote><p>首先将栈顶元素(栈顶指针指向的元素)赋给一个指定的变量，然后将栈顶指针减一(即top减1)<br>当栈顶指针为0时，说明栈空，不可进行退栈操作<br>这种情况称为栈的”下溢”错误</p></blockquote></li><li><p>读栈顶元素：读栈顶元素是指将栈顶元素赋给一个指定的变量</p><blockquote><p>这个运算不删除栈顶元素，只是将它赋给一个变量，因此栈顶指针不会改变<br>当栈顶指针为0时，说明栈空，读不到栈顶元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据，但是出栈方式有多种选择</li></ul><hr><h3 id="线性链表的基本概念"><a href="#线性链表的基本概念" class="headerlink" title="线性链表的基本概念"></a>线性链表的基本概念</h3><ul><li><p>涉及结点的组成</p></li><li><p>在链式存储方式中，要求每个结点由两部分组成：</p><blockquote><p>一部分用于存放数据元素值，称为数据域<br>另一部分用于存放指针，称为指针域<br>其中指针用于指向该结点的前一个或后一个结点(即前件或后件)</p></blockquote></li><li><p>链式存储方式既可用于表示线性结构，也可用于表示非线性结构</p></li></ul><p><strong>线性链表</strong></p><ul><li>线性表的链式存储结构称为线性链表<blockquote><p>在某些应用中，对线性链表中的每个结点设置两个指针<br>一个称为左指针，用以指向其前件结点<br>另一个称为右指针，用以指向其后件结点<br>这样的表称为双向链表</p></blockquote></li></ul><p><strong>带链的栈</strong></p><ul><li><p>栈也是线性表，也可以采用链式存储结构</p><blockquote><p>带链的栈可以用来收集计算机存储空间中所有空闲的存储结点<br>这种带链的栈称为可利用栈</p></blockquote></li><li><p>在链式结构中，存储空间位置关系与逻辑关系:</p><blockquote><p>在链式存储结构中，存储数据结构的存储空间可以不连续<br>各数据结点的存储顺序与数据元素之间的逻辑关系可以不一致<br>而数据元素之间的逻辑关系是由指针域来确定的</p></blockquote></li></ul><hr><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树与二叉树及其基本性质"><a href="#树与二叉树及其基本性质" class="headerlink" title="树与二叉树及其基本性质"></a>树与二叉树及其基本性质</h3><ul><li><p>涉及树及二叉树的性质</p></li><li><p>误区警示: 满二叉树也是完全二叉树，而完全二叉树一般不是满二叉树</p></li><li><p>结构示意图:</p></li></ul><img src="/images/二叉树-1.png" width="40%" height="40%"> <img src="/images/二叉树-2.png" width="40%" height="40%"><hr><p><strong>树的基本概念</strong></p><ul><li>树(tree)是一种简单的非线性结构<blockquote><p>在树结构中，每一个结点只有一个前件，称为父结点<br>没有前件的结点只有一个，称为树的根结点<br>每一个结点可以有多个后件，它们称为该结点的子结点<br>没有后件的结点称为叶子结点</p></blockquote></li></ul><ul><li>在树结构中，一个结点所拥有的后件个数称为该结点的度<blockquote><p>叶子结点的度为0<br>在树中，所有结点中的最大的度称为树的度</p></blockquote></li></ul><p><strong>二叉树的定义及其基本性质</strong></p><p><strong>二叉树的定义</strong></p><ul><li><p>二叉树是一种很有用的非线性结构</p></li><li><p>具有以下两个特点:</p><blockquote><p>1-非空二叉树只有一个根结点<br>2-每一个结点最多有两棵子树，且分别称为该结点的左子树和右子树</p></blockquote></li><li><p>由以上特点可以看出:</p><blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树（左子树或右子树）也均为二叉树<br>而树结构中的每一个结点的度可以是任意的<br>另外，二叉树中的每个结点的子树被明显地分为左子树和右子树</p></blockquote></li><li><p>在二叉树中，一个结点可以只有左子树而没有右子树</p><blockquote><p>也可以只有右子树而没有左子树<br>当一个结点既没有左子树也没有右子树时，该结点即为叶子结点</p></blockquote></li></ul><hr><p><strong>二叉树的基本性质</strong></p><ul><li><p>二叉树具有以下几个性质：</p><blockquote><p>性质1：在二叉树的第k层上，最多有<code>2k-1 (k≥1)</code>个结点<br>性质2：深度为m的二叉树最多有<code>2m-1</code>个结点<br>性质3：在任意一棵二叉树中，度为0的结点(即叶子结点)总是比度为2的结点多一个<br>性质4：具有n个结点的二叉树，其深度至少为<code>[log2n]+1</code><br>其中[log2n]表示取log2n的整数部分<br>因为文本无法输入下标，所以本文中所有log2n都用于表示已2为底n的对数</p></blockquote></li><li><p>在二叉树的遍历中，无论是前序遍历，中序遍历还是后序遍历，二叉树的叶子结点的先后顺序都是不变的</p></li></ul><hr><p><strong>满二叉树与完全二叉树</strong></p><p><strong>满二叉树</strong></p><ul><li><p>满二叉树是指这样的一种二叉树:</p><blockquote><p>除最后一层外，每一层上的所有结点都有两个子结点<br>在满二叉树中，每一层上的结点数都达到最大值<br>即在满二叉树的第k层上有<code>2k-1</code>个结点，且深度为m的满二叉树有<code>2m-1</code>个结点</p></blockquote></li><li><p>完全二叉树是指这样的二叉树:</p><blockquote><p>除最后一层外，每一层上的结点数均达到最大值<br>在最后一层上只缺少右边的若干结点</p></blockquote></li><li><p>对于完全二叉树来说，叶子结点只可能在层次最大的两层上出现：</p><blockquote><p>对于任何一个结点，若其右分支下的子孙结点的最大层次为p<br>则其左分支下的子孙结点的最大层次或为p，或为<code>p+1</code></p></blockquote></li></ul><p><strong>完全二叉树</strong></p><ul><li><p>完全二叉树具有以下两个性质(接上文二叉树的基本性质):</p><blockquote><p>性质5: 具有n个结点的完全二叉树的深度为`[log2n]+1</p></blockquote></li><li><p>性质6: 设完全二叉树共有n个结点</p><blockquote><p>如果从根结点开始，按层次(每一层从左到右)用自然数<code>1，2，……，n</code>给结点进行编号<br>则对于编号为k（k=1，2，……，n）的结点有以下结论:<br>1-若<code>k=1</code>，则该结点为根结点，它没有父结点<br>若<code>k&gt;1</code>，则该结点的父结点编号为<code>INT(k/2) 2-若</code>2k≤n<code>，则编号为k的结点的左子结点编号为2k 否则该结点无左子结点(显然也没有右子结点) 3-若</code>2k+1≤n<code>，则编号为k的结点的右子结点编号为</code>2k+1`<br>否则该结点无右子结点</p></blockquote></li></ul><hr><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>涉及遍历的具体算法，以及能由两种遍历的结果推导另一种遍历的结果</p></li><li><p>在遍历二叉树的过程中，一般先遍历左子树，再遍历右子树</p></li><li><p>在先左后右的原则下，根据访问根结点的次序，二叉树的遍历分为三类:</p><blockquote><p>前序遍历，中序遍历和后序遍历</p></blockquote></li></ul><ol><li><p>前序遍历：先访问根结点、然后遍历左子树，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先访问根结点<br>然后遍历左子树，最后遍历右子树</p></blockquote></li><li><p>中序遍历：先遍历左子树、然后访问根结点，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后访问根结点，最后遍历右子树</p></blockquote></li><li><p>后序遍历：先遍历左子树，然后遍历右子树，最后访问根结点</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后遍历右子树，最后访问根结点</p></blockquote></li></ol><ul><li>树与二叉树的不同之处<blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树(左子树或右子树)也均为二叉树<br>而树结构中的每一个结点的度可以是任意的</p></blockquote></li></ul><hr><h2 id="查找技术"><a href="#查找技术" class="headerlink" title="查找技术"></a>查找技术</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><ul><li><p>涉及顺序查找的算法</p></li><li><p>查找是指在一个给定的数据结构中查找某个指定的元素</p><blockquote><p>从线性表的第一个元素开始，依次将线性表中的元素与被查找的元素相比较<br>若相等则表示查找成功<br>若线性表中所有的元素都与被查找元素进行了比较但都不相等<br>则表示查找失败</p></blockquote></li><li><p>在下列两种情况下也只能采用顺序查找：</p></li></ul><ol><li>如果线性表为无序表，则不管是顺序存储结构还是链式存储结构，只能用顺序查找</li><li>即使是有序线性表，如果采用链式存储结构，也只能用顺序查找</li></ol><hr><h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><ul><li><p>涉及二分查找法的算法</p></li><li><p>二分法只适用于顺序存储的，按非递减排列的有序表，其方法如下：</p><blockquote><p>设有序线性表的长度为n，被查找的元素为i<br>1-将i与线性表的中间项进行比较<br>2-若i与中间项的值相等，则查找成功<br>3-若i小于中间项，则在线性表的前半部分以相同的方法查找<br>4-若i大于中间项，则在线性表的后半部分以相同的方法查找</p></blockquote></li><li><p>二分查找法适用情况</p><blockquote><p>二分查找法只适用于顺序存储的有序表<br>在此所说的有序表是指线性表中的元素按值非递减排列(即从小到大，但允许相邻元素值相等)<br>这个过程一直进行到查找成功或子表长度为0为止<br>对于长度为n的有序线性表，在最坏情况下，二分查找只需要比较<code>log2n</code>次</p></blockquote></li></ul><hr><h3 id="排序技术"><a href="#排序技术" class="headerlink" title="排序技术"></a>排序技术</h3><ul><li><p>交换类排序法</p></li><li><p>涉及排序算法的基本过程</p></li><li><p>冒泡排序法和快速排序法都属于交换类排序法</p></li></ul><p><strong>冒泡排序法</strong></p><ol><li><p>首先，从表头开始往后扫描线性表，逐次比较相邻两个元素的大小</p><blockquote><p>若前面的元素大于后面的元素，则将它们互换，不断地将两个相邻元素中的大者往后移动<br>最后最大者到了线性表的最后</p></blockquote></li><li><p>然后，从后到前扫描剩下的线性表，逐次比较相邻两个元素的大小，若后面的元素小于前面的元素，则将它们互换</p><blockquote><p>不断地将两个相邻元素中的小者往前移动<br>最后最小者到了线性表的最前面</p></blockquote></li><li><p>对剩下的线性表重复上述过程，直到剩下的线性表变空为止，此时已经排好序</p><blockquote><p>在最坏的情况下，冒泡排序需要比较次数为<code>n(n－1)/2</code>次</p></blockquote></li></ol><p><strong>快速排序法</strong></p><ul><li><p>它的基本思想是：</p><blockquote><p>任取待排序序列中的某个元素作为基准(一般取第一个元素)<br>通过一趟排序，将待排元素分为左右两个子序列<br>左子序列元素的排序码均小于或等于基准元素的排序码<br>右子序列的排序码则大于基准元素的排序码<br>然后分别对两个子序列继续进行排序<br>直至整个序列有序。</p></blockquote></li><li><p>冒泡排序和快速排序的平均执行时间:</p><blockquote><p>冒泡排序法的平均执行时间是O(n2)<br>而快速排序法的平均执行时间是O(nlog2n)</p></blockquote></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下内容参考自中文维基:</strong></p><ul><li><p>CN-具体数学<a href="https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8</code></p></blockquote></li><li><p>CN-线性代数<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0</code></p></blockquote></li><li><p>CN-离散数学<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6</code></p></blockquote></li><li><p>CN-概率论<a href="https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA</code></p></blockquote></li><li><p>CN-二分查找算法<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-算法分析<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90</code></p></blockquote></li><li><p>CN-排序算法<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-数据结构<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</code></p></blockquote></li><li><p>CN-二叉树<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li><li><p>CN-Category:Binary trees<a href="https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn</code></p></blockquote></li><li><p>CN-分类-二叉树<a href="https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li></ul><p><strong>以下为已使用电子书籍资源:</strong></p><ul><li><p>全国计算机二级考试公共基础知识完整版整合</p></li><li><p>计算机二级公共基础知识完整</p></li><li><p>二级公共基础知识电子书</p></li><li><p>公共基础知识总和本(无密)</p></li><li><p>资源获取-百度网盘(永久链接)<a href="https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w" target="_blank" rel="noopener">跳转</a></p><blockquote><p>链接: <code>https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w</code><br>提取码: aynj</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;基础概念-数据结构与算法&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MS-SQL-1</title>
    <link href="https://unit-serow.github.io/2020/03/07/MS-SQL-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/MS-SQL-1/</id>
    <published>2020-03-07T08:43:29.000Z</published>
    <updated>2020-03-07T08:59:01.899Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --><center><strong>Access/MS SQL基本概念归纳</strong></center><a id="more"></a><h2 id="MS-SQL-1"><a href="#MS-SQL-1" class="headerlink" title="MS SQL-1"></a>MS SQL-1</h2><ul><li><p>网课随堂笔记</p></li><li><p>Access</p></li><li><p>MS SQL</p></li><li><p>数据库基础概念相关知识(数据抽象/数据模型/关系模型/各级关系运算)</p></li></ul><hr><h3 id="1-数据抽象"><a href="#1-数据抽象" class="headerlink" title="1. 数据抽象"></a>1. 数据抽象</h3><ul><li>设计数据库就是对数据的抽象过程:<blockquote><p><code>用户需求-抽象-&gt;概念模型-转换-&gt;[逻辑数据模型(外部模型)]-&gt;物理模型-&gt;数据库</code></p></blockquote></li><li>物理模型用于实现在数据库中对数据的存储</li><li>设计数据库的主要工作是构造数据模型</li><li>数据模型是对现实世界中数据特征的抽象</li><li>数据抽象中的数据模型主要有四种</li><li>概念模型 实体联系模型，可用于表达用户需求观点的数据全局逻辑结构的模型</li><li>ER图表示，ER图通常需要进行优化<blockquote><p><code>局部概念模型-&gt;全局概念模型</code></p></blockquote></li><li>ER图通常十分直观且形象</li></ul><hr><ul><li>逻辑模型<blockquote><p>用于表达计算机实现观点的数据库全局逻辑结构的模型<br>以树结构组织数据被称为层次模型<br>以网状结构组织数据称为网状模型<br>以二维表组织数据称之为关系模型(通常为主流数据模型)<br>ER图转化为逻辑模型<br>一对多，多对多，一对一，数据结构中存在几个实体对象，就将之称为几元联系<br>关系模式-(关系名-&gt;属性名)</p></blockquote></li><li>所有实体对象的集合被称之为关系</li></ul><hr><ul><li>内部模型<blockquote><p>即为物理模型<br>是用于表达数据库物理结构的数据库全局模型<br>以概念模型为基础，而转换处物理模型(内部模型)<br>有了物理模型，即可以在数据库中建立与之相对应的表结构</p></blockquote></li></ul><hr><ul><li>外部模型<blockquote><p>是用于表达用户使用观点的数据库局部逻辑结构的模型<br><code>[逻辑模型(若干外部模型)]</code><br>数据抽象过程</p></blockquote></li></ul><hr><ul><li><p>关系模型</p><blockquote><p>数据模型是一种严格定义的概念模型<br>关系模型精准的定义了数据结构，以及表与表之间可能发生的各种数据操作与管理，包括数据完整性操作<br>关系模型是以二维表的形式来组织数据<br>支持关系模型的数据库即为关系数据库<br>它使用若干个数据表来存储数据，此间可将一张二维表称之为关系<br>而关系的集合即为关系数据库</p></blockquote></li><li><p>关系模型的有关概念</p><blockquote><p>元组:表中的行，或称为记录<br>属性:表中的列，或称为字段与数据项<br>域:属性的取值范围<br>分量:一个属性的值<br>码:表中某个属性或属性组唯一标识一个元组<br>比如在一个表内，ID字符标识了所在行的整个元组，则称ID为码，即为关系模式约束<br><code>概念模型-&gt;逻辑模型-&gt;物理模型(内部模型)</code></p></blockquote></li><li><p>同种类型的实体集合被称之为实体型</p></li><li><p>在逻辑模型中所设计的一切概念，都被称之为关系模式</p><blockquote><p>关系模式由关系名及其属性的集合构成<br>在逻辑模型中将其称之为关系</p></blockquote></li><li><p>在内部模型中，也就是表结构，实体集为同一类型的表所属的数据集合</p><blockquote><p>在关系模型中将其称之为表</p></blockquote></li><li><p>为何把表称之为关系</p><blockquote><p>数学上把一系列域上的笛卡尔积的子集称为关系<br>而表正符合此定义</p></blockquote></li><li><p>域是一组具有相同类型的值的集合</p><blockquote><p>比如: 整型，实型或指定长度的字符串集合<br>而关系中属性的域可以被理解为属性的取值范围<br>比如学生中的性别属性，它的域就是男与女两个字符串</p></blockquote></li><li><p>笛卡尔积</p><blockquote><p>所有域的所有取值的任意集合<br>在数学中，以乘号来描述此概念<br>即<code>A*B={(x,y)|x∈A^y∈B}</code></p></blockquote></li><li><p>设集<code>A={a,b}</code>，集<code>B={0,1,2}</code></p><blockquote><p>即A的两个值乘以B的三个值<br>则两个集合的笛卡尔积为<code>{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}</code><br>如果A表示某学校学生的集合，B表示改学校所有课程的集合<br>则A与B的笛卡尔积可以用于表示所有的选课情况<br>A如果表示声母集合，B如果表示所有的声母集合，则A与B的笛卡尔积则可表示所有汉字的读音组合</p></blockquote></li><li><p>笛卡尔积并不都是有意义的</p><blockquote><p>设集<code>A={01,02}</code>,集<code>B={张三,李四}</code><br>则两个集合的笛卡尔积为<code>{(01,张三),(01,李四),(02,张三),(02,李四)}</code><br>如果A代表学号，B代表姓名，假设张三的学号是一号，而李四是二号<br>所以该笛卡尔积的结果集中，01的李四与02的张三是没有意义的</p></blockquote></li><li><p>数学上将一系列域上的笛卡尔积的子集称之为关系</p></li><li><p>而笛卡尔积中具有意义的那些元组则才被称之为关系</p></li><li><p>不是所有的二维表都是关系，关系是有以下特性的:</p><blockquote><p>关系必须规范化，比如: 每个表有多行，每个行有多列，每个行列单元都是不能再分的原子值<br>在同一关系中不允许出现相同的属性名<br>而关系中不允许有完全相同的元组<br>并且同一关系中元组及其属性的顺序可以随意</p></blockquote></li><li><p>严格的去定义表的具体规则与基本要求</p></li></ul><hr><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul><li><p>关系操作与数据查询操作可以用关系代数与关系逻辑的方法描述</p></li><li><p>或用具体的数据库语言，如SQL-结构化查询语言来描述与实现</p></li><li><p>最基本的方法是代数方法，即关系代数</p><blockquote><p><code>关系A&lt;-运算集合-&gt;关系B=关系C</code><br>代数是数学概念，同时关系代数也同为数学概念<br>运算符包括一系列运算集合<br>两个不同的关系通过一个运算符的运算来获得一个新的关系结果</p></blockquote></li><li><p>关系运算的运算符有两类，即为集合运算符和专门的关系运算符</p></li><li><p>选择运算</p><blockquote><p>选择运算是从关系中找出满足条件的元组的元组的操作<br>将其记为: <code>σ[(下标)&lt;条件表达式&gt;] (R)</code><br>用处于右下角的谓词来写条件表达式<br>其中，σ是选择运算符，R是关系名</p></blockquote></li><li><p>选择运算是根据给定的条件选择关系R中的若干元组而组成的新关系，是对关系的元组进行筛选</p><blockquote><p>结果关系与原关系有着相同的模式<br>可以将其表示为: <code>σ[(下标)sex]=R(tables_name)</code><br>在<code>tables_name</code>表中，找出sex字段等于R的所有记录<br>所以选择运算是对于行的操作</p></blockquote></li></ul><hr><p><strong>投影运算</strong></p><ul><li><p>投影运算是从关系中选取若干属性组成新的关系</p></li><li><p>投影运算是从列的角度进行计算，相当于对关系进行垂直分解</p></li><li><p>投影运算符用π来表示</p><blockquote><p><code>π[(下标)A] (R)</code><br>A用于表示投影属性或属性组，R是关系名</p></blockquote></li><li><p>例子: <code>π[(下标)A], π[(下标)A1](R)</code></p><blockquote><p>在R表中对A与A1两个字段进行投影，形成新的关系，同时去掉结果关系中重复的元组</p></blockquote></li><li><p>关系代数是把表看作元组集合的关系，既然是集合就不包括重复元组</p></li><li><p>也就是说，关系代数的每个运算都是去重复的</p></li></ul><hr><p><strong>并运算</strong></p><ul><li><p>并运算属于集合运算</p><blockquote><p>集合运算的两个关系必须拥有相同的关系模式，即相同的结构<br>两个关系包含属性的个数一致<br>两个关系对应属性的域应该相同或包容</p></blockquote></li><li><p>两个已知关系R和S的并将产生一个包含R，S中所有不同元组的新关系</p><blockquote><p>将其记为: <code>R∪S</code><br>则为R并S，因此并运算可以将其理解为现实中的或者</p></blockquote></li><li><p>两个已知关系R和S的交，是属于R而且也属于S的元组组成的新关系</p><blockquote><p>将其极为: <code>R∩S</code></p></blockquote></li><li><p>实例:</p><blockquote><p>设有两张不同的表<code>tables_A</code>与<code>tables_B</code>，并且设这两个表中分别有字段a，b，c，d，其值分别为拥有4行分别1，2，3，4的矩阵数列<br>首先找表<code>tables_A</code>中的a字段，即为:<br>先在<code>tables_A</code>表中进行选择运算，寻找的条件是a字段等于1，即为找出所有a等于1类型的数据记录，然后再进行投影运算，只取c字段(基于字段/列c来对a=1进行投影计算，也可称之为映射计算)<br>并且再<code>tables_B</code>表中进行选择运算，寻找的条件是b小于3的所有记录，然后进行投影运算<br>再将表<code>tables_A</code>与表<code>tables_B</code>进行差运算<br>此时的输出数据就是<br>将表<code>tables_A</code>中将所有已经排除了表<code>tables_B</code>中b小于三的数值类型的所有数值类型<br>因此得到想要查询的类型</p></blockquote></li><li><p>可将SQL语句具体描述为</p><blockquote><p><code>(π[(下标)c], π[(下标)a=1](tables_A))) - (π[(下标)c], π[(下标)b&gt;3](tables_B)))</code></p></blockquote></li><li><p>此时应输出的查询值即为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>笛卡尔积运算</strong></p><ul><li><p>设A和B是两个关系，如果A是m元关系，有i个元组</p></li><li><p>B是n元关系，有j个元组，则笛卡尔积为<code>A*B</code>是一个<code>m+n</code>元关系，则有<code>i*j</code>个元组</p></li><li><p>实例:</p></li><li><p>数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>此时A关系有三个元组，同时B关系有三个元组</p></li><li><p>此时的笛卡尔积则为<code>3*3</code>，则为9个元组</p><blockquote><p>A关系的第一个元组与B关系的所有元组进行连接<br>A关系的第二个元组与B关系的所有元组进行连接<br>A关系的第三个元组与B关系的所有元组进行连接</p></blockquote></li><li><p>此结果即为此笛卡尔运算的乘积结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a，b，c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积运算可以把两个运算连接到一起，从而形成一个新的关系</p><blockquote><p>由此引出连接运算与笛卡尔积的关系与区别</p></blockquote></li></ul><hr><p><strong>连接运算</strong></p><ul><li><p>连接运算是将两个关系的若干属性值拼接成一个新的关系的操作</p></li><li><p>对应的新关系中，包含满足连接条件的所有元组</p></li><li><p>即可将其记为: <code>R 连接(AθB) S</code> (连接符号于普通文本间无法输入)</p></li><li><p>其中，R与S是关系名</p><blockquote><p>A，B分别是R和S上度相等且可比的属性组<br>θ是比较运算符</p></blockquote></li><li><p>实例:</p></li><li><p>数据结构模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，a2，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，1</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li><li><p>对表<code>tables_A</code>与表<code>tables_B</code>进行以下比较连接</p></li><li><p><code>tables_A 连接(c&lt;E) tables_B</code>，即为<code>tables_A</code>中的c属性小于<code>tables_B</code>中的E属性</p></li><li><p>连接所输出的结果集为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C，E</span><br><span class="line"><span class="number">3</span>，<span class="number">8</span></span><br><span class="line"><span class="number">4</span>，<span class="number">9</span></span><br><span class="line"><span class="literal">null</span>，<span class="number">6</span></span><br></pre></td></tr></table></figure></li><li><p>此例为比较连接</p></li></ul><hr><ul><li>当比较运算符为等号时，可分为等值连接与自然连接</li></ul><p><strong>等值连接:</strong></p><ul><li>当连接条件为”=”时的连接运算 <code>R 连接(R.C=S.E) S</code>，此条件即可描述为R的C属性等于S的E属性</li></ul><p><strong>自然连接</strong></p><ul><li><p>自然连接是一种特殊的等值连接</p><blockquote><p>它要求两个关系中进行变焦的分量是相同的属性组，并且在结果中把重复的属性列去掉，可表示为: <code>R 连接 S</code></p></blockquote></li><li><p>此间的连接符号皆使用文字描述</p></li><li><p>如果将上述数据模型进行自然连接，即为将量表中的B列所拥有且相等的所有分量进行连接</p></li><li><p>连接运算与笛卡尔积运算的区别</p></li><li><p>连接运算是笛卡尔积运算和特定选择运算合并而成的一个运算</p></li><li><p>以此数据模型为例:</p></li></ul><ol><li>等值连接<blockquote><p>当<code>tables_A 连接(tables_A.C=tables_B.E) tables_b</code><br>即为将量表进行等值运算，运算条件与输出的值则为量表中分别<code>C=E</code>的值</p></blockquote></li></ol><ul><li>结果即为:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，tables_B.B，E</span><br><span class="line">a1，b1，<span class="number">3</span>，a2，<span class="number">3</span></span><br><span class="line">a2，b3，<span class="number">6</span>，a1，<span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>自然连接</li></ol><ul><li><p><code>tables_A 连接 tables_B</code></p><blockquote><p>此间无任何条件</p></blockquote></li><li><p>结果即为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，E</span><br><span class="line">a1，b1，<span class="number">8</span>，<span class="number">8</span></span><br><span class="line">a1，b2，<span class="number">3</span>，<span class="number">9</span></span><br><span class="line">a2，b3，<span class="number">6</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，3</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>等值连接</strong></p><ul><li><code>tables_A</code>中的C属性与<code>tables_B</code>中的E属性进行比较，一直比较到有相同的元组相等时，将所在元组进行连接<blockquote><p>比如在此实例中3，6，相等，即连接结果为以上两条元组</p></blockquote></li></ul><p><strong>自然连接</strong></p><ul><li><code>tables_A</code>中的B属性和<code>tables_B</code>中的B属性进行等值比较<blockquote><p>此时b1=b1，b2=b2，b3=b3都互为相等，则互相连接，则输出结果为以上两个元组</p></blockquote></li></ul><hr><ul><li>从运算过程可以总结规律: 自然连接必定是等值连接，自然连接与等值连接的区别则在于自然连接所比较的属性必须为公共属性，或者是属性组<blockquote><p>还有一点就是自然连接所形成的新关系会自动将重复的属性去掉<br>在上例中就把<code>tables_B</code>中的B属性去掉了，因为同样的属性所产生的值也必然是相同的，所以会将重复复的值去掉</p></blockquote></li></ul><hr><p><strong>外连接</strong></p><ul><li><p>有些元组不能跟另外关系的任何一个元组匹配，一些实际应用中希望在结果中保留悬浮元组，因此就产生了外连接机制</p></li><li><p>外连接包括了左外连接，右外连接以及全外连接的概念</p></li><li><p>外连接运算的逻辑</p></li></ul><ol><li>计算内连接(比较连接，等值连接与自然连接)</li><li>然后根据左外连接，右外连接或全外连接再加上左侧关系或者右侧关系或者两侧关系中的没有匹配到的元组及悬浮元组</li><li>最后加上悬浮元组用控制NULL来填充相对与另一侧属性的属性值</li></ol><ul><li><p>实例:</p><blockquote><p>自然连接符号的右上角会标识有连接标识L左外连接，R右外连接，F全外连接</p></blockquote></li><li><p>数据模型结构:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a3，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line">D，E</span><br><span class="line">b1，<span class="number">8</span></span><br><span class="line">b2，<span class="number">9</span></span><br><span class="line">a1，<span class="number">3</span></span><br><span class="line">a2，<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>计算机会先计算出自然连接的结果</li><li>之后再进行认为所指定的连接运算规则</li><li>然后再将所有乘积的属性置为空(NULL)</li><li>最后输出的数据集合变为结果</li></ol><ul><li>其它的运算都可以从这些基本关系的运算合并而成</li></ul><hr><ul><li><p>更多的实例这里不做过多阐述了，因为是Access与MS SQL，因此没有什么对其进行过多抽象描述的必要</p></li><li><p>知识图谱图片:</p></li></ul><img src="images/MS-SQL-2.png" width="30%" height="30%"><ul><li>相关概念图片:</li></ul><img src="images/MS-SQL-1.png" width="30%" height="30%"><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>参考URL</strong></p><ul><li><p>数据抽象级别<a href="https://blog.csdn.net/LetsStudy/article/details/79095315" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/LetsStudy/article/details/79095315</code></p></blockquote></li><li><p>数据科学的核心问题：现实问题的数据抽象与程序表达<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://new.qq.com/omn/20181003/20181003A0XITF00</code></p></blockquote></li><li><p>数据库关系模型范式总结<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36616602/article/details/85345295</code></p></blockquote></li><li><p>数据库之父对实现关系型数据库管理系统的12条建议<a href="https://blog.csdn.net/happmaoo/article/details/83075287" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/happmaoo/article/details/83075287</code></p></blockquote></li><li><p>数据库关系运算<a href="http://baijiahao.baidu.com/s?id=1602887097860809528&wfr=spider&for=pc" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://baijiahao.baidu.com/s?id=1602887097860809528&amp;wfr=spider&amp;for=pc</code></p></blockquote></li></ul><p><strong>参考书籍:</strong></p><ul><li><p>数据库原理及应用 (2017.06-郭春生，方昕)</p></li><li><p>数据库应用技术 (2018.1-栾志军，吕海洋，付海娟主编)</p></li><li><p>数据库技术与应用-2020年春季</p><blockquote><p>第一章-数据库基础知识<br>1.4节-1.6节(数据抽象/关系模型/关系运算)</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Tue Mar 17 2020 01:23:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;Access/MS SQL基本概念归纳&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="数据库" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="RDBMS" scheme="https://unit-serow.github.io/tags/RDBMS/"/>
    
  </entry>
  
</feed>
