<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-07T08:59:01.899Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MS-SQL-1</title>
    <link href="https://unit-serow.github.io/2020/03/07/MS-SQL-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/MS-SQL-1/</id>
    <published>2020-03-07T08:43:29.000Z</published>
    <updated>2020-03-07T08:59:01.899Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:48 GMT+0800 (中国标准时间) --><center><strong>Access/MS SQL基本概念归纳</strong></center><a id="more"></a><h2 id="MS-SQL-1"><a href="#MS-SQL-1" class="headerlink" title="MS SQL-1"></a>MS SQL-1</h2><ul><li><p>网课随堂笔记</p></li><li><p>Access</p></li><li><p>MS SQL</p></li><li><p>数据库基础概念相关知识(数据抽象/数据模型/关系模型/各级关系运算)</p></li></ul><hr><h3 id="1-数据抽象"><a href="#1-数据抽象" class="headerlink" title="1. 数据抽象"></a>1. 数据抽象</h3><ul><li>设计数据库就是对数据的抽象过程:<blockquote><p><code>用户需求-抽象-&gt;概念模型-转换-&gt;[逻辑数据模型(外部模型)]-&gt;物理模型-&gt;数据库</code></p></blockquote></li><li>物理模型用于实现在数据库中对数据的存储</li><li>设计数据库的主要工作是构造数据模型</li><li>数据模型是对现实世界中数据特征的抽象</li><li>数据抽象中的数据模型主要有四种</li><li>概念模型 实体联系模型，可用于表达用户需求观点的数据全局逻辑结构的模型</li><li>ER图表示，ER图通常需要进行优化<blockquote><p><code>局部概念模型-&gt;全局概念模型</code></p></blockquote></li><li>ER图通常十分直观且形象</li></ul><hr><ul><li>逻辑模型<blockquote><p>用于表达计算机实现观点的数据库全局逻辑结构的模型<br>以树结构组织数据被称为层次模型<br>以网状结构组织数据称为网状模型<br>以二维表组织数据称之为关系模型(通常为主流数据模型)<br>ER图转化为逻辑模型<br>一对多，多对多，一对一，数据结构中存在几个实体对象，就将之称为几元联系<br>关系模式-(关系名-&gt;属性名)</p></blockquote></li><li>所有实体对象的集合被称之为关系</li></ul><hr><ul><li>内部模型<blockquote><p>即为物理模型<br>是用于表达数据库物理结构的数据库全局模型<br>以概念模型为基础，而转换处物理模型(内部模型)<br>有了物理模型，即可以在数据库中建立与之相对应的表结构</p></blockquote></li></ul><hr><ul><li>外部模型<blockquote><p>是用于表达用户使用观点的数据库局部逻辑结构的模型<br><code>[逻辑模型(若干外部模型)]</code><br>数据抽象过程</p></blockquote></li></ul><hr><ul><li><p>关系模型</p><blockquote><p>数据模型是一种严格定义的概念模型<br>关系模型精准的定义了数据结构，以及表与表之间可能发生的各种数据操作与管理，包括数据完整性操作<br>关系模型是以二维表的形式来组织数据<br>支持关系模型的数据库即为关系数据库<br>它使用若干个数据表来存储数据，此间可将一张二维表称之为关系<br>而关系的集合即为关系数据库</p></blockquote></li><li><p>关系模型的有关概念</p><blockquote><p>元组:表中的行，或称为记录<br>属性:表中的列，或称为字段与数据项<br>域:属性的取值范围<br>分量:一个属性的值<br>码:表中某个属性或属性组唯一标识一个元组<br>比如在一个表内，ID字符标识了所在行的整个元组，则称ID为码，即为关系模式约束<br><code>概念模型-&gt;逻辑模型-&gt;物理模型(内部模型)</code></p></blockquote></li><li><p>同种类型的实体集合被称之为实体型</p></li><li><p>在逻辑模型中所设计的一切概念，都被称之为关系模式</p><blockquote><p>关系模式由关系名及其属性的集合构成<br>在逻辑模型中将其称之为关系</p></blockquote></li><li><p>在内部模型中，也就是表结构，实体集为同一类型的表所属的数据集合</p><blockquote><p>在关系模型中将其称之为表</p></blockquote></li><li><p>为何把表称之为关系</p><blockquote><p>数学上把一系列域上的笛卡尔积的子集称为关系<br>而表正符合此定义</p></blockquote></li><li><p>域是一组具有相同类型的值的集合</p><blockquote><p>比如: 整型，实型或指定长度的字符串集合<br>而关系中属性的域可以被理解为属性的取值范围<br>比如学生中的性别属性，它的域就是男与女两个字符串</p></blockquote></li><li><p>笛卡尔积</p><blockquote><p>所有域的所有取值的任意集合<br>在数学中，以乘号来描述此概念<br>即<code>A*B={(x,y)|x∈A^y∈B}</code></p></blockquote></li><li><p>设集<code>A={a,b}</code>，集<code>B={0,1,2}</code></p><blockquote><p>即A的两个值乘以B的三个值<br>则两个集合的笛卡尔积为<code>{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}</code><br>如果A表示某学校学生的集合，B表示改学校所有课程的集合<br>则A与B的笛卡尔积可以用于表示所有的选课情况<br>A如果表示声母集合，B如果表示所有的声母集合，则A与B的笛卡尔积则可表示所有汉字的读音组合</p></blockquote></li><li><p>笛卡尔积并不都是有意义的</p><blockquote><p>设集<code>A={01,02}</code>,集<code>B={张三,李四}</code><br>则两个集合的笛卡尔积为<code>{(01,张三),(01,李四),(02,张三),(02,李四)}</code><br>如果A代表学号，B代表姓名，假设张三的学号是一号，而李四是二号<br>所以该笛卡尔积的结果集中，01的李四与02的张三是没有意义的</p></blockquote></li><li><p>数学上将一系列域上的笛卡尔积的子集称之为关系</p></li><li><p>而笛卡尔积中具有意义的那些元组则才被称之为关系</p></li><li><p>不是所有的二维表都是关系，关系是有以下特性的:</p><blockquote><p>关系必须规范化，比如: 每个表有多行，每个行有多列，每个行列单元都是不能再分的原子值<br>在同一关系中不允许出现相同的属性名<br>而关系中不允许有完全相同的元组<br>并且同一关系中元组及其属性的顺序可以随意</p></blockquote></li><li><p>严格的去定义表的具体规则与基本要求</p></li></ul><hr><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul><li><p>关系操作与数据查询操作可以用关系代数与关系逻辑的方法描述</p></li><li><p>或用具体的数据库语言，如SQL-结构化查询语言来描述与实现</p></li><li><p>最基本的方法是代数方法，即关系代数</p><blockquote><p><code>关系A&lt;-运算集合-&gt;关系B=关系C</code><br>代数是数学概念，同时关系代数也同为数学概念<br>运算符包括一系列运算集合<br>两个不同的关系通过一个运算符的运算来获得一个新的关系结果</p></blockquote></li><li><p>关系运算的运算符有两类，即为集合运算符和专门的关系运算符</p></li><li><p>选择运算</p><blockquote><p>选择运算是从关系中找出满足条件的元组的元组的操作<br>将其记为: <code>σ[(下标)&lt;条件表达式&gt;] (R)</code><br>用处于右下角的谓词来写条件表达式<br>其中，σ是选择运算符，R是关系名</p></blockquote></li><li><p>选择运算是根据给定的条件选择关系R中的若干元组而组成的新关系，是对关系的元组进行筛选</p><blockquote><p>结果关系与原关系有着相同的模式<br>可以将其表示为: <code>σ[(下标)sex]=R(tables_name)</code><br>在<code>tables_name</code>表中，找出sex字段等于R的所有记录<br>所以选择运算是对于行的操作</p></blockquote></li></ul><hr><p><strong>投影运算</strong></p><ul><li><p>投影运算是从关系中选取若干属性组成新的关系</p></li><li><p>投影运算是从列的角度进行计算，相当于对关系进行垂直分解</p></li><li><p>投影运算符用π来表示</p><blockquote><p><code>π[(下标)A] (R)</code><br>A用于表示投影属性或属性组，R是关系名</p></blockquote></li><li><p>例子: <code>π[(下标)A], π[(下标)A1](R)</code></p><blockquote><p>在R表中对A与A1两个字段进行投影，形成新的关系，同时去掉结果关系中重复的元组</p></blockquote></li><li><p>关系代数是把表看作元组集合的关系，既然是集合就不包括重复元组</p></li><li><p>也就是说，关系代数的每个运算都是去重复的</p></li></ul><hr><p><strong>并运算</strong></p><ul><li><p>并运算属于集合运算</p><blockquote><p>集合运算的两个关系必须拥有相同的关系模式，即相同的结构<br>两个关系包含属性的个数一致<br>两个关系对应属性的域应该相同或包容</p></blockquote></li><li><p>两个已知关系R和S的并将产生一个包含R，S中所有不同元组的新关系</p><blockquote><p>将其记为: <code>R∪S</code><br>则为R并S，因此并运算可以将其理解为现实中的或者</p></blockquote></li><li><p>两个已知关系R和S的交，是属于R而且也属于S的元组组成的新关系</p><blockquote><p>将其极为: <code>R∩S</code></p></blockquote></li><li><p>实例:</p><blockquote><p>设有两张不同的表<code>tables_A</code>与<code>tables_B</code>，并且设这两个表中分别有字段a，b，c，d，其值分别为拥有4行分别1，2，3，4的矩阵数列<br>首先找表<code>tables_A</code>中的a字段，即为:<br>先在<code>tables_A</code>表中进行选择运算，寻找的条件是a字段等于1，即为找出所有a等于1类型的数据记录，然后再进行投影运算，只取c字段(基于字段/列c来对a=1进行投影计算，也可称之为映射计算)<br>并且再<code>tables_B</code>表中进行选择运算，寻找的条件是b小于3的所有记录，然后进行投影运算<br>再将表<code>tables_A</code>与表<code>tables_B</code>进行差运算<br>此时的输出数据就是<br>将表<code>tables_A</code>中将所有已经排除了表<code>tables_B</code>中b小于三的数值类型的所有数值类型<br>因此得到想要查询的类型</p></blockquote></li><li><p>可将SQL语句具体描述为</p><blockquote><p><code>(π[(下标)c], π[(下标)a=1](tables_A))) - (π[(下标)c], π[(下标)b&gt;3](tables_B)))</code></p></blockquote></li><li><p>此时应输出的查询值即为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>笛卡尔积运算</strong></p><ul><li><p>设A和B是两个关系，如果A是m元关系，有i个元组</p></li><li><p>B是n元关系，有j个元组，则笛卡尔积为<code>A*B</code>是一个<code>m+n</code>元关系，则有<code>i*j</code>个元组</p></li><li><p>实例:</p></li><li><p>数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>此时A关系有三个元组，同时B关系有三个元组</p></li><li><p>此时的笛卡尔积则为<code>3*3</code>，则为9个元组</p><blockquote><p>A关系的第一个元组与B关系的所有元组进行连接<br>A关系的第二个元组与B关系的所有元组进行连接<br>A关系的第三个元组与B关系的所有元组进行连接</p></blockquote></li><li><p>此结果即为此笛卡尔运算的乘积结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a，b，c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积运算可以把两个运算连接到一起，从而形成一个新的关系</p><blockquote><p>由此引出连接运算与笛卡尔积的关系与区别</p></blockquote></li></ul><hr><p><strong>连接运算</strong></p><ul><li><p>连接运算是将两个关系的若干属性值拼接成一个新的关系的操作</p></li><li><p>对应的新关系中，包含满足连接条件的所有元组</p></li><li><p>即可将其记为: <code>R 连接(AθB) S</code> (连接符号于普通文本间无法输入)</p></li><li><p>其中，R与S是关系名</p><blockquote><p>A，B分别是R和S上度相等且可比的属性组<br>θ是比较运算符</p></blockquote></li><li><p>实例:</p></li><li><p>数据结构模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，a2，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，1</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li><li><p>对表<code>tables_A</code>与表<code>tables_B</code>进行以下比较连接</p></li><li><p><code>tables_A 连接(c&lt;E) tables_B</code>，即为<code>tables_A</code>中的c属性小于<code>tables_B</code>中的E属性</p></li><li><p>连接所输出的结果集为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C，E</span><br><span class="line"><span class="number">3</span>，<span class="number">8</span></span><br><span class="line"><span class="number">4</span>，<span class="number">9</span></span><br><span class="line"><span class="literal">null</span>，<span class="number">6</span></span><br></pre></td></tr></table></figure></li><li><p>此例为比较连接</p></li></ul><hr><ul><li>当比较运算符为等号时，可分为等值连接与自然连接</li></ul><p><strong>等值连接:</strong></p><ul><li>当连接条件为”=”时的连接运算 <code>R 连接(R.C=S.E) S</code>，此条件即可描述为R的C属性等于S的E属性</li></ul><p><strong>自然连接</strong></p><ul><li><p>自然连接是一种特殊的等值连接</p><blockquote><p>它要求两个关系中进行变焦的分量是相同的属性组，并且在结果中把重复的属性列去掉，可表示为: <code>R 连接 S</code></p></blockquote></li><li><p>此间的连接符号皆使用文字描述</p></li><li><p>如果将上述数据模型进行自然连接，即为将量表中的B列所拥有且相等的所有分量进行连接</p></li><li><p>连接运算与笛卡尔积运算的区别</p></li><li><p>连接运算是笛卡尔积运算和特定选择运算合并而成的一个运算</p></li><li><p>以此数据模型为例:</p></li></ul><ol><li>等值连接<blockquote><p>当<code>tables_A 连接(tables_A.C=tables_B.E) tables_b</code><br>即为将量表进行等值运算，运算条件与输出的值则为量表中分别<code>C=E</code>的值</p></blockquote></li></ol><ul><li>结果即为:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，tables_B.B，E</span><br><span class="line">a1，b1，<span class="number">3</span>，a2，<span class="number">3</span></span><br><span class="line">a2，b3，<span class="number">6</span>，a1，<span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>自然连接</li></ol><ul><li><p><code>tables_A 连接 tables_B</code></p><blockquote><p>此间无任何条件</p></blockquote></li><li><p>结果即为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，E</span><br><span class="line">a1，b1，<span class="number">8</span>，<span class="number">8</span></span><br><span class="line">a1，b2，<span class="number">3</span>，<span class="number">9</span></span><br><span class="line">a2，b3，<span class="number">6</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，3</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>等值连接</strong></p><ul><li><code>tables_A</code>中的C属性与<code>tables_B</code>中的E属性进行比较，一直比较到有相同的元组相等时，将所在元组进行连接<blockquote><p>比如在此实例中3，6，相等，即连接结果为以上两条元组</p></blockquote></li></ul><p><strong>自然连接</strong></p><ul><li><code>tables_A</code>中的B属性和<code>tables_B</code>中的B属性进行等值比较<blockquote><p>此时b1=b1，b2=b2，b3=b3都互为相等，则互相连接，则输出结果为以上两个元组</p></blockquote></li></ul><hr><ul><li>从运算过程可以总结规律: 自然连接必定是等值连接，自然连接与等值连接的区别则在于自然连接所比较的属性必须为公共属性，或者是属性组<blockquote><p>还有一点就是自然连接所形成的新关系会自动将重复的属性去掉<br>在上例中就把<code>tables_B</code>中的B属性去掉了，因为同样的属性所产生的值也必然是相同的，所以会将重复复的值去掉</p></blockquote></li></ul><hr><p><strong>外连接</strong></p><ul><li><p>有些元组不能跟另外关系的任何一个元组匹配，一些实际应用中希望在结果中保留悬浮元组，因此就产生了外连接机制</p></li><li><p>外连接包括了左外连接，右外连接以及全外连接的概念</p></li><li><p>外连接运算的逻辑</p></li></ul><ol><li>计算内连接(比较连接，等值连接与自然连接)</li><li>然后根据左外连接，右外连接或全外连接再加上左侧关系或者右侧关系或者两侧关系中的没有匹配到的元组及悬浮元组</li><li>最后加上悬浮元组用控制NULL来填充相对与另一侧属性的属性值</li></ol><ul><li><p>实例:</p><blockquote><p>自然连接符号的右上角会标识有连接标识L左外连接，R右外连接，F全外连接</p></blockquote></li><li><p>数据模型结构:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a3，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line">D，E</span><br><span class="line">b1，<span class="number">8</span></span><br><span class="line">b2，<span class="number">9</span></span><br><span class="line">a1，<span class="number">3</span></span><br><span class="line">a2，<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>计算机会先计算出自然连接的结果</li><li>之后再进行认为所指定的连接运算规则</li><li>然后再将所有乘积的属性置为空(NULL)</li><li>最后输出的数据集合变为结果</li></ol><ul><li>其它的运算都可以从这些基本关系的运算合并而成</li></ul><hr><ul><li><p>更多的实例这里不做过多阐述了，因为是Access与MS SQL，因此没有什么对其进行过多抽象描述的必要</p></li><li><p>知识图谱图片:</p></li></ul><img src="images/MS-SQL-2.png" width="30%" height="30%"><ul><li>相关概念图片:</li></ul><img src="images/MS-SQL-1.png" width="30%" height="30%"><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>参考URL</strong></p><ul><li><p>数据抽象级别<a href="https://blog.csdn.net/LetsStudy/article/details/79095315" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/LetsStudy/article/details/79095315</code></p></blockquote></li><li><p>数据科学的核心问题：现实问题的数据抽象与程序表达<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://new.qq.com/omn/20181003/20181003A0XITF00</code></p></blockquote></li><li><p>数据库关系模型范式总结<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36616602/article/details/85345295</code></p></blockquote></li><li><p>数据库之父对实现关系型数据库管理系统的12条建议<a href="https://blog.csdn.net/happmaoo/article/details/83075287" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/happmaoo/article/details/83075287</code></p></blockquote></li><li><p>数据库关系运算<a href="http://baijiahao.baidu.com/s?id=1602887097860809528&wfr=spider&for=pc" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://baijiahao.baidu.com/s?id=1602887097860809528&amp;wfr=spider&amp;for=pc</code></p></blockquote></li></ul><p><strong>参考书籍:</strong></p><ul><li><p>数据库原理及应用 (2017.06-郭春生，方昕)</p></li><li><p>数据库应用技术 (2018.1-栾志军，吕海洋，付海娟主编)</p></li><li><p>数据库技术与应用-2020年春季</p><blockquote><p>第一章-数据库基础知识<br>1.4节-1.6节(数据抽象/关系模型/关系运算)</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:48 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;Access/MS SQL基本概念归纳&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="数据库" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="RDBMS" scheme="https://unit-serow.github.io/tags/RDBMS/"/>
    
  </entry>
  
  <entry>
    <title>规则</title>
    <link href="https://unit-serow.github.io/2020/03/07/%E8%A7%84%E5%88%99/"/>
    <id>https://unit-serow.github.io/2020/03/07/%E8%A7%84%E5%88%99/</id>
    <published>2020-03-06T22:14:44.000Z</published>
    <updated>2020-03-06T22:18:47.872Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>规则-主观</strong></center><a id="more"></a><hr><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><p>目的是引人思考，而绝非让人理解，即便能够理解，也必然不够全面</p></li><li><p>论题核心: 规则/规律/逻辑</p></li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>逻辑</li><li>规律</li><li>规则</li><li>秩序</li><li>智慧</li></ul><hr><p><strong>论题及其导论:</strong></p><ul><li>何为规则？</li><li>规则由何而来？</li><li>何为秩序？</li><li>秩序从何而来？</li><li>秩序与规则的关系与本质？</li><li>规则与秩序的对立概念？</li><li>为何要追求规则与秩序？</li><li>追求规则与秩序所带来的必然结果为何种概念？</li></ul><hr><h3 id="人类-2"><a href="#人类-2" class="headerlink" title="人类-2"></a>人类-2</h3><p><strong>规则与秩序</strong></p><ul><li><p>基于规则，实现秩序</p><blockquote><p>智慧于逻辑铸就规则<br>且相对于秩序<br>规则于现实铸就秩序<br>本能与自由相对秩序<br>本质与现实相对规则</p></blockquote></li><li><p>存在即现实</p><blockquote><p>人类的社会性的前提<br>无智规则<br>无智逻辑</p></blockquote></li><li><p>规则于现实中实现的方式可分为两类</p><blockquote><p>前者为完全/绝对且纯粹的基于智慧<br>其次为基于无智逻辑，即自然规则(自然法则)，此间的规则被称为规律<br>基于智慧的规则产生了可将其称之为法则的规则与规律，法律的概念这里不做阐述<br>自然规则来源于世界与现实，是一切存在于现实的物质与概念的基础<br>自然规则定义了生命，铸就了无智逻辑<br>规则/规律铸就逻辑<br>规则与逻辑皆来源于现实/世界与空</p></blockquote></li><li><p>纯粹性规则/纯粹性秩序的实现</p><blockquote><p>即为拥有纯粹智慧的社会性形态<br>并非纯粹的共产主义<br>而是绝对的纯粹意识形态<br>无即为一切，一切终究归于无，而又源于无<br>即为规则与秩序的根源<br>无规则即为纯粹规则，无逻辑即为纯粹逻辑<br>且<br>无意识即为纯粹意识<br>但智慧是存在于现实的<br>将一切归根结底的答案，都将归于无<br>在此所讨论的一切，都将不产生任何意义<br>理智与智慧是不应存于现实的，理智与智慧是最为荒谬的概念且为最不接近(或称其为抛离/脱离)于现实/世界的概念<br>人类/智慧生物在理智状态下做做出的一切行动都是最为荒谬的…</p></blockquote></li><li><p>顺天应人，随心而行，终究是最终且最合理的结果</p><blockquote><p>纯粹的纯粹唯物主义也莫过于如此<br>但大多或称所有，所谓的存在于现实中的顺天应人的智慧<br>都为主观结果，而非空或无所产生/带来的结果<br>纯粹且绝对性的概率如果存在，顺天应人则绝对不存在<br>光凭人类的智慧恐怕是完全无法做到所谓的顺天应人<br>追求规则与秩序所带来的必然结果即为无结果(绝对追求/追求绝对的规则与秩序)</p></blockquote></li><li><p>平衡</p><blockquote><p>针对平衡的概念与深层理解与思考<br>一切概念的最优解结尾平衡，平衡即为存于现实间最美好且最完全的概念<br>为何要去追求规则与秩序<br>一切都是为了将世界/现实达到或保持所谓的平衡，无论客观与主观<br>弱者与强者间的平衡，本能与理智间的平衡，本质与智慧之间的平衡，有与无(空)之间的平衡…</p></blockquote></li></ul><hr><h3 id="相关主观概念"><a href="#相关主观概念" class="headerlink" title="相关主观概念"></a>相关主观概念</h3><ul><li>现实/世界中所存在的一切皆可对立且皆成逻辑与规则</li><li>现实层面概念所产生与存在的现实概念:</li><li>现实/世界/自然因智慧/理智的存在而产生了最荒谬的结果</li><li>因此自然/世界将永远无法达到平衡(现实/世界存在智慧)</li></ul><p><strong>而人类社会更是与其相同</strong></p><ul><li><p>人与人之间于智慧层面的差距是人类永远也无法去主观进行理解的概念</p></li><li><p>而人与人之间所产生的智慧的差距皆来源于世界</p><blockquote><p>这里也可以将世界的概念称之为自然环境与绝对性概率所产生的环境差异</p></blockquote></li><li><p>正常状态下的人类皆拥有智慧？</p><blockquote><p>不<br>所谓的智慧，并非是所有人都在乞求得到的事物<br>沉迷于精神世界或沉迷于现实世界间的智慧将永远都不配将其称之为智慧(对于无限接近于纯粹的智慧而言)<br>有的人拥有的智慧接近于纯粹，而有的人则接近于无(此类人与无智慧生物相近，也就是猿猴)<br>但无论是任何形式的智慧，无论是拥有这两种绝对的概念其中的哪一个<br>所带来的结果都是绝对荒谬的<br>而接近于纯粹智慧的智慧永远都达不到且无法拥有纯粹的智慧，因为他们存在于现实间<br>而平衡，往往是于现实间所存在的最完美智慧<br>接近于纯粹智慧的智慧(按理/此处为主观愚解)应当理解这些基本的概念<br>接近于纯粹智慧的智慧会去无限的接近于平衡的智慧，而并非一味的去追求纯粹<br>一味的去追求纯粹的智慧并非为接近纯粹智慧的智慧<br>疯子与精神病患者可能会聪明绝顶，但其拥有的绝对不是接近于绝对纯粹的智慧<br>接近于绝对纯粹的智慧会尽力的去保持应有且为原有应当的平衡<br>即为将同时存在于现实与精神世界的人体意识时刻保持平衡<br>现实/世界间应只存在”最”的概念，而不应存在”绝对”的概念<br>无<br>纯粹</p></blockquote></li><li><p>此间只可意会，无法以言语相传</p></li><li><p>此间概念应有丢失，待今后进行相应补充</p></li></ul><p><strong>死循环<del>(嵌套循环)</del></strong></p><p><strong>即永远无法到达的平衡与纯粹</strong></p><p><strong>至此</strong></p><hr><h3 id="不精之精，而至纯粹"><a href="#不精之精，而至纯粹" class="headerlink" title="不精之精，而至纯粹"></a>不精之精，而至纯粹</h3><ul><li><p>改意之于-元精者，不精之精，其体纯粹，发而为智</p></li><li><p>此句来源于易经-周易阐真-序-先天五元，发为五得</p><blockquote><p>元性者（甲），无性之性，其体柔慈，发而为仁。<br>元神者（丙），不神之神，其体圆通，发而为礼。<br>元气者（戊），无气之气，其体纯一，发而为信。<br>元情者（庚），无情之情，其体刚烈，发而为义。<br>元精者（壬），不精之精，其体纯粹，发而为智。</p></blockquote></li></ul><hr><ul><li>而之即有其词-后天五浊，感生五贼<blockquote><p>游魂（乙）主生，其性善，感则生喜。<br>识神（丁）至灵，其性贪，感则生乐。<br>妄意（己）至动，其性乱，感则生欲。<br>鬼魂（辛）主死，其性恶，感则生怒。<br>浊精（癸）至浮，其性痴，感则生哀。</p></blockquote></li></ul><hr><p><strong>其它:</strong></p><ul><li>万物皆为相生相克，此存在于现实的概念恐怕8000年前的古中国就早已经有智慧提出了</li><li>而由进现代的相对论(狭义/广义)/质能守恒定律所产生的质能方程E=mc^2则完全且绝对的证明了此存在于现实的逻辑与观点</li><li>存在于现实的纯粹唯物主义的一切/绝对基本条件即为纯粹性概率/完全性概率，此概念将对应于现代所产生的量子理论</li><li>我虽自称沉醉于纯粹的纯粹唯物主义，但我对本质即为存在于现实世界的物理学一无所知</li><li>即便是纯粹的理论物理，而能令我沉迷的只有比其更接近于纯粹的纯粹数学</li></ul><hr><p><strong>下一论题:</strong></p><ul><li>智慧的起源/根源及其本质<blockquote><p>即为一切论题的基础，一切存在(唯心主义)于现实间的根源与基础<br>智慧绝非凭空产生或来于它类，进化论于唯物主义理论中是完全存在的<br>存在于现实的一切概念与生命都不可能拥有纯粹的智慧，因为纯粹的自由完全不属于现实(精神或意识形态)</p></blockquote></li></ul><hr><ul><li>文章内所涉及的一切现实与精神概念的相关内容皆基于主观理解与描述</li><li>相对于自身有限的智慧层次而对其客观进行的理解与描述</li><li>并且我将会尽量的做到绝对存在于现实的客观，但终究有限</li></ul><hr><ul><li>Because it is there-(因为山在那里)</li><li>我所拥有的一切皆来源于现实与世界，因此我终将一无所有</li></ul><hr><ul><li>补充一点: 0与1即为无与有，此时应当联想到何物？<blockquote><p>二进制……与机械智能……</p></blockquote></li></ul><hr><p><strong>相关资料:</strong></p><ul><li>中国哲学书电子化计划 -《周易阐真》<a href="https://ctext.org/wiki.pl?if=gb&res=904129&remap=gb" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://ctext.org/wiki.pl?if=gb&amp;res=904129&amp;remap=gb</code></p></blockquote></li></ul><blockquote><p>周易闡真（易道心法真傳）- 卷首-河圖<a href="https://www.eee-learning.com/book/eee-shinfa-ch3" target="_blank" rel="noopener">跳转</a><br><code>https://www.eee-learning.com/book/eee-shinfa-ch3</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;规则-主观&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LSP-2.2</title>
    <link href="https://unit-serow.github.io/2020/03/07/LSP-2-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/LSP-2-1/</id>
    <published>2020-03-06T17:59:36.000Z</published>
    <updated>2020-03-06T18:01:30.453Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用与库函数调用的执行检查与错误处理</strong></center><center><strong>UNIX/Linux-2.2</strong></center><a id="more"></a><h2 id="LSP-2-2"><a href="#LSP-2-2" class="headerlink" title="LSP-2.2"></a>LSP-2.2</h2><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-2</li></ul><hr><p><strong>涉及概念一览:</strong></p><ul><li>库函数基本检查</li><li>系统调用检查与错误处理</li><li>库函数调用检查与错误处理</li></ul><hr><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><ul><li><p>库函数即为存在于C 标准库内的任何函数，也可以称其为函数</p><blockquote><p>设计库函数的目的是为了提供比底层系统调用更方便的调用接口</p></blockquote></li><li><p>标准C语言函数库: GNU C 语言函数库(Glibc)</p><blockquote><p>标准C语言函数库的实现跟随UNIX的实现而异<br>GNU C语言函数库即为Linux上最常用的实现</p></blockquote></li><li><p>除了标准的函数之外通常还有其它的拓展函数uClibc与dietlibc</p><blockquote><p>uClibc: htttp://<a href="http://www.ulibc.org" target="_blank" rel="noopener">www.ulibc.org</a><br>dietlibc: <a href="http://www.fefe.de/detlibc" target="_blank" rel="noopener">http://www.fefe.de/detlibc</a></p></blockquote></li><li><p>因为Linux开发的大多数开发都只能用到Glibc，所以这里将不会对其它的拓展函数库进行过多讨论</p></li><li><p>查看当前系统的Glibc版本</p><blockquote><p>直接运行其glibc的共享库文件(可执行文件)，以获取版本<br><code>$ /lib/libc.so.6</code></p></blockquote></li><li><p>确定改库存放位置的方法之一:</p><blockquote><p>针对某个与glibc动态链接的可执行文件，运行ldd程序<br>然后再检查已输出的库依赖列表，便能发现glibc共享库所处于的位置<br><code>$ ldd myprog | grep libc</code></p></blockquote></li></ul><hr><ul><li>应用程序可以通过测试常量和调用函数库这两种方法来确定系统所安装的glibc版本及其详细信息<blockquote><p>从版本2.0开始，glibc定义了两个常量<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>，以供程序再编译时(在<code>#ifdef</code>语句中)测试使用<br>为了避免在同步机器上造成的版本不同而产生的参数差异所带来的种种问题，可以在程序内调用<code>gnu_get_libc_version()</code>来确定运行时的glibc版本</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/libc-version&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gnu_get_libc_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>而对于获取glibc版本信息，还有一种方法，即为使用<code>confstr()</code>函数来获取(glibc特有的)<code>_CS_GNU_LIBC_VERSION</code>配置变量的值<blockquote><p>其返回的字符串与上述实例相同</p></blockquote></li></ul><hr><h3 id="如何处理来自系统调用的错误与如何处理来自库函数的错误"><a href="#如何处理来自系统调用的错误与如何处理来自库函数的错误" class="headerlink" title="如何处理来自系统调用的错误与如何处理来自库函数的错误"></a>如何处理来自系统调用的错误与如何处理来自库函数的错误</h3><ul><li>几乎每个系统调用和库函数都会返回某类状态值，用以表明调用成功与否<blockquote><p>如果想要深入的了解调用是否成功，必须检查对状态值进行检查<br>若调用失败，则采取相应行动<br>所以让程序显示错误消息，以防止有意想不到的时间发生，是非常有必要的<br>但是还有少数几个系统调用函数在调用时从不会失败(例如<code>getppid()</code>总是能成功返回<code>进程的ID</code>，而<code>_exit()</code>总能终止进程，则无需对此类系统调用的返回值进行检查)</p></blockquote></li></ul><hr><p><strong>如何处理来自系统调用的错误:</strong></p><ul><li>每个系统调用的手册页记录有调用可能的返回值，并指出了哪些值表示错误<blockquote><p>通常，返回值为-1则表示出错，当处于此种情况下，可以使用下列代码对系统调用进行检查</p></blockquote></li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="keyword">open</span>(pathname, flags, mode); <span class="comment">/* system call to open a file */</span></span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to handle the error */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">close</span>(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to heandle the error */</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>当系统调用失败时，会将全局整形变量<code>errno</code>设为一个正值，以标识具体的错误</p><blockquote><p>程序(<code>#include</code>)包含<code>&lt;errno.h&gt;</code>头文件，该文件提供了对<code>errno</code>的声明，以及一组针对各种错误编号而定义的常量<br>所有这些符号名都以子字母E打头，在每个手册页内标题为<code>ERRORS</code>的章节内，都刊载有一份相应系统调用可能返回的<code>errno值</code>列表</p></blockquote></li><li><p>这里是利用<code>errno</code>来诊断系统调用错误的一个简单实例:</p></li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cnt</span> = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">cnt</span> == -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">errno</span> == EINTR)</span><br><span class="line">fpintf(stderr, <span class="string">"read was interrupted by a signal\n"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Some other error occurred */</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>如果调用系统函数和函数库成功，<code>errno</code>绝不会被重置为0，故此改变了值不为0，还有可能是因为之前的调用失败造成的</p><blockquote><p>此外，<code>SUSv3</code>允许在函数调用成功时，将<code>errno</code>设置为非零值(但是基于没有函数会这么做)<br>因此，在进行错误检查时，必须检查首先检查函数的返回值是否表明调用出错，然后再检查<code>errno</code>确定错误原因<br>少数系统调用(比如<code>getpriority()</code>)在调用成功后，也会<code>返回-1</code><br>所以在要判断此类系统调用是否发生错误，应在调用前将<code>errno</code>设置为0，并在调用后进行检查(以上所描述的手法同样适用于某些库函数)</p></blockquote></li><li><p>系统调用失败后，常见的做法之一就是根据<code>errno</code>值来打印错误消息，提供的库函数<code>perror()</code>和<code>strerror()</code>，就是处于此目的</p><blockquote><p>此实例中函数<code>perror()</code>会打印出其<code>msg参数</code>所指向的字符串，紧跟一条与当前<code>errno值</code>相对应的消息</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>以下是对系统调用错误进行错误的一种简单方式:</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(pathname, flags, mode);</span><br><span class="line"><span class="keyword">if</span> (fd == -<span class="number">1</span>) &#123;</span><br><span class="line">perror(<span class="string">"open"</span>)</span><br><span class="line"><span class="keyword">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>strerror()</code>会针对其<code>errnum</code>参数中所给定的错误号，返回相应的错误字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>由<code>strerror()</code>所返回的字符串可以是静态分配的，这意味着后续对<code>sterror()</code>的调用可能会覆盖该字符串</p><blockquote><p>若无法识别<code>errnum</code>所含的错误编号，则<code>strerror()</code>会返回<code>&quot;Unknown error nnn&quot;</code>形式的字符串<br>在某些其它的视线中，在这种情况下，<code>strerror()</code>会返回<code>NULL</code></p></blockquote></li><li><p>由于<code>perror()</code>和<code>sterror()</code>都属于对语言环境敏感(locale-sensitive)的函数，故而错误描述中使用的都是本地语言</p></li></ul><hr><p><strong>处理来自库函数的错误</strong></p><ul><li>不同的库函数在调用发生错误时，所返回的数据类型和值也各不相同(可以参见每个函数的手册页)</li><li>从错误的角度来讲，可以分为以下几类:</li></ul><ol><li>某些库函数返回错误信息的方式与系统调用完全相同，则<code>返回值为-1</code>，伴之以<code>errno号</code>来标识具体错误<blockquote><p><code>remove()</code>便是其中一例，可使用该库函数来删除文件(调用<code>unlink()</code>相同调用)或目录(调用<code>rmdir()</code>相同调用)<br>对此类函数所发生的错误进行诊断，其方式与系统调用完全相同</p></blockquote></li><li>某些库函数在出错时会<code>返回-1</code>之外的其他值，但仍会设置<code>errno</code>来表明具体的出错情况<blockquote><p>例如，<code>fopen()</code>在出错时会返回一个<code>NULL指针</code>，还会根据出错的具体底层相同调用来设置<code>errno</code><br>函数<code>perror()</code>和<code>sterror()</code>都可用来诊断此类错误</p></blockquote></li><li>还有一些函数根本不使用<code>errno</code>，对此类函数来说，确定错误存在与否及其起因的方法各不相同<blockquote><p>同样可见诸于相应函数的手册页中，不应使用<code>errno</code>，<code>perror()</code>或<code>strerror()</code>来诊断错误</p></blockquote></li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li>Linux/UNIX系统编程(上册)</li><li>参考自原书3.3-3.4章节</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用与库函数调用的执行检查与错误处理&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.2&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="软件" scheme="https://unit-serow.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LSP-2-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-2/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-2/</id>
    <published>2020-03-06T10:39:20.000Z</published>
    <updated>2020-03-06T10:48:01.174Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:48 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用概念及其执行逻辑叙述</strong></center><center><strong>UNIX/Linux-2.1</strong></center><a id="more"></a><h2 id="LSP-2-1"><a href="#LSP-2-1" class="headerlink" title="LSP-2.1"></a>LSP-2.1</h2><ul><li>LSP/Linux System Prorgramming-2</li></ul><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-1</li><li>系统编程先决条件及其执行逻辑整合文案-1</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>系统调用及其执行逻辑刨析</li><li>对已执行的调用进行检查</li><li>逻辑简述</li></ul><hr><ul><li>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律</li></ul><hr><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li><p>系统调用是受控的内核入口，因此机制，进程可以请求内核以自己的名义去执行某些动作</p></li><li><p>以应用程序编程接口(API)的形式，内核提供有一系列服务提供程序访问(包括创建新进程，执行I/O，以及为进程间通信创建管道等)</p></li><li><p>在深入系统调用的运作方式之前，需要对其进行关注的几个问题点</p></li></ul><ol><li>系统调用是将处理器从用户态切换到和心态，以便CPU访问受到保护的内核内存</li><li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识(程序通过名称来标识系统调用，此编号机制通常与其无关)</li><li>每个系统调用可辅之以一套参数，对用户空间(亦即进程的虚拟地址空间)与内核空间之间(相互)传递的信息加以规范</li></ol><ul><li><p>从编程的角度去理解，系统调用与C语言函数的调用很相似</p><blockquote><p>然而在系统调用时，其幕后会经理诸多步骤，接下来将会对该步骤的具体逻辑进行叙述:</p></blockquote></li><li><p>这里将硬件平台-<code>x86-32</code>为例，按事件发生的顺序对这些步骤加以分析</p></li></ul><ol><li>应用程序通过调用C语言函数库中的外壳(wrapper)函数，以发起系统调用</li><li>对系统调用中断处理的例程来说，外壳函数必须保证所有的系统调用参数可用<blockquote><p>通过堆栈，这些参数传入外壳函数，但内核却希望这些参数置于特定的寄存器<br>因此，外壳函数会将上述参数复制到寄存器</p></blockquote></li><li>由于所有系统调用进入内核的方式相同，内核需要设法区分每个相同调用<blockquote><p>为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器(%eax)中</p></blockquote></li><li>外壳函数执行一条中断机器指令(<code>int 0x80</code>)，引发处理器从用户态切换到和心态，并执行系统终端<code>0x80</code>(十进制数为128)的终端矢量所指向的代码<blockquote><p>在较新的<code>x86-32</code>硬件平台实现了<code>sysenter指令</code>，较之传统的<code>int 0x80</code>中断指令，sysenter指令进入内核的速度更快，2.6内核与glibc2.3.2以后的版本都支持<code>sysenter指令</code></p></blockquote></li><li>为相应中断<code>0x80</code>，内核会调用<code>system_all()</code>例程(位于汇编文件<code>arch/i386/entry.S</code>中)来处理这次中断，具体的处理逻辑与步骤如下:<blockquote><p>1-在内核栈中保存寄存器值(这里先不做阐述)<br>2-审核系统调用编号的有效性<br>3-以系统调用编号对存放所有调用服务例程的列表(内核变量<code>sys_call_table</code>)并进行索引，发现并调用相应的系统系统调用服务例程<br>3.1-若系统调用服务例程带有参数，那么将会首先检查参数的有效性<br>3.2-例如，会检查地址指向用户空间的内存位置是否有效<br>3.3-随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改<br>3.4-以及在用户内存和内核内存间传递数据(比如在I/O操作中)<br>3.5-最后，该服务例程会将结果状态返回给<code>system_call()</code>例程<br>4.-从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中<br>5.-返回值外壳函数，同时将处理器切换回用户态</p></blockquote></li><li>若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno<blockquote><p>然后，外壳函数返回一个整型值，以表明系统调用是否成功<br>在Linux上，系统调用服务例程所遵循的惯例是调用成功则返回负值<br>发生错误时，例程会对相应erron常量取反，则返回一个负值<br>C语言函数库的外壳函数即对其再次取反(此时负负得正)，将此结果拷贝至 errno<br>同时以-1作为外壳函数的返回值返回，以此向调用程序表明有错误发生<br>上述惯例所依赖的先决条件是系统调用服务例程，若调用成功则不会返回负值<br>可是对于少数例程来说，这一前提并不成立<br>一般情况下，这也不会有问题，因为取反的errno值范围不会与调用成功返回负值的范围有交集<br>不过还有一种情况沿用这个惯例确实会出问题: 系统调用<code>fcntl()</code>的<code>F_GETOWN</code>操作，这里先不做阐述</p></blockquote></li></ol><hr><ul><li>以相同调用<code>execve()</code>为例，此图片展示了上文叙述及事件的发生序列</li><li>在<code>Linux/x86-32</code>上，<code>execve()</code>的系统调用号为<code>11(__NR_execve)</code><blockquote><p>因此，在<code>sys_call_table</code>向量中，<code>条目11</code>包含了该系统调用的服务例程<code>sys_execve()</code>的地址</p></blockquote></li><li>在Linux中，系统调用服务例程的命名通常会采取<code>sys_xyz()</code>的形式，其中<code>xyz()</code>则是所论及的系统调用</li></ul><p><strong>系统调用的执行步骤图例</strong></p><img src="/images/系统调用-1.png" width="40%" height="40%"><hr><ul><li><p>在系统调用的实际情况中，通常不需要将概念掌握并理解的如此深刻</p><blockquote><p>但即便对于一个简单的系统调用，仍要完成相当多的工作<br>因此系统调用的开销虽然很小，却也不容忽视</p></blockquote></li><li><p>这里可以将getppid()系统调用为例，研判一下发起系统调用的开销:</p><blockquote><p>该系统调用只是简单地返回调用进程的父进程ID<br>此时在一台运行着<code>Linux 2.6.25</code>的<code>x86-32</code>系统上，调用<code>getppid()</code>一千万次大约需要<code>2.2秒</code>钟，每次调用大致需要<code>0.3微秒</code><br>相形之下，在同一系统上，调用某个只返回整数的C语言函数一千万次，仅需0.11秒，约为<code>getppid()</code>耗费时间的<code>1/20</code><br>当然，大多数系统调用的开销都明显高于<code>getppid()</code></p></blockquote></li></ul><hr><ul><li>因此，从C 语言编程的角度去看，调用C语言函数库的外壳函数等同于调用相应的系统调用服务例程<blockquote><p>在今后的章节里，调用系统调用<code>xyz()</code>这类说法即意味着: 调用外壳函数，然后再由外壳函数去调用系统调用<code>xyz()</code></p></blockquote></li><li>为调试程序，或是研究程序的运作机制，可以使用<code>stace命令</code>，以便对程序发起的系统调用进行跟踪</li><li>有关与Linux系统调用机制有关的信息可参见其它书籍: [Love，2010]，[Bovet &amp; Cesati，2005]以及[Maxwell，1999]</li></ul><hr><p><strong>相关概念整合:</strong></p><ul><li><p>系统编程概念</p></li><li><p>系统编程先决条件及其执行逻辑整合文案</p></li><li><p>系统编程概念</p><blockquote><p>系统编程先决条件整合文案<br>系统调用<br>执行逻辑<br>库函数<br>GNU Libc (Glibc-GNU C 标准库)<br>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律<br>已执行调用检查<br>库函数错误<br>系统条用错误<br>可移植性<br>特性测试宏<br>SUSv3中定义的标准系统数据类型</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>可参考URL目录</p></li><li><p>CN-CSDN-Linux系统调用手册<a href="https://blog.csdn.net/xtx1990/article/details/8173950" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/xtx1990/article/details/8173950</code></p></blockquote></li><li><p>CN-CSDN-linux常用系统调用简介<a href="https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>CN-个人博客-[译] Linux 系统调用权威指南（2016）<a href="https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/</code></p></blockquote></li><li><p>CN-百度文库-系统调用手册<a href="https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html</code></p></blockquote></li><li><p>CN-IBM-Linux系统调用列表<a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</code></p></blockquote></li></ul><p>CN-个人博客-Linux系统调用(syscall)原理<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://gityuan.com/2016/05/21/syscall/</code></p></blockquote><hr><ul><li><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a><blockquote><p>第三章节内容<br>PDF资源可参考文章OS-1<br>手册页-Linux系统调用<br>书籍-附录A</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:48 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用概念及其执行逻辑叙述&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LSP-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-1/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-1/</id>
    <published>2020-03-06T07:41:05.000Z</published>
    <updated>2020-03-06T07:56:52.591Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux内核与操作系统基本概念归纳</strong></center><center><strong>UNIX/Linux-1</strong></center><a id="more"></a><h2 id="LSP-1"><a href="#LSP-1" class="headerlink" title="LSP-1"></a>LSP-1</h2><ul><li>LSP/Linux System Prorgramming</li></ul><hr><h3 id="UNIX-Linux-1"><a href="#UNIX-Linux-1" class="headerlink" title="UNIX/Linux-1"></a>UNIX/Linux-1</h3><ul><li>内核与操作系统的相关基本概念归纳</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><p><strong>内核</strong></p><ul><li><p>内核概念</p><blockquote><p>操作系统的核心<br>内核在狭义范围内被理解为用于管理与分配计算机硬件资源(即CPU，RAM，设备等)的核心层软件<br>在没有内核的情况下，计算机也能运行程序<br>内核的作用是对其它程序的编写和使用进行简化(通常会产生极大的简化效果)<br>者一切都要归功于内核为管理计算机的有限资源所提供的软件层</p></blockquote></li><li><p>内核文件命名机制</p><blockquote><p><code>vmunix/</code><br><code>boot/vmlinuz</code><br>内核为经由压缩的可执行文件</p></blockquote></li></ul><p><strong>内核的存在意义与职责</strong></p><ul><li><p>进程调度</p><blockquote><p>通常计算机内存在着若干个CPU(中央处理单元)以执行程序命令<br>UNIX kernel system与UNIX-like(Linux) kernel system属于抢占式多任务系统<br>多任务意指多个进程(即运行中的程序)可同时驻留于内存，且每个进程都能够获得对CPU的使用权<br>抢占用于泛指一组规则，这组规则控制着指定进程对CPU的使用权与使用时间<br>以上两者均有内核进程调度程序(而非程序本身)决定</p></blockquote></li><li><p>内存管理</p><blockquote><p>由于硬件资源的有限且软件对其硬件资源的占用，使得物理内存(RAM)被定义为有限资源<br>内核的作用就是以公平且高效的方式在进程间共享这一资源<br>多数的现代操作系统(包括Linux)采用了虚拟内存管理机制<br>使得进程与进程之间，进程与内核之间彼此隔离，以防止进程读取或修改内核或其它进程中的内存内容<br>只需将进程的一部分保存在内存中，以降低每个进程对内存的需求量与实现在RAM中同时加载更多的进程<br>此方法大幅提升了在任意时刻的CPU都有至少一个进程可以执行，以使得对CPU资源的利用更加充分的情况</p></blockquote></li><li><p>文件系统提供</p><blockquote><p>内核在磁盘之上有提供文件系统，并且允许对文件系统执行创建，获取，更新以及删除等管理操作</p></blockquote></li><li><p>创建和终止进程</p><blockquote><p>内核可以将新程序载入内存，以为其提供运行所需的资源(比如CPU，内存以及对文件的访问等)<br>这样一个处于运行状态下的程序被称之为进程<br>一旦进程执行完毕，内核还要确保释放其占用的资源，以备后续程序重新使用</p></blockquote></li><li><p>对设备与其硬件的访问</p><blockquote><p>计算机的外界设备(人体学输入设备，磁盘或磁带驱动器等)可实现计算机与外部世界的通信<br>此通信机制包括输入，输出或两者兼而有之<br>内核即为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问</p></blockquote></li><li><p>联网的机制与其实现</p><blockquote><p>内核以用户进程的名义收发网络消息(数据包)<br>该任务包括将网络数据表路由至目标系统</p></blockquote></li><li><p>提供系统调用应用编程接口(API)</p><blockquote><p>进程可利用内核入口点(也可称其为系统调用)请求内核去执行各种任务<br>衍生概念: Linux系统内核调用API的方法与步骤，此概念将会在以后章节内进行详细刨析与实践</p></blockquote></li><li><p>通常情况下，多用户操作系统(例如Linux等)会为用户提供一种名为: 虚拟私有计算机(virtual private computer)的抽象概念</p></li><li><p>即为每个用户都可以登陆操作系统，并且其独立的操作与其它的用户大致无干(包括独立访问设备，独立运行程序，CPU，磁盘及其硬件资源独立分配等等)</p></li><li><p>此时的内核用于负责解决(多进程)访问硬件资源时可能引发的冲突，并且不对用户和进程产生任何层面的影响</p></li></ul><hr><p><strong>内核态与用户态</strong></p><blockquote><p>现代处理器架构一般允许CPI至少在两者不同的状态下允许<br>即为用户态与核心态(有时也可称之为监管态supervisor mode)<br>执行硬件执行可使得CPU在两者状态间来回切换<br>与之相对应的虚拟内存区域也可划分(标记)为用户空间部分与内核空间部分<br>在用户状态下运行时: CPU只能访问被标记为用户空间的内存，视图访问属于内核空间的内存会引发硬件异常<br>在内核状态下运行时: CPU既能访问用户空间内存，也能访问内核空间内存<br>内核状态下运行的处理器通常可以完成某些特定操作: 此特定操作包括了执行宕机(halt)，访问内存管理硬件，以及设备I/O操作的初始化等等<br>实现者们通常会利用这一硬件设计将操作系统置于内核空间以确保用户进程不能访问内核指令和数据结构，保证了其无法对操作系统执行不利于操作系统运行的操作<br>而程序员在进行日常的编程任务时有必要去习惯于利用面向进程(process-oriented)的思维方式来考虑编程问题<br>即以进程及内核的视角来检视系统</p></blockquote><hr><h3 id="Shell相关"><a href="#Shell相关" class="headerlink" title="Shell相关"></a>Shell相关</h3><ul><li>shell是用于读取用户输入指令并将其相对应的程序进行执行并相应的软件程序<blockquote><p>也可将其称之为命令解释器<br>术语: 登陆shell(login shell)用于特质用户刚登陆系统时，由系统创建，用以运行shell的进程<br>在某些操作系统内会将命令解释器集成于内核中，对于UNIX系统而言，shell只是一个用户进程<br>在UNIX系统的历史中出现过的重要shell: Bourne shell (sh)，C shell (csh)，Korn shell (ksh，bash)等等<br>分别对应了UNIX，BSD，Linux等等</p></blockquote></li></ul><hr><h3 id="操作系统层面相关概念列表"><a href="#操作系统层面相关概念列表" class="headerlink" title="操作系统层面相关概念列表"></a>操作系统层面相关概念列表</h3><ul><li>用户和组-操作系统层面概念</li><li>单根目录层级-操作系统层面概念</li><li>目录-操作系统层面概念</li><li>链接/路径和链接/符号链接-操作系统层面概念</li><li>文件/链接文件/文件类型/文件命名/文件的所有权与权限(相对于用户与操作系统)-操作系统层面概念</li><li>路径/路径命名-操作系统层面概念</li><li>当前工作目录-操作系统层面概念</li><li>文件[I/O模型]/文件描述符-操作系统层面概念</li><li>stdio函数库(C语言在执行文件I/O操作时，通常会调用C标准库内的I/O函数，也可将I/O函数称为stdio函数库)，stdio函数位于I/O系统调用层之上-操作系统层面概念</li></ul><hr><p><strong>程序-操作系统层面概念</strong></p><ul><li><p>程序的存在形式与概念:</p><blockquote><p>程序在现实中的实现可分为两种形式: 源码文件与二进制文件<br>源码文件在执行程序时需要先将其转换(编译和链接处理)为二进制文件，即机器可以理解的二进制机器语言指令</p></blockquote></li><li><p>脚本</p><blockquote><p>脚本是包含命令的文本文件，它可以由shell或其它命令解释器之类的程序直接处理</p></blockquote></li><li><p>有关程序的相关概念列表:</p><blockquote><p>过滤器<br>命令行参数</p></blockquote></li></ul><hr><p><strong>进程</strong></p><ul><li><p>进程的概念与存在意义:</p><blockquote><p>进程即为正在执行的程序实例<br>在程序执行时，内核会将程序的源码载入虚拟内存，以为程序变量分配空间，建立内核记账(bookkeeping)数据结构<br>由此记录进程有关的各种信息(如: 进程ID，用户ID，组ID及其终止状态等)</p></blockquote></li><li><p>在内核的角度去观察进程</p><blockquote><p>进程是一个个实体，内核必须在它们之间共享各种计算机资源<br>以实现让所有的可再生资源在进程间进行平等的资源共享</p></blockquote></li><li><p>进程相关概念列表</p><blockquote><p>进程的内存布局</p></blockquote></li><li><p>逻辑上可以将某一个内存划分为这几部分(也可称为几段):</p><blockquote><p>文本: 程序的指令<br>数据: 程序使用的静态变量<br>堆: 程序可以从该区域动态分配额外内存<br>栈: 随机函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间</p></blockquote></li><li><p>进程相关的基础概念列表:</p></li><li><p>创建进程</p></li><li><p>创建可执行程序</p></li><li><p>进程ID</p></li><li><p>父进程ID</p></li><li><p>进程终止与终止状态</p></li><li><p>进程的用户和组标识符</p></li><li><p>特权进程</p></li><li><p>能力(概念-Capabilities/始于Linux kernel-v2.2)</p></li><li><p>init进程</p></li><li><p>守护进程</p></li><li><p>环境列表</p></li><li><p>资源限制</p></li></ul><hr><p><strong>内存映射</strong></p><ul><li>内存映射基本概念及其实现方法:<blockquote><p>调用系统函数<code>mmap()</code>的进程，会在其虚拟地址空间中创建一个新的内存映射</p></blockquote></li><li>内存映射可分为以下两类:</li></ul><ol><li>文件映射: 将文件的部分区域映射入调用进程的虚拟内存<blockquote><p>调用一旦完成，对文件映射内容的访问则转化为对应相应内存区域的字节操作，映射页面对按需自动从文件中加载</p></blockquote></li><li>相映成趣的是并无文件与之相应的匿名映射，其映射页面的内容会被初始化为0</li></ol><ul><li>由某一进程所映射的内存可以与其它进程的映射共享，而共享的方式通常有两个:</li></ul><ol><li>两个进程都针对某一文件的相同部分加以映射</li><li>由<code>fork()</code>创建的子进程自父进程处继承映射</li></ol><ul><li>内存映射有关概念:<blockquote><p>内存内容填充量分配<br>文件(I/O)，即映射内存I/O<br>进程间通信(通过内存共享映射)</p></blockquote></li></ul><hr><p><strong>静态库和共享库</strong></p><ul><li><p>所特指目标库的概念:</p><blockquote><p>所谓的目标库文件就是: 将(通常是逻辑相关的)一组函数代码加以编译，并置于一个文件中，以供其它程序调用的文件<br>此方法通常有利于程序的开发与维护</p></blockquote></li><li><p>现代UNIX系统提供两种类型的对象库: 静态库和共享库</p></li><li><p>静态库</p><blockquote><p>有时也可称之为档案文件[archives]，是早期UNIX系统中唯一的一种目标库<br>从本质上来讲，可以将静态库描述为: 是对已编译目标模块的一种结构化整合<br>使用静态库时需要在创建程序的链接命令中指定相应的库<br>主程序会在之后对静态库中隶属于各目标模块的不同函数加以引用<br>对于细节这里先不做过多描述，此后的章节内会对其进行具体且完整的刨析与使用和实践</p></blockquote></li><li><p>共享库</p><blockquote><p>共享库存在的意义亦在解决静态库所存在的问题<br>如果将程序链接到共享库，那么此时的链接器就不会把库中的目标模块复制到执行行文件中，而是在可执行文件中写入一条记录，用以表名可执行文件在运行时需要使用该共享库<br>在运行时将可执行文件载入内存的同时会由一个名为动态链接器的程序进行同步执行，以确保将可执行文件所需的动态库找到，并载入内存<br>随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中的函数定义相关联起来<br>在运行时的共享库代码在内存中秩序保存一份，且可供所有运行中的程序使用<br>且经过编译处理的函数仅在共享库内保存一份以解决磁盘空间<br>此设计还能确保各类程序在编译时会及时使用到函数的最新版本，即只需将带有函数新定义的共享库重新加以编译即可，程序将会在下次执行时自动使用新函数</p></blockquote></li></ul><hr><p><strong>进程间通信及其同步</strong></p><ul><li><p>Linux系统上运行有多个进程，其中许多都是独立运行</p><blockquote><p>然而有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制</p></blockquote></li><li><p>读写磁盘文件中的信息是进程通信的方法之一</p><blockquote><p>可是这种方法对于许多程序来说既慢又缺乏灵活性<br>因此，Linux像所有现代UNIX系统所实现的那样去提供了丰富进程间通信的IPC机制</p></blockquote></li><li><p>IPC机制相关概念列表/相关作用及其存在意义:</p><blockquote><p>信号(signal)，用于表示实践的发生<br>管道(即shell用户中的”|”)操作符和FIFO，用于在进程间传递数据<br>套接字，用于为同一台主机或是联网的不同主机上所允许的进程之间传递数据<br>文件锁定，用于防止其它进程读取或更新文件内容，同时运行某进程对文件的部分区域加以锁定<br>消息队列，用于在进程之间交换消息(数据包)<br>信号量(semaphore)，用于同步进程动作<br>共享内存，用于运行两个及两个以上的进程共享同一块内存</p></blockquote></li><li><p>就本质而言，FIFO和UNIX套接字的功能几近相同，即允许统一系统上并无关联的进程间彼此交换数据</p></li><li><p>两种可以并存于现在UNIX系统之中是由于FIFO来自System V，而套接字则源于BSD</p></li><li><p>IPC相关概念:</p><blockquote><p>对于信号及对其的深入刨析与讨论(依旧在后续章节对其实现与刨析)</p></blockquote></li></ul><hr><p><strong>线程</strong></p><ul><li><p>线程的基本概念描述:</p><blockquote><p>在现代UNIX实现中，每个进程都可执行多个线程<br>可将线程的概念比喻为共享同一虚拟内存及一干其它属性的进程<br>每个线程都会执行相同的程序代码，共享同一数据区域和堆<br>并且在同时，每个线程都拥有属于自己的栈，用以装载本地变量和函数调用等链接信息<br>线程之间可通过共享的全局变量进行通信<br>此外，利用上面所描述的IPC和同步机制，线程之间也能够彼此通信</p></blockquote></li><li><p>线程的优点:</p><blockquote><p>线程的优点就在于协同线程之间的数据共享(通过全局变量)更为容易<br>而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然<br>再者就是多线程应用能从多处理器硬件的并行处理中受益匪浅</p></blockquote></li><li><p>有关线程的相关概念列表:</p><blockquote><p>进程组<br>shell任务控制机制<br>会话机制<br>控制终端机制<br>控制进程机制</p></blockquote></li></ul><hr><p><strong>其它操作系统层面的相关概念:</strong></p><ul><li><p>伪终端，是一对相互连接的虚拟设备，也可称之为主从设备</p><blockquote><p>在这对设备之间，设有一条IPC信道以供数据之间进行双向传递<br>并且从设备(slave device)所提供的接口，其行为方式与终端相类似<br>最知名的伪终端要数telnet和ssh之类提供网络登陆服务的应用，以及 x window 系统所提供的终端窗口实现</p></blockquote></li><li><p>日期和时间</p><blockquote><p>进程涉及两种类型时间: 真实时间与进程时间(即为CPU时间，指自进程启动而来，所占有的CPU时间总量)<br>还可进一步的将CPU时间划分为系统CPU时间和用户CPU时间，前者用于指内核模式中执行代码所占用的时间，后者用于指在用户模式中执行代码所占用的时间<br>time命令会显示出真实时间，系统CPU时间，以及执行管道中的多个线程而花费的用户CPU时间</p></blockquote></li><li><p>客户端/服务器架构</p><blockquote><p>即C/S架构<br>这里不做过多赘述</p></blockquote></li><li><p>实时性</p><blockquote><p>纯粹性概念，字面理解<br>关于实时性概念的实现与对其的具体定义这里不做过多赘述</p></blockquote></li><li><p><code>/proc</code>文件系统</p><blockquote><p>在Linux中实现并且提供了类似于其它的现代UNIX系统中的<code>/proc</code>文件系统<br>由一组目录和文件所组成，装配(mount，或称其为挂载)于<code>/proc</code>目录下<br><code>/proc</code>文件系统是一种虚拟文件系统，以文件系统目录和文件形式来提供一个指向内核数据结构的接口<br>以用于用户查看，改变和管理各种系统属性<br>关于/proc文件系统的内容这里先不做过多赘述，今后的章节内会进行刨析与实践</p></blockquote></li></ul><hr><p><strong>本章节所涉及的相关概念归纳</strong></p><ul><li>涉及概念一览(完整版本)</li><li>UNIX/Linux kernel</li><li>操作系统</li><li>shell/shell任务控制</li><li>文件</li><li>I/O模型</li><li>程序</li><li>进程/进程间通信与进程间同步</li><li>信号</li><li>线程</li><li>进程组</li><li>会话</li><li>内存/内存映射</li><li>静态库</li><li>共享库</li><li>终端控制</li><li>进程控制</li><li>伪终端</li><li>日期及时间</li><li>C/S-客户端/服务器架构</li><li>实时性</li><li><code>/proc</code>文件系统</li></ul><p><strong>本章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>所有涉及的文献资料皆来源于电子书籍</p></li><li><p><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a></p><blockquote><p>第二章节内容<br>PDF资源可参考文章OS-1</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux内核与操作系统基本概念归纳&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>自由</title>
    <link href="https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/"/>
    <id>https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/</id>
    <published>2020-03-06T04:32:03.000Z</published>
    <updated>2020-03-06T04:33:29.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>自由-主观</strong></center><a id="more"></a><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><ul><li>论题三大核心: 自由/纯粹/智慧</li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>自由/纯粹自由</li><li>理智/纯粹理智</li><li>本能/纯粹本能</li><li>智慧/纯粹智慧</li></ul><hr><p><strong>论题:</strong></p><ul><li>什么是自由</li><li>自由从从何而来</li><li>自由的本质是什么</li></ul><hr><p><strong>引论:</strong></p><ul><li>如何定义自由</li><li>对于自由的主观定义</li><li>所谓的自由</li><li>自由于精神层面的理解</li><li>自由于现实层面的实现</li><li>为何要去实现或追求自由</li></ul><hr><h3 id="人类-1"><a href="#人类-1" class="headerlink" title="人类-1"></a>人类-1</h3><p><strong>论题推论:</strong></p><ul><li>什么是自由</li><li>自由从何而来</li><li>自由的本质是什么</li></ul><p><strong>什么是自由?/自由从何而来?/自由的本质是什么?</strong></p><ul><li><p>自由源于人类的本质与天性，所谓天性，即为因存在于现实世界而产生的本能性质的无智逻辑(如果以具备智慧层面的生物来定义，也可称此为无逻辑)</p></li><li><p>但世事皆有因果，万物皆成逻辑(这里将不会过多的带入无的相关与衍生概念)</p></li><li><p>无智逻辑(亦可将其称之或理解为环境逻辑与自然逻辑)</p></li><li><p>存在即现实</p><blockquote><p>世界(即环境)源于空，空源于无<br>任何现实事物的本质来源于世界与环境，包括生命与智慧<br>生命是一切存在于现实的前提，但生命不会定义存在，而智慧可以定义存在<br>存在只是作为存在而存在于现实，概念将归于空-0<br>而当现实的存在被[定义]为存在于现实时，概念将归于世界，即为有-1<br>无即为无</p></blockquote></li><li><p>对于自由的主观定义</p><blockquote><p>在人类的存在还没有被定义之时，生物(即现实层面)的本质就早已被世界或环境所定义<br>此概念的逻辑为无智慧逻辑，也可将其定义于空，将不会产生任何讨论意义<br>此层面逻辑定义了人类于现实层面(世界)内最基本的性质，即存在(生命)<br>而伴随生命而存在的其它事物-现实，世界，无智逻辑(环境逻辑)<br>此间的现实中不存在于秩序，规则与存在等智慧层面的逻辑与概念</p></blockquote></li><li><p>存在即现实</p><blockquote><p>而自由与自由的概念所产生的本质皆来源于此刻<br>为什么会存在自由，有关自由的一切概念从何而来<br>自由来源于本质，而本质来源于环境与世界，世界源于空</p></blockquote></li><li><p>至此，引出我对自由的主观定义</p><blockquote><p>自由虽源于空，但绝不是凭空出现的<br>自由只是人类/生物于现实世界间所产生与拥有的本质<br>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面<br>或称为自由存在于现实层面，由此被智慧定义</p></blockquote></li><li><p>自由有可能可以被归于纯粹层面，即纯粹自由/本质(本能)自由</p><blockquote><p>自由是无智的逻辑，归于本质与本能，是人类永远不可能抛离的概念与本质<br>但人类拥有智慧，智慧可以定义与控制本质与本能<br>智慧存在于现实或精神层面之间的意义，即为定义本能或称[一切存在于世界之间的概念]<br>自由源于空，源于世界，源于本质，但绝对不会[源]于智慧<br>追求本质也是人类作为生物而存在于现实间的本质<br>一切概念与现实皆源于空，即存在-源于空</p></blockquote></li><li><p>存在即现实</p><blockquote><p>存在于现实间的本质与基本的条件/逻辑/概念—即为生命<br>即-生命归于现实，现实归于本质(人类)，本质归于空<br>至此自由是同存在/生命而存在与现实的<br>即人类/生物的本质即为存在，存在则为自由-[无规则(无秩序)/空-无]<br>人类源于空/无，人类/生物的本质即为空/无<br>自由是无概念概念，前者的概念为无，后者的概念为智慧所定义的概念<br>由源于空/源于无，自由是由无智时期就存在于现实间的概念</p></blockquote></li><li><p>生命与自由是人存在于现实的本质，本质即为无智逻辑</p><blockquote><p>于空或无间定义的概念，存在于现实间的人类或生物将永远无法抛离<br>不存在即为无意义，将不会产生任何讨论的意义<br>但不存在于现实可以进行讨论，这里先不进行讨论</p></blockquote></li><li><p>我目前还没有找到我想要找到的答案……</p><blockquote><p>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面 <?>自由存在于现实层面，由此被智慧定义 <?> 迷惑概念<br>主观的现实逻辑混乱，有一些概念只可意会，无法言传<br>或称为我的主观智慧层次与逻辑层次未到足矣将其以言传之的境界</p></blockquote></li></ul><hr><p><strong>引论答案:</strong></p><ul><li><p>如何定义自由</p></li><li><p>对于自由的主观定义</p><blockquote><p>自由于主观智慧被定义为无逻辑概念</p></blockquote></li><li><p>所谓的自由</p></li><li><p>自由于精神层面的理解</p></li><li><p>自由于现实层面的实现</p></li><li><p>为何要去实现或追求自由</p><blockquote><p>自由源于本质，本质源于现实，讨论于智慧层面间的存在等概念将不会产生任何存在意义<br>现实源于空，空源于无</p></blockquote></li></ul><hr><ul><li><p>一切皆归于无，一切皆可定义为无</p><blockquote><p>逻辑漏洞/逻辑死角/逻辑缺口<br>或称为现实(世界/环境)漏洞/现实缺陷<br>世界也可将其主观的定义为宇宙(现实)</p></blockquote></li><li><p>无</p><blockquote><p>现实逻辑漏洞，有待思考……</p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li><p>如何实现自由，现实间的自由为何物？</p></li><li><p>为何要去实现与追求自由？</p></li><li><p>自由来源于本能，同时将终于智慧</p><blockquote><p>智慧与理智的产物-规则与秩序<br>限制了所谓的自由(即本能)<br>自由所带来的结果必然与智慧(最基本且必然的产物: 规则/秩序)相对<br>当然，由资本所带来的规则与秩序是极度不堪与肮脏的<br>纯粹的智慧终究会产生最精密的逻辑与最极端的规则与秩序<br>而拥有与持续规则与秩序的最基本的条件与概念为-[理智]<br>理智是完全相对于本能的，相对于生物的(与之完全对立且相反，这里称其为相对)<br>或称其是完全且绝对相对于低等/低智能或无智能生物的</p></blockquote></li><li><p>规则与秩序的最基本条件是理智，同时来源于智慧</p><blockquote><p>一味的追求本能与自由的后果即为-停止前进/进化<br>本能与智慧-自由与秩序-滞留与进化<br>自由在理智与智慧的层面是无意义的，是愚昧的，是与之完全/绝对相对的<br>但在本质与本能的层面是完全合理的，是必然的，是完全符合无智逻辑的，是完全正确的</p></blockquote></li><li><p>人类的本质是社会性的</p><blockquote><p>而现有/现实存在的人类/生物的最高进化概念即为-共产主义<br>智慧，理智与秩序最高的社会性形态即为共产主义社会<br>共产主义不会脱离社会性(或称共产主义就是完全建立在社会性的基础上的)，即绝对且完全不会去尝试抛离本能(抛离本能的概念将不存在于现实)<br>而共产主义的弊端即为-此概念是近乎抛离本能的(非本质)，所以成为纯粹共产主义者的前提-就是拥有绝对且成熟的理智与纯粹的智慧<br>抛离本能带来的最终结果即为-抛离自由-共产主义者的自由将必然会被社会性/所处共产主义社会形态所完全(或称绝对)剥夺</p></blockquote></li><li><p>纯粹共产主义社会没有自由可言</p><blockquote><p>因为每一个独立者都将拥有最绝对的理智与最纯粹的智慧<br>它们将不乞求于自由<br>它们将抛离生物的本能(非本质)<br>目前看来…<br>它们…注定不会是存在于现实间的人类…<br>生产力完全充足之时，将有可能实现？<br>不<br>只有当人类完全抛离生而为人/为生物的本质之时<br>才有可能实现<br>此概念将抛离于现实</p></blockquote></li><li><p>人类实现共产主义…</p><blockquote><p>机械智能能否实现共产主义？<br>只有纯粹的精神意识体，能够实现所谓的纯粹共产主义-即纯粹理想主义<br>纯粹理想主义的概念为非现实概念(即便有可能存在于现实)</p></blockquote></li><li><p>纯粹-纯粹自由/纯粹共产主义</p></li></ul><p><strong>至此</strong></p><hr><ul><li>下一论题<blockquote><p>规则与秩序</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;自由-主观&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>UNIX/PIPE-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/PIPE-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/PIPE-1/</id>
    <published>2020-03-05T06:37:00.000Z</published>
    <updated>2020-03-06T08:00:26.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>UNIX-PIPES概述</strong></center><a id="more"></a><h2 id="UNIX-PIPE-1"><a href="#UNIX-PIPE-1" class="headerlink" title="UNIX/PIPE-1"></a>UNIX/PIPE-1</h2><hr><h3 id="Unix-Pipeline-Pipes-1"><a href="#Unix-Pipeline-Pipes-1" class="headerlink" title="Unix-Pipeline/Pipes-1"></a>Unix-Pipeline/Pipes-1</h3><p><strong>概述:</strong></p><ul><li>管道(Pipeline)是一系列将标准输入输出链接起来的进程</li><li>其中每一个进程的输出被直接作为下一个进程的输入</li><li>每一个链接都由匿名管道实现</li><li>管道中的组成元素也被称作过滤程序</li><li>通常被用于类Unix操作系统(以及一些其他借用了这个设计的操作系统，如Windows)中</li><li>其他操作系统的这个特色源自于Unix，例如Taos和MS-DOS<blockquote><p>最终成为软件工程的管道与过滤器设计样本</p></blockquote></li><li>这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名</li><li>UNIX管道技术需要注意的一点就是需要将管道与管线区分开来(两种截然不同的概念)</li></ul><hr><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述:"></a>具体描述:</h3><p><strong>管道概念:</strong></p><ol><li>管道是用于将一系列的标准输入输出指令(代码)链接起来，从而形成进程的最基本条件</li><li>并且被链接的每一个进程的输出被直接作为下一个进程的输入</li></ol><p><strong>还可以将其描述为:</strong></p><ol><li><p>管道是将一系列标准输入输出链接起来的进程</p></li><li><p>其中每一个进程的输出被直接作为下一个进程的输入</p></li><li><p>其中每一个链接都由匿名管道实现</p></li><li><p>管道中的组成元素也被称作过滤程序</p></li></ol><ul><li><p>其概念模型非常类似于现实世界种的管道</p></li><li><p>该图片描述了某一文字终端上一个包含三个程序的管道:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>管线:</strong></p><ul><li><p>是指将计算机指令处理过程拆分为多个步骤</p></li><li><p>并通过多个硬件处理单元并行执行来加快指令执行速度</p></li><li><p>亦可称之为流水线</p><blockquote><p>因为其具体执行过程类似工厂中的流水线，并因此得名<br>可以将计算机指令比喻为流水线传送带上的产品<br>而各个硬件处理单元就是流水线旁的工人<br>每个不同的产品都需要细分为几个互不相同的部门来实现其各部件的所需<br>所以流水线中所属部门不同的工人会为了同一个产品而同时工作</p></blockquote></li></ul><hr><ul><li>微处理器</li><li>在使用流水线的处理器中一个指令不是在处理器的一个定时器信号中完成的<blockquote><p>而是被分到多个信号中去完成，但是与此同时多个指令的分任务被同时处理</p></blockquote></li><li>由于这些分任务比整个指令要简单，因此可以通过使用流水线提高定时器频率<blockquote><p>虽然每个指令需要多个信号后才能完成<br>但是通过多个指令的并行运算每个信号内一个指令可以完成<br>因此通过这个方法整个速度可以提高</p></blockquote></li></ul><hr><ul><li>流水线级</li><li>一条流水线的每个分步骤被称为流水线级<blockquote><p>它们被流水线寄存器分开除指令流水线外在现代系统中还有其它流水线<br>比如用来计算浮点数的算术流水线</p></blockquote></li></ul><hr><ul><li>管线危障(pipeline hazards)</li><li>假如，一个指令在执行的时候，需要等待流水线上前一个指令先执行完毕的话<blockquote><p>那么这两个指令相互之间彼此有依赖关系<br>这可能导致流水线冲突的现象发生<br>即为管线危障</p></blockquote></li><li>常见情况可分为四种: 资源冲突/数据冲突(指令层的数据冲突/传输层的数据冲突)/控制流冲突</li><li>通过分支预测器可以避免控制冲突<blockquote><p>在这里处理器预测性地继续运算，直到正式预测是正确为止</p></blockquote></li></ul><hr><p><strong>网络管线:</strong></p><ul><li>Unix哲学: “一切皆文件”<blockquote><p>netcat和socat这样的工具可以将管道连接到TCP/IP套接字</p></blockquote></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>管道(UNIX)</li><li>具名管道</li><li>命名管道</li><li>匿名管道</li><li>匿名命名管道</li><li>哈特曼管道</li><li>管线(流水线)</li><li>管线/流水线(计算机)</li><li>管线危障(pipeline hazards)</li><li>重定向(计算机)</li><li><code>tee指令</code><blockquote><p>该程序用于从管线内取出数据</p></blockquote></li><li>XML管道即为处理XML的管线</li><li>网络管线</li><li>UNIX</li><li>进程间通信</li><li>数字通信技术<blockquote><p>计算机通信技术</p></blockquote></li><li>管道协议</li><li>并发计算</li><li>协同控制</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>EN-System Interfaces<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html" target="_blank" rel="noopener">跳转</a></p></li><li><p>单一UNIX规范第7期，由国际开放标准组织发布</p><blockquote><p><code>https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html</code></p></blockquote></li><li><p>EN-Pipes: A Brief Introduction by The Linux Information Project (LINFO)<a href="http://www.linfo.org/pipe.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linfo.org/pipe.html</code></p></blockquote></li><li><p>获取管道的doc文案: <a href="http://www.cs.rit.edu/~swm/history/DTSS.doc" target="_blank" rel="noopener">http://www.cs.rit.edu/~swm/history/DTSS.doc</a></p></li></ul><hr><ul><li><p>以下内容参考自中文维基:</p></li><li><p>CN-分类:</p><blockquote><p>进程通信<a href="https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">跳转</a><br>进程间通信<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</code><br><code>https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A</code></p></blockquote></li><li><p>CN-分类: UNIX<a href="https://zh.wikipedia.org/wiki/Category:Unix" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Unix</code></p></blockquote></li><li><p>CN-分类: 并发计算<a href="https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97</code></p></blockquote></li><li><p>CN-分类: 协同控制<a href="https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6</code></p></blockquote></li><li><p>EN-分类: 指令处理<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><ul><li>CN-维基百科-点对点隧道协议: <a href="https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0</a></li><li>CN-维基百科-管道机制: <a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)</a></li><li>CN-维基百科-管道流: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-IDC: <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83</a></li><li>CN-维基百科-管线: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-命名管道: <a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93</a></li><li>EN-维基百科-管道(计算机): <a href="https://en.wikipedia.org/wiki/Pipeline_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pipeline_(computing)</a></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX-PIPES概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>OS-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/OS-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/OS-1/</id>
    <published>2020-03-05T03:34:05.000Z</published>
    <updated>2020-03-05T05:12:06.302Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>OS-PDF/URL资源整合目录</strong></center><a id="more"></a><h2 id="Operating-System-1"><a href="#Operating-System-1" class="headerlink" title="Operating System-1"></a>Operating System-1</h2><ul><li>操作系统</li><li>Operating System/OS</li></ul><hr><h3 id="电子书资源整合目录"><a href="#电子书资源整合目录" class="headerlink" title="电子书资源整合目录"></a>电子书资源整合目录</h3><ul><li><p>可能还会利用持续利用此文本进行URL资源整合</p></li><li><p>操作系统概念</p></li><li><p>操作系统原理</p></li><li><p>操作系统设计</p></li><li><p>操作系统制作</p></li><li><p>操作系统实现</p></li></ul><hr><ul><li>操作系统分析与理解<blockquote><p>Unix操作系统<br>FreeBSD(Unix-Like)操作系统<br>Linux(Unix-Like)操作系统</p></blockquote></li></ul><hr><ul><li>中文维基-<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</code></p></blockquote></li></ul><hr><p><strong>使用资源目录:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)<a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/297382.html</code><br><code>https://pan.baidu.com/s/1ntzHejv</code></p></blockquote></li><li><p>CN-Linux系统编程手册上册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p></li><li><p>CN-Linux系统编程手册下册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2016-10/135953.htm</code></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)<a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/232150.html</code></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)<a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://pan.baidu.com/s/1gdKdxlT</code></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)<a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/90585.html</code></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)<a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/294083.html</code></p></blockquote></li></ul><hr><p><strong>资源相关URL补充:</strong></p><ul><li><p>Linux/UNIX编程手册(分卷压缩文件)</p><blockquote><p><code>https://download.csdn.net/download/js_gary/10216486</code><br><code>https://download.csdn.net/download/js_gary/10216495</code></p></blockquote></li><li><p>FreeBSD解析</p><blockquote><p><a href="https://download.csdn.net/download/starry225/6223229" target="_blank" rel="noopener">https://download.csdn.net/download/starry225/6223229</a></p></blockquote></li></ul><hr><p><strong>整合包获取:</strong></p><ul><li>以上PDF资源整合文件的压缩包(一共七本电子书，rar格式):</li><li>百度网盘地址<a href="https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w" target="_blank" rel="noopener">永久链接</a><blockquote><p><code>https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w</code></p></blockquote></li><li>提取码: j3qc</li></ul><hr><p><strong>资源汇总:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)</p><blockquote><p><a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">https://www.jb51.net/books/297382.html</a><br><a href="https://pan.baidu.com/s/1ntzHejv" target="_blank" rel="noopener">https://pan.baidu.com/s/1ntzHejv</a></p></blockquote></li><li><p>CN-Linux系统编程手册上册</p></li><li><p>CN-Linux系统编程手册下册</p><blockquote><p><a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-10/135953.htm</a></p></blockquote></li><li><p>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</p><blockquote><p><a href="http://www.downcc.com/soft/302635.html" target="_blank" rel="noopener">http://www.downcc.com/soft/302635.html</a></p></blockquote></li><li><p>CN-现代操作系统 (原书第四版)</p><blockquote><p><a href="https://www.jb51.net/books/655464.html" target="_blank" rel="noopener">https://www.jb51.net/books/655464.html</a></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)</p><blockquote><p><a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">https://www.jb51.net/books/232150.html</a></p></blockquote></li><li><p>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</p></li><li><p>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</p><blockquote><p><a href="https://www.jb51.net/books/483820.html" target="_blank" rel="noopener">https://www.jb51.net/books/483820.html</a></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</p><blockquote><p><a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">https://pan.baidu.com/s/1gdKdxlT</a></p></blockquote></li><li><p>CN-深入理解UNIX系统内核 (瓦哈利亚)</p><blockquote><p><a href="https://www.jb51.net/books/609170.html" target="_blank" rel="noopener">https://www.jb51.net/books/609170.html</a></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</p><blockquote><p><a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">https://www.jb51.net/books/294083.html</a></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)</p><blockquote><p><a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">https://www.jb51.net/books/90585.html</a></p></blockquote></li></ul><hr><p><strong>书籍参考目录:</strong></p><ul><li>CN-操作系统概念 (原书第九版)</li><li>CN-操作系统概念 (2007-第七版，西尔伯查茨)</li><li>CN-操作系统概念 (原书第7版，清大出版)</li><li>CN-操作系统概念精要 (原书第二版)</li></ul><hr><ul><li>CN-Linux系统编程手册上册</li><li>CN-Linux系统编程手册下册</li><li>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</li></ul><hr><ul><li>CN-现代操作系统 (原书第四版)</li><li>CN-现代操作系统 (原书第三版)</li></ul><hr><ul><li>CN-操作系统精髓与设计原理 (原书第六版)</li><li>CN-计算机系统: 核心概念及软硬件实现 (原书第四版)</li><li>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</li><li>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</li><li>CN-操作系统设计与实现 (2008版，ANDREW S.TANENBAUM/ALBERT S.WOODHULL)</li></ul><hr><ul><li>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</li><li>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</li><li>CN-30天自制操作系统 (2012版，川和秀实)</li><li>CN-深入理解UNIX系统内核 (瓦哈利亚)</li></ul><hr><p><strong>其它:</strong></p><ul><li>书不重要</li><li>问题在于看书的人所拥有的能力</li><li>同种类型的书的本质都是相同的</li><li>找出，理解并且完全记住其中的关键字</li><li>至于对于电子书的版号的选择也无所谓的</li><li>译版与原版随意，有译版最好读译版</li><li>通常EN版的寻找难度比CN版小很多</li></ul><hr><ul><li>系统化学习目录</li><li>Operating System kernel</li><li>数字理论基础</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;OS-PDF/URL资源整合目录&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>VPS/KVM-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/VPS-KVM-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/VPS-KVM-1/</id>
    <published>2020-03-04T20:28:57.000Z</published>
    <updated>2020-03-05T06:53:16.497Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>VPS/KVM简要概述</strong></center><a id="more"></a><h2 id="VPS-KVM-1"><a href="#VPS-KVM-1" class="headerlink" title="VPS/KVM-1"></a>VPS/KVM-1</h2><hr><h3 id="虚拟专用服务器-Virtual-private-server"><a href="#虚拟专用服务器-Virtual-private-server" class="headerlink" title="虚拟专用服务器 (Virtual private server)"></a>虚拟专用服务器 (Virtual private server)</h3><p><strong>简述:</strong></p><ul><li>简称VPS</li><li>由容器技术或虚拟机技术实现</li><li>在容器或虚拟机中，每个VPS都拥有独立的公网IP，操作系统，磁盘空间，内存与处理器资源<blockquote><p>同时进程与系统配置之间也相互隔离<br>目的就是为了让用户和应用程序在同一个主机上模拟出完全不同，独立且相互隔离的资源占用与控制<br>以此让VPS可以完全拥有独立服务器的所有功能</p></blockquote></li><li>并且VPS为用户提供了管理配置的自由</li><li>VPS多用于企业虚拟化于IDC资源租用</li><li>VPS拥有完全的独立性，包括可以在容器内自行安装任何程序与其它对于虚拟硬件的操作<blockquote><p>远端服务器-&gt;容器/虚拟机-&gt;容器/虚拟机-&gt;用户</p></blockquote></li></ul><hr><h3 id="基于内核的虚拟机-Kernel-based-Virtual-Machine"><a href="#基于内核的虚拟机-Kernel-based-Virtual-Machine" class="headerlink" title="基于内核的虚拟机 (Kernel-based Virtual Machine)"></a>基于内核的虚拟机 (Kernel-based Virtual Machine)</h3><p><strong>简述:</strong></p><ul><li>可简称为KVM</li><li>是一种用于Linux内核中的虚拟化基础设施，可将Linux内核转化为一个虚拟机监视器</li><li>KVM于2007年2月5日被导入Linux 2.6.20核心中，基于C</li><li>KVM需要支持硬件虚拟化拓展特性的处理器</li><li>对于操作系统支持的范围较为广泛</li><li>基于多个GNY协议授权<blockquote><p>包括KVM内核模块: GPL v2<br>KVM用户模块: LGPL v2<br>QEMU虚拟CPU内核库(libqemu.a)和QEMU PC系统模拟器: LGPL<br>Linux用户模式QEMU模拟器: GPL<br>BIOS文件(bios.bin，vgabios.bin和vgabios-cirrus.bin): LGPL v2或更新</p></blockquote></li><li>KVM现由保罗·邦齐尼(Paolo Bonzini)维护</li><li>KVM 支持VirtIO半虚拟化技术-平行虚拟化技术(paravirtualization)</li></ul><hr><p><strong>内部结构:</strong></p><ul><li>KVM提供抽象的设备，但不模拟处理器</li><li>它开放了<code>/dev/kvm</code>接口，供使用者模式的主机使用:</li></ul><ol><li>设置客户虚拟机的地址空间<blockquote><p>宿主机同样也需用户可用于引导进主操作系统的固件镜像(通常为模拟PC时的自定义BIOS)</p></blockquote></li><li>为客户机模拟I/O</li><li>将客户机的视频显示映射回系统宿主机上</li></ol><ul><li><p>在Linux上，QEMU版本0.10.1及更新版就是一个用户层主机</p><blockquote><p>QEMU使用KVM以近乎原生的速度虚拟化客户机，若无KVM的话则将仅使用软件模拟</p></blockquote></li><li><p>KVM内部使用SeaBIOS作为对16位x86 BIOS的开源模拟</p></li><li><p>KVM/QEMU环境的高级概述:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>相关GUI(图形化管理)工具:</strong></p><ul><li>Kimchi – 网页版KVM虚拟化管理工具</li><li>Virtual Machine Manager – 支持创建、编辑、开始于关闭基于KVM的虚拟机，同时也支持对宿主之间的实时或冷拖拽虚拟机迁移</li><li>Proxmox虚拟环境 – 一项开源的虚拟化管理包，包括KVM与LXC<blockquote><p>同时它还有裸机安装器、网页版远程管理界面、HA集群堆栈、统一存储、柔性网络及可选的商业支持</p></blockquote></li><li>OpenQRM – 用于管理不同数据中心基础设施的平台</li><li>GNOME 机柜 – Linux上用于管理libvirt客户机的Gnome界面</li><li>oVirt – 用于管理基于libvirt的KVM开源工具</li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>VPS</li><li>KVM</li><li>Virtual</li><li>CN2</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-Redhat-KVM官方网站<a href="https://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux-kvm.org/page/Main_Page</code></p></blockquote></li><li><p>CN-CN2线路是什么，有哪些CN2线路的VPS<a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</code></p></blockquote></li></ul><p><strong>维基百科参考内容:</strong></p><ul><li><p>CN-虚拟主机<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA</code></p></blockquote></li><li><p>CN-虚拟专用服务器<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-服务器<a href="https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-虚拟化<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>CN-硬件虚拟化<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96</code></p></blockquote></li><li><p>CN-KVM-基于内核的虚拟机<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA</code></p></blockquote></li></ul><hr><h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><ul><li><p>境外KVM类型的VPS大约360RMB/年(美国)</p><blockquote><p>最便宜的</p></blockquote></li><li><p>官网地址: <a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">https://shadowsocks.org/en/index.html</a></p></li><li><p>仓库地址: <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></p></li></ul><hr><p><strong>可用参考:</strong></p><ul><li><p>CN-Github-SS教程</p><blockquote><p><a href="https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B</a><br><a href="https://ssr.tools/252" target="_blank" rel="noopener">https://ssr.tools/252</a></p></blockquote></li><li><p>搬瓦工 (Bandwagon Host)</p><blockquote><p>VPS供应商，支持支付宝支付<br><a href="https://bwh88.net/cart.php?gid=1" target="_blank" rel="noopener">https://bwh88.net/cart.php?gid=1</a><br><a href="https://bwg.net/" target="_blank" rel="noopener">https://bwg.net/</a></p></blockquote></li><li><p>CN2: <a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</a></p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;VPS/KVM简要概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Text</title>
    <link href="https://unit-serow.github.io/2020/03/04/text/"/>
    <id>https://unit-serow.github.io/2020/03/04/text/</id>
    <published>2020-03-03T23:18:27.000Z</published>
    <updated>2020-03-04T01:11:38.154Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>常驻Text文档</strong></center><a id="more"></a><p><strong>常驻随笔文档</strong></p><ul><li>无<blockquote><p>无很容易理解<br>但很难做到<br>很难在现实中实现?<br>不<br>无不属于现实<br>无则为无<br>空源于无<br>世界源于空<br>思维源于世界<br>而思维终将归于无</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;常驻Text文档&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="https://unit-serow.github.io/2020/03/02/test/"/>
    <id>https://unit-serow.github.io/2020/03/02/test/</id>
    <published>2020-03-02T12:46:19.000Z</published>
    <updated>2020-03-07T02:57:51.972Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><center><strong>常驻Test文档</strong></center><a id="more"></a><p><strong>样式实验文档</strong></p><p><span id="inline-blue">text.md</span></p><p><i class="fa fa-pencil"></i></p><ul><li><p>简介加粗并居中</p><blockquote><p><code>&lt;center&gt;&lt;strong&gt;常驻Test文档&lt;/strong&gt;&lt;/center&gt;</code><br><code>&lt;!-- more --&gt;</code></p></blockquote></li><li><p>插入图片</p><blockquote><p><code>&lt;img src=&quot;图片URL&quot; width=&quot;20%&quot; height=&quot;20%&quot;&gt;</code></p></blockquote></li></ul><hr><p><strong>URL收藏目录</strong></p><ul><li><p>他人学习笔记-BLFS/CLFS<a href="https://www.cnblogs.com/renren-study-notes/p/10385413.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/renren-study-notes/p/10385413.html</code></p></blockquote></li><li><p>免费高清壁纸-宇宙<a href="https://joer.ru/?id=23&start=294" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://joer.ru/?id=23&amp;start=294</code></p></blockquote></li></ul><hr><ul><li><p>更换图片教程<a href="https://www.jianshu.com/p/30bf702f533c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/30bf702f533c</code></p></blockquote></li><li><p>调色板<a href="https://www.colorhexa.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.colorhexa.com/</code></p></blockquote></li></ul><hr><p><strong>Emacs</strong></p><ul><li><p>这里标注一个大佬-子龙山人</p></li><li><p>知乎<a href="https://zilongshanren.com/tags/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zilongshanren.com/tags/</code></p></blockquote></li><li><p>博客<a href="https://www.zhihu.com/people/zilongshanren/answers" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.zhihu.com/people/zilongshanren/answers</code></p></blockquote></li><li><p>Github-spacemacs中文教程-子龙山人<a href="https://github.com/emacs-china/Spacemacs-rocks" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/emacs-china/Spacemacs-rocks</code></p></blockquote></li></ul><hr><ul><li>EN-GNU-An Introduction to Programming in Emacs Lisp<a href="https://www.gnu.org/software/emacs/manual/html_mono/eintr.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/eintr.html</code></p></blockquote></li></ul><hr><p><strong>在线测试网站收藏:</strong></p><ul><li><p>各类教程内的在线编译测试和各类参考手册都很好用</p></li><li><p>CN-<a href="https://www.tutorialspoint.com/compile_c_online.php" target="_blank" rel="noopener">C</a></p><blockquote><p><code>https://www.tutorialspoint.com/compile_c_online.php</code></p></blockquote></li><li><p>CN-<a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">tools</a></p><blockquote><p><code>https://tool.lu/coderunner/</code></p></blockquote></li><li><p>CN-<a href="http://www.dooccn.com/" target="_blank" rel="noopener">代码测试</a></p><blockquote><p><code>http://www.dooccn.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/" target="_blank" rel="noopener">RUNOOB</a></p><blockquote><p><code>https://www.runoob.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></p><blockquote><p><code>https://www.w3school.com.cn/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/w3cnote/runoob-chm.html" target="_blank" rel="noopener">离线版runoob获取</a></p><blockquote><p><code>https://www.runoob.com/w3cnote/runoob-chm.html</code></p></blockquote></li><li><p>CN-Git仓库地址<a href="https://github.com/it-ebooks/w3school" target="_blank" rel="noopener">W3cshool</a><a href="https://github.com/gagayuan/runoob-PDF-/tree/master/runoob" target="_blank" rel="noopener">Runoob-PDF</a></p><blockquote><p><code>https://github.com/it-ebooks/w3school</code><br><code>https://github.com/gagayuan/runoob-PDF-/tree/master/runoob</code></p></blockquote></li></ul><hr><p><strong>CN-LFS</strong></p><ul><li>CN-LFS-仓库: <a href="https://lctt.github.io/LFS-BOOK/" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/</a></li><li>CN-LFS-v9.0: <a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</a></li></ul><hr><h3 id="社交账户"><a href="#社交账户" class="headerlink" title="社交账户"></a>社交账户</h3><ul><li><p>Github</p><blockquote><p>ID: Unit-serow<br><a href="https://github.com/Unit-serow" target="_blank" rel="noopener">https://github.com/Unit-serow</a></p></blockquote></li><li><p>开源中国</p><blockquote><p>ID: serow<br><a href="https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0" target="_blank" rel="noopener">https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0</a></p></blockquote></li><li><p>博客园</p><blockquote><p>ID: UNITED<br><a href="https://home.cnblogs.com/u/1927298/" target="_blank" rel="noopener">https://home.cnblogs.com/u/1927298/</a></p></blockquote></li><li><p>CSDN</p><blockquote><p>ID: Unit-serow<br><a href="https://i.csdn.net/#/uc/profile" target="_blank" rel="noopener">https://i.csdn.net/#/uc/profile</a></p></blockquote></li><li><p>简书</p><blockquote><p>ID: G鬣羚<br><a href="https://www.jianshu.com/u/b852f1059757" target="_blank" rel="noopener">https://www.jianshu.com/u/b852f1059757</a></p></blockquote></li><li><p>码云</p><blockquote><p>ID: serow<br><a href="https://gitee.com/serow" target="_blank" rel="noopener">https://gitee.com/serow</a></p></blockquote></li></ul><hr><p><strong>国内的云服务平台</strong></p><ul><li>华为云: <a href="https://www.huaweicloud.com/" target="_blank" rel="noopener">https://www.huaweicloud.com/</a></li><li>阿里云: <a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a></li><li>腾讯云: <a href="https://cloud.tencent.com/" target="_blank" rel="noopener">https://cloud.tencent.com/</a></li><li>网易云: <a href="https://www.163yun.com/" target="_blank" rel="noopener">https://www.163yun.com/</a></li><li>百度云: <a href="https://cloud.baidu.com/" target="_blank" rel="noopener">https://cloud.baidu.com/</a></li><li>小鸟云: <a href="https://www.niaoyun.com/" target="_blank" rel="noopener">https://www.niaoyun.com/</a></li><li>七牛云: <a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></li></ul><hr><p><strong>LFS-金步国</strong></p><ul><li>金步国作品集<a href="http://www.jinbuguo.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.jinbuguo.com/</code></p></blockquote></li></ul><hr><ul><li>EN-Wiki-指令处理(Category:Instruction processing)<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><img src="/images/GNU-1.png" width="60%" height="60%"><ul><li>图片来源于: <a href="https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83</a></li></ul><hr><h3 id="GNU-Linux相关URL目录"><a href="#GNU-Linux相关URL目录" class="headerlink" title="GNU/Linux相关URL目录"></a>GNU/Linux相关URL目录</h3><ul><li><p>Linux Foundation<a href="https://www.linux.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux.com/</code></p></blockquote></li><li><p>Linux Listing of Wikis<a href="https://www.wiki.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.wiki.kernel.org/</code></p></blockquote></li><li><p>Linux 内核归档 (The Linux Kernel Archives)<a href="https://www.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/</code></p></blockquote></li><li><p>Linux 内核文档 (The Linux Kernel documentation)<a href="https://www.kernel.org/doc/html/latest/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/doc/html/latest/</code></p></blockquote></li><li><p>Linux 手册页项目 (The Linux man-pages project)<a href="https://www.kernel.org/doc/man-pages/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/doc/man-pages/</code></p></blockquote></li><li><p>Linux kernel 发行版镜像归档<a href="https://mirrors.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mirrors.kernel.org/</code></p></blockquote></li><li><p>Kernel.org-Git存储库<a href="https://git.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://git.kernel.org/</code></p></blockquote></li><li><p>GNU<a href="https://www.gnu.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/</code></p></blockquote></li><li><p>FSF<a href="https://www.linuxfoundation.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxfoundation.org/</code></p></blockquote></li></ul><hr><ul><li><p>GNU Hurd<a href="https://www.gnu.org/software/hurd/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/hurd/</code></p></blockquote></li><li><p>GNU Compiler Collection<a href="https://gcc.gnu.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://gcc.gnu.org/</code></p></blockquote></li><li><p>GNOME<a href="https://www.gnome.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnome.org/</code></p></blockquote></li></ul><hr><ul><li><p>廖雪峰</p><blockquote><p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></p></blockquote></li><li><p>Social-icons 图标</p><blockquote><p><a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">https://fontawesome.com/icons?d=gallery</a><br><a href="https://www.easyicon.net/iconsearch/iconset:social-icons/" target="_blank" rel="noopener">https://www.easyicon.net/iconsearch/iconset:social-icons/</a></p></blockquote></li><li><p>next主题优化</p><blockquote><p><a href="https://www.dazhuanlan.com/2019/12/11/5df04019e1c6a/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/12/11/5df04019e1c6a/</a><br><a href="https://bestzuo.cn/posts/blog-establish.html" target="_blank" rel="noopener">https://bestzuo.cn/posts/blog-establish.html</a><br><a href="https://io-oi.me/" target="_blank" rel="noopener">https://io-oi.me/</a><br><a href="https://enfangzhong.github.io/" target="_blank" rel="noopener">https://enfangzhong.github.io/</a></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;常驻Test文档&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-02</title>
    <link href="https://unit-serow.github.io/2020/03/02/%E9%9A%8F%E7%AC%94-2020-03-02/"/>
    <id>https://unit-serow.github.io/2020/03/02/%E9%9A%8F%E7%AC%94-2020-03-02/</id>
    <published>2020-03-01T21:33:55.000Z</published>
    <updated>2020-03-07T03:51:18.608Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="d3e39dd93751f79d95d3e6ef729763a6e60cbe659a96532cf9e8717c9ac2e814">0267ec72f19b8c198697a4f72870a3a8f489ae057af863b44ef2cb5078e04092eb15b0d3f3cafce5a8154463f71c998ea078f4727447ff0d4a1e0ca8b9d738adaf343055d2b2fccb77e639ddd5cfe81b852ec97ef4a9b183b9394fea0980a056a82d52fa5f3945d4420c9a871b379920ef59ae242efb9b220e61505bf3f3800803d4999d173dbc1b985a7e78710bc66a4175e69d119c32b9edb2778b3b44c37e3d1e422ff352ca9c898cb041a274b804038774ab8e947f1d159d889a3ce9c47868cef0745b7ac48804513d34d249f2a7cffeedef167f9409cac838f7b7e0ca39801da6e2a2723b7c77d1c594718c9a1495ccb1d85129704bd77d073f6b9fd58d10dd6895f01766d7e56a0f805078af7bf02ce2a85c47270028fcefa7d54daa37b94e56742efaec01c72558faf965fd4b29721835059fa5c863e2404e649a289f6b4f0042a26e585a6f759980ce1639a54cd3a446f74e5dfbe2014ff7ffce84d0dd81e445f9fb5bfe1a411b3fbe5064ceb8c913ea78fd129398492a035ffc901466d76183e0b4365de2a6dfb9e4c8ba23ef68d4fb3b4b27a01329bca050f9bfb503e595022482383c3b508c240e00135b6972c1c2417f32b60ceeae137bfb4b1624d5681afc092eeaf50318531ccba61a6d0e6cadbd13cfd5bebf72cf4590d8813c026434cf7d98648ddb4a3b17e0220a11994799e74a16de4ed3648f648e83fd0a47c3e264cf0d0434764ce3193617f6333a557f6ad9c8fb589825ee40f76cfa9b99aa87724160ece0fc2c4e4867ca1d3554c9fd42e2eacb6751d657a0ccffa8964fce9b81b671f8c6758b7e05fbca9efe183a33168c73e4c12b989c5ccdb1b1f3ba3046cf73d894b082a40a411ceb6995b3906974ac4e7fcc5ca05c673a577ab93e75b06c234ba0bacc470dfe3586622441fdcd4e99ad1d01e44710ce1fbb289110c60233215f965cd92bf301a65355fa11d9c5552fe03cd5aa540631403fdfaa0003990f4630b5822ff59a1cda84eb37afa18e96cb6195a8a955aee525563cc574251f9f084cc03880e24f434189e4b48a008cec8f2099402d6377cc654662ac8ca0fd403e907bb56ad025502324d3a8dfe0d12e3195086ce73ea4cfd768d9ac395b1b7d3ced5fa1741aa0da5ff07b3485d8b3e071a5600913eb41024a3587939e78e71222061ba1b4aa2f55bf3d260118ab33ed81b5ffd8d3ffce754638c4f5e8d1b91e27c86dfb1b9e0d8566c00debd128efd52c0a4d2992063e6e520c1e03cfc7d135180e91081f602d24fb5fcbcb742d98f4b36662ef0e2a86511c194626bf0522dbdb977e41856f64c572e5db802318b5cba86e3760d9c40558e542cef892fa2e3b2c2333d1bf5417e332b0ac6a4d5f4d17bf05488d2f9b306e5d3aaeb2e54c93dc8f33de147c54d05dc681ef8fe2135f18db1093b94082d8b8d224526c3e5516a62faf24afb1f3dbcdf14bb350675bfe19799e3e744b4689337e375aacc5416657bb40b51627665dda37842b0f8e4d2f0527d3b16eb8af3b8baabb5d8b8bcb883694dd9c18fe470e07ba6f8fd7102d844bb4a7f8cb58cfd5ac0d94bab8b655337ae142626b6da1aed298ec0cb8f5cea40af299ddfaf34d4c80a0994782b3d7325a987a705f6961d0cbeb2d1987be2b1bab3d3d6f7d838cb7df79f88b189be7318334d63d01af7bcff5edf24c1a27d971c7cf013c11bdbe4f30d98354fc44a3a40201ec3d29d939c2da66734625492cf3cb43bbc43a4c95dd1c15b5bbc78c45f2009718baa23b07725f4a1dbbadc02e8f8f6e84da4e8163fc924268a2ecf36942b923daf9424296a06c8e69f94c57aaea5effc4e32fb887a5b613509ee0cb18e9bddd5e9fc9c2ebfb0357737eb54f154b073b1e200161dcfb81f703948d9d6115637658dfa3b397faf4e851788ff333deb6cf8c0d9c38e196c5e77c200bb8caa195d5c7facb119305d049482cb7c4d0a762c6cf7cf3207d3acd50907b4e4e20371ed4803ab4852d196cfb3fa8a8664f57b023ac2520d58d5fcac0311ca82a6572941fb49fb7a16618f2371488a40ceb6117f6b9569b2998dfc148fc0137a8968fde5afc6d35d25d1dd45ab41c675ef62edd5ddabf71dd2ba1d62ebb9d8f8eee6712b0d26fa39e852c661e437780b773516d2566a12613467489c63924ebc6810104832eb9439d3cf170bc0b1aef6fa018d98e6ab0904330118cf85be50e0f733448cd6e2fdd52eaa1fd9613ef607f371d8e9a2d0a81ace97505a789986f05613ced63f4ecb5900e526d31a7979686424493824307bbf6de6ffc859f5e56a905b8ad5d898bd6b04a9cd20c80783ef7372c59d12f9c3ee4b67f8a2c2d311effc2d9d592725d2fadf4c998aa86bec746c146cf6ac81bf1181d6512b191c823d8168a4fbee06ec945c46d7008f74b8415475d88e8439a397f0bf817bed27e0e6302e09c791f0cdab3bf096400e1bb8230a569d40c6cd0d425d153907ee60a4f485fd21a73e4ad84354f9721506edeb8a0120be4cd51a9e37efc4d93284e6811373e02d750aad5963700afe25a4eb35e5618fd6db367023359a70d2a585f3289bc43f2f66c6a62a32ab5be67127129910924d6013461f509db402263095fad08d27c178d11ddfe3b9b3562fbac63ba9fc166b967f2ce84aaad964ad4d5e2be0f9d03dcdc4818e788255d137263a88513e7a6941098fcbc34154a1c28c3f54a0b406d69b272a7fe3a5002d840abb9b2f20af56f9a892ebd7170ec525bb7a94187047407f95b96c1ef8564d23c929a9a99276c9c1d0f876d0cd072df3bfdbcfca406839af53a2adab0701224c79f68531a4c570065303f9b2435ae1d7fe97a65080dcc83954a3b3c38cec1173f4f9a9e65842f3c27b56e8722531a23577d7bf02a9c6e21174cf86b0734280cd1f611664033ab80c20cbdeece77e78ce72aa1debb86ed996628b181a2c66961cfde660544244a7304ebbd5667307dd6e8233f0db2ea498b472f43d6c7e2c6f89db6903509a3c9695f161f7d3e473c76208900517def448874cd4cb6fec64f16955e1d3b5d842cc7d8d1652d89e0bbb7068c939ef8b7ff7ac7fb2dbf89f5b54dca622238de7aeb62f25f7c6ea298f9b08fc3c1df8badbc89d3964abaf652e1a1175e41ca147b574e1d35b1545cacd2edca2b4cbcae26793ddbb58723b9e31e83b913bee0455a4cbbe521bd445fc7913420ab3de62ade1d2efc4ac35a9bb574476ad9aa275b47d0e0a110f9f97d111f5691a90a1f22a92a9722c28bed1ccfb0e379674a083ac9d050309f460e86bcc8d559ecb28d6377560b583205dcbc2c930bb2bcacb3b6b9666b49e9edbf724e28acefd23fe6126e7e1ecda22e14ab8c34473532bfb3f7f8709c6cd1705d87e1f88e1293d685e0dfe52a4fce75ad36257caef622da7408810e7ec1012850aab94e89b3dc468ecb3b37d88a802aa79606b96c18b322142eab567ba07c13b1dcfc1b9c1d16f06a807998baa9f25153d282d9f5a598b36159b04fdb1bda6a90497dcf7833323560f1e012ab24314a509dd1f876ca004669ac2756c877f58e7c3270732f04f960daebccec7d090eaa7e3f6885fc314bc0ac0c518276576c25831107cba8dbb4587fbfff71e3c2e0b53d4a7a439bdc9fbd318e5c4ec9bfb474ffea069ec96e6beb339268216beec1d0e1b7e573c327a7765af5cda21bb3df8238582b656e2eae364904fa54e7a791e95949962e74f70f04bd59f3a99719894f246124fcf3d8807e735d70d7aaca38f7256b32898dd593b2c21540330e6a52192f24629852e3a82f1b5bbbecfbbefad02fb995d05440c8033f3a2ad73c2b93c88f25c9a3e4d8cddb72c70eb542713bc5caf96ea2de6ccb8a11808b2acc1ad9acecaa41440cb9c5daaba3c631d33e591807bcc07de0e1b399c9463312c046d42c567a7b58c98087c6a912332ad1f3ebb339aa69cdec888a25d3d476a56e19dea4c19809dfdf9232bfb63ba43eee8d2cd626c5ac8f45c1171cdce0742168305fd7297b73f8c4dade3d27c10ac7b7afb17e74138b0523fefb42466cdbbf8493191c3102fd66fd719590d0d5ed78d634d198d187524ddf858293f2990ae85c39f0b0e131ba4839727ed74206f1b9c076b899032278c7aed640aaa1276a1fbedbb6c94b74553c4fc72573f269e934546c0147d5b6aba5a4c971ac66ccded8e08e70a031514bd14fb5a4ec49c5a3a5bdc039e743bfea85eb1f4ac45cdffa2f35bc616061bbefc7ba7578d6ed713ec9f45aa54172982762e6956f7f6bc2ff30b5c89bf8c8fc6bfefa5ec80a96bfb723d883f623d34048791ac90e266c364eed27ba0e9154390a692fa4842706302d24b8a41b11dbad481e707b989bd4b2b3edc4037b6312eaf7102af241262015e642a9049307fd399488fda1ecf50200082b710471fea731a4dc0388c2728e9654a21f6c799d9091ca263071b8eb11fd08f0c8e6e834e436074ba2bb1c9b5fed48516ba5541879bb7a9c3fc24733381750e16de36fa41ee226315a45d12ea1b63e8339d49b84d30f4789653ba7009781a6b93aadc63a1a9b8b0866216b487884f6f952e2dc3178ec5f7b5b0cabe3b0d72c0bde9f3f22e42d291ed240038c208294c218e9ecc16d72973f1d36bf74fb66a869769c6f9c71cf740c131617d5400ec88f2348c2adbd20caa8a06c758418b4e19c9ff1a3668a181b5d003fd8a7f105dfda78a781da751732a312beb8ace9f69eb74612f262f205114606027ff5a51cb61e294af42988b89000ddcc390c6f9a42d51a56d955e2f3cb0dc399c2fd7cf93a8031902cc2b595050e0b2fcd60b1d6ede89f3286b1e4d43bfc101edb40d3efc8814f6fa895ad733a1b39de8934945e845f8d430d9509f335951c632d3f6f01445ef75187dcae89664fe1a3c24af1e1af763cccceef366348189e7b69bd989df82c2c1d8c2f6ff9043be8dbec08e1a056d79c65ff21230834770b0219993b27cd102e2fd49d353d936e8266aba120d7238a885e2853a168aa0058fca2603990fed4190032cc4290e8f075f56642a6e53aabdeb716e46bc3cf8220a663d5fdebf2efce45c6d73f3873ebb54c4ea244700371085c0ccf6a9ca552a41b27f61e49572d5a5ebd167e7f7925bd64c067d56c7bcf9b5b4cd47e0f2e5ee556fe13992e0bd68f1ff6ba31657596fbb375e0e0ed97e4749c595ead2be5498f4969ee71221bb363793ca221ce7aa7430e9226c47d926b1a049ce536ae5dce0306296a1e0322dd34ebc87020074bfa651a9f67886ac0201cb1582044fe1151ceb6fc7410b336f3dbd0cac35010f478ecacf6533515d6d5fdf5ae906f9002c52e921f118c82397c8e4d9cfb4cfbadae2f7d1c357ce9c786c58cac68942048237fe617d26d8ca528ae2ee638ea7aefe2d5168521e737f1c1d258de39f9c9a24d1b6f7ef2e41c3d08b675c9a1b9ceb79c433f030c3e90400f35c333b29c3e4660d95d5f141bdab2e346fd36d3a6bacdbe6509c07d3e6726afd3e82db5d9fad48744b20c3b0da0fff2b1fffe5a715fdcea687d0c0ddaea8b422ddc8511051f17d48b125b7e4d11ea559bb0b8418391cbaef38abcac69b553949bd94e48be3d8c33826a39d2a7051290c40d8f7b686dfd5c3b6e5cdb16149d2fd3d4e79afa0ab39e2802e58d88ac7c67a5bcb9c6e8197f6b047b0aa2e49a6f120f087295dfec50ca38ae12c6cc7d08563dd76b4540c535191769a7c9406f81eaf56542a757ad29a0ff5268063a3dbfd1d402904f1ae10c31e0d6caff678c5dd664df1ce0281b444fdcc75a01ff9d980f2668d024a7ddfcd5ffd34a1562907eb757f372c2354a1cab7c233811d90b916859bf6f58356c2033d823d319dee36f6c17df16f15dd506e765fcf1fff80fed28478b9cc3567974e33a662fbd96291e909eb0d4d486a90237d2b0ba22c2b826287a3e84830becf94335252a93b2fe288bb082642444cec990d0184fbced21fae4b4807934f1d6951d34d075df35c424072d4e84e2275cdc2c3098204ec650d8000cf7b861b8ccd0da9b00489750b0a23c2e275963af6e5b19f6c5272ef0c245e17c0b0024a57e4809ea47a63945e1604aa610f6610b705c5aa1bbebd539d13fd0dec40f8b33405dd1cb364b12014252632460d48068bdf282696db3a3bfe914cbef121520f5469a120497669ef0a2d5ede322921b62a8965f6ff925d7c81c5b64a8f15432e2db562156719400b66228bfbb64473f139517f32fef1e28fd3f5a3593dd57b36e650295ff1593bb9b5afc02c7a69723d04c1d461829c20c490ccd18af287ffc3e4cb377dc1f9ed5d7d317ab5979f95f1a872a027166a38e882c823704a49d91342aaa6d999ca8e3ca0d85e9a5f7b50f02453efe317728ce0eba0011d44dd674ec34a21ecf4a3b49eafbec9bcebf9aa1ed6921bed9e24bff9581b2c3b6d51972e2be68296d1f3d907d24db14478c02be11c5b48e1dfd2a7704643e3f47b22285fff76f86b2cd5ddad8acaee9dde28806384a41573ab3d132725919f0d79755f99c6646a1204d099218549de4fb83c5874502bf6f71bbc2f71e9df8523ae89b97f569a4e74985dd739d4021704c859ad9bb96ac6efcd6833952a6f59b4e21d04083f999f3f42e991ec09d915e015ed35c60bd7f967da071c67e73a3b2277db0bc54f35c6cfc7c835ea14bd392313d6d4588ef490a04ac6245e01669395aa153125e89a12fd0612d46a846bee487a88e789a418c640419e3c0f17292cf90ea639ded37191e9fe5ef478b052ed8894fbe2378eb85e5218dffb881c80b88317fbf1068ef2e4269a3d109cab205091425c2e985829d323fa17db332d34c375709be54dba162ce7e7320c7637df06d0d47ab28d4cfa52f5eb0cac87e6a428744cd902d4676b1120ee5d76f557d0a3f4a3cf09e3f55ca9681bb83c483c727d6d0fa5945a34fe852bbb3ce2bef9d33bba19d12d1b5cda8b226d578334647f945436ec5fe44ef9823a8a12b2b5258ec9546f850407fec25cc1d5c8464ab41bfe97591c5be76090b89ded7e77c89674134eb1526a4c029cf8e491bd3476473070295c1368b57e78b98d5c6450a44b9f3dfbab7533cec2f8c759848a2b29f7bb4888fadcab2844616b2a81370b806beddbedb0fd98aadd060faf2768a390f943b0527410b4201e1343b547ff6830c4b2199dd01f9e5117331be0bba250ec9fcbe5ff73bdcb0b8d0dc453fecde6d4beba10bc950ce6a60ae93e70e91ba7f743331bebac96a9f3c4622e0b62d60d4f906c66d3f202e69f9bb16b44091f17c763e0b31c9eba13ba3504d5fb601492f68a25b8722afd3aede308bb02819da79c8004030f0ce258dad434dc28e1814185008c427ff91f252777d81210e42bf5193f7dbeae9b3a0ff47246c79375a35c1bd7003ec3224c94fb27735fd5df9b04f4e7788555deddddc4faf3a8f51a2a1426ebf10e3578938fddcd1b9447af9d5b3ba090080bd56b6fa9d8a90b8b4d04757f32fb32c909e467a349786a7341e26b8c46a7e4e6c2f79c0ad2fce6305958ec9be08ddf9c8c4de7ee771b52a93325aa6692803b533c48a9025e05a42d1f296b3813c3be4cbd56ac6caa747882afb7896e25189c75594c0bfe7cca297bf00cbf78a0f28f4b4b8b28e283fcc222537c10053eeea681fdb22233b9846596f27fe963c9ffe8d8554f751bb85f23f9d1bc93428818ac096ec1612575bcbf837dd1c29018eaa95268f40702b1c627e2cbdef4ac649a000816b4b5630e3cb85e5f226b38c5ead7673de70413651ebf15ba5b3f62b5f8c716adbb379ad1c655742b1519518642782580652d4b110d640a17b3faecd9f967ee0c23e0bca729e0c12a09413a19fbbeb2449333668aacd11051a11900ecabd49ec8e8ec39bf510f691dc2c3508f4ce21304a004f44ea4a157165024cb1682881109277f7eaa3c0444c1f94c0fc71a0c13dcbe847d4b1a1c9aeebc77c197b7d2c488b9ef06a08aee86a903188bdd27cedc59ccad30a34e210de7f661bf20e60c3177a0473c4c21a6f2a1da91b5704862bf7a435e9faf6d8744dd9967cb92d01fc2df0b1e2106fd8438ae0c388477d8c123ce1075282d49f2e836796f53b67c7993c7a8cec74a903f6357fc66e53710011f0d6b0a0752e4107c3eb14f9e24fa3d42dbe3f2f8140786034d43974b59d6b3f2284343f72488256c85d61db3ad3b5139b97a149a31f0c5ff033c760f8c0c964e29cafad2dcb78353ee560bef24c865775f9bf7ad7f84e26ef36e5adbc35182081cb44a33977f3f0f25917796d0d3641314728f3bc93d327b1cc82cac10df3011b482dea96b031c8dc7bc42009239f8ba14e594230067bb694080e033a2fa91b04779415c84569a91cdd0df9c588dfaf7effc06e90d16aa3ca74a95dc30648e695cacf462e3ba17122753251bb9c7d4931905973ca97ce92864fc2c428862b6468d829f450c5f4ec453f646ca8c4ee4ff89cc1533c6b13fc1bd039216e00f202898dddde9c13c2706d0535a06b22782df82963b46c1c70c389e271d717588020554130e029781568d14a1b1d5f12adafe5012940a231598b498a0f302b3ee2c0a680ae56977c863ede6eeddb7213d49afc643d967d1611ad6d725490a4fdc5256d686b5a7a67a70bb1f45852431e389e9a24d7244ffaf6c83a4612834477a0597a34c2f696c117f426d9797969019bdbdd150a617ee15399291a5ee4d058e674a05dbeec604f40e390a1f841bb5c7ba2a24ee9669b7d2aac2709febc81ca3943a367a2d0050498c912683ba733e349a72093dd21925ec41b4f07ebf79176fc4903902fe8bfa95aa093c09fa64927c71d71383d3d08531320a2a8af727bbcf26332dc1439a4baa1d88372b982580860bdb3c1137dde92b7e070bef4b8abe2aa9f8a2752fa72f41a9c9d67e86a594dd091a07a51d573f16074f1cf974e72d9bd78d50212fd55c6707ef72759326f8e9b828139b033ce83f6ac9796e0eda103d6b50fd0af6ed433a60aa0957f6d7631c47dd4c610d67060beef94984c86bf090f04e79f826381472ba260e3e6b1a18d13b9d68eb740d45d859d9ce1238d3aa36569cddc48899a2d5a693da3d18d57c156cad05886e6d21a576c2fb43e13b95749551011ebb33737622af342419852906565619c763639509306399869a54339f270c50bcdcbf2094acbe4f998d15eb7ca58b097f781301ee3a9ab9c69feea6f9a944612d5ac96b62699e79e5864c0980a52f08d9183f0cd95570adb5773b7c817451b69c943ef52e9a0c27ddf1912741946289fb7ab91034026b4f5c4d1575cb0fe9356de6c4dbd829400e5e656cca6cdb7080e0e2e226d1700374fb7be87f6c12ea376809995a88987208ae1e86f103c2b9c6054ce1678036b7a5c60baddb6c9ae7172f7ac8d01aad596b63d0ae784a5076b4dd4c1b17887fc6a67b3213270f3201e7815ad7bff550ed80e66bbc83223cd96e26ff089777a60ed242a53a79f637118cc314df1997c0b5aa7c81ff6f0ca8d939637c0be7410d81768786a3668e64bbf38164a58b7f788c51d25eec20b3aa0fa3dc6834943a05c1a0448b1cab4f2e8e3e4321d1db798e00e256764c50a364370520df255b13820d419b123a65512487dac872fd8277035c92df9cf65e896cc36941ec428f0a121c45b2078c8516318e904d4b19ae5ab9a974c22b362a29ff874ac8030790682b4b17a50129124b6d48e5de9b1abda6d62a2a808eacc111d69df10d16bb15aa0ddc5fef7cd5183055b2398ad19bb1f7f5c714eaf80137eba84dcf4a17004583ef167d32398ed3e5693e7ca28b6b3ac98a4f47ba9136d9875c5a38ae4c969fa04a7abf1e0993e7a5d9234bc465115247855f6265c2efe699c68e463dfe0eef18abbb0adc79a7356bfd5e6bc880cc9c1da078451ffd7ac5108b532c6d5bb3a9d1b951871e0253dc226098ecf12c6bc8ee5db8ea0948e25fb5465143811529bd5e2d7ebb32200af088b1ed347ec19fabac1970939779be9f1d3b2826b205eeeed15d0c748ee73734e5e6e3313b704332cf036cc1c3d8bc6ec623137719188735f6bf4824565354d3027e6b9e9cb7b29e268ea68ea9df7880a7daa92656c4f44d6fd898b1ddb869f17bf162fe917a570c1168cfc3ddd591a7720f6cda4c1890b8fd77c685cc60a6bf51388b06e4493f4e884ccf0f40a3e0fbcd0640ff0511fe36ddbe84f6e54939f10a690e73d787032ed619f1606d7751a3a7f2ad44ba37ef9aee6d818b29157896b8c3ce9b3f9455e56034600b2f58da2f8becdcd358e9e67de18b21b9f4e1726a9347bab2d3c76b416550c22ba3d231687233333719804f93f2355e86dc62374f806fae16f0b706a6404faf9fa86b5c4955b07561d5de6ef596eb029708892d7bc991f4e3dd8309bce0e07d921dbb2c94aa892066f091143461380be0c858d7030794c0db2f31e555f945448aa834edd70e721fcfb662a2b3397f3113497986b21b092af0e2a38fa6169268e3cbde302aa910ffb91685d85572b5fee395bab2e28740e84f17a671a0ae27ae196a9c03dd036cdc02a0c1ebfa2b7e746c7dfb7897e27d1bdfdc66f48d15e7add75f40e40bc8bcd4acfb575b992334a13c5f4b280a46b96623b1a91fb715887a989bccf87c8f866fea24f9ea667668d05893d59b5d649383dd1eb37630e74c4c03e484260ad5dbd5fde893d00a940058638679a7cd69f0e6f64ea08abd1c88d57eca1887ac5b176478b15d9060265e0fee9e9fb0163cb3535b6e06695e8e59c76265e0922e12f1c83657c0eec0b0cdb8461979379d381530a1a9f60fcc6cd13b9f47b3ea0e91691abe32c7eeab099ab18f151fb3efa47984682c177ba6854afcda05ef3821dc1eb3c825f6442fc911aeed8424b14ceb3683bd36c1a1942177476e8b7e0d1ff2152857024f716ca454520e9ce5d5f9992f7f8251c856510e98968487c092cfb97d923e5712c31069aa2d0d767caf6b7fbd0c9cef177ba90c9084fda8f528085b7711d4fa5d3b94ac09289687823f0af76e28d5f1769d222d381bf8bce9b4f70a4c9f7de5b061e1dfbb31f1d7804ae</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      简易加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-3</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/</id>
    <published>2020-03-01T14:10:58.000Z</published>
    <updated>2020-03-01T14:42:36.136Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-3-3"><a href="#GNU-LFS-3-3" class="headerlink" title="GNU-LFS-3-3"></a>GNU-LFS-3-3</h2><ul><li>系统转换过程与细节描述</li></ul><hr><p><strong>文案说明:</strong></p><ul><li>本篇文案用于描述目标系统环境的最基本配置与对从临时系统进入到目标系统的各种细节的描述</li><li>参考文献及版本为LFS-v6.2/v6.3</li><li>描述主体为LFS-v6.3，LFS-v6.2会有特别标注</li><li>LFS-v6.2和LFS-v6.3的内容与执行语句通常没有本质上的区别<blockquote><p>多数都只是执行顺序或者深层的处理逻辑不同<br>但大体非常相似</p></blockquote></li><li>多数指令在目标主机的chroot环境下进行</li></ul><p><strong>目录简述:</strong></p><ul><li>系统清理</li><li>虚拟文件系统</li><li>chroot环境</li><li>标准文件系统(FHS标准)</li><li>用户与用户组的基本配置</li><li>参考资料</li></ul><hr><h3 id="系统清理"><a href="#系统清理" class="headerlink" title="系统清理"></a>系统清理</h3><p><strong>临时主机的系统清理</strong></p><ul><li><p>删除已经安装的可执行程序和库文件当中的调试符号，以节约空间(大约70 MB)</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code><br><code>$ strip --strip-unneeded /tools/{,s}bin/*</code></p></blockquote></li><li><p>命令会跳过大约20个文件，报告不能识别这些文件格式</p><blockquote><p>其中大多数是脚本而不是二进制文件</p></blockquote></li><li><p>这里需要注意的一点是千万不要在库文件上使用<code>--strip-unneeded</code>，否则会破坏其静态版本</p><blockquote><p>如果已经是过去时了的话，就得从头开始编译全部的工具链软件包了</p></blockquote></li><li><p>删除相关文档文件(info，man)，会节约20 MB</p><blockquote><p><code>$ rm -rf /tools/{info,man}</code></p></blockquote></li></ul><hr><ul><li><p>到目前为止，临时工具链已制作完毕</p></li><li><p>这一阶段开始进入目标主机环境</p></li><li><p>从现在开始不需要lfs用户来制作系统了</p></li><li><p>退出lfs用户</p><blockquote><p><code>$ exit</code></p></blockquote></li><li><p>此时为root用户环境，改变必要文件的权限与所有者</p></li><li><p>一部分的原因是为了避免不必要的安全方面所产生的问题</p></li><li><p>将$LFS/tools目录以及其中文件的所有者改为root用户</p><blockquote><p><code>$ chown -R root:root $LFS/tools</code></p></blockquote></li><li><p>这里说明一下:</p><blockquote><p>建立LFS系统的时候，在创建<code>/etc/passwd</code>文件时<br>添加的user ID和group ID是与宿主系统的user ID和group ID相同的lfs用户</p></blockquote></li></ul><hr><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><strong>挂载虚拟文件系统</strong></p><ul><li><p>为虚拟内核文件系统建立挂载目录(dev,proc,sys)</p><blockquote><p><code>$ mkdir -pv $LFS/{dev,proc,sys}</code></p></blockquote></li><li><p>创建初始设备节点(创建两个目标系统所必须的设备文件)</p><blockquote><p><code>$ mknod -m 600 $LFS/dev/console c 5 1</code><br><code>$ mknod -m 666 $LFS/dev/null c 1 3</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>内核在引导时要求某些设备节点必须存在(特别是console和null)<br>这些设备节点必须创建在 硬盘上才能使得内核在udev尚未启动之前就可以使用它们<br>此外还有当Linux以<code>init=/bin/bash</code>启动</p></blockquote></li><li><p>挂载并填充/dev目录(LFS-v6.2)</p><blockquote><p><code>$ mount --bind /dev $LFS/dev</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>LFS-v6.2推荐的向<code>/dev</code>目录填充设备的方法是在<code>/dev</code>上挂载一个虚拟文件系统(比如 tmpfs)<br>然后在设备被检测到或被访问到的时候(通常是在系统引导的过程中)动态创建设备节点<br>既然现在新的系统尚未被引导，那么就有必要通过手工挂载和填充<code>/dev</code>目录<br>这可以通过绑定挂载宿主系统的<code>/dev</code>目录<br>绑定挂载是一种特殊的挂载方式，允许本地主机上的当前用户创建一个目录或者是挂载点的镜像到其他的地方</p></blockquote></li><li><p>挂载虚拟内核文件系统</p><blockquote><p><code>$ mount -v --bind /dev $LFS/dev</code><br><code>$ mount -vt devpts devpts $LFS/dev/pts</code><br><code>$ mount -vt tmpfs shm $LFS/dev/shm</code><br><code>$ mount -vt proc proc $LFS/proc</code><br><code>$ mount -vt sysfs sysfs $LFS/sys</code></p></blockquote></li></ul><hr><ul><li>在进入chroot环境之前，可以将<code>lfs-sources/</code>里面所有源码包复制到<code>$LFS/sources/</code>目录中</li><li>这么做会让后面在构建目标系统的时候使用源代码变得更方便<blockquote><p><code>$ cp -a /lfs-sources/* $LFS/sources/</code></p></blockquote></li></ul><hr><h3 id="chroot环境"><a href="#chroot环境" class="headerlink" title="chroot环境"></a>chroot环境</h3><p><strong>进入chroot环境</strong></p><ul><li>Chroot到目标系统的目录下，以便不受主系统的影响来制作目标系统</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chroot <span class="string">"$LFS"</span> <span class="regexp">/tools/</span>bin/env -i \ </span><br><span class="line">HOME=/root TERM=<span class="string">"$TERM"</span> PS1=<span class="string">'\u:\w\$ '</span> \ </span><br><span class="line">PATH=<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/tools/</span>bin \ </span><br><span class="line"><span class="regexp">/tools/</span>bin/bash --login +h</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><code>env</code>命令的<code>参数-i</code>的作用是清除所有chroot环境变量<blockquote><p>后面是重新设定HOME,TERM,PS1, PATH等变量的值</p></blockquote></li><li><code>TERM=$TERM</code>设定虚拟根环境中的TERM的值与chroot外面的一样<blockquote><p>这个值是让像vim和less之类的程序可以正确操作<br>如果还需要重新设置其它的值，如CFLAGS或CXXFLAGS，这里是个不错的位置</p></blockquote></li></ul><hr><ul><li><p>从这里开始，不再需要LFS环境变量了，因为所有的工作都被限制在LFS文件系统里面</p><blockquote><p>这是由于已经告诉了Bash shell $LFS 是现在的根目录(<code>/</code>)<br>注意，这里<code>/tools/bin</code>位于PATH的最后面<br>也就是说当软件包的最终版本安装之后就不再使用临时工具了<br>为了使shell无法记住可执行二进制代码的位置，需要通过使用<code>+h参数</code>关闭bash的散列功能</p></blockquote></li><li><p>此时bash提示符会显示: <code>I have no name!</code>这是正常的，因为<code>/etc/passwd</code>还没有创建</p></li></ul><hr><h3 id="标准文件系统"><a href="#标准文件系统" class="headerlink" title="标准文件系统"></a>标准文件系统</h3><p><strong>创建符合FHS标准的Unix文件系统</strong></p><p><strong>创建系统目录结构(FHS标准目录树):</strong></p><blockquote><p><code>$ mkdir -pv /{bin,boot,etc/opt,home,lib,mnt,opt}</code><br><code>$ mkdir -pv /{media/{floppy,cdrom},sbin,srv,var}</code><br><code>$ install -dv -m 0750 /root</code><br><code>$ install -dv -m 1777 /tmp /var/tmp</code><br><code>$ mkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}</code><br><code>$ mkdir -pv /usr/{,local/}share/{doc,info,locale,man}</code><br><code>$ mkdir -pv /usr/{,local/}share/{misc,terminfo,zoneinfo}</code><br><code>$ mkdir -pv /usr/{,local/}share/man/man{1..8}</code></p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">for</span> <span class="keyword">dir</span> <span class="keyword">in</span> /usr /usr/<span class="keyword">local</span>; <span class="keyword">do</span></span><br><span class="line">ln -sv share/&#123;<span class="keyword">man</span>,doc,info&#125; <span class="variable">$dir</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p><code>$ mkdir -pv /var/{lock,log,mail,run,spool}</code><br><code>$ mkdir -pv /var/{opt,cache,lib/{misc,locate},local}</code></p></blockquote><hr><p><strong>创建必需的文件与符号连接</strong></p><ul><li>一些程序使用固化的路径(<code>hard-wired paths</code>)指向一些目前还不存在的程序上</li><li>为了兼容这些程序，可以创建一些符号链接</li><li>然后在软件安装之后用实际文件进行替代</li></ul><p><strong>创建必要的符号链接:</strong></p><blockquote><p><code>$ ln -sv /tools/bin/{bash,cat,echo,grep,pwd,stty} /bin</code><br><code>$ ln -sv /tools/bin/perl /usr/bin</code><br><code>$ ln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib</code><br><code>$ ln -sv /tools/lib/libstdc++.so{,.6} /usr/lib</code><br><code>$ ln -sv bash /bin/sh</code><br><code>$ touch /etc/mtab</code></p></blockquote><hr><h3 id="用户与用户组的基本配置"><a href="#用户与用户组的基本配置" class="headerlink" title="用户与用户组的基本配置"></a>用户与用户组的基本配置</h3><p><strong>配置必要的用户组</strong></p><ul><li><p>以下区块为LFS-v6.2独有</p></li><li><p>一个常规的Linux系统在<code>/etc/mtab</code>中有一个已挂载文件系统的列表正常情况下</p></li><li><p>这个文件 在我们挂载一个新的文件系统的时候会被创建</p></li><li><p>因为从此开始在chroot环境下不会再挂载任何文件系统</p></li><li><p>所以需要人为的为那些用到<code>/etc/mtab</code>的程序创建一个空文件</p><blockquote><p><code>$ touch /etc/mtab</code></p></blockquote></li><li><p>为了让<code>root用户</code>可以登录而且<code>用户名root</code>可以被识别</p></li><li><p>在这里需要创建相应的<code>/etc/passwd</code>和<code>/etc/group</code>文件</p></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat &gt; <span class="regexp">/etc/passwd</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span>0<span class="symbol">:</span>0<span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>此时root的真正密码将在后面设置(<code>&quot;x&quot;</code>在这里只是一个占位符)</li></ul><hr><ul><li>使用以下命令创建/etc/group文件(LFS-v6.2):</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>在LFS-v6.2这里创建的用户组并不是某个标准所要求的部分<blockquote><p>只是因为在随后<code>Udev配置</code>将要用到而以</p></blockquote></li></ul><hr><p><strong>创建<code>root</code>及<code>nobody用户</code>和必要的组(LFS-v6.3):</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>passwd &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>:<span class="number">0</span>:<span class="string">root:</span><span class="regexp">/root:/</span>bin/bash </span><br><span class="line"><span class="string">nobody:</span><span class="string">x:</span><span class="number">99</span>:<span class="number">99</span>:Unprivileged <span class="string">User:</span><span class="regexp">/dev/</span><span class="string">null:</span><span class="regexp">/bin/</span><span class="literal">false</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line"><span class="string">mail:</span><span class="string">x:</span><span class="number">34</span>: </span><br><span class="line"><span class="string">nogroup:</span><span class="string">x:</span><span class="number">99</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><hr><ul><li><p>因为完整的Glibc在目标系统中已经安装</p></li><li><p>而且<code>/etc/passwd</code>和<code>/etc/group</code>文件也已创建</p></li><li><p>所以用户名和组名现在可以开始使用了</p></li><li><p>重新加载bash，以使root用户起效</p><blockquote><p><code>$ exec /tools/bin/bash --login +h</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>参数+h</code>用于告诉bash不能使用其内部哈希表查找路径</p></blockquote></li></ul><hr><ul><li>程序 login, agetty, init(还有其它一些程序)使用一些日志文件来记录信息</li><li>比如谁在什么时候登录了系统等等</li><li>然而如果这些日志文件不存在，这些程序则无法写入</li><li>下面初始化这些日志文件，并设置适当的权限:</li></ul><blockquote><p><code>$ touch /var/run/utmp /var/log/{btmp,lastlog,wtmp}</code><br><code>$ chgrp -v utmp /var/run/utmp /var/log/lastlog</code><br><code>$ chmod -v 664 /var/run/utmp /var/log/lastlog</code></p></blockquote><ul><li>目录作用明细:<blockquote><p><code>/var/run/utmp</code>记录着现在登录的用户<br><code>/var/log/wtmp</code>记录所有的登录和退出<br><code>/var/log/lastlog</code>记录每个用户最后的登录信息<br><code>/var/log/btmp</code>记录错误的登录尝试</p></blockquote></li></ul><hr><ul><li>此时就已经完成了对目标主机的基础配置</li><li>同时已经进入目标主机的标准环境了</li><li>一下步即开始对目录主机进行程序编译与配置</li><li>进入源代码目录与设置LFS变量<blockquote><p><code>$ cd /sources</code><br><code>$ export LFS=/sources</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>官方-EN-LFS-v6.2</li><li>官方-EN-LFS-v6.3</li><li>金步国-CN-LFS-v6.2</li><li>孙海勇-CN-LFS-v6.3</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-3-3&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-3&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-9</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-9/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-9/</id>
    <published>2020-02-29T20:44:43.000Z</published>
    <updated>2020-03-02T02:30:03.689Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h2 id="LFS-9"><a href="#LFS-9" class="headerlink" title="LFS-9"></a>LFS-9</h2><hr><h3 id="实现逻辑梳理-LFS-v6-3"><a href="#实现逻辑梳理-LFS-v6-3" class="headerlink" title="实现逻辑梳理(LFS-v6.3)"></a>实现逻辑梳理(LFS-v6.3)</h3><ul><li>主观理解，仅供参考</li></ul><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol><li>将原主机分区，假设分为两个分区:<blockquote><p>一个用作swap内存交换分区，另一个用作LFS系统制作分区</p></blockquote></li><li>创建LFS系统的制作及操作目录</li><li>挂载FLS系统所对应的分区目录</li><li>在被挂载的分区目录下建立源码存放目录/sources与工具编译目录/tools</li><li>利用原主机的root环境来为文件目录分配权限，同时配置目录的符号链接<blockquote><p>以方便操作与管理</p></blockquote></li><li>创建用户lfs与用户组lfs(可以同名)</li><li>登陆用户并建立lfs用户环境</li></ol><p><strong>建立临时系统</strong></p><ul><li><p>此时将所有的文件都编译进<code>$LFS/tools</code>目录内</p></li><li><p>源代码与压缩包存储于<code>$LFS/sources</code>目录内</p></li><li><p>构建GNU工具链内工具</p></li></ul><ol><li>Binutils Pass-1</li><li>GCC Pass-1</li><li>Kernel Headers API</li><li>Gilbc<blockquote><p>在Glibc在正确编译且安装完之后:<br>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils Pass-2</li><li>GCC Pass-2</li></ol><ul><li><p>构建其它辅助工具与系统程序</p></li><li><p>编译完成时，临时系统已完整</p></li><li><p>然后利用Strip程序对环境进行清理，info与man也可以进行清理</p></li><li><p>此时可以进入下一阶段</p></li></ul><hr><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li><p>此时的临时系统将作为目标系统的辅助系统以保证存在目的</p></li><li><p>退出lfs用户</p><blockquote><p>此时回到原主机的root环境<br>从此开始的编译都由root用户进行</p></blockquote></li><li><p>此时为了避免安全上的问题</p><blockquote><p>将$LFS/tools目录权限转交给root用户<br>可以将tools目录保留，以创建多个相同版本的LFS</p></blockquote></li></ul><hr><p><strong>首先挂载虚拟内核文件系统</strong></p><ol><li>创建虚拟内核文件系统(或其它设备文件)将要挂载的目录(dev,proc,sys)</li><li>创建设备初始节点</li><li>挂载并填充/dev目录</li><li>最后挂载虚拟文件系统至上面创建的节点之内<blockquote><p>挂载的同时创建了几个最重要的文件系统</p></blockquote></li><li>这里也可以将<code>/lfs-sources/*</code>内的源码包复制到<code>$LFS/sources/</code>内<blockquote><p>以方便使用</p></blockquote></li></ol><p><strong>其它内容:</strong></p><ul><li><p>系统环境逻辑:</p><blockquote><p><code>原主机-&gt;临时系统-&gt;目标系统</code><br><code>原主机-&gt;临时系统</code><br><code>原主机-&gt;目标系统</code><br><code>目标系统&lt;-临时系统</code></p></blockquote></li><li><p>这里要重点指出它们的关系并不是线性的</p></li><li><p>主系统包含于临时系统与目标系统</p></li><li><p>进入chroot的目的是让目标系统完全独立</p><blockquote><p>但此时的目标系统还带有临时系统所编译的工具环境<br>此时的原主机进入了chroot模式，因此现在不存在原主机的概念<br>原主机即为目标系统，而目标系统内当前还拥有临时系统的环境与功能</p></blockquote></li></ul><hr><p><strong>进入chroot来进行对LFS系统的操作</strong></p><ul><li>chroot</li><li>此时根据指令来进入chroot环境</li><li>现在所做的任何工作都是为了对已经进入的chroot进行补充<blockquote><p>以构建最终的LFS系统<br>并且chroot内只能使用到临时系统所构建的工具环境<br>此时所有的工作都被限制在LFS文件系统内<br>所以<code>Bash shell $LFS</code>就是现在的根目录<code>/</code></p></blockquote></li></ul><ol><li>清除所有chroot环境变量</li><li>重新设定HOME,TERM,PS1,PATH等变量的值</li><li>创建LFS系统的系统目录结构(必须是标准目录树/完全遵守FHS标准)</li><li>配置必要的符号链接<blockquote><p>因为有一些程序使用的固化的路径(hard-wired paths)指向一些还不存在的程序上<br>为了兼容这些程序，可以创建一些符号链接，然后在程序安装之后用实际文件进行替代</p></blockquote></li><li>然后再去创建root及nobody用户和必要的组<blockquote><p>以让root用户可以登陆与用户名root可以被识别</p></blockquote></li><li>此时因为已经拥有了临时系统内所构建的glibc和刚刚创建的<code>/etc/passwd</code>和<code>/etc/group</code>文件<blockquote><p>所以现在用户名和用户组已经处于可用状态了</p></blockquote></li><li>启动新的shell</li><li>设置某些特定程序的log文件，以保证这些程序能够正常写入</li><li>最后进入源代码目录下，此时还可以将之前复制到sources下的源代码文件目录设置符号链接</li></ol><hr><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><strong>建立目标系统</strong></p><ul><li><p>此时将所有的文件都编入当前LFS主机(分区)的/usr/bin目录下</p></li><li><p>GNU工具链内工具</p></li></ul><ol><li>Linux kernel headers</li><li>Man-pages</li><li>Glibc<blockquote><p>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils</li><li>GCC</li></ol><ul><li>构建其它辅助工具与系统程序<blockquote><p>当目标主机最后一个工具-vim已经编译安装成功之后，开始进行下一阶段</p></blockquote></li></ul><hr><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul><li>此时应该先对系统做一个备份<blockquote><p>因为此时操作此系统的人处于任何原因的手残或其它的失误<br>都会导致新操作系统的完全崩坏</p></blockquote></li></ul><ol><li>然后退出此时的虚拟根环境</li><li>接着再次进入虚拟根环境(为了清理系统)</li><li>利用Strip来清理系统</li><li>清理完成之后退出chroot并重新进入chroot<blockquote><p>从现在开始，每当重新进入LFS系统的chroot环境时，都不应该需要加入<code>/tools</code>参数了<br>因为此时的LFS主机内已经拥有完整的工具环境了</p></blockquote></li><li>进入chroot环境之后进行下一步配置<blockquote><p>包括配置启动脚本(boot loader)，设备处理模块，控制台，网络配置脚本，Bash Shell启动文件等等<br>然后为设备创建惯用的符号链接</p></blockquote></li><li>为了让LFS系统能够启动，还需要配置<code>/etc/fstab</code>文件</li><li>最后安装Linux内核</li><li>当配置完内核之后，安装GRUB并配置GRUB启动菜单</li><li>退出chroot</li><li>卸载虚拟文件系统</li><li>卸载LFS自己的文件系统</li><li>此时应该能够保证GRUB引导装载程序已经被设置，并且按照其启动菜单可以自动启动LFS系统</li></ol><p><strong>shutdown -r now</strong></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><hr><ul><li>需要理解的知识点:</li></ul><ol><li>工具链的制作与配置和对于配置细节的理解<blockquote><p>包括静态库与动态库的配置，应用与理解<br>打上该打的补丁(patch)，批处理文件(sed)，链接器与汇编器的使用与配置(as/ld)</p></blockquote></li><li>链接的过程与程序配置文件的编写<blockquote><p>在进入下一个阶段时对软链接的使用</p></blockquote></li><li>从一个系统到达另一个系统的配置环节<blockquote><p>清理工具(Strip)<br>固化代码</p></blockquote></li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-LFS-v6.6(非官方)<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><h3 id="LFS-补充内容"><a href="#LFS-补充内容" class="headerlink" title="LFS-补充内容"></a>LFS-补充内容</h3><ul><li><p>临时系统环境搭建(分区)</p></li><li><p>临时工具链安装与说明</p></li><li><p>临时工具链配置与说明</p></li><li><p>目标系统环境搭建(chroot)</p></li><li><p>目标工具链安装与说明</p></li><li><p>目标工具链配置与说明</p></li><li><p>然后以chroot进入纯粹的目标系统进行程序编译与安装</p></li><li><p>再然后进行对启动脚本与其它系统所需的最基本脚本进行配置</p></li><li><p>最后再创建fstab与编译并配置内核，重启系统结束</p></li><li><p>具体的脚本配置根据当前本地主机的内核版本而定</p></li><li><p>可参考LFS官方文案，这里不做过多赘述</p></li></ul><hr><ul><li>LFS-v6.2/v6.3所需的最基本脚本配置文件与程序</li></ul><ol><li>配置，编译并安装 LFS-Bootscripts-6.3</li><li>配置setclock脚本 (Configuring the setclock Script)</li><li>配置Linux控制台 (Configuring the Linux Console)</li><li>配置sysklogd脚本 (Configuring the sysklogd Script)</li><li>创建/etc/inputrc文件 (Creating the /etc/inputrc File)</li><li>配置Bash Shell启动文件 (The Bash Shell Startup Files)</li><li>配置localnet脚本 (Configuring the localnet Script)</li><li>自定义/etc/hosts文件 (Customizing the /etc/hosts File)</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li><li>配置网络脚本 (Creating the /etc/fstab File)</li><li>配置，编译并安装Linux-2.6.22.5</li><li>配置GRUB以使得系统可引导 (Making the LFS System Bootable)</li><li>重启操作系统 (Rebooting the System)</li></ol><hr><p><strong>参考资料:</strong></p><ul><li><p>LFS-v6.2/v6.3</p></li><li><p>EN-LFS-书籍仓库<a href="http://www.linuxfromscratch.org/lfs/downloads/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/</code></p></blockquote></li><li><p>EN-LFS-v6.2<a href="http://www.linuxfromscratch.org/lfs/downloads/6.2/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.2/</code></p></blockquote></li><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>具体的中文版可参考金钟国及其所属团队的译本</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-9&quot;&gt;&lt;a href=&quot;#LFS-9&quot; class=&quot;headerlink&quot; title=&quot;LFS-9&quot;&gt;&lt;/a&gt;LFS-9&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-8</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-8/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-8/</id>
    <published>2020-02-29T20:40:11.000Z</published>
    <updated>2020-02-29T20:44:36.228Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h2 id="LFS-8"><a href="#LFS-8" class="headerlink" title="LFS-8"></a>LFS-8</h2><hr><h3 id="LFS-v6-3基本程序一览"><a href="#LFS-v6-3基本程序一览" class="headerlink" title="LFS-v6.3基本程序一览"></a>LFS-v6.3基本程序一览</h3><ul><li>LFS-v6.3内软件目录(包含版本与章节)</li><li>不包含[GNU 工具链]内程序</li></ul><p><strong>参考资料:</strong></p><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-6.6非官方<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><p><strong>临时主机程序目录</strong></p><p>5.13. Ncurses-5.6<br>5.14. Bash-3.2<br>5.15. Bzip2-1.0.4<br>5.16. Coreutils-6.9<br>5.17. Diffutils-2.8.1<br>5.18. Findutils-4.2.31<br>5.19. Gawk-3.1.5<br>5.20. Gettext-0.16.1<br>5.21. Grep-2.5.1a<br>5.22. Gzip-1.3.12<br>5.23. Make-3.81<br>5.24. Patch-2.5.4<br>5.25. Perl-5.8.8<br>5.26. Sed-4.1.5<br>5.27. Tar-1.18<br>5.28. Texinfo-4.9<br>5.29. Util-linux-2.12r</p><hr><p><strong>目标主机程序目录</strong></p><p>6.13. Berkeley DB-4.5.20<br>6.14. Sed-4.1.5<br>6.15. E2fsprogs-1.40.2<br>6.16. Coreutils-6.9<br>6.17. Iana-Etc-2.20<br>6.18. M4-1.4.10<br>6.19. Bison-2.3<br>6.20. Ncurses-5.6<br>6.21. Procps-3.2.7<br>6.22. Libtool-1.5.24<br>6.23. Perl-5.8.8<br>6.24. Readline-5.2<br>6.25. Zlib-1.2.3<br>6.26. Autoconf-2.61<br>6.27. Automake-1.10<br>6.28. Bash-3.2<br>6.29. Bzip2-1.0.4<br>6.30. Diffutils-2.8.1<br>6.31. File-4.21<br>6.32. Findutils-4.2.31<br>6.33. Flex-2.5.33<br>6.34. GRUB-0.97<br>6.35. Gawk-3.1.5<br>6.36. Gettext-0.16.1<br>6.37. Grep-2.5.1a<br>6.38. Groff-1.18.1.4<br>6.39. Gzip-1.3.12<br>6.40. Inetutils-1.5<br>6.41. IPRoute2-2.6.20-070313<br>6.42. Kbd-1.12<br>6.43. Less-406<br>6.44. Make-3.81<br>6.45. Man-DB-2.4.4<br>6.46. Mktemp-1.5<br>6.47. Module-Init-Tools-3.2.2<br>6.48. Patch-2.5.4<br>6.49. Psmisc-22.5<br>6.50. Shadow-4.0.18.1<br>6.51. Sysklogd-1.4.1<br>6.52. Sysvinit-2.86<br>6.53. Tar-1.18<br>6.54. Texinfo-4.9<br>6.55. Udev-113<br>6.56. Util-linux-2.12r<br>6.57. Vim-7.1</p><hr><p><strong>最终阶段程序</strong></p><p>7.2. LFS-Bootscripts-6.3<br>Linux-2.6.22.5</p><hr><h2 id="相关指令参考"><a href="#相关指令参考" class="headerlink" title="相关指令参考"></a>相关指令参考</h2><ul><li>patch</li><li>sed</li><li>ld</li><li>strip</li></ul><hr><h3 id="patch命令"><a href="#patch命令" class="headerlink" title="patch命令"></a>patch命令</h3><ul><li><p>Linux patch命令用于修补文件(为文件打上补丁)</p><blockquote><p>patch指令让用户利用设置修补文件的方式，修改，更新原始文件<br>倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行<br>如果配合修补文件的方式则能一次修补大批文件<br>这也是Linux系统核心的升级方法之一</p></blockquote></li><li><p>语法:</p><blockquote><p><code>patch [参数] [选项] [原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-patch.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-patch.html</a></p></blockquote></li><li><p>实例:</p></li><li><p><code>$ patch -Np1 i ../expect-5.43.0-spawn-1.patch</code></p><blockquote><p>将<code>expect</code>工具打上补丁<code>expect-5.43.0-spawn-1.patch</code></p></blockquote></li></ul><hr><h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><ul><li><p>Linux sed 命令的作用是利用脚本来处理文本文件</p></li><li><p>sed可依照脚本的指令来处理，编辑文本文件</p></li><li><p>sed主要用来自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等</p></li><li><p>命令语法:</p><blockquote><p><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-sed.html</a></p></blockquote></li><li><p>实例:</p></li><li><p>利用sed命令来确保在非bootstrap编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ld命令"><a href="#ld命令" class="headerlink" title="ld命令"></a>ld命令</h3><ul><li><p>ld 命令是二进制工具集GNU Binutils的一员，是GNU的链接器，用于将目标文件与库链接为可执行文件或库文件</p></li><li><p>命令语法:</p><blockquote><p><code>$ ld [OPTIONS] OBJFILES</code></p></blockquote></li><li><p>实例:</p></li><li><p>链接目标文件生成可执行文件</p></li><li><p>给定C++目标文件<code>test.o</code>与<code>main.o</code>，生成可执行文件<code>test.out</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ld /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o &amp;&amp;</span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtbegin</span>.<span class="title">o</span> /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtend</span>.<span class="title">o</span> &amp;&amp;</span></span><br><span class="line">-L/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5 &amp;&amp;</span></span><br><span class="line">-L/usr/lib64 -L/usr/<span class="class"><span class="keyword">lib</span> -<span class="title">lstdc</span>++ -<span class="title">lm</span> -<span class="title">lgcc_s</span> -<span class="title">lc</span> -<span class="title">lgcc</span>  <span class="title">main</span>.<span class="title">o</span> <span class="title">test</span>.<span class="title">o</span> -<span class="title">o</span> <span class="title">test</span>.<span class="title">out</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>具体参考:<br><a href="https://www.gnu.org/software/binutils/" target="_blank" rel="noopener">https://www.gnu.org/software/binutils/</a><br><a href="https://www.linux.org/docs/man1/ld.html" target="_blank" rel="noopener">https://www.linux.org/docs/man1/ld.html</a><br><a href="https://blog.csdn.net/K346K346/article/details/89088652" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/89088652</a><br><a href="https://dablelv.blog.csdn.net/article/details/88094902" target="_blank" rel="noopener">https://dablelv.blog.csdn.net/article/details/88094902</a><br><a href="http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat" target="_blank" rel="noopener">http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat</a></p></blockquote><ul><li>ld和ld.so的区别<a href="https://www.cnblogs.com/foohack/p/4105717.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.cnblogs.com/foohack/p/4105717.html</code></p></blockquote></li></ul><hr><h3 id="Strip"><a href="#Strip" class="headerlink" title="Strip"></a>Strip</h3><ul><li><p>从特定文件中剥掉一些符号信息和调试信息，使文件变小</p></li><li><p>strip - Discard symbols from object files(from man strip)</p></li><li><p>具体语法:</p><blockquote><p><code>$ strip [-xxx bfdname |--xxx=bfdname]</code><br>strip 之后的任何选项都是自定义参数，这里将不会做过多阐述<br>参考自: <a href="https://blog.csdn.net/qq_37858386/article/details/78559490" target="_blank" rel="noopener">https://blog.csdn.net/qq_37858386/article/details/78559490</a></p></blockquote></li><li><p>实例:</p></li><li><p>清理<code>/tools/lib</code>内所有的debug文件</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-8&quot;&gt;&lt;a href=&quot;#LFS-8&quot; class=&quot;headerlink&quot; title=&quot;LFS-8&quot;&gt;&lt;/a&gt;LFS-8&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-2</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/</id>
    <published>2020-02-29T16:58:18.000Z</published>
    <updated>2020-02-29T16:59:17.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-2"><a href="#GNU-LFS-3-2" class="headerlink" title="GNU LFS-3-2"></a>GNU LFS-3-2</h3><hr><p><strong>目标主机-2</strong></p><ul><li>GCC</li><li>Binutils</li><li>LFS-v6.2/v6.3</li></ul><hr><h3 id="Binutils"><a href="#Binutils" class="headerlink" title="Binutils"></a>Binutils</h3><p><strong>Binutils-2.17/Binutils-2.16.1</strong></p><blockquote><p><code>$ tar xvf $LFS/binutils-2.17/2.16.1.tar.bz2</code><br><code>$ mkdir -v ../binutils-build</code><br><code>$ cd ../binutils-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ../binutils<span class="number">-2.17</span>/<span class="number">2.16</span><span class="number">.1</span>/configure --prefix=/usr \</span><br><span class="line">            --enable-<span class="keyword">shared</span></span><br></pre></td></tr></table></figure></li><li><p>源码编译:</p><blockquote><p><code>$ make tooldir=/usr</code></p></blockquote></li></ul><p><strong>make参数含义:</strong></p><ul><li><p>参数<code>tooldir=/usr</code></p><blockquote><p>通常情况下，tooldir(可执行文件的安装目录)是<code>$(exec_prefix)/$(target_alias)</code><br>例如在i686机器上，将是<code>tt class=&quot;filename&quot;&gt;/usr/i686-pc-linux-gnu</code><br>因为此时只为自己的系统进 行编译，就并不需要在<code>/usr</code>目录后面再存在特殊的后缀<br><code>$(exec_prefix)/$(target_alias)</code>只是在交叉编译时(比如在Intel机器上编译将要在PowerPC上执行的程序)才用到</p></blockquote></li><li><p>编译测试套件:</p><blockquote><p><code>$ make check</code></p></blockquote></li><li><p>编译安装软件包</p><blockquote><p><code>$ make tooldir=/usr install</code></p></blockquote></li><li><p>安装某些软件包需要的<code>libiberty头文件</code></p><blockquote><p><code>$ cp -v ../binutils-2.17/2.16.1/include/libiberty.h /usr/include</code></p></blockquote></li><li><p>Binutils的内容这里不做过多阐述，可参考原文第6.11.2章节</p></li></ul><hr><h3 id="GCC-4-1-2-GCC-4-0-3"><a href="#GCC-4-1-2-GCC-4-0-3" class="headerlink" title="GCC-4.1.2/GCC-4.0.3"></a>GCC-4.1.2/GCC-4.0.3</h3><blockquote><p><code>$ tar xvf $LFS/gcc-4.1.2/4.0.3.tar.bz2</code><br><code>$ cd gcc-4.1.2/4.0.3</code></p></blockquote><ul><li><p>先使用一个sed命令来禁止GCC安装它自己的<code>libiberty.a</code></p></li><li><p>这里将使用Binutils附带的<code>libiberty.a</code>来代替</p><blockquote><p><code>$ sed -i &#39;s/install_to_$(INSTALL_DEST) //&#39; libiberty/Makefile.in</code></p></blockquote></li><li><p>在临时主机中应用的bootstrap编译中，编译器会有<code>-fomit-frame-pointer</code>的标志</p></li><li><p>非bootstrap编译默认是忽略这个标志的，可以应用下面的sed命令来确保编译的可靠性</p><blockquote><p><code>$ sed -i &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in</code></p></blockquote></li><li><p><code>fixincludes脚本</code>偶尔会因为修改系统的头文件而出错</p></li><li><p>因为GCC-4.1.2/4.0.3和Glibc-2.5.1/2.3.6是不需要修改的，运行下面的命令可以避免<code>fixincludes脚本</code>运行:</p><blockquote><p><code>$ sed -i &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in</code></p></blockquote></li><li><p>GCC中提供了一个<code>gccbug脚本</code>，会在编译时侦测<code>mktemp</code>是否存在，并且在测试中加强代码</p></li><li><p>这将会导致脚本使用一些不算很随机的名字来命名临时文件</p></li><li><p>因为我们后面会安装mktemp ，这里就将人为的去模仿它的存在:</p><blockquote><p><code>$ sed -i &#39;s/@have_mktemp_command@/yes/&#39; gcc/gccbug.in</code></p></blockquote></li></ul><blockquote><p><code>$ mkdir -v ../gcc-build</code><br><code>$ cd ../gcc-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/(gcc-4.1.2/4.0.3)/configure <span class="attribute">--prefix</span>=/usr \ </span><br><span class="line"><span class="attribute">--libexecdir</span>=/usr/lib \</span><br><span class="line">--enable-shared \ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix \</span><br><span class="line">--enable-__cxa_atexit \ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu \</span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++</span><br></pre></td></tr></table></figure></li><li><p>参数作用与目标主机内的作用相同，这里不做过多阐述</p></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li>预编译测试:<blockquote><p><code>$ make -k check</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>有的软件包希望C PreProcessor(预处理器)安装在<code>/lib</code>目录下，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv ../usr/bin/cpp /lib</code></p></blockquote></li><li><p>许多软件包使用cc作为C编译器的名字，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv gcc /usr/bin/cc</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-1</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/</id>
    <published>2020-02-29T16:12:11.000Z</published>
    <updated>2020-02-29T16:14:12.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-1"><a href="#GNU-LFS-3-1" class="headerlink" title="GNU-LFS-3-1"></a>GNU-LFS-3-1</h3><ul><li>此下任何关于LFS的讨论都是基于LFS-v6.2/6.3的LiveCD与手册之上的</li><li>程序内所拥有的文件与库这里不做阐述，可参考LFS-v6.2/6.3手册内容</li></ul><hr><p><strong>目标主机-1</strong></p><ul><li>内核头文件安装</li><li>Glibc安装</li><li>目标主机工具链解析</li><li>LFS-v6.2/v6.3</li><li>LFS-v6.3-LiveCD</li></ul><h3 id="内核头文件"><a href="#内核头文件" class="headerlink" title="内核头文件"></a>内核头文件</h3><p><strong>LFS-v6.3</strong></p><ul><li>[Linux-2.6.22.5]安装流程<blockquote><p><code>$ tar xvf $LFS/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code><br><code>$ sed -i &#39;/scsi/d&#39; include/Kbuild</code><br><code>$ make mrproper</code><br><code>$ make headers_check</code><br><code>$ make INSTALL_HDR_PATH=dest headers_install</code><br><code>$ cp -rv dest/include/* /usr/include</code><br><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Linux-Libc-Headers-2.6.12.0</strong></p><ul><li><p>添加一个用户空间头文件和新内核对于<code>inotify</code>特性的系统调用支持:</p><blockquote><p><code>$ patch -Np1 -i ../linux-libc-headers-2.6.12.0-inotify-3.patch</code></p></blockquote></li><li><p>安装内核头文件:</p><blockquote><p><code>$ install -dv /usr/include/asm</code><br><code>$ cp -Rv include/asm-i386/* /usr/include/asm</code><br><code>$ cp -Rv include/linux /usr/include</code></p></blockquote></li><li><p>确保这些头文件的所有者是root:</p><blockquote><p><code>$ chown -Rv root:root /usr/include/{asm,linux}</code></p></blockquote></li><li><p>确保用户可以读取这些头文件:</p><blockquote><p><code>$ find /usr/include/{asm,linux} -type d -exec chmod -v 755 {} \;</code><br><code>$ find /usr/include/{asm,linux} -type f -exec chmod -v 644 {} \;</code></p></blockquote></li><li><p>此时安装的头文件为<code>/usr/include/{asm,linux}/*.h</code></p></li><li><p>头文件内容可参考LFS-v6.2的6.7.2章节，这里不做过多阐述</p></li></ul><hr><p><strong>Man-pages-2.63/Man-pages-2.34</strong></p><ul><li>直接进行编译安装:<blockquote><p><code>$ tar xvf $LFS/man-pages-2.63.tar.bz2</code><br><code>$ cd man-pages-2.63</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf man-pages-2.63</code></p></blockquote></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><p><strong>Glibc-2.5.1/2.3.6</strong></p><ul><li><p>在进行之前请检查一下是否glibc-2.5.1和glibc-build这两个目录已经被删除，如果没有删除请删除后在继续</p></li><li><p>将glibc-libidn包解压到Glibc的源码目录:</p><blockquote><p><code>$ tar xvf $LFS/glibc-2.5.1.tar.bz2</code><br><code>$ cd glibc-2.5.1</code><br><code>$ tar -xvf $LFS/glibc-libidn-2.5.1.tar.gz</code><br><code>$ mv glibc-libidn-2.5.1 libidn</code></p></blockquote></li><li><p>应用下面这个patch来修正软件包在<code>sys/kd.h</code>之后包含<code>linux/types.h</code>导致编译错误:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-linux_types-1.patch</code></p></blockquote></li><li><p>添加一个头文件来定义为新内核对于inotify特性的系统调用函数:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-inotify-1.patch</code></p></blockquote></li><li><p>抑制locale的安装，以避免出现bash的bug</p><blockquote><p><code>$ sed -i &#39;/vi_VN.TCVN/d&#39; localedata/SUPPORTED</code></p></blockquote></li><li><p>当运行make install时，一个叫<code>test-installation.pl</code>的脚本会在我们新安装的Glibc上做一个小的完整性测试</p></li><li><p>然而，由于我们的<code>toolchain</code>仍然指向<code>/tools</code>目录，完整性测试会导致使用错误的Glibc</p></li><li><p>所以必须强制脚本测试刚安装的脚本</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i \ </span><br><span class="line">'s|<span class="type">libs</span> -o|<span class="type">libs</span> -L/usr/lib -Wl,-dynamic-linker=/lib/ld-linux.so<span class="number">.2</span> -o|<span class="type">' \   </span></span><br><span class="line"><span class="type">scripts</span>/test-installation.pl</span><br></pre></td></tr></table></figure></li><li><p>继续运行指令:</p><blockquote><p><code>$ sed -i &#39;s|@BASH@|/bin/bash|&#39; elf/ldd.bash.in</code><br><code>$ mkdir -v</code><br><code>$ ../glibc-build</code><br><code>$ cd ../glibc-build</code></p></blockquote></li><li><p>配置安装脚本:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure </span><br><span class="line">-<span class="ruby">-prefix=<span class="regexp">/usr \ </span></span></span><br><span class="line"><span class="ruby">--disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \ </span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--libexecdir=<span class="regexp">/usr/lib</span><span class="regexp">/glibc</span></span></span><br></pre></td></tr></table></figure></li><li><p>新参数说明:</p></li><li><p>参数<code>--libexecdir=/usr/lib/glibc</code></p><blockquote><p>把<code>pt_chown</code>程序的位置从默认的<code>/usr/libexec</code>改为<code>/usr/lib/glibc</code></p></blockquote></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li><p>对结果进行测试:</p><blockquote><p><code>$ make -k check 2&gt;&amp;1 | tee glibc-check-log</code><br><code>$ grep Error glibc-check-log</code></p></blockquote></li><li><p>在安装Glibc的过程中，它会警告缺少<code>/etc/ld.so.conf</code>文件</p></li><li><p>其实这没什么关系，不过下面的命令能修正它:</p><blockquote><p><code>$ touch /etc/ld.so.conf</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>(LFS-v6.2独有)此部还需要安装<code>inotify头文件</code>到系统头文件的地方:</p><blockquote><p><code>$ cp -v ../glibc-2.3.6/sysdeps/unix/sysv/linux/inotify.h \ /usr/include/sys</code></p></blockquote></li><li><p>一次安装所有列在<code>glibc-2.3.6/localedata/SUPPORTED</code>中的<code>locales</code></p><blockquote><p><code>$ make localedata/install-locales</code></p></blockquote></li></ul><hr><p><strong>配置Glibc</strong></p><ul><li><p>此时需要建立<code>/etc/nsswitch.conf</code>文件</p></li><li><p>因为在这个文件丢失或不正确的情况下，Glibc会使用默认配置，而Glibc的默认配置无法很好地在网络环境下工作</p></li><li><p>并且我们也需要设置自己的时区</p></li><li><p>建立一个新的<code>/etc/nsswitch.conf</code>文件:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/nsswitch.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"># Begin /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">passwd: <span class="keyword">files</span> </span><br><span class="line">group: <span class="keyword">files</span> </span><br><span class="line">shado<span class="variable">w:</span> <span class="keyword">files</span></span><br><span class="line">host<span class="variable">s:</span> <span class="keyword">files</span> dns </span><br><span class="line">network<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">protocol<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">service<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">ether<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">rpc: <span class="keyword">files</span> </span><br><span class="line"># End /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>设置时区:</p><blockquote><p><code>$ cp -v --remove-destination /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p></blockquote></li><li><p>配置动态链接库加载程序</p></li><li><p>写入配置</p></li><li><p>LFS-v6.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;ld.so.conf &lt;&lt; &quot;EOF&quot; </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib </span><br><span class="line">&#x2F;opt&#x2F;lib </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>LFS-v6.2</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"># Begin /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span></span><br><span class="line">/usr/<span class="keyword">local</span>/lib </span><br><span class="line">/opt/lib</span><br><span class="line"># End /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote><ul><li>glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误，还有一些能引起错误的LFS手册上有所提及</li><li>由此某些情况的错误可以无视</li></ul><hr><h3 id="调整目标主机工具链"><a href="#调整目标主机工具链" class="headerlink" title="调整目标主机工具链"></a>调整目标主机工具链</h3><ul><li><p>现在，最终的C库已经安装好了，此时需要再次调整工具链，让本章随后编译的那些工具都连接到这个库上</p></li><li><p>基本上，就是把临系统时增加中调整工具链那里做的调整给取消掉</p></li><li><p>在临时系统中，工具链使用的库是从宿主系统的<code>/{,usr/}lib</code>转向新安装的<code>/tools/lib</code>目录</p></li><li><p>同样的，现在工具链使用的库将从临时的<code>/tools/lib</code>转向LFS系统最终的<code>/{,usr/}lib</code>目录</p></li><li><p>首先，备份<code>/tools</code>下的链接</p><blockquote><p>用刚才在临时主机中编译的链接器来替换<br>再创建一个链接到在<code>/tools/$(gcc -dumpmachine)/bin</code>中的副本</p></blockquote></li><li><p>执行以下命令:</p><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote></li><li><p>接下来，修正GCC的specs文件，使它指向新的动态链接器</p></li><li><p>这样GCC才能知道在哪能发 现开始文件</p></li><li><p>这里应用一个sed命令:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | sed <span class="string">\</span> </span><br><span class="line">-e <span class="string">'s@/tools/lib/ld-linux.so.2@/lib/ld-linux.so.2@g'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*startfile_prefix_spec:/&#123;n;s@.*@/usr/lib/ @&#125;'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*cpp:/&#123;n;s@$@ -isystem /usr/include@&#125;'</span> &gt; <span class="string">\</span> </span><br><span class="line">`dirname $(gcc --<span class="built_in">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>还可以利用perl命令</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | \ </span><br><span class="line">perl -p -e's<span class="comment">@/tools/lib/ld-linux.so.2@</span>/<span class="keyword">lib</span>/ld-linux.so<span class="number">.2</span><span class="comment">@g;' \</span></span><br><span class="line"><span class="comment">-e 's@</span>\*startfile_prefix_spec:\n<span class="comment">@$_/usr/lib/ @</span>g;' &gt; \</span><br><span class="line">`dirname$(gcc --<span class="keyword">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>如果此时本地主机的系统平台上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须把上面命令里的<code>ldlinux.so.2</code>换成此时本地主机的系统平台上动态连接器的名字</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-1&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-1&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-4</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/</id>
    <published>2020-02-29T11:26:43.000Z</published>
    <updated>2020-02-29T11:27:56.144Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-4"><a href="#GNU-LFS-2-4" class="headerlink" title="GNU LFS-2-4"></a>GNU LFS-2-4</h2><ul><li>[GNU 工具链]全面逻辑梳理</li><li>重点在于配置链接器与工具链的逻辑</li></ul><hr><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul><li>可以将临时主机的工具链搭建分为两部分</li><li>前半部分为第一遍编译并安装GCC，Binutils和内核头文件</li><li>后半部分为编译并安装Glibc，在配置完Glibc之后，正式调整临时工具链并再次安装GCC与Binutils</li><li>第一步与第二部和第五步与第六步的顺序没有严格规定</li><li>但对GCC与Binutils的第二次编译安装必须在先配置并且编译安装完Glibc之后再进行</li></ul><hr><ul><li><code>Binutils-&gt;GCC-&gt;Headres-&gt;GLibc-&gt;Tools调整-&gt;Binutils-&gt;GCC/C++补丁</code></li><li>参考至<code>LFSv6.2/6.3</code></li></ul><hr><ul><li>因为这里所使用的LiveCD是LFS官方提供的</li><li>由于官方于6.3版本之后就停止维护了</li><li>所以这里只介绍6.3及以下版本</li></ul><hr><ul><li>这里将以下七个工具所需要的</li><li>每个工具编译的重要步骤</li><li>与对工具链的链接和链接器的配置进行了逻辑的梳理</li></ul><hr><h3 id="1-Binutils-Pass-1"><a href="#1-Binutils-Pass-1" class="headerlink" title="1. Binutils Pass-1"></a>1. Binutils Pass-1</h3><ul><li>编译并安装过后</li><li>为调整工具链而准备链接器</li></ul><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/tools/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote><ul><li>参数<code>-C ld LIB_PATH=/tools/lib</code></li><li>指定<code>Makefile</code>的<code>LIB_PATH</code>变量值</li><li>使其明确指向临时工具目录，以覆盖默认值</li><li>这个变量同时还指定了链接器的默认库搜索路径</li><li>在编译完Glibc后就会用到</li></ul><hr><h3 id="2-GCC-Pass-1"><a href="#2-GCC-Pass-1" class="headerlink" title="2. GCC Pass-1"></a>2. GCC Pass-1</h3><ul><li>编译并安装过后</li><li>创建gcc的符号链接为cc，以保证兼容性<blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li></ul><hr><h3 id="3-kernel-headers-API"><a href="#3-kernel-headers-API" class="headerlink" title="3. kernel headers API"></a>3. kernel headers API</h3><ul><li>将头文件编译并复制到所需目录</li></ul><hr><h3 id="4-Glibc"><a href="#4-Glibc" class="headerlink" title="4. Glibc"></a>4. Glibc</h3><ul><li>编译并安装C标准库</li><li>执行<code>touch /tools/etc/ld.so.conf</code></li><li>以修补安装过程中缺少的<code>/tools/etc/ld.so.conf</code></li></ul><hr><h3 id="5-调整工具链-LFS-v6-2-v6-3"><a href="#5-调整工具链-LFS-v6-2-v6-3" class="headerlink" title="5. 调整工具链(LFS-v6.2/v6.3)"></a>5. 调整工具链(LFS-v6.2/v6.3)</h3><ul><li><p>在临时系统的C标准库安装好之后</p></li><li><p>需要将临时工具链中的所有工具都连接到C标准库之上</p></li><li><p>为了达到这个目标，必须调整链接器和编译器的space文件</p></li><li><p>因为Binutils Pass-1的时候以经调整过链接器了</p></li><li><p>所以现在需要做的只是将其重新命名并被正确的找到和使用</p></li><li><p>方法是备份原来的链接器，然后再用调整过的链接器来替代</p></li><li><p>最后再创建一个指向<code>/tools/$(gcc -dumpmachine)/bin</code>中链接器副本的链接</p></li></ul><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote><ul><li>从现在开始，所有程序都将连接到<code>/tools/lib</code>中的库文件</li></ul><hr><ul><li><p>接下来需要做的就是修正GCC中的spaces文件</p></li><li><p>目的是使他指向一个新的动态链接器</p></li><li><p>本质上就是把specs中所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>这里用的是sed命令，有两种语法(分别是LFS-v6.2与LFS-v6.3)</p></li><li><p>如果当前的本地主机上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须人为的把以下命令里的<code>ldlinux.so.2</code>换成本地主机的系统平台上动态连接器的名</p></li><li><p>LFS-v6.2</p></li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFIL</span><br></pre></td></tr></table></figure><ul><li>LFS-v6.3</li></ul><blockquote><p><code>$ gcc -dumpspecs | sed &#39;s@^/lib/ld-linux.so.2@/tools&amp;@g&#39; &gt;</code>dirname $(gcc -print-libgcc-file-name)<code>/ specs</code></p></blockquote><hr><ul><li><p>最后删除GCC专属头文件目录中的头文件，以避免宿主机中的头文件污染编译环境</p></li><li><p>这里的命令v6.2与v6.3没有区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>工具链的调整方法有好几种</p></li><li><p>而且不同版本GCC的specs可能会有不同</p></li><li><p>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>还直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件</p></li></ul><hr><h3 id="6-Binutils-Pass-2"><a href="#6-Binutils-Pass-2" class="headerlink" title="6. Binutils Pass-2"></a>6. Binutils Pass-2</h3><ul><li><p>编译并安装</p></li><li><p>编译配置中配置参数<code>--with-lib-path=/tools/lib</code></p></li><li><p>以指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code></p></li><li><p>以防止连接器搜索宿主系统的库目录</p></li><li><p>最后为目标主机的调整工具链阶段配置链接器:</p><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/usr/lib:/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote></li></ul><hr><h3 id="7-GCC-C-补丁-Pass-2"><a href="#7-GCC-C-补丁-Pass-2" class="headerlink" title="7. GCC/C++补丁 Pass-2"></a>7. GCC/C++补丁 Pass-2</h3><ul><li><p>在GCC编译过程中会运行<code>fixincludes脚本</code>来扫描系统头文件目录</p></li><li><p>并找出需要修正的头文件，然后把修正后的头文件放到GCC专属头文件目录里</p></li><li><p>因为现在GCC和Glibc已经安装完毕，而且它们的头文件已知无需修正</p></li><li><p>所以这里并不需要<code>fixincludes脚本</code></p></li><li><p>必须先禁止fixincludes运行，以保证编译环境不受原主机所污染</p><blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig} &amp;&amp;</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li><p>因为在前几步中编译的GCC Pass-1中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项</p></li><li><p>而非<code>bootstrap</code>编译则默认忽略了该选项</p></li><li><p>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项</p></li><li><p>用以保持一致性:</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure><ul><li><p>然后使用补丁修改补丁修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置:</p><blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li><p>该命令同时还把/usr/include`从GCC的头文件搜索路径里删掉</p></li><li><p>现在预先打补丁而不是在安装GCC之后调整specs文件可以保证新的动态连接器在编译GCC的时候就用上</p></li><li><p>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></li><li><p>然后配置编译器，并进行编译与编译安装</p></li><li><p>关于GCC的C++是在LFS-v9.0中出现的，这里先不做过多阐述</p></li></ul><hr><ul><li>至此结束临时主机的[GNU 工具链]配置环节</li><li>下一步即为配置其它的辅助命令与工具链所处的大环境</li><li>从而为目标主机提供应有的功能与服务</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-2-4&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-4&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-3</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-3/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-3/</id>
    <published>2020-02-29T11:22:36.000Z</published>
    <updated>2020-02-29T11:26:27.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-3"><a href="#GNU-LFS-2-3" class="headerlink" title="GNU LFS-2.3"></a>GNU LFS-2.3</h3><ul><li>GCC Pass-2</li><li>Bintils Pass-2</li></ul><hr><h3 id="Bintils-Pass-2"><a href="#Bintils-Pass-2" class="headerlink" title="Bintils Pass-2"></a>Bintils Pass-2</h3><ul><li>Binutils-2.16.1/LFS-6.2 Pass-2 154 MB 1.1 SBU</li><li>Binutils-2.17/LFS-6.3 Pass 2</li><li>Binutils-2.32/LFS-9.0 Pass-2 879 MB 1.1 SUB</li></ul><hr><p><strong>Binutils-2.16.1/2.17</strong></p><ul><li>解压文件并进入编译目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li></ul><p>编译配置</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="string">../binutils-2.17</span><span class="params">(-2.16.1)</span><span class="string">/configure</span> <span class="params">--prefix=/tools</span> \</span><br><span class="line"><span class="params">--disable-nls</span> \ </span><br><span class="line"><span class="params">--with-lib-path=/tools/lib</span></span><br></pre></td></tr></table></figure><ul><li><p>新参数含义:</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这个选项指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code><br>以防止连接器搜索宿主系统的库目录</p></blockquote></li><li><p>编译及安装</p><blockquote><p><code>$ make</code><br><code>$ make install</code></p></blockquote></li><li><p>为目标机器的工具链调整配置连接器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new/tools/bin</span><br></pre></td></tr></table></figure></li><li><p>最后清理一下</p><blockquote><p><code>$ cd .. rm -rf binutils-build</code><br><code>$ rm -rf binutils-2.17</code></p></blockquote></li></ul><hr><p><strong>Binutils-2.32</strong></p><ul><li>编译配置<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                \ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                 \ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib         \ </span><br><span class="line"><span class="built_in">..</span>/configure                 \    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools          \    </span><br><span class="line">--disable-nls             \    </span><br><span class="line">--disable-werror        \   </span><br><span class="line"><span class="attribute">--with-lib-path</span>=/tools/lib  \  </span><br><span class="line"> --with-sysroot</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数含义:</strong></p><ul><li><p>参数<code>CC=$LFS_TGT-gcc</code>,<code>AR=$LFS_TGT-ar</code>,<code>RANLIB=$LFS_TGT-ranlib</code></p><blockquote><p>因为这是真正的原生编译Binutils，设置这些变量能确保编译系统使用交叉编译器和相关的工具，而不是 宿主系统中已有的</p></blockquote></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这告诉配置脚本在编译Binutils的时候指定库搜索目录，此处将<code>/tools/lib</code>传递到链接器</p></blockquote></li><li><p>参数<code>--with-sysroot sysroot</code></p><blockquote><p>功能使链接器可以找到包括在其命令行中的其它共享对象明确需要的共享对象<br>否则的话，在某些主机上一些软件包可能会编译不成功</p></blockquote></li><li><p>之后进行编译安装</p></li><li><p>为目标机器中的工具链阶段准备链接器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>make 参数说明</strong></p><ul><li>参数<code>-C ld clean</code><blockquote><p>用于告诉make程序移除所有ld子目录中编译过的文件</p></blockquote></li><li>参数<code>-C ld LIB_PATH=/usr/lib:/lib</code><blockquote><p>这个选项重新编译ld子目录中的所有文件<br>在命令行中指定<code>Makefile</code>的<code>LIB_PATH</code>变量可以使我们能 够重写临时工具的默认值并指向正确的最终路径<br>该变量的值指定链接器的默认库搜索路径<br>目标主机中会用到这个准备</p></blockquote></li></ul><hr><h3 id="GCC-Pass-2"><a href="#GCC-Pass-2" class="headerlink" title="GCC Pass-2"></a>GCC Pass-2</h3><ul><li>GCC 9.2.0 LFS-9.0 3.7 GB/15 SBU</li><li>GCC 4.1.2 LFS-6.3</li><li>GCC 4.0.3 LFS-6.2 443 MB/4.2 SBU</li></ul><hr><p><strong>GCC 4.1.2/4.0.3 Pass-2</strong></p><blockquote><p><code>$ tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</code><br><code>$ cd gcc-4.1.2</code></p></blockquote><ul><li>禁止fixincludes脚本运行，以保证编译环境不被污染<blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig}</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li>因为在之前的<code>GCC Pass-1</code>中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项，而非bootstrap`编译则默认忽略了该选项</li><li>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性<blockquote><p><code>$ cp -v gcc/Makefile.in{,.tmp}</code><br><code>$ sed &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in.tmp gcc \</code><br><code>&gt; Makefile.in</code></p></blockquote></li><li>使用下面的补丁来修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置，同时把<code>/usr/include</code>从GCC的头文件搜索路径里删掉:<blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li>预先打补丁而不是在安装GCC之后调整specs文件的作用是:<blockquote><p>可以保证新的动态连接器在编译GCC的时候就用上<br>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></blockquote></li><li>此补丁非常重要，必须进行使用才能成功编译</li></ul><ul><li>GCC Pass-2 编译配置:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -v <span class="built_in">..</span>/gcc-build</span><br><span class="line">$ cd <span class="built_in">..</span>/gcc-build </span><br><span class="line">$ <span class="built_in">..</span>/gcc-4.1.2/configure <span class="attribute">--prefix</span>=/tools \ </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools \ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu \</span><br><span class="line">--enable-shared \ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix \</span><br><span class="line">--enable-__cxa_atexit \ </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++ \</span><br><span class="line">--disable-libstdcxx-pch</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数解析:</strong><br><code>--prefix=/tools</code><br><code>--with-local-prefix=/tools</code></p><ul><li>参数<code>--enable-clocale=gnu</code><blockquote><p>用于确保确保C++库在任何情况下都使用正确的locale模块</p></blockquote></li><li>参数<code>--enable-threads=posix</code><blockquote><p>用于使C++异常能处理多线程代码</p></blockquote></li><li>参数<code>--enable-__cxa_atexit</code><blockquote><p>用<code>__cxa_atexit</code>代替<code>atexit</code>来登记C++对象的本地静态和全局析构函数<br>这是为了完全符合标准对析构函数的处理规定</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>用于编译C和C++语言的编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译头(PCH)，它占用了很大空间，并且在此版本中用不到它</p></blockquote></li></ul><hr><p><strong>编译安装并清理:</strong></p><blockquote><p><code>$ make</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote><hr><p><strong>GCC 9.2.0 Pass-2</strong></p><ul><li><p>因为在第一次编译GCC的时候安装了一些内部系统头文件</p></li><li><p>其中的一个<code>limits.h</code>会反过来包括对应的系统头文件<code>limits.h</code>，在本次的实例中，是<code>/tools/include/limits.h</code></p></li><li><p>但是，第一次编译gcc的时候<code>/tools/include/limits.h</code>并不存在</p></li><li><p>因此GCC安装的内部头文件只是部分的自包含文件，并不包括系 统头文件的扩展功能</p></li><li><p>这足以编译临时libc，但是这次编译GCC要求完整的内部头文件</p></li><li><p>使用和正常情况下GCC编译系统使用的相同的命令创建一个完整版本的内部头文件:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat gcc/limitx.h gcc/glimits.h gcc/limity.h &gt; \  </span><br><span class="line">`dirname <span class="constructor">$($LFS_TGT-<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`/<span class="keyword">include</span>-fixed/limits.h</span><br></pre></td></tr></table></figure></li><li><p>再一次更改 GCC 的默认动态链接器的位置，使用安装在<code>/tools</code>的那个</p></li><li><p>执行以下配置:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ for file in gcc/config/&#123;linux,i386/linux&#123;,64&#125;&#125;<span class="string">.h</span> </span><br><span class="line">do  </span><br><span class="line">cp -uv $file&#123;,<span class="string">.orig</span>&#125;  </span><br><span class="line">sed -e 's@<span class="string">/lib</span>\<span class="params">(64\)</span>\?\<span class="params">(32\)</span>\?<span class="string">/ld</span>@<span class="string">/tools</span>&amp;@g' \</span><br><span class="line">       -e 's@<span class="string">/usr</span>@<span class="string">/tools</span>@g' $file.orig &gt; $file  </span><br><span class="line"><span class="keyword">echo</span> ' </span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_1 </span></span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_2 </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/" </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file  </span></span><br><span class="line">touch $file.orig </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>环境上构建，为64位库改变默认目录名至<code>lib</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $(uname -m) <span class="keyword">in</span>  </span><br><span class="line">x86_64)    </span><br><span class="line">sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \        </span><br><span class="line">-i.orig gcc/config/i386/t-linux64  </span><br><span class="line">;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p>和第一次编译GCC一样，它要求GMP,MPFR和MPC软件包</p></li><li><p>解压tar包并把它们重名为到所需的文件夹名</p></li><li><p>执行以下命令:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xf ../mpfr<span class="number">-4.0</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v mpfr<span class="number">-4.0</span><span class="number">.2</span> mpfr </span><br><span class="line">$ tar -xf ../gmp<span class="number">-6.1</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v gmp<span class="number">-6.1</span><span class="number">.2</span> gmp </span><br><span class="line">$ tar -xf ../mpc<span class="number">-1.1</span><span class="number">.0</span>.tar.gz </span><br><span class="line">$ mv -v mpc<span class="number">-1.1</span><span class="number">.0</span> mpc</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>在开始编译 GCC 之前，注意要取消所有会覆盖默认优化选项的环境变量</p></li><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                                   \ </span><br><span class="line"><span class="attribute">CXX</span>=<span class="variable">$LFS_TGT</span>-g++                               \ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                                 \ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib                             \ </span><br><span class="line"><span class="built_in">..</span>/configure                                      \    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                                \    </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools                 \    </span><br><span class="line"><span class="attribute">--with-native-system-header-dir</span>=/tools/include    \    </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++                                \    </span><br><span class="line">--disable-libstdcxx-pch                               \    </span><br><span class="line">--disable-multilib                                     \    </span><br><span class="line">--disable-bootstrap                            \    </span><br><span class="line">--disable-libgomp</span><br></pre></td></tr></table></figure></li></ul><p><strong>新参数说明:</strong></p><ul><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保编译了C 和C++编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译的头文件(PCH)<br>这会花费很多时间，却对我们没有用处</p></blockquote></li><li>参数<code>--disable-bootstrap</code><blockquote><p>对于原生编译的 GCC，默认是做一个[引导]构建<br>这不仅会编译GCC一次，而是会编译很多次</p></blockquote></li></ul><hr><ul><li>然后执行编译安装等操作</li><li>在编译并安装过后，可以为其设置符号链接(<code>gcc-&gt;cc</code>)<blockquote><p><code>$ ln -sv gcc /tools/bin/cc</code></p></blockquote></li><li>很多程序和脚本执行cc而不是gcc来保证程序的通用性<blockquote><p>并且在所有的Unix类型的系统上都能用<br>而非仅局限于安装了GCC的Unix 类型的系统</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>LFS-v6.2</li><li>LFS-v6.3</li><li>LFS-v9.0</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-2-3&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-3&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-2</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/</id>
    <published>2020-02-29T00:28:41.000Z</published>
    <updated>2020-02-29T00:31:56.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-2"><a href="#GNU-LFS-2-2" class="headerlink" title="GNU LFS-2-2"></a>GNU LFS-2-2</h3><ul><li><p>内容简述</p><blockquote><p>Linux Kernel Headeres(CN-LFS-6.2/6.3/9.0)<br>Glibc/Libstdc++(CN-LFS-6.2/6.3/9.0)<br>第一遍的工具链调整(CN-LFS-6.2/6.3/9.0)</p></blockquote></li><li><p>说明内容:</p></li><li><p>本篇内容将新版和旧版的资料相融合(将新版补充旧版的内容)</p></li><li><p>同时将其它的学习资料补充进LFS官方的文档内</p></li><li><p>在区分版本说明时，会先去介绍6.3再解释其它版本</p></li></ul><hr><h3 id="Linux-API-Headers"><a href="#Linux-API-Headers" class="headerlink" title="Linux API Headers"></a>Linux API Headers</h3><ul><li><p>每个版本的Linux kernel headers的名字都不一样</p></li><li><p>这里整合性的指出了三个版本的安装方法，分别是:</p><blockquote><p>Linux-2.6.22.5 API Headers(LFS-6.3)<br>Linux-5.2.8 API (LFS-9.0)<br>Linux-Libc-Headers-2.6.12.0 (LFS-6.2)</p></blockquote></li><li><p>新建编译目录和清理工作这里就不做过多阐述了</p></li></ul><hr><p><strong>Version-2.6.22.5(LFS-v6.3)</strong></p><ul><li>解压并进入文件夹<blockquote><p><code>$ tar xvf /lfs-sources/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code></p></blockquote></li></ul><p>清除所有存在的多余依赖关系:</p><blockquote><p><code>$ make mrproper</code></p></blockquote><p>编译头文件</p><blockquote><p><code>$ make headers_check</code></p></blockquote><ul><li><p>从源代码中提取用户可见的内核头文件到指定位置</p><blockquote><p><code>$ make INSTALL_HDR_PATH=dest headers_install</code></p></blockquote></li><li><p>保存在一个临时本地文件夹中然后复制到所需的位置</p><blockquote><p><code>$ cp -rv dest/include/* /tools/include</code></p></blockquote></li><li><p>清理</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Version-5.2.8(LFS-v9.0)</strong></p><ul><li><p>大致构建用时: 0.1 SBU</p></li><li><p>所需磁盘空间: 960 MB</p></li><li><p>清除依赖项</p><blockquote><p><code>$ make mrproper</code></p></blockquote></li><li><p>从源代码中提取用户可见的内核头文件</p></li><li><p>把它们保存在一个临时本地文件夹中然后复制到所需的位置</p></li><li><p>因为解压过程会移除目标文件夹中任何已有的文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">make</span> INSTALL_HDR_PATH=dest headers_install</span><br><span class="line"><span class="keyword">cp</span> -<span class="keyword">rv</span> dest/include/* /tools/include</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Version-2.6.12.0(LFS-未知版本)</strong></p><ul><li><p>Linux-Libc-Headers-2.6.12.0</p></li><li><p>Linux-Libc-Headers内包含了纯净的内核头文件</p></li><li><p>预计编译时间：少于0.1</p></li><li><p>SBU所需磁盘空间：27MB</p></li><li><p>安装这些头文件所需指令:</p><blockquote><p><code>cp -Rv include/asm-i386 /tools/include/asm</code><br><code>cp -Rv include/linux /tools/include</code></p></blockquote></li><li><p>asm-i386为架构参数，需要自行进行调整</p></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><ul><li>Glibc-2.5.1</li><li>Glibc-2.30</li></ul><hr><p><strong>Glibc-2.5.1</strong></p><ul><li><p>LFS-v6.3</p></li><li><p>解压并进入编译目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/glibc-2.5.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v glibc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> glibc-build</span></span><br></pre></td></tr></table></figure></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure --prefix=/tools \</span><br><span class="line">-<span class="ruby">-disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \</span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--with-binutils=<span class="regexp">/tools/bin</span> \ </span></span><br><span class="line"><span class="ruby">--without-gd \</span></span><br><span class="line"><span class="ruby">--with-headers=<span class="regexp">/tools/include</span> \ </span></span><br><span class="line"><span class="ruby">--without-selinux</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>--prefix=/tools</code></p><blockquote><p>用于指定安装目录</p></blockquote></li><li><p>参数<code>--disable-profile</code></p></li><li><p>参数<code>--enable-add-ons</code></p><blockquote><p>用于指示Glibc使用附加的NPTL包作为线程库</p></blockquote></li><li><p>参数<code>--enable-kernel=2.6.0</code></p><blockquote><p>用于告诉Glibc编译支持2.6.x内核的库</p></blockquote></li><li><p>参数<code>--with-binutils=/tools/bin</code></p><blockquote><p>用于保证在编译Glibc时不会用错Binutils程序</p></blockquote></li><li><p>参数<code>--without-gd</code></p><blockquote><p>可以保证不生成memusagestat程序</p></blockquote></li><li><p>参数<code>--with-headers=/tools/include</code></p><blockquote><p>数指示Glibc按照前面刚刚安装到tools目录中的内核头文件编译自己<br>从而精确的知道内核的特性以根据这些特性对自己进行最佳化编译</p></blockquote></li><li><p>参数<code>--without-selinux</code></p><blockquote><p>用于明确禁用含有SELinux特性的Glibc，以防止会出现许多操作失败的结果</p></blockquote></li><li><p>其中参数<code>--enable-kernel=2.6.0</code>，只是为了说明kernel的大版本</p><blockquote><p>所以不需要根据实际的kernel版本来改<br>即使是用linux-2.6.15也一样只写2.6.0就可以了</p></blockquote></li><li><p>编译至二进制格式</p><blockquote><p><code>$make</code></p></blockquote></li><li><p>配置链接器</p><blockquote><p><code>$ mkdir -v /tools/etc</code><br><code>$ touch /tools/etc/ld.so.conf</code></p></blockquote></li><li><p>编译安装</p><blockquote><p><code>$ make install</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote></li></ul><hr><p><strong>Glibc-2.30</strong></p><ul><li><p>Glibc 软件包包含了主要的 C 函数库</p></li><li><p>这个库提供了分配内存，搜索目录，打开关闭文件，读写文件，操作字 符串，模式匹配，基础算法等基本程序</p></li><li><p>大致构建用时: 4.8 SBU</p></li><li><p>所需磁盘空间: 896 MB</p></li><li><p>编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/glibc-2.5.1/configure              \      </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                    \      </span><br><span class="line"><span class="attribute">--host</span>=<span class="variable">$LFS_TGT</span>                    \      </span><br><span class="line"><span class="attribute">--build</span>=$(../scripts/config.guess) \      </span><br><span class="line"><span class="attribute">--enable-kernel</span>=3.2                \      </span><br><span class="line"><span class="attribute">--with-headers</span>=/tools/include</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p><code>$ --host=$LFS_TGT, --build=$(../scripts/config.guess)</code></p><blockquote><p>这些选项的组合效果是Glibc的构建系统配置它自己用<code>/tools</code>里面的交叉链接器和交叉编译器交叉编译自己</p></blockquote></li><li><p><code>$ --enable-kernel=3.2</code></p><blockquote><p>这告诉Glibc编译能支持3.2以及之后的内核库<br>更早的内核版本不受支持</p></blockquote></li><li><p><code>$ --with-headers=/tools/include</code>告诉Glibc利用刚刚安装在tools文件夹中的头文件编译自身</p><blockquote><p>此能够根据内核的具体特性提供更好的优化</p></blockquote></li><li><p>在新版本的配置中，不仅需要安装C语言的标准库，还需要安装与配置对C++支持的标准库</p></li><li><p>Libstdc++是标准的C++库</p></li><li><p>需要用它来编译C++ 代码(GCC的一部分是用C++写的)</p></li><li><p>但是在构建GCC Pass-1时，我们需要推迟它的安装进程，因为依赖的glibc，还未部署在<code>/tools</code>目录中</p></li><li><p>大致构建用时: 0.5 SBU</p></li><li><p>所需磁盘空间: 879 MB</p></li><li><p>记得新建源码编译目录与编译完清理，这里不对此部分进行赘述了</p></li><li><p>因为Libstdc++是GCC源文件的一部分</p></li><li><p>所以首先应该解压GCC的压缩包，然后进入<code>gcc-9.2.0</code>文件夹</p></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../libstdc++-v3/configure             \    </span><br><span class="line">-<span class="ruby">-host=$LFS_TGT                 \    </span></span><br><span class="line"><span class="ruby">--prefix=<span class="regexp">/tools                 \    </span></span></span><br><span class="line"><span class="ruby">--disable-multilib              \    </span></span><br><span class="line"><span class="ruby">--disable-nls                   \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-threads     \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-pch         \    </span></span><br><span class="line"><span class="ruby">--with-gxx-<span class="keyword">include</span>-dir=<span class="regexp">/tools/</span>$LFS_TGT/<span class="keyword">include</span>/c++<span class="regexp">/9.2.0</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>配置说明:</strong></p><ul><li><p>参数<code>--host=...</code></p><blockquote><p>用于指示使用我们刚才编译的交叉编译器，而不是<code>/usr/bin</code>中的</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-threads</code></p><blockquote><p>由于我们还没有编译C线程库，C++的也还不能编译</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-pch</code></p><blockquote><p>此选项防止安装预编译文件，此步骤并不需要</p></blockquote></li><li><p>参数<code>--with-gxx-include-dir=/tools/$LFS_TGT/include/c++/9.2.0</code></p><blockquote><p>这是C++编译器搜索标准include文件的位置<br>在一般的编译中，这个信息自动从顶层文件夹中传入Libstdc++ configure选项<br>在我们的例子中，必须明确给出这信息</p></blockquote></li><li><p>进行编译安装</p><blockquote><p>$ make<br>$ make install</p></blockquote></li></ul><hr><p><strong>其它情况</strong></p><ul><li>在编译过程中可能会发生以下警告</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure: WARNING: </span><br><span class="line"><span class="comment">*** These auxiliary programs are missing or </span></span><br><span class="line"><span class="comment">*** incompatible versions: msgfmt </span></span><br><span class="line"><span class="comment">*** some features will be disabled. </span></span><br><span class="line"><span class="comment">*** Check the INSTALL file for required versions.</span></span><br></pre></td></tr></table></figure><ul><li>msgfmt程序的缺失或者不兼容通常是无害的</li><li>这个msgfmt程序是Gettext软件包的一部分，主机发行版应该提供了</li></ul><hr><h3 id="调整工具链"><a href="#调整工具链" class="headerlink" title="调整工具链"></a>调整工具链</h3><ul><li>根据自身情况进行工具链调整</li><li>以下实例为LFS-v6.3的配置代码</li><li>同时也包括了部分LFS-v6.2的内容</li></ul><hr><p><strong>调整思路:</strong></p><ul><li>因为现在临时的C库已经装好，接下来本章中要编译的所有工具应该连接到这些库上</li><li>为了达到这个目标，需要调整连接器和编译器的specs文件</li><li>在第一遍编译Binutils快结束时已经调整过的连接器，现在需要被重新命名以便可以被正确的找到和使用</li><li>首先备份原来的连接器，然后用调整过的连接器来替代</li><li>最后还要创建一个指向<code>/tools/$(gcc-dumpmachine)/bin</code>中连接器副本的连接</li><li>如果当前本地主机的系统平台上，动态连接器的名字不是<code>ld-linux.so.2</code></li><li>必须人为的把spaces配置里的<code>ldlinux.so.2</code>换成你的系统平台上动态连接器的名字</li></ul><hr><ul><li>以下为工具链配置代码(LFS-6.3)<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;ld-<span class="keyword">new</span>,ld&#125; </span><br><span class="line">$ ln -sv /tools/bin/ld /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/ld </span><br><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>语句内容刨析:</strong></p><ul><li>符号链接部分</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/$(gcc -dumpmachine)/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>-new,<span class="keyword">ld</span>&#125; </span><br><span class="line">$ ln -sv /tools/bin/<span class="keyword">ld</span> /tools/$(gcc -dumpmachine)/bin/<span class="keyword">ld</span></span><br></pre></td></tr></table></figure><ul><li><p>就是几个符号链接</p></li><li><p>当设置完成之后，所有程序都将连接到<code>/tools/lib</code>中的库文件</p></li><li><p>space部分</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure><p>此代码还可以拆成以下两部分</p><ul><li><p>部分一</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFILE</span><br></pre></td></tr></table></figure></li><li><p>用于修正GCC的specs文件，使它指向新的动态连接器</p></li><li><p>只需要像以上那样使用一个简单的sed命令就能做到</p></li><li><p>同时也可以手动编辑specs文件</p><blockquote><p>本质上就是把所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code>就行</p></blockquote></li><li><p>部分二</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>用于删除GCC专属头文件目录中的头文件</p><blockquote><p>以避免宿主系统中的头文件污染编译环境</p></blockquote></li></ul><hr><ul><li>相关说明<blockquote><p>工具链的调整方法有好几种，而且不同版本GCC的specs可能会有不同<br>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成了<code>/tools/lib/ld-linux.so.2</code><br>所以即使有些文章在调整工具链上的命令和LFS手册上的不一样也不用太奇怪<br>当然也可以 直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件<br>spaces必须加以检查以确保被修改的配置的的确确生效了</p></blockquote></li></ul><hr><h3 id="内容参考"><a href="#内容参考" class="headerlink" title="内容参考"></a>内容参考</h3><ul><li>CN-LFS-v9.0</li><li>CN-LFS-v6.3</li><li>CN-LFS-v6.2</li><li>在LFS-1的URL资源整合目录里都有说明</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 08 2020 04:36:47 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-2-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
