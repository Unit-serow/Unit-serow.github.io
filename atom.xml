<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-02-29T00:31:56.255Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GNU-LFS-2-2</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/</id>
    <published>2020-02-29T00:28:41.000Z</published>
    <updated>2020-02-29T00:31:56.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 08:32:01 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-2"><a href="#GNU-LFS-2-2" class="headerlink" title="GNU LFS-2-2"></a>GNU LFS-2-2</h3><ul><li><p>内容简述</p><blockquote><p>Linux Kernel Headeres(CN-LFS-6.2/6.3/9.0)<br>Glibc/Libstdc++(CN-LFS-6.2/6.3/9.0)<br>第一遍的工具链调整(CN-LFS-6.2/6.3/9.0)</p></blockquote></li><li><p>说明内容:</p></li><li><p>本篇内容将新版和旧版的资料相融合(将新版补充旧版的内容)</p></li><li><p>同时将其它的学习资料补充进LFS官方的文档内</p></li><li><p>在区分版本说明时，会先去介绍6.3再解释其它版本</p></li></ul><hr><h3 id="Linux-API-Headers"><a href="#Linux-API-Headers" class="headerlink" title="Linux API Headers"></a>Linux API Headers</h3><ul><li><p>每个版本的Linux kernel headers的名字都不一样</p></li><li><p>这里整合性的指出了三个版本的安装方法，分别是:</p><blockquote><p>Linux-2.6.22.5 API Headers(LFS-6.3)<br>Linux-5.2.8 API (LFS-9.0)<br>Linux-Libc-Headers-2.6.12.0 (LFS-6.2)</p></blockquote></li><li><p>新建编译目录和清理工作这里就不做过多阐述了</p></li></ul><hr><p><strong>Version-2.6.22.5(LFS-v6.3)</strong></p><ul><li>解压并进入文件夹<blockquote><p><code>$ tar xvf /lfs-sources/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code></p></blockquote></li></ul><p>清除所有存在的多余依赖关系:</p><blockquote><p><code>$ make mrproper</code></p></blockquote><p>编译头文件</p><blockquote><p><code>$ make headers_check</code></p></blockquote><ul><li><p>从源代码中提取用户可见的内核头文件到指定位置</p><blockquote><p><code>$ make INSTALL_HDR_PATH=dest headers_install</code></p></blockquote></li><li><p>保存在一个临时本地文件夹中然后复制到所需的位置</p><blockquote><p><code>$ cp -rv dest/include/* /tools/include</code></p></blockquote></li><li><p>清理</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Version-5.2.8(LFS-v9.0)</strong></p><ul><li><p>大致构建用时: 0.1 SBU</p></li><li><p>所需磁盘空间: 960 MB</p></li><li><p>清除依赖项</p><blockquote><p><code>$ make mrproper</code></p></blockquote></li><li><p>从源代码中提取用户可见的内核头文件</p></li><li><p>把它们保存在一个临时本地文件夹中然后复制到所需的位置</p></li><li><p>因为解压过程会移除目标文件夹中任何已有的文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">make</span> INSTALL_HDR_PATH=dest headers_install</span><br><span class="line"><span class="keyword">cp</span> -<span class="keyword">rv</span> dest/include/* /tools/include</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Version-2.6.12.0(LFS-未知版本)</strong></p><ul><li><p>Linux-Libc-Headers-2.6.12.0</p></li><li><p>Linux-Libc-Headers内包含了纯净的内核头文件</p></li><li><p>预计编译时间：少于0.1</p></li><li><p>SBU所需磁盘空间：27MB</p></li><li><p>安装这些头文件所需指令:</p><blockquote><p><code>cp -Rv include/asm-i386 /tools/include/asm</code><br><code>cp -Rv include/linux /tools/include</code></p></blockquote></li><li><p>asm-i386为架构参数，需要自行进行调整</p></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><ul><li>Glibc-2.5.1</li><li>Glibc-2.30</li></ul><hr><p><strong>Glibc-2.5.1</strong></p><ul><li><p>LFS-v6.3</p></li><li><p>解压并进入编译目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/glibc-2.5.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v glibc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> glibc-build</span></span><br></pre></td></tr></table></figure></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure --prefix=/tools \</span><br><span class="line">-<span class="ruby">-disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \</span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--with-binutils=<span class="regexp">/tools/bin</span> \ </span></span><br><span class="line"><span class="ruby">--without-gd \</span></span><br><span class="line"><span class="ruby">--with-headers=<span class="regexp">/tools/include</span> \ </span></span><br><span class="line"><span class="ruby">--without-selinux</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>--prefix=/tools</code></p><blockquote><p>用于指定安装目录</p></blockquote></li><li><p>参数<code>--disable-profile</code></p></li><li><p>参数<code>--enable-add-ons</code></p><blockquote><p>用于指示Glibc使用附加的NPTL包作为线程库</p></blockquote></li><li><p>参数<code>--enable-kernel=2.6.0</code></p><blockquote><p>用于告诉Glibc编译支持2.6.x内核的库</p></blockquote></li><li><p>参数<code>--with-binutils=/tools/bin</code></p><blockquote><p>用于保证在编译Glibc时不会用错Binutils程序</p></blockquote></li><li><p>参数<code>--without-gd</code></p><blockquote><p>可以保证不生成memusagestat程序</p></blockquote></li><li><p>参数<code>--with-headers=/tools/include</code></p><blockquote><p>数指示Glibc按照前面刚刚安装到tools目录中的内核头文件编译自己<br>从而精确的知道内核的特性以根据这些特性对自己进行最佳化编译</p></blockquote></li><li><p>参数<code>--without-selinux</code></p><blockquote><p>用于明确禁用含有SELinux特性的Glibc，以防止会出现许多操作失败的结果</p></blockquote></li><li><p>其中参数<code>--enable-kernel=2.6.0</code>，只是为了说明kernel的大版本</p><blockquote><p>所以不需要根据实际的kernel版本来改<br>即使是用linux-2.6.15也一样只写2.6.0就可以了</p></blockquote></li><li><p>编译至二进制格式</p><blockquote><p><code>$make</code></p></blockquote></li><li><p>配置链接器</p><blockquote><p><code>$ mkdir -v /tools/etc</code><br><code>$ touch /tools/etc/ld.so.conf</code></p></blockquote></li><li><p>编译安装</p><blockquote><p><code>$ make install</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote></li></ul><hr><p><strong>Glibc-2.30</strong></p><ul><li><p>Glibc 软件包包含了主要的 C 函数库</p></li><li><p>这个库提供了分配内存，搜索目录，打开关闭文件，读写文件，操作字 符串，模式匹配，基础算法等基本程序</p></li><li><p>大致构建用时: 4.8 SBU</p></li><li><p>所需磁盘空间: 896 MB</p></li><li><p>编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/glibc-2.5.1/configure              \      </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                    \      </span><br><span class="line"><span class="attribute">--host</span>=<span class="variable">$LFS_TGT</span>                    \      </span><br><span class="line"><span class="attribute">--build</span>=$(../scripts/config.guess) \      </span><br><span class="line"><span class="attribute">--enable-kernel</span>=3.2                \      </span><br><span class="line"><span class="attribute">--with-headers</span>=/tools/include</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p><code>$ --host=$LFS_TGT, --build=$(../scripts/config.guess)</code></p><blockquote><p>这些选项的组合效果是Glibc的构建系统配置它自己用<code>/tools</code>里面的交叉链接器和交叉编译器交叉编译自己</p></blockquote></li><li><p><code>$ --enable-kernel=3.2</code></p><blockquote><p>这告诉Glibc编译能支持3.2以及之后的内核库<br>更早的内核版本不受支持</p></blockquote></li><li><p><code>$ --with-headers=/tools/include</code>告诉Glibc利用刚刚安装在tools文件夹中的头文件编译自身</p><blockquote><p>此能够根据内核的具体特性提供更好的优化</p></blockquote></li><li><p>在新版本的配置中，不仅需要安装C语言的标准库，还需要安装与配置对C++支持的标准库</p></li><li><p>Libstdc++是标准的C++库</p></li><li><p>需要用它来编译C++ 代码(GCC的一部分是用C++写的)</p></li><li><p>但是在构建GCC Pass-1时，我们需要推迟它的安装进程，因为依赖的glibc，还未部署在<code>/tools</code>目录中</p></li><li><p>大致构建用时: 0.5 SBU</p></li><li><p>所需磁盘空间: 879 MB</p></li><li><p>记得新建源码编译目录与编译完清理，这里不对此部分进行赘述了</p></li><li><p>因为Libstdc++是GCC源文件的一部分</p></li><li><p>所以首先应该解压GCC的压缩包，然后进入<code>gcc-9.2.0</code>文件夹</p></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../libstdc++-v3/configure             \    </span><br><span class="line">-<span class="ruby">-host=$LFS_TGT                 \    </span></span><br><span class="line"><span class="ruby">--prefix=<span class="regexp">/tools                 \    </span></span></span><br><span class="line"><span class="ruby">--disable-multilib              \    </span></span><br><span class="line"><span class="ruby">--disable-nls                   \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-threads     \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-pch         \    </span></span><br><span class="line"><span class="ruby">--with-gxx-<span class="keyword">include</span>-dir=<span class="regexp">/tools/</span>$LFS_TGT/<span class="keyword">include</span>/c++<span class="regexp">/9.2.0</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>配置说明:</strong></p><ul><li><p>参数<code>--host=...</code></p><blockquote><p>用于指示使用我们刚才编译的交叉编译器，而不是<code>/usr/bin</code>中的</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-threads</code></p><blockquote><p>由于我们还没有编译C线程库，C++的也还不能编译</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-pch</code></p><blockquote><p>此选项防止安装预编译文件，此步骤并不需要</p></blockquote></li><li><p>参数<code>--with-gxx-include-dir=/tools/$LFS_TGT/include/c++/9.2.0</code></p><blockquote><p>这是C++编译器搜索标准include文件的位置<br>在一般的编译中，这个信息自动从顶层文件夹中传入Libstdc++ configure选项<br>在我们的例子中，必须明确给出这信息</p></blockquote></li><li><p>进行编译安装</p><blockquote><p>$ make<br>$ make install</p></blockquote></li></ul><hr><p><strong>其它情况</strong></p><ul><li>在编译过程中可能会发生以下警告</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure: WARNING: </span><br><span class="line"><span class="comment">*** These auxiliary programs are missing or </span></span><br><span class="line"><span class="comment">*** incompatible versions: msgfmt </span></span><br><span class="line"><span class="comment">*** some features will be disabled. </span></span><br><span class="line"><span class="comment">*** Check the INSTALL file for required versions.</span></span><br></pre></td></tr></table></figure><ul><li>msgfmt程序的缺失或者不兼容通常是无害的</li><li>这个msgfmt程序是Gettext软件包的一部分，主机发行版应该提供了</li></ul><hr><h3 id="调整工具链"><a href="#调整工具链" class="headerlink" title="调整工具链"></a>调整工具链</h3><ul><li>根据自身情况进行工具链调整</li><li>以下实例为LFS-v6.3的配置代码</li><li>同时也包括了部分LFS-v6.2的内容</li></ul><hr><p><strong>调整思路:</strong></p><ul><li>因为现在临时的C库已经装好，接下来本章中要编译的所有工具应该连接到这些库上</li><li>为了达到这个目标，需要调整连接器和编译器的specs文件</li><li>在第一遍编译Binutils快结束时已经调整过的连接器，现在需要被重新命名以便可以被正确的找到和使用</li><li>首先备份原来的连接器，然后用调整过的连接器来替代</li><li>最后还要创建一个指向<code>/tools/$(gcc-dumpmachine)/bin</code>中连接器副本的连接</li><li>如果当前本地主机的系统平台上，动态连接器的名字不是<code>ld-linux.so.2</code></li><li>必须人为的把spaces配置里的<code>ldlinux.so.2</code>换成你的系统平台上动态连接器的名字</li></ul><hr><ul><li>以下为工具链配置代码(LFS-6.3)<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;ld-<span class="keyword">new</span>,ld&#125; </span><br><span class="line">$ ln -sv /tools/bin/ld /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/ld </span><br><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>语句内容刨析:</strong></p><ul><li>符号链接部分</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/$(gcc -dumpmachine)/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>-new,<span class="keyword">ld</span>&#125; </span><br><span class="line">$ ln -sv /tools/bin/<span class="keyword">ld</span> /tools/$(gcc -dumpmachine)/bin/<span class="keyword">ld</span></span><br></pre></td></tr></table></figure><ul><li><p>就是几个符号链接</p></li><li><p>当设置完成之后，所有程序都将连接到<code>/tools/lib</code>中的库文件</p></li><li><p>space部分</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure><p>此代码还可以拆成以下两部分</p><ul><li><p>部分一</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFILE</span><br></pre></td></tr></table></figure></li><li><p>用于修正GCC的specs文件，使它指向新的动态连接器</p></li><li><p>只需要像以上那样使用一个简单的sed命令就能做到</p></li><li><p>同时也可以手动编辑specs文件</p><blockquote><p>本质上就是把所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code>就行</p></blockquote></li><li><p>部分二</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>用于删除GCC专属头文件目录中的头文件</p><blockquote><p>以避免宿主系统中的头文件污染编译环境</p></blockquote></li></ul><hr><ul><li>相关说明<blockquote><p>工具链的调整方法有好几种，而且不同版本GCC的specs可能会有不同<br>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成了<code>/tools/lib/ld-linux.so.2</code><br>所以即使有些文章在调整工具链上的命令和LFS手册上的不一样也不用太奇怪<br>当然也可以 直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件<br>spaces必须加以检查以确保被修改的配置的的确确生效了</p></blockquote></li></ul><hr><h3 id="内容参考"><a href="#内容参考" class="headerlink" title="内容参考"></a>内容参考</h3><ul><li>CN-LFS-v9.0</li><li>CN-LFS-v6.3</li><li>CN-LFS-v6.2</li><li>在LFS-1的URL资源整合目录里都有说明</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 08:32:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-2-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-1</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-1/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-1/</id>
    <published>2020-02-28T17:06:14.000Z</published>
    <updated>2020-02-28T17:13:18.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-1"><a href="#GNU-LFS-2-1" class="headerlink" title="GNU LFS-2-1"></a>GNU LFS-2-1</h2><hr><h3 id="构造临时系统-1-0"><a href="#构造临时系统-1-0" class="headerlink" title="构造临时系统-1.0"></a>构造临时系统-1.0</h3><ul><li>1.0-为第一遍编译并安装临时工具链内Binutils与GCC</li></ul><p><strong>概述:</strong></p><ul><li><p>对于临时系统的简述</p></li><li><p>目的是何构造一个最小的Linux系统</p></li><li><p>该系统将包含刚好足够构建目标主机中最终LFS系统所需的工具，以及一个比最小环境具有更好用户便利性的工作环境</p></li><li><p>使用的软件包皆为v6.3版本的LFS-liveCD中拥有的软件包</p></li><li><p>本文只介绍基本的[GNU 工具链]的搭建参考于v6.3与v9.0(对6.3进行补充，对9.0进行说明)</p><blockquote><p>v6.3和v9.0都有进行举例说明</p></blockquote></li><li><p>构建这个最小系统有两个步骤:</p><blockquote><p>第一步: 构建一个与宿主系统无关的新工具链(编译器、汇编器、链接器、 库和一些有用的工具)<br>第二步: 使用该工具链，去构建其它的基础工具</p></blockquote></li><li><p>临时系统中编译得到的文件将被安装在目录<code>$LFS/tools</code>中</p><blockquote><p>以确保在下一章中安装的文件和宿主系统生成的目录相互分离<br>由于此处编译的软件包都是临时性的，因此可以人为的去避免出现污染后面即将构成的LFS系统的情况发生</p></blockquote></li></ul><p><strong>需要特别注意的几点:</strong></p><ul><li>在构建的过程需要注意的问题</li></ul><ol><li>把所有源文件和补丁放到 chroot 环境可访问的目录，例如<code>/mnt/lfs/sources/</code><blockquote><p>但是千万不 能把源文件放在<code>/mnt/lfs/tools/</code>中</p></blockquote></li><li>进入到源文件目录</li><li>对于每个软件包:<blockquote><p>a. 用tar程序解压要编译的软件包<br>同时在临时系统目录中，确保解压软件包时本地主机使用的是lfs用户<br>b. 进入到解压后创建的目录中<br>c. 根据指南说明编译软件包<br>d. 回退到源文件目录<br>e. 除非特别说明，删除解压出来的目录</p></blockquote></li></ol><hr><ul><li><p>进入LFS包编译目录</p><blockquote><p><code>cd $LFS/sources</code></p></blockquote></li><li><p>第一遍编译[GNU 工具链]说明:</p><blockquote><p>在编译完成之后，通常需要运行测试套件<br>但此时测试套件框架(Tcl，Expect和DejaGNU)还没有就绪<br>同时因为此时是所有工作的初期阶段<br>所以此进行测试的收效甚微，因为第一遍编译的程序很快会被第二遍的代</p></blockquote></li></ul><hr><h3 id="1-0-0"><a href="#1-0-0" class="headerlink" title="1.0.0"></a>1.0.0</h3><p><strong>Binutils-2.17/2.32-Pass 1</strong><br><strong>安装交叉编译的Binutils</strong></p><ul><li><p>目标软件包简述:</p><blockquote><p>Binutils 软件包包含一个链接器，一个汇编器，以及其它处理目标文件的工具<br>大致构建用时: 1 SBU<br>所需磁盘空间: 580 MB</p></blockquote></li><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3配置编译</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> <span class="string">../binutils-2.17/configure</span> <span class="params">--prefix=/tools</span>  \</span><br><span class="line">            <span class="params">--disable-nls</span> \</span><br><span class="line">            <span class="params">--disable-werror</span></span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span>  <span class="built_in">..</span>/binutils-2.32/configure <span class="attribute">--prefix</span>=/tools            \</span><br><span class="line">             <span class="attribute">--with-sysroot</span>=<span class="variable">$LFS</span>        \</span><br><span class="line">             <span class="attribute">--with-lib-path</span>=/tools/lib \</span><br><span class="line">             <span class="attribute">--target</span>=<span class="variable">$LFS_TGT</span>          \</span><br><span class="line">             --disable-nls              \</span><br><span class="line">             --disable-werror</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>CC=&quot;gcc -B/usr/bin/&quot;</code>该选项强制gcc使用宿主系统中/usr/bin目录下的连接器</p><blockquote><p>这样做的必要是因为新生成的ld可能与某些宿主系统的gcc不兼容</p></blockquote></li><li><p>参数<code>--prefix=/tools</code>用于告诉配置脚本将<code>Binutils程序</code>安装到<code>/tools</code>文件夹</p></li><li><p>参数<code>--with-sysroot=$LFS</code>用于交叉编译，告诉编译系统在<code>$LFS</code>中查找所需的目标系统库</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code>指定需要配置使用的链接器的库路径</p></li><li><p>参数<code>--target=$LFS_TGT</code>，因为<code>LFS_TGT</code>变量中的机器描述和<code>config.guess</code>脚本返回的值略有不同，这个选项会告诉<code>configure</code>脚本调整<code>Binutils</code>的构建系统来构建一个交叉链接器</p></li><li><p>参数<code>--disable-nls</code>会禁止国际化(i18n)，因为国际化对临时工具来说没有必要</p></li><li><p>参数<code>--disable-werror</code>会防止来自宿主编译器的警告事件导致停止编译</p></li><li><p>继续编译并进行编译安装</p><blockquote><p>$make<br>$make install</p></blockquote></li><li><p>为调整工具链步骤准备连接器</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -C <span class="keyword">ld</span> clean </span><br><span class="line">$ make -C <span class="keyword">ld</span> LIB_PATH=/tools/lib</span><br><span class="line">$ <span class="keyword">cp</span> -v <span class="keyword">ld</span>/<span class="keyword">ld</span>-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>-C ld clean</code></p><blockquote><p>用于告诉make程序删除所有ld子目录中编译生成的文件</p></blockquote></li><li><p>参数<code>-C ld LIB_PATH=/tools/lib</code></p><blockquote><p>用于这个选项重新编译ld子目录中的所有文件</p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-2.17</span></span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>上构建，创建符号链接，以确保工具链的完整性:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">case</span> $(uname -m) in  </span><br><span class="line">x86_64) mkdir -v /tools/<span class="class"><span class="keyword">lib</span> &amp;&amp; <span class="title">ln</span> -<span class="title">sv</span> <span class="title">lib</span> /<span class="title">tools</span>/<span class="title">lib64</span> ;</span>; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.16.2</code>的<code>Binutils内容</code></p></li></ul><hr><h3 id="2-0-0"><a href="#2-0-0" class="headerlink" title="2.0.0"></a>2.0.0</h3><p><strong>GCC-4.12/9.2.0 Pass-1</strong><br><strong>安装交叉编译的GCC</strong></p><ul><li>目标软件包简述:<blockquote><p>GCC软件包包括GNU编译器集，其中有C和C++的编译器<br>大致构建用时: 12 SBU<br>所需磁盘空间: 3.1 GB</p></blockquote></li></ul><p><strong>以下内容为LFS-v6.3的GCC编译过程</strong></p><ul><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v gcc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gcc-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span> <span class="built_in">..</span>/gcc-4.1.2/configure <span class="attribute">--prefix</span>=/tools \ </span><br><span class="line">       <span class="attribute">--with-local-prefix</span>=/tools \</span><br><span class="line">       --disable-nls \</span><br><span class="line">       --enable-shared \</span><br><span class="line">       <span class="attribute">--enable-languages</span>=c</span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> ../gcc-<span class="number">9.2</span>.<span class="number">0</span>/configure       <span class="string">\</span></span><br><span class="line"> --target=$LFS_TGT                              <span class="string">\</span></span><br><span class="line"> --prefix=/tools                                <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-glibc-version=<span class="number">2.11</span>                      <span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-sysroot=$LFS                            <span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-newlib                                  <span class="string">\</span> </span><br><span class="line"> --without-headers                              <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-local-prefix=/tools                     <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-<span class="keyword">native</span>-system-header-dir=/tools/include <span class="string">\</span> </span><br><span class="line"> --disable-nls                                  <span class="string">\</span></span><br><span class="line"> --disable-shared                               <span class="string">\</span></span><br><span class="line"> --disable-multilib                             <span class="string">\</span> </span><br><span class="line"> --disable-decimal-float                        <span class="string">\</span> </span><br><span class="line"> --disable-threads                              <span class="string">\</span> </span><br><span class="line"> --disable-libatomic                            <span class="string">\</span> </span><br><span class="line"> --disable-libgomp                              <span class="string">\</span> </span><br><span class="line"> --disable-libquadmath                          <span class="string">\</span> </span><br><span class="line"> --disable-libssp                               <span class="string">\</span> </span><br><span class="line"> --disable-libvtv                               <span class="string">\</span></span><br><span class="line"> --disable-libstdcxx                            <span class="string">\</span> </span><br><span class="line"> --enable-languages=c,c++</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>配置含义(参数说明):</strong></p><ul><li>参数<code>--with-newlib</code><blockquote><p>由于还没有可用的C库，这确保编译libgcc时定义了常数<code>inhibit_libc</code><br>这可以防止编译任何需要libc支持的代码</p></blockquote></li><li>参数<code>--without-headers</code><blockquote><p>在创建完整的交叉编译器时，GCC要求标准头文件和目标系统兼容<br>对于我们的目的来说，不需要这些头文件<br>这个选项可以防止GCC查找它们</p></blockquote></li><li>参数<code>--with-local-prefix=/tools GCC</code><blockquote><p>此参数会查找本地已安装的include文件的系统位置<br>默认是<code>/usr/local</code><br>把它设置为<code>/tools</code>能把主机位置中的<code>/usr/local</code>从GCC的搜索路径中排除</p></blockquote></li><li>参数<code>--with-native-system-header-dir=/tools/include</code><blockquote><p>GCC默认会在/usr/include中查找系统头文件<br>和<code>sysroot</code>选项一起使用，会转换为<code>$LFS/usr/include</code><br>在后面两个章节中头文件会被安装到<code>$LFS/tools/include</code><br>这个选项确保 gcc 能正确找 到它们<br>第二次编译 GCC 时，同样的选项可以保证不会去寻找主机系统的头文件</p></blockquote></li><li>参数<code>--disable-shared</code><blockquote><p>这个选项强制GCC静态链接到它的内部库<br>我们这样做是为了避免主机系统可能出现的问题</p></blockquote></li><li>参数:<blockquote><p><code>--disable-decimal-float</code>,<code>--disable-threads</code>,<code>--disable-libatomic</code>,<code>--disablelibgomp</code>,<br><code>--disable-libquadmath</code>,<code>--disable-libssp</code>,<code>--disable-libvtv</code>,<code>--disablelibstdcxx</code><br>这些选项取消了对十进制浮点数扩展，线程化，<code>libatomic</code>，<code>libgomp</code>，<code>libquadmath</code>，<code>libssp</code>，<code>libvtv</code>，<code>libcilkrts</code>和<code>C++</code>标准库的支持<br>这些功能在编译 交叉编译器的时候会导致编译失败，对于交叉编译临时 libc 来说也没有必要</p></blockquote></li><li>参数<code>--disable-multilib</code><blockquote><p>在<code>x86_64</code>机器上，LFS 还不支持<code>multilib</code>配置<br>这个选项对 x86 来说无害</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保只编译 C 和 C++ 编译器<br>这些是现在唯一需要的语言</p></blockquote></li><li>此时只编译了GCC里的C编译器</li></ul><hr><ul><li><p>编译并安装</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; $ make bootstrap</span></span><br><span class="line"><span class="quote">&gt; $ make install</span></span><br></pre></td></tr></table></figure></li><li><p>创建符号连接(工具链)</p><blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-build </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-4.1.2</span></span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.21.2</code>的GCC软件包内容里</p></li></ul><hr><ul><li>对于工具链内的工具或其它软件的编译安装大致可分为以下几步:</li></ul><ol><li>创建目录</li><li>配置编译器与其脚本文件</li><li>编译并安装</li><li>配置工具链</li></ol><ul><li>配置其它独有(针对于不同工具的特殊配置)性质</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>金钟国的v6.3-LFS</p></li><li><p>孙海勇的v6.3-LFS</p></li><li><p>LFS-v9.0</p></li><li><p><code>5.4. Binutils-2.18 - 第一遍</code><a href="https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html</code></p></blockquote></li><li><p><code>gcc -B/usr/bin -B</code>的含义<a href="https://www.169it.com/tech-qa-linux/article-10702497996978005026.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.169it.com/tech-qa-linux/article-10702497996978005026.html</code></p></blockquote></li><li><p>百度知道<a href="https://zhidao.baidu.com/question/501313846.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zhidao.baidu.com/question/501313846.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-2-1&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-1&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-1</title>
    <link href="https://unit-serow.github.io/2020/02/28/GNU-LFS-1/"/>
    <id>https://unit-serow.github.io/2020/02/28/GNU-LFS-1/</id>
    <published>2020-02-28T15:31:21.000Z</published>
    <updated>2020-02-28T15:35:03.276Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h3 id="LFS-1"><a href="#LFS-1" class="headerlink" title="LFS-1"></a>LFS-1</h3><ul><li>参考资料为CN-[LFS-BOOK(v9.0)]-PDF版</li></ul><hr><p><strong>本地主机环境一览:</strong></p><ul><li>原主机环境准备</li><li>主机内存(RAM)为4GB</li><li>主机磁盘为30GB</li><li>CPU为4核-2.2GHZ</li><li>本地主机硬盘接口类型为SCSI</li><li>磁盘分区表类型为MBR(GPT/GUID不做阐述)</li><li>磁盘启动引导类型为BIOS(UEFI不做阐述)</li><li>CD使用LFS-liveCD-v6.3(2007)</li></ul><hr><h3 id="1-0-0-1-2-7"><a href="#1-0-0-1-2-7" class="headerlink" title="1.0.0-1.2.7"></a>1.0.0-1.2.7</h3><p><strong>1.0.0</strong></p><ul><li>使用cfdisk工具对原主机进行分区(也可以使用fdisk工具进行分区操作)<blockquote><p><code>$cfdisk /dev/sda</code></p></blockquote></li></ul><p><strong>1.1.0 格式化磁盘分区</strong></p><ul><li><p>Swap分区(swap)</p><blockquote><p><code>$mkswap /dev/&lt;yyy&gt;</code><br><code>$mkswap /dev/sda1</code></p></blockquote></li><li><p>LFS分区(ext)</p><blockquote><p><code>$mkfs -v -t ext4/ext3 /dev/&lt;xxx&gt;</code><br><code>$mkfs.ext4/ext3 /dev/sda2</code><br><code>$mkfs -v -t ext3 /dev/sda2</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>前者为标准格式，后者为实例</li><li>在原主机磁盘上创建新分区</li><li>由于是LFS官方提供的liveCD，所以此时的原主机没有任何分区</li><li>这里创建两个本地的主分区: /dev/sda1用于交换分区(swap)，/dev/sda2用作目标主机制作环境，分区文件格式为ext3(或ext3/ext4等等)</li><li>存储容量分别是7000B与530000B(拟定，因本地主机的处理器指令集位数问题，实际情况会发生细微变动)</li></ul><hr><p><strong>1.2.0 设置LFS所处目录的系统变量</strong></p><ul><li>因为整个实现过程需要多次用到LFS系统的目录，所以先将LFS系统目录设置为LFS变量(变量名自拟，这里为LFS，即$LFS)</li><li>因为这里将要把LFS分区挂载到/mnt目录中，所以可以将LFS系统目录建立到/mnt目录内，以下指令直接创建环境变量:<blockquote><p><code>$export LFS=/mnt/lfs</code></p></blockquote></li></ul><p><strong>1.2.1 将新分区(LFS系统分区)进行挂载</strong></p><ul><li>挂载的目是访问所被挂载的分区，上一步中将分区所在目录设为了$LFS变量所指向的地址</li><li>创建挂载点<blockquote><p><code>mkdir -pv $LFS</code></p></blockquote></li><li>挂载LFS分区及其文件系统(文件可以自动识别，即便不加也是可以的)<blockquote><p><code>mount -v -t ext3/ext4 /dev/&lt;xxx&gt; $LFS</code><br><code>mount -v -t ext3 /dev/sda2 $LFS</code><br><code>mount /dev/sda2 $LFS</code></p></blockquote></li><li>(非必要)挂载并使用swap分区<blockquote><p><code>/sbin/swapon -v /dev/&lt;zzz&gt;</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>这里与以后的说明都将/dev/sda2分区称为LFS分区，即目标系统根目录</li><li>交换分区(swap)的作用是可以有效的解决编译过程中所需内存的不足，所以可以分出一个小型磁盘分区来当作swap空间</li><li>所以swap的容量可以按需分配，而sda2当然是越大越好</li><li>宿主机(原主机)和LFS分区的swap是公用的，如果原宿主机拥有swap，就没有必要再新建一个了</li><li>有关于磁盘分区的标志与其它分区表类型和启动引导类型的内容这里就不做过多赘述了</li></ul><hr><p><strong>1.2.2 创建必要目录以及目录权限分配</strong></p><ul><li><p>今后在第二阶段(临时系统)制作的时候会将所有的软件编译到<code>$LFS/tools</code>中，以便与第三阶段时所编译的软件完全分离</p></li><li><p>在目标系统成型后，便可将其遗弃</p></li><li><p>执行以下操作需要root权限</p></li><li><p>创建工具链目录<code>$LFS/tools</code></p><blockquote><p><code>mkdir -v $LFS/tools</code></p></blockquote></li><li><p>在原主机内创建符号链接，用以指向LFS分区中新建的目录(/tools)</p></li><li><p>此时所创建的符号链接将永远指向<code>/tools</code>文件夹</p><blockquote><p>即编译器，汇编器，链接器无论是在临时系统或是目标系统中都可以进行使用</p></blockquote></li><li><p>配置符号链接</p><blockquote><p><code>ln -sv $LFS/tools /</code></p></blockquote></li></ul><p><strong>1.2.3 创建源代码编译用目录</strong></p><blockquote><p><code>mkdir -v $LFS/sources</code></p></blockquote><ul><li>权限分配<blockquote><p><code>chmod -v a+wt $LFS/sources</code></p></blockquote></li></ul><hr><p><strong>1.2.4 添加LFS用户(自定义非特权用户命名)</strong></p><ul><li>因为以root用户登陆时，一个操作失误便可以摧毁整个操作系统，所以在此需要新建一个非特权用户来对软件包进行编译</li><li>同时也是为了建立一个干净的工作环境，这里创建一个名为lfs的新用于作为新组(同样命名为lfs)的成员</li><li>添加新用户:<blockquote><p><code>groupadd lfs</code></p></blockquote></li><li>将新用户lfs的shell设为默认bash，并将用户lfs添加到lfs组中，同时为lfs用户创建主目录</li><li>并对用户输入位置设置为空设备(null)，以防止可能从框架目录复制文件的情况<blockquote><p><code>useradd -s /bin/bash -g lfs -m -k /dev/null lfs</code></p></blockquote></li><li>设置lfs用户密码，可以为空<blockquote><p><code>passwd lfs</code></p></blockquote></li><li>将目录所有者改变为lfs<blockquote><p><code>chown -v lfs $LFS/tools</code></p></blockquote></li><li>同时为用户lfs赋予访问$LFS/tools目录的所有权限<blockquote><p><code>chown -v lfs $LFS/sources</code></p></blockquote></li><li>以lfs身份登陆主机</li><li>切换用户并启动shell环境<blockquote><p><code>su - lfs</code></p></blockquote></li></ul><hr><p><strong>1.2.5 设置环境</strong></p><ul><li>通过为bash shell创建两个开机启动文件，来设置合适的工作环境</li><li>以lfs用户的身份来创建一个新的<code>.bash_profile</code>文件<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ~/.bash_profile &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line">exec env -i <span class="attribute">HOME</span>=<span class="variable">$HOME</span> <span class="attribute">TERM</span>=<span class="variable">$TERM</span> <span class="attribute">PS1</span>=<span class="string">'\u:\w\$ '</span> /bin/bash </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li>当以lfs用户身份登录时，初始shell通常是一个login的shell</li></ul><ol><li>它先读取宿主机的<code>/etc/profile</code>文件(很可能包括一些设定和环境变量)</li><li>然后是<code>.bash_profile</code>文件</li><li><code>.bash_profile</code>中的命令<code>exec env -i.../bin/bash</code>用一个除了HOME，TERM和PS1变量外</li><li>其他环境完全为空的新shell代替运行中的shell</li><li>这能确保不会有潜在的和意想不到的危险环境变量，从宿主机泄露到构建环境中</li><li>这样做主要是为了确保环境的干净</li></ol><hr><p><strong>1.2.6 配置<code>.bashrc</code>文件</strong></p><ul><li>新的shell实例是一个<code>non-login</code>的shell</li><li>它不会读取<code>/etc/profile</code>或者<code>.bash_profile</code>文件，而是读取<code>.bashrc</code></li><li>创建<code>.bashrc</code>文件:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ~/.bashrc &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="builtin-name">set</span> +h </span><br><span class="line">umask 022 </span><br><span class="line"><span class="attribute">LFS</span>=/mnt/lfs </span><br><span class="line"><span class="attribute">LC_ALL</span>=POSIX </span><br><span class="line"><span class="attribute">LFS_TGT</span>=$(uname -m)-lfs-linux-gnu </span><br><span class="line"><span class="attribute">PATH</span>=/tools/bin:/bin:/usr/bin </span><br><span class="line"><span class="builtin-name">export</span> LFS LC_ALL LFS_TGT PATH </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li><code>set +h</code>命令关闭了bash的哈希功能</li><li>设置用户文件新建时的掩码(umask)为 022，以确保新建的文件和目录只有其所有者可写，但任何人都可读可执行</li><li>LFS 变量应设置成选定的挂载点</li><li><code>LC_ALL变量</code>控制某些程序的本地化，使它们的消息遵循特定国家的惯例</li><li>设置<code>LC_ALL</code>为<code>POSIX</code>或<code>C</code>(两者是等价的)，以确保在chroot环境中一切能如期望的那样进行</li><li><code>LFS_TGT变量</code>设置了一个虽非默认，但在构建交叉编译器、连接器和交叉编译临时工作链时，用得上到的兼容的机器说明</li><li>通过把<code>/tools/bin</code>放在标准<code>PATH变量</code>的前面，使得所有在临时主机中安装的程序，一经安装shell便能马上使用</li><li>与之配合的关闭哈希功能，能在临时主机环境中的程序在可用的情况下，限制使用宿主机中旧程序的风险</li></ul><hr><ul><li>1.2.7 启用配置</li><li>最后，启用刚才创建的用户配置</li><li>为构建临时工具完全准备好环境:<blockquote><p><code>source ~/.bash_profile</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;LFS-1&quot;&gt;&lt;a href=&quot;#LFS-1&quot; class=&quot;headerlink&quot; title=&quot;LFS-1&quot;&gt;&lt;/a&gt;LFS-1&lt;/h3
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="GNU\Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Disk-1</title>
    <link href="https://unit-serow.github.io/2020/02/28/Disk/"/>
    <id>https://unit-serow.github.io/2020/02/28/Disk/</id>
    <published>2020-02-28T03:08:36.000Z</published>
    <updated>2020-02-28T03:09:31.104Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="Disk-1"><a href="#Disk-1" class="headerlink" title="Disk-1"></a>Disk-1</h2><hr><h3 id="Disk-引导逻辑全过程描述"><a href="#Disk-引导逻辑全过程描述" class="headerlink" title="Disk 引导逻辑全过程描述"></a>Disk 引导逻辑全过程描述</h3><ul><li>磁盘从底层固件引导至操作系统启动所对应的执行逻辑</li><li>本篇内容仅为主观描述，仅供参考</li></ul><p><strong>执行逻辑简述:</strong></p><p>Linux</p><blockquote><p><code>BIOS/UEFI(ROM)-&gt;MBR/GPT/GUID-(LBA/CHS)-&gt;VBR-&gt;grldr-&gt;boot loader-&gt;GRUB/LILO...-&gt;启动整个Linux系统</code></p></blockquote><p>windows</p><blockquote><p><code>BIOS-&gt;MBR-&gt;DPT-&gt;PBR-&gt;Bootmgr-&gt;BCD-&gt;系统选择界面--&gt;选择windows-NT-&gt;Winload.exe-&gt;内核加载等 -&gt;启动整个windows-NT系统</code></p></blockquote><p><strong>文字描述:</strong></p><ul><li><ol><li>先给基于ROM的固件BIOS/UEFI通电(启动/运行)，以加载磁盘主引导程序</li></ol></li><li><ol start="2"><li>POST(Power-On Self-Test)，基于BIOS程序进行对本地主机的硬件自检</li></ol></li><li><ol start="3"><li>基于对应固件类别来加载引导扇区(Boot Sequence)<blockquote><p>BIOS根据Boot Sequence中的顺序，将最前面的存储设备的引导扇区的内容加载到内存中，并跳转到引导程序的第一条指令</p></blockquote></li></ol></li><li><ol start="4"><li>再通过基于主引导记录类型(MBR/GPT/GUID)来指定的寻址模式(LBA/CHS)来寻找已有的开机引导程序(进入磁盘启动环节)<blockquote><p>关于MBR与GPT的内容可参考历史文章</p></blockquote></li></ol></li><li><ol start="5"><li>基于某个类别的主引导记录类型利用分区表将控制权转交给硬盘的某个分区<blockquote><p>此时在四个主分区里面，只有一个是激活的计算机会读取激活分区的第一个扇区，叫做卷引导记录(Volume Boot Record，缩写为VBR，也可称为分区引导记录，Partition Boot Record，缩写为PBR)<br>卷引导记录的有以下主要作用:<br>寻找激活分区根目录下的grldr(Grub),NTLDR(XP),bootmgr(Win7 above),btldr.mbr(BootLink)等可用于引导的程序</p></blockquote></li></ol></li><li><ol start="6"><li>执行启动管理器(boot loader)，此时卷引导记录搜索到激活分区中的启动管理器，将控制权交给启动管理器运行<blockquote><p>boot loader是系统预先安装的程序，用以实现由用户选择启动哪一个操作系统<br>启动管理器寻找激活分区中的启动配置数据(如: Win7中的BCD文件、XP中的boot.ini文件)，根据启动配置数据，在显示器上显示多操作系统选择画面<br>然后选择相应的操作系统<br>最后控制权交给操作系统<br>Linux环境中，目前最流行的启动管理器是Grub<br>在windows下为启动管理器bootmgr(xp中的ntldr文件)</p></blockquote></li></ol></li><li><ol start="7"><li>下一步是将控制权转交给操作系统，以此让操作系统的内核首先被载入内存</li></ol></li><li><ol start="8"><li>最后实现磁盘内操作系统的启动</li></ol></li><li><p><em>或*</em></p></li><li><ol><li>由BIOS/UEFI寻找第一个可启动设备(通常为Disk)</li></ol></li><li><ol start="2"><li>然后从MBR/GPT/GUID中基于的寻址模式来加载启动程序</li></ol></li><li><ol start="3"><li>最终把代码控制权交给GRUB(或其它引导程序)</li></ol></li><li><p>所谓操作系统的引导过程是将存放在硬盘上的静态的操作系统装载到内存中，并开始执行操作系统的过程</p></li><li><p>每一个不同类别的工具都有完全不同的执行逻辑与所执行步骤对应的执行标志，这里先不做过多阐述</p></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>引导扇区: 主引导记录(主引导扇区)/全局唯一标识符(全局唯一标识分区表)<blockquote><p>MBR/GPT/GUID</p></blockquote></li><li>磁盘引导程序所基于的寻址模式(LBA/CHS)</li><li>LVM/RAID(逻辑卷管理/磁盘阵列)</li><li>BIOS/UEFI(固件系统)</li><li>磁盘/磁盘分区所属数据类型/文件系统</li><li>磁盘映像文件格式</li><li>磁盘驱动/硬件驱动/设备驱动</li><li>扩展分区(Extended partition)和逻辑分区(logical partition)<blockquote><p>扩展引导记录(Extended boot record)缩写为EBR</p></blockquote></li><li>MBR/GPT分区表</li><li>启动管理器(boot loader)</li></ul><hr><p><strong>磁盘缓存(Disk Buffer/Disk Cache)相关概述:</strong></p><ul><li><p>用于将下载到的数据先保存于系统为软件分配的内存空间中(这个内存空间被称之为”内存池”)</p><blockquote><p>当保存到内存池中的数据达到一个程度时，便会将数据保存到硬盘中<br>这样可以减少实际的磁盘操作，有效的保护磁盘免于重复的读写操作而导致的损坏</p></blockquote></li><li><p>磁盘缓存是为了减少CPU透过I/O读取磁盘驱动器的次数</p><blockquote><p>提升磁盘I/O的效率，用一块存储器来存储访问较频繁的磁盘内容<br>因为存储器的访问是电子动作，而磁盘的访问是机械动作，感觉上磁盘I/O变得较为快速</p></blockquote></li><li><p>普遍的磁盘通常有32MB或64MB缓存，现在市售上128MB与256MB也十分常见</p><blockquote><p>旧的硬盘则有8MB或16MB</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-磁盘缓存<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98</code></p></blockquote></li><li><p>CN-阮一峰-计算机是如何启动的?<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ruanyifeng.com/blog/2013/02/booting.html</code></p></blockquote></li><li><p>CSDN-操作系统引导过程<a href="https://blog.csdn.net/jonathan321/article/details/51987680" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/jonathan321/article/details/51987680</code></p></blockquote></li><li><p>CSDN-操作系统引导程序学习笔记<a href="https://blog.csdn.net/aice_dachong/article/details/50843240" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/aice_dachong/article/details/50843240</code></p></blockquote></li><li><p>CSDN-操作系统概念：系统引导过程、引导程序、固件<a href="https://blog.csdn.net/qq_36328643/article/details/79922425" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36328643/article/details/79922425</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Disk-1&quot;&gt;&lt;a href=&quot;#Disk-1&quot; class=&quot;headerlink&quot; title=&quot;Disk-1&quot;&gt;&lt;/a&gt;Disk-1
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Disk" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Disk/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU GRUB</title>
    <link href="https://unit-serow.github.io/2020/02/28/GNU-GRUB/"/>
    <id>https://unit-serow.github.io/2020/02/28/GNU-GRUB/</id>
    <published>2020-02-27T17:04:40.000Z</published>
    <updated>2020-02-27T17:06:05.278Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h3 id="GRUB-简述"><a href="#GRUB-简述" class="headerlink" title="GRUB 简述"></a>GRUB 简述</h3><ul><li>概述</li><li>启动过程(逻辑)</li><li>特性(相对于LILO或其它的引导程序)</li><li>相关概念</li></ul><p><strong>概述:</strong></p><ul><li>GNU GRUB，简称GRUB</li><li>基于GNU通用公共许可证</li><li>是一个来自GNU项目的启动引导程序</li><li>GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统并在计算机启动时选择希望运行的操作系统</li><li>GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数</li><li>GNU GRUB的前身为Grand Unified Bootloader</li><li>它主要用于类Unix系统</li><li>同大多Linux发行版一样，GNU系统也采用GNU GRUB作为它的启动器</li><li>Solaris从10 1/06版开始在x86系统上也采用GNU GRUB作为启动器</li></ul><hr><p><strong>GRUB启动过程:</strong></p><ol><li>计算机启动后，BIOS将寻找第一个可启动的设备(通常为硬盘)</li><li>而后从MBR中加载启动程序，然后把控制交给这段代码</li><li>MBR位于硬盘的前512字节内</li></ol><ul><li>GRUB第一版的启动过程</li></ul><ol><li>GRUB的步骤1包含在MBR中<blockquote><p>由于受MBR的大小限制，步骤1所做的几乎只是装载GRUB的下一步骤(存放在硬盘的其它位置)</p></blockquote></li><li>步骤1既可以直接装载步骤2，也可以装载步骤1.5: GRUB的步骤1.5包含在MBR后面的30千字节中</li><li>步骤1.5加载步骤2</li><li>当步骤2启动后，它将呈现一个界面来让用户选择启动的操作系统<blockquote><p>这步通常采用的是图形菜单的形式，如果图形方式不可用或者用户需要更高级的控制<br>可以使用GRUB的命令行提示，通过它，用户可以手工指定启动参数<br>GRUB还可以设置超时后自动从某一个内核启动</p></blockquote></li></ol><ul><li>GRUB第二版的启动过程</li><li>与GRUB第一版相似的是，<code>boot.img</code>像步骤1一样在MBR或在启动分区中<blockquote><p>但是，它可以从任何LBA48地址的一个扇区中读取</p></blockquote></li></ul><ol><li>它(boot.img)将读取core.img(产生于diskboot.img)的第一个扇区以用来后面读取core.img的剩余部分</li><li>core.img正常情况下跟步骤1.5储存在同一地方并且有着同样的问题<blockquote><p>可是，当他被移动到一个文件系统或一个纯粹的分区时会比在步骤1.5移动或删除引起更少的麻烦<br>一旦完成读取，core.img会读取默认的配置文件和其他需要的模块</p></blockquote></li></ol><ul><li>当GRUB启动后的执行逻辑(NT内核的特点)</li><li>一旦选择了启动选项，GRUB把选择的内核加载内存并把控制交给内核<blockquote><p>在此步骤中，对于Windows之类不支持多启动标准的操作系统，GRUB也可以通过链式启动把控制传给其它启动器<br>在这种情况下，其它操作系统的启动程序被GRUB保存了下来</p></blockquote></li><li>与内核不同，其它操作系统如同直接自MBR启动<blockquote><p>类似Windows的启动菜单，也许是另一个启动管理器，它允许在多个不支持多启动的操作系统中做进一步的选择<br>在已有Windows的系统上面，或者包含多个Windows版本的系统上安装现代的Linux而不修改原操作系统，即属于这类情况</p></blockquote></li></ul><hr><p><strong>GRUB特点:</strong></p><ul><li><p>GRUB的一个重要的特性是安装它不需依附一个操作系统</p><blockquote><p>但是，这种安装需要一个Linux/Windows副本<br>由于单独工作，GRUB实质上是一个微型系统，通过链式启动的方式，它可以启动所有安装的主流操作系统</p></blockquote></li><li><p>与LILO不同，修改GRUB的配置文件后，不必把GRUB重新安装到MBR或者某个分区中</p></li><li><p>在Linux中，<code>$grub-install</code>命令是用来把GRUB的步骤1安装到MBR或者分区中的</p><blockquote><p>GRUB的配置文件、步骤2以及其它文件必须安装到某个可用的分区中<br>如果这些文件或者分区不可用，步骤1将把用户留在命令行界面</p></blockquote></li><li><p>GRUB Legacy的配置文件</p><blockquote><p>为<code>/boot/grub/menu.lst</code>或<code>/boot/grub/grub.conf</code></p></blockquote></li><li><p>GRUB 2的配置文件</p><blockquote><p>为<code>/boot/grub/grub.conf</code></p></blockquote></li><li><p>除了硬盘外，GRUB也可安装到光盘、软盘和闪存盘等移动介质中</p><blockquote><p>以此引导一台无法从硬盘启动的系统</p></blockquote></li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>LILO</li><li>SYSLINUX</li><li>GRUB</li><li>UEFI</li><li>BIOS</li><li>MBR</li><li>GPT</li><li>NTLDR</li><li>Windows Boot Manager</li></ul><hr><h3 id="GRUB-使用方法与相关指令简述"><a href="#GRUB-使用方法与相关指令简述" class="headerlink" title="GRUB 使用方法与相关指令简述"></a>GRUB 使用方法与相关指令简述</h3><ul><li>grub命令是多重引导程序grub的命令行shell工具</li><li>基本语法:<blockquote><p><code>$grub [options]</code></p></blockquote></li><li>直接键入grub则直接进入grub命令行</li><li>其它参数这里不过过多阐述</li></ul><hr><ul><li><p>正常启动情况下，屏幕上出现grub的启动项选择菜单时按<code>c键</code>也是可以进入<code>grub&gt;</code>状态的</p></li><li><p>grub指令最重要且最常用的功能就是用来启动损坏的或者是LFS的已独立系统</p></li><li><p>用grub的命令来手工启动系统只需要用到四个命令<code>boot</code>，<code>kernel</code>，<code>initrd</code>，<code>boot</code></p></li><li><p>参数<code>--help</code>用于显示帮助信息</p></li><li><p>列出当前电脑上可能的磁盘设备</p><blockquote><p><code>grub&gt; root (hd/sd</code><br>然后按两次TAB键<br>通常会输出硬盘为<code>hd0/hd1</code>或<code>sd0/sd1</code>等</p></blockquote></li><li><p>选择本地主机的安装Linux系统的硬盘</p></li><li><p>比如<code>hd0</code>，执行</p><blockquote><p><code>grub&gt; root (hd0,</code><br>再按两次TAB键<br>通常输出并列出本地主机第一块硬盘上的分区情况<br>此时可以知道哪个是swap交换分区(0x82)或哪个是Linux分区(0x83)</p></blockquote></li><li><p>然后选择可能的/boot目录所在的分区</p><blockquote><p>执行<code>root (hd0, 1)</code>并回车</p></blockquote></li><li><p>查看所选分区是否为<code>/boot</code>所在分区(根目录分区判断)</p><blockquote><p><code>grub&gt; cat /xxx/xxx</code><br>xxx为指定文件目录<br>按两次TAB键</p></blockquote></li><li><p>这里以输入<code>cat /sbin/init</code>来举例，连按两次TAB键之后参考以下两种情况:</p></li></ul><ol><li>如果出现一些init开头的文件，则说明该分区为<code>/</code>所在的分区</li><li>如果没有出现/sbin/init文件，说明(hd0,1)分区仅仅是<code>/boot</code>分区而不是<code>/</code>分区<blockquote><p>此时需要重新输入<code>$root (hd0,N)</code>命令，这里N是某个Linux分区<br>然后再试<code>cat /sbin/init</code>， 直到屏幕上出现<code>/sbin/init</code><br>则说明找到了<code>/</code>分区<br>严格来说，应该是<code>/sbin</code>目录所在的分区</p></blockquote></li></ol><ul><li><p>此指令还可用于判断所选分区内的文件目录与拥有文件，利用所存储文件的类别来判断分区的作用及分区名</p></li><li><p>这里的关键问题是如何确定系统的几个分区: <code>/boot</code>，<code>/</code>与<code>/sbin</code></p></li><li><p>比如输入<code>cat /boot/vm</code>并按两次TAB键</p><blockquote><p>如果出现一些<code>vm</code>开头的文件，比如<code>vmlinuz-2.6.15-26-386</code>说明这里是<code>/boot</code>所在的分区</p></blockquote></li><li><p>再输入<code>cat /boot/initrd</code>并按两次TAB键</p><blockquote><p>如果出现一些<code>initrd</code>开头的文件，比如<code>initrd.img-2.6.15-26-386</code>说明这个<code>/boot</code>所在的分区有<code>initrd</code>即<code>ramdisk</code>镜像</p></blockquote></li></ul><p><strong>通用指令集:</strong></p><ul><li>一般情况下，依次输入以下命令即可以进入(启动)系统<blockquote><p><code>root (hd0,1)</code> # 此时假设<code>/dev/hda2</code>是本地主机的<code>/boot</code>所在的分区<br><code>kernel /boot/vmlinuz-2.6.15-26-386 ro dev=/dev/hda3</code> # 此时假设<code>/dev/hda3</code>是本地主机的根目录<code>/</code>所在的分区<br><code>initrd /boot/initrd.img-2.6.15-26-386</code><br><code>boot</code><br>双引号</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-WIKI-GNU GRUB<a href="https://zh.wikipedia.org/wiki/GNU_GRUB" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU_GRUB</code></p></blockquote></li><li><p>EN-GNU 官网<a href="https://www.gnu.org/software/grub/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/grub/</code></p></blockquote></li><li><p>EN-GNU 手册<a href="https://www.gnu.org/software/grub/manual/grub/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/grub/manual/grub/</code></p></blockquote></li><li><p>CN-GRUB 2 中文指南<a href="http://wiki.ubuntu-tw.org/index.php?title=GRUB_2_%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://wiki.ubuntu-tw.org/index.php?title=GRUB_2_%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97</code></p></blockquote></li><li><p>CN-GRUB入门教程(Ubantu论坛)<a href="https://forum.ubuntu.org.cn/viewtopic.php?t=2475" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://forum.ubuntu.org.cn/viewtopic.php?t=2475</code></p></blockquote></li><li><p>EN-mmap.page<a href="https://mmap.page/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mmap.page/</code></p></blockquote></li><li><p>CN-GRUB指令集整合<a href="https://man.linuxde.net/grub" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://man.linuxde.net/grub</code></p></blockquote></li><li><p>CN-Linux命令大全<a href="https://man.linuxde.net/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://man.linuxde.net/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GRUB-简述&quot;&gt;&lt;a href=&quot;#GRUB-简述&quot; class=&quot;headerlink&quot; title=&quot;GRUB 简述&quot;&gt;&lt;/a&gt;GRU
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Disk" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Disk/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Toolchain/GNU toolchain</title>
    <link href="https://unit-serow.github.io/2020/02/27/Toolchain-GNU-toolchain/"/>
    <id>https://unit-serow.github.io/2020/02/27/Toolchain-GNU-toolchain/</id>
    <published>2020-02-27T13:08:35.000Z</published>
    <updated>2020-02-27T14:00:05.546Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="工具链基本概念简述-1"><a href="#工具链基本概念简述-1" class="headerlink" title="工具链基本概念简述-1"></a>工具链基本概念简述-1</h2><ul><li>此模块只做简单的概述与对于概念的浅层理解</li><li>工具环境所需要的包这里不做过多赘述(与工具链无关)</li></ul><hr><h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p><strong>概述:</strong></p><ul><li>Toolchain</li><li>在开发软件过程中，一组工具链(toolchain)是一系列用于制作软件程序的工具</li><li>这些工具一般一个接一个地运用，上一个工具的输出即是下一个工具的输入，因此得名</li><li>但工具链这个词汇也可指涉这些工具并无此相依运行的限制</li><li>工具链与集成开发环境形成对照，分别代表了两种不同风格的软件开发环境</li></ul><p><strong>基本构成:</strong></p><ul><li>通常一个软件开发的工具链由以下组成:</li></ul><ol><li>编译器</li><li>链接器 (将源代码/目标代码转换成可执行程序档)</li><li>库 (提供与操作系统之间的界面)</li><li>调试器 (用来测试、调试所产出的程序)</li></ol><hr><h3 id="GNU-工具链"><a href="#GNU-工具链" class="headerlink" title="GNU 工具链"></a>GNU 工具链</h3><p><strong>概述:</strong></p><ul><li>GNU toolchain</li><li>是一个包含了由GNU计划所产生的各种编程工具的集合，由自由软件基金会负责维护工作</li><li>这些工具形成了一条工具链，用于开发应用程序和操作系统</li><li>同时与集成开发环境相对应</li></ul><p><strong>GNU工具链组成:</strong></p><ul><li>GNU make：用于编译和构建的自动工具</li><li>GNU编译器集合 (GCC) 一组多种编程语言的编译器</li><li>GNU Binutils: 包含链接器、汇编器和其它工具的工具集</li><li>GNU Bison: 编译器编译程序，经常和 Flex词法分析器 配合使用</li><li>GNU m4: m4 宏预处理器</li><li>GNU Debugger (GDB):代码调试工具</li><li>GNU构建系统 (autotools):<blockquote><p>Autoconf<br>Autoheader<br>Automake<br>Libtool</p></blockquote></li><li>GNU C Library: GNU C标准函数库</li><li>GNU Classpath</li></ul><hr><h3 id="交叉工具链"><a href="#交叉工具链" class="headerlink" title="交叉工具链:"></a>交叉工具链:</h3><p><strong>概述:</strong></p><ul><li><p>用于提供编译，链接，处理等功能</p></li><li><p>就是为了编译，链接，处理和调试跨平台体系结构的程序代码</p></li><li><p>每次执行工具链软件时，通过带有不同的参数，可以实现编译，链接，处理或者调试等不同的功能</p></li><li><p>从工具链的组成上来说，它一般由多个程序构成，分别对应着各个功能</p></li><li><p>所谓的交叉工具链是由以下两个概念组合而成的:</p></li></ul><ol><li>交叉编译: 是A机器上编译生成，运行在B机器上<blockquote><p>两个机子有不同的机器指令</p></blockquote></li><li>工具链: 一般由编译器，连接器，解释器和调试器组成</li></ol><hr><h3 id="交叉编译器"><a href="#交叉编译器" class="headerlink" title="交叉编译器:"></a>交叉编译器:</h3><ul><li>是指一个在某个系统平台下可以产生另一个系统平台的可执行文件的编译器</li><li>交叉编译器在目标系统平台(开发出来的应用程序序所运行的平台)难以或不容易编译时非常有用</li><li>交叉编译器的存在对于从一个开发主机为多个平台编译代码是非常有必要的</li><li>直接在平台上编译有时行不通，例如在一个嵌入式系统的单片机 ，因为它们没有操作系统，所以直接编译行不通</li><li>交叉编译器和源代码至源代码编译器不同，交叉编译器用于二进制代码的跨平台软件开发<blockquote><p>而源到源编译器是将某种编程语言的程序源代码作为输入<br>生成以另一种编程语言构成的等效源代码的编译器，但两者都是编程工具</p></blockquote></li><li>交叉编译器的基本用法就是将构建环境与目标环境分开</li><li>常在下面几种情况中使用(具体使用方法这里不做过多赘述):<blockquote><p>嵌入式电脑<br>编译多个目标库<br>引导一个新平台(Bootstrapping)<br>程序虚拟机(比如JVM)</p></blockquote></li></ul><hr><ul><li>工具链用途简述:</li><li>GNU工具链在针对嵌入式系统的Linux内核、BSD及其它软件的开发中起着至关重要的作用</li><li>GNU工具链中的部分工具也被Solaris, Mac OS X, Microsoft Windows (via Cygwin and MinGW/MSYS) and Sony PlayStation 3等其它平台直接使用或进行了移植</li></ul><hr><p><strong>工具链相关概念(关键字):</strong></p><ul><li>工具链</li><li>GNU 工具链</li><li>集成开发环境</li><li>编译器/标准库/链接器/调试器</li><li>交叉编译器</li><li>分布式/并发版本控制系统(CVS,Git等等)</li><li>工具链环境</li></ul><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p><strong>工具链环境:</strong></p><ul><li>所谓的工具链环境就是:<blockquote><p>不光包含于工具链的基本组件<br>还包含于各类辅助指令所对应的工具与程序的本地系统环境</p></blockquote></li></ul><hr><h3 id="GNU工具链组件完全性参考"><a href="#GNU工具链组件完全性参考" class="headerlink" title="GNU工具链组件完全性参考:"></a>GNU工具链组件完全性参考:</h3><p><strong>基本工具:</strong></p><ul><li>GNU make: 用于编译和构建的自动工具</li><li>GNU编译器集(GCC): 一组多种编程语言的编译器</li><li>GNU Binutils: 包含链接器，汇编器和其它工具的工具集</li><li>GNU调试工具(GDB): 代码调试工具</li><li>GNU自动化生成工具(autotools): 自动化检查软件编译过程的工具</li></ul><hr><p><strong>工具链体系:</strong></p><ul><li>此部分用于描述工具链的相关概念与结构，以实现对工具链实施完整的分析</li><li>本文选取LFS的工具链来说明工具链体系内的软件包组成及依赖关系</li><li>为了使以上不同类别的所属工具形成一个互相关联且互相依赖的工具链体系</li><li>必须安装与配置以下软件包工具与相关程序及源码来构成与实现其工具链体系的依赖关系</li></ul><p><strong>所需软件一览:</strong></p><p><strong>Binutils(汇编器):</strong></p><ul><li>包含的程序:<blockquote><p><code>addr2line，ar，as，c++filt，elfedit，gprof，ld，ld.bfd</code>，<br><code>nm，objcopy，objdump，ranlib，readelf，size，strings 和 strip</code></p></blockquote></li><li>包含的库:<blockquote><p><code>libiberty，libbfd</code> 和 <code>libopcodes</code></p></blockquote></li></ul><p><strong>GCC(编译器):</strong></p><ul><li>包含的程序:<blockquote><p><code>c++，cc(到 gcc 的链接)，cpp，g++，gcc</code>，<br><code>gcc-ar，gcc-nm，gcc-ranlib，gccbug</code> 和 <code>gcov</code></p></blockquote></li><li>包含的库:<blockquote><p><code>libgcc，libgcov，libgomp，liblto_plugin，libmudflap</code>，<br><code>libquadmath，libssp，libstdc++，libsupc++</code></p></blockquote></li><li>依赖的包: <code>gmp，mpfr，mpc</code></li></ul><p><strong>Linux API Headers:</strong></p><ul><li>这个是可选包，如果是为了做一个通用工具链，必须将其换成相应平台的头文件包</li><li>包含的头文件:<blockquote><p><code>/usr/include/asm/*.h</code>，<code>/usr/include/asm-generic/*.h</code>，<br><code>/usr/include/drm/*.h</code>，<code>/usr/include/linux/*.h</code>，<code>/usr/include/mtd/*.h</code>，<br><code>/usr/include/rdma/*.h</code>，<code>/usr/include/scsi/*.h</code>，<br><code>/usr/include/sound/*.h</code>，<code>/usr/include/video/*.h</code>，<code>/usr/include/xen/*.h</code></p></blockquote></li></ul><p><strong>Glibc:</strong></p><ul><li>可以根据标准LFS系统的制作方法来安装Glic(可以大幅度简化实现难度)</li><li>包含的程序:<blockquote><p><code>catchsegv，gencat，getconf，getent，iconv，iconvconfig</code>，<br><code>ldconfig，ldd，lddlibc4，locale, localedef，makedb，mtrace，nscd</code>，<br><code>pcprofiledump，pldd，pt_chown，rpcgen, sln, sotruss, sprof, tzselect, xtrace, zdump 和 zic</code></p></blockquote></li><li>包含的库:<blockquote><p><code>ld.so</code>，<code>libBrokenLocale</code>，<code>libSegFault</code>，<code>libanl</code>，<code>libbsd-compat</code>，<code>libc</code>，<code>libcidn</code>，<code>libcrypt</code>，<br><code>libdl</code>，<code>libg</code>，<code>libieee</code>，<code>libm</code>，<code>libmcheck</code>，<code>libmemusage</code>，<code>libnsl</code>，<code>libnss</code>，<code>libpcprofile</code>，<code>libpthread</code>，<br><code>libresolv</code>，<code>librpcsvc</code>，<code>librt</code>，<code>libthread_db</code>，<code>libutil</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-WIKI GNU核心工具组<a href="https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84</code></p></blockquote></li><li><p>CN-WIKI GNU工具链<a href="https://zh.wikipedia.org/wiki/GNU%E5%B7%A5%E5%85%B7%E9%93%BE" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU%E5%B7%A5%E5%85%B7%E9%93%BE</code></p></blockquote></li><li><p>CN-WIKI 交叉工具链<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</code></p></blockquote></li><li><p>百度百科 交叉工具链<a href="https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E5%B7%A5%E5%85%B7%E9%93%BE/2503696" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E5%B7%A5%E5%85%B7%E9%93%BE/2503696</code></p></blockquote></li><li><p>CN-WIKI 交叉编译器<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</code></p></blockquote></li><li><p>Linux From Scratch (简体中文版/版本: 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Chapter (5.x. 构建临时系统) 与 (5.2. 工具链技术说明)<br><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>工具链技术分析与实现(GNU 工具链)<a href="https://www.cnblogs.com/Leo_wl/p/3405580.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/Leo_wl/p/3405580.html</code></p></blockquote></li></ul><hr><h2 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="工具链技术实现"><a href="#工具链技术实现" class="headerlink" title="工具链技术实现"></a>工具链技术实现</h3><ul><li>GNU 工具链</li></ul><h3 id="工具链的使用方式"><a href="#工具链的使用方式" class="headerlink" title="工具链的使用方式"></a>工具链的使用方式</h3><ul><li><p>工具链的目的是提供一个临时可用的编译工作环境，通过chroot来完成在工具环境中进行开发、编译、制作工作</p></li><li><p>为了制作出干净、可移植的工具环境，建议创建一个专用于制作工具链的用户，这也是LFS推荐的</p></li><li><p>在使用工具链之前，此时的本地环境身份应该是root</p></li><li><p>首先挂载虚拟文件系统，然后进入到chroot环境中</p></li></ul><ol><li><strong>挂载虚拟文件系统</strong></li></ol><ul><li><p>可以将以下代码保存为相应的Shell脚本文件，添加执行权限即可使用</p></li><li><p>使用顺序是先挂载虚拟文件系统、后进入chroot环境</p></li><li><p>下方代码只适用于LFS的构建，可根据需求做适当的变量替换，原理和步骤是相同的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mount -o <span class="built_in">bind</span> /dev <span class="variable">$LFS</span>/dev</span><br><span class="line">mount -t devpts devpts <span class="variable">$LFS</span>/dev/pts -o gid=5,mode=620</span><br><span class="line">mount -t proc proc <span class="variable">$LFS</span>/proc</span><br><span class="line">mount -t sysfs sysfs <span class="variable">$LFS</span>/sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -h <span class="variable">$LFS</span>/dev/shm ]; <span class="keyword">then</span></span><br><span class="line">  link=$(readlink <span class="variable">$LFS</span>/dev/shm)</span><br><span class="line">  mkdir -p <span class="variable">$LFS</span>/<span class="variable">$link</span></span><br><span class="line">  mount -t tmpfs shm <span class="variable">$LFS</span>/<span class="variable">$link</span></span><br><span class="line">  <span class="built_in">unset</span> link</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  mount -t tmpfs shm <span class="variable">$LFS</span>/dev/shm</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>进入到Chroot环境执行以下代码:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">chroot <span class="string">"<span class="variable">$LFS</span>"</span> /tools/bin/env -i \</span><br><span class="line">    HOME=/root                  \</span><br><span class="line">    TERM=<span class="string">"<span class="variable">$TERM</span>"</span>                \</span><br><span class="line">    PS1=<span class="string">'\u:\w\$ '</span>              \</span><br><span class="line">    PATH=/tools/bin:/tools/sbin:/bin:/usr/bin:/sbin:/usr/sbin \</span><br><span class="line">    /tools/bin/bash --login +h</span><br></pre></td></tr></table></figure><hr><ul><li><p>Linux From Scratch (简体中文版/版本: 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Chapter (5.x. 构建临时系统) 与 (5.2. 工具链技术说明)<br><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>工具链技术分析与实现(GNU 工具链)<a href="https://www.cnblogs.com/Leo_wl/p/3405580.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/Leo_wl/p/3405580.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;工具链基本概念简述-1&quot;&gt;&lt;a href=&quot;#工具链基本概念简述-1&quot; class=&quot;headerlink&quot; title=&quot;工具链基本概念简
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-7</title>
    <link href="https://unit-serow.github.io/2020/02/27/LFS-7/"/>
    <id>https://unit-serow.github.io/2020/02/27/LFS-7/</id>
    <published>2020-02-27T08:53:15.000Z</published>
    <updated>2020-02-27T08:54:57.998Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h3 id="LFS-7"><a href="#LFS-7" class="headerlink" title="LFS-7"></a>LFS-7</h3><ul><li>内核编译等内容</li><li>有关GRUB的内容会再做补充</li></ul><hr><h3 id="相关指令-通用执行逻辑简述"><a href="#相关指令-通用执行逻辑简述" class="headerlink" title="相关指令(通用执行逻辑简述)"></a>相关指令(通用执行逻辑简述)</h3><ul><li>清理编译所处环境的内核依赖树<blockquote><p><code>$makemrpoper</code></p></blockquote></li></ul><hr><ul><li><p>通过菜单驱动的界面配置内核</p></li><li><p>BLFS包含一些有关LFS外部软件包的特定内核配置要求的信息<a href="http://www.linuxfromscratch.org/blfs/view/svn/longindex.html#kernel-config-index" target="_blank" rel="noopener">BLFS-kernel</a></p></li><li><p>基本语法</p><blockquote><p><code>make LANG=&lt;host_LANG_value&gt; LC_ALL= menuconfig</code></p></blockquote></li><li><p>参数含义:</p><blockquote><p>make将语言环境设置建立为主机上使用的语言环境设置(这个参数建立主机上使用的locale设置)<br>UTF-8 的linux文本控制台上的菜单配置ncurses 接口线图需要这个值<br>确保用主机上的<code>$LANG变量代替&lt;host_LANG_value&gt;(还可以说是用主机中变量&lt;host_LANG_value&gt;的值替换$LANG)</code><br>如果主机没有设置，还可以使用<code>$LC_ALL或$LC_CTYPE</code>的值代替</p></blockquote></li><li><p>另外在某一些场合使用<code>$make oldconfig</code>可能更合适</p><blockquote><p>更多信息可参考README文件</p></blockquote></li><li><p>还有一种方法，可以跳过配置内核的步骤</p><blockquote><p>直接把宿主系统里的内核配置文件<code>.config</code>(如果存在的话)复制到解压后的linux-2.6.32.8目录<br>FLS官方说明这里不推荐这么去做<br>考察全部的配置菜单并从头开始创建内核配置是更好的办法</p></blockquote></li></ul><hr><ul><li><p>编译内核映像和所选模块</p><blockquote><p>make</p></blockquote></li><li><p>参数说明</p><blockquote><p>如果使用内核模块，可能需要<code>/etc/modprobe.d</code>目录中的模块配置<br>关于模块和内核配置的信息请参考 Section 7.9内的LFS 系统的设备和模块处理内容和linux-2.6.32.8/Documentation目录的内核文档<br><code>modprobe.conf(5)</code>也可能有用</p></blockquote></li></ul><hr><ul><li><p>如果内核配置使用模块，执行模块安装指令:</p><blockquote><p><code>make modules_install</code></p></blockquote></li><li><p>当内核编译完成后，还需要一些步骤来完成安装</p></li><li><p>比如需要把一些文件拷贝到/boot目录</p></li></ul><hr><ul><li><p>内核镜像文件所在的路径因所处主机使用的平台不同而不同</p></li><li><p>下面的文件名可以更改为符合本地主机的配置</p></li><li><p>但为了与下一节描述的启动过程的自动安装兼容，文件名的词干应该是vmlinux</p></li><li><p>x86平台上运行以下命令:</p><blockquote><p><code>cp -v arch/x86/boot/bzImage /boot/vmlinux-2.6.32.8-lfs-6.6</code></p></blockquote></li><li><p>System.map是内核的符号文件</p></li><li><p>它映射了内核API中每个函数的入口， 以及正在运行内核的数据结构的地址</p></li><li><p>在调查内核问题时，使用它作为一种资源， 运行以下的命令安装此文件:</p><blockquote><p><code>cp -v System.map /boot/System.map-2.6.32.8</code></p></blockquote></li><li><p>上面<code>make menuconfig</code>这一步产生的内核配置文件<code>.config</code>包含了刚刚编译的内核的所有配置选项</p></li><li><p>最好保留这个文件以备将来参考:</p><blockquote><p><code>cp -v .config /boot/config-2.6.32.8</code></p></blockquote></li><li><p>安装Linux内核文档:</p><blockquote><p><code>install -d /usr/share/doc/linux-2.6.32.8</code><br><code>cp -r Documentation/* /usr/share/doc/linux-2.6.32.8</code></p></blockquote></li></ul><hr><p><strong>配置Linux模块装载顺序:</strong></p><ul><li><p>需要创建<code>/etc/modprobe.d/usb.conf</code>文件</p><blockquote><p>以便如果将USB驱动(<code>ehci_hcd， ohci_hcd 和uhci_hcd</code>)编译成模块时，它们会按正确的顺序装载<br>为了避免在启动时出现警告，<code>ehci_hcd</code>必须在<code>ohci_hcd和uhci_hcd</code>之前装载</p></blockquote></li><li><p>通过运行下面的命令来建立一个新文件/etc/modprobe.d/usb.conf:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">install -v -m755 -d <span class="string">/etc/modprobe.d</span></span><br><span class="line">cat &gt; <span class="string">/etc/modprobe.d/usb.conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="comment"># Begin /etc/modprobe.d/usb.conf</span></span><br><span class="line"></span><br><span class="line">install ohci_hcd <span class="string">/sbin/modprobe</span> ehci_hcd ; <span class="string">/sbin/modprobe</span> -i ohci_hcd ; <span class="literal">true</span></span><br><span class="line">install uhci_hcd <span class="string">/sbin/modprobe</span> ehci_hcd ; <span class="string">/sbin/modprobe</span> -i uhci_hcd ; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># End /etc/modprobe.d/usb.conf</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>注意事项:</strong></p><ul><li><p>重要的一点是要注意到内核源码目录里的文件所有者不是root</p><blockquote><p>只要是用 root(像在chroot环境里做的那样)用户解压软件包，解压出来的文件的用户和组ID是这个软件包打包者计算机上的用户和组ID<br>对于其它软件包， 这通常不是问题， 因为安装完这些软件包之后源码目录就删除了<br>但是 Linux 内核源码树常常会保存很长的时间， 这样就有可能打包者的用户 ID 和您计算机上某个用户的 ID 相同<br>从而让您计算机上的这个用户获得了内核源码的写权限</p></blockquote></li><li><p>如果准备保留内核源代码，在<code>linux-2.6.32.8</code>目录上执行<code>chown -R 0:0</code>命令以确保全部文件的所有者是<code>root</code></p></li><li><p>一些内核文档建议建立一个从<code>/usr/src/linux</code>指向源码目录的符号链接</p><blockquote><p>这只是一个对 2.6 以前版本内核的特殊要求，并且在 LFS 系统上是不允许这样做的<br>因为基本的LFS系统完成以后，安装其他软件包时可能会因此而引起问题</p></blockquote></li><li><p>系统include目录中的头问题件应该总是保持Glibc编译时的那个版本</p><blockquote><p>这也是Linux内核tar包中的干净的头文件<br>因而，它们绝不要被替换成原始的内核头文件和其他干净的头文件</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li><p>LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/view/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/</code></p></blockquote></li><li><p>LFS-v9.3 重新启动系统<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter09/reboot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter09/reboot.html</code></p></blockquote></li><li><p>CSDN参考资料<a href="https://blog.csdn.net/Sugar_girl/article/details/78713316" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/Sugar_girl/article/details/78713316</code></p></blockquote></li><li><p>LFS内核配置全面信息<a href="http://www.linuxfromscratch.org/hints/downloads/files/kernel-configuration.txt" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/hints/downloads/files/kernel-configuration.txt</code></p></blockquote></li><li><p>LFS-v6.3-第八章第三节<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html</code></p></blockquote></li><li><p>Beyond Linux From Scratch (System V Edition) - Version 2020-02-27<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/blfs/view/svn/longindex.html#kernel-config-index</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;LFS-7&quot;&gt;&lt;a href=&quot;#LFS-7&quot; class=&quot;headerlink&quot; title=&quot;LFS-7&quot;&gt;&lt;/a&gt;LFS-7&lt;/h3
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-6</title>
    <link href="https://unit-serow.github.io/2020/02/26/LFS-6/"/>
    <id>https://unit-serow.github.io/2020/02/26/LFS-6/</id>
    <published>2020-02-26T12:38:21.000Z</published>
    <updated>2020-02-26T12:40:18.873Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="LFS-6"><a href="#LFS-6" class="headerlink" title="LFS-6"></a>LFS-6</h2><hr><h3 id="LFS实现逻辑补充"><a href="#LFS实现逻辑补充" class="headerlink" title="LFS实现逻辑补充"></a>LFS实现逻辑补充</h3><p><strong>LFS的实现大致可分为以下四个阶段:</strong></p><ul><li>一阶段</li></ul><p>1.创建目标系统目录<br>2.创建临时系统目录</p><ul><li>二阶段</li></ul><p>3.建立预工具链</p><ul><li>三阶段</li></ul><p>4.建立临时系统<br>5.建立目标工具链</p><ul><li>四阶段</li></ul><p>6.建立目标系统<br>7.收尾工作</p><hr><h2 id="临时系统"><a href="#临时系统" class="headerlink" title="临时系统"></a>临时系统</h2><ol start="3"><li><strong>建立预工具链</strong></li></ol><ul><li><p>预工具链</p></li><li><p>汇编器Binutils，编译器GCC，标准库Glibc</p></li><li><p>以及主系统(内核头接口/API headers)</p><blockquote><p>API headers/GCC/BIN/GLI</p></blockquote></li><li><p>调整工具链</p><blockquote><p>每次安装完工具链想用工具集时都需要适当的调整工具链并对工具链进行测试</p></blockquote></li><li><p>Glibc编译过程中需要设置内核版本参数(可忽略小版本只写大版本)</p></li><li><p>二次安装工具目录(GCC/Bintils)</p></li><li><p>Tcl-v8.4</p></li><li><p>Expect-v5.4</p></li><li><p>DejaGNU-v1.4</p></li><li><p>GCC-Pass2</p></li><li><p>Binutils-Pass2</p></li><li><p>其它辅助程序(工具)</p></li><li><p>Tcl/Expect/DejaGNU为代码(二进制)编译文件测试工具</p><blockquote><p><code>$make check</code></p></blockquote></li></ul><hr><h3 id="预工具链安装逻辑"><a href="#预工具链安装逻辑" class="headerlink" title="预工具链安装逻辑:"></a>预工具链安装逻辑:</h3><ol><li>Binutils-2.17 - Pass 1</li><li>GCC-4.1.2 - Pass 1</li><li>Linux-2.6.22.5 API Headers</li><li>Glibc-2.5.1</li><li>Adjusting the Toolchain(调整工具链)</li><li>Tcl-8.4.15</li><li>Expect-5.43.0</li><li>DejaGNU-1.4.4</li><li>GCC-4.1.2 - Pass 2</li><li>Binutils-2.17 - Pass 2</li><li>其它辅助工具</li></ol><hr><p><strong>所对应LFS内章节内容:</strong></p><ol start="5"><li>Constructing a Temporary System(建立一个临时系统)</li></ol><ul><li>Introduction (介绍与说明)</li><li>Toolchain Technical Notes (工具链技术说明)</li><li>Binutils-2.17 - Pass 1 (汇编器)</li><li>GCC-4.1.2 - Pass 1 (编译器)</li><li>Linux-2.6.22.5 API Headers (内核接口)</li><li>Glibc-2.5.1 (标准库)</li><li>至</li><li>Util-linux-2.12r (UTIL)</li><li>Stripping (抛离)</li><li>Changing Ownership (改变所有权)</li><li>临时系统建立至此截止</li></ul><hr><h2 id="目标系统"><a href="#目标系统" class="headerlink" title="目标系统"></a>目标系统</h2><p><strong>第一步(进行必要配置):</strong></p><ol><li>建立目标系统的文件目录结构</li><li>创建与配置必要软链接</li><li>创建root及nobody用户和必要的组</li><li>此时可以选择是否重新加载bash</li><li>加载以使root用户起效</li><li>创建和设置几个临时文件和日志文件</li></ol><p><strong>第二步(建立目标工具链):</strong></p><ul><li>包括安装逻辑说明</li><li>Linux-2.6.22.5 API Headers - 1</li><li>Man-pages-2.63 - 2</li><li>Glibc-2.5.1 - 3</li><li>Re-adjusting the Toolchain(工具链调试) - 4</li><li>Binutils-2.17 - 5</li><li>GCC-4.1.2 - 6</li><li>其它辅助工具 (Shell/Bash，M4，Autotools等等) - 7</li><li>至此，一直到所有软件安装完毕后，进行工具链调试(v6.3的FSL中最后一个工具通常是vim)</li><li>之后退出chroot环境，设置启动脚本</li><li>下一步即为第七章-设置系统启动脚本然后进行最终的内核编译(Kernel Compile)</li></ul><hr><h3 id="建立目标工具链以及目标工具链环境"><a href="#建立目标工具链以及目标工具链环境" class="headerlink" title="建立目标工具链以及目标工具链环境:"></a>建立目标工具链以及目标工具链环境:</h3><p><strong>参考章节</strong></p><p><strong>三.建立LFS系统(III.Building the LFS System)</strong></p><ol start="6"><li>Installing Basic System Software (6.安装基本系统软件)</li></ol><ul><li>Introduction (介绍)</li><li>Preparing Virtual Kernel File Systems (准备虚拟内核文件系统)</li><li>Package Management (包装管理)</li><li>Entering the Chroot Environment (进入Chroot环境)</li><li>Creating Directories (创建目录)</li><li>Creating Essential Files and Symlinks (创建基本文件和符号链接)</li><li>Linux-2.6.22.5 API Headers (Linux-2.6.22.5 API标头)</li><li>Man-pages-2.63 (Man-帮助手册)</li><li>Glibc-2.5.1 (标准库)</li><li>Re-adjusting the Toolchain (重新调整工具链)</li><li>Binutils-2.17 (汇编器)</li><li>GCC-4.1.2 (编译器)</li><li>至</li><li>About Debugging Symbols (调试符相关内容)</li><li>Stripping Again (再次抛离)</li><li>Cleaning Up (清理环境)</li><li>目标系统环境已搭建完毕</li></ul><hr><h3 id="系统启动脚本设置与编译-包括编写"><a href="#系统启动脚本设置与编译-包括编写" class="headerlink" title="系统启动脚本设置与编译(包括编写)"></a>系统启动脚本设置与编译(包括编写)</h3><p><strong>参考自LFS英文版第七章内容:</strong><br><strong>7. Setting Up System Bootscripts</strong></p><ul><li>介绍 (Introduction)</li><li>LFS-Bootscripts-6.3 (LFS-boot 脚本)</li><li>至</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li></ul><p><strong>配置逻辑说明:</strong></p><ol><li>编译并安装 LFS-Bootscripts-6.3 (LFS-Bootscripts-6.3)</li><li>配置LFS系统上的设备和模块处理 (Device and Module Handling on an LFS System)</li><li>配置setclock脚本 (Configuring the setclock Script)</li><li>配置Linux控制台 (Configuring the Linux Console)</li><li>配置sysklogd脚本 (Configuring the sysklogd Script)</li><li>创建/etc/inputrc文件 (Creating the /etc/inputrc File)</li><li>Bash Shell启动文件 (The Bash Shell Startup Files)</li><li>配置本地网脚本 (Configuring the localnet Script)</li><li>定制/etc/hosts文件 (Customizing the /etc/hosts File)</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li></ol><ul><li>至此结束系统启动脚本配置，下一步即为内核编译</li></ul><hr><h3 id="配置LFS系统引导项-内核编译"><a href="#配置LFS系统引导项-内核编译" class="headerlink" title="配置LFS系统引导项(内核编译)"></a>配置LFS系统引导项(内核编译)</h3><p><strong>参考自FLS文档第八章</strong><br><strong>8. Making the LFS System Bootable</strong></p><p><strong>配置逻辑介绍(参考内容):</strong></p><ol><li>介绍 (Introduction)</li><li>创建/etc /fstab文件 (Creating the /etc/fstab File)</li><li>Linux-2.6.22.5 (Linux-2.6.22.5编译，配置并安装)</li><li>使LFS系统可启动 (Making the LFS System Bootable)</li></ol><ul><li>相关指令集可参考官方文档</li><li>有关第三项的详细说明与配置参考下一篇文章</li></ul><hr><p><strong>其它内容:</strong></p><ul><li>具体配置内容与描述可参考官方文档(EN/CN)</li><li>这里使用的是LFS官方的LiveCD，官方早已停止维护，所以版本已经很老了</li><li>最新的版本是<code>lfslivecd-x86_64-6.3-r2145.iso</code>(614.510KB)-2007</li><li>这里使用的版本是<code>lfslivecd-x86-6.3-r2145.iso</code>(32位版本/648.638KB)-2007</li><li>在<a href="http://unit-serow.com/2020/02/22/LFS-1/#more" target="_blank" rel="noopener">LFS-1</a>这篇文章内有有关LFS所有资料的链接<blockquote><p><code>http://unit-serow.com/2020/02/22/LFS-1/#more</code></p></blockquote></li></ul><hr><ul><li>对于目标系统中的任何工具的编译完成之后，最好进行编译文件(二进制文件)测试是否正确且可用</li><li>即便有错误，只要不是太多或可以通过下一步的应用测试，就可以先无视掉</li><li>等到目标系统内核建立并编译完成之后再对目标Debug进行修补与维护</li><li>测试指令(测试动态链接库): <code>$make check</code></li><li>测试时间长短由工具决定</li><li>有些二进制包在测试时可能会发生几处无关紧要的错误，但不会影响安装和正常使用<blockquote><p>比如类似于找不到man的动态链接库之类的错误</p></blockquote></li><li>有时测试不能顺利结束，可以根据报错来判断问题所在<blockquote><p>多半是文件依赖，动态库，文件映射或配置文件缺失等问题</p></blockquote></li></ul><hr><h3 id="需调整工具链"><a href="#需调整工具链" class="headerlink" title="需调整工具链:"></a>需调整工具链:</h3><ul><li><p>工具链一(预/临时工具链):</p><blockquote><p>预工具链与临时工具链(GCC/Glibc/Binutils/Linux Kernel API Headers)<br>调整specs文件<br>调试与测试所属工具链环境</p></blockquote></li><li><p>工具链二(目标工具链):</p><blockquote><p>目标工具链(GCC/Glibc/Linux Kernel API Headers/Binutils/Man-pages)<br>调整specs文件<br>调试与测试所属工具链环境</p></blockquote></li><li><p>最后执行Strip命令并进入新的chroot环境</p></li><li><p>即为拥有两次抛离过程</p><blockquote><p>第一次是主系统-临时系统<br>第二次是临时系统-目标系统<br>最后保证目标系统可以独立运行并将其独立(完全抛离原系统)</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>具体的配置代码与安装代码可参考LFS官方中/英文书籍</li><li>CN-参考资料FSL为6.3版本<a href="http://www.linuxfromscratch.org/lfs/view/6.3/index.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/index.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-6&quot;&gt;&lt;a href=&quot;#LFS-6&quot; class=&quot;headerlink&quot; title=&quot;LFS-6&quot;&gt;&lt;/a&gt;LFS-6&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-5</title>
    <link href="https://unit-serow.github.io/2020/02/26/LFS-5/"/>
    <id>https://unit-serow.github.io/2020/02/26/LFS-5/</id>
    <published>2020-02-25T20:21:50.000Z</published>
    <updated>2020-02-28T03:11:00.406Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="LFS-5"><a href="#LFS-5" class="headerlink" title="LFS-5"></a>LFS-5</h2><ul><li>应用笔记以及经验总结</li></ul><hr><h3 id="首要逻辑说明"><a href="#首要逻辑说明" class="headerlink" title="首要逻辑说明:"></a>首要逻辑说明:</h3><ul><li>编译工具就是汇编工具与语言编译器(Binutils/GCC)</li><li>汇编工具，语言编译器，对应语言标准库被合称为工具链(Binutils/GCC/Glibc)<blockquote><p>工具链的配置即为以上三个工具的配置<br>因为让编译工具生成可执行文件需要对应标准库，所以这里将标准库算到工具链内(严格来说标准库并不是工具)</p></blockquote></li><li>辅助命令</li><li>文件(目录)映射</li></ul><hr><ol><li>创建目标系统目录</li><li>创建临时系统目录</li><li>建立预工具链</li><li>建立临时系统</li><li>建立目标工具链</li><li>建立目标系统</li><li>收尾工作</li></ol><hr><p><strong>作用解释:</strong></p><ul><li><code>CC=&quot;gcc -B/usr/bin&quot;</code></li><li>在第一遍编译GCC中是调用/tools内的gcc<blockquote><p>调用GCC作为编译器，指定GCC运行环境为/usr/bin</p></blockquote></li><li>在第一遍编译Binutils时是调用/tools内的GCC，接下来指定链接器指向</li><li>在第二遍编译Binutils中是在调用host中的GCC</li></ul><hr><p><strong>注意事项(相关内容):</strong></p><ul><li>设置工具链的时候必须保证工具处于可用状态</li><li>有些程序和工具可能需要编译及安装两遍以上</li><li>在目标机器内Glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误<blockquote><p>还有一些能引起错误的LFS手册上有所提及<br>类似于超时这种 错误有时候很难避免<br>只能跳过去或进行多次编译以及安装</p></blockquote></li><li>跳过对于目标机器内Glibc及其工具链的测试</li><li>有一两个Error就忽略吧</li><li>测试代码并统计<blockquote><p><code>$make check</code><br>测试统计有可能会出现个别失败<br>有时会完全成功</p></blockquote></li><li>参考资料均来自十年前(最少)</li><li>参考资料本身没什么太大问题</li></ul><hr><h3 id="问题一览"><a href="#问题一览" class="headerlink" title="问题一览"></a>问题一览</h3><ul><li>待解决问题<blockquote><p>v6.2 无内核头部配置文件<br>v6.3 第二次编译C函数库(Glibc)时出错<br>v6.3 目标工具链-Binutils编译出现错误，没有通过测试，并且已无视<br>v6.3 目标工具链-GCC编译出现几处错误，但不影响使用并已成功通过安装测试与应用测试<br>v6.3 测试Automake-1.10工具源代码编译文件时出现三个错误，但无伤大雅<br>v6.3 Linux内核编译出现问题(kernel version:2.6.22.5)<br>v6.3 找不到GCC</p></blockquote></li></ul><hr><ul><li>目标机器内的Glibc标准函数库测试错误问题已解决</li><li>目标机器内的GCC编译器问题已解决</li><li>目标工具链内的GCC安装与应用测试成功</li><li>编译Coreutils-6.9出现两处Error<blockquote><p>动态链接库测试中编译帮助文件<code>man目录</code>失效<br><code>BEGIN failed--compilation aborted at ./help2man line 28</code><br>离开<code>*/man</code>目录<br>已经无视，并且进行代码测试后也是这个问题</p></blockquote></li><li>Procps-3.2.7(Top)<blockquote><p><code>collect2: ld returned 1 exit status</code><br>make停止<br>安装失败</p></blockquote></li><li>Perl-5.8.8<blockquote><p>动态链接库测试中编译出现两条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Readline-5.2<blockquote><p>动态链接库测试中编译出现一条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Automake-1.10<blockquote><p>动态链接库测试中编译出现三条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Psmisc-22.5<blockquote><p>cannot find tinfo，ncurses or termcap libraries<br>无法找到无法找到tinfo、ncurses或termcap库<br>编译失败</p></blockquote></li><li>Udev-113<blockquote><p>make test测试与安装无错误</p></blockquote></li><li>到达第七章与第八章之间的退出chroot出现问题<blockquote><p>根据LFS官方手册配置，进入新的系统环境下GCC丢失<br>未解决</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>开源中国<a href="https://www.oschina.net/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.oschina.net/</code></p></blockquote></li></ul><hr><ul><li>LFS注册<a href="http://www.linuxfromscratch.org/cgi-bin/lfscounter.php" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/cgi-bin/lfscounter.php</code></p></blockquote></li></ul><hr><ul><li>LFS-6.3版本<a href="http://www.linuxfromscratch.org/lfs/view/6.3/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/</code></p></blockquote></li></ul><hr><ul><li>LFS-6.3内核编译(kernel version:2.6.22.5)<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html</code></p></blockquote></li></ul><hr><ul><li>冲天飞豹Blog(已经挂了)<blockquote><p><code>http://youbest.cublog.cn/</code></p></blockquote></li></ul><hr><ul><li>LFS-PDF<a href="https://pan.baidu.com/s/1nZARmQlO63fh5BVGug4gPg" target="_blank" rel="noopener">跳转</a><blockquote><p>链接:<code>https://pan.baidu.com/s/1nZARmQlO63fh5BVGug4gPg</code><br>提取码:414z</p></blockquote></li></ul><hr><h3 id="重要工具与程序简述-小部分-最新版本"><a href="#重要工具与程序简述-小部分-最新版本" class="headerlink" title="重要工具与程序简述(小部分/最新版本):"></a>重要工具与程序简述(小部分/最新版本):</h3><ul><li><p>Glibc (2.30) - 16,189 KB:</p><blockquote><p>主页: <code>http://www.gnu.org/software/libc/</code><br>下载: <code>http://ftp.gnu.org/gnu/glibc/glibc-2.30.tar.xz</code><br>MD5 校验和: <code>2b1dbdf27b28620752956c061d62f60c</code></p></blockquote></li><li><p>GCC (9.2.0) - 68,953 KB:</p><blockquote><p>主页: <code>https://gcc.gnu.org/</code><br>下载: <code>http://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.xz</code><br>MD5 校验和: <code>3818ad8600447f05349098232c2ddc78</code></p></blockquote></li><li><p>Linux (5.2.8) - 104,555 KB:</p><blockquote><p>主页: <code>https://www.kernel.org/</code><br>下载: <code>https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.2.8.tar.xz</code><br>MD5 校验和: <code>602dd0ecb8646e539fefb2beb6eb6fe0</code></p></blockquote></li><li><p>Binutils (2.32) - 20,288 KB:</p><blockquote><p>主页: <code>http://www.gnu.org/software/binutils/</code><br>下载: <code>http://ftp.gnu.org/gnu/binutils/binutils-2.32.tar.xz</code><br>MD5 校验和: <code>0d174cdaf85721c5723bf52355be41e6</code></p></blockquote></li><li><p>GRUB (2.04) - 6,245 KB:</p><blockquote><p>主页: <code>http://www.gnu.org/software/grub/</code><br>下载: <code>https://ftp.gnu.org/gnu/grub/grub-2.04.tar.xz</code><br>MD5 校验和: <code>5aaca6713b47ca2456d8324a58755ac7</code></p></blockquote></li><li><p>LFS-Bootscripts (20190524) - 32 KB:</p><blockquote><p>下载: <code>http://www.linuxfromscratch.org/lfs/downloads/9.0/lfs-bootscripts-20190524.tar.xz</code><br>MD5 校验和: <code>c91b11e366649c9cec60c2552820fed5</code></p></blockquote></li></ul><hr><ul><li><p>Autoconf (2.69) - 1,186 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/autoconf/" target="_blank" rel="noopener">http://www.gnu.org/software/autoconf/</a><br>下载： <a href="http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.xz</a><br>MD5 校验和： 50f97f4159805e374639a73e2636f22e</p></blockquote></li><li><p>Automake (1.16.1) - 1,499 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/automake/" target="_blank" rel="noopener">http://www.gnu.org/software/automake/</a><br>下载： <a href="http://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.xz</a><br>MD5 校验和： 53f38e7591fa57c3d2cee682be668e5b</p></blockquote></li><li><p>Bash (5.0) - 9,898 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/bash/" target="_blank" rel="noopener">http://www.gnu.org/software/bash/</a><br>下载： <a href="http://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz</a><br>MD5 校验和： 2b44b47b905be16f45709648f671820b</p></blockquote></li><li><p>File (5.37) - 867 KB:</p><blockquote><p>主页： <a href="https://www.darwinsys.com/file/" target="_blank" rel="noopener">https://www.darwinsys.com/file/</a><br>下载： <a href="ftp://ftp.astron.com/pub/file/file-5.37.tar.gz" target="_blank" rel="noopener">ftp://ftp.astron.com/pub/file/file-5.37.tar.gz</a><br>MD5 校验和： 80c29aca745466c6c24d11f059329075</p></blockquote></li><li><p>Libtool (2.4.6) - 951 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/libtool/" target="_blank" rel="noopener">http://www.gnu.org/software/libtool/</a><br>下载： <a href="http://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.xz</a><br>MD5 校验和： 1bfb9b923f2c1339b4d2ce1807064aa5</p></blockquote></li><li><p>M4 (1.4.18) - 1,180 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/m4/" target="_blank" rel="noopener">http://www.gnu.org/software/m4/</a><br>下载： <a href="http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.xz</a><br>MD5 校验和： 730bb15d96fffe47e148d1e09235af82</p></blockquote></li><li><p>Make (4.2.1) - 1,932 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/make/" target="_blank" rel="noopener">http://www.gnu.org/software/make/</a><br>下载： <a href="http://ftp.gnu.org/gnu/make/make-4.2.1.tar.gz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/make/make-4.2.1.tar.gz</a><br>MD5 校验和： 7d0dcb6c474b258aab4d54098f2cf5a7</p></blockquote></li><li><p>OpenSSL (1.1.1c) - 8,657 KB:</p><blockquote><p>主页： <a href="https://www.openssl.org/" target="_blank" rel="noopener">https://www.openssl.org/</a><br>下载： <a href="https://www.openssl.org/source/openssl-1.1.1c.tar.gz" target="_blank" rel="noopener">https://www.openssl.org/source/openssl-1.1.1c.tar.gz</a><br>MD5 校验和： 15e21da6efe8aa0e0768ffd8cd37a5f6</p></blockquote></li></ul><hr><ul><li><p>Gawk (5.0.1) - 3,063 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/gawk/" target="_blank" rel="noopener">http://www.gnu.org/software/gawk/</a><br>下载： <a href="http://ftp.gnu.org/gnu/gawk/gawk-5.0.1.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/gawk/gawk-5.0.1.tar.xz</a><br>MD5 校验和： f9db3f6715207c6f13719713abc9c707</p></blockquote></li><li><p>Util-linux (2.34) - 4,859 KB:</p><blockquote><p>主页： <a href="http://freecode.com/projects/util-linux" target="_blank" rel="noopener">http://freecode.com/projects/util-linux</a><br>下载： <a href="https://www.kernel.org/pub/linux/utils/util-linux/v2.34/util-linux-2.34.tar.xz" target="_blank" rel="noopener">https://www.kernel.org/pub/linux/utils/util-linux/v2.34/util-linux-2.34.tar.xz</a><br>MD5 校验和： a78cbeaed9c39094b96a48ba8f891d50</p></blockquote></li><li><p>Zlib (1.2.11) - 457 KB:</p><blockquote><p>主页： <a href="https://www.zlib.net/" target="_blank" rel="noopener">https://www.zlib.net/</a><br>下载： <a href="https://zlib.net/zlib-1.2.11.tar.xz" target="_blank" rel="noopener">https://zlib.net/zlib-1.2.11.tar.xz</a><br>MD5 校验和： 85adef240c5f370b308da8c938951a68</p></blockquote></li></ul><hr><p><strong>补丁:</strong></p><ul><li><p>Coreutils 国际化修复补丁 - 168 KB:</p><blockquote><p>下载： <a href="http://www.linuxfromscratch.org/patches/lfs/9.0/coreutils-8.31-i18n-1.patch" target="_blank" rel="noopener">http://www.linuxfromscratch.org/patches/lfs/9.0/coreutils-8.31-i18n-1.patch</a><br>MD5 校验和： a9404fb575dfd5514f3c8f4120f9ca7d</p></blockquote></li><li><p>Glibc FHS 补丁 - 2.8 KB:</p><blockquote><p>下载： <a href="http://www.linuxfromscratch.org/patches/lfs/9.0/glibc-2.30-fhs-1.patch" target="_blank" rel="noopener">http://www.linuxfromscratch.org/patches/lfs/9.0/glibc-2.30-fhs-1.patch</a><br>MD5 校验和： 9a5997c3452909b1769918c759eff8a2</p></blockquote></li></ul><hr><h3 id="已解决问题一览"><a href="#已解决问题一览" class="headerlink" title="已解决问题一览"></a>已解决问题一览</h3><ul><li>如果实在找不到GCC且有难以解决的问题，可以先利用已有的临时主机中的/tools目录来对目标主机进行错误与空白修补</li><li>各参数作用这里不做过多赘述，可参考LFS官方手册</li></ul><hr><ul><li>参考自LFS-v6.3版本第6.4-Entering the Chroot Environment至6.59-Stripping Again章节</li><li>第七章末尾找不到GCC的问题已解决<blockquote><p>需要先完全配置才能去抛离上一级系统目录环境(此时需要脱离的是临时系统)<br>在第六章开头理解出问题了<br>在查询了FSL官方的英文文档之后<br>发现退出chroot的代码只需要执行一遍<br>chroot及附带配置的作用是抛离前(是属于目标系统的)的配置<br>使用Strip对文件(二进制压缩包)进行清理</p></blockquote></li></ul><p><strong>可参考以下指令:</strong></p><ol><li><p>退出chroot环境:</p><blockquote><p><code>$logout</code></p></blockquote></li><li><p>为Strip而进入chroot环境:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chroot <span class="variable">$LFS</span> /tools/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM=$TERM PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span> \</span><br><span class="line">    /tools/bin/bash --login</span><br></pre></td></tr></table></figure></li><li><p>Strip:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tools/bin/find /&#123;,usr/&#125;&#123;bin,<span class="class"><span class="keyword">lib</span>,<span class="title">sbin</span>&#125; -<span class="title">type</span> <span class="title">f</span> \</span></span><br><span class="line">  -exec /tools/bin/strip --strip-debug <span class="string">'&#123;&#125;'</span> <span class="string">';'</span></span><br></pre></td></tr></table></figure></li></ol><hr><ul><li>摘选自LFS-v6.3/EN-CN(翻译)<blockquote><p>A large number of files will be reported as having their file format not recognized.<br>These warnings can be safely ignored.<br>These warnings indicate that those files are scripts instead of binaries.</p></blockquote></li><li>翻译内容:<blockquote><p>大量文件将被报告为文件格式无法识别<br>可以安全地忽略这些警告<br>这些警告表明这些文件是脚本而不是二进制文件</p></blockquote></li></ul><hr><p><strong>补充内容:</strong></p><ul><li><p>摘选自FSL官方文档:</p><blockquote><p>From now on, when reentering the chroot environment after exiting, use the following modified chroot command:</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chroot <span class="string">"$LFS"</span> /usr/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM="$TERM" PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span> \</span><br><span class="line">    /bin/bash --login</span><br></pre></td></tr></table></figure><blockquote><p>The reason for this is that the programs in /tools are no longer needed. Since they are no longer needed you can delete the /tools directory if so desired.</p></blockquote></li><li><p>翻译内容:</p><blockquote><p>从现在开始，退出后重新进入chroot环境时，请使用以下修改后的chroot命令：<br>这样做的原因是/tools不再需要其中的程序<br>因为不再需要它们，所以可以根据需要来决定是否去删除/tools目录</p></blockquote></li></ul><hr><p><strong>补充内容:</strong></p><ul><li>6.4章节中描述的带有临时机器中的/tools文件夹的目标机器<blockquote><p>It is time to enter the chroot environment to begin building and installing the final LFS system. As user root, run the following command to enter the realm that is, at the moment, populated with only the temporary tools:</p></blockquote></li><li>翻译内容:<blockquote><p>现在是时候进入chroot环境开始构建和安装最终的LFS系统了<br>以user root身份，运行以下命令以输入当前仅由临时工具填充的领域:</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chroot <span class="string">"$LFS"</span> /tools/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM="$TERM" PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/tools/bin</span> \</span><br><span class="line">    /tools/bin/bash --login +h</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>重点内容-1</strong></p><ul><li>6.2.章节 准备虚拟内核文件系统</li><li>6.22章节 挂载和激活/dev</li></ul><hr><p><strong>解决思路:</strong></p><ul><li>把/tools的内容转到<code>/usr</code>内<blockquote><p>为什么<code>cc/gcc</code>工具会不生效<br><code>GCC/Binutils/Glibc/Linux-2.6.22.5</code>已成功编译并安装入目标主机的<code>/usr</code>或<code>/usr/bin</code>文件目录内<br>每次的重新开始都是对经验的不断累积</p></blockquote></li><li>孙海勇在LinuxSir上的LFS教程-26-27页与29页</li><li><code>LFS 7.4 chapter 6.7: make: gcc: Command not found</code><a href="https://unix.stackexchange.com/questions/110184/lfs-7-4-chapter-6-7-make-gcc-command-not-found" target="_blank" rel="noopener">跳转</a><blockquote><p>LFS 7.4-第6.7章:make: gcc: 找不到命令<br><code>https://unix.stackexchange.com/questions/110184/lfs-7-4-chapter-6-7-make-gcc-command-not-found</code></p></blockquote></li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>6.4 Entering the Chroot Environment<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/chroot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/chroot.html</code></p></blockquote></li><li><p>6.59. Stripping Again<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/strippingagain.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/strippingagain.html</code></p></blockquote></li><li><p>6.60. Cleaning Up<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/revisedchroot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/revisedchroot.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-5&quot;&gt;&lt;a href=&quot;#LFS-5&quot; class=&quot;headerlink&quot; title=&quot;LFS-5&quot;&gt;&lt;/a&gt;LFS-5&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU Privacy Guard/GPG-1</title>
    <link href="https://unit-serow.github.io/2020/02/24/GPG-1/"/>
    <id>https://unit-serow.github.io/2020/02/24/GPG-1/</id>
    <published>2020-02-24T10:17:18.000Z</published>
    <updated>2020-02-24T10:18:52.880Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="GNU-Privacy-Guard-GPG-1"><a href="#GNU-Privacy-Guard-GPG-1" class="headerlink" title="GNU Privacy Guard/GPG-1"></a>GNU Privacy Guard/GPG-1</h2><h3 id="简要概述与参考资料整理"><a href="#简要概述与参考资料整理" class="headerlink" title="简要概述与参考资料整理"></a>简要概述与参考资料整理</h3><ul><li><p>数据完整性(Data integrity)</p></li><li><p>使用工具:</p></li><li><p>GPG(GNU Privacy Guard)</p><blockquote><p>Linux GPG<br>GNU PG</p></blockquote></li></ul><hr><h3 id="命令简述"><a href="#命令简述" class="headerlink" title="命令简述:"></a>命令简述:</h3><ul><li><p>生成密钥</p><blockquote><p><code>$gpg --gen-key</code><br>安装提示对密钥进行配置</p></blockquote></li><li><p>列出密钥</p><blockquote><p><code>$gpg --list-keys</code></p></blockquote></li><li><p>删除密钥</p><blockquote><p><code>gpg --delete-key [用户ID]</code></p></blockquote></li><li><p>输入密钥</p><blockquote><p><code>gpg --import [密钥文件]</code></p></blockquote></li><li><p>加密文件</p><blockquote><p><code>gpg --recipient [用户ID] --output [file name] --encrypt [file name]</code></p></blockquote></li><li><p>解密并输出内容</p><blockquote><p><code>gpg [file name]</code></p></blockquote></li><li><p>文件签名(二进制存储)</p><blockquote><p><code>gpg --sign [file name]</code></p></blockquote></li><li><p>文件签名(ASCII码存储)</p><blockquote><p><code>gpg --clearsign [file name]</code></p></blockquote></li><li><p>生成单独的签名文件(二进制存储)</p><blockquote><p><code>gpg --detach-sign [file name]</code></p></blockquote></li><li><p>生成单独的签名文件(ASCII码存储)</p><blockquote><p><code>gpg --armor --detach-sign [file name]</code></p></blockquote></li><li><p>验证签名</p><blockquote><p><code>gpg --verify [file name].[asc] [file name]</code></p></blockquote></li><li><p>等等</p></li></ul><hr><p><strong>其它说明:</strong></p><ul><li>方括号为可选参数</li><li>这里的数据完整性以数据签名实现</li><li>压缩所选文件或目录并进行哈希加密实现数字签名</li><li>不进行压缩进行数字加密</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>GPG</li><li>PGP</li><li>GPG2</li><li>RSA加密算法(对称加密算法)</li><li>数据校检</li><li>数字签名</li><li>数据完整性</li><li>软件包签名</li><li>压缩文件签名</li><li>数据库数据完整性</li><li>文件目录数据完整性</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><strong>以下内容参考自中文维基与百度百科:</strong></p><p><strong>中文维基</strong></p><ul><li><p>数据完整性<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7</code></p></blockquote></li><li><p>数字签名<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0</code></p></blockquote></li></ul><p><strong>百度百科</strong></p><ul><li><p>数据完整性<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7</code></p></blockquote></li><li><p>数据校检<a href="https://baike.so.com/doc/741565-784957.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.so.com/doc/741565-784957.html</code></p></blockquote></li></ul><hr><p><strong>参考文献:</strong></p><ul><li><p>Linux下使用GPG加密解密的说明及示例<a href="https://www.linuxidc.com/Linux/2015-02/113015.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2015-02/113015.htm</code></p></blockquote></li><li><p>如何在Linux下使用GPG(GnuPG)加密及解密<a href="https://jingyan.baidu.com/album/3d69c5513244a7f0ce02d751.html?picindex=1" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://jingyan.baidu.com/album/3d69c5513244a7f0ce02d751.html?picindex=1</code></p></blockquote></li><li><p>GPG简要介绍<a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ruanyifeng.com/blog/2013/07/gpg.html</code></p></blockquote></li><li><p>Gnu隐私卫士(GnuPG)袖珍HOWTO(中文版)<a href="https://www.gnupg.org/howtos/zh/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnupg.org/howtos/zh/index.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-Privacy-Guard-GPG-1&quot;&gt;&lt;a href=&quot;#GNU-Privacy-Guard-GPG-1&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Password" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Password/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Linux Containers/LXC-1</title>
    <link href="https://unit-serow.github.io/2020/02/24/LXC-1/"/>
    <id>https://unit-serow.github.io/2020/02/24/LXC-1/</id>
    <published>2020-02-24T08:32:34.000Z</published>
    <updated>2020-02-24T08:34:54.444Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="Linux-Containers-LXC-1"><a href="#Linux-Containers-LXC-1" class="headerlink" title="Linux Containers/LXC-1"></a>Linux Containers/LXC-1</h2><p><strong>相关内容:</strong></p><ul><li>LXC(Linux Containers)</li><li>linux内核映射文件</li><li>文件映射</li></ul><hr><h3 id="LXC-Linux-Containers"><a href="#LXC-Linux-Containers" class="headerlink" title="LXC(Linux Containers)"></a>LXC(Linux Containers)</h3><p><strong>概述:</strong></p><ul><li>其名称来自Linux软件容器(Linux Containers)的缩写</li><li>是一种操作系统层虚拟化（Operating system–level virtualization)技术</li><li>作用是为Linux内核容器功能的一个用户空间接口</li></ul><hr><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><ol><li><strong>实现方法:</strong></li></ol><ul><li>在Linux内核中，提供了cgroups功能，来达成资源的区隔化<blockquote><p>它同时也提供了名称空间区隔化的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括行程树，网络，用户id，以及挂载的文件系统<br>但是cgroups并不一定需要引导任何虚拟机<br>LXC利用cgroups与名称空间的功能，提供应用软件一个独立的操作系统环境<br>LXC不需要Hypervisor这个软件层，软件容器(Container)本身极为轻量化，提升了创建虚拟机的速度<br>软件Docker被用来管理LXC的环境</p></blockquote></li></ul><hr><ul><li>执行流程简述:<blockquote><p>它将应用软件系统打包成一个软件容器(Container)，内含应用软件本身的代码，以及所需要的操作系统核心和库<br>透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境<br>从而使得Linux用户可以容易的创建和管理系统或应用容器</p></blockquote></li></ul><hr><ol start="2"><li><strong>具体实现:</strong></li></ol><ul><li><p>当前的LXC使用下列内核功能来控制进程:</p><blockquote><p>内核名字空间(进程间通信，uts，mount，pid，network和user)<br>AppArmor和SELinux配置<br>Seccomp策略<br>chroot(使用<code>pivot_root</code>)<br>Kernel Capibilities<br>控制组(cgroups)</p></blockquote></li><li><p>因此，LXC通常被认为介于“加强版”的chroot和完全成熟的虚拟机之间的技术。LXC的目标是创建一个尽可能与标准安装的Linux相同但又不需要分离内核的环境</p></li></ul><hr><ol start="3"><li><strong>具体使用:</strong></li></ol><ul><li>Proxmox VE:它直到4.0版才使用LXC技术，在此之前的版本都是使用OpenVZ技术</li><li>Docker:它在0.9版之前都是使用LXC技术，但在0.9版之后，已不再是唯一且默认的运行环境</li></ul><hr><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p><strong>概述:</strong></p><ul><li>内存映射文件(Memory-mapped file)，或称”文件映射”与”映射文件”</li><li>是一段虚内存逐字节对应于一个文件或类文件的资源，使得应用程序处理映射部分如同访问主内存</li></ul><hr><p><strong>内存映射文件分为以下两种:</strong></p><ul><li>Persisted<blockquote><p>Persisted文件与硬盘文件相关联，当关闭内存映射时，数据被写入对应的硬盘文件中<br>适合于很大的文件</p></blockquote></li><li>Non-persisted<blockquote><p>Non-persisted文件并不关联于硬盘文件。当关闭内存映射文件，所有数据被抛弃<br>适用于创建进程间通信的共享内存</p></blockquote></li></ul><p><strong>作用:</strong></p><ol><li>最常见用途是绝大多数操作系统(包括Microsoft Windows与Unix-like系统)用于加载进程</li><li>另一个用途是多个进程的共享内存</li><li>第三个用途是对大文件的读写</li></ol><p><strong>优势:</strong></p><ol><li>主要用处是增加I/O性能，特别是用于大文件</li><li>对于小文件，内存映射文件会导致碎片空间浪费，因为内存映射总是要对齐页边界，这起码是4 KiB<blockquote><p>因而一个5 KiB文件将会映射占用8 KiB内存，浪费了3 KiB内存</p></blockquote></li><li>访问内存映射文件比直接文件读写要快几个数量级</li></ol><p><strong>缺点(弊端):</strong></p><ol><li>内存映射文件需要在进程的占用一块很大的连续逻辑地址空间</li><li>对于Intel的IA-32的4 GiB逻辑地址空间，可用的连续地址空间远远小于<code>2---3GiB</code><blockquote><p>相关联的文件的I/O错误(如可拔出驱动器或光驱被弹出，磁盘满时写操作等)的内存映射文件会向应用程序报告SIGSEGV/SIGBUS信号(POSIX环境)<br>或<code>EXECUTE_IN_PAGE_ERROR</code>结构化异常(Windows环境)<br>但通常的内存操作是无需考虑这些异常的</p></blockquote></li><li>有内存管理单元(MMU)才支持内存映射文件</li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>官方网站<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linuxcontainers.org/</code></p></blockquote></li><li><p>LXC官方文档<a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linuxcontainers.org/lxc/introduction/</code></p></blockquote></li></ul><hr><p><strong>以下内容参考自中文维基:</strong></p><ul><li><p>虚拟内存<a href="https://zh.wikipedia.org/wiki/Category:%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98</code></p></blockquote></li><li><p>磁盘文件系统<a href="https://zh.wikipedia.org/wiki/Category:%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F</code></p></blockquote></li><li><p>Linux容器化<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%AE%B9%E5%99%A8%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%AE%B9%E5%99%A8%E5%8C%96</code></p></blockquote></li><li><p>Linux内核功能<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD</code></p></blockquote></li><li><p>操作系统层虚拟化<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>DevOps<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/DevOps</code></p></blockquote></li><li><p>虚拟化技术(Virtualization)<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Linux-Containers-LXC-1&quot;&gt;&lt;a href=&quot;#Linux-Containers-LXC-1&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Debian-3</title>
    <link href="https://unit-serow.github.io/2020/02/23/Debian-3/"/>
    <id>https://unit-serow.github.io/2020/02/23/Debian-3/</id>
    <published>2020-02-23T10:57:21.000Z</published>
    <updated>2020-02-23T15:48:44.028Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="Debian-GNU-Linux-3"><a href="#Debian-GNU-Linux-3" class="headerlink" title="Debian GNU/Linux-3"></a>Debian GNU/Linux-3</h2><h3 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h3><hr><ul><li>本篇文章会不断进行补充</li></ul><p><strong>常见的分区有以下三个:</strong></p><ul><li>fdisk</li><li>cfdisk</li><li>partman</li></ul><hr><p><strong>cfdisk用法</strong></p><ul><li>简易分区管理工具</li><li>这里的磁盘类型是<code>SCSI</code>，<code>IDE</code>则为<code>hda</code>，<code>SATA</code>与<code>NVMe</code>这里不进行过多赘述</li><li>具体可以查看<code>man手册</code>与<code>help帮助</code>指令</li><li>基本流程:<code>创建分区-&gt;配置文件系统根目录与其它选项(作用/用途)-&gt;格式化文件系统-&gt;文件系统挂载并使用</code></li></ul><p><strong>创建分区:</strong></p><ol><li>键入指令<code>$cfdisk /dev/sda</code></li><li>选择任意分区(最好是空白分区，已有分区需要先进行删除)</li><li><code>选择[new选项]-&gt;[primary选项]-&gt;[指定容量数值(以字节为单位)]</code></li><li><code>选择[write选择]-&gt;键入[yes保存修改]-&gt;选择[quit选项退出工具]</code></li></ol><ul><li>参数说明:</li><li>primary 主分区</li><li>extended 扩展分区</li></ul><hr><p><strong>交换分区操作:</strong></p><ul><li><p>格式化交换分区指令(这里将sda1格式化为交换分区)</p><blockquote><p><code>$mkswap /dev/sda1</code></p></blockquote></li><li><p>使用交换分区</p><blockquote><p><code>$swapon [交换分区设备名/交换文件]</code><br><code>$swapon /dev/sda</code></p></blockquote></li><li><p>查看内存信息来检查是否已启用交换分区</p><blockquote><p><code>$free</code></p></blockquote></li><li><p>取消交换分区</p><blockquote><p><code>$swapoff /dev/sda1</code></p></blockquote></li></ul><hr><p><strong>其它概念(交换分区):</strong></p><p><strong>swap</strong></p><ul><li>swap的部分内容就是开启了多少交换空间，其空间大小是开启使用的交换分区或者文件大小的总和</li><li>交换分区可以同时存在多个并可以同时使用</li><li>同时也可以使用文件格式的交换空间</li></ul><p><strong>交换空间</strong></p><ul><li>一般主机系统里会有两个磁盘分区</li><li>一个是交换空间，另一个则是其它的任何分区</li><li>第一个分区计划为用于交换空间</li><li>交换空间又可被称为交换内存空间</li><li>使用这种文件系统的分区被称为交换分区，用于进行系统过程中的内存交换</li></ul><hr><p><strong>格式化分区操作:</strong></p><ul><li>将磁盘分区格式化为指定的文件系统</li><li>有以下几种语法格式:<blockquote><p><code>mkfs.ext2/ext3/ext4/xfs等等 /dev/sdaxxx/(指定磁盘)</code><br><code>mkfs.文件系统 [分区或设备名]</code><br><code>mkfs [options] [指定磁盘文件格式] /dev/sdaxxx/(指定磁盘)</code><br>参数<code>-v</code>，<code>-t</code>等等<br>例如:<code>mkfs -t ext4 /dev/sda3</code></p></blockquote></li></ul><hr><p><strong>磁盘(光盘或设备)挂载:</strong></p><ul><li><p>基本语法格式:</p><blockquote><p><code>mount -o loop [/dev/sdaxxx(指定磁盘)] [/mnt(被挂载目录)]</code><br><code>mount -t ext4(指定磁盘文件系统) /dev/sda4 /mnt</code></p></blockquote></li><li><p>卸载光盘</p><blockquote><p><code>umount /mnt</code><br><code>umount /dev/sda2</code></p></blockquote></li><li><p>mount查看磁盘文件系统挂载情况</p><blockquote><p>参数<code>-h</code>返回容量单位</p></blockquote></li><li><p>mount输出参数说明:</p><blockquote><p>ro表示只读<br>rw为可读可写</p></blockquote></li></ul><hr><p><strong>查看磁盘文件系统挂载情况:</strong></p><blockquote><p><code>$df</code></p></blockquote><hr><p><strong>磁盘文件系统修复:</strong></p><ul><li><p>fsck</p><blockquote><p>fsck(file system consistency check)</p></blockquote></li><li><p>是Unix和类Unix系统上用于检查文件系统完整性的工具</p></li><li><p>基本命令格式:</p><blockquote><p><code>fsck -y /dev/sda1(指定磁盘)</code></p></blockquote></li><li><p>fuser</p><blockquote><p><code>fuser -m /boot</code> 输出选项模块对应线程的pid<br><code>fuser -mk /boot</code> kill掉所选进程的pid</p></blockquote></li></ul><hr><p><strong>其它概念:</strong></p><ul><li>hda一般是指IDE接口的硬盘，hda一般指第一块硬盘，类似的有hdb,hdc等</li><li>sda一般是指SATA接口的硬盘，sda一般指第一块硬盘，类似的有sdb,sdc等</li><li>现在的内核都会把硬盘，移动硬盘，U盘之类的识别为sdX的形式</li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>Debian 分区程序<a href="https://www.debian.org/releases/wheezy/mips/apcs05.html.zh-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.debian.org/releases/wheezy/mips/apcs05.html.zh-cn</code></p></blockquote></li><li><p>从零开始的Linux From Scratch<a href="http://www.linuxfromscratch.org/lfs/downloads/9.1-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/9.1-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html</code></p></blockquote></li></ul><hr><p><strong>问题解决方案:</strong></p><p><strong>1.找不到fdisk指令</strong></p><ul><li><p>查看路径:</p><blockquote><p><code>whereis cfdisk</code></p></blockquote></li><li><p>输出现有PATH变量路径</p><blockquote><p><code>echo $PATH</code></p></blockquote></li><li><p>配置软链接</p><blockquote><p><code>ln -sv [软件所在路径] [PATH所指定路径]</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Debian-GNU-Linux-3&quot;&gt;&lt;a href=&quot;#Debian-GNU-Linux-3&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Debian GNU/Linux-2</title>
    <link href="https://unit-serow.github.io/2020/02/23/Debian-2/"/>
    <id>https://unit-serow.github.io/2020/02/23/Debian-2/</id>
    <published>2020-02-22T17:36:50.000Z</published>
    <updated>2020-02-23T10:59:35.171Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="Debian-GNU-Linux-2"><a href="#Debian-GNU-Linux-2" class="headerlink" title="Debian GNU/Linux-2"></a>Debian GNU/Linux-2</h2><ul><li>网络配置问题统一解决方案</li></ul><h3 id="Debian网络配置基本命令"><a href="#Debian网络配置基本命令" class="headerlink" title="Debian网络配置基本命令"></a>Debian网络配置基本命令</h3><ul><li><p>输出网卡与网络配置情况</p><blockquote><p><code>ip -a/ifconfig</code></p></blockquote></li><li><p>查看所有已有网卡</p><blockquote><p><code>networkctl</code></p></blockquote></li><li><p>网卡配置目录</p><blockquote><p>/etc/network/interfaces</p></blockquote></li></ul><p><strong>网卡配置说明:</strong></p><ul><li><p>配置静态IP地址</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto eth0 #开机自动激活</span><br><span class="line">iface eth0 inte static #静态IP</span><br><span class="line">address<span class="built_in"> IP </span>#本机IP</span><br><span class="line">netmask 255.255.255.0 #子网掩码</span><br><span class="line"><span class="comment"># network IP</span></span><br><span class="line"><span class="comment"># broadcast IP</span></span><br><span class="line">gateway<span class="built_in"> IP</span>#路由网关</span><br></pre></td></tr></table></figure></li><li><p>DHCP自动获取(动态IP地址)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto</span> <span class="string">eth0</span></span><br><span class="line"><span class="attr">iface</span> <span class="string">eth0 inet dhcp</span></span><br></pre></td></tr></table></figure></li><li><p>配置好之后保存配置，重启网卡(多种方式)</p><blockquote><p><code>service networking restart</code> #service工具<br><code>systemctl restart network</code> #systemctl工具<br><code>/etc/init.d/network-manager restart</code><br><code>/etc/init.d/networking restart</code></p></blockquote></li><li><p>重启指定网卡</p><blockquote><p><code>ifdown eth0</code><br><code>ifup eth0</code></p></blockquote></li><li><p>配置DNS</p><blockquote><p><code>vi /etc/resolv.conf</code><br><code>nameserver 0.0.0.0</code></p></blockquote></li></ul><hr><h3 id="名称与各参数简述与解释"><a href="#名称与各参数简述与解释" class="headerlink" title="名称与各参数简述与解释:"></a>名称与各参数简述与解释:</h3><p><strong>eth(ethernet)</strong></p><blockquote><p>有线网卡<br>物理网卡<br>如:eth0，eth1，eth2…则代表网卡一，网卡二，网卡三…<br>还可称为en</p></blockquote><hr><ul><li>eth各接口说明<blockquote><p>eth0=lan接口<br>eth1=wan接口<br>br-lan=lan网桥<br>br-lan 虚拟设备，用于LAN口设备桥接，可以用<code>brctl show</code>查看使用情况</p></blockquote></li></ul><hr><ul><li>en(ethernet)标识说明:<blockquote><p>o:主板板载网卡，集成是的设备索引号<br>p:独立网卡，PCI网卡<br>s:热插拔网卡，USB之类的扩展槽索引号<br>nnn(数字):MAC地址+主板信息计算得出唯一序列</p></blockquote></li></ul><hr><p><strong>lo</strong></p><blockquote><p>代表localhost，即127.0.0.1<br>虚拟设备，自身的回环网设备</p></blockquote><hr><p><strong>ens</strong></p><blockquote><p>ens33为自动备援模式，名称定为ens33<br>eno1表示主板BIOS内置的网卡<br>ens1表示主板BIOS中内置的PCI-E网卡<br>enp2s0为PCI-E独立网卡<br>eth0:如果没有使用以上任何一个，则将返回默认的网卡名</p></blockquote><hr><ul><li>wlan<blockquote><p>无线网卡<br>wlan0=无限端口</p></blockquote></li></ul><hr><p><strong>网络接口的传统命名方式(可预测命名方案)</strong><br><strong>传统命名:</strong></p><ul><li>以太网:ethX,[0,oo)<blockquote><p>例如eth0，eth1…</p></blockquote></li><li>PPP网络:pppX, [0,…]<blockquote><p>例如，ppp0, ppp1, …</p></blockquote></li></ul><hr><h3 id="NONA"><a href="#NONA" class="headerlink" title="NONA"></a>NONA</h3><ol><li><p>设置网卡</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nano</span> <span class="string">/etc/network/interfaces</span>  <span class="string">/etc/network/interfacesbak</span>   <span class="comment">#备份原有配置文件</span></span><br><span class="line"><span class="string">nano</span> <span class="string">/etc/network/interfaces</span>   <span class="comment">#编辑网网卡配置文件</span></span><br><span class="line"><span class="string">auto</span> <span class="string">lo</span></span><br><span class="line"><span class="string">auto</span> <span class="string">eth0</span>  <span class="comment">#开机自动连接网络</span></span><br><span class="line"><span class="string">iface</span> <span class="string">lo</span> <span class="string">inet</span> <span class="string">loopback</span></span><br><span class="line"><span class="string">allow-hotplug</span> <span class="string">eth0</span></span><br><span class="line"><span class="string">iface</span> <span class="string">eth0</span> <span class="string">inet</span> <span class="string">static</span>   <span class="comment">#static表示使用固定ip，dhcp表述使用动态ip</span></span><br><span class="line"><span class="string">address</span> <span class="number">192.168</span><span class="number">.21</span><span class="number">.166</span>   <span class="comment">#设置ip地址</span></span><br><span class="line"><span class="string">netmask</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  <span class="comment">#设置子网掩码</span></span><br><span class="line"><span class="string">gateway</span> <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span>    <span class="comment">#设置网关</span></span><br><span class="line"><span class="string">ctrl+o</span>   <span class="comment">#保存配置</span></span><br><span class="line"><span class="string">ctrl+x</span>   <span class="comment">#退出</span></span><br></pre></td></tr></table></figure></li><li><p>设置DNS</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cp</span>  <span class="string">/etc/resolv.conf</span>   <span class="string">/etc/resolv.confbak</span>    <span class="comment">#备份原有dns配置文件</span></span><br><span class="line"><span class="string">nano</span> <span class="string">/etc/resolv.conf</span>   <span class="comment">#编辑配置文件</span></span><br><span class="line"><span class="string">nameserver</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>   <span class="comment">#设置首选dns</span></span><br><span class="line"><span class="string">nameserver</span> <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span>   <span class="comment">#设置备用dns</span></span><br><span class="line"><span class="string">ctrl+o</span>   <span class="comment">#保存配置</span></span><br><span class="line"><span class="string">ctrl+x</span>   <span class="comment">#退出</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>网络上关于以下概念的资料数不胜数，这里就不再多做阐述了</li></ul><p><strong>OSI七层模型:</strong></p><blockquote><p>由上至下简述(程序至底层)<br>应用层/表示层/会话层/传输层/网络层/数据链路层/物理层<br>上层依赖于下层，下层为上层提供服务<br>OSI内的每一层模型都有属于自己的协议集与功能集<br>层与层之间相互独立且相互依赖</p></blockquote><ul><li><p>中文维基<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B</code></p></blockquote></li><li><p>TCP/IP</p><blockquote><p>IP:互联网协议<br>TCP:传输控制协议<br>三次握手与四次握手<br>任何基于互联网协议蔟与协议套组都基于TCP/IP</p></blockquote></li><li><p>HTTP</p><blockquote><p>超文本传输协议<br>无状态协议<br>大部分实现都是基于TCP的</p></blockquote></li><li><p>DNS</p><blockquote><p>域名系统</p></blockquote></li><li><p>其它常用协议</p><blockquote><p>应用层:BGP/DHCP/HTTPS/IMAP/NNTP/NTP/POP/SMTP/SNMP/SSH/Telnet等等<br>传输层:UDP/TLS/SSL/DCCP等等<br>网络层:IP/ICMP/IGMP/IPsec等等<br>链接层:APR/PPP/DSL/ISDN等等</p></blockquote></li></ul><hr><h3 id="操作流程-逻辑-整合-简述"><a href="#操作流程-逻辑-整合-简述" class="headerlink" title="操作流程(逻辑)整合/简述"></a>操作流程(逻辑)整合/简述</h3><ol><li>查看网络配置</li><li>查看已有网卡</li><li>启动或重启网卡</li><li>设置配置文件(静态IP或动态IP)</li><li>配置网关</li><li>配置DNS</li><li>保存配置并重启网卡</li></ol><ul><li>任何网络与本地的流量与数据的传输都需要经过本地或无限的网卡</li><li>流量与数据的抓取也只是读取经由网卡的信息并进行输出</li><li>配置无线或有限网的前提是所处的物理环境已有网络支持</li><li>网卡用于联网的虚拟信息处理方式，网络离不开物理层面的支持</li><li>网卡被归纳为设备内</li></ul><hr><p><strong>参考资料:</strong></p><ul><li>Linux系统运维<a href="https://www.osyunwei.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.osyunwei.com/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Debian-GNU-Linux-2&quot;&gt;&lt;a href=&quot;#Debian-GNU-Linux-2&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-4</title>
    <link href="https://unit-serow.github.io/2020/02/22/LFS-4/"/>
    <id>https://unit-serow.github.io/2020/02/22/LFS-4/</id>
    <published>2020-02-22T10:33:46.000Z</published>
    <updated>2020-02-22T15:09:24.833Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="LFS-4"><a href="#LFS-4" class="headerlink" title="LFS-4"></a>LFS-4</h2><h3 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h3><hr><p><strong>制作步骤设计:</strong></p><p><strong>分为三个阶段:</strong></p><ul><li>一阶段:1.创建目标系统目录，2.创建临时系统目录，3. 建立预工具链</li><li>二阶段: 4.建立临时系统，5. 建立目标工具链</li><li>三阶段: 6.建立目标系统，7.收尾工作</li></ul><hr><ol><li>创建目标系统目录</li></ol><ul><li>先建立一个空白的分区用于存放目标系统，并保证在制作完成后可以从这个分区启动已经制作完的系统</li><li>将这个分区格式化为主系统能够识别的文件系统，比如<code>EXT3</code>，并将该分区挂载到主系统中的某个目录，比如<code>/opt/mylinux</code>，这个目录将作为目标系统的制作目录</li><li>另外，还需要人为的将制作中所需要的软件包放在某个目录内，该目录需要在已经制作完成的系统的运行环境中能够访问到</li><li>可以存放在目标系统制作的目录中，如建立一个<code>/opt/mylinux/source</code>目录并存放于其中</li></ul><hr><ol start="2"><li>创建临时系统目录</li></ol><ul><li>本步骤是为了在主系统制作临时系统(详情可见阶段一与阶段二)和使用临时系统来制作目标系统(详情可见阶段三)能够用同样的目录来访问临时系统的目录和文件</li><li>阶段二和阶段三分别在不同根目录的运行环境中，但都使用到了临时系统，如果想让临时系统以最小的改动就可以使其中的命令既可以在主系统所在的运行环境中正常工作，也可以在目的相同所在的运行环境中工作正常</li><li>最好的解决方式就是让两个环境中调用临时系统的目录路径是完全一样的</li></ul><p><strong>执行步骤:</strong></p><ul><li><p>在目标系统所在目录中创建一个存放临时系统的目录，如<code>/opt/mylinux/tools</code></p></li><li><p>然后利用软链接文件的方式在主系统的根目录建立一个指向<code>/opt/mylinux/tools</code>的链接文件</p></li><li><p>该链接文件的文件名必须是<code>/tools</code></p></li><li><p>不去先建立<code>/tools</code>，然后再在<code>/opt/mylinux</code>目录下建立一个指向<code>/tools</code>的同名软链接的原因</p></li><li><p>原因就是目标系统目录是主系统的根目录下的某个目录，主系统根目录的运行环境都可以正常访问目标系统中目录</p></li><li><p>而目标系统在进入以所在目录为根目录的运行环境后就无法访问主系统的其它目录中的内容了</p></li><li><p>所以将真正的内容存放在目录系统的目录中将能够保证各个制作阶段均能访问临时系统中的内容，并且保证访问路径一致</p></li><li><p>采用链接方式在不同阶段的方式关系(链接我呢见在不同环境中的访问关系)</p></li></ul><p><strong>逻辑简述:</strong></p><p><strong>一阶段&amp;二阶段-&gt;三阶段</strong></p><blockquote><p><code>一阶段&amp;二阶段:[主系统(/tools)]&lt;-&gt;[目标系统所在目录(/opt/mylinux/tools)]</code><br><code>三阶段:{运行主系统环境[主系统(/tools)]}-可以访问-&gt;{运行目标系统环境[目标系统(/tools)]}</code><br>同时<br><code>三阶段:{运行目标系统环境[目标系统(/tools)]}-无法访问-&gt;{运行主系统环境[主系统(/tools)]}</code></p></blockquote><ul><li>箭头代表链接关系，箭头指向的是实际目录，另一方则为链接文件</li><li>在一阶段与二阶段中<code>/tools</code>和<code>/opt/mylinux/tools</code>无论谁是链接文件都不影响互相访问</li><li>而在第三阶段，只有<code>/tools</code>是链接文件时才能互相访问，<code>/opt/mylinux/tools</code>(在目标系统环境中变为<code>/tools</code>)是链接文件时无法访问<code>/tools</code>中的内容</li><li>同时还可以使用目录映射的方式使两个阶段都能够正常访问临时系统，即有两种方法:一种是软连接的方式，另一种是目录映射的方式</li><li>本篇文章仅介绍软链接的方式</li></ul><hr><ol start="3"><li>建立预工具链</li></ol><ul><li>预工具链的作用是生成临时工具链，临时工具链是独立于主系统中的工具链，根据工具链的制作原则需要有一个外部依赖的工具链作为过渡，该工具链就是预工具链</li></ul><p><strong>预工具链到临时工具链的制作过程与步骤</strong></p><ol><li>先完成预工具链的编译工具部分，此时预工具链是一个内部依赖的工具链，依赖主系统中的Glibc</li><li>然后使用编译工具完成临时系统中的Glibc，该Glibc存放在临时系统目录中，作为临时工具链和临时系统所依赖的Glibc</li><li>对预工具链进行调整，变为外部依赖的工具链，即可开始编译临时工具链中的编译工具，以此完成临时工具链</li><li>预工具链是临时工具链的过渡工具链，可以将其存放在临时系统的目录中，临时工具链的安装会覆盖掉预工具链，也可以存放在其它目录下，但需要在用完后手工删除掉</li></ol><p><strong>到此第一阶段的制作已经完成，即将开始第二阶段的制作过程</strong></p><hr><ol start="4"><li>建立临时系统</li></ol><ul><li><p>现在已经完成了临时工具链，但仅仅有一个工具链还不能顺利的编译各种软件包，需要有各种各样的辅助命令来共同完成</p></li><li><p>当前还处于主系统运行环境中，主系统所附带的各种辅助命令目前都可以用于编译</p></li><li><p>为了切换到目标系统运行环境后还能继续使用这些辅助命令，就必须将这些辅助命令存放在目标系统运行环境所能访问到的目录中</p></li><li><p>建立临时系统的原因就是为了承前启后，前即为主系统，后则为目标系统</p></li><li><p>临时系统是目标系统建立前用于支撑目标系统运行环境的基本框架，目标系统需要人为的进行从头建立</p></li><li><p>即为一开始什么都没有，此时临时系统承担了运行环境的运作，包括提供用户的交互功能，编译软件包以及常用命令</p></li><li><p>因此临时系统中必须加入工具链，辅助命令，常用命令和支撑运行环境的程序(如Bash)</p></li></ul><p><strong>逻辑简述(不同阶段切换过程中各个系统的内容)</strong></p><p><strong>一阶段开始-&gt;二阶段开始-&gt;三阶段开始-&gt;三阶段结束</strong></p><blockquote><p>一阶段:<code>{一阶段开始，主系统运行环境内(/&amp;/tools)[主系统(完整)/临时系统(无内容)]}-此时的目标系统内无内容</code><br>二阶段:<code>{二阶段开始，主系统运行环境内(/&amp;/tools)[主系统(完整)/临时系统(部分)]}-此时的目标系统内无内容</code><br>三阶段:<code>{三阶段开始，目标系统运行环境内(/&amp;/tools)[临时系统(完整)/目标系统(无内容)]}-{/[主系统(完整)]}</code><br>三阶段:<code>{三阶段结束，目标系统运行环境内(/&amp;/tools)[临时系统(完整)/目标系统(完整)]}-{/[主系统(完整)]}</code></p></blockquote><ul><li><p>第三阶段开始时，目标系统的根目录(<code>/</code>)没有任何内容，只能靠临时系统提供各种编译和运行的功能</p></li><li><p>第三阶段完成后，目标系统已经完整，就可以不需要临时系统而直接运行了</p></li><li><p>可以了解到临时洗头膏必须拥有相对完整的运行能力，并且要独立于主系统，无论临时工具链还是临时系统中其它辅助命令都必须依赖临时系统中的函数库</p></li><li><p>临时系统必须全部由临时工具链来链接生成</p></li><li><p>此时临时系统的制作内容就非常明确了，如Bash，常用命令(Coreuils等)和工具链环境(Awk，Sed等)</p></li></ul><hr><ol start="5"><li>建立目标工具链</li></ol><ul><li><p>制作完成了临时系统后就要进入第三阶段的制作过程，即为将运行环境正式切换到目标系统运行环境</p></li><li><p>需要明确的是:目标系统最终是需要通过人为方式去将内容进行保留，临时系统在完成目标系统后就会被删除掉</p></li><li><p>目标系统同样需要一个内部链接的工具链，这是为了实现今后目标系统脱离主系统后能成为一个独立的系统且能够继续编译安装软件包</p></li><li><p>目标的临时工具链也是内部依赖的工具链，根据制作原则可以知道从内部依赖的工具链生成另外一个内部依赖的工具链需要有一个外部依赖的工具链作为过渡</p></li><li><p>此时已经不再编译临时系统上的程序文件了，可以通过调整工具链的方法将临时工具链内部依赖变为内部依赖，过渡用的外部依赖工具链就用调整临时工具链的方法来实现，临时工具链由此开始作为过渡工具链</p></li><li><p>根据工具链的制作原则，调整之前需要先建立好目标系统中的Glibc，这个Glibc同样根据工具链制作原则存放在目标系统的目录中</p></li><li><p>然后调整临时工具链，再编译目标系统中的，形成内部依赖的工具链</p></li><li><p>目标工具链的形成意味着临时工具链的使命已经完成，虽然现在临时工具链经过了调整，但后续的制作过程中不会再使用到它了</p></li><li><p>此时不用在意它的存在，也不需要这时去删除它，在最后完成目标系统后再将它连同临时系统一并删除</p></li></ul><hr><ol start="6"><li>建立目标系统</li></ol><ul><li>临时工具链虽然已经不再需要了，但目前目标系统除了目标工具链还一无所有</li><li>还需要用到临时系统中的各种各种目录以及其它常用命令，交互环境程序也还在使用临时系统中的命令</li><li>如同制作临时系统的时候需要的命令安装到临时系统中一样，可以人为的将临时系统中出现的所有的软件包都重新用目标工具链再次编译并安装到目标系统目录中</li><li>最终将完全替代掉临时系统中的所有软件包和命令</li><li>目标系统和临时系统的要求是不一样的，临时系统只需要为制作目标系统编译环境和简单的运行环境的支撑能力即可</li><li>但目标系统除了要具备临时系统所具有的功能之外还需要有更高的要求</li><li>比如网络的支持，程序进程的管理，系统启动等，因此还需要安装许多Linux系统中常见的软件包</li><li>至于关于常见软件包，这里不过过多枚举</li></ul><hr><ol start="7"><li>收尾工作</li></ol><ul><li><p>完成了目标系统后，就可以展开收尾工作了</p></li><li><p>包括删除临时系统，临时系统所有文件都存放在了<code>/tools</code>目录中，只需要删除<code>/tools</code>就可以了</p></li><li><p>还有一些公共的配置文件需要进行设置，如主机名，网络地址等，这些内容将在后续章节内进行介绍，这里先不再赘述</p></li><li><p>对于编译出来的命令程序还有一个需要注意的地方，很多软件包编译生成的程序文件带有许多调试信息，会占据相当大的磁盘空间</p></li><li><p>有的程序文件所附带的调试信息可以使其增加数倍的大小，主体代码只有几百KB的程序可能会超过1MB，去掉这些调试信息显得非常重要</p></li><li><p>调试信息的删除可以使用strip命令来完成，具体参数不进行过多阐述，需要注意的一点就是某一些程序或软件的调试信息中会与其静态函数库发生关联，如果去掉则可能导致静态函数库无法使用</p></li></ul><hr><ol start="8"><li>启动目标系统</li></ol><ul><li>让这个目标系统正常的启动起来</li><li>如果以LiveCD的方式进行制作，同时所使用的本地计算机内没有任何影片盘的启动器时，可以使用GRUB的启动程序</li><li>关于GRUB的使用这里不做过多阐述</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-4&quot;&gt;&lt;a href=&quot;#LFS-4&quot; class=&quot;headerlink&quot; title=&quot;LFS-4&quot;&gt;&lt;/a&gt;LFS-4&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-3</title>
    <link href="https://unit-serow.github.io/2020/02/22/LFS-3/"/>
    <id>https://unit-serow.github.io/2020/02/22/LFS-3/</id>
    <published>2020-02-22T08:08:52.000Z</published>
    <updated>2020-02-22T15:09:08.669Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="LFS-3"><a href="#LFS-3" class="headerlink" title="LFS-3"></a>LFS-3</h2><ul><li>内容接LFS-2</li></ul><h3 id="制作过程中的相关技术"><a href="#制作过程中的相关技术" class="headerlink" title="制作过程中的相关技术"></a>制作过程中的相关技术</h3><ol><li>虚拟根目录</li></ol><ul><li>制作目标系统的最终且最基本点是让其称为一个可以独立运行的系统(不依赖主系统和临时系统的纯净系统)</li><li>根据Linux系统的特点它需要存放于根目录下，而第一阶段中的主系统也同样存放在根目录下</li><li>主系统在制作过程中是始终运行的，制作过程中要运行目标系统中的命令，从而形成了命令的执行矛盾</li><li>而在Linux系统中使用虚拟根目录可以解决这个矛盾</li><li>linux内核启动时建立的根目录被定义为真正的目录，虚拟根目录可以简单的理解为:一个运行的Linux系统中可以存在多个运行环境，而每个运行环境都有自己的根目录，这些运行环境的根目录就可以被定义为虚拟根目录，任何目录都可以被设置为某个运行环境中的根目录</li><li>在主系统中建立一个目录，其中存放系统的基本命令，即可将该目录作为虚拟根目录启动一个新的运行环境</li><li>如果将主系统环境称为环境A，把在A环境下建立的新的运行环境称为环境B，则可称环境B为环境A的子环境，而环境A被称为环境B的父环境</li></ul><p><strong>实现逻辑简述:</strong></p><ol><li>假设主系统中的根目录下存在若干文件目录</li><li>指定其中某一目录作为制作目标系统的基础目录(将此目录设置为新的运行环境的根目录)</li><li>此时将此目录称为X，而此目录下还可以存放若干文件目录，这里用X1，X2，X3表示</li><li>基于跟目录X创建一个运行环境，此时运行目录X下将只有X1，X2，X3目录</li></ol><ul><li>用于作为新运行环境中的根目录可以是父环境中的任何命令或者目录中的目录，同时也包括父环境中的根目录</li></ul><hr><ol start="2"><li>分区的挂载</li></ol><ul><li>目标系统的最终目的是独立于主系统而运行，此时需要将目标系统装在一个分区中，而不是主系统的某个目录下</li><li>Linux系统是通过挂载的方式使用分区，挂载就是将某个存储设备以某种文件系统链接到某个目录</li><li>用户查看到目录中的文件即为分区中的文件，对其中的文件进行操作与操作一般目录的文件相同</li><li>只要有一个空分区，将该分区格式化为主系统能识别的文件系统，并将其挂载到主系统的某个目录上就可以了</li><li>目标系统只需要存放到这个目录就等于存放在该分区，制作完成后就可以直接使用这个分区来启动系统，存放在目录下的第一级的文件和目录就是目标系统跟目录的内容</li></ul><p><strong>实现逻辑简述</strong></p><ol><li>挂载主系统的根目录下的某个目录，将此目录定义为磁盘分区A，此磁盘分区下拥有若干个目录</li><li>然后从磁盘分区A启动目标系统，启动之后的目标系统的根目录以及根目录下的文件即为主系统下被挂载的文件目录的中的文件，在这里还可将其称为磁盘分区A</li><li>从而使目标系统脱离主系统运行</li></ol><ul><li>可以看出子环境运行的方式和目标系统重新启动后的根目录相同</li><li>根据此原理，制作目标系统的过程中以挂载分区的目录作为虚拟根目录创建新的运行环境，在其中可以使用目标系统的命令</li><li>从而解决了主系统和目标系统都需要使用根目录的矛盾</li><li>目标系统制作完成后，目录系统就可以从分区单独启动以此来脱离主系统</li></ul><hr><ol start="3"><li>链接文件</li></ol><ul><li><p>在Linux系统中有一种用来引用其它文件的符号链接文件，这里将其简称为链接文件</p></li><li><p>其包含有一条绝对路径或者相对路径的形式用于指向其它文件或者目录的引用</p></li><li><p>其所链接的文件被称为目标文件，链接文件和目标文件的文件名可以相同也可以不同</p></li><li><p>相同文件名的情况下目标文件和链接文件不能存放于实质相同的目录下</p></li><li><p>链接文件可以分为软链接与硬链接两种</p><blockquote><p>软链接文件的读写就如同直接对目标文件进行操作，链接文件是一个独立文件，其存在并不依赖于目标文件<br>如果删除一个链接文件，它所指向的目标文件不受影响<br>如果删除了目标文件，其指向目标文件的链接文件依然存在</p></blockquote></li><li><p>硬链接与目标文件使用同一个文件索引节点，因此只能在同一个磁盘分区中使用硬链接，并且它不能离开关联文件而独立存在</p><blockquote><p>如果一个硬链接被移动，重命名或者删除时，其余关联到同一文件的硬链接不受影响<br>当最后一条指向该文件的硬链接被删除时，该文件内容会消失</p></blockquote></li><li><p>软链接可以跨磁盘分区来进行目标文件的指定，而硬链接只能使用同一个磁盘分区中的文件</p></li><li><p>建立软链接和硬链接的命令在Linux系统中是相同的，都是ln命令，使用不同的选项以建立不同的连接方式</p></li><li><p>ln命令的基本格式</p><blockquote><p><code>ln [options] 目标文件 链接文件</code></p></blockquote></li><li><p>参数<code>-s</code>表示建立软链接，没有设置的情况下默认建立硬链接</p></li><li><p>目标文件可以是相对路径或绝对路径</p></li><li><p>在制作过程中，均使用软链接文件，即符号链接文件</p></li></ul><hr><ol start="4"><li>文件系统</li></ol><ul><li>文件系统是一种存储和组织计算机文件和数据的方法，以更容易的去访问和查找数据</li><li>文件系统类型一览</li></ul><ol><li>磁盘文件系统:EXT2/3，XFS等等，可以直接应用在软硬盘存储设备上</li><li>网络文件系统:NFS，CIFS等等</li><li>事务文件系统:AUFS等等</li><li>内存文件系统:TmpFS等等，使用内存来模拟存储设备的文件系统，可以从内存中划出一块区域用于像磁盘文件系统那样来存放文件和目录</li><li>特殊文件系统:proc，sysfs等等，具有特殊功能的文件系统，如内核文件系统</li></ol><p><strong>文件系统的使用:</strong></p><ul><li>文件系统在Linux系统中以挂载的方式使用，挂载工具为mount<blockquote><p><code>mount [options] 设备名 目录名</code></p></blockquote></li><li>参数-t用于指定文件系统名称，一般mount会自动检测文件系统名称</li><li>如<code>mount /dev/sda3 /mnt</code><blockquote><p><code>/dev/sda3</code>是挂载分区，<code>/mnt</code>是被挂载的目录</p></blockquote></li></ul><hr><ol start="5"><li>目录映射</li></ol><ul><li>子环境的运行方式和从分区启动的方式中，虽然根目录是一致的，但就整个系统来说还是有很多差别的</li><li>比如有些目录，类似于/dev或/proc等等中的内容都是系统启动过程中创建的，并且会在运行过程中发生变化</li><li>这些目录中的内容有时会影响系统的制作，如果想让两种方式的效果最为接近，就需要让这些目录中存放的内容相似</li><li>这些目录的内容多与内核相关，但子环境的运行方式所使用的是主系统中的内核</li><li>因此目标系统和主系统的内核应当尽量保存兼容，以此利用主系统中相应目录的内容来补充目标系统中的这些目录中的内容</li><li>想让主系统和目标系统对应目录中的内容保存一致，最容易的办法无非是复制目录，但因为/proc的内容是反应内核当前的情况(动态目录)，复制过来的目录并不能随着系统的运行而发生变化，所以不能采用复制的方法</li><li>可以用建立软链接文件的方式来让两个目录的内容一致而又不采用复制目录的方法</li><li>访问链接文件就如同访问它所链接到的目录一样，但软链接文件的一个问题就是目标文件或目录必须存在且可以被当前的运行环境所访问</li></ul><p><strong>这里举一个例子:</strong></p><ul><li>在主系统中的根目录下存在/proc目录，现在系统在/opt/目录下创建一个proc_a链接文件并指向/proc</li><li>当前运行环境中访问/opt/proc_a中的内容就如同访问/proc中的内容</li><li>但如果将/opt作为虚拟根目录启动一个新的运行环境时，原先的/opt/proc_a将变成/proc_a(此时此分区的文件目录与原主机的文件目录相隔离)</li><li>所以它指向的/proc无法在这个运行环境中被访问到，则会导致链接文件失效，所以链接文件的方法也不能使用</li><li>所以这里就要引出目录映射的概念了</li></ul><p><strong>文件映射:</strong></p><ul><li><p>被映射的源目录和映射目录内容上保存一致，对它们中任何一方目录内的改动都将直接导致另一方同样的修改</p></li><li><p>与链接文件处理方式不同，源目录和映射目录都必须是实际目录，而非链接文件</p></li><li><p>目录映射并不依赖源目录的存在位置，即使在建立好目录映射后，改变源目录的名称或者位置都不会影响到映射目录中的内容</p></li><li><p>因此使用映射方式建立的目录一致性将在进入新的运行环境中继续产生作用</p></li><li><p>映射目录方法所建立起的文件关联会直接涉及于文件所在磁盘的物理地址，所以不会因为别名或修改文件状态的操作而发生失效或错误</p></li></ul><hr><ol start="6"><li>工具链调整</li></ol><p>*工具链从内部依赖转为外部依赖，不同外部依赖的转换，外部依赖转内部依赖，都属于调整依赖工具链<br>*调整工具链不存在内部依赖转内部依赖的情况</p><p><strong>这里举一个例子:</strong></p><ul><li>将工具链分为三个部分并用实际的软件包名称来表示:</li><li>工具链=Binutils+GCC+Glibc</li><li>调整工具链的实质就是用新的Glibc代替工具链原来的Glibc，两个Glibc存放在不同目录</li><li>调整工具链的原因是要让工具链中的编译工具改变链接的函数库位置，这个改变只需要改变两个地方:GCC的编译配置和Binutils中ld命令的函数库查询目录</li><li>GCC的编译默认配置被编译于GCC的相关文件中，GCC中的gcc命令有两种配置方式，一种是外部的配置文件，另一种是内部的默认配置</li><li>gcc命令优先使用外部配置的方式，则修改配置文件就可以实现目的</li><li>因为GCC的配置文件很复杂而不便于重新编写，所以可采用gcc命令将默认配置导出，然后修改相应的内容并保存到特定的文件中的方法来实现目的</li><li>gcc命令的默认导出配置方式的执行命令:<code>gcc -dumpspecs</code></li><li>该命令将默认配置显示在屏幕上，只需要人为的将其存放到gcc读取配置文件的目录中</li><li>gcc读取外部配置文件的目录可以使用此命令来获得:<code>dirname $(gcc -print-libgcc-file-name)</code></li><li>该命令返回读取配置文件的目录名，接下来只需要在这个目录中创建一个名为specs的文件，并将已经人为配置完的配置文件存放在该目录中就可以了</li><li>执行该命令:<code>gcc -dumpspecs &gt; $(dirname $(gcc -print-libgcc-file-name))/specs</code></li><li>此时配置文件已经准备好了，目前这个文件中的内容和GCC的默认配置完全一个，只需要人为的将文件中的内容进行修改就行</li><li>该文件以文本内容存放，所以可以使用一般的文本编辑器来进行修改，也可以使用文本编辑器的命令来进行修改，如sed命令</li><li>修改其寻址函数库的目录为新函数库的所在目录即可</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-3&quot;&gt;&lt;a href=&quot;#LFS-3&quot; class=&quot;headerlink&quot; title=&quot;LFS-3&quot;&gt;&lt;/a&gt;LFS-3&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-2</title>
    <link href="https://unit-serow.github.io/2020/02/22/LFS-2/"/>
    <id>https://unit-serow.github.io/2020/02/22/LFS-2/</id>
    <published>2020-02-22T08:07:09.000Z</published>
    <updated>2020-02-22T15:08:46.148Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="Linux-from-Scratch-LFS-2"><a href="#Linux-from-Scratch-LFS-2" class="headerlink" title="Linux from Scratch/LFS-2"></a>Linux from Scratch/LFS-2</h2><ul><li>名词解释</li><li>制作逻辑</li><li>相关技术 LSF-3</li><li>制作步骤 LSF-4</li><li>目的为创造一个崭新的，基于Linux内核的操作系统</li></ul><hr><p><strong>linux from scratch</strong></p><h3 id="涉及名称一览-解释"><a href="#涉及名称一览-解释" class="headerlink" title="涉及名称一览(解释)"></a>涉及名称一览(解释)</h3><p><strong>主系统</strong></p><ul><li>源系统，用于提供制作处新系统的基本环境</li><li>可以比喻成一架航母上的某一架飞机的基础机型</li></ul><p><strong>目标系统</strong></p><ul><li>基于主系统要仿制/制作的目标系统(最终目的)</li><li>可以比喻成要仿制基础机型进行制造的另一架飞机</li></ul><p><strong>临时系统</strong></p><ul><li>在制作目标系统的过程中需要的过渡系统，用于辅助目标系统的制作过程</li><li>可以比喻成要制造却还在规划中的飞机模型与飞机的基本结构</li></ul><hr><p><strong>编译工具</strong></p><ul><li>这里将汇编工具Binutils与编译器GCC合称为编译工具</li></ul><p><strong>工具链</strong></p><ul><li><p>汇编工具，编译器，与C标准库(Binutils，GCC，Glibc)合成为工具链</p></li><li><p>因为让工具链生成可执行文件通常都需要函数库(标准库)，所以这里这里将函数库包含于工具链内</p></li><li><p>因为在整个制作过程中，各个阶段都会产生工具链，所以这里将各个阶段的工具链名称进行以下定义和命名</p></li></ul><ol><li>原工具链</li></ol><ul><li>主系统的工具链</li></ul><ol start="2"><li>预工具链</li></ol><ul><li>用于生成临时工具链的工具链</li></ul><ol start="3"><li>临时工具链</li></ol><ul><li>用于生成临时系统的工具链</li></ul><ol start="4"><li>目标工具链</li></ol><ul><li>用于生成目标系统的工具链</li></ul><hr><p><strong>辅助命令</strong></p><ul><li>在编译软件包的过程中，处理工具链以外通常还需要一些命令的参与</li><li>类似于make之类的，这类工具这里将其合成为辅助命令</li></ul><p><strong>工具链环境</strong></p><ul><li>将工具链同辅助命令合称为工具链环境，因为不同的阶段会出现不同的组合，所以这里将各个阶段工具链环境的名称进行以下定义和命名</li></ul><ol><li>预工具链环境</li></ol><ul><li>预工具链+主系统中的辅助命令及基本函数库</li></ul><ol start="2"><li>预临时工具链环境</li></ol><ul><li>临时工具链+临时系统中的辅助命令及基本函数库</li></ul><ol start="3"><li>目标工具链</li></ol><ul><li>目标工具链+目标系统中的辅助命令及基本函数库</li></ul><hr><p><strong>运行环境</strong></p><ul><li>因为在一个运行的系统中可以存在多个不同的环境，这些环境中有各自的根目录及环境设置</li><li>这一类的环境被称为运行环境，因为在制作过程中各个阶段会处于不同的运行环境，所以这里将各个阶段的运行环境进行以下定义和命名</li></ul><ol><li>主系统运行环境</li></ol><ul><li>以主系统所在的运行环境</li></ul><ol start="2"><li>目标系统运行环境</li></ol><ul><li>目标系统所在目录为根目录的运行环境</li></ul><hr><p><strong>头文件</strong></p><ul><li>用于编译的一类文件，以存放函数的接口描述与结构体信息等程序设计的相关内容</li></ul><p><strong>纯净度</strong></p><ul><li>目标系统对于主系统依赖程度的评估</li><li>目标系统必须完全不依赖于主系统，才可称其为独立系统</li></ul><hr><p><strong>结构体系描述</strong></p><blockquote><p><code>系统=内核+各类函数库+交互环境+各种应用程序(常用命令的指令集)+各类配置文件(辅助文件)</code></p></blockquote><blockquote><p><code>[程序]-配置文件-&gt;[命令]-配置文件-&gt;[交互环境]-配置文件-&gt;[函数库]-&gt;{内核}</code></p></blockquote><hr><p><strong>启动过程描述</strong></p><blockquote><p><code>BIOS/UEFI-&gt;GRUB/LILO-&gt;KERNEL(Kernel)</code></p></blockquote><hr><p><strong>基本编译过程描述</strong></p><blockquote><p><code>[Make]-GCC/各种编译工具-[源代码]-&gt;[目标代码]</code><br>同时Binutils利用以生成的目标代码<br><code>[Make]-[Binutils]-&gt;[共享函数库(运行时需要)/静态函数库(编译进程序)]-[目标代码]-&gt;{可执行程序}</code></p></blockquote><hr><h3 id="制作逻辑描述"><a href="#制作逻辑描述" class="headerlink" title="制作逻辑描述"></a>制作逻辑描述</h3><ul><li>常用命令尽量使用GNU所提供的</li></ul><ol><li>主系统准备</li></ol><ul><li>主系统与目标系统相同或相兼容</li><li>拥有工具链与辅助命令，即为原工具链</li></ul><hr><ol start="2"><li>预工具链的生成</li></ol><ul><li>主系统准备好之后就可以建立预工具链了</li><li>建立预工具链的目的是建立临时工具链</li><li>预工具链由原工具链生成，即为原工具链(初始工具链)到临时工具链(目的工具链)的过渡工具链</li><li>预工具链建立之初是一个内部依赖方式的工具链，用它编译出来的程序文件将链接到主系统的Glibc(C标准库)上</li></ul><hr><ol start="3"><li>临时工具链的生成</li></ol><ul><li>临时工具链的目的是建立临时系统，临时系统需要脱离主系统的运行环境</li><li>临时工具链本身也是临时系统的重要组成部分，所以临时工具链也能够脱离主系统的运行环境</li><li>预工具链负责完成临时系统种的Glibc，当Glibc完成后对预工具链进行依赖方式的调整，使与工具链变为外部依赖的工具链</li><li>调整完成后生成临时编译工具，临时编译工具依赖于临时系统种的Glibc</li><li>临时编译工具与临时系统的Glibc一起组成临时工具链，预工具链的使命到此完成</li><li>临时工具链将代替预工具链完成临时系统的制作</li><li>临时工具链不依赖主系统下的函数库，临时工具链为内部依赖的形式</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>[主系统(源工具链/辅助命令/其它命令...)]-1-&gt;[预工具链]-2-&gt;[临时工具链]</code><br>同时<br><code>[辅助命令]-2-&gt;[临时工具链]</code></p></blockquote><hr><ol start="4"><li>临时系统的生成</li></ol><ul><li>编译一个软件往往除了编译器之外还需要其它程序的参与，仅仅靠临时工具链是无法完成目标系统的制作的</li><li>因此需要一个相对完整的工具链环境，临时系统将完成临时工具链环境的创建</li><li>临时工具链环境的创建过程需要主系统的辅助命令参与完成，在完成临时工具链环境的辅助命令后便完成了临时工具链</li><li>此时的临时工具链不再依赖主系统种的辅助命令编译软件了，为临时系统脱离主系统环境做好准备</li><li>临时工具链将继续完成临时系统的制作，临时系统的制作目的是为了给制作目标提供一个不依赖于主系统的编译环境</li><li>用临时工具链生成临时系统可保证其中各种工具环境所依赖的函数库也是临时系统种的函数库</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>[主系统(源工具链/辅助命令/其它命令...)]-1-&gt;[预工具链]-2-&gt;[临时系统(临时工具链)-3-&gt;(辅助命令)]</code><br>同时<br><code>[辅助命令]-3-&gt;[临时系统(辅助命令)]</code></p></blockquote><hr><ol start="5"><li>目标工具链</li></ol><ul><li>此时临时系统已经完成制作，接下来将要做的是让临时系统脱离主系统，即用临时系统去制作目标系统</li><li>同时为了能让目标系统称为自我扩展的系统，必须人为的为这个目标系统提供一个工具链</li><li>即用已经生成的临时系统来生成目标系统的Glibc，然后调整临时工具链使其编译出来的程序文件或库文件链接到目标系统的Glibc上</li><li>即内部依赖的临时工具链变成外部依赖方式，再编译目标系统上的Binuils和GCC</li><li>此时完成目标工具链的建立，下一步将再用目标工具链和生成目标工具链环境</li><li>此时临时工具链已经完成了使命，但临时工具链环境种的辅助命令还需要继续使用直到目标工具链中相应的辅助命令建立，从而形成目标工具链环境</li></ul><hr><ol start="6"><li>目标工具链环境的生成</li></ol><ul><li>为了让目标系统能够自给自足的进行扩展更新，目标系统需要带有最基本的编译环境</li><li>以上的操作已经将目标工具链生成，但使用的辅助命令还是临时系统中的命令</li><li>这个时候就需要人为的编译这些需要用到的辅助命令，并安装到目标系统中，以此成为目标工具链环境</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>[主系统(源工具链/辅助命令/其它命令...)]-1-&gt;[预工具链]-2-&gt;[临时系统(临时工具链)-3-&gt;(辅助命令)]</code><br>同时<br><code>[辅助命令]-3-&gt;[临时系统(辅助命令)]</code><br><strong>在以上步骤进行完成后</strong><br><code>[临时系统(临时工具链/辅助命令)]-4-&gt;[目标工具链]</code></p></blockquote><ul><li>按照生成临时系统的内容编译完各种辅助命令之后，就可以安装更多的辅助命令或其它程序了</li></ul><p><strong>在以上步骤进行完成后</strong></p><blockquote><p><code>[临时系统(临时工具链/辅助命令)]-4-&gt;[目标工具链环境(目标工具链)-5-&gt;(辅助命令)]</code><br>同时<br><code>[目标工具链环境(辅助命令)]&lt;-5-&gt;[临时系统(辅助命令)]</code></p></blockquote><hr><ol start="7"><li>目标系统的生成</li></ol><ul><li>在目标工具链环境生成之后将这个环境进一步完善，包括编辑工具，网络工具等，使之成为真正有用的目标系统</li><li>这部分内容的选择并没由什么限制与约束</li><li>在目标系统主体程序安装完毕后需要让这个系统能够正常而独立的运行起来，还需要人为的对启动过程进行处理</li></ul><p><strong>逻辑表示即为</strong></p><blockquote><p><code>[主系统]-预工具链-&gt;[临时系统]-&gt;[目标系统]</code></p></blockquote><p><strong>精准逻辑表示</strong></p><p><strong>区块一:</strong></p><blockquote><p><code>区块一(主系统-&gt;临时系统)</code><br><code>[主系统(源工具链/辅助命令/其它命令)]-1-&gt;预工具链-2-&gt;[临时系统(临时工具链-3-&gt;辅助命令)]</code><br>同时<br><code>[主系统(辅助命令)]-2-&gt;[临时系统(临时工具链-3-&gt;辅助命令)]</code><br>同时<br><code>[主系统(辅助命令)-3-&gt;[临时系统(辅助命令)]</code></p></blockquote><p><strong>区块二:</strong></p><blockquote><p><code>区块二(临时系统-&gt;目标系统)</code><br><code>[临时系统(临时工具链-3-&gt;辅助命令)]-4-&gt;[目标系统(目标系统工具链环境-5-&gt;辅助命令)-6-&gt;(其它命令...)]</code><br>同时<br><code>[临时系统(辅助命令)]-4-&gt;[目标系统(命令工具链)]</code><br><code>[临时系统(辅助命令)]&lt;-5-&gt;[目标系统(辅助命令)]</code></p></blockquote><hr><h3 id="执行逻辑一览-汇总"><a href="#执行逻辑一览-汇总" class="headerlink" title="执行逻辑一览(汇总)"></a>执行逻辑一览(汇总)</h3><ul><li><p>可以分为三个阶段，六个时间点(步骤点)</p></li><li><p>阶段一</p></li></ul><ol><li>利用主系统的工具链与辅助命令生成预工具链</li><li>利用主系统中的辅助命令与已经生成的预工具链生成临时系统中所需的临时工具链</li></ol><ul><li>阶段二</li></ul><ol start="3"><li>利用主系统中的辅助命令和临时系统中的临时工具链生成临时系统中的辅助命令</li><li>利用临时系统中的临时工具链和辅助命令生成目标系统中的目标工具链</li></ol><ul><li>阶段三</li></ul><ol start="5"><li>利用目标系统中的目标工具链生与临时系统中的辅助命令生成目标系统中的辅助命令，以此生成目标工具链环境(目标工具链+辅助命令)</li><li>利用目标系统中的目标工具链环境中的目标工具链和辅助命令生成其它命令</li></ol><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Linux-from-Scratch-LFS-2&quot;&gt;&lt;a href=&quot;#Linux-from-Scratch-LFS-2&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-1</title>
    <link href="https://unit-serow.github.io/2020/02/22/LFS-1/"/>
    <id>https://unit-serow.github.io/2020/02/22/LFS-1/</id>
    <published>2020-02-21T19:55:25.000Z</published>
    <updated>2020-02-27T17:07:45.530Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="Linux-from-Scratch-LFS-1"><a href="#Linux-from-Scratch-LFS-1" class="headerlink" title="Linux from Scratch/LFS-1"></a>Linux from Scratch/LFS-1</h2><hr><h3 id="资源整合目录"><a href="#资源整合目录" class="headerlink" title="资源整合目录"></a>资源整合目录</h3><p><strong>Linux from scratch</strong></p><ul><li>官方网站<a href="http://linuxfromscratch.org/" target="_blank" rel="noopener">跳转</a><blockquote><p><a href="http://linuxfromscratch.org/" target="_blank" rel="noopener">http://linuxfromscratch.org/</a></p></blockquote></li></ul><p><strong>LFS LiveCD</strong></p><ul><li><p>HTTP获取</p><blockquote><p><code>http://linuxfromscratch.org/livecd/download.html</code></p></blockquote></li><li><p>FTP获取</p><blockquote><p><code>http://ftp.osuosl.org/pub/lfs-livecd/lfslivecd-x86-6.3-r2145. iso</code></p></blockquote></li><li><p>LFS LiveCD说明<a href="http://linuxfromscratch.org/livecd/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://linuxfromscratch.org/livecd/index.html</code></p></blockquote></li><li><p>LFS wiki<a href="https://trac.clfs.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://trac.clfs.org/</code></p></blockquote></li><li><p>操作手册<a href="http://linuxfromscratch.org/lfs/downloads/9.1-rc1/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://linuxfromscratch.org/lfs/downloads/9.1-rc1/</code></p></blockquote></li><li><p>中文维基<a href="https://zh.wikipedia.org/wiki/Linux_From_Scratch" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Linux_From_Scratch</code></p></blockquote></li><li><p>从LFS官网下载的速度属实不言而喻(无论是FTP还是HTTP)</p></li><li><p>以下链接为永久有效</p></li><li><p>Version:<code>lfslivecd-x86-6.2-3</code></p></li><li><p>LFS LiveCD 百度网盘地址<a href="https://pan.baidu.com/s/1IROLau9-OxbN2f-BL3PJVA" target="_blank" rel="noopener">跳转</a></p><blockquote><p>URL:<code>https://pan.baidu.com/s/1IROLau9-OxbN2f-BL3PJVA</code><br>提取码:y0ss</p></blockquote></li><li><p>Version:<code>lfslivecd-x86-6.3-r2145</code></p><blockquote><p>链接<a href="https://pan.baidu.com/s/1ix83uytHKlvqaOUEa4Rq0w" target="_blank" rel="noopener">跳转</a><br>URL:<code>https://pan.baidu.com/s/1ix83uytHKlvqaOUEa4Rq0w</code><br>提取码:dlp4</p></blockquote></li><li><p>Version:<code>lfslivecd-x86_64-6.3-r2145</code></p><blockquote><p>链接<a href="https://pan.baidu.com/s/1R4T6j07yoR9JAO1U2EoClA" target="_blank" rel="noopener">跳转</a><br>URL:<code>https://pan.baidu.com/s/1R4T6j07yoR9JAO1U2EoClA</code><br>提取码:1atk</p></blockquote></li><li><p>linux公社仓库<a href="https://linux.linuxidc.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linux.linuxidc.com/</code></p></blockquote></li></ul><hr><p><strong>GNU/Linux LFS Linux From Scratch</strong></p><ul><li><p>基础准备与Linux系统定制原理</p></li><li><p>LiveCD</p><blockquote><p>利用LFS的方法生成可以自行启动并安装了足够软件的CD<br>可以用来在空机器上安装LFS，或者直接在其上运行应用，已经停止维护</p></blockquote></li><li><p>Linux From Scratch简体中文版(version 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>Linux From Scratch简体中文版(全本版)<a href="https://lctt.github.io/LFS-BOOK/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/</code></p></blockquote></li></ul><hr><p><strong>LFS官方教材所整理的步骤</strong></p><ul><li><p>在宿主操作系统上安装LFS，需要的步骤如下:</p></li><li><p>宿主机即为原主机，原主机可以是GNU/Linux任何发行版</p></li><li><p>对硬盘分区，添加用于安装LFS的用户和组(LFS教科书第2章)</p></li><li><p>下载所有需要的软件包源代码(LFS教科书第3章)</p></li><li><p>准备开发环境(LFS教科书第4章)</p></li><li><p>构造一个基本开发环境(称为工具链/LFS教科书第5章)</p></li><li><p>构造完整的目标系统(LFS教科书第6章)</p></li><li><p>配置系统启动脚本(LFS教科书第7章)</p></li><li><p>启动系统(LFS教科书第8章)</p></li><li><p>相关项目</p></li></ul><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><hr><ul><li><p>Building and Installing Software Packages for Linux<a href="http://www.tldp.org/HOWTO/Software-Building-HOWTO.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p>软件构建知识Software-Building-HOWTO<br><code>http://www.tldp.org/HOWTO/Software-Building-HOWTO.html</code></p></blockquote></li><li><p>Linux用户手册1<a href="http://www.linuxfromscratch.org/hints/downloads/files/essential_prereading.txt" target="_blank" rel="noopener">跳转</a></p><blockquote><p>The Linux Users’ Guide<br>The Essential Pre-Reading<br><code>http://www.linuxfromscratch.org/hints/downloads/files/essential_prereading.txt</code></p></blockquote></li><li><p>Linux用户手册2<a href="http://www.linuxhq.com/guides/LUG/guide.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>The Linux Users&#39; Guide http://www.linuxhq.com/guides/LUG/guide.html</code></p></blockquote></li><li><p>Linuxsir<a href="http://www.linuxsir.org/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxsir.org/index.html</code></p></blockquote></li><li><p>LFS-内容参考资料</p></li><li><p>作者:孙海勇(冲天飞豹)</p></li><li><p>书籍名称:手把手教你如何建立自己的Linux系统第一版以及第二版</p><blockquote><p>2008/2010</p></blockquote></li><li><p>网络有很多的URL和仓库都已经失效或废除了</p></li><li><p>以我目前拥有的水平与能力，似乎已经找不到更多的参考和资料了</p></li><li><p>即便找到也毫无意义，因为都是搜索引擎已经爬取过的数据了……</p></li></ul><hr><h3 id="FLS-1-补充内容-2"><a href="#FLS-1-补充内容-2" class="headerlink" title="FLS-1 补充内容-2"></a>FLS-1 补充内容-2</h3><p><strong>LFS目录简述与参考:</strong></p><ul><li>一阶段<blockquote><p>第0至1章节-序章与介绍<br>第2至4章节-准备工作</p></blockquote></li><li>二阶段<blockquote><p>第5章节-临时系统</p></blockquote></li><li>三阶段<blockquote><p>第6章节-目标系统</p></blockquote></li><li>四阶段<blockquote><p>第7章节-系统配置<br>第8章节-系统可导<br>第9章节-系统启动(完全抛离)<br>第10章节-最后的清理与附录(尾声)</p></blockquote></li></ul><hr><h3 id="相关内容URL整合目录补充内容"><a href="#相关内容URL整合目录补充内容" class="headerlink" title="相关内容URL整合目录补充内容"></a>相关内容URL整合目录补充内容</h3><ul><li><p>CN-Chroot<a href="https://zh.wikipedia.org/wiki/Chroot" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Chroot</code></p></blockquote></li><li><p>CN-Linux内核功能<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD</code></p></blockquote></li><li><p>CN-金步国的<code>Linux-4.4-x86_64</code>内核配置选项简介<a href="http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html</code></p></blockquote></li><li><p>CN-Unix实用程序列表<a href="https://zh.wikipedia.org/wiki/Unix%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Unix%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8</code></p></blockquote></li><li><p>EN-Linux From Scratch(Version 9.1-systemd-rc1)<a href="http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Published February 14th, 2020<br><code>http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html</code></p></blockquote></li></ul><hr><ul><li><p>EN-Index of /lfs/downloads/9.1-systemd-rc1<a href="http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/</code></p></blockquote></li><li><p>EN-Download the Linux From Scratch Book<a href="http://www.linuxfromscratch.org/lfs/download.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/download.html</code></p></blockquote></li><li><p>CN-LFS(v9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-systemd/LFS-SYSD-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/lfs-systemd/LFS-SYSD-BOOK.pdf</code></p></blockquote></li><li><p>EN-The Linux From Scratch Counter<a href="http://www.linuxfromscratch.org/cgi-bin/lfscounter.php" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/cgi-bin/lfscounter.php</code></p></blockquote></li><li><p>EN-Linux Sea<a href="http://swift.siphos.be/linux_sea/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://swift.siphos.be/linux_sea/</code></p></blockquote></li><li><p>EN-其它发行版<a href="http://www.gentoo.org/" target="_blank" rel="noopener">Gentoo</a><a href="https://www.funtoo.org/Welcome" target="_blank" rel="noopener">Funtoo</a></p><blockquote><p>Gentoo: <code>http://www.gentoo.org/</code><br>Funtoo: <code>https://www.funtoo.org/Welcome</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Linux-from-Scratch-LFS-1&quot;&gt;&lt;a href=&quot;#Linux-from-Scratch-LFS-1&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Zsh-1</title>
    <link href="https://unit-serow.github.io/2020/02/21/Zsh-1/"/>
    <id>https://unit-serow.github.io/2020/02/21/Zsh-1/</id>
    <published>2020-02-21T14:35:07.000Z</published>
    <updated>2020-02-21T14:38:32.278Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="Shell-Zsh"><a href="#Shell-Zsh" class="headerlink" title="Shell-Zsh"></a>Shell-Zsh</h2><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh my zsh"></a>oh my zsh</h3><ul><li>配置过程</li></ul><p><strong>相关指令:</strong></p><ul><li>查看系统当前使用的shell<blockquote><p><code>$ echo $SHELL</code></p></blockquote></li></ul><hr><ul><li>查看系统支持Shell列表<blockquote><p><code>$ cat /etc/shells</code></p></blockquote></li></ul><hr><ul><li>安装zsh<blockquote><p><code>apt-get -y install zsh</code></p></blockquote></li></ul><hr><ul><li>切换shell为zsh<blockquote><p><code>$ chsh -s /bin/zsh</code></p></blockquote></li></ul><hr><ul><li>修改主题<blockquote><p><code>$ vim ~/.zshrc</code></p></blockquote></li></ul><hr><ul><li>这里将<code>ZSH_THEME</code>改成ys<blockquote><p><code>ZSH_THEME=&quot;ys&quot;</code></p></blockquote></li></ul><p>–</p><ul><li>更新配置<blockquote><p><code>$ source ~/.zshrc</code></p></blockquote></li></ul><hr><p><strong>补全插件配置:</strong></p><ul><li><p>incr.zsh补全插件下载</p><blockquote><p><code>$ wget http://mimosa-pudica.net/src/incr-0.2.zsh</code></p></blockquote></li><li><p>将此插件放到oh-my-zsh目录的插件库下:</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$cd ~/.oh-my-zsh/plugins/<span class="keyword">incr</span></span><br><span class="line">$mkdir <span class="keyword">incr</span></span><br><span class="line"><span class="comment"># root @ debian in ~/.oh-my-zsh/plugins/incr on git:master x [15:05:07] </span></span><br><span class="line">$ ls</span><br><span class="line"><span class="keyword">incr</span><span class="number">-0.2</span>.zsh</span><br></pre></td></tr></table></figure></li><li><p>在~/.zshrc文件末尾加上</p><blockquote><p><code>emacs ~/.zshrc</code><br><code>source ~/.oh-my-zsh/plugins/incr/incr*.zsh</code></p></blockquote></li><li><p>更新配置:</p><blockquote><p><code>$ source ~/.zshrc</code></p></blockquote></li></ul><hr><p><strong>与vim的提示冲突的解决方法:</strong></p><ul><li>使用自动补全插件可能会与vim的提示功能相冲突，如会报以下错误:</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">vim</span> t</span><br><span class="line">_argument<span class="variable">s:451</span>: _vim_file<span class="variable">s:</span> <span class="function"><span class="keyword">function</span> <span class="title">definition</span> <span class="title">file</span> <span class="title">not</span> <span class="title">found</span></span></span><br></pre></td></tr></table></figure><hr><ul><li>解决方法：将<code>~/.zcompdump*</code>删除即可<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf ~/.zcompdump*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span> zsh</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>获取方式(Git/Curl/Wget):</strong></p><ul><li><p>Git拉取并安装</p><blockquote><p><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></p></blockquote></li><li><p>Curl</p><blockquote><p><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p></blockquote></li><li><p>Wget</p><blockquote><p><code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></p></blockquote></li><li><p>Git源码地址<a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/ohmyzsh/ohmyzsh</code></p></blockquote></li><li><p>Zsh主题乐园<a href="http://blog.ysmood.org/my-ys-terminal-theme/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://blog.ysmood.org/my-ys-terminal-theme/</code></p></blockquote></li></ul><hr><p><strong>参考资料(技术博客):</strong></p><ul><li><p>修改Linux的shell从默认的bash切换为zsh<a href="http://www.findme.wang/blog/detail/id/282.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.findme.wang/blog/detail/id/282.html</code></p></blockquote></li><li><p>oh-my-zsh,让你的终端从未这么爽过<a href="https://www.jianshu.com/p/d194d29e488c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/d194d29e488c</code></p></blockquote></li><li><p>写给 Pythonist 的 Spacemacs 入门指北<a href="https://www.jianshu.com/p/c5cc672aae63" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/c5cc672aae63</code></p></blockquote></li><li><p>oh-my-zsh,最好用的shell,没有之一<a href="https://www.itshutong.com/articles/281/oh-my-zsh-the-best-shell-none" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.itshutong.com/articles/281/oh-my-zsh-the-best-shell-none</code></p></blockquote></li></ul><hr><p><strong>其它内容:</strong></p><ul><li><p>Shell<a href="">跳转</a></p><blockquote><p>本篇<br><code>oh my zsh</code></p></blockquote></li><li><p>编辑器<a href="http://unit-serow.com/2020/02/21/Emacs-1/#more" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>spacemacs</code></p></blockquote></li><li><p>X window<a href="http://unit-serow.com/2020/02/20/Window-1/#more" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>X.org/GNOME</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Shell-Zsh&quot;&gt;&lt;a href=&quot;#Shell-Zsh&quot; class=&quot;headerlink&quot; title=&quot;Shell-Zsh&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-2-2-21</title>
    <link href="https://unit-serow.github.io/2020/02/21/%E9%9A%8F%E7%AC%94-2020-2-2-21/"/>
    <id>https://unit-serow.github.io/2020/02/21/%E9%9A%8F%E7%AC%94-2020-2-2-21/</id>
    <published>2020-02-21T11:10:39.000Z</published>
    <updated>2020-02-21T11:11:53.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h3 id="编程语言知识体系概述与整合-1"><a href="#编程语言知识体系概述与整合-1" class="headerlink" title="编程语言知识体系概述与整合-1"></a>编程语言知识体系概述与整合-1</h3><ul><li>C/C++</li></ul><h2 id="编程语言初级知识体系整合"><a href="#编程语言初级知识体系整合" class="headerlink" title="编程语言初级知识体系整合"></a>编程语言初级知识体系整合</h2><p><strong>类型汇总:</strong></p><ul><li>面向过程OO Procedure Oriented</li><li>面向对象OOP</li><li>面向数据</li><li>脚本语言</li><li>汇编语言</li></ul><hr><p><strong>语言类型:</strong></p><ul><li><p>架构描述语言</p></li><li><p>硬件描述语言</p></li><li><p>置标语言</p></li><li><p>建模语言</p></li><li><p>编程语言</p></li><li><p>查询语言</p></li><li><p>规约语言</p></li><li><p>样式表语言</p></li><li><p>模板语言</p></li><li><p>转换语言</p></li><li><p>中文维基<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80</code></p></blockquote></li></ul><hr><p><strong>通用概念整合:</strong></p><ol><li>程序结构(独有)</li><li>基本语法(独有)</li><li>数据类型(通用)</li><li>变量(通用)</li><li>常量(通用)</li><li>运算符(通用)</li><li>函数/回调函数/方法(通用)</li><li>判断(通用)</li><li>循环(通用)</li><li>作用域(通用)</li><li>数组(通用)</li><li>枚举(通用)</li><li>字符串(通用)</li><li>输入&amp;输出/I&amp;O(通用)</li><li>文件读写(通用)</li><li>别名/typedef(通用)</li><li>强制类型转换(通用)</li><li>错误/异常处理(通用)</li><li>递归(通用)</li><li>算法(通用)</li><li>命令行参数(通用)</li><li>标准库(通用)</li><li>修饰符(通用)</li><li>引用(通用)</li><li>日期/时间(通用)</li><li>数据结构(通用)</li><li>多线程(通用)</li><li>类(通用)</li><li>命名空间(通用)</li></ol><hr><p><strong>C/C++:</strong></p><ol><li>预处理器</li><li>头文件</li><li>指针/指针函数</li><li>存储类</li><li>结构体</li><li>共用体</li><li>位域</li><li>内存管理</li><li>可变参数</li><li>面向过程</li><li>面向对象</li></ol><hr><p><strong>通用概念:</strong></p><ul><li>程序结构(独有)</li><li>基本语法(独有)</li><li>数据类型(通用)</li><li>运算符(通用)</li><li>修饰符(通用)</li><li>标准库(通用)</li><li>强制类型转换(通用)</li></ul><hr><p><strong>纯粹概念:</strong></p><ul><li>算法(通用)</li><li>类(通用)</li><li>多线程(通用)</li><li>数据结构(通用)</li><li>递归(通用)</li><li>字符串(通用)</li><li>循环(通用)</li><li>判断(通用)</li></ul><hr><p><strong>方法概念:</strong></p><ul><li>引用(通用)</li><li>错误/异常处理(通用)</li><li>别名/typedef(通用)</li><li>文件读写(通用)</li><li>输入&amp;输出/I&amp;O(通用)</li><li>枚举(通用)</li><li>数组(通用)</li><li>作用域(通用)</li><li>函数/回调函数/方法(通用)</li><li>变量(通用)</li><li>常量(通用)</li><li>包括头文件或预处理器等独有概念</li></ul><hr><ul><li><p>存储概念与通用概念只需要初步认识，方法概念和小部分通用概念需要多次实践</p></li><li><p>大概率会有遗漏，学习过程中对其进行补充</p></li></ul><hr><h3 id="其它-饼"><a href="#其它-饼" class="headerlink" title="其它(饼)"></a>其它(饼)</h3><p><strong>应用操作系统:</strong></p><ul><li>Debian(10.02/Buster)</li></ul><hr><p><strong>应用文本编辑器:</strong></p><ul><li>Spacemacs</li><li>Emacs</li><li>Vim</li></ul><hr><p><strong>语言路线:</strong></p><ol><li>C</li><li>PHP</li><li>Lisp</li><li>C++</li><li>Python</li><li>Ruby</li><li>Perl</li><li>C#</li><li>JavaScript</li><li>Java</li></ol><ul><li>其它框架汇总(框架)</li><li>其它拓展与插件(扩展)</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;编程语言知识体系概述与整合-1&quot;&gt;&lt;a href=&quot;#编程语言知识体系概述与整合-1&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU Emacs-1</title>
    <link href="https://unit-serow.github.io/2020/02/21/Emacs-1/"/>
    <id>https://unit-serow.github.io/2020/02/21/Emacs-1/</id>
    <published>2020-02-20T23:04:29.000Z</published>
    <updated>2020-02-21T12:46:42.482Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h3 id="Emacs-1"><a href="#Emacs-1" class="headerlink" title="Emacs-1"></a>Emacs-1</h3><h3 id="Emacs快捷键快速参考-参考资料整理"><a href="#Emacs快捷键快速参考-参考资料整理" class="headerlink" title="Emacs快捷键快速参考(参考资料整理)"></a>Emacs快捷键快速参考(参考资料整理)</h3><p><strong>基本快捷键(常用且泛用):</strong></p><ul><li>C/M/De说明:<blockquote><p>C(Control/Ctrl)<br>M(Meta/Alt|Esc)<br>De(Backspace)</p></blockquote></li></ul><table><thead><tr><th align="left">指令</th><th align="left">作用</th><th align="left">摘要</th></tr></thead><tbody><tr><td align="left">C-x C-s</td><td align="left">保存文件</td><td align="left">保存</td></tr><tr><td align="left">C-x C-w</td><td align="left">使用其他文件名另存为文件</td><td align="left">另存为</td></tr><tr><td align="left">C-x C-f</td><td align="left">“find”文件, 即在缓冲区打开/新建一个文件</td><td align="left">新建</td></tr><tr><td align="left">C-z</td><td align="left">挂起emacs</td><td align="left">挂起</td></tr><tr><td align="left">C-x C-c</td><td align="left">关闭emacs</td><td align="left">关闭</td></tr><tr><td align="left">C-x i</td><td align="left">在当前光标处插入文件</td><td align="left">插入</td></tr><tr><td align="left">C-x C-v</td><td align="left">关闭当前缓冲区文件并打开新文件</td><td align="left">关闭缓冲区</td></tr><tr><td align="left">C-x b</td><td align="left">新建/切换缓冲区</td><td align="left">新建缓冲区</td></tr><tr><td align="left">C-x C-b</td><td align="left">显示缓冲区列表</td><td align="left">缓冲区信息</td></tr><tr><td align="left">C-x k</td><td align="left">关闭当前缓冲区</td><td align="left">关闭缓冲区</td></tr><tr><td align="left">M-n</td><td align="left">重复执行后一个命令n次</td><td align="left">宏</td></tr><tr><td align="left">C-d</td><td align="left">删除(delete)后一个字符</td><td align="left">删除字符</td></tr><tr><td align="left">M-d</td><td align="left">删除后一个单词</td><td align="left">删除字符串</td></tr><tr><td align="left">C-k</td><td align="left">移除(kill)一行</td><td align="left">删除行</td></tr><tr><td align="left">C-g</td><td align="left">停止当前运行/输入的命令</td><td align="left">停止</td></tr><tr><td align="left">C-x u</td><td align="left">撤销前一个命令</td><td align="left">撤销</td></tr><tr><td align="left">C-s</td><td align="left">向后搜索</td><td align="left">搜索</td></tr><tr><td align="left">C-r</td><td align="left">向前搜索</td><td align="left">搜索</td></tr><tr><td align="left">M-x shell</td><td align="left">打开shell模式</td><td align="left">shell</td></tr></tbody></table><hr><p><strong>帮助指令:</strong></p><table><thead><tr><th align="left">指令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">C-h c</td><td align="left">显示快捷键绑定的命令</td></tr><tr><td align="left">C-h k</td><td align="left">显示快捷键绑定的命令和它的作用</td></tr><tr><td align="left">C-h l</td><td align="left">显示最后100个键入的内容</td></tr><tr><td align="left">C-h w</td><td align="left">显示命令被绑定到哪些快捷键上</td></tr><tr><td align="left">C-h f</td><td align="left">显示函数的功能</td></tr><tr><td align="left">C-h v</td><td align="left">显示变量的含义和值</td></tr><tr><td align="left">C-h b</td><td align="left">显示当前缓冲区所有可用的快捷键</td></tr><tr><td align="left">C-h t</td><td align="left">打开emacs教程</td></tr><tr><td align="left">C-h i</td><td align="left">打开info阅读器</td></tr><tr><td align="left">C-h C-f</td><td align="left">显示emacs FAQ</td></tr><tr><td align="left">C-h p</td><td align="left">显示本机Elisp包的信息</td></tr></tbody></table><hr><h3 id="其它"><a href="#其它" class="headerlink" title="其它:"></a>其它:</h3><p><strong>指令集类型一共可以分为七种类型(具体可参考参考资料):</strong></p><ol><li>基本快捷键(Basic)</li><li>光标移动基本快捷键(Basic Movement)</li><li>编辑(Editint)</li><li>重要快捷键(Important)</li><li>在线帮助(Online-Help)</li><li>搜索/替换(Seach/Replace)</li><li>使用正则表达式(Regular expression)搜索/替换</li><li>窗口命令(Window Commands)</li><li>书签命令(Bookmark commands)</li><li>Text</li><li>Telnet</li><li>DIRectory EDitor (dired)</li><li>Shell</li><li>宏命令(Macro-commands)</li><li>编程(Programming)</li><li>GDB(调试器)</li><li>版本控制(Version Control)</li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>官方网站<a href="https://www.gnu.org/software/emacs/emacs.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/emacs.html</code></p></blockquote></li><li><p>官方手册<a href="https://www.gnu.org/software/emacs/manual/html_mono/emacs.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/emacs.html</code></p></blockquote></li><li><p>Emacs Lisp<a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/elisp.html</code></p></blockquote></li><li><p>获取地址:<a href="https://www.gnu.org/software/emacs/download.html#gnu-linux" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/download.html#gnu-linux</code></p></blockquote></li><li><p>国内社区<a href="https://emacs-china.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://emacs-china.org/</code></p></blockquote></li><li><p>apt-get获取</p><blockquote><p><code>apt-get -y install emacs</code><br>插件和拓展的配置与安装本章节不会多做赘述</p></blockquote></li><li><p>spacemacs仓库/获取地址<a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs</code></p></blockquote></li><li><p>spacemacs获取方式</p><blockquote><p><code>git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d</code></p></blockquote></li></ul><hr><p><strong>其它指令参考网站:</strong></p><ul><li><p>CN-2015-Emacs常用基本快捷键<a href="https://gist.github.com/shijinkui/2048195" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://gist.github.com/shijinkui/2048195</code></p></blockquote></li><li><p>CN-2008-Emacs快捷键列表<a href="https://aifreedom.com/technology/112" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://aifreedom.com/technology/112</code><br>这个相当详细</p></blockquote></li><li><p>CN-2019-Emacs常用快捷键一览<a href="https://qiutedyuan.github.io/blog/2019/06/12/Emacs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%80%E8%A7%88/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://qiutedyuan.github.io/blog/2019/06/12/Emacs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%80%E8%A7%88/</code></p></blockquote></li></ul><hr><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></p><p><a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></p><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><ul><li>2020-02-21<blockquote><p>20.46</p></blockquote></li></ul><hr><h3 id="Spacemacs"><a href="#Spacemacs" class="headerlink" title="Spacemacs"></a>Spacemacs</h3><p><strong>spacemacs参考资料</strong></p><ul><li><p>其它功能拓展与插件</p></li><li><p>代码补全</p><blockquote><p>自动补全 (company mode)</p></blockquote></li><li><p>语法高亮</p><blockquote><p>语法高亮 (Org-mode)</p></blockquote></li><li><p>其它工具</p><blockquote><p>major mode<br>minor mode</p></blockquote></li><li><p>编程/编译环境</p></li></ul><hr><p><strong>参考文献:</strong></p><ul><li><p>中文社区<a href="https://emacs-china.org/c/spacemacs" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://emacs-china.org/c/spacemacs</code></p></blockquote></li><li><p>EN-文档<a href="https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org</code></p></blockquote></li><li><p>代码仓库<a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="noopener">跳转</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/syl20bnr/</span>spacemacs</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/syl20bnr/</span>spacemacs.git</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>EN-Wiki<a href="https://en.wikipedia.org/wiki/Spacemacs" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://en.wikipedia.org/wiki/Spacemacs</code></p></blockquote></li><li><p>技术博客子龙山人</p><blockquote><p><code>https://zilongshanren.com/</code></p></blockquote></li><li><p>CSND某博客<a href="https://blog.csdn.net/csfreebird/article/details/52744771" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/csfreebird/article/details/52744771</code></p></blockquote></li></ul><hr><h3 id="相关工具整理"><a href="#相关工具整理" class="headerlink" title="相关工具整理:"></a>相关工具整理:</h3><ul><li><p>zsh</p><blockquote><p>Z shell(Zsh)是一款可用作交互式登录的shell及脚本编写的命令解释器<br>Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能<br>实现工具: <code>oh-my-zsh</code></p></blockquote></li><li><p>参考网站:<a href="https://www.jianshu.com/p/d194d29e488c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/d194d29e488c</code></p></blockquote></li><li><p>Python管理工具</p><blockquote><p>pyenv<br>pyenv virtualenv</p></blockquote></li><li><p>其它工具</p><blockquote><p>nvm<br>npm</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Emacs-1&quot;&gt;&lt;a href=&quot;#Emacs-1&quot; class=&quot;headerlink&quot; title=&quot;Emacs-1&quot;&gt;&lt;/a&gt;Ema
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
