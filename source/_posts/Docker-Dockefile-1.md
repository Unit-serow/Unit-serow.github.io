---
title: Docker Dockefile-1
date: 2020-02-07 16:44:44
tags: Docker
categories: [软件,虚拟化]
---

### Dockerfile

**概述:**
* Dockerfile是用于构建镜像的文本文件
* 文本内容包含构建镜像所需的指令和说明

**关于上下文的概念:**
* 上下文路径，是指Docker在构建镜像时如果需要使用到本机内的文件(比如复制)，`docker build`命令得知所指定的路径后，会将该路径下的所有内容打包
* Docker的运行模式是C/S，主机为C，Docker引擎是S
* 实际的构建过程是在Docker引擎内完成的，所以此时无法调用到本机内的文件，此时就需要人为的把本机指定目录下的所有文件打包，并提供给Docker引擎进行调用
* 如果未说明最后一个参数(未指定上下文所在路径)，那么默认上下文路径就是Dockerfile所在的目录下
* 上下文路径下所有的文件都会打包给Docker引擎，如果无用文件过多的话会造成执行过程缓慢

---

**Dockerfile内的基本指令**

1. **FROM**
* 定制的镜像都是基于FROM的镜像，在选择完要定义的基础镜像之后，后续的操作都是基于该基础镜像的
* 格式:
> `FROM <所选基础镜像名>`

---

2. **RUN** 
* 用于执行后面跟着的命令行命令，有两种格式
> Shell格式: RUN [命令行命令]
> Exec格式: RUN ["可执行文件", "参数一", "参数二"]
* Dockefile每次执行指令都会在docker上新建一层，多余的层会造成镜像膨胀
* 可以用&&符号来连接命令，从而不进行指令的线性执行，目的就是让所有的指令都集成到一层内
```
RUN xxx \
   && xxx \
   && xxx
```

3. **CMD**
* 类似于`RUN`指令，用于运行程序
* 二者的区别在于其运行的时间点不同:
> `CMD`在`docker run`时运行
> `RUN`是在`docker build`时运行
* 作用:
> 为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束
> `CMD`指令指定的程序可被`docker run`命令行参数中指定要运行的程序所覆盖
* 格式:
```
CMD <shell 命令> 
CMD ["<可执行文件或命令>","<param1>","<param2>",...] 
CMD ["<param1>","<param2>",...]
```
> 第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是`.sh`，所以可以直接使用第二种格式
> `最后一种写法是为`ENTRYPOINT`指令指定的程序提供默认参数`

4. **ENTRYPOINT**
* 类似于`CMD`指令，但其不会被`docker run`的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给`ENTRYPOINT`指令指定的程序
* 但如果运行`docker run`时使用了`--entrypoint`选项，此选项的参数可当作要运行的程序覆盖`ENTRYPOINT`指令指定的程序
* 特点就是在执行`docker run`的时候可以指定`ENTRYPOINT`运行所需的参数
* 但如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效
* 格式:
> `ENTRYPOINT ["<executeable>","<param1>","<param2>",...]`
* 还可以搭配`CMD`命令使用:一般是变参才会使用`CMD`，这里的`CMD`等于是在给`ENTRYPOINT`传参

* 这里假设已有了某镜像
```
FROM 某镜像

ENTRYPOINT ["<某镜像>", "-c"] #定参
CMD ["</执行脚本所在文件目录>"] #变参 
```
* 不传参运行
> `$ docker run  <某镜像>`
* 此时容器内会默认(等于)运行以下命令，启动主进程
> `<某镜像> -c </执行脚本所在文件目录>`
* 传参运行
> `$ docker run <某镜像> -c </执行脚本所在文件目录>`
* 容器内会默认(等于)运行以下命令，启动主进程`(/执行脚本所在文件目录:假设容器内已有此文件)`
> `<某镜像> -c </执行脚本所在文件目录>`
* 简述
> 指定了参数以后可以选择以传参或不传参的模式启动
> 不用传参就是直接启动所键入命令，用传参就是使用已指定的参数

---

5. **COPY**
* 用于复制的指令，可以从上下文目录复制文件或者目录到容器内的指定路径
* 使用格式:
> `COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>`
> `COPY [--chown=<user>:<group>] ["<源路径1>",...  "<目标路径>"]`
* 参数说明:
> `[--chown=<user>:<group>]`为可选参数，可以让用户改变复制到容器内文件的拥有者和属组
> `<源路径>`用于表示源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足Go的`filepath.Match`规则
> `<目标路径>`用于在容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建

6. **ADD**
* ADD和COPY的使用格式一致
* 同样需求下，官方推荐使用COPY
* ADD的优缺点:
> ADD的优点:在执行`<源文件>`为`tar`压缩文件的话，压缩格式为`gzip`，`bzip2`以及`xz`的情况下，会自动复制并解压到`<目标路径>`
> ADD的缺点:在不解压的前提下，无法复制`tar`压缩文件，会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢
* 具体是否使用，可以根据所处情况是否需要自动解压来决定

---

7. **ENV**
* 用于设置与定义环境变量，定义之后可以直接使用环境变量
* 使用格式:
> `ENV <key> <value>`
> `ENV <key1>=<value1> <key2>=<value2>...`

* 以下示例设置`NODE_VERSION = 7.2.0`，在后续的指令中可以直接通过`$NODE_VERSION`进行引用
```
ENV NODE_VERSION 7.2.0

RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \
  && curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc"
```

8. **ARG**
* 构建参数，与`ENV`作用一致，不过作用域不一样，`ARG`设置的环境变量仅对`Dockerfile`内有效，也就是说只有`docker build`的过程中有效，构建好的镜像内不存在此环境变量
* 构建命令`docker build`中可以用`--build-arg <参数名>=<值>`来覆盖
* 使用格式：
> `ARG <参数名>[=<默认值>]`

---

9. **VOLUME**
* 定义匿名数据卷
* 在启动容器时忘记挂载数据卷，会自动挂载到匿名卷
* 可以避免重要的数据因容器重启而丢失
* 还可以避免容器不断变大
* 使用格式:
> `VOLUME ["<路径1>", "<路径2>"...]`
> `VOLUME <路径>`
* 在启动容器`docker run`的时候，可以使用参数`-v`修改挂载点

---

10. **EXPOSE**
* 用于声明端口
* 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射
* 在运行时使用随机端口映射时，也就是`docker run -P`时，会自动随机映射`EXPOSE`的端口
* 使用格式:
> `EXPOSE <端口1> [<端口2>...]`

---

11. **WORKDIR**
* 用于指定工作目录
* 用`WORKDIR`指定的工作目录，会在构建镜像的每一层中都存在(`WORKDIR`指定的工作目录，必须是提前创建好的)
* 在使用`docker build`构建镜像过程中的，每一个`RUN`命令都是新建的一层，只有通过`WORKDIR`创建的目录才会一直存在
* 使用格式:
> `WORKDIR <工作目录路径>`

12. **USER**
* 用于指定执行后续命令的用户和用户组，用于切换后续命令执行的用户(用户和用户组必须提前已经存在)
* 使用格式:
> `USER <用户名>[:<用户组>]`

---

13. **HEALTHCHECK**
* 用于指定某个程序或者指令来监控Docker容器服务的运行状态
* 使用格式:
> `HEALTHCHECK [选项] CMD <命令>`:设置检查容器健康状况的命令
> `HEALTHCHECK NONE`:如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令
> `HEALTHCHECK [选项] CMD <命令>` : 这个`CMD`后面跟随的命令使用，可以参考`CMD`的用法

---

14. **ONBUILD**
* 用于延迟构建命令的执行
* 简述:
> 在`Dockerfile`里用`ONBUILD`指定的命令，在本次构建镜像的过程中不会执行(假设镜像为test-build)
> 当有新的`Dockerfile`使用了之前构建的镜像`FROM test-build`，这是执行新镜像的`Dockerfile`构建时候，`会执行 test-build`的`Dockerfile`里的`ONBUILD`指定的命令
* 使用格式:
> `ONBUILD <其它指令>`
