<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-06T18:01:30.453Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LSP-2.2</title>
    <link href="https://unit-serow.github.io/2020/03/07/LSP-2-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/LSP-2-1/</id>
    <published>2020-03-06T17:59:36.000Z</published>
    <updated>2020-03-06T18:01:30.453Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Mar 07 2020 02:01:37 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用与库函数调用的执行检查与错误处理</strong></center><center><strong>UNIX/Linux-2.2</strong></center><a id="more"></a><h2 id="LSP-2-2"><a href="#LSP-2-2" class="headerlink" title="LSP-2.2"></a>LSP-2.2</h2><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-2</li></ul><hr><p><strong>涉及概念一览:</strong></p><ul><li>库函数基本检查</li><li>系统调用检查与错误处理</li><li>库函数调用检查与错误处理</li></ul><hr><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><ul><li><p>库函数即为存在于C 标准库内的任何函数，也可以称其为函数</p><blockquote><p>设计库函数的目的是为了提供比底层系统调用更方便的调用接口</p></blockquote></li><li><p>标准C语言函数库: GNU C 语言函数库(Glibc)</p><blockquote><p>标准C语言函数库的实现跟随UNIX的实现而异<br>GNU C语言函数库即为Linux上最常用的实现</p></blockquote></li><li><p>除了标准的函数之外通常还有其它的拓展函数uClibc与dietlibc</p><blockquote><p>uClibc: htttp://<a href="http://www.ulibc.org" target="_blank" rel="noopener">www.ulibc.org</a><br>dietlibc: <a href="http://www.fefe.de/detlibc" target="_blank" rel="noopener">http://www.fefe.de/detlibc</a></p></blockquote></li><li><p>因为Linux开发的大多数开发都只能用到Glibc，所以这里将不会对其它的拓展函数库进行过多讨论</p></li><li><p>查看当前系统的Glibc版本</p><blockquote><p>直接运行其glibc的共享库文件(可执行文件)，以获取版本<br><code>$ /lib/libc.so.6</code></p></blockquote></li><li><p>确定改库存放位置的方法之一:</p><blockquote><p>针对某个与glibc动态链接的可执行文件，运行ldd程序<br>然后再检查已输出的库依赖列表，便能发现glibc共享库所处于的位置<br><code>$ ldd myprog | grep libc</code></p></blockquote></li></ul><hr><ul><li>应用程序可以通过测试常量和调用函数库这两种方法来确定系统所安装的glibc版本及其详细信息<blockquote><p>从版本2.0开始，glibc定义了两个常量<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>，以供程序再编译时(在<code>#ifdef</code>语句中)测试使用<br>为了避免在同步机器上造成的版本不同而产生的参数差异所带来的种种问题，可以在程序内调用<code>gnu_get_libc_version()</code>来确定运行时的glibc版本</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/libc-version&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gnu_get_libc_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>而对于获取glibc版本信息，还有一种方法，即为使用<code>confstr()</code>函数来获取(glibc特有的)<code>_CS_GNU_LIBC_VERSION</code>配置变量的值<blockquote><p>其返回的字符串与上述实例相同</p></blockquote></li></ul><hr><h3 id="如何处理来自系统调用的错误与如何处理来自库函数的错误"><a href="#如何处理来自系统调用的错误与如何处理来自库函数的错误" class="headerlink" title="如何处理来自系统调用的错误与如何处理来自库函数的错误"></a>如何处理来自系统调用的错误与如何处理来自库函数的错误</h3><ul><li>几乎每个系统调用和库函数都会返回某类状态值，用以表明调用成功与否<blockquote><p>如果想要深入的了解调用是否成功，必须检查对状态值进行检查<br>若调用失败，则采取相应行动<br>所以让程序显示错误消息，以防止有意想不到的时间发生，是非常有必要的<br>但是还有少数几个系统调用函数在调用时从不会失败(例如<code>getppid()</code>总是能成功返回<code>进程的ID</code>，而<code>_exit()</code>总能终止进程，则无需对此类系统调用的返回值进行检查)</p></blockquote></li></ul><hr><p><strong>如何处理来自系统调用的错误:</strong></p><ul><li>每个系统调用的手册页记录有调用可能的返回值，并指出了哪些值表示错误<blockquote><p>通常，返回值为-1则表示出错，当处于此种情况下，可以使用下列代码对系统调用进行检查</p></blockquote></li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="keyword">open</span>(pathname, flags, mode); <span class="comment">/* system call to open a file */</span></span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to handle the error */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">close</span>(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to heandle the error */</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>当系统调用失败时，会将全局整形变量<code>errno</code>设为一个正值，以标识具体的错误</p><blockquote><p>程序(<code>#include</code>)包含<code>&lt;errno.h&gt;</code>头文件，该文件提供了对<code>errno</code>的声明，以及一组针对各种错误编号而定义的常量<br>所有这些符号名都以子字母E打头，在每个手册页内标题为<code>ERRORS</code>的章节内，都刊载有一份相应系统调用可能返回的<code>errno值</code>列表</p></blockquote></li><li><p>这里是利用<code>errno</code>来诊断系统调用错误的一个简单实例:</p></li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cnt</span> = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">cnt</span> == -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">errno</span> == EINTR)</span><br><span class="line">fpintf(stderr, <span class="string">"read was interrupted by a signal\n"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Some other error occurred */</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>如果调用系统函数和函数库成功，<code>errno</code>绝不会被重置为0，故此改变了值不为0，还有可能是因为之前的调用失败造成的</p><blockquote><p>此外，<code>SUSv3</code>允许在函数调用成功时，将<code>errno</code>设置为非零值(但是基于没有函数会这么做)<br>因此，在进行错误检查时，必须检查首先检查函数的返回值是否表明调用出错，然后再检查<code>errno</code>确定错误原因<br>少数系统调用(比如<code>getpriority()</code>)在调用成功后，也会<code>返回-1</code><br>所以在要判断此类系统调用是否发生错误，应在调用前将<code>errno</code>设置为0，并在调用后进行检查(以上所描述的手法同样适用于某些库函数)</p></blockquote></li><li><p>系统调用失败后，常见的做法之一就是根据<code>errno</code>值来打印错误消息，提供的库函数<code>perror()</code>和<code>strerror()</code>，就是处于此目的</p><blockquote><p>此实例中函数<code>perror()</code>会打印出其<code>msg参数</code>所指向的字符串，紧跟一条与当前<code>errno值</code>相对应的消息</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>以下是对系统调用错误进行错误的一种简单方式:</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(pathname, flags, mode);</span><br><span class="line"><span class="keyword">if</span> (fd == -<span class="number">1</span>) &#123;</span><br><span class="line">perror(<span class="string">"open"</span>)</span><br><span class="line"><span class="keyword">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>strerror()</code>会针对其<code>errnum</code>参数中所给定的错误号，返回相应的错误字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>由<code>strerror()</code>所返回的字符串可以是静态分配的，这意味着后续对<code>sterror()</code>的调用可能会覆盖该字符串</p><blockquote><p>若无法识别<code>errnum</code>所含的错误编号，则<code>strerror()</code>会返回<code>&quot;Unknown error nnn&quot;</code>形式的字符串<br>在某些其它的视线中，在这种情况下，<code>strerror()</code>会返回<code>NULL</code></p></blockquote></li><li><p>由于<code>perror()</code>和<code>sterror()</code>都属于对语言环境敏感(locale-sensitive)的函数，故而错误描述中使用的都是本地语言</p></li></ul><hr><p><strong>处理来自库函数的错误</strong></p><ul><li>不同的库函数在调用发生错误时，所返回的数据类型和值也各不相同(可以参见每个函数的手册页)</li><li>从错误的角度来讲，可以分为以下几类:</li></ul><ol><li>某些库函数返回错误信息的方式与系统调用完全相同，则<code>返回值为-1</code>，伴之以<code>errno号</code>来标识具体错误<blockquote><p><code>remove()</code>便是其中一例，可使用该库函数来删除文件(调用<code>unlink()</code>相同调用)或目录(调用<code>rmdir()</code>相同调用)<br>对此类函数所发生的错误进行诊断，其方式与系统调用完全相同</p></blockquote></li><li>某些库函数在出错时会<code>返回-1</code>之外的其他值，但仍会设置<code>errno</code>来表明具体的出错情况<blockquote><p>例如，<code>fopen()</code>在出错时会返回一个<code>NULL指针</code>，还会根据出错的具体底层相同调用来设置<code>errno</code><br>函数<code>perror()</code>和<code>sterror()</code>都可用来诊断此类错误</p></blockquote></li><li>还有一些函数根本不使用<code>errno</code>，对此类函数来说，确定错误存在与否及其起因的方法各不相同<blockquote><p>同样可见诸于相应函数的手册页中，不应使用<code>errno</code>，<code>perror()</code>或<code>strerror()</code>来诊断错误</p></blockquote></li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li>Linux/UNIX系统编程(上册)</li><li>参考自原书3.3-3.4章节</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Mar 07 2020 02:01:37 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用与库函数调用的执行检查与错误处理&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.2&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
      <category term="软件" scheme="https://unit-serow.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>LSP-2-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-2/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-2/</id>
    <published>2020-03-06T10:39:20.000Z</published>
    <updated>2020-03-06T10:48:01.174Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 18:49:13 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用概念及其执行逻辑叙述</strong></center><center><strong>UNIX/Linux-2.1</strong></center><a id="more"></a><h2 id="LSP-2-1"><a href="#LSP-2-1" class="headerlink" title="LSP-2.1"></a>LSP-2.1</h2><ul><li>LSP/Linux System Prorgramming-2</li></ul><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-1</li><li>系统编程先决条件及其执行逻辑整合文案-1</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>系统调用及其执行逻辑刨析</li><li>对已执行的调用进行检查</li><li>逻辑简述</li></ul><hr><ul><li>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律</li></ul><hr><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li><p>系统调用是受控的内核入口，因此机制，进程可以请求内核以自己的名义去执行某些动作</p></li><li><p>以应用程序编程接口(API)的形式，内核提供有一系列服务提供程序访问(包括创建新进程，执行I/O，以及为进程间通信创建管道等)</p></li><li><p>在深入系统调用的运作方式之前，需要对其进行关注的几个问题点</p></li></ul><ol><li>系统调用是将处理器从用户态切换到和心态，以便CPU访问受到保护的内核内存</li><li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识(程序通过名称来标识系统调用，此编号机制通常与其无关)</li><li>每个系统调用可辅之以一套参数，对用户空间(亦即进程的虚拟地址空间)与内核空间之间(相互)传递的信息加以规范</li></ol><ul><li><p>从编程的角度去理解，系统调用与C语言函数的调用很相似</p><blockquote><p>然而在系统调用时，其幕后会经理诸多步骤，接下来将会对该步骤的具体逻辑进行叙述:</p></blockquote></li><li><p>这里将硬件平台-<code>x86-32</code>为例，按事件发生的顺序对这些步骤加以分析</p></li></ul><ol><li>应用程序通过调用C语言函数库中的外壳(wrapper)函数，以发起系统调用</li><li>对系统调用中断处理的例程来说，外壳函数必须保证所有的系统调用参数可用<blockquote><p>通过堆栈，这些参数传入外壳函数，但内核却希望这些参数置于特定的寄存器<br>因此，外壳函数会将上述参数复制到寄存器</p></blockquote></li><li>由于所有系统调用进入内核的方式相同，内核需要设法区分每个相同调用<blockquote><p>为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器(%eax)中</p></blockquote></li><li>外壳函数执行一条中断机器指令(<code>int 0x80</code>)，引发处理器从用户态切换到和心态，并执行系统终端<code>0x80</code>(十进制数为128)的终端矢量所指向的代码<blockquote><p>在较新的<code>x86-32</code>硬件平台实现了<code>sysenter指令</code>，较之传统的<code>int 0x80</code>中断指令，sysenter指令进入内核的速度更快，2.6内核与glibc2.3.2以后的版本都支持<code>sysenter指令</code></p></blockquote></li><li>为相应中断<code>0x80</code>，内核会调用<code>system_all()</code>例程(位于汇编文件<code>arch/i386/entry.S</code>中)来处理这次中断，具体的处理逻辑与步骤如下:<blockquote><p>1-在内核栈中保存寄存器值(这里先不做阐述)<br>2-审核系统调用编号的有效性<br>3-以系统调用编号对存放所有调用服务例程的列表(内核变量<code>sys_call_table</code>)并进行索引，发现并调用相应的系统系统调用服务例程<br>3.1-若系统调用服务例程带有参数，那么将会首先检查参数的有效性<br>3.2-例如，会检查地址指向用户空间的内存位置是否有效<br>3.3-随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改<br>3.4-以及在用户内存和内核内存间传递数据(比如在I/O操作中)<br>3.5-最后，该服务例程会将结果状态返回给<code>system_call()</code>例程<br>4.-从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中<br>5.-返回值外壳函数，同时将处理器切换回用户态</p></blockquote></li><li>若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno<blockquote><p>然后，外壳函数返回一个整型值，以表明系统调用是否成功<br>在Linux上，系统调用服务例程所遵循的惯例是调用成功则返回负值<br>发生错误时，例程会对相应erron常量取反，则返回一个负值<br>C语言函数库的外壳函数即对其再次取反(此时负负得正)，将此结果拷贝至 errno<br>同时以-1作为外壳函数的返回值返回，以此向调用程序表明有错误发生<br>上述惯例所依赖的先决条件是系统调用服务例程，若调用成功则不会返回负值<br>可是对于少数例程来说，这一前提并不成立<br>一般情况下，这也不会有问题，因为取反的errno值范围不会与调用成功返回负值的范围有交集<br>不过还有一种情况沿用这个惯例确实会出问题: 系统调用<code>fcntl()</code>的<code>F_GETOWN</code>操作，这里先不做阐述</p></blockquote></li></ol><hr><ul><li>以相同调用<code>execve()</code>为例，此图片展示了上文叙述及事件的发生序列</li><li>在<code>Linux/x86-32</code>上，<code>execve()</code>的系统调用号为<code>11(__NR_execve)</code><blockquote><p>因此，在<code>sys_call_table</code>向量中，<code>条目11</code>包含了该系统调用的服务例程<code>sys_execve()</code>的地址</p></blockquote></li><li>在Linux中，系统调用服务例程的命名通常会采取<code>sys_xyz()</code>的形式，其中<code>xyz()</code>则是所论及的系统调用</li></ul><p><strong>系统调用的执行步骤图例</strong></p><img src="/images/系统调用-1.png" width="40%" height="40%"><hr><ul><li><p>在系统调用的实际情况中，通常不需要将概念掌握并理解的如此深刻</p><blockquote><p>但即便对于一个简单的系统调用，仍要完成相当多的工作<br>因此系统调用的开销虽然很小，却也不容忽视</p></blockquote></li><li><p>这里可以将getppid()系统调用为例，研判一下发起系统调用的开销:</p><blockquote><p>该系统调用只是简单地返回调用进程的父进程ID<br>此时在一台运行着<code>Linux 2.6.25</code>的<code>x86-32</code>系统上，调用<code>getppid()</code>一千万次大约需要<code>2.2秒</code>钟，每次调用大致需要<code>0.3微秒</code><br>相形之下，在同一系统上，调用某个只返回整数的C语言函数一千万次，仅需0.11秒，约为<code>getppid()</code>耗费时间的<code>1/20</code><br>当然，大多数系统调用的开销都明显高于<code>getppid()</code></p></blockquote></li></ul><hr><ul><li>因此，从C 语言编程的角度去看，调用C语言函数库的外壳函数等同于调用相应的系统调用服务例程<blockquote><p>在今后的章节里，调用系统调用<code>xyz()</code>这类说法即意味着: 调用外壳函数，然后再由外壳函数去调用系统调用<code>xyz()</code></p></blockquote></li><li>为调试程序，或是研究程序的运作机制，可以使用<code>stace命令</code>，以便对程序发起的系统调用进行跟踪</li><li>有关与Linux系统调用机制有关的信息可参见其它书籍: [Love，2010]，[Bovet &amp; Cesati，2005]以及[Maxwell，1999]</li></ul><hr><p><strong>相关概念整合:</strong></p><ul><li><p>系统编程概念</p></li><li><p>系统编程先决条件及其执行逻辑整合文案</p></li><li><p>系统编程概念</p><blockquote><p>系统编程先决条件整合文案<br>系统调用<br>执行逻辑<br>库函数<br>GNU Libc (Glibc-GNU C 标准库)<br>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律<br>已执行调用检查<br>库函数错误<br>系统条用错误<br>可移植性<br>特性测试宏<br>SUSv3中定义的标准系统数据类型</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>可参考URL目录</p></li><li><p>CN-CSDN-Linux系统调用手册<a href="https://blog.csdn.net/xtx1990/article/details/8173950" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/xtx1990/article/details/8173950</code></p></blockquote></li><li><p>CN-CSDN-linux常用系统调用简介<a href="https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>CN-个人博客-[译] Linux 系统调用权威指南（2016）<a href="https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/</code></p></blockquote></li><li><p>CN-百度文库-系统调用手册<a href="https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html</code></p></blockquote></li><li><p>CN-IBM-Linux系统调用列表<a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</code></p></blockquote></li></ul><p>CN-个人博客-Linux系统调用(syscall)原理<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://gityuan.com/2016/05/21/syscall/</code></p></blockquote><hr><ul><li><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a><blockquote><p>第三章节内容<br>PDF资源可参考文章OS-1<br>手册页-Linux系统调用<br>书籍-附录A</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 18:49:13 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用概念及其执行逻辑叙述&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LSP-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-1/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-1/</id>
    <published>2020-03-06T07:41:05.000Z</published>
    <updated>2020-03-06T07:56:52.591Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 15:57:02 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux内核与操作系统基本概念归纳</strong></center><center><strong>UNIX/Linux-1</strong></center><a id="more"></a><h2 id="LSP-1"><a href="#LSP-1" class="headerlink" title="LSP-1"></a>LSP-1</h2><ul><li>LSP/Linux System Prorgramming</li></ul><hr><h3 id="UNIX-Linux-1"><a href="#UNIX-Linux-1" class="headerlink" title="UNIX/Linux-1"></a>UNIX/Linux-1</h3><ul><li>内核与操作系统的相关基本概念归纳</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><p><strong>内核</strong></p><ul><li><p>内核概念</p><blockquote><p>操作系统的核心<br>内核在狭义范围内被理解为用于管理与分配计算机硬件资源(即CPU，RAM，设备等)的核心层软件<br>在没有内核的情况下，计算机也能运行程序<br>内核的作用是对其它程序的编写和使用进行简化(通常会产生极大的简化效果)<br>者一切都要归功于内核为管理计算机的有限资源所提供的软件层</p></blockquote></li><li><p>内核文件命名机制</p><blockquote><p><code>vmunix/</code><br><code>boot/vmlinuz</code><br>内核为经由压缩的可执行文件</p></blockquote></li></ul><p><strong>内核的存在意义与职责</strong></p><ul><li><p>进程调度</p><blockquote><p>通常计算机内存在着若干个CPU(中央处理单元)以执行程序命令<br>UNIX kernel system与UNIX-like(Linux) kernel system属于抢占式多任务系统<br>多任务意指多个进程(即运行中的程序)可同时驻留于内存，且每个进程都能够获得对CPU的使用权<br>抢占用于泛指一组规则，这组规则控制着指定进程对CPU的使用权与使用时间<br>以上两者均有内核进程调度程序(而非程序本身)决定</p></blockquote></li><li><p>内存管理</p><blockquote><p>由于硬件资源的有限且软件对其硬件资源的占用，使得物理内存(RAM)被定义为有限资源<br>内核的作用就是以公平且高效的方式在进程间共享这一资源<br>多数的现代操作系统(包括Linux)采用了虚拟内存管理机制<br>使得进程与进程之间，进程与内核之间彼此隔离，以防止进程读取或修改内核或其它进程中的内存内容<br>只需将进程的一部分保存在内存中，以降低每个进程对内存的需求量与实现在RAM中同时加载更多的进程<br>此方法大幅提升了在任意时刻的CPU都有至少一个进程可以执行，以使得对CPU资源的利用更加充分的情况</p></blockquote></li><li><p>文件系统提供</p><blockquote><p>内核在磁盘之上有提供文件系统，并且允许对文件系统执行创建，获取，更新以及删除等管理操作</p></blockquote></li><li><p>创建和终止进程</p><blockquote><p>内核可以将新程序载入内存，以为其提供运行所需的资源(比如CPU，内存以及对文件的访问等)<br>这样一个处于运行状态下的程序被称之为进程<br>一旦进程执行完毕，内核还要确保释放其占用的资源，以备后续程序重新使用</p></blockquote></li><li><p>对设备与其硬件的访问</p><blockquote><p>计算机的外界设备(人体学输入设备，磁盘或磁带驱动器等)可实现计算机与外部世界的通信<br>此通信机制包括输入，输出或两者兼而有之<br>内核即为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问</p></blockquote></li><li><p>联网的机制与其实现</p><blockquote><p>内核以用户进程的名义收发网络消息(数据包)<br>该任务包括将网络数据表路由至目标系统</p></blockquote></li><li><p>提供系统调用应用编程接口(API)</p><blockquote><p>进程可利用内核入口点(也可称其为系统调用)请求内核去执行各种任务<br>衍生概念: Linux系统内核调用API的方法与步骤，此概念将会在以后章节内进行详细刨析与实践</p></blockquote></li><li><p>通常情况下，多用户操作系统(例如Linux等)会为用户提供一种名为: 虚拟私有计算机(virtual private computer)的抽象概念</p></li><li><p>即为每个用户都可以登陆操作系统，并且其独立的操作与其它的用户大致无干(包括独立访问设备，独立运行程序，CPU，磁盘及其硬件资源独立分配等等)</p></li><li><p>此时的内核用于负责解决(多进程)访问硬件资源时可能引发的冲突，并且不对用户和进程产生任何层面的影响</p></li></ul><hr><p><strong>内核态与用户态</strong></p><blockquote><p>现代处理器架构一般允许CPI至少在两者不同的状态下允许<br>即为用户态与核心态(有时也可称之为监管态supervisor mode)<br>执行硬件执行可使得CPU在两者状态间来回切换<br>与之相对应的虚拟内存区域也可划分(标记)为用户空间部分与内核空间部分<br>在用户状态下运行时: CPU只能访问被标记为用户空间的内存，视图访问属于内核空间的内存会引发硬件异常<br>在内核状态下运行时: CPU既能访问用户空间内存，也能访问内核空间内存<br>内核状态下运行的处理器通常可以完成某些特定操作: 此特定操作包括了执行宕机(halt)，访问内存管理硬件，以及设备I/O操作的初始化等等<br>实现者们通常会利用这一硬件设计将操作系统置于内核空间以确保用户进程不能访问内核指令和数据结构，保证了其无法对操作系统执行不利于操作系统运行的操作<br>而程序员在进行日常的编程任务时有必要去习惯于利用面向进程(process-oriented)的思维方式来考虑编程问题<br>即以进程及内核的视角来检视系统</p></blockquote><hr><h3 id="Shell相关"><a href="#Shell相关" class="headerlink" title="Shell相关"></a>Shell相关</h3><ul><li>shell是用于读取用户输入指令并将其相对应的程序进行执行并相应的软件程序<blockquote><p>也可将其称之为命令解释器<br>术语: 登陆shell(login shell)用于特质用户刚登陆系统时，由系统创建，用以运行shell的进程<br>在某些操作系统内会将命令解释器集成于内核中，对于UNIX系统而言，shell只是一个用户进程<br>在UNIX系统的历史中出现过的重要shell: Bourne shell (sh)，C shell (csh)，Korn shell (ksh，bash)等等<br>分别对应了UNIX，BSD，Linux等等</p></blockquote></li></ul><hr><h3 id="操作系统层面相关概念列表"><a href="#操作系统层面相关概念列表" class="headerlink" title="操作系统层面相关概念列表"></a>操作系统层面相关概念列表</h3><ul><li>用户和组-操作系统层面概念</li><li>单根目录层级-操作系统层面概念</li><li>目录-操作系统层面概念</li><li>链接/路径和链接/符号链接-操作系统层面概念</li><li>文件/链接文件/文件类型/文件命名/文件的所有权与权限(相对于用户与操作系统)-操作系统层面概念</li><li>路径/路径命名-操作系统层面概念</li><li>当前工作目录-操作系统层面概念</li><li>文件[I/O模型]/文件描述符-操作系统层面概念</li><li>stdio函数库(C语言在执行文件I/O操作时，通常会调用C标准库内的I/O函数，也可将I/O函数称为stdio函数库)，stdio函数位于I/O系统调用层之上-操作系统层面概念</li></ul><hr><p><strong>程序-操作系统层面概念</strong></p><ul><li><p>程序的存在形式与概念:</p><blockquote><p>程序在现实中的实现可分为两种形式: 源码文件与二进制文件<br>源码文件在执行程序时需要先将其转换(编译和链接处理)为二进制文件，即机器可以理解的二进制机器语言指令</p></blockquote></li><li><p>脚本</p><blockquote><p>脚本是包含命令的文本文件，它可以由shell或其它命令解释器之类的程序直接处理</p></blockquote></li><li><p>有关程序的相关概念列表:</p><blockquote><p>过滤器<br>命令行参数</p></blockquote></li></ul><hr><p><strong>进程</strong></p><ul><li><p>进程的概念与存在意义:</p><blockquote><p>进程即为正在执行的程序实例<br>在程序执行时，内核会将程序的源码载入虚拟内存，以为程序变量分配空间，建立内核记账(bookkeeping)数据结构<br>由此记录进程有关的各种信息(如: 进程ID，用户ID，组ID及其终止状态等)</p></blockquote></li><li><p>在内核的角度去观察进程</p><blockquote><p>进程是一个个实体，内核必须在它们之间共享各种计算机资源<br>以实现让所有的可再生资源在进程间进行平等的资源共享</p></blockquote></li><li><p>进程相关概念列表</p><blockquote><p>进程的内存布局</p></blockquote></li><li><p>逻辑上可以将某一个内存划分为这几部分(也可称为几段):</p><blockquote><p>文本: 程序的指令<br>数据: 程序使用的静态变量<br>堆: 程序可以从该区域动态分配额外内存<br>栈: 随机函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间</p></blockquote></li><li><p>进程相关的基础概念列表:</p></li><li><p>创建进程</p></li><li><p>创建可执行程序</p></li><li><p>进程ID</p></li><li><p>父进程ID</p></li><li><p>进程终止与终止状态</p></li><li><p>进程的用户和组标识符</p></li><li><p>特权进程</p></li><li><p>能力(概念-Capabilities/始于Linux kernel-v2.2)</p></li><li><p>init进程</p></li><li><p>守护进程</p></li><li><p>环境列表</p></li><li><p>资源限制</p></li></ul><hr><p><strong>内存映射</strong></p><ul><li>内存映射基本概念及其实现方法:<blockquote><p>调用系统函数<code>mmap()</code>的进程，会在其虚拟地址空间中创建一个新的内存映射</p></blockquote></li><li>内存映射可分为以下两类:</li></ul><ol><li>文件映射: 将文件的部分区域映射入调用进程的虚拟内存<blockquote><p>调用一旦完成，对文件映射内容的访问则转化为对应相应内存区域的字节操作，映射页面对按需自动从文件中加载</p></blockquote></li><li>相映成趣的是并无文件与之相应的匿名映射，其映射页面的内容会被初始化为0</li></ol><ul><li>由某一进程所映射的内存可以与其它进程的映射共享，而共享的方式通常有两个:</li></ul><ol><li>两个进程都针对某一文件的相同部分加以映射</li><li>由<code>fork()</code>创建的子进程自父进程处继承映射</li></ol><ul><li>内存映射有关概念:<blockquote><p>内存内容填充量分配<br>文件(I/O)，即映射内存I/O<br>进程间通信(通过内存共享映射)</p></blockquote></li></ul><hr><p><strong>静态库和共享库</strong></p><ul><li><p>所特指目标库的概念:</p><blockquote><p>所谓的目标库文件就是: 将(通常是逻辑相关的)一组函数代码加以编译，并置于一个文件中，以供其它程序调用的文件<br>此方法通常有利于程序的开发与维护</p></blockquote></li><li><p>现代UNIX系统提供两种类型的对象库: 静态库和共享库</p></li><li><p>静态库</p><blockquote><p>有时也可称之为档案文件[archives]，是早期UNIX系统中唯一的一种目标库<br>从本质上来讲，可以将静态库描述为: 是对已编译目标模块的一种结构化整合<br>使用静态库时需要在创建程序的链接命令中指定相应的库<br>主程序会在之后对静态库中隶属于各目标模块的不同函数加以引用<br>对于细节这里先不做过多描述，此后的章节内会对其进行具体且完整的刨析与使用和实践</p></blockquote></li><li><p>共享库</p><blockquote><p>共享库存在的意义亦在解决静态库所存在的问题<br>如果将程序链接到共享库，那么此时的链接器就不会把库中的目标模块复制到执行行文件中，而是在可执行文件中写入一条记录，用以表名可执行文件在运行时需要使用该共享库<br>在运行时将可执行文件载入内存的同时会由一个名为动态链接器的程序进行同步执行，以确保将可执行文件所需的动态库找到，并载入内存<br>随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中的函数定义相关联起来<br>在运行时的共享库代码在内存中秩序保存一份，且可供所有运行中的程序使用<br>且经过编译处理的函数仅在共享库内保存一份以解决磁盘空间<br>此设计还能确保各类程序在编译时会及时使用到函数的最新版本，即只需将带有函数新定义的共享库重新加以编译即可，程序将会在下次执行时自动使用新函数</p></blockquote></li></ul><hr><p><strong>进程间通信及其同步</strong></p><ul><li><p>Linux系统上运行有多个进程，其中许多都是独立运行</p><blockquote><p>然而有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制</p></blockquote></li><li><p>读写磁盘文件中的信息是进程通信的方法之一</p><blockquote><p>可是这种方法对于许多程序来说既慢又缺乏灵活性<br>因此，Linux像所有现代UNIX系统所实现的那样去提供了丰富进程间通信的IPC机制</p></blockquote></li><li><p>IPC机制相关概念列表/相关作用及其存在意义:</p><blockquote><p>信号(signal)，用于表示实践的发生<br>管道(即shell用户中的”|”)操作符和FIFO，用于在进程间传递数据<br>套接字，用于为同一台主机或是联网的不同主机上所允许的进程之间传递数据<br>文件锁定，用于防止其它进程读取或更新文件内容，同时运行某进程对文件的部分区域加以锁定<br>消息队列，用于在进程之间交换消息(数据包)<br>信号量(semaphore)，用于同步进程动作<br>共享内存，用于运行两个及两个以上的进程共享同一块内存</p></blockquote></li><li><p>就本质而言，FIFO和UNIX套接字的功能几近相同，即允许统一系统上并无关联的进程间彼此交换数据</p></li><li><p>两种可以并存于现在UNIX系统之中是由于FIFO来自System V，而套接字则源于BSD</p></li><li><p>IPC相关概念:</p><blockquote><p>对于信号及对其的深入刨析与讨论(依旧在后续章节对其实现与刨析)</p></blockquote></li></ul><hr><p><strong>线程</strong></p><ul><li><p>线程的基本概念描述:</p><blockquote><p>在现代UNIX实现中，每个进程都可执行多个线程<br>可将线程的概念比喻为共享同一虚拟内存及一干其它属性的进程<br>每个线程都会执行相同的程序代码，共享同一数据区域和堆<br>并且在同时，每个线程都拥有属于自己的栈，用以装载本地变量和函数调用等链接信息<br>线程之间可通过共享的全局变量进行通信<br>此外，利用上面所描述的IPC和同步机制，线程之间也能够彼此通信</p></blockquote></li><li><p>线程的优点:</p><blockquote><p>线程的优点就在于协同线程之间的数据共享(通过全局变量)更为容易<br>而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然<br>再者就是多线程应用能从多处理器硬件的并行处理中受益匪浅</p></blockquote></li><li><p>有关线程的相关概念列表:</p><blockquote><p>进程组<br>shell任务控制机制<br>会话机制<br>控制终端机制<br>控制进程机制</p></blockquote></li></ul><hr><p><strong>其它操作系统层面的相关概念:</strong></p><ul><li><p>伪终端，是一对相互连接的虚拟设备，也可称之为主从设备</p><blockquote><p>在这对设备之间，设有一条IPC信道以供数据之间进行双向传递<br>并且从设备(slave device)所提供的接口，其行为方式与终端相类似<br>最知名的伪终端要数telnet和ssh之类提供网络登陆服务的应用，以及 x window 系统所提供的终端窗口实现</p></blockquote></li><li><p>日期和时间</p><blockquote><p>进程涉及两种类型时间: 真实时间与进程时间(即为CPU时间，指自进程启动而来，所占有的CPU时间总量)<br>还可进一步的将CPU时间划分为系统CPU时间和用户CPU时间，前者用于指内核模式中执行代码所占用的时间，后者用于指在用户模式中执行代码所占用的时间<br>time命令会显示出真实时间，系统CPU时间，以及执行管道中的多个线程而花费的用户CPU时间</p></blockquote></li><li><p>客户端/服务器架构</p><blockquote><p>即C/S架构<br>这里不做过多赘述</p></blockquote></li><li><p>实时性</p><blockquote><p>纯粹性概念，字面理解<br>关于实时性概念的实现与对其的具体定义这里不做过多赘述</p></blockquote></li><li><p><code>/proc</code>文件系统</p><blockquote><p>在Linux中实现并且提供了类似于其它的现代UNIX系统中的<code>/proc</code>文件系统<br>由一组目录和文件所组成，装配(mount，或称其为挂载)于<code>/proc</code>目录下<br><code>/proc</code>文件系统是一种虚拟文件系统，以文件系统目录和文件形式来提供一个指向内核数据结构的接口<br>以用于用户查看，改变和管理各种系统属性<br>关于/proc文件系统的内容这里先不做过多赘述，今后的章节内会进行刨析与实践</p></blockquote></li></ul><hr><p><strong>本章节所涉及的相关概念归纳</strong></p><ul><li>涉及概念一览(完整版本)</li><li>UNIX/Linux kernel</li><li>操作系统</li><li>shell/shell任务控制</li><li>文件</li><li>I/O模型</li><li>程序</li><li>进程/进程间通信与进程间同步</li><li>信号</li><li>线程</li><li>进程组</li><li>会话</li><li>内存/内存映射</li><li>静态库</li><li>共享库</li><li>终端控制</li><li>进程控制</li><li>伪终端</li><li>日期及时间</li><li>C/S-客户端/服务器架构</li><li>实时性</li><li><code>/proc</code>文件系统</li></ul><p><strong>本章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>所有涉及的文献资料皆来源于电子书籍</p></li><li><p><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a></p><blockquote><p>第二章节内容<br>PDF资源可参考文章OS-1</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 15:57:02 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux内核与操作系统基本概念归纳&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>自由</title>
    <link href="https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/"/>
    <id>https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/</id>
    <published>2020-03-06T04:32:03.000Z</published>
    <updated>2020-03-06T04:33:29.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --><center><strong>自由-主观</strong></center><a id="more"></a><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><ul><li>论题三大核心: 自由/纯粹/智慧</li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>自由/纯粹自由</li><li>理智/纯粹理智</li><li>本能/纯粹本能</li><li>智慧/纯粹智慧</li></ul><hr><p><strong>论题:</strong></p><ul><li>什么是自由</li><li>自由从从何而来</li><li>自由的本质是什么</li></ul><hr><p><strong>引论:</strong></p><ul><li>如何定义自由</li><li>对于自由的主观定义</li><li>所谓的自由</li><li>自由于精神层面的理解</li><li>自由于现实层面的实现</li><li>为何要去实现或追求自由</li></ul><hr><h3 id="人类-1"><a href="#人类-1" class="headerlink" title="人类-1"></a>人类-1</h3><p><strong>论题推论:</strong></p><ul><li>什么是自由</li><li>自由从何而来</li><li>自由的本质是什么</li></ul><p><strong>什么是自由?/自由从何而来?/自由的本质是什么?</strong></p><ul><li><p>自由源于人类的本质与天性，所谓天性，即为因存在于现实世界而产生的本能性质的无智逻辑(如果以具备智慧层面的生物来定义，也可称此为无逻辑)</p></li><li><p>但世事皆有因果，万物皆成逻辑(这里将不会过多的带入无的相关与衍生概念)</p></li><li><p>无智逻辑(亦可将其称之或理解为环境逻辑与自然逻辑)</p></li><li><p>存在即现实</p><blockquote><p>世界(即环境)源于空，空源于无<br>任何现实事物的本质来源于世界与环境，包括生命与智慧<br>生命是一切存在于现实的前提，但生命不会定义存在，而智慧可以定义存在<br>存在只是作为存在而存在于现实，概念将归于空-0<br>而当现实的存在被[定义]为存在于现实时，概念将归于世界，即为有-1<br>无即为无</p></blockquote></li><li><p>对于自由的主观定义</p><blockquote><p>在人类的存在还没有被定义之时，生物(即现实层面)的本质就早已被世界或环境所定义<br>此概念的逻辑为无智慧逻辑，也可将其定义于空，将不会产生任何讨论意义<br>此层面逻辑定义了人类于现实层面(世界)内最基本的性质，即存在(生命)<br>而伴随生命而存在的其它事物-现实，世界，无智逻辑(环境逻辑)<br>此间的现实中不存在于秩序，规则与存在等智慧层面的逻辑与概念</p></blockquote></li><li><p>存在即现实</p><blockquote><p>而自由与自由的概念所产生的本质皆来源于此刻<br>为什么会存在自由，有关自由的一切概念从何而来<br>自由来源于本质，而本质来源于环境与世界，世界源于空</p></blockquote></li><li><p>至此，引出我对自由的主观定义</p><blockquote><p>自由虽源于空，但绝不是凭空出现的<br>自由只是人类/生物于现实世界间所产生与拥有的本质<br>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面<br>或称为自由存在于现实层面，由此被智慧定义</p></blockquote></li><li><p>自由有可能可以被归于纯粹层面，即纯粹自由/本质(本能)自由</p><blockquote><p>自由是无智的逻辑，归于本质与本能，是人类永远不可能抛离的概念与本质<br>但人类拥有智慧，智慧可以定义与控制本质与本能<br>智慧存在于现实或精神层面之间的意义，即为定义本能或称[一切存在于世界之间的概念]<br>自由源于空，源于世界，源于本质，但绝对不会[源]于智慧<br>追求本质也是人类作为生物而存在于现实间的本质<br>一切概念与现实皆源于空，即存在-源于空</p></blockquote></li><li><p>存在即现实</p><blockquote><p>存在于现实间的本质与基本的条件/逻辑/概念—即为生命<br>即-生命归于现实，现实归于本质(人类)，本质归于空<br>至此自由是同存在/生命而存在与现实的<br>即人类/生物的本质即为存在，存在则为自由-[无规则(无秩序)/空-无]<br>人类源于空/无，人类/生物的本质即为空/无<br>自由是无概念概念，前者的概念为无，后者的概念为智慧所定义的概念<br>由源于空/源于无，自由是由无智时期就存在于现实间的概念</p></blockquote></li><li><p>生命与自由是人存在于现实的本质，本质即为无智逻辑</p><blockquote><p>于空或无间定义的概念，存在于现实间的人类或生物将永远无法抛离<br>不存在即为无意义，将不会产生任何讨论的意义<br>但不存在于现实可以进行讨论，这里先不进行讨论</p></blockquote></li><li><p>我目前还没有找到我想要找到的答案……</p><blockquote><p>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面 <?>自由存在于现实层面，由此被智慧定义 <?> 迷惑概念<br>主观的现实逻辑混乱，有一些概念只可意会，无法言传<br>或称为我的主观智慧层次与逻辑层次未到足矣将其以言传之的境界</p></blockquote></li></ul><hr><p><strong>引论答案:</strong></p><ul><li><p>如何定义自由</p></li><li><p>对于自由的主观定义</p><blockquote><p>自由于主观智慧被定义为无逻辑概念</p></blockquote></li><li><p>所谓的自由</p></li><li><p>自由于精神层面的理解</p></li><li><p>自由于现实层面的实现</p></li><li><p>为何要去实现或追求自由</p><blockquote><p>自由源于本质，本质源于现实，讨论于智慧层面间的存在等概念将不会产生任何存在意义<br>现实源于空，空源于无</p></blockquote></li></ul><hr><ul><li><p>一切皆归于无，一切皆可定义为无</p><blockquote><p>逻辑漏洞/逻辑死角/逻辑缺口<br>或称为现实(世界/环境)漏洞/现实缺陷<br>世界也可将其主观的定义为宇宙(现实)</p></blockquote></li><li><p>无</p><blockquote><p>现实逻辑漏洞，有待思考……</p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li><p>如何实现自由，现实间的自由为何物？</p></li><li><p>为何要去实现与追求自由？</p></li><li><p>自由来源于本能，同时将终于智慧</p><blockquote><p>智慧与理智的产物-规则与秩序<br>限制了所谓的自由(即本能)<br>自由所带来的结果必然与智慧(最基本且必然的产物: 规则/秩序)相对<br>当然，由资本所带来的规则与秩序是极度不堪与肮脏的<br>纯粹的智慧终究会产生最精密的逻辑与最极端的规则与秩序<br>而拥有与持续规则与秩序的最基本的条件与概念为-[理智]<br>理智是完全相对于本能的，相对于生物的(与之完全对立且相反，这里称其为相对)<br>或称其是完全且绝对相对于低等/低智能或无智能生物的</p></blockquote></li><li><p>规则与秩序的最基本条件是理智，同时来源于智慧</p><blockquote><p>一味的追求本能与自由的后果即为-停止前进/进化<br>本能与智慧-自由与秩序-滞留与进化<br>自由在理智与智慧的层面是无意义的，是愚昧的，是与之完全/绝对相对的<br>但在本质与本能的层面是完全合理的，是必然的，是完全符合无智逻辑的，是完全正确的</p></blockquote></li><li><p>人类的本质是社会性的</p><blockquote><p>而现有/现实存在的人类/生物的最高进化概念即为-共产主义<br>智慧，理智与秩序最高的社会性形态即为共产主义社会<br>共产主义不会脱离社会性(或称共产主义就是完全建立在社会性的基础上的)，即绝对且完全不会去尝试抛离本能(抛离本能的概念将不存在于现实)<br>而共产主义的弊端即为-此概念是近乎抛离本能的(非本质)，所以成为纯粹共产主义者的前提-就是拥有绝对且成熟的理智与纯粹的智慧<br>抛离本能带来的最终结果即为-抛离自由-共产主义者的自由将必然会被社会性/所处共产主义社会形态所完全(或称绝对)剥夺</p></blockquote></li><li><p>纯粹共产主义社会没有自由可言</p><blockquote><p>因为每一个独立者都将拥有最绝对的理智与最纯粹的智慧<br>它们将不乞求于自由<br>它们将抛离生物的本能(非本质)<br>目前看来…<br>它们…注定不会是存在于现实间的人类…<br>生产力完全充足之时，将有可能实现？<br>不<br>只有当人类完全抛离生而为人/为生物的本质之时<br>才有可能实现<br>此概念将抛离于现实</p></blockquote></li><li><p>人类实现共产主义…</p><blockquote><p>机械智能能否实现共产主义？<br>只有纯粹的精神意识体，能够实现所谓的纯粹共产主义-即纯粹理想主义<br>纯粹理想主义的概念为非现实概念(即便有可能存在于现实)</p></blockquote></li><li><p>纯粹-纯粹自由/纯粹共产主义</p></li></ul><p><strong>至此</strong></p><hr><ul><li>下一论题<blockquote><p>规则与秩序</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;自由-主观&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>UNIX/PIPE-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/PIPE-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/PIPE-1/</id>
    <published>2020-03-05T06:37:00.000Z</published>
    <updated>2020-03-06T08:00:26.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 16:00:37 GMT+0800 (中国标准时间) --><center><strong>UNIX-PIPES概述</strong></center><a id="more"></a><h2 id="UNIX-PIPE-1"><a href="#UNIX-PIPE-1" class="headerlink" title="UNIX/PIPE-1"></a>UNIX/PIPE-1</h2><hr><h3 id="Unix-Pipeline-Pipes-1"><a href="#Unix-Pipeline-Pipes-1" class="headerlink" title="Unix-Pipeline/Pipes-1"></a>Unix-Pipeline/Pipes-1</h3><p><strong>概述:</strong></p><ul><li>管道(Pipeline)是一系列将标准输入输出链接起来的进程</li><li>其中每一个进程的输出被直接作为下一个进程的输入</li><li>每一个链接都由匿名管道实现</li><li>管道中的组成元素也被称作过滤程序</li><li>通常被用于类Unix操作系统(以及一些其他借用了这个设计的操作系统，如Windows)中</li><li>其他操作系统的这个特色源自于Unix，例如Taos和MS-DOS<blockquote><p>最终成为软件工程的管道与过滤器设计样本</p></blockquote></li><li>这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名</li><li>UNIX管道技术需要注意的一点就是需要将管道与管线区分开来(两种截然不同的概念)</li></ul><hr><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述:"></a>具体描述:</h3><p><strong>管道概念:</strong></p><ol><li>管道是用于将一系列的标准输入输出指令(代码)链接起来，从而形成进程的最基本条件</li><li>并且被链接的每一个进程的输出被直接作为下一个进程的输入</li></ol><p><strong>还可以将其描述为:</strong></p><ol><li><p>管道是将一系列标准输入输出链接起来的进程</p></li><li><p>其中每一个进程的输出被直接作为下一个进程的输入</p></li><li><p>其中每一个链接都由匿名管道实现</p></li><li><p>管道中的组成元素也被称作过滤程序</p></li></ol><ul><li><p>其概念模型非常类似于现实世界种的管道</p></li><li><p>该图片描述了某一文字终端上一个包含三个程序的管道:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>管线:</strong></p><ul><li><p>是指将计算机指令处理过程拆分为多个步骤</p></li><li><p>并通过多个硬件处理单元并行执行来加快指令执行速度</p></li><li><p>亦可称之为流水线</p><blockquote><p>因为其具体执行过程类似工厂中的流水线，并因此得名<br>可以将计算机指令比喻为流水线传送带上的产品<br>而各个硬件处理单元就是流水线旁的工人<br>每个不同的产品都需要细分为几个互不相同的部门来实现其各部件的所需<br>所以流水线中所属部门不同的工人会为了同一个产品而同时工作</p></blockquote></li></ul><hr><ul><li>微处理器</li><li>在使用流水线的处理器中一个指令不是在处理器的一个定时器信号中完成的<blockquote><p>而是被分到多个信号中去完成，但是与此同时多个指令的分任务被同时处理</p></blockquote></li><li>由于这些分任务比整个指令要简单，因此可以通过使用流水线提高定时器频率<blockquote><p>虽然每个指令需要多个信号后才能完成<br>但是通过多个指令的并行运算每个信号内一个指令可以完成<br>因此通过这个方法整个速度可以提高</p></blockquote></li></ul><hr><ul><li>流水线级</li><li>一条流水线的每个分步骤被称为流水线级<blockquote><p>它们被流水线寄存器分开除指令流水线外在现代系统中还有其它流水线<br>比如用来计算浮点数的算术流水线</p></blockquote></li></ul><hr><ul><li>管线危障(pipeline hazards)</li><li>假如，一个指令在执行的时候，需要等待流水线上前一个指令先执行完毕的话<blockquote><p>那么这两个指令相互之间彼此有依赖关系<br>这可能导致流水线冲突的现象发生<br>即为管线危障</p></blockquote></li><li>常见情况可分为四种: 资源冲突/数据冲突(指令层的数据冲突/传输层的数据冲突)/控制流冲突</li><li>通过分支预测器可以避免控制冲突<blockquote><p>在这里处理器预测性地继续运算，直到正式预测是正确为止</p></blockquote></li></ul><hr><p><strong>网络管线:</strong></p><ul><li>Unix哲学: “一切皆文件”<blockquote><p>netcat和socat这样的工具可以将管道连接到TCP/IP套接字</p></blockquote></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>管道(UNIX)</li><li>具名管道</li><li>命名管道</li><li>匿名管道</li><li>匿名命名管道</li><li>哈特曼管道</li><li>管线(流水线)</li><li>管线/流水线(计算机)</li><li>管线危障(pipeline hazards)</li><li>重定向(计算机)</li><li><code>tee指令</code><blockquote><p>该程序用于从管线内取出数据</p></blockquote></li><li>XML管道即为处理XML的管线</li><li>网络管线</li><li>UNIX</li><li>进程间通信</li><li>数字通信技术<blockquote><p>计算机通信技术</p></blockquote></li><li>管道协议</li><li>并发计算</li><li>协同控制</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>EN-System Interfaces<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html" target="_blank" rel="noopener">跳转</a></p></li><li><p>单一UNIX规范第7期，由国际开放标准组织发布</p><blockquote><p><code>https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html</code></p></blockquote></li><li><p>EN-Pipes: A Brief Introduction by The Linux Information Project (LINFO)<a href="http://www.linfo.org/pipe.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linfo.org/pipe.html</code></p></blockquote></li><li><p>获取管道的doc文案: <a href="http://www.cs.rit.edu/~swm/history/DTSS.doc" target="_blank" rel="noopener">http://www.cs.rit.edu/~swm/history/DTSS.doc</a></p></li></ul><hr><ul><li><p>以下内容参考自中文维基:</p></li><li><p>CN-分类:</p><blockquote><p>进程通信<a href="https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">跳转</a><br>进程间通信<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</code><br><code>https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A</code></p></blockquote></li><li><p>CN-分类: UNIX<a href="https://zh.wikipedia.org/wiki/Category:Unix" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Unix</code></p></blockquote></li><li><p>CN-分类: 并发计算<a href="https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97</code></p></blockquote></li><li><p>CN-分类: 协同控制<a href="https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6</code></p></blockquote></li><li><p>EN-分类: 指令处理<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><ul><li>CN-维基百科-点对点隧道协议: <a href="https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0</a></li><li>CN-维基百科-管道机制: <a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)</a></li><li>CN-维基百科-管道流: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-IDC: <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83</a></li><li>CN-维基百科-管线: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-命名管道: <a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93</a></li><li>EN-维基百科-管道(计算机): <a href="https://en.wikipedia.org/wiki/Pipeline_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pipeline_(computing)</a></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 16:00:37 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX-PIPES概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>OS-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/OS-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/OS-1/</id>
    <published>2020-03-05T03:34:05.000Z</published>
    <updated>2020-03-05T05:12:06.302Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><center><strong>OS-PDF/URL资源整合目录</strong></center><a id="more"></a><h2 id="Operating-System-1"><a href="#Operating-System-1" class="headerlink" title="Operating System-1"></a>Operating System-1</h2><ul><li>操作系统</li><li>Operating System/OS</li></ul><hr><h3 id="电子书资源整合目录"><a href="#电子书资源整合目录" class="headerlink" title="电子书资源整合目录"></a>电子书资源整合目录</h3><ul><li><p>可能还会利用持续利用此文本进行URL资源整合</p></li><li><p>操作系统概念</p></li><li><p>操作系统原理</p></li><li><p>操作系统设计</p></li><li><p>操作系统制作</p></li><li><p>操作系统实现</p></li></ul><hr><ul><li>操作系统分析与理解<blockquote><p>Unix操作系统<br>FreeBSD(Unix-Like)操作系统<br>Linux(Unix-Like)操作系统</p></blockquote></li></ul><hr><ul><li>中文维基-<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</code></p></blockquote></li></ul><hr><p><strong>使用资源目录:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)<a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/297382.html</code><br><code>https://pan.baidu.com/s/1ntzHejv</code></p></blockquote></li><li><p>CN-Linux系统编程手册上册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p></li><li><p>CN-Linux系统编程手册下册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2016-10/135953.htm</code></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)<a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/232150.html</code></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)<a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://pan.baidu.com/s/1gdKdxlT</code></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)<a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/90585.html</code></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)<a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/294083.html</code></p></blockquote></li></ul><hr><p><strong>资源相关URL补充:</strong></p><ul><li><p>Linux/UNIX编程手册(分卷压缩文件)</p><blockquote><p><code>https://download.csdn.net/download/js_gary/10216486</code><br><code>https://download.csdn.net/download/js_gary/10216495</code></p></blockquote></li><li><p>FreeBSD解析</p><blockquote><p><a href="https://download.csdn.net/download/starry225/6223229" target="_blank" rel="noopener">https://download.csdn.net/download/starry225/6223229</a></p></blockquote></li></ul><hr><p><strong>整合包获取:</strong></p><ul><li>以上PDF资源整合文件的压缩包(一共七本电子书，rar格式):</li><li>百度网盘地址<a href="https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w" target="_blank" rel="noopener">永久链接</a><blockquote><p><code>https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w</code></p></blockquote></li><li>提取码: j3qc</li></ul><hr><p><strong>资源汇总:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)</p><blockquote><p><a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">https://www.jb51.net/books/297382.html</a><br><a href="https://pan.baidu.com/s/1ntzHejv" target="_blank" rel="noopener">https://pan.baidu.com/s/1ntzHejv</a></p></blockquote></li><li><p>CN-Linux系统编程手册上册</p></li><li><p>CN-Linux系统编程手册下册</p><blockquote><p><a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-10/135953.htm</a></p></blockquote></li><li><p>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</p><blockquote><p><a href="http://www.downcc.com/soft/302635.html" target="_blank" rel="noopener">http://www.downcc.com/soft/302635.html</a></p></blockquote></li><li><p>CN-现代操作系统 (原书第四版)</p><blockquote><p><a href="https://www.jb51.net/books/655464.html" target="_blank" rel="noopener">https://www.jb51.net/books/655464.html</a></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)</p><blockquote><p><a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">https://www.jb51.net/books/232150.html</a></p></blockquote></li><li><p>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</p></li><li><p>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</p><blockquote><p><a href="https://www.jb51.net/books/483820.html" target="_blank" rel="noopener">https://www.jb51.net/books/483820.html</a></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</p><blockquote><p><a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">https://pan.baidu.com/s/1gdKdxlT</a></p></blockquote></li><li><p>CN-深入理解UNIX系统内核 (瓦哈利亚)</p><blockquote><p><a href="https://www.jb51.net/books/609170.html" target="_blank" rel="noopener">https://www.jb51.net/books/609170.html</a></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</p><blockquote><p><a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">https://www.jb51.net/books/294083.html</a></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)</p><blockquote><p><a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">https://www.jb51.net/books/90585.html</a></p></blockquote></li></ul><hr><p><strong>书籍参考目录:</strong></p><ul><li>CN-操作系统概念 (原书第九版)</li><li>CN-操作系统概念 (2007-第七版，西尔伯查茨)</li><li>CN-操作系统概念 (原书第7版，清大出版)</li><li>CN-操作系统概念精要 (原书第二版)</li></ul><hr><ul><li>CN-Linux系统编程手册上册</li><li>CN-Linux系统编程手册下册</li><li>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</li></ul><hr><ul><li>CN-现代操作系统 (原书第四版)</li><li>CN-现代操作系统 (原书第三版)</li></ul><hr><ul><li>CN-操作系统精髓与设计原理 (原书第六版)</li><li>CN-计算机系统: 核心概念及软硬件实现 (原书第四版)</li><li>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</li><li>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</li><li>CN-操作系统设计与实现 (2008版，ANDREW S.TANENBAUM/ALBERT S.WOODHULL)</li></ul><hr><ul><li>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</li><li>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</li><li>CN-30天自制操作系统 (2012版，川和秀实)</li><li>CN-深入理解UNIX系统内核 (瓦哈利亚)</li></ul><hr><p><strong>其它:</strong></p><ul><li>书不重要</li><li>问题在于看书的人所拥有的能力</li><li>同种类型的书的本质都是相同的</li><li>找出，理解并且完全记住其中的关键字</li><li>至于对于电子书的版号的选择也无所谓的</li><li>译版与原版随意，有译版最好读译版</li><li>通常EN版的寻找难度比CN版小很多</li></ul><hr><ul><li>系统化学习目录</li><li>Operating System kernel</li><li>数字理论基础</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;OS-PDF/URL资源整合目录&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>VPS/KVM-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/VPS-KVM-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/VPS-KVM-1/</id>
    <published>2020-03-04T20:28:57.000Z</published>
    <updated>2020-03-05T06:53:16.497Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --><center><strong>VPS/KVM简要概述</strong></center><a id="more"></a><h2 id="VPS-KVM-1"><a href="#VPS-KVM-1" class="headerlink" title="VPS/KVM-1"></a>VPS/KVM-1</h2><hr><h3 id="虚拟专用服务器-Virtual-private-server"><a href="#虚拟专用服务器-Virtual-private-server" class="headerlink" title="虚拟专用服务器 (Virtual private server)"></a>虚拟专用服务器 (Virtual private server)</h3><p><strong>简述:</strong></p><ul><li>简称VPS</li><li>由容器技术或虚拟机技术实现</li><li>在容器或虚拟机中，每个VPS都拥有独立的公网IP，操作系统，磁盘空间，内存与处理器资源<blockquote><p>同时进程与系统配置之间也相互隔离<br>目的就是为了让用户和应用程序在同一个主机上模拟出完全不同，独立且相互隔离的资源占用与控制<br>以此让VPS可以完全拥有独立服务器的所有功能</p></blockquote></li><li>并且VPS为用户提供了管理配置的自由</li><li>VPS多用于企业虚拟化于IDC资源租用</li><li>VPS拥有完全的独立性，包括可以在容器内自行安装任何程序与其它对于虚拟硬件的操作<blockquote><p>远端服务器-&gt;容器/虚拟机-&gt;容器/虚拟机-&gt;用户</p></blockquote></li></ul><hr><h3 id="基于内核的虚拟机-Kernel-based-Virtual-Machine"><a href="#基于内核的虚拟机-Kernel-based-Virtual-Machine" class="headerlink" title="基于内核的虚拟机 (Kernel-based Virtual Machine)"></a>基于内核的虚拟机 (Kernel-based Virtual Machine)</h3><p><strong>简述:</strong></p><ul><li>可简称为KVM</li><li>是一种用于Linux内核中的虚拟化基础设施，可将Linux内核转化为一个虚拟机监视器</li><li>KVM于2007年2月5日被导入Linux 2.6.20核心中，基于C</li><li>KVM需要支持硬件虚拟化拓展特性的处理器</li><li>对于操作系统支持的范围较为广泛</li><li>基于多个GNY协议授权<blockquote><p>包括KVM内核模块: GPL v2<br>KVM用户模块: LGPL v2<br>QEMU虚拟CPU内核库(libqemu.a)和QEMU PC系统模拟器: LGPL<br>Linux用户模式QEMU模拟器: GPL<br>BIOS文件(bios.bin，vgabios.bin和vgabios-cirrus.bin): LGPL v2或更新</p></blockquote></li><li>KVM现由保罗·邦齐尼(Paolo Bonzini)维护</li><li>KVM 支持VirtIO半虚拟化技术-平行虚拟化技术(paravirtualization)</li></ul><hr><p><strong>内部结构:</strong></p><ul><li>KVM提供抽象的设备，但不模拟处理器</li><li>它开放了<code>/dev/kvm</code>接口，供使用者模式的主机使用:</li></ul><ol><li>设置客户虚拟机的地址空间<blockquote><p>宿主机同样也需用户可用于引导进主操作系统的固件镜像(通常为模拟PC时的自定义BIOS)</p></blockquote></li><li>为客户机模拟I/O</li><li>将客户机的视频显示映射回系统宿主机上</li></ol><ul><li><p>在Linux上，QEMU版本0.10.1及更新版就是一个用户层主机</p><blockquote><p>QEMU使用KVM以近乎原生的速度虚拟化客户机，若无KVM的话则将仅使用软件模拟</p></blockquote></li><li><p>KVM内部使用SeaBIOS作为对16位x86 BIOS的开源模拟</p></li><li><p>KVM/QEMU环境的高级概述:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>相关GUI(图形化管理)工具:</strong></p><ul><li>Kimchi – 网页版KVM虚拟化管理工具</li><li>Virtual Machine Manager – 支持创建、编辑、开始于关闭基于KVM的虚拟机，同时也支持对宿主之间的实时或冷拖拽虚拟机迁移</li><li>Proxmox虚拟环境 – 一项开源的虚拟化管理包，包括KVM与LXC<blockquote><p>同时它还有裸机安装器、网页版远程管理界面、HA集群堆栈、统一存储、柔性网络及可选的商业支持</p></blockquote></li><li>OpenQRM – 用于管理不同数据中心基础设施的平台</li><li>GNOME 机柜 – Linux上用于管理libvirt客户机的Gnome界面</li><li>oVirt – 用于管理基于libvirt的KVM开源工具</li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>VPS</li><li>KVM</li><li>Virtual</li><li>CN2</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-Redhat-KVM官方网站<a href="https://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux-kvm.org/page/Main_Page</code></p></blockquote></li><li><p>CN-CN2线路是什么，有哪些CN2线路的VPS<a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</code></p></blockquote></li></ul><p><strong>维基百科参考内容:</strong></p><ul><li><p>CN-虚拟主机<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA</code></p></blockquote></li><li><p>CN-虚拟专用服务器<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-服务器<a href="https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-虚拟化<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>CN-硬件虚拟化<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96</code></p></blockquote></li><li><p>CN-KVM-基于内核的虚拟机<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA</code></p></blockquote></li></ul><hr><h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><ul><li><p>境外KVM类型的VPS大约360RMB/年(美国)</p><blockquote><p>最便宜的</p></blockquote></li><li><p>官网地址: <a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">https://shadowsocks.org/en/index.html</a></p></li><li><p>仓库地址: <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></p></li></ul><hr><p><strong>可用参考:</strong></p><ul><li><p>CN-Github-SS教程</p><blockquote><p><a href="https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B</a><br><a href="https://ssr.tools/252" target="_blank" rel="noopener">https://ssr.tools/252</a></p></blockquote></li><li><p>搬瓦工 (Bandwagon Host)</p><blockquote><p>VPS供应商，支持支付宝支付<br><a href="https://bwh88.net/cart.php?gid=1" target="_blank" rel="noopener">https://bwh88.net/cart.php?gid=1</a><br><a href="https://bwg.net/" target="_blank" rel="noopener">https://bwg.net/</a></p></blockquote></li><li><p>CN2: <a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</a></p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;VPS/KVM简要概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Text</title>
    <link href="https://unit-serow.github.io/2020/03/04/text/"/>
    <id>https://unit-serow.github.io/2020/03/04/text/</id>
    <published>2020-03-03T23:18:27.000Z</published>
    <updated>2020-03-04T01:11:38.154Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --><center><strong>常驻Text文档</strong></center><a id="more"></a><p><strong>常驻随笔文档</strong></p><ul><li>无<blockquote><p>无很容易理解<br>但很难做到<br>很难在现实中实现?<br>不<br>无不属于现实<br>无则为无<br>空源于无<br>世界源于空<br>思维源于世界<br>而思维终将归于无</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;常驻Text文档&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="https://unit-serow.github.io/2020/03/02/test/"/>
    <id>https://unit-serow.github.io/2020/03/02/test/</id>
    <published>2020-03-02T12:46:19.000Z</published>
    <updated>2020-03-06T10:49:07.578Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 18:49:13 GMT+0800 (中国标准时间) --><center><strong>常驻Test文档</strong></center><a id="more"></a><p><strong>样式实验文档</strong></p><p><span id="inline-blue">text.md</span></p><p><i class="fa fa-pencil"></i></p><ul><li><p>简介加粗并居中</p><blockquote><p><code>&lt;center&gt;&lt;strong&gt;常驻Test文档&lt;/strong&gt;&lt;/center&gt;</code><br><code>&lt;!-- more --&gt;</code></p></blockquote></li><li><p>插入图片</p><blockquote><p><code>&lt;img src=&quot;图片URL&quot; width=&quot;20%&quot; height=&quot;20%&quot;&gt;</code></p></blockquote></li></ul><hr><p><strong>URL收藏目录</strong></p><ul><li><p>他人学习笔记-BLFS/CLFS<a href="https://www.cnblogs.com/renren-study-notes/p/10385413.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/renren-study-notes/p/10385413.html</code></p></blockquote></li><li><p>免费高清壁纸-宇宙<a href="https://joer.ru/?id=23&start=294" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://joer.ru/?id=23&amp;start=294</code></p></blockquote></li></ul><hr><ul><li><p>更换图片教程<a href="https://www.jianshu.com/p/30bf702f533c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/30bf702f533c</code></p></blockquote></li><li><p>调色板<a href="https://www.colorhexa.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.colorhexa.com/</code></p></blockquote></li></ul><hr><p><strong>Emacs</strong></p><ul><li><p>这里标注一个大佬-子龙山人</p></li><li><p>知乎<a href="https://zilongshanren.com/tags/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zilongshanren.com/tags/</code></p></blockquote></li><li><p>博客<a href="https://www.zhihu.com/people/zilongshanren/answers" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.zhihu.com/people/zilongshanren/answers</code></p></blockquote></li><li><p>Github-spacemacs中文教程-子龙山人<a href="https://github.com/emacs-china/Spacemacs-rocks" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/emacs-china/Spacemacs-rocks</code></p></blockquote></li></ul><hr><ul><li>EN-GNU-An Introduction to Programming in Emacs Lisp<a href="https://www.gnu.org/software/emacs/manual/html_mono/eintr.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/eintr.html</code></p></blockquote></li></ul><hr><p><strong>在线测试网站收藏:</strong></p><ul><li><p>各类教程内的在线编译测试和各类参考手册都很好用</p></li><li><p>CN-<a href="https://www.tutorialspoint.com/compile_c_online.php" target="_blank" rel="noopener">C</a></p><blockquote><p><code>https://www.tutorialspoint.com/compile_c_online.php</code></p></blockquote></li><li><p>CN-<a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">tools</a></p><blockquote><p><code>https://tool.lu/coderunner/</code></p></blockquote></li><li><p>CN-<a href="http://www.dooccn.com/" target="_blank" rel="noopener">代码测试</a></p><blockquote><p><code>http://www.dooccn.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/" target="_blank" rel="noopener">RUNOOB</a></p><blockquote><p><code>https://www.runoob.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></p><blockquote><p><code>https://www.w3school.com.cn/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/w3cnote/runoob-chm.html" target="_blank" rel="noopener">离线版runoob获取</a></p><blockquote><p><code>https://www.runoob.com/w3cnote/runoob-chm.html</code></p></blockquote></li><li><p>CN-Git仓库地址<a href="https://github.com/it-ebooks/w3school" target="_blank" rel="noopener">W3cshool</a><a href="https://github.com/gagayuan/runoob-PDF-/tree/master/runoob" target="_blank" rel="noopener">Runoob-PDF</a></p><blockquote><p><code>https://github.com/it-ebooks/w3school</code><br><code>https://github.com/gagayuan/runoob-PDF-/tree/master/runoob</code></p></blockquote></li></ul><hr><p><strong>CN-LFS</strong></p><ul><li>CN-LFS-仓库: <a href="https://lctt.github.io/LFS-BOOK/" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/</a></li><li>CN-LFS-v9.0: <a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</a></li></ul><hr><h3 id="社交账户"><a href="#社交账户" class="headerlink" title="社交账户"></a>社交账户</h3><ul><li><p>Github</p><blockquote><p>ID: Unit-serow<br><a href="https://github.com/Unit-serow" target="_blank" rel="noopener">https://github.com/Unit-serow</a></p></blockquote></li><li><p>开源中国</p><blockquote><p>ID: serow<br><a href="https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0" target="_blank" rel="noopener">https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0</a></p></blockquote></li><li><p>博客园</p><blockquote><p>ID: UNITED<br><a href="https://home.cnblogs.com/u/1927298/" target="_blank" rel="noopener">https://home.cnblogs.com/u/1927298/</a></p></blockquote></li><li><p>CSDN</p><blockquote><p>ID: Unit-serow<br><a href="https://i.csdn.net/#/uc/profile" target="_blank" rel="noopener">https://i.csdn.net/#/uc/profile</a></p></blockquote></li><li><p>简书</p><blockquote><p>ID: G鬣羚<br><a href="https://www.jianshu.com/u/b852f1059757" target="_blank" rel="noopener">https://www.jianshu.com/u/b852f1059757</a></p></blockquote></li><li><p>码云</p><blockquote><p>ID: serow<br><a href="https://gitee.com/serow" target="_blank" rel="noopener">https://gitee.com/serow</a></p></blockquote></li></ul><hr><p><strong>国内的云服务平台</strong></p><ul><li>华为云: <a href="https://www.huaweicloud.com/" target="_blank" rel="noopener">https://www.huaweicloud.com/</a></li><li>阿里云: <a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a></li><li>腾讯云: <a href="https://cloud.tencent.com/" target="_blank" rel="noopener">https://cloud.tencent.com/</a></li><li>网易云: <a href="https://www.163yun.com/" target="_blank" rel="noopener">https://www.163yun.com/</a></li><li>百度云: <a href="https://cloud.baidu.com/" target="_blank" rel="noopener">https://cloud.baidu.com/</a></li><li>小鸟云: <a href="https://www.niaoyun.com/" target="_blank" rel="noopener">https://www.niaoyun.com/</a></li><li>七牛云: <a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></li></ul><hr><p><strong>LFS-金步国</strong></p><ul><li>金步国作品集<a href="http://www.jinbuguo.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.jinbuguo.com/</code></p></blockquote></li></ul><hr><ul><li>EN-Wiki-指令处理(Category:Instruction processing)<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri Mar 06 2020 18:49:13 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;常驻Test文档&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-02</title>
    <link href="https://unit-serow.github.io/2020/03/02/%E9%9A%8F%E7%AC%94-2020-03-02/"/>
    <id>https://unit-serow.github.io/2020/03/02/%E9%9A%8F%E7%AC%94-2020-03-02/</id>
    <published>2020-03-01T21:33:55.000Z</published>
    <updated>2020-03-06T04:36:29.791Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="0c95bcd16292c800b262b85c2df061fcdfd0f115012201e9942b338aeaeaf0cb">0267ec72f19b8c198697a4f72870a3a8f84b4d9c168288eea8ee191432915e0b8091a0d64cdcafdda986b590f2c5b03be9af5a1c6bd5c7d112e61e443ff55b871f4f5a38e1129f4fa01b5d5c5c8d8ca8bf2694def64d4ed82f79ca54f14d094e5b7c6ec5094a8dcb5f8800d8c69e25635f8d9d2842d1f291335748f9b761e874547e7bb9ccb290de7bb5fc698338883055f2171c21340bdabb36a8785eb78f237ec400f9672237853297c05de7893250870b8d85f2e0d475c2d802b2022f504e7f8855fd34a41b6fb7077ed50f153f85ab288bc832bb43e8c9c9fa4a24e9b0dbfb5cc1387a187e57c7847b76ae0c60b00316266e5662e85b13ed24ef33cc05cd54a5e92a9cd6a473c7fc9d7fca7148ce5e04979190989b17ea38a46b483bde6eeb2282969d44d72eed62344f68bae0edab49b34afc21af06ba688de7c622b819046265d2263815f0760f0d396a855883e732029c466ef9789249c3e74eceeef0e5603e96e09549ac80f5ac619a728fc17dd18ebc48777f01d37d898e4fc2aa570b4a4290b8df7090b8f371a03b71294739fbea4f6885686a393a6dc530da9651cb566bf78a421174503c1c6c7be399222b810ff89fd85e820a623aa0b3b33bd7a8fc6c2bf01d8be2b6bb7d8cd2ed9cd162ed5bc85772cbc17338fe11a86d109bfcd145bc4575d5edeab6288f04fe8b01678bbc78a4d1ed7799385f9349c29e747831bbcc8ffeb1140e10b65e1681fad7a6aabd2a17f22f81245d2a63ac94ac0f53b82d255171f2121462e8d19965d43aa8ba66093ac3b8553d9970555989eab50c78fa65c213762c7f1720d00fe2c99abfc29d9a074e5e800ac9a4dded96c3f5e4875cb59f06d0d24feaa4792d0211be722fa343113cd3967f440c3ccd3260ec8da345db69f5a3a3f5f41f9b98ca4ee205a8cbfbcd58378b1a784df580eb7211d21f0803010c447091241a48b2ccb0e1d18f08e195f98bb1e2339e62b6e22a5390352d6481ece503868e041eafe00f7e9a7bcc8f9c510c3a9ac149e6360fe9005220ebbc4bba34e89c0b3a3f8565520d29905a328bf56e5b9452525b73e027258b08173826efad3754d6402ff6e8fbae2332b3a8525fb1e15af226387a668a842c1076bfea13968caab6ae0e0395979420745cf2041337bb403845ac4525b4b673290503dac8efa7d17acfa315869cce42acdccedb5d129e5011e97b484ba4ea04aaf8fc62bf26df46e1b1c29f68570e60a2a973dc4d5793fb44a15b660516919d7412e3fc9beeffddf5fa66da190b278035931fa246510660bc6098c9145d6f222875f3915f1ac6e0f625d4138fc65dff28258d53f71a7796422fe93db2d40250eb93042bfff9903553d56b12606ac9154fd3bc7f5c369728108a1a53ecac415d71da98187fac163cc061000773f2bfb7726496d29511fc7ccf2a4eca9748e96f64e2230d4d528f6590d2253d89ace934ae7ecb1dc103ab3edb84a0513ebab2114a8772719b1de4a875c190d206c2096206713dc57c563e2d052ae708a415d0867f0bd16379d1697c3133128ed47c9d81f199c30466f29bbca0a162e820f87c983a1d203a9d92f30f399e5fb4a9cda512edc294fe5d6236cc8c5f65023ce71175a6796fbd78993711fba4b07fc5f443f90ef50976eb3c11037f1dbf03afeaa62692bd25e520a87a54974534bd13b11356af1dfef3f37bd23030279e04f6086facb52d0c3a390508b2964b582c7ca5874222f176f0f2b2605649ecd38a599bc9c8dcf5827411637ff8bed928efa6b88dd5b1272e2edd8ffedf64980fffa10a5cdd1c6f48d1864a8c0d72ff5dc646924361b663a493196b1879c0665044e63aa14c4be273a8c628d59dc54c3c23e6de78e01bba2611a405dc748614a3891342d728720bd42214400117222559c2e5bc4439c21ac760389c6838f1bbd18137d57459bdd613c199f522033ca5c483d259a0c1362d7a2fbf7bec54314adf5d2fdbf141d32fff60df8a1e10e56992e2ada07376055f806bf055438f709aa282ae13095607025d0e7a599b59f221ff5007655c328560518791d989638b3bedc191471e7085288422e1c9800775c7e6be4d3ce2058a1adba5eff6415e9615043282783d24683c25b45605ccc8eceeb3d40faab1bf8cdf86381b387f07baa18b917eaf699073607480c54ca8897768fd814244e8750a3a68670b1cb47ff14c919eae4285762d3129560f91a363054e6afd7015849b469ca78676aa50431bcd547a26f89e07ecdef7da06d9f8bb88b560d7a1812a91db56d59866a9ebe0d51c5d68c523b8baaea1c818a292a3d4750bc73250508e0ed835000d288a9f205bb250d58588da00c8a152a445be6ccd11ae485140cd7b299ad175e3b2394bb3d5d9263681cdf14dea87fe93c5eb168a281b82e262af3b761b430a6c22f71d39d2ac00a3b1237a2dc2f3ca228673b3de2bb7c4c6763c6a37a35c57860c8332f09c32626a84e6c27408bcd6d23097a1eb7026cd4f00fdafa00718dd7b9b3d9752dcc65fd7f92e98c6c50e9096e2bd378c13a1d1fb2eddbc71ede0ec7ba1c568e2ed3dea056ef71c420998afe0400e94fef0a0ff3ede746d18a052da334000482153797a2710adefee7ce8e975d084ec407ca2333e01310d79f3a10dd6e39849839675f650af8ee937b70f6f19dbc630bd347a693ce047a427e6cfc6af7c13408f9193b3fa5dac57d166125000502e6070a468bae88a1861583813940af06c488917feb9743d8611682ed6d736ebdeb07ecf3d64d830ff49de8f7323ba7e55713fa902d215ebfc62b57b2607bb40a54ce945a943436a8c037d7c465527da5e76d885ab0313e188a548c06a4edaea349e4b3227956054f5a1f8e31f4e89d1102c1b9e3347808a31d05ed6b4a7eb7c3c4e2277e83a6e6c64702581dc60b11bba7246cc88d94ecbd47525a0d439e66445f33b090db02cc05209bceafe6fa536f75755b241c3fb963843e5767b0b30e8a448c181b7c125948c4fe19239fa4db7f05bebd0e90580ce10816fed16984d2457973b7afa1a2e5dc837a69c1b465b3afb4b0fe02a09627b0b3df773a0b3d3a4276427d2148147de81675a6108de56bdaf4ade93bd94fd9fc318b4e9d413bc2e7009993ca88915fdd494a408c774e9772f19a1d250d6ed84d8f9188fa85caf96bfac5002949254232775c8fe4c0be6dba3c6eb7146575f6d3d9de689c040454a604dd5eb176022832294d17802f099ab25440a89aafaac724a8c9015d633e3b238f383cfdd3d81be6bbe283c4a0be12af5ba611696200d0b46b1abf354279b24e8a16b6f343d8e472d21e70465eaf22c8b1241fc6cd0bc5e39cf152fa1c667cef3985940319910d51a0ace055724dfe607b04e5821f1f4080767138e45fbc28be14175b94f86e67abe215e629967da6126f5d8191f61febfd30f53e381b2294240feb6ed2f3eac53c6656b9fbfd6ab717e0f73182838c0d6250100751d640cebd4e6dc56489fd726e067fa742c3d0cd7aa3bb16fbb877ace74eabec1a5f3b6fca48c56a5d0bd583a0989536bcf31b7c54c8981e1bf486e37bbd4fd463f9eb8b31cbe41952c3c813b5d525de0dfe788420ae6d9418807e7364b619c3f7eb48168c43eb198f739cbbee0bb592ecb31d5516298a1060f9293d60f27ec79387d47c8d956971e8d5df188b1e5993cbbe1245f4ff4615006d1edda9ed3f6cebd27e5857945b160d37c381bd64aa5ed6adcd698000e8ae2822ff5d588983effb5512dbc53bf934c355580ccd3b9312137822a55dabb5e10d9ef8c7d366e40d4e643872aedc7916b1ed5d88371ba15d48690a095f0ed26b02ff9b4496f1ad77499adb116215f77bbb335ad99d190ee642eb9bf3c315b25f22dc4348c407528ca6f7047f46c236811d10b1554507e0bdd2a26ab4a9b4234f9bc3df6f5d1f495abceaa836a5f71384a9821af37a1e1d92af7cae2e2419740af6f3cfe62cbcb0f65e11420f512e09e404783a1ba9d750ab6a6bd2aecf47467b8b623227fdd0fcd7d967efbb658cc3ba277d353b8598e65dd9530f60fdb5c27813245cc5a150b5a7867bfaf3e2b2f11c1dafe119148cb508d91abe84a40ba6f9ed7f4ab98fab0f98690aec5b5c9301832c6aaea9333dbc377d5725d07f847eeae801cea463683e2646050563a0b9b8a9d924861ff340655cd217db5d545adae12689f7e925abf9192a605c60d2c19bd68e7ce9935d0941fdcd8b348b6db9f905809cb113e2e95c30bd56698dc7a6ce82387ccf815907b498ec7fbdcdc35b4d859266a430a1d9eea0723bf59a90ea5523d71df4b5faa5c6b6694b18462a6bc45074ab2a370b74d2c636c34370a667b9fda766e880914cfc1f60f65f46697f9624c99a3fa81c03d8fb3b8c3f14f7ef6d319efddee26356c0ed6463a3adef55946337f98e6d8bd5d253ff5bcd9eea34383d3b473b7f9b5003cc17a59f2c1d44fc33edf3d5af2c5395f6c1fcc640f9f6caa244d477066629dfcfb730be771f58dd6a9865a4ed95e4d2b3a1c25bab8c44457278f778c3d47c087536d3fca95434028218f9c70d1e12401df175a37cb67312f7a9a175f1e006e42c1b59e8af8e814a0fff2b5704016c42d293c5f7ea610527f4cb9c864c9b92ae728d0edcdd5e2e64a1c18bcd05f1bffb93120070c01df9f8b81f6824d1cc4d7a589b9dd7930c33e7dc7bcd15e971114c61dfb65d1bcc8f5cfd611a3db1708728e9bcd0dad423b1ad235dfdbcab4ce984698c9aba3fcbee35c9e35ba9ab15004a48b526e4bd8898da196beaa6002dc678140a15704fc79a6e25aa8e21046fed47cc35abcbf2ea03d0b743d661e94f766a944f0afc20cd46677d0abb46b49056a5ea42b5af1bad0bf29ae3c8b2d2461596d816e1b4283c51a45c660d88f9939d1a063773c59ffcc25c110dbe552691c52780306211d428bdea3239e36b08d215fced51a0118bdfbe9a11dfd85f6166bd8aefac3fd36d833a134edb9c851a8a0bd59760d60f53bd4e9c905587d6bf0db95ea7f7d42632afa61633c752bbbcef00570811a91d8fee6a9c322b5bea3577979d33d1828251aa11b7e24e4f59a89c74d2a405628a46b3bf6cba7d67a87f7785a3261b393503e6cfc09de595995c2bd82b465536f12e907dd77d387ff7df83ca576839c8078cc2dd71af20e6ee989ecbabf977b083df1b8eb2cf4ec1ba3f32ed2b18be93da0d1070632826109d94af55696d4bd4225db8215be133fb7d82b11c1e72461f9a6f61607aa9a1085b9aa67c681a4281fdc79b3271b3c59eb4cb78edea3c358cd023dd5d6892d0b147ba2320886bfa530e20d95cc3e0d25248d3b903396a566ddd7f976c3d35d04aac70cc86c281077698a546a1a784af3f9c62f0772cb9be4c7e2913f4a004d2a3f4df4ccbb7a13a33897676ae6d6fc45fb6b9d40fbeac866707083f35f35d92c4e62ac166bb1987e1825429c08566fdcd1bea1ae5217b49ea2a6fb19cb1c256d56036c8d585063bd86310e90b8232b299ed551aa039fabb135f0cd30abcc80668cf6b211868a6de2767d85f2407f450a826a779a999600598dabc2a3745e387e64818ac4861fbe107c7e7ae14f3e7d14c064b959c185060787708f6e0ad3c33599b3a50d47a02fefef9a9d8fa18779a8d655784cbfae0383854f919495b5ca5df7e9217090e638a7fc35614449865cb53e1699abfd3f5c35ba91b86f4c2a8e02ea6c57f4868e483ba213ba413b75e5f917bf2e4c3a175cc6cb624f6dbdbb17aaf7f50329868b64fe28e03b2e190cc946b21b734f0d79b01247388989ade6b439264ec9d641fd2e4ed84a5070c8dbdabb92d4cfbb01ffb33c502fbd6731a550f5b78997a7b640ddf6cc4be470773e39429c430867869f829daf02159d5025077d12306b4b13f5a80552f687316c5125451761c6801be873978c97d5f5e86eabf0b4b9499c8e9842c3015e3459bb031b31299c788e0b4a25f08087ebfe1859afc34f4df832a0ef762ef472cb2af1accb441d7e965983e6efb4018baa62a59ffb2daecf270640a10f3d8ec15cd2e2a332883f5195c269824de62155b5bc773bb1554a89b0b6285686d97cbdb22f7a2787efe09584ec4b9f0481dc9d3c8ed87a09f9ba5800903875bc744cb83e744250ca66ceaeb745e08ff019ff2fe415571d185643708933dfd0ef7e332d0672941e6a8afc5e2777be744d3525f7edf22801e472e6e8a92ebed5fd313211cb9ff7e8571697b04f102cf39c3d4a91c2b4ea7eee439aa4d831db88be774e8cb96d4e282990f4ad07644c0f4909b57af697b9dba83b79b014ddbd45bc928ebab23b9a3e6a9a65d8bc778fa4e770358baf061a1f0c336a1847168abd302b4528e6262faccfaa8293017b7c09b4ca663486fce342de426db67a2d35fce7293a058af4b1a3e4560f805baf95f25324b1e73e5e1793f9b06ad441251ee75f26d4e373f1899dc36df6378060e189dce8a6307bcc07bc107d58e2433ab3ff6db5a125f360dfd15e0fa3223b06a5c1ad762a150958cf98a4b75631390c4f12112053a6374ae6b1575bb8fef3883b22fdad165537821a24bef1fd835c7f61c412b0d4af992ef0f0bc2589fc3bce19e25e38b7412133194a58f7f0a5a7dd848b607f17776cb3dbad6b01630888acc1f78e0c71ff56dad72c91fa0b22bc031d97bc5effaa76ca2e1f9bb81177333153a7b9520ba659932010a182a24d9d90173a98fa46b65507b952df8c4b6b92456b1d18812447142dfe92031e06e6e14890eed791d34494c4dce20cb6594eaf6d49421b5b1b3473b7e6e497afd62758e0ebbf664dfd110d1dbcad6875d61f118bea547accfe0480e250684b237f67377d5f7e9d629b79b8155a291c264873fc589383791a1f3df56c6467f1444f8d046c1f6a9894e3e100d05b8980c364e26af98a7a8c706e0c85452b8363ea114e3d4c1f90e1d44103b5b10fb50cb2a623ea0dc5f9198798e2507f7091aa98a5dad27a0400c9567338b0d425c3a42183c4f53c12ce5d5567d0a2571b80d914729140a0c446ef3a0780fcd2fdc3a524575f277825ad8b50cee8ed49a67874c63ad34a30edc0283461b1693854ef545d0e80d4154bda3a53932f6616627d19ee0c5ed8a8f309b26e28259ac007816d13f7d4fd02f2682f4e8f531cd1dc45a4c03156d8ef90680d8ee20e0fa8268ae44be51dc7b5a41a14cb91cbc823529a34a1b764bdda7bd37249ba1dac197de892daf560f42cb6350a3134d7fadc57cb0aea67c27d8eceb2a85408c27d472db28b08ac73d8992a6eedf73d21a33c8fb0ca99089bfd865de8861240a2c3c5bdc45f72d4c4a3d449df66dd088f958ebaa1ad1cfbd274e1f0a873f6b6fded814c58218f3bb9f103ad39a5b886b254ef4c3ff8c8a9cf669499b1a5c20ed14ffc08e76801933dd351c4cc94c8df24dd4654d2b10b746a2f0737</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      简易加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-3</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/</id>
    <published>2020-03-01T14:10:58.000Z</published>
    <updated>2020-03-01T14:42:36.136Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-3-3"><a href="#GNU-LFS-3-3" class="headerlink" title="GNU-LFS-3-3"></a>GNU-LFS-3-3</h2><ul><li>系统转换过程与细节描述</li></ul><hr><p><strong>文案说明:</strong></p><ul><li>本篇文案用于描述目标系统环境的最基本配置与对从临时系统进入到目标系统的各种细节的描述</li><li>参考文献及版本为LFS-v6.2/v6.3</li><li>描述主体为LFS-v6.3，LFS-v6.2会有特别标注</li><li>LFS-v6.2和LFS-v6.3的内容与执行语句通常没有本质上的区别<blockquote><p>多数都只是执行顺序或者深层的处理逻辑不同<br>但大体非常相似</p></blockquote></li><li>多数指令在目标主机的chroot环境下进行</li></ul><p><strong>目录简述:</strong></p><ul><li>系统清理</li><li>虚拟文件系统</li><li>chroot环境</li><li>标准文件系统(FHS标准)</li><li>用户与用户组的基本配置</li><li>参考资料</li></ul><hr><h3 id="系统清理"><a href="#系统清理" class="headerlink" title="系统清理"></a>系统清理</h3><p><strong>临时主机的系统清理</strong></p><ul><li><p>删除已经安装的可执行程序和库文件当中的调试符号，以节约空间(大约70 MB)</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code><br><code>$ strip --strip-unneeded /tools/{,s}bin/*</code></p></blockquote></li><li><p>命令会跳过大约20个文件，报告不能识别这些文件格式</p><blockquote><p>其中大多数是脚本而不是二进制文件</p></blockquote></li><li><p>这里需要注意的一点是千万不要在库文件上使用<code>--strip-unneeded</code>，否则会破坏其静态版本</p><blockquote><p>如果已经是过去时了的话，就得从头开始编译全部的工具链软件包了</p></blockquote></li><li><p>删除相关文档文件(info，man)，会节约20 MB</p><blockquote><p><code>$ rm -rf /tools/{info,man}</code></p></blockquote></li></ul><hr><ul><li><p>到目前为止，临时工具链已制作完毕</p></li><li><p>这一阶段开始进入目标主机环境</p></li><li><p>从现在开始不需要lfs用户来制作系统了</p></li><li><p>退出lfs用户</p><blockquote><p><code>$ exit</code></p></blockquote></li><li><p>此时为root用户环境，改变必要文件的权限与所有者</p></li><li><p>一部分的原因是为了避免不必要的安全方面所产生的问题</p></li><li><p>将$LFS/tools目录以及其中文件的所有者改为root用户</p><blockquote><p><code>$ chown -R root:root $LFS/tools</code></p></blockquote></li><li><p>这里说明一下:</p><blockquote><p>建立LFS系统的时候，在创建<code>/etc/passwd</code>文件时<br>添加的user ID和group ID是与宿主系统的user ID和group ID相同的lfs用户</p></blockquote></li></ul><hr><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><strong>挂载虚拟文件系统</strong></p><ul><li><p>为虚拟内核文件系统建立挂载目录(dev,proc,sys)</p><blockquote><p><code>$ mkdir -pv $LFS/{dev,proc,sys}</code></p></blockquote></li><li><p>创建初始设备节点(创建两个目标系统所必须的设备文件)</p><blockquote><p><code>$ mknod -m 600 $LFS/dev/console c 5 1</code><br><code>$ mknod -m 666 $LFS/dev/null c 1 3</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>内核在引导时要求某些设备节点必须存在(特别是console和null)<br>这些设备节点必须创建在 硬盘上才能使得内核在udev尚未启动之前就可以使用它们<br>此外还有当Linux以<code>init=/bin/bash</code>启动</p></blockquote></li><li><p>挂载并填充/dev目录(LFS-v6.2)</p><blockquote><p><code>$ mount --bind /dev $LFS/dev</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>LFS-v6.2推荐的向<code>/dev</code>目录填充设备的方法是在<code>/dev</code>上挂载一个虚拟文件系统(比如 tmpfs)<br>然后在设备被检测到或被访问到的时候(通常是在系统引导的过程中)动态创建设备节点<br>既然现在新的系统尚未被引导，那么就有必要通过手工挂载和填充<code>/dev</code>目录<br>这可以通过绑定挂载宿主系统的<code>/dev</code>目录<br>绑定挂载是一种特殊的挂载方式，允许本地主机上的当前用户创建一个目录或者是挂载点的镜像到其他的地方</p></blockquote></li><li><p>挂载虚拟内核文件系统</p><blockquote><p><code>$ mount -v --bind /dev $LFS/dev</code><br><code>$ mount -vt devpts devpts $LFS/dev/pts</code><br><code>$ mount -vt tmpfs shm $LFS/dev/shm</code><br><code>$ mount -vt proc proc $LFS/proc</code><br><code>$ mount -vt sysfs sysfs $LFS/sys</code></p></blockquote></li></ul><hr><ul><li>在进入chroot环境之前，可以将<code>lfs-sources/</code>里面所有源码包复制到<code>$LFS/sources/</code>目录中</li><li>这么做会让后面在构建目标系统的时候使用源代码变得更方便<blockquote><p><code>$ cp -a /lfs-sources/* $LFS/sources/</code></p></blockquote></li></ul><hr><h3 id="chroot环境"><a href="#chroot环境" class="headerlink" title="chroot环境"></a>chroot环境</h3><p><strong>进入chroot环境</strong></p><ul><li>Chroot到目标系统的目录下，以便不受主系统的影响来制作目标系统</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chroot <span class="string">"$LFS"</span> <span class="regexp">/tools/</span>bin/env -i \ </span><br><span class="line">HOME=/root TERM=<span class="string">"$TERM"</span> PS1=<span class="string">'\u:\w\$ '</span> \ </span><br><span class="line">PATH=<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/tools/</span>bin \ </span><br><span class="line"><span class="regexp">/tools/</span>bin/bash --login +h</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><code>env</code>命令的<code>参数-i</code>的作用是清除所有chroot环境变量<blockquote><p>后面是重新设定HOME,TERM,PS1, PATH等变量的值</p></blockquote></li><li><code>TERM=$TERM</code>设定虚拟根环境中的TERM的值与chroot外面的一样<blockquote><p>这个值是让像vim和less之类的程序可以正确操作<br>如果还需要重新设置其它的值，如CFLAGS或CXXFLAGS，这里是个不错的位置</p></blockquote></li></ul><hr><ul><li><p>从这里开始，不再需要LFS环境变量了，因为所有的工作都被限制在LFS文件系统里面</p><blockquote><p>这是由于已经告诉了Bash shell $LFS 是现在的根目录(<code>/</code>)<br>注意，这里<code>/tools/bin</code>位于PATH的最后面<br>也就是说当软件包的最终版本安装之后就不再使用临时工具了<br>为了使shell无法记住可执行二进制代码的位置，需要通过使用<code>+h参数</code>关闭bash的散列功能</p></blockquote></li><li><p>此时bash提示符会显示: <code>I have no name!</code>这是正常的，因为<code>/etc/passwd</code>还没有创建</p></li></ul><hr><h3 id="标准文件系统"><a href="#标准文件系统" class="headerlink" title="标准文件系统"></a>标准文件系统</h3><p><strong>创建符合FHS标准的Unix文件系统</strong></p><p><strong>创建系统目录结构(FHS标准目录树):</strong></p><blockquote><p><code>$ mkdir -pv /{bin,boot,etc/opt,home,lib,mnt,opt}</code><br><code>$ mkdir -pv /{media/{floppy,cdrom},sbin,srv,var}</code><br><code>$ install -dv -m 0750 /root</code><br><code>$ install -dv -m 1777 /tmp /var/tmp</code><br><code>$ mkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}</code><br><code>$ mkdir -pv /usr/{,local/}share/{doc,info,locale,man}</code><br><code>$ mkdir -pv /usr/{,local/}share/{misc,terminfo,zoneinfo}</code><br><code>$ mkdir -pv /usr/{,local/}share/man/man{1..8}</code></p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">for</span> <span class="keyword">dir</span> <span class="keyword">in</span> /usr /usr/<span class="keyword">local</span>; <span class="keyword">do</span></span><br><span class="line">ln -sv share/&#123;<span class="keyword">man</span>,doc,info&#125; <span class="variable">$dir</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p><code>$ mkdir -pv /var/{lock,log,mail,run,spool}</code><br><code>$ mkdir -pv /var/{opt,cache,lib/{misc,locate},local}</code></p></blockquote><hr><p><strong>创建必需的文件与符号连接</strong></p><ul><li>一些程序使用固化的路径(<code>hard-wired paths</code>)指向一些目前还不存在的程序上</li><li>为了兼容这些程序，可以创建一些符号链接</li><li>然后在软件安装之后用实际文件进行替代</li></ul><p><strong>创建必要的符号链接:</strong></p><blockquote><p><code>$ ln -sv /tools/bin/{bash,cat,echo,grep,pwd,stty} /bin</code><br><code>$ ln -sv /tools/bin/perl /usr/bin</code><br><code>$ ln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib</code><br><code>$ ln -sv /tools/lib/libstdc++.so{,.6} /usr/lib</code><br><code>$ ln -sv bash /bin/sh</code><br><code>$ touch /etc/mtab</code></p></blockquote><hr><h3 id="用户与用户组的基本配置"><a href="#用户与用户组的基本配置" class="headerlink" title="用户与用户组的基本配置"></a>用户与用户组的基本配置</h3><p><strong>配置必要的用户组</strong></p><ul><li><p>以下区块为LFS-v6.2独有</p></li><li><p>一个常规的Linux系统在<code>/etc/mtab</code>中有一个已挂载文件系统的列表正常情况下</p></li><li><p>这个文件 在我们挂载一个新的文件系统的时候会被创建</p></li><li><p>因为从此开始在chroot环境下不会再挂载任何文件系统</p></li><li><p>所以需要人为的为那些用到<code>/etc/mtab</code>的程序创建一个空文件</p><blockquote><p><code>$ touch /etc/mtab</code></p></blockquote></li><li><p>为了让<code>root用户</code>可以登录而且<code>用户名root</code>可以被识别</p></li><li><p>在这里需要创建相应的<code>/etc/passwd</code>和<code>/etc/group</code>文件</p></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat &gt; <span class="regexp">/etc/passwd</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span>0<span class="symbol">:</span>0<span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>此时root的真正密码将在后面设置(<code>&quot;x&quot;</code>在这里只是一个占位符)</li></ul><hr><ul><li>使用以下命令创建/etc/group文件(LFS-v6.2):</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>在LFS-v6.2这里创建的用户组并不是某个标准所要求的部分<blockquote><p>只是因为在随后<code>Udev配置</code>将要用到而以</p></blockquote></li></ul><hr><p><strong>创建<code>root</code>及<code>nobody用户</code>和必要的组(LFS-v6.3):</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>passwd &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>:<span class="number">0</span>:<span class="string">root:</span><span class="regexp">/root:/</span>bin/bash </span><br><span class="line"><span class="string">nobody:</span><span class="string">x:</span><span class="number">99</span>:<span class="number">99</span>:Unprivileged <span class="string">User:</span><span class="regexp">/dev/</span><span class="string">null:</span><span class="regexp">/bin/</span><span class="literal">false</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line"><span class="string">mail:</span><span class="string">x:</span><span class="number">34</span>: </span><br><span class="line"><span class="string">nogroup:</span><span class="string">x:</span><span class="number">99</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><hr><ul><li><p>因为完整的Glibc在目标系统中已经安装</p></li><li><p>而且<code>/etc/passwd</code>和<code>/etc/group</code>文件也已创建</p></li><li><p>所以用户名和组名现在可以开始使用了</p></li><li><p>重新加载bash，以使root用户起效</p><blockquote><p><code>$ exec /tools/bin/bash --login +h</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>参数+h</code>用于告诉bash不能使用其内部哈希表查找路径</p></blockquote></li></ul><hr><ul><li>程序 login, agetty, init(还有其它一些程序)使用一些日志文件来记录信息</li><li>比如谁在什么时候登录了系统等等</li><li>然而如果这些日志文件不存在，这些程序则无法写入</li><li>下面初始化这些日志文件，并设置适当的权限:</li></ul><blockquote><p><code>$ touch /var/run/utmp /var/log/{btmp,lastlog,wtmp}</code><br><code>$ chgrp -v utmp /var/run/utmp /var/log/lastlog</code><br><code>$ chmod -v 664 /var/run/utmp /var/log/lastlog</code></p></blockquote><ul><li>目录作用明细:<blockquote><p><code>/var/run/utmp</code>记录着现在登录的用户<br><code>/var/log/wtmp</code>记录所有的登录和退出<br><code>/var/log/lastlog</code>记录每个用户最后的登录信息<br><code>/var/log/btmp</code>记录错误的登录尝试</p></blockquote></li></ul><hr><ul><li>此时就已经完成了对目标主机的基础配置</li><li>同时已经进入目标主机的标准环境了</li><li>一下步即开始对目录主机进行程序编译与配置</li><li>进入源代码目录与设置LFS变量<blockquote><p><code>$ cd /sources</code><br><code>$ export LFS=/sources</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>官方-EN-LFS-v6.2</li><li>官方-EN-LFS-v6.3</li><li>金步国-CN-LFS-v6.2</li><li>孙海勇-CN-LFS-v6.3</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-3-3&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-3&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-9</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-9/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-9/</id>
    <published>2020-02-29T20:44:43.000Z</published>
    <updated>2020-03-02T02:30:03.689Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --><h2 id="LFS-9"><a href="#LFS-9" class="headerlink" title="LFS-9"></a>LFS-9</h2><hr><h3 id="实现逻辑梳理-LFS-v6-3"><a href="#实现逻辑梳理-LFS-v6-3" class="headerlink" title="实现逻辑梳理(LFS-v6.3)"></a>实现逻辑梳理(LFS-v6.3)</h3><ul><li>主观理解，仅供参考</li></ul><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol><li>将原主机分区，假设分为两个分区:<blockquote><p>一个用作swap内存交换分区，另一个用作LFS系统制作分区</p></blockquote></li><li>创建LFS系统的制作及操作目录</li><li>挂载FLS系统所对应的分区目录</li><li>在被挂载的分区目录下建立源码存放目录/sources与工具编译目录/tools</li><li>利用原主机的root环境来为文件目录分配权限，同时配置目录的符号链接<blockquote><p>以方便操作与管理</p></blockquote></li><li>创建用户lfs与用户组lfs(可以同名)</li><li>登陆用户并建立lfs用户环境</li></ol><p><strong>建立临时系统</strong></p><ul><li><p>此时将所有的文件都编译进<code>$LFS/tools</code>目录内</p></li><li><p>源代码与压缩包存储于<code>$LFS/sources</code>目录内</p></li><li><p>构建GNU工具链内工具</p></li></ul><ol><li>Binutils Pass-1</li><li>GCC Pass-1</li><li>Kernel Headers API</li><li>Gilbc<blockquote><p>在Glibc在正确编译且安装完之后:<br>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils Pass-2</li><li>GCC Pass-2</li></ol><ul><li><p>构建其它辅助工具与系统程序</p></li><li><p>编译完成时，临时系统已完整</p></li><li><p>然后利用Strip程序对环境进行清理，info与man也可以进行清理</p></li><li><p>此时可以进入下一阶段</p></li></ul><hr><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li><p>此时的临时系统将作为目标系统的辅助系统以保证存在目的</p></li><li><p>退出lfs用户</p><blockquote><p>此时回到原主机的root环境<br>从此开始的编译都由root用户进行</p></blockquote></li><li><p>此时为了避免安全上的问题</p><blockquote><p>将$LFS/tools目录权限转交给root用户<br>可以将tools目录保留，以创建多个相同版本的LFS</p></blockquote></li></ul><hr><p><strong>首先挂载虚拟内核文件系统</strong></p><ol><li>创建虚拟内核文件系统(或其它设备文件)将要挂载的目录(dev,proc,sys)</li><li>创建设备初始节点</li><li>挂载并填充/dev目录</li><li>最后挂载虚拟文件系统至上面创建的节点之内<blockquote><p>挂载的同时创建了几个最重要的文件系统</p></blockquote></li><li>这里也可以将<code>/lfs-sources/*</code>内的源码包复制到<code>$LFS/sources/</code>内<blockquote><p>以方便使用</p></blockquote></li></ol><p><strong>其它内容:</strong></p><ul><li><p>系统环境逻辑:</p><blockquote><p><code>原主机-&gt;临时系统-&gt;目标系统</code><br><code>原主机-&gt;临时系统</code><br><code>原主机-&gt;目标系统</code><br><code>目标系统&lt;-临时系统</code></p></blockquote></li><li><p>这里要重点指出它们的关系并不是线性的</p></li><li><p>主系统包含于临时系统与目标系统</p></li><li><p>进入chroot的目的是让目标系统完全独立</p><blockquote><p>但此时的目标系统还带有临时系统所编译的工具环境<br>此时的原主机进入了chroot模式，因此现在不存在原主机的概念<br>原主机即为目标系统，而目标系统内当前还拥有临时系统的环境与功能</p></blockquote></li></ul><hr><p><strong>进入chroot来进行对LFS系统的操作</strong></p><ul><li>chroot</li><li>此时根据指令来进入chroot环境</li><li>现在所做的任何工作都是为了对已经进入的chroot进行补充<blockquote><p>以构建最终的LFS系统<br>并且chroot内只能使用到临时系统所构建的工具环境<br>此时所有的工作都被限制在LFS文件系统内<br>所以<code>Bash shell $LFS</code>就是现在的根目录<code>/</code></p></blockquote></li></ul><ol><li>清除所有chroot环境变量</li><li>重新设定HOME,TERM,PS1,PATH等变量的值</li><li>创建LFS系统的系统目录结构(必须是标准目录树/完全遵守FHS标准)</li><li>配置必要的符号链接<blockquote><p>因为有一些程序使用的固化的路径(hard-wired paths)指向一些还不存在的程序上<br>为了兼容这些程序，可以创建一些符号链接，然后在程序安装之后用实际文件进行替代</p></blockquote></li><li>然后再去创建root及nobody用户和必要的组<blockquote><p>以让root用户可以登陆与用户名root可以被识别</p></blockquote></li><li>此时因为已经拥有了临时系统内所构建的glibc和刚刚创建的<code>/etc/passwd</code>和<code>/etc/group</code>文件<blockquote><p>所以现在用户名和用户组已经处于可用状态了</p></blockquote></li><li>启动新的shell</li><li>设置某些特定程序的log文件，以保证这些程序能够正常写入</li><li>最后进入源代码目录下，此时还可以将之前复制到sources下的源代码文件目录设置符号链接</li></ol><hr><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><strong>建立目标系统</strong></p><ul><li><p>此时将所有的文件都编入当前LFS主机(分区)的/usr/bin目录下</p></li><li><p>GNU工具链内工具</p></li></ul><ol><li>Linux kernel headers</li><li>Man-pages</li><li>Glibc<blockquote><p>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils</li><li>GCC</li></ol><ul><li>构建其它辅助工具与系统程序<blockquote><p>当目标主机最后一个工具-vim已经编译安装成功之后，开始进行下一阶段</p></blockquote></li></ul><hr><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul><li>此时应该先对系统做一个备份<blockquote><p>因为此时操作此系统的人处于任何原因的手残或其它的失误<br>都会导致新操作系统的完全崩坏</p></blockquote></li></ul><ol><li>然后退出此时的虚拟根环境</li><li>接着再次进入虚拟根环境(为了清理系统)</li><li>利用Strip来清理系统</li><li>清理完成之后退出chroot并重新进入chroot<blockquote><p>从现在开始，每当重新进入LFS系统的chroot环境时，都不应该需要加入<code>/tools</code>参数了<br>因为此时的LFS主机内已经拥有完整的工具环境了</p></blockquote></li><li>进入chroot环境之后进行下一步配置<blockquote><p>包括配置启动脚本(boot loader)，设备处理模块，控制台，网络配置脚本，Bash Shell启动文件等等<br>然后为设备创建惯用的符号链接</p></blockquote></li><li>为了让LFS系统能够启动，还需要配置<code>/etc/fstab</code>文件</li><li>最后安装Linux内核</li><li>当配置完内核之后，安装GRUB并配置GRUB启动菜单</li><li>退出chroot</li><li>卸载虚拟文件系统</li><li>卸载LFS自己的文件系统</li><li>此时应该能够保证GRUB引导装载程序已经被设置，并且按照其启动菜单可以自动启动LFS系统</li></ol><p><strong>shutdown -r now</strong></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><hr><ul><li>需要理解的知识点:</li></ul><ol><li>工具链的制作与配置和对于配置细节的理解<blockquote><p>包括静态库与动态库的配置，应用与理解<br>打上该打的补丁(patch)，批处理文件(sed)，链接器与汇编器的使用与配置(as/ld)</p></blockquote></li><li>链接的过程与程序配置文件的编写<blockquote><p>在进入下一个阶段时对软链接的使用</p></blockquote></li><li>从一个系统到达另一个系统的配置环节<blockquote><p>清理工具(Strip)<br>固化代码</p></blockquote></li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-LFS-v6.6(非官方)<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><h3 id="LFS-补充内容"><a href="#LFS-补充内容" class="headerlink" title="LFS-补充内容"></a>LFS-补充内容</h3><ul><li><p>临时系统环境搭建(分区)</p></li><li><p>临时工具链安装与说明</p></li><li><p>临时工具链配置与说明</p></li><li><p>目标系统环境搭建(chroot)</p></li><li><p>目标工具链安装与说明</p></li><li><p>目标工具链配置与说明</p></li><li><p>然后以chroot进入纯粹的目标系统进行程序编译与安装</p></li><li><p>再然后进行对启动脚本与其它系统所需的最基本脚本进行配置</p></li><li><p>最后再创建fstab与编译并配置内核，重启系统结束</p></li><li><p>具体的脚本配置根据当前本地主机的内核版本而定</p></li><li><p>可参考LFS官方文案，这里不做过多赘述</p></li></ul><hr><ul><li>LFS-v6.2/v6.3所需的最基本脚本配置文件与程序</li></ul><ol><li>配置，编译并安装 LFS-Bootscripts-6.3</li><li>配置setclock脚本 (Configuring the setclock Script)</li><li>配置Linux控制台 (Configuring the Linux Console)</li><li>配置sysklogd脚本 (Configuring the sysklogd Script)</li><li>创建/etc/inputrc文件 (Creating the /etc/inputrc File)</li><li>配置Bash Shell启动文件 (The Bash Shell Startup Files)</li><li>配置localnet脚本 (Configuring the localnet Script)</li><li>自定义/etc/hosts文件 (Customizing the /etc/hosts File)</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li><li>配置网络脚本 (Creating the /etc/fstab File)</li><li>配置，编译并安装Linux-2.6.22.5</li><li>配置GRUB以使得系统可引导 (Making the LFS System Bootable)</li><li>重启操作系统 (Rebooting the System)</li></ol><hr><p><strong>参考资料:</strong></p><ul><li><p>LFS-v6.2/v6.3</p></li><li><p>EN-LFS-书籍仓库<a href="http://www.linuxfromscratch.org/lfs/downloads/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/</code></p></blockquote></li><li><p>EN-LFS-v6.2<a href="http://www.linuxfromscratch.org/lfs/downloads/6.2/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.2/</code></p></blockquote></li><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>具体的中文版可参考金钟国及其所属团队的译本</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:56 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-9&quot;&gt;&lt;a href=&quot;#LFS-9&quot; class=&quot;headerlink&quot; title=&quot;LFS-9&quot;&gt;&lt;/a&gt;LFS-9&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-8</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-8/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-8/</id>
    <published>2020-02-29T20:40:11.000Z</published>
    <updated>2020-02-29T20:44:36.228Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h2 id="LFS-8"><a href="#LFS-8" class="headerlink" title="LFS-8"></a>LFS-8</h2><hr><h3 id="LFS-v6-3基本程序一览"><a href="#LFS-v6-3基本程序一览" class="headerlink" title="LFS-v6.3基本程序一览"></a>LFS-v6.3基本程序一览</h3><ul><li>LFS-v6.3内软件目录(包含版本与章节)</li><li>不包含[GNU 工具链]内程序</li></ul><p><strong>参考资料:</strong></p><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-6.6非官方<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><p><strong>临时主机程序目录</strong></p><p>5.13. Ncurses-5.6<br>5.14. Bash-3.2<br>5.15. Bzip2-1.0.4<br>5.16. Coreutils-6.9<br>5.17. Diffutils-2.8.1<br>5.18. Findutils-4.2.31<br>5.19. Gawk-3.1.5<br>5.20. Gettext-0.16.1<br>5.21. Grep-2.5.1a<br>5.22. Gzip-1.3.12<br>5.23. Make-3.81<br>5.24. Patch-2.5.4<br>5.25. Perl-5.8.8<br>5.26. Sed-4.1.5<br>5.27. Tar-1.18<br>5.28. Texinfo-4.9<br>5.29. Util-linux-2.12r</p><hr><p><strong>目标主机程序目录</strong></p><p>6.13. Berkeley DB-4.5.20<br>6.14. Sed-4.1.5<br>6.15. E2fsprogs-1.40.2<br>6.16. Coreutils-6.9<br>6.17. Iana-Etc-2.20<br>6.18. M4-1.4.10<br>6.19. Bison-2.3<br>6.20. Ncurses-5.6<br>6.21. Procps-3.2.7<br>6.22. Libtool-1.5.24<br>6.23. Perl-5.8.8<br>6.24. Readline-5.2<br>6.25. Zlib-1.2.3<br>6.26. Autoconf-2.61<br>6.27. Automake-1.10<br>6.28. Bash-3.2<br>6.29. Bzip2-1.0.4<br>6.30. Diffutils-2.8.1<br>6.31. File-4.21<br>6.32. Findutils-4.2.31<br>6.33. Flex-2.5.33<br>6.34. GRUB-0.97<br>6.35. Gawk-3.1.5<br>6.36. Gettext-0.16.1<br>6.37. Grep-2.5.1a<br>6.38. Groff-1.18.1.4<br>6.39. Gzip-1.3.12<br>6.40. Inetutils-1.5<br>6.41. IPRoute2-2.6.20-070313<br>6.42. Kbd-1.12<br>6.43. Less-406<br>6.44. Make-3.81<br>6.45. Man-DB-2.4.4<br>6.46. Mktemp-1.5<br>6.47. Module-Init-Tools-3.2.2<br>6.48. Patch-2.5.4<br>6.49. Psmisc-22.5<br>6.50. Shadow-4.0.18.1<br>6.51. Sysklogd-1.4.1<br>6.52. Sysvinit-2.86<br>6.53. Tar-1.18<br>6.54. Texinfo-4.9<br>6.55. Udev-113<br>6.56. Util-linux-2.12r<br>6.57. Vim-7.1</p><hr><p><strong>最终阶段程序</strong></p><p>7.2. LFS-Bootscripts-6.3<br>Linux-2.6.22.5</p><hr><h2 id="相关指令参考"><a href="#相关指令参考" class="headerlink" title="相关指令参考"></a>相关指令参考</h2><ul><li>patch</li><li>sed</li><li>ld</li><li>strip</li></ul><hr><h3 id="patch命令"><a href="#patch命令" class="headerlink" title="patch命令"></a>patch命令</h3><ul><li><p>Linux patch命令用于修补文件(为文件打上补丁)</p><blockquote><p>patch指令让用户利用设置修补文件的方式，修改，更新原始文件<br>倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行<br>如果配合修补文件的方式则能一次修补大批文件<br>这也是Linux系统核心的升级方法之一</p></blockquote></li><li><p>语法:</p><blockquote><p><code>patch [参数] [选项] [原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-patch.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-patch.html</a></p></blockquote></li><li><p>实例:</p></li><li><p><code>$ patch -Np1 i ../expect-5.43.0-spawn-1.patch</code></p><blockquote><p>将<code>expect</code>工具打上补丁<code>expect-5.43.0-spawn-1.patch</code></p></blockquote></li></ul><hr><h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><ul><li><p>Linux sed 命令的作用是利用脚本来处理文本文件</p></li><li><p>sed可依照脚本的指令来处理，编辑文本文件</p></li><li><p>sed主要用来自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等</p></li><li><p>命令语法:</p><blockquote><p><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-sed.html</a></p></blockquote></li><li><p>实例:</p></li><li><p>利用sed命令来确保在非bootstrap编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ld命令"><a href="#ld命令" class="headerlink" title="ld命令"></a>ld命令</h3><ul><li><p>ld 命令是二进制工具集GNU Binutils的一员，是GNU的链接器，用于将目标文件与库链接为可执行文件或库文件</p></li><li><p>命令语法:</p><blockquote><p><code>$ ld [OPTIONS] OBJFILES</code></p></blockquote></li><li><p>实例:</p></li><li><p>链接目标文件生成可执行文件</p></li><li><p>给定C++目标文件<code>test.o</code>与<code>main.o</code>，生成可执行文件<code>test.out</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ld /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o &amp;&amp;</span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtbegin</span>.<span class="title">o</span> /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtend</span>.<span class="title">o</span> &amp;&amp;</span></span><br><span class="line">-L/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5 &amp;&amp;</span></span><br><span class="line">-L/usr/lib64 -L/usr/<span class="class"><span class="keyword">lib</span> -<span class="title">lstdc</span>++ -<span class="title">lm</span> -<span class="title">lgcc_s</span> -<span class="title">lc</span> -<span class="title">lgcc</span>  <span class="title">main</span>.<span class="title">o</span> <span class="title">test</span>.<span class="title">o</span> -<span class="title">o</span> <span class="title">test</span>.<span class="title">out</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>具体参考:<br><a href="https://www.gnu.org/software/binutils/" target="_blank" rel="noopener">https://www.gnu.org/software/binutils/</a><br><a href="https://www.linux.org/docs/man1/ld.html" target="_blank" rel="noopener">https://www.linux.org/docs/man1/ld.html</a><br><a href="https://blog.csdn.net/K346K346/article/details/89088652" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/89088652</a><br><a href="https://dablelv.blog.csdn.net/article/details/88094902" target="_blank" rel="noopener">https://dablelv.blog.csdn.net/article/details/88094902</a><br><a href="http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat" target="_blank" rel="noopener">http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat</a></p></blockquote><ul><li>ld和ld.so的区别<a href="https://www.cnblogs.com/foohack/p/4105717.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.cnblogs.com/foohack/p/4105717.html</code></p></blockquote></li></ul><hr><h3 id="Strip"><a href="#Strip" class="headerlink" title="Strip"></a>Strip</h3><ul><li><p>从特定文件中剥掉一些符号信息和调试信息，使文件变小</p></li><li><p>strip - Discard symbols from object files(from man strip)</p></li><li><p>具体语法:</p><blockquote><p><code>$ strip [-xxx bfdname |--xxx=bfdname]</code><br>strip 之后的任何选项都是自定义参数，这里将不会做过多阐述<br>参考自: <a href="https://blog.csdn.net/qq_37858386/article/details/78559490" target="_blank" rel="noopener">https://blog.csdn.net/qq_37858386/article/details/78559490</a></p></blockquote></li><li><p>实例:</p></li><li><p>清理<code>/tools/lib</code>内所有的debug文件</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-8&quot;&gt;&lt;a href=&quot;#LFS-8&quot; class=&quot;headerlink&quot; title=&quot;LFS-8&quot;&gt;&lt;/a&gt;LFS-8&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-2</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/</id>
    <published>2020-02-29T16:58:18.000Z</published>
    <updated>2020-02-29T16:59:17.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-2"><a href="#GNU-LFS-3-2" class="headerlink" title="GNU LFS-3-2"></a>GNU LFS-3-2</h3><hr><p><strong>目标主机-2</strong></p><ul><li>GCC</li><li>Binutils</li><li>LFS-v6.2/v6.3</li></ul><hr><h3 id="Binutils"><a href="#Binutils" class="headerlink" title="Binutils"></a>Binutils</h3><p><strong>Binutils-2.17/Binutils-2.16.1</strong></p><blockquote><p><code>$ tar xvf $LFS/binutils-2.17/2.16.1.tar.bz2</code><br><code>$ mkdir -v ../binutils-build</code><br><code>$ cd ../binutils-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ../binutils<span class="number">-2.17</span>/<span class="number">2.16</span><span class="number">.1</span>/configure --prefix=/usr \</span><br><span class="line">            --enable-<span class="keyword">shared</span></span><br></pre></td></tr></table></figure></li><li><p>源码编译:</p><blockquote><p><code>$ make tooldir=/usr</code></p></blockquote></li></ul><p><strong>make参数含义:</strong></p><ul><li><p>参数<code>tooldir=/usr</code></p><blockquote><p>通常情况下，tooldir(可执行文件的安装目录)是<code>$(exec_prefix)/$(target_alias)</code><br>例如在i686机器上，将是<code>tt class=&quot;filename&quot;&gt;/usr/i686-pc-linux-gnu</code><br>因为此时只为自己的系统进 行编译，就并不需要在<code>/usr</code>目录后面再存在特殊的后缀<br><code>$(exec_prefix)/$(target_alias)</code>只是在交叉编译时(比如在Intel机器上编译将要在PowerPC上执行的程序)才用到</p></blockquote></li><li><p>编译测试套件:</p><blockquote><p><code>$ make check</code></p></blockquote></li><li><p>编译安装软件包</p><blockquote><p><code>$ make tooldir=/usr install</code></p></blockquote></li><li><p>安装某些软件包需要的<code>libiberty头文件</code></p><blockquote><p><code>$ cp -v ../binutils-2.17/2.16.1/include/libiberty.h /usr/include</code></p></blockquote></li><li><p>Binutils的内容这里不做过多阐述，可参考原文第6.11.2章节</p></li></ul><hr><h3 id="GCC-4-1-2-GCC-4-0-3"><a href="#GCC-4-1-2-GCC-4-0-3" class="headerlink" title="GCC-4.1.2/GCC-4.0.3"></a>GCC-4.1.2/GCC-4.0.3</h3><blockquote><p><code>$ tar xvf $LFS/gcc-4.1.2/4.0.3.tar.bz2</code><br><code>$ cd gcc-4.1.2/4.0.3</code></p></blockquote><ul><li><p>先使用一个sed命令来禁止GCC安装它自己的<code>libiberty.a</code></p></li><li><p>这里将使用Binutils附带的<code>libiberty.a</code>来代替</p><blockquote><p><code>$ sed -i &#39;s/install_to_$(INSTALL_DEST) //&#39; libiberty/Makefile.in</code></p></blockquote></li><li><p>在临时主机中应用的bootstrap编译中，编译器会有<code>-fomit-frame-pointer</code>的标志</p></li><li><p>非bootstrap编译默认是忽略这个标志的，可以应用下面的sed命令来确保编译的可靠性</p><blockquote><p><code>$ sed -i &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in</code></p></blockquote></li><li><p><code>fixincludes脚本</code>偶尔会因为修改系统的头文件而出错</p></li><li><p>因为GCC-4.1.2/4.0.3和Glibc-2.5.1/2.3.6是不需要修改的，运行下面的命令可以避免<code>fixincludes脚本</code>运行:</p><blockquote><p><code>$ sed -i &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in</code></p></blockquote></li><li><p>GCC中提供了一个<code>gccbug脚本</code>，会在编译时侦测<code>mktemp</code>是否存在，并且在测试中加强代码</p></li><li><p>这将会导致脚本使用一些不算很随机的名字来命名临时文件</p></li><li><p>因为我们后面会安装mktemp ，这里就将人为的去模仿它的存在:</p><blockquote><p><code>$ sed -i &#39;s/@have_mktemp_command@/yes/&#39; gcc/gccbug.in</code></p></blockquote></li></ul><blockquote><p><code>$ mkdir -v ../gcc-build</code><br><code>$ cd ../gcc-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/(gcc-4.1.2/4.0.3)/configure <span class="attribute">--prefix</span>=/usr \ </span><br><span class="line"><span class="attribute">--libexecdir</span>=/usr/lib \</span><br><span class="line">--enable-shared \ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix \</span><br><span class="line">--enable-__cxa_atexit \ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu \</span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++</span><br></pre></td></tr></table></figure></li><li><p>参数作用与目标主机内的作用相同，这里不做过多阐述</p></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li>预编译测试:<blockquote><p><code>$ make -k check</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>有的软件包希望C PreProcessor(预处理器)安装在<code>/lib</code>目录下，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv ../usr/bin/cpp /lib</code></p></blockquote></li><li><p>许多软件包使用cc作为C编译器的名字，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv gcc /usr/bin/cc</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-1</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/</id>
    <published>2020-02-29T16:12:11.000Z</published>
    <updated>2020-02-29T16:14:12.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-1"><a href="#GNU-LFS-3-1" class="headerlink" title="GNU-LFS-3-1"></a>GNU-LFS-3-1</h3><ul><li>此下任何关于LFS的讨论都是基于LFS-v6.2/6.3的LiveCD与手册之上的</li><li>程序内所拥有的文件与库这里不做阐述，可参考LFS-v6.2/6.3手册内容</li></ul><hr><p><strong>目标主机-1</strong></p><ul><li>内核头文件安装</li><li>Glibc安装</li><li>目标主机工具链解析</li><li>LFS-v6.2/v6.3</li><li>LFS-v6.3-LiveCD</li></ul><h3 id="内核头文件"><a href="#内核头文件" class="headerlink" title="内核头文件"></a>内核头文件</h3><p><strong>LFS-v6.3</strong></p><ul><li>[Linux-2.6.22.5]安装流程<blockquote><p><code>$ tar xvf $LFS/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code><br><code>$ sed -i &#39;/scsi/d&#39; include/Kbuild</code><br><code>$ make mrproper</code><br><code>$ make headers_check</code><br><code>$ make INSTALL_HDR_PATH=dest headers_install</code><br><code>$ cp -rv dest/include/* /usr/include</code><br><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Linux-Libc-Headers-2.6.12.0</strong></p><ul><li><p>添加一个用户空间头文件和新内核对于<code>inotify</code>特性的系统调用支持:</p><blockquote><p><code>$ patch -Np1 -i ../linux-libc-headers-2.6.12.0-inotify-3.patch</code></p></blockquote></li><li><p>安装内核头文件:</p><blockquote><p><code>$ install -dv /usr/include/asm</code><br><code>$ cp -Rv include/asm-i386/* /usr/include/asm</code><br><code>$ cp -Rv include/linux /usr/include</code></p></blockquote></li><li><p>确保这些头文件的所有者是root:</p><blockquote><p><code>$ chown -Rv root:root /usr/include/{asm,linux}</code></p></blockquote></li><li><p>确保用户可以读取这些头文件:</p><blockquote><p><code>$ find /usr/include/{asm,linux} -type d -exec chmod -v 755 {} \;</code><br><code>$ find /usr/include/{asm,linux} -type f -exec chmod -v 644 {} \;</code></p></blockquote></li><li><p>此时安装的头文件为<code>/usr/include/{asm,linux}/*.h</code></p></li><li><p>头文件内容可参考LFS-v6.2的6.7.2章节，这里不做过多阐述</p></li></ul><hr><p><strong>Man-pages-2.63/Man-pages-2.34</strong></p><ul><li>直接进行编译安装:<blockquote><p><code>$ tar xvf $LFS/man-pages-2.63.tar.bz2</code><br><code>$ cd man-pages-2.63</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf man-pages-2.63</code></p></blockquote></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><p><strong>Glibc-2.5.1/2.3.6</strong></p><ul><li><p>在进行之前请检查一下是否glibc-2.5.1和glibc-build这两个目录已经被删除，如果没有删除请删除后在继续</p></li><li><p>将glibc-libidn包解压到Glibc的源码目录:</p><blockquote><p><code>$ tar xvf $LFS/glibc-2.5.1.tar.bz2</code><br><code>$ cd glibc-2.5.1</code><br><code>$ tar -xvf $LFS/glibc-libidn-2.5.1.tar.gz</code><br><code>$ mv glibc-libidn-2.5.1 libidn</code></p></blockquote></li><li><p>应用下面这个patch来修正软件包在<code>sys/kd.h</code>之后包含<code>linux/types.h</code>导致编译错误:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-linux_types-1.patch</code></p></blockquote></li><li><p>添加一个头文件来定义为新内核对于inotify特性的系统调用函数:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-inotify-1.patch</code></p></blockquote></li><li><p>抑制locale的安装，以避免出现bash的bug</p><blockquote><p><code>$ sed -i &#39;/vi_VN.TCVN/d&#39; localedata/SUPPORTED</code></p></blockquote></li><li><p>当运行make install时，一个叫<code>test-installation.pl</code>的脚本会在我们新安装的Glibc上做一个小的完整性测试</p></li><li><p>然而，由于我们的<code>toolchain</code>仍然指向<code>/tools</code>目录，完整性测试会导致使用错误的Glibc</p></li><li><p>所以必须强制脚本测试刚安装的脚本</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i \ </span><br><span class="line">'s|<span class="type">libs</span> -o|<span class="type">libs</span> -L/usr/lib -Wl,-dynamic-linker=/lib/ld-linux.so<span class="number">.2</span> -o|<span class="type">' \   </span></span><br><span class="line"><span class="type">scripts</span>/test-installation.pl</span><br></pre></td></tr></table></figure></li><li><p>继续运行指令:</p><blockquote><p><code>$ sed -i &#39;s|@BASH@|/bin/bash|&#39; elf/ldd.bash.in</code><br><code>$ mkdir -v</code><br><code>$ ../glibc-build</code><br><code>$ cd ../glibc-build</code></p></blockquote></li><li><p>配置安装脚本:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure </span><br><span class="line">-<span class="ruby">-prefix=<span class="regexp">/usr \ </span></span></span><br><span class="line"><span class="ruby">--disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \ </span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--libexecdir=<span class="regexp">/usr/lib</span><span class="regexp">/glibc</span></span></span><br></pre></td></tr></table></figure></li><li><p>新参数说明:</p></li><li><p>参数<code>--libexecdir=/usr/lib/glibc</code></p><blockquote><p>把<code>pt_chown</code>程序的位置从默认的<code>/usr/libexec</code>改为<code>/usr/lib/glibc</code></p></blockquote></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li><p>对结果进行测试:</p><blockquote><p><code>$ make -k check 2&gt;&amp;1 | tee glibc-check-log</code><br><code>$ grep Error glibc-check-log</code></p></blockquote></li><li><p>在安装Glibc的过程中，它会警告缺少<code>/etc/ld.so.conf</code>文件</p></li><li><p>其实这没什么关系，不过下面的命令能修正它:</p><blockquote><p><code>$ touch /etc/ld.so.conf</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>(LFS-v6.2独有)此部还需要安装<code>inotify头文件</code>到系统头文件的地方:</p><blockquote><p><code>$ cp -v ../glibc-2.3.6/sysdeps/unix/sysv/linux/inotify.h \ /usr/include/sys</code></p></blockquote></li><li><p>一次安装所有列在<code>glibc-2.3.6/localedata/SUPPORTED</code>中的<code>locales</code></p><blockquote><p><code>$ make localedata/install-locales</code></p></blockquote></li></ul><hr><p><strong>配置Glibc</strong></p><ul><li><p>此时需要建立<code>/etc/nsswitch.conf</code>文件</p></li><li><p>因为在这个文件丢失或不正确的情况下，Glibc会使用默认配置，而Glibc的默认配置无法很好地在网络环境下工作</p></li><li><p>并且我们也需要设置自己的时区</p></li><li><p>建立一个新的<code>/etc/nsswitch.conf</code>文件:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/nsswitch.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"># Begin /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">passwd: <span class="keyword">files</span> </span><br><span class="line">group: <span class="keyword">files</span> </span><br><span class="line">shado<span class="variable">w:</span> <span class="keyword">files</span></span><br><span class="line">host<span class="variable">s:</span> <span class="keyword">files</span> dns </span><br><span class="line">network<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">protocol<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">service<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">ether<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">rpc: <span class="keyword">files</span> </span><br><span class="line"># End /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>设置时区:</p><blockquote><p><code>$ cp -v --remove-destination /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p></blockquote></li><li><p>配置动态链接库加载程序</p></li><li><p>写入配置</p></li><li><p>LFS-v6.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;ld.so.conf &lt;&lt; &quot;EOF&quot; </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib </span><br><span class="line">&#x2F;opt&#x2F;lib </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>LFS-v6.2</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"># Begin /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span></span><br><span class="line">/usr/<span class="keyword">local</span>/lib </span><br><span class="line">/opt/lib</span><br><span class="line"># End /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote><ul><li>glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误，还有一些能引起错误的LFS手册上有所提及</li><li>由此某些情况的错误可以无视</li></ul><hr><h3 id="调整目标主机工具链"><a href="#调整目标主机工具链" class="headerlink" title="调整目标主机工具链"></a>调整目标主机工具链</h3><ul><li><p>现在，最终的C库已经安装好了，此时需要再次调整工具链，让本章随后编译的那些工具都连接到这个库上</p></li><li><p>基本上，就是把临系统时增加中调整工具链那里做的调整给取消掉</p></li><li><p>在临时系统中，工具链使用的库是从宿主系统的<code>/{,usr/}lib</code>转向新安装的<code>/tools/lib</code>目录</p></li><li><p>同样的，现在工具链使用的库将从临时的<code>/tools/lib</code>转向LFS系统最终的<code>/{,usr/}lib</code>目录</p></li><li><p>首先，备份<code>/tools</code>下的链接</p><blockquote><p>用刚才在临时主机中编译的链接器来替换<br>再创建一个链接到在<code>/tools/$(gcc -dumpmachine)/bin</code>中的副本</p></blockquote></li><li><p>执行以下命令:</p><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote></li><li><p>接下来，修正GCC的specs文件，使它指向新的动态链接器</p></li><li><p>这样GCC才能知道在哪能发 现开始文件</p></li><li><p>这里应用一个sed命令:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | sed <span class="string">\</span> </span><br><span class="line">-e <span class="string">'s@/tools/lib/ld-linux.so.2@/lib/ld-linux.so.2@g'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*startfile_prefix_spec:/&#123;n;s@.*@/usr/lib/ @&#125;'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*cpp:/&#123;n;s@$@ -isystem /usr/include@&#125;'</span> &gt; <span class="string">\</span> </span><br><span class="line">`dirname $(gcc --<span class="built_in">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>还可以利用perl命令</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | \ </span><br><span class="line">perl -p -e's<span class="comment">@/tools/lib/ld-linux.so.2@</span>/<span class="keyword">lib</span>/ld-linux.so<span class="number">.2</span><span class="comment">@g;' \</span></span><br><span class="line"><span class="comment">-e 's@</span>\*startfile_prefix_spec:\n<span class="comment">@$_/usr/lib/ @</span>g;' &gt; \</span><br><span class="line">`dirname$(gcc --<span class="keyword">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>如果此时本地主机的系统平台上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须把上面命令里的<code>ldlinux.so.2</code>换成此时本地主机的系统平台上动态连接器的名字</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-1&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-1&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-4</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/</id>
    <published>2020-02-29T11:26:43.000Z</published>
    <updated>2020-02-29T11:27:56.144Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-4"><a href="#GNU-LFS-2-4" class="headerlink" title="GNU LFS-2-4"></a>GNU LFS-2-4</h2><ul><li>[GNU 工具链]全面逻辑梳理</li><li>重点在于配置链接器与工具链的逻辑</li></ul><hr><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul><li>可以将临时主机的工具链搭建分为两部分</li><li>前半部分为第一遍编译并安装GCC，Binutils和内核头文件</li><li>后半部分为编译并安装Glibc，在配置完Glibc之后，正式调整临时工具链并再次安装GCC与Binutils</li><li>第一步与第二部和第五步与第六步的顺序没有严格规定</li><li>但对GCC与Binutils的第二次编译安装必须在先配置并且编译安装完Glibc之后再进行</li></ul><hr><ul><li><code>Binutils-&gt;GCC-&gt;Headres-&gt;GLibc-&gt;Tools调整-&gt;Binutils-&gt;GCC/C++补丁</code></li><li>参考至<code>LFSv6.2/6.3</code></li></ul><hr><ul><li>因为这里所使用的LiveCD是LFS官方提供的</li><li>由于官方于6.3版本之后就停止维护了</li><li>所以这里只介绍6.3及以下版本</li></ul><hr><ul><li>这里将以下七个工具所需要的</li><li>每个工具编译的重要步骤</li><li>与对工具链的链接和链接器的配置进行了逻辑的梳理</li></ul><hr><h3 id="1-Binutils-Pass-1"><a href="#1-Binutils-Pass-1" class="headerlink" title="1. Binutils Pass-1"></a>1. Binutils Pass-1</h3><ul><li>编译并安装过后</li><li>为调整工具链而准备链接器</li></ul><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/tools/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote><ul><li>参数<code>-C ld LIB_PATH=/tools/lib</code></li><li>指定<code>Makefile</code>的<code>LIB_PATH</code>变量值</li><li>使其明确指向临时工具目录，以覆盖默认值</li><li>这个变量同时还指定了链接器的默认库搜索路径</li><li>在编译完Glibc后就会用到</li></ul><hr><h3 id="2-GCC-Pass-1"><a href="#2-GCC-Pass-1" class="headerlink" title="2. GCC Pass-1"></a>2. GCC Pass-1</h3><ul><li>编译并安装过后</li><li>创建gcc的符号链接为cc，以保证兼容性<blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li></ul><hr><h3 id="3-kernel-headers-API"><a href="#3-kernel-headers-API" class="headerlink" title="3. kernel headers API"></a>3. kernel headers API</h3><ul><li>将头文件编译并复制到所需目录</li></ul><hr><h3 id="4-Glibc"><a href="#4-Glibc" class="headerlink" title="4. Glibc"></a>4. Glibc</h3><ul><li>编译并安装C标准库</li><li>执行<code>touch /tools/etc/ld.so.conf</code></li><li>以修补安装过程中缺少的<code>/tools/etc/ld.so.conf</code></li></ul><hr><h3 id="5-调整工具链-LFS-v6-2-v6-3"><a href="#5-调整工具链-LFS-v6-2-v6-3" class="headerlink" title="5. 调整工具链(LFS-v6.2/v6.3)"></a>5. 调整工具链(LFS-v6.2/v6.3)</h3><ul><li><p>在临时系统的C标准库安装好之后</p></li><li><p>需要将临时工具链中的所有工具都连接到C标准库之上</p></li><li><p>为了达到这个目标，必须调整链接器和编译器的space文件</p></li><li><p>因为Binutils Pass-1的时候以经调整过链接器了</p></li><li><p>所以现在需要做的只是将其重新命名并被正确的找到和使用</p></li><li><p>方法是备份原来的链接器，然后再用调整过的链接器来替代</p></li><li><p>最后再创建一个指向<code>/tools/$(gcc -dumpmachine)/bin</code>中链接器副本的链接</p></li></ul><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote><ul><li>从现在开始，所有程序都将连接到<code>/tools/lib</code>中的库文件</li></ul><hr><ul><li><p>接下来需要做的就是修正GCC中的spaces文件</p></li><li><p>目的是使他指向一个新的动态链接器</p></li><li><p>本质上就是把specs中所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>这里用的是sed命令，有两种语法(分别是LFS-v6.2与LFS-v6.3)</p></li><li><p>如果当前的本地主机上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须人为的把以下命令里的<code>ldlinux.so.2</code>换成本地主机的系统平台上动态连接器的名</p></li><li><p>LFS-v6.2</p></li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFIL</span><br></pre></td></tr></table></figure><ul><li>LFS-v6.3</li></ul><blockquote><p><code>$ gcc -dumpspecs | sed &#39;s@^/lib/ld-linux.so.2@/tools&amp;@g&#39; &gt;</code>dirname $(gcc -print-libgcc-file-name)<code>/ specs</code></p></blockquote><hr><ul><li><p>最后删除GCC专属头文件目录中的头文件，以避免宿主机中的头文件污染编译环境</p></li><li><p>这里的命令v6.2与v6.3没有区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>工具链的调整方法有好几种</p></li><li><p>而且不同版本GCC的specs可能会有不同</p></li><li><p>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>还直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件</p></li></ul><hr><h3 id="6-Binutils-Pass-2"><a href="#6-Binutils-Pass-2" class="headerlink" title="6. Binutils Pass-2"></a>6. Binutils Pass-2</h3><ul><li><p>编译并安装</p></li><li><p>编译配置中配置参数<code>--with-lib-path=/tools/lib</code></p></li><li><p>以指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code></p></li><li><p>以防止连接器搜索宿主系统的库目录</p></li><li><p>最后为目标主机的调整工具链阶段配置链接器:</p><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/usr/lib:/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote></li></ul><hr><h3 id="7-GCC-C-补丁-Pass-2"><a href="#7-GCC-C-补丁-Pass-2" class="headerlink" title="7. GCC/C++补丁 Pass-2"></a>7. GCC/C++补丁 Pass-2</h3><ul><li><p>在GCC编译过程中会运行<code>fixincludes脚本</code>来扫描系统头文件目录</p></li><li><p>并找出需要修正的头文件，然后把修正后的头文件放到GCC专属头文件目录里</p></li><li><p>因为现在GCC和Glibc已经安装完毕，而且它们的头文件已知无需修正</p></li><li><p>所以这里并不需要<code>fixincludes脚本</code></p></li><li><p>必须先禁止fixincludes运行，以保证编译环境不受原主机所污染</p><blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig} &amp;&amp;</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li><p>因为在前几步中编译的GCC Pass-1中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项</p></li><li><p>而非<code>bootstrap</code>编译则默认忽略了该选项</p></li><li><p>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项</p></li><li><p>用以保持一致性:</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure><ul><li><p>然后使用补丁修改补丁修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置:</p><blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li><p>该命令同时还把/usr/include`从GCC的头文件搜索路径里删掉</p></li><li><p>现在预先打补丁而不是在安装GCC之后调整specs文件可以保证新的动态连接器在编译GCC的时候就用上</p></li><li><p>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></li><li><p>然后配置编译器，并进行编译与编译安装</p></li><li><p>关于GCC的C++是在LFS-v9.0中出现的，这里先不做过多阐述</p></li></ul><hr><ul><li>至此结束临时主机的[GNU 工具链]配置环节</li><li>下一步即为配置其它的辅助命令与工具链所处的大环境</li><li>从而为目标主机提供应有的功能与服务</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-2-4&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-4&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-3</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-3/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-3/</id>
    <published>2020-02-29T11:22:36.000Z</published>
    <updated>2020-02-29T11:26:27.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-3"><a href="#GNU-LFS-2-3" class="headerlink" title="GNU LFS-2.3"></a>GNU LFS-2.3</h3><ul><li>GCC Pass-2</li><li>Bintils Pass-2</li></ul><hr><h3 id="Bintils-Pass-2"><a href="#Bintils-Pass-2" class="headerlink" title="Bintils Pass-2"></a>Bintils Pass-2</h3><ul><li>Binutils-2.16.1/LFS-6.2 Pass-2 154 MB 1.1 SBU</li><li>Binutils-2.17/LFS-6.3 Pass 2</li><li>Binutils-2.32/LFS-9.0 Pass-2 879 MB 1.1 SUB</li></ul><hr><p><strong>Binutils-2.16.1/2.17</strong></p><ul><li>解压文件并进入编译目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li></ul><p>编译配置</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="string">../binutils-2.17</span><span class="params">(-2.16.1)</span><span class="string">/configure</span> <span class="params">--prefix=/tools</span> \</span><br><span class="line"><span class="params">--disable-nls</span> \ </span><br><span class="line"><span class="params">--with-lib-path=/tools/lib</span></span><br></pre></td></tr></table></figure><ul><li><p>新参数含义:</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这个选项指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code><br>以防止连接器搜索宿主系统的库目录</p></blockquote></li><li><p>编译及安装</p><blockquote><p><code>$ make</code><br><code>$ make install</code></p></blockquote></li><li><p>为目标机器的工具链调整配置连接器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new/tools/bin</span><br></pre></td></tr></table></figure></li><li><p>最后清理一下</p><blockquote><p><code>$ cd .. rm -rf binutils-build</code><br><code>$ rm -rf binutils-2.17</code></p></blockquote></li></ul><hr><p><strong>Binutils-2.32</strong></p><ul><li>编译配置<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                \ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                 \ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib         \ </span><br><span class="line"><span class="built_in">..</span>/configure                 \    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools          \    </span><br><span class="line">--disable-nls             \    </span><br><span class="line">--disable-werror        \   </span><br><span class="line"><span class="attribute">--with-lib-path</span>=/tools/lib  \  </span><br><span class="line"> --with-sysroot</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数含义:</strong></p><ul><li><p>参数<code>CC=$LFS_TGT-gcc</code>,<code>AR=$LFS_TGT-ar</code>,<code>RANLIB=$LFS_TGT-ranlib</code></p><blockquote><p>因为这是真正的原生编译Binutils，设置这些变量能确保编译系统使用交叉编译器和相关的工具，而不是 宿主系统中已有的</p></blockquote></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这告诉配置脚本在编译Binutils的时候指定库搜索目录，此处将<code>/tools/lib</code>传递到链接器</p></blockquote></li><li><p>参数<code>--with-sysroot sysroot</code></p><blockquote><p>功能使链接器可以找到包括在其命令行中的其它共享对象明确需要的共享对象<br>否则的话，在某些主机上一些软件包可能会编译不成功</p></blockquote></li><li><p>之后进行编译安装</p></li><li><p>为目标机器中的工具链阶段准备链接器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>make 参数说明</strong></p><ul><li>参数<code>-C ld clean</code><blockquote><p>用于告诉make程序移除所有ld子目录中编译过的文件</p></blockquote></li><li>参数<code>-C ld LIB_PATH=/usr/lib:/lib</code><blockquote><p>这个选项重新编译ld子目录中的所有文件<br>在命令行中指定<code>Makefile</code>的<code>LIB_PATH</code>变量可以使我们能 够重写临时工具的默认值并指向正确的最终路径<br>该变量的值指定链接器的默认库搜索路径<br>目标主机中会用到这个准备</p></blockquote></li></ul><hr><h3 id="GCC-Pass-2"><a href="#GCC-Pass-2" class="headerlink" title="GCC Pass-2"></a>GCC Pass-2</h3><ul><li>GCC 9.2.0 LFS-9.0 3.7 GB/15 SBU</li><li>GCC 4.1.2 LFS-6.3</li><li>GCC 4.0.3 LFS-6.2 443 MB/4.2 SBU</li></ul><hr><p><strong>GCC 4.1.2/4.0.3 Pass-2</strong></p><blockquote><p><code>$ tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</code><br><code>$ cd gcc-4.1.2</code></p></blockquote><ul><li>禁止fixincludes脚本运行，以保证编译环境不被污染<blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig}</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li>因为在之前的<code>GCC Pass-1</code>中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项，而非bootstrap`编译则默认忽略了该选项</li><li>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性<blockquote><p><code>$ cp -v gcc/Makefile.in{,.tmp}</code><br><code>$ sed &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in.tmp gcc \</code><br><code>&gt; Makefile.in</code></p></blockquote></li><li>使用下面的补丁来修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置，同时把<code>/usr/include</code>从GCC的头文件搜索路径里删掉:<blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li>预先打补丁而不是在安装GCC之后调整specs文件的作用是:<blockquote><p>可以保证新的动态连接器在编译GCC的时候就用上<br>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></blockquote></li><li>此补丁非常重要，必须进行使用才能成功编译</li></ul><ul><li>GCC Pass-2 编译配置:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -v <span class="built_in">..</span>/gcc-build</span><br><span class="line">$ cd <span class="built_in">..</span>/gcc-build </span><br><span class="line">$ <span class="built_in">..</span>/gcc-4.1.2/configure <span class="attribute">--prefix</span>=/tools \ </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools \ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu \</span><br><span class="line">--enable-shared \ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix \</span><br><span class="line">--enable-__cxa_atexit \ </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++ \</span><br><span class="line">--disable-libstdcxx-pch</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数解析:</strong><br><code>--prefix=/tools</code><br><code>--with-local-prefix=/tools</code></p><ul><li>参数<code>--enable-clocale=gnu</code><blockquote><p>用于确保确保C++库在任何情况下都使用正确的locale模块</p></blockquote></li><li>参数<code>--enable-threads=posix</code><blockquote><p>用于使C++异常能处理多线程代码</p></blockquote></li><li>参数<code>--enable-__cxa_atexit</code><blockquote><p>用<code>__cxa_atexit</code>代替<code>atexit</code>来登记C++对象的本地静态和全局析构函数<br>这是为了完全符合标准对析构函数的处理规定</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>用于编译C和C++语言的编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译头(PCH)，它占用了很大空间，并且在此版本中用不到它</p></blockquote></li></ul><hr><p><strong>编译安装并清理:</strong></p><blockquote><p><code>$ make</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote><hr><p><strong>GCC 9.2.0 Pass-2</strong></p><ul><li><p>因为在第一次编译GCC的时候安装了一些内部系统头文件</p></li><li><p>其中的一个<code>limits.h</code>会反过来包括对应的系统头文件<code>limits.h</code>，在本次的实例中，是<code>/tools/include/limits.h</code></p></li><li><p>但是，第一次编译gcc的时候<code>/tools/include/limits.h</code>并不存在</p></li><li><p>因此GCC安装的内部头文件只是部分的自包含文件，并不包括系 统头文件的扩展功能</p></li><li><p>这足以编译临时libc，但是这次编译GCC要求完整的内部头文件</p></li><li><p>使用和正常情况下GCC编译系统使用的相同的命令创建一个完整版本的内部头文件:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat gcc/limitx.h gcc/glimits.h gcc/limity.h &gt; \  </span><br><span class="line">`dirname <span class="constructor">$($LFS_TGT-<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`/<span class="keyword">include</span>-fixed/limits.h</span><br></pre></td></tr></table></figure></li><li><p>再一次更改 GCC 的默认动态链接器的位置，使用安装在<code>/tools</code>的那个</p></li><li><p>执行以下配置:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ for file in gcc/config/&#123;linux,i386/linux&#123;,64&#125;&#125;<span class="string">.h</span> </span><br><span class="line">do  </span><br><span class="line">cp -uv $file&#123;,<span class="string">.orig</span>&#125;  </span><br><span class="line">sed -e 's@<span class="string">/lib</span>\<span class="params">(64\)</span>\?\<span class="params">(32\)</span>\?<span class="string">/ld</span>@<span class="string">/tools</span>&amp;@g' \</span><br><span class="line">       -e 's@<span class="string">/usr</span>@<span class="string">/tools</span>@g' $file.orig &gt; $file  </span><br><span class="line"><span class="keyword">echo</span> ' </span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_1 </span></span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_2 </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/" </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file  </span></span><br><span class="line">touch $file.orig </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>环境上构建，为64位库改变默认目录名至<code>lib</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $(uname -m) <span class="keyword">in</span>  </span><br><span class="line">x86_64)    </span><br><span class="line">sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \        </span><br><span class="line">-i.orig gcc/config/i386/t-linux64  </span><br><span class="line">;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p>和第一次编译GCC一样，它要求GMP,MPFR和MPC软件包</p></li><li><p>解压tar包并把它们重名为到所需的文件夹名</p></li><li><p>执行以下命令:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xf ../mpfr<span class="number">-4.0</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v mpfr<span class="number">-4.0</span><span class="number">.2</span> mpfr </span><br><span class="line">$ tar -xf ../gmp<span class="number">-6.1</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v gmp<span class="number">-6.1</span><span class="number">.2</span> gmp </span><br><span class="line">$ tar -xf ../mpc<span class="number">-1.1</span><span class="number">.0</span>.tar.gz </span><br><span class="line">$ mv -v mpc<span class="number">-1.1</span><span class="number">.0</span> mpc</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>在开始编译 GCC 之前，注意要取消所有会覆盖默认优化选项的环境变量</p></li><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                                   \ </span><br><span class="line"><span class="attribute">CXX</span>=<span class="variable">$LFS_TGT</span>-g++                               \ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                                 \ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib                             \ </span><br><span class="line"><span class="built_in">..</span>/configure                                      \    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                                \    </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools                 \    </span><br><span class="line"><span class="attribute">--with-native-system-header-dir</span>=/tools/include    \    </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++                                \    </span><br><span class="line">--disable-libstdcxx-pch                               \    </span><br><span class="line">--disable-multilib                                     \    </span><br><span class="line">--disable-bootstrap                            \    </span><br><span class="line">--disable-libgomp</span><br></pre></td></tr></table></figure></li></ul><p><strong>新参数说明:</strong></p><ul><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保编译了C 和C++编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译的头文件(PCH)<br>这会花费很多时间，却对我们没有用处</p></blockquote></li><li>参数<code>--disable-bootstrap</code><blockquote><p>对于原生编译的 GCC，默认是做一个[引导]构建<br>这不仅会编译GCC一次，而是会编译很多次</p></blockquote></li></ul><hr><ul><li>然后执行编译安装等操作</li><li>在编译并安装过后，可以为其设置符号链接(<code>gcc-&gt;cc</code>)<blockquote><p><code>$ ln -sv gcc /tools/bin/cc</code></p></blockquote></li><li>很多程序和脚本执行cc而不是gcc来保证程序的通用性<blockquote><p>并且在所有的Unix类型的系统上都能用<br>而非仅局限于安装了GCC的Unix 类型的系统</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>LFS-v6.2</li><li>LFS-v6.3</li><li>LFS-v9.0</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-2-3&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-3&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-2</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/</id>
    <published>2020-02-29T00:28:41.000Z</published>
    <updated>2020-02-29T00:31:56.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-2"><a href="#GNU-LFS-2-2" class="headerlink" title="GNU LFS-2-2"></a>GNU LFS-2-2</h3><ul><li><p>内容简述</p><blockquote><p>Linux Kernel Headeres(CN-LFS-6.2/6.3/9.0)<br>Glibc/Libstdc++(CN-LFS-6.2/6.3/9.0)<br>第一遍的工具链调整(CN-LFS-6.2/6.3/9.0)</p></blockquote></li><li><p>说明内容:</p></li><li><p>本篇内容将新版和旧版的资料相融合(将新版补充旧版的内容)</p></li><li><p>同时将其它的学习资料补充进LFS官方的文档内</p></li><li><p>在区分版本说明时，会先去介绍6.3再解释其它版本</p></li></ul><hr><h3 id="Linux-API-Headers"><a href="#Linux-API-Headers" class="headerlink" title="Linux API Headers"></a>Linux API Headers</h3><ul><li><p>每个版本的Linux kernel headers的名字都不一样</p></li><li><p>这里整合性的指出了三个版本的安装方法，分别是:</p><blockquote><p>Linux-2.6.22.5 API Headers(LFS-6.3)<br>Linux-5.2.8 API (LFS-9.0)<br>Linux-Libc-Headers-2.6.12.0 (LFS-6.2)</p></blockquote></li><li><p>新建编译目录和清理工作这里就不做过多阐述了</p></li></ul><hr><p><strong>Version-2.6.22.5(LFS-v6.3)</strong></p><ul><li>解压并进入文件夹<blockquote><p><code>$ tar xvf /lfs-sources/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code></p></blockquote></li></ul><p>清除所有存在的多余依赖关系:</p><blockquote><p><code>$ make mrproper</code></p></blockquote><p>编译头文件</p><blockquote><p><code>$ make headers_check</code></p></blockquote><ul><li><p>从源代码中提取用户可见的内核头文件到指定位置</p><blockquote><p><code>$ make INSTALL_HDR_PATH=dest headers_install</code></p></blockquote></li><li><p>保存在一个临时本地文件夹中然后复制到所需的位置</p><blockquote><p><code>$ cp -rv dest/include/* /tools/include</code></p></blockquote></li><li><p>清理</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Version-5.2.8(LFS-v9.0)</strong></p><ul><li><p>大致构建用时: 0.1 SBU</p></li><li><p>所需磁盘空间: 960 MB</p></li><li><p>清除依赖项</p><blockquote><p><code>$ make mrproper</code></p></blockquote></li><li><p>从源代码中提取用户可见的内核头文件</p></li><li><p>把它们保存在一个临时本地文件夹中然后复制到所需的位置</p></li><li><p>因为解压过程会移除目标文件夹中任何已有的文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">make</span> INSTALL_HDR_PATH=dest headers_install</span><br><span class="line"><span class="keyword">cp</span> -<span class="keyword">rv</span> dest/include/* /tools/include</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Version-2.6.12.0(LFS-未知版本)</strong></p><ul><li><p>Linux-Libc-Headers-2.6.12.0</p></li><li><p>Linux-Libc-Headers内包含了纯净的内核头文件</p></li><li><p>预计编译时间：少于0.1</p></li><li><p>SBU所需磁盘空间：27MB</p></li><li><p>安装这些头文件所需指令:</p><blockquote><p><code>cp -Rv include/asm-i386 /tools/include/asm</code><br><code>cp -Rv include/linux /tools/include</code></p></blockquote></li><li><p>asm-i386为架构参数，需要自行进行调整</p></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><ul><li>Glibc-2.5.1</li><li>Glibc-2.30</li></ul><hr><p><strong>Glibc-2.5.1</strong></p><ul><li><p>LFS-v6.3</p></li><li><p>解压并进入编译目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/glibc-2.5.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v glibc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> glibc-build</span></span><br></pre></td></tr></table></figure></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure --prefix=/tools \</span><br><span class="line">-<span class="ruby">-disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \</span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--with-binutils=<span class="regexp">/tools/bin</span> \ </span></span><br><span class="line"><span class="ruby">--without-gd \</span></span><br><span class="line"><span class="ruby">--with-headers=<span class="regexp">/tools/include</span> \ </span></span><br><span class="line"><span class="ruby">--without-selinux</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>--prefix=/tools</code></p><blockquote><p>用于指定安装目录</p></blockquote></li><li><p>参数<code>--disable-profile</code></p></li><li><p>参数<code>--enable-add-ons</code></p><blockquote><p>用于指示Glibc使用附加的NPTL包作为线程库</p></blockquote></li><li><p>参数<code>--enable-kernel=2.6.0</code></p><blockquote><p>用于告诉Glibc编译支持2.6.x内核的库</p></blockquote></li><li><p>参数<code>--with-binutils=/tools/bin</code></p><blockquote><p>用于保证在编译Glibc时不会用错Binutils程序</p></blockquote></li><li><p>参数<code>--without-gd</code></p><blockquote><p>可以保证不生成memusagestat程序</p></blockquote></li><li><p>参数<code>--with-headers=/tools/include</code></p><blockquote><p>数指示Glibc按照前面刚刚安装到tools目录中的内核头文件编译自己<br>从而精确的知道内核的特性以根据这些特性对自己进行最佳化编译</p></blockquote></li><li><p>参数<code>--without-selinux</code></p><blockquote><p>用于明确禁用含有SELinux特性的Glibc，以防止会出现许多操作失败的结果</p></blockquote></li><li><p>其中参数<code>--enable-kernel=2.6.0</code>，只是为了说明kernel的大版本</p><blockquote><p>所以不需要根据实际的kernel版本来改<br>即使是用linux-2.6.15也一样只写2.6.0就可以了</p></blockquote></li><li><p>编译至二进制格式</p><blockquote><p><code>$make</code></p></blockquote></li><li><p>配置链接器</p><blockquote><p><code>$ mkdir -v /tools/etc</code><br><code>$ touch /tools/etc/ld.so.conf</code></p></blockquote></li><li><p>编译安装</p><blockquote><p><code>$ make install</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote></li></ul><hr><p><strong>Glibc-2.30</strong></p><ul><li><p>Glibc 软件包包含了主要的 C 函数库</p></li><li><p>这个库提供了分配内存，搜索目录，打开关闭文件，读写文件，操作字 符串，模式匹配，基础算法等基本程序</p></li><li><p>大致构建用时: 4.8 SBU</p></li><li><p>所需磁盘空间: 896 MB</p></li><li><p>编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/glibc-2.5.1/configure              \      </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                    \      </span><br><span class="line"><span class="attribute">--host</span>=<span class="variable">$LFS_TGT</span>                    \      </span><br><span class="line"><span class="attribute">--build</span>=$(../scripts/config.guess) \      </span><br><span class="line"><span class="attribute">--enable-kernel</span>=3.2                \      </span><br><span class="line"><span class="attribute">--with-headers</span>=/tools/include</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p><code>$ --host=$LFS_TGT, --build=$(../scripts/config.guess)</code></p><blockquote><p>这些选项的组合效果是Glibc的构建系统配置它自己用<code>/tools</code>里面的交叉链接器和交叉编译器交叉编译自己</p></blockquote></li><li><p><code>$ --enable-kernel=3.2</code></p><blockquote><p>这告诉Glibc编译能支持3.2以及之后的内核库<br>更早的内核版本不受支持</p></blockquote></li><li><p><code>$ --with-headers=/tools/include</code>告诉Glibc利用刚刚安装在tools文件夹中的头文件编译自身</p><blockquote><p>此能够根据内核的具体特性提供更好的优化</p></blockquote></li><li><p>在新版本的配置中，不仅需要安装C语言的标准库，还需要安装与配置对C++支持的标准库</p></li><li><p>Libstdc++是标准的C++库</p></li><li><p>需要用它来编译C++ 代码(GCC的一部分是用C++写的)</p></li><li><p>但是在构建GCC Pass-1时，我们需要推迟它的安装进程，因为依赖的glibc，还未部署在<code>/tools</code>目录中</p></li><li><p>大致构建用时: 0.5 SBU</p></li><li><p>所需磁盘空间: 879 MB</p></li><li><p>记得新建源码编译目录与编译完清理，这里不对此部分进行赘述了</p></li><li><p>因为Libstdc++是GCC源文件的一部分</p></li><li><p>所以首先应该解压GCC的压缩包，然后进入<code>gcc-9.2.0</code>文件夹</p></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../libstdc++-v3/configure             \    </span><br><span class="line">-<span class="ruby">-host=$LFS_TGT                 \    </span></span><br><span class="line"><span class="ruby">--prefix=<span class="regexp">/tools                 \    </span></span></span><br><span class="line"><span class="ruby">--disable-multilib              \    </span></span><br><span class="line"><span class="ruby">--disable-nls                   \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-threads     \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-pch         \    </span></span><br><span class="line"><span class="ruby">--with-gxx-<span class="keyword">include</span>-dir=<span class="regexp">/tools/</span>$LFS_TGT/<span class="keyword">include</span>/c++<span class="regexp">/9.2.0</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>配置说明:</strong></p><ul><li><p>参数<code>--host=...</code></p><blockquote><p>用于指示使用我们刚才编译的交叉编译器，而不是<code>/usr/bin</code>中的</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-threads</code></p><blockquote><p>由于我们还没有编译C线程库，C++的也还不能编译</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-pch</code></p><blockquote><p>此选项防止安装预编译文件，此步骤并不需要</p></blockquote></li><li><p>参数<code>--with-gxx-include-dir=/tools/$LFS_TGT/include/c++/9.2.0</code></p><blockquote><p>这是C++编译器搜索标准include文件的位置<br>在一般的编译中，这个信息自动从顶层文件夹中传入Libstdc++ configure选项<br>在我们的例子中，必须明确给出这信息</p></blockquote></li><li><p>进行编译安装</p><blockquote><p>$ make<br>$ make install</p></blockquote></li></ul><hr><p><strong>其它情况</strong></p><ul><li>在编译过程中可能会发生以下警告</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure: WARNING: </span><br><span class="line"><span class="comment">*** These auxiliary programs are missing or </span></span><br><span class="line"><span class="comment">*** incompatible versions: msgfmt </span></span><br><span class="line"><span class="comment">*** some features will be disabled. </span></span><br><span class="line"><span class="comment">*** Check the INSTALL file for required versions.</span></span><br></pre></td></tr></table></figure><ul><li>msgfmt程序的缺失或者不兼容通常是无害的</li><li>这个msgfmt程序是Gettext软件包的一部分，主机发行版应该提供了</li></ul><hr><h3 id="调整工具链"><a href="#调整工具链" class="headerlink" title="调整工具链"></a>调整工具链</h3><ul><li>根据自身情况进行工具链调整</li><li>以下实例为LFS-v6.3的配置代码</li><li>同时也包括了部分LFS-v6.2的内容</li></ul><hr><p><strong>调整思路:</strong></p><ul><li>因为现在临时的C库已经装好，接下来本章中要编译的所有工具应该连接到这些库上</li><li>为了达到这个目标，需要调整连接器和编译器的specs文件</li><li>在第一遍编译Binutils快结束时已经调整过的连接器，现在需要被重新命名以便可以被正确的找到和使用</li><li>首先备份原来的连接器，然后用调整过的连接器来替代</li><li>最后还要创建一个指向<code>/tools/$(gcc-dumpmachine)/bin</code>中连接器副本的连接</li><li>如果当前本地主机的系统平台上，动态连接器的名字不是<code>ld-linux.so.2</code></li><li>必须人为的把spaces配置里的<code>ldlinux.so.2</code>换成你的系统平台上动态连接器的名字</li></ul><hr><ul><li>以下为工具链配置代码(LFS-6.3)<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;ld-<span class="keyword">new</span>,ld&#125; </span><br><span class="line">$ ln -sv /tools/bin/ld /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/ld </span><br><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>语句内容刨析:</strong></p><ul><li>符号链接部分</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/$(gcc -dumpmachine)/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>-new,<span class="keyword">ld</span>&#125; </span><br><span class="line">$ ln -sv /tools/bin/<span class="keyword">ld</span> /tools/$(gcc -dumpmachine)/bin/<span class="keyword">ld</span></span><br></pre></td></tr></table></figure><ul><li><p>就是几个符号链接</p></li><li><p>当设置完成之后，所有程序都将连接到<code>/tools/lib</code>中的库文件</p></li><li><p>space部分</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure><p>此代码还可以拆成以下两部分</p><ul><li><p>部分一</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFILE</span><br></pre></td></tr></table></figure></li><li><p>用于修正GCC的specs文件，使它指向新的动态连接器</p></li><li><p>只需要像以上那样使用一个简单的sed命令就能做到</p></li><li><p>同时也可以手动编辑specs文件</p><blockquote><p>本质上就是把所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code>就行</p></blockquote></li><li><p>部分二</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>用于删除GCC专属头文件目录中的头文件</p><blockquote><p>以避免宿主系统中的头文件污染编译环境</p></blockquote></li></ul><hr><ul><li>相关说明<blockquote><p>工具链的调整方法有好几种，而且不同版本GCC的specs可能会有不同<br>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成了<code>/tools/lib/ld-linux.so.2</code><br>所以即使有些文章在调整工具链上的命令和LFS手册上的不一样也不用太奇怪<br>当然也可以 直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件<br>spaces必须加以检查以确保被修改的配置的的确确生效了</p></blockquote></li></ul><hr><h3 id="内容参考"><a href="#内容参考" class="headerlink" title="内容参考"></a>内容参考</h3><ul><li>CN-LFS-v9.0</li><li>CN-LFS-v6.3</li><li>CN-LFS-v6.2</li><li>在LFS-1的URL资源整合目录里都有说明</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-2-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-1</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-1/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-1/</id>
    <published>2020-02-28T17:06:14.000Z</published>
    <updated>2020-02-29T16:16:23.695Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-1"><a href="#GNU-LFS-2-1" class="headerlink" title="GNU LFS-2-1"></a>GNU LFS-2-1</h2><hr><h3 id="构造临时系统-1-0"><a href="#构造临时系统-1-0" class="headerlink" title="构造临时系统-1.0"></a>构造临时系统-1.0</h3><ul><li>1.0-为第一遍编译并安装临时工具链内Binutils与GCC</li></ul><p><strong>概述:</strong></p><ul><li><p>对于临时系统的简述</p></li><li><p>目的是何构造一个最小的Linux系统</p></li><li><p>该系统将包含刚好足够构建目标主机中最终LFS系统所需的工具，以及一个比最小环境具有更好用户便利性的工作环境</p></li><li><p>使用的软件包皆为v6.3版本的LFS-liveCD中拥有的软件包</p></li><li><p>本文只介绍基本的[GNU 工具链]的搭建参考于v6.3与v9.0(对6.3进行补充，对9.0进行说明)</p><blockquote><p>v6.3和v9.0都有进行举例说明</p></blockquote></li><li><p>构建这个最小系统有两个步骤:</p><blockquote><p>第一步: 构建一个与宿主系统无关的新工具链(编译器、汇编器、链接器、 库和一些有用的工具)<br>第二步: 使用该工具链，去构建其它的基础工具</p></blockquote></li><li><p>临时系统中编译得到的文件将被安装在目录<code>$LFS/tools</code>中</p><blockquote><p>以确保在下一章中安装的文件和宿主系统生成的目录相互分离<br>由于此处编译的软件包都是临时性的，因此可以人为的去避免出现污染后面即将构成的LFS系统的情况发生</p></blockquote></li></ul><p><strong>需要特别注意的几点:</strong></p><ul><li>在构建的过程需要注意的问题</li></ul><ol><li>把所有源文件和补丁放到 chroot 环境可访问的目录，例如<code>/mnt/lfs/sources/</code><blockquote><p>但是千万不 能把源文件放在<code>/mnt/lfs/tools/</code>中</p></blockquote></li><li>进入到源文件目录</li><li>对于每个软件包:<blockquote><p>a. 用tar程序解压要编译的软件包<br>同时在临时系统目录中，确保解压软件包时本地主机使用的是lfs用户<br>b. 进入到解压后创建的目录中<br>c. 根据指南说明编译软件包<br>d. 回退到源文件目录<br>e. 除非特别说明，删除解压出来的目录</p></blockquote></li></ol><hr><ul><li><p>进入LFS包编译目录</p><blockquote><p><code>cd $LFS/sources</code></p></blockquote></li><li><p>第一遍编译[GNU 工具链]说明:</p><blockquote><p>在编译完成之后，通常需要运行测试套件<br>但此时测试套件框架(Tcl，Expect和DejaGNU)还没有就绪<br>同时因为此时是所有工作的初期阶段<br>所以此进行测试的收效甚微，因为第一遍编译的程序很快会被第二遍的代</p></blockquote></li></ul><hr><h3 id="1-0-0"><a href="#1-0-0" class="headerlink" title="1.0.0"></a>1.0.0</h3><p><strong>Binutils-2.17/2.32-Pass 1</strong><br><strong>安装交叉编译的Binutils</strong></p><ul><li><p>目标软件包简述:</p><blockquote><p>Binutils 软件包包含一个链接器，一个汇编器，以及其它处理目标文件的工具<br>大致构建用时: 1 SBU<br>所需磁盘空间: 580 MB</p></blockquote></li><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3配置编译</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> <span class="string">../binutils-2.17/configure</span> <span class="params">--prefix=/tools</span>  \</span><br><span class="line">            <span class="params">--disable-nls</span> \</span><br><span class="line">            <span class="params">--disable-werror</span></span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span>  <span class="built_in">..</span>/binutils-2.32/configure <span class="attribute">--prefix</span>=/tools            \</span><br><span class="line">             <span class="attribute">--with-sysroot</span>=<span class="variable">$LFS</span>        \</span><br><span class="line">             <span class="attribute">--with-lib-path</span>=/tools/lib \</span><br><span class="line">             <span class="attribute">--target</span>=<span class="variable">$LFS_TGT</span>          \</span><br><span class="line">             --disable-nls              \</span><br><span class="line">             --disable-werror</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>CC=&quot;gcc -B/usr/bin/&quot;</code>该选项强制gcc使用宿主系统中/usr/bin目录下的连接器</p><blockquote><p>这样做的必要是因为新生成的ld可能与某些宿主系统的gcc不兼容</p></blockquote></li><li><p>参数<code>--prefix=/tools</code>用于告诉配置脚本将<code>Binutils程序</code>安装到<code>/tools</code>文件夹</p></li><li><p>参数<code>--with-sysroot=$LFS</code>用于交叉编译，告诉编译系统在<code>$LFS</code>中查找所需的目标系统库</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code>指定需要配置使用的链接器的库路径</p></li><li><p>参数<code>--target=$LFS_TGT</code>，因为<code>LFS_TGT</code>变量中的机器描述和<code>config.guess</code>脚本返回的值略有不同，这个选项会告诉<code>configure</code>脚本调整<code>Binutils</code>的构建系统来构建一个交叉链接器</p></li><li><p>参数<code>--disable-nls</code>会禁止国际化(i18n)，因为国际化对临时工具来说没有必要</p></li><li><p>参数<code>--disable-werror</code>会防止来自宿主编译器的警告事件导致停止编译</p></li><li><p>继续编译并进行编译安装</p><blockquote><p>$make<br>$make install</p></blockquote></li><li><p>为调整工具链步骤准备连接器</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -C <span class="keyword">ld</span> clean </span><br><span class="line">$ make -C <span class="keyword">ld</span> LIB_PATH=/tools/lib</span><br><span class="line">$ <span class="keyword">cp</span> -v <span class="keyword">ld</span>/<span class="keyword">ld</span>-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>-C ld clean</code></p><blockquote><p>用于告诉make程序删除所有ld子目录中编译生成的文件</p></blockquote></li><li><p>参数<code>-C ld LIB_PATH=/tools/lib</code></p><blockquote><p>用于这个选项重新编译ld子目录中的所有文件</p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-2.17</span></span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>上构建，创建符号链接，以确保工具链的完整性:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">case</span> $(uname -m) in  </span><br><span class="line">x86_64) mkdir -v /tools/<span class="class"><span class="keyword">lib</span> &amp;&amp; <span class="title">ln</span> -<span class="title">sv</span> <span class="title">lib</span> /<span class="title">tools</span>/<span class="title">lib64</span> ;</span>; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.16.2</code>的<code>Binutils内容</code></p></li></ul><hr><h3 id="2-0-0"><a href="#2-0-0" class="headerlink" title="2.0.0"></a>2.0.0</h3><p><strong>GCC-4.12/9.2.0 Pass-1</strong><br><strong>安装交叉编译的GCC</strong></p><ul><li>目标软件包简述:<blockquote><p>GCC软件包包括GNU编译器集，其中有C和C++的编译器<br>大致构建用时: 12 SBU<br>所需磁盘空间: 3.1 GB</p></blockquote></li></ul><p><strong>以下内容为LFS-v6.3的GCC编译过程</strong></p><ul><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v gcc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gcc-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span> <span class="built_in">..</span>/gcc-4.1.2/configure <span class="attribute">--prefix</span>=/tools \ </span><br><span class="line">       <span class="attribute">--with-local-prefix</span>=/tools \</span><br><span class="line">       --disable-nls \</span><br><span class="line">       --enable-shared \</span><br><span class="line">       <span class="attribute">--enable-languages</span>=c</span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> ../gcc-<span class="number">9.2</span>.<span class="number">0</span>/configure       <span class="string">\</span></span><br><span class="line"> --target=$LFS_TGT                              <span class="string">\</span></span><br><span class="line"> --prefix=/tools                                <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-glibc-version=<span class="number">2.11</span>                      <span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-sysroot=$LFS                            <span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-newlib                                  <span class="string">\</span> </span><br><span class="line"> --without-headers                              <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-local-prefix=/tools                     <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-<span class="keyword">native</span>-system-header-dir=/tools/include <span class="string">\</span> </span><br><span class="line"> --disable-nls                                  <span class="string">\</span></span><br><span class="line"> --disable-shared                               <span class="string">\</span></span><br><span class="line"> --disable-multilib                             <span class="string">\</span> </span><br><span class="line"> --disable-decimal-float                        <span class="string">\</span> </span><br><span class="line"> --disable-threads                              <span class="string">\</span> </span><br><span class="line"> --disable-libatomic                            <span class="string">\</span> </span><br><span class="line"> --disable-libgomp                              <span class="string">\</span> </span><br><span class="line"> --disable-libquadmath                          <span class="string">\</span> </span><br><span class="line"> --disable-libssp                               <span class="string">\</span> </span><br><span class="line"> --disable-libvtv                               <span class="string">\</span></span><br><span class="line"> --disable-libstdcxx                            <span class="string">\</span> </span><br><span class="line"> --enable-languages=c,c++</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>配置含义(参数说明):</strong></p><ul><li>参数<code>--with-newlib</code><blockquote><p>由于还没有可用的C库，这确保编译libgcc时定义了常数<code>inhibit_libc</code><br>这可以防止编译任何需要libc支持的代码</p></blockquote></li><li>参数<code>--without-headers</code><blockquote><p>在创建完整的交叉编译器时，GCC要求标准头文件和目标系统兼容<br>对于我们的目的来说，不需要这些头文件<br>这个选项可以防止GCC查找它们</p></blockquote></li><li>参数<code>--with-local-prefix=/tools GCC</code><blockquote><p>此参数会查找本地已安装的include文件的系统位置<br>默认是<code>/usr/local</code><br>把它设置为<code>/tools</code>能把主机位置中的<code>/usr/local</code>从GCC的搜索路径中排除</p></blockquote></li><li>参数<code>--with-native-system-header-dir=/tools/include</code><blockquote><p>GCC默认会在/usr/include中查找系统头文件<br>和<code>sysroot</code>选项一起使用，会转换为<code>$LFS/usr/include</code><br>在后面两个章节中头文件会被安装到<code>$LFS/tools/include</code><br>这个选项确保 gcc 能正确找 到它们<br>第二次编译 GCC 时，同样的选项可以保证不会去寻找主机系统的头文件</p></blockquote></li><li>参数<code>--disable-shared</code><blockquote><p>这个选项强制GCC静态链接到它的内部库<br>我们这样做是为了避免主机系统可能出现的问题</p></blockquote></li><li>参数:<blockquote><p><code>--disable-decimal-float</code>,<code>--disable-threads</code>,<code>--disable-libatomic</code>,<code>--disablelibgomp</code>,<br><code>--disable-libquadmath</code>,<code>--disable-libssp</code>,<code>--disable-libvtv</code>,<code>--disablelibstdcxx</code><br>这些选项取消了对十进制浮点数扩展，线程化，<code>libatomic</code>，<code>libgomp</code>，<code>libquadmath</code>，<code>libssp</code>，<code>libvtv</code>，<code>libcilkrts</code>和<code>C++</code>标准库的支持<br>这些功能在编译 交叉编译器的时候会导致编译失败，对于交叉编译临时 libc 来说也没有必要</p></blockquote></li><li>参数<code>--disable-multilib</code><blockquote><p>在<code>x86_64</code>机器上，LFS 还不支持<code>multilib</code>配置<br>这个选项对 x86 来说无害</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保只编译 C 和 C++ 编译器<br>这些是现在唯一需要的语言</p></blockquote></li><li>此时只编译了GCC里的C编译器</li></ul><hr><ul><li><p>编译并安装</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; $ make bootstrap</span></span><br><span class="line"><span class="quote">&gt; $ make install</span></span><br></pre></td></tr></table></figure></li><li><p>创建符号连接(工具链)</p><blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-build </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-4.1.2</span></span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.21.2</code>的GCC软件包内容里</p></li></ul><hr><ul><li>对于工具链内的工具或其它软件的编译安装大致可分为以下几步:</li></ul><ol><li>创建目录</li><li>配置编译器与其脚本文件</li><li>编译并安装</li><li>配置工具链</li></ol><ul><li>配置其它独有(针对于不同工具的特殊配置)性质</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>金钟国的v6.3-LFS</p></li><li><p>孙海勇的v6.3-LFS</p></li><li><p>LFS-v9.0</p></li><li><p><code>5.4. Binutils-2.18 - 第一遍</code><a href="https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html</code></p></blockquote></li><li><p><code>gcc -B/usr/bin -B</code>的含义<a href="https://www.169it.com/tech-qa-linux/article-10702497996978005026.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.169it.com/tech-qa-linux/article-10702497996978005026.html</code></p></blockquote></li><li><p>百度知道<a href="https://zhidao.baidu.com/question/501313846.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zhidao.baidu.com/question/501313846.html</code></p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>对于9.2.0版本的GCC的补充内容</strong></p><ul><li><p>需要GMP，MPFR和MPC 软件包</p></li><li><p>在本地的主机发行版中可能并不包括这些软件包，它们将和GCC一起编译</p></li><li><p>将每个解压软件包到 GCC 的目录下，并重命名解压后得到的目录，以便GCC编译过程中能自动使用这些软件</p></li><li><p>执行以下命令:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xf ../mpfr<span class="number">-4.0</span><span class="number">.2</span>.tar.xz</span><br><span class="line">$ mv -v mpfr<span class="number">-4.0</span><span class="number">.2</span> mpfr </span><br><span class="line">$ tar -xf ../gmp<span class="number">-6.1</span><span class="number">.2</span>.tar.xz</span><br><span class="line">$ mv -v gmp<span class="number">-6.1</span><span class="number">.2</span> gmp</span><br><span class="line">$ tar -xf ../mpc<span class="number">-1.1</span><span class="number">.0</span>.tar.gz</span><br><span class="line">$ mv -v mpc<span class="number">-1.1</span><span class="number">.0</span> mpc</span><br></pre></td></tr></table></figure></li><li><p>下面的指令将会修改GCC默认的动态链接器的位置，安装到<code>/tools</code>目录中的</p></li><li><p>并将<code>/usr/include</code>从GCC的include检索路径中移除</p></li><li><p>执行以下命令:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ for file in gcc/config/&#123;linux,i386/linux&#123;,64&#125;&#125;<span class="string">.h</span> </span><br><span class="line">do  </span><br><span class="line">cp -uv $file&#123;,<span class="string">.orig</span>&#125;  </span><br><span class="line">sed -e 's@<span class="string">/lib</span>\<span class="params">(64\)</span>\?\<span class="params">(32\)</span>\?<span class="string">/ld</span>@<span class="string">/tools</span>&amp;@g' \</span><br><span class="line">-e 's@<span class="string">/usr</span>@<span class="string">/tools</span>@g' $file.orig &gt; $file  </span><br><span class="line"><span class="keyword">echo</span> ' </span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_1 </span></span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_2 </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/" </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file  </span></span><br><span class="line">touch $file.orig </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>参数解析:</strong></p><p><strong>执行逻辑说明:</strong></p><ol><li>首先复制文件<code>gcc/config/linux. h</code>,<code>gcc/config/i386/linux.h</code>，和<code>gcc/config/i368/linux64.h</code></li><li>然后给复制的文件加上<code>.orig</code>后缀</li><li>然后第一个sed表达式在每个<code>/lib/ld</code>,<code>/lib64/ld</code>或者<code>/lib32/ld</code>实例前面增加<code>/tools</code><blockquote><p>第二个sed表达式替换<code>/usr</code>的硬编码实例</p></blockquote></li><li>然后添加这改变默认<code>startfile前缀</code>到文件末尾的定义语句<blockquote><p>此时需要注意<code>/tools/lib/</code>后面的<code>/</code>是必须的</p></blockquote></li><li>最后用<code>touch</code>更新复制文件的时间戳<blockquote><p>当与<code>cp -u</code>一起使用时，可以防止命令被无意中运行两次造成对原始文件意外的更改</p></blockquote></li></ol><hr><ul><li>在<code>x86_64</code>的主机上，为64位的库设置默认目录名至[lib]:</li><li>执行以下命令:<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span><span class="keyword">case</span> <span class="variable">$(</span>uname -m) <span class="keyword">in</span>  </span><br><span class="line">x86_64)</span><br><span class="line">sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \        </span><br><span class="line">-i.orig gcc/config/i386/t-linux64 </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><ul><li><p>在LFS-v6.3版本中</p></li><li><p>这里要注意第一遍编译的时候编译器参数需要指定:<code>CC=&quot;gcc -B/usr/bin/</code></p><blockquote><p>用以强制gcc使用宿主系统中/usr/bin目录下的连接器</p></blockquote></li><li><p>ld-GNU链接器</p></li><li><p>在第一次工具链调整之后需要进行一次可用性测试</p></li><li><p>在第二次编译安装完成GCC后需要进行一次可用性测试</p></li><li><p>测试组件</p><blockquote><p>Tcl-8.4.15<br>Expect-5.43.0<br>DejaGNU-1.4.4</p></blockquote></li></ul><hr><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>参考自LFS-v9.0第5.5章节</p></li><li><p>LFS-v9.0<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>LFS-v6.2</p><blockquote><p>参考金步国的中文译本</p></blockquote></li><li><p>LFS-v6.3</p><blockquote><p>参考孙海勇的中文译本</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-2-1&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-1&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-1</title>
    <link href="https://unit-serow.github.io/2020/02/28/GNU-LFS-1/"/>
    <id>https://unit-serow.github.io/2020/02/28/GNU-LFS-1/</id>
    <published>2020-02-28T15:31:21.000Z</published>
    <updated>2020-03-04T20:33:26.572Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --><h3 id="LFS-1"><a href="#LFS-1" class="headerlink" title="LFS-1"></a>LFS-1</h3><ul><li>参考资料为CN-[LFS-BOOK(v9.0)]-PDF版</li></ul><hr><p><strong>文案说明:</strong></p><ul><li><p>GNU LFS-1-x 为LFS基本配置描述</p></li><li><p>GNU LFS-2-x 为临时系统描述</p></li><li><p>GNU LFS-3-x 为目标主机描述</p></li><li><p>进入chroot来操作目标主机</p></li><li><p>因为文章内关于LFS-v6.3或LFS-v6.2的内容使用了相近的解释，所以对于版本参数的描述可能有些凌乱</p></li><li><p>所以版本的问题需要就具体情况而定，文章里不会做对版本的细致区别</p></li><li><p>6.2和6.3版本的LFS有一个比较大的区别就是内核文件的不同，其它近乎相同</p></li><li><p>同时文章内的内容与资料仅供参考，具体实践还需查阅官方文档</p></li><li><p>使用6.3版本的原因是因为LFS官方的LiveCD的最新版本为6.3版本</p></li></ul><p><strong>本地主机环境一览:</strong></p><ul><li>原主机环境准备</li><li>主机内存(RAM)为4GB</li><li>主机磁盘为30GB</li><li>CPU为4核-2.2GHZ</li><li>本地主机硬盘接口类型为SCSI</li><li>磁盘分区表类型为MBR(GPT/GUID不做阐述)</li><li>磁盘启动引导类型为BIOS(UEFI不做阐述)</li><li>CD使用LFS-liveCD-v6.3(2007)</li></ul><hr><h3 id="1-0-0-1-2-7"><a href="#1-0-0-1-2-7" class="headerlink" title="1.0.0-1.2.7"></a>1.0.0-1.2.7</h3><p><strong>1.0.0</strong></p><ul><li>使用cfdisk工具对原主机进行分区(也可以使用fdisk工具进行分区操作)<blockquote><p><code>$cfdisk /dev/sda</code></p></blockquote></li></ul><p><strong>1.1.0 格式化磁盘分区</strong></p><ul><li><p>Swap分区(swap)</p><blockquote><p><code>$mkswap /dev/&lt;yyy&gt;</code><br><code>$mkswap /dev/sda1</code></p></blockquote></li><li><p>LFS分区(ext)</p><blockquote><p><code>$mkfs -v -t ext4/ext3 /dev/&lt;xxx&gt;</code><br><code>$mkfs.ext4/ext3 /dev/sda2</code><br><code>$mkfs -v -t ext3 /dev/sda2</code></p></blockquote></li><li><p>格式化为ext3文件系统</p><blockquote><p><code>mke2fs -jv /dev/&lt;xxx&gt;</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>前者为标准格式，后者为实例</li><li>在原主机磁盘上创建新分区</li><li>由于是LFS官方提供的liveCD，所以此时的原主机没有任何分区</li><li>这里创建两个本地的主分区: /dev/sda1用于交换分区(swap)，/dev/sda2用作目标主机制作环境，分区文件格式为ext3(或ext3/ext4等等)</li><li>存储容量分别是7000B与530000B(拟定，因本地主机的处理器指令集位数问题，实际情况会发生细微变动)</li></ul><hr><p><strong>1.2.0 设置LFS所处目录的系统变量</strong></p><ul><li>因为整个实现过程需要多次用到LFS系统的目录，所以先将LFS系统目录设置为LFS变量(变量名自拟，这里为LFS，即$LFS)</li><li>因为这里将要把LFS分区挂载到/mnt目录中，所以可以将LFS系统目录建立到/mnt目录内，以下指令直接创建环境变量:<blockquote><p><code>$export LFS=/mnt/lfs</code></p></blockquote></li></ul><p><strong>1.2.1 将新分区(LFS系统分区)进行挂载</strong></p><ul><li>挂载的目是访问所被挂载的分区，上一步中将分区所在目录设为了$LFS变量所指向的地址</li><li>创建挂载点<blockquote><p><code>mkdir -pv $LFS</code></p></blockquote></li><li>挂载LFS分区及其文件系统(文件可以自动识别，即便不加也是可以的)<blockquote><p><code>mount -v -t ext3/ext4 /dev/&lt;xxx&gt; $LFS</code><br><code>mount -v -t ext3 /dev/sda2 $LFS</code><br><code>mount /dev/sda2 $LFS</code></p></blockquote></li><li>(非必要)挂载并使用swap分区<blockquote><p><code>/sbin/swapon -v /dev/&lt;zzz&gt;</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>这里与以后的说明都将/dev/sda2分区称为LFS分区，即目标系统根目录</li><li>交换分区(swap)的作用是可以有效的解决编译过程中所需内存的不足，所以可以分出一个小型磁盘分区来当作swap空间</li><li>所以swap的容量可以按需分配，而sda2当然是越大越好</li><li>宿主机(原主机)和LFS分区的swap是公用的，如果原宿主机拥有swap，就没有必要再新建一个了</li><li>有关于磁盘分区的标志与其它分区表类型和启动引导类型的内容这里就不做过多赘述了</li></ul><hr><p><strong>1.2.2 创建必要目录以及目录权限分配</strong></p><ul><li><p>今后在第二阶段(临时系统)制作的时候会将所有的软件编译到<code>$LFS/tools</code>中，以便与第三阶段时所编译的软件完全分离</p></li><li><p>在目标系统成型后，便可将其遗弃</p></li><li><p>执行以下操作需要root权限</p></li><li><p>创建工具链目录<code>$LFS/tools</code></p><blockquote><p><code>mkdir -v $LFS/tools</code></p></blockquote></li><li><p>在原主机内创建符号链接，用以指向LFS分区中新建的目录(/tools)</p></li><li><p>此时所创建的符号链接将永远指向<code>/tools</code>文件夹</p><blockquote><p>即编译器，汇编器，链接器无论是在临时系统或是目标系统中都可以进行使用</p></blockquote></li><li><p>配置符号链接</p><blockquote><p><code>ln -sv $LFS/tools /</code></p></blockquote></li></ul><p><strong>1.2.3 创建源代码编译用目录</strong></p><blockquote><p><code>mkdir -v $LFS/sources</code></p></blockquote><ul><li>权限分配<blockquote><p><code>chmod -v a+wt $LFS/sources</code></p></blockquote></li></ul><hr><p><strong>1.2.4 添加LFS用户(自定义非特权用户命名)</strong></p><ul><li>因为以root用户登陆时，一个操作失误便可以摧毁整个操作系统，所以在此需要新建一个非特权用户来对软件包进行编译</li><li>同时也是为了建立一个干净的工作环境，这里创建一个名为lfs的新用于作为新组(同样命名为lfs)的成员</li><li>添加新用户:<blockquote><p><code>groupadd lfs</code></p></blockquote></li><li>将新用户lfs的shell设为默认bash，并将用户lfs添加到lfs组中，同时为lfs用户创建主目录</li><li>并对用户输入位置设置为空设备(null)，以防止可能从框架目录复制文件的情况<blockquote><p><code>useradd -s /bin/bash -g lfs -m -k /dev/null lfs</code></p></blockquote></li><li>设置lfs用户密码，可以为空<blockquote><p><code>passwd lfs</code></p></blockquote></li><li>将目录所有者改变为lfs<blockquote><p><code>chown -v lfs $LFS/tools</code></p></blockquote></li><li>同时为用户lfs赋予访问$LFS/tools目录的所有权限<blockquote><p><code>chown -v lfs $LFS/sources</code></p></blockquote></li><li>以lfs身份登陆主机</li><li>切换用户并启动shell环境<blockquote><p><code>su - lfs</code></p></blockquote></li></ul><hr><p><strong>1.2.5 设置环境</strong></p><ul><li>通过为bash shell创建两个开机启动文件，来设置合适的工作环境</li><li>以lfs用户的身份来创建一个新的<code>.bash_profile</code>文件<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ~/.bash_profile &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line">exec env -i <span class="attribute">HOME</span>=<span class="variable">$HOME</span> <span class="attribute">TERM</span>=<span class="variable">$TERM</span> <span class="attribute">PS1</span>=<span class="string">'\u:\w\$ '</span> /bin/bash </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li>当以lfs用户身份登录时，初始shell通常是一个login的shell</li></ul><ol><li>它先读取宿主机的<code>/etc/profile</code>文件(很可能包括一些设定和环境变量)</li><li>然后是<code>.bash_profile</code>文件</li><li><code>.bash_profile</code>中的命令<code>exec env -i.../bin/bash</code>用一个除了HOME，TERM和PS1变量外</li><li>其他环境完全为空的新shell代替运行中的shell</li><li>这能确保不会有潜在的和意想不到的危险环境变量，从宿主机泄露到构建环境中</li><li>这样做主要是为了确保环境的干净</li></ol><hr><p><strong>1.2.6 配置<code>.bashrc</code>文件</strong></p><ul><li>新的shell实例是一个<code>non-login</code>的shell</li><li>它不会读取<code>/etc/profile</code>或者<code>.bash_profile</code>文件，而是读取<code>.bashrc</code></li><li>创建<code>.bashrc</code>文件:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ~/.bashrc &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="builtin-name">set</span> +h </span><br><span class="line">umask 022 </span><br><span class="line"><span class="attribute">LFS</span>=/mnt/lfs </span><br><span class="line"><span class="attribute">LC_ALL</span>=POSIX </span><br><span class="line"><span class="attribute">LFS_TGT</span>=$(uname -m)-lfs-linux-gnu </span><br><span class="line"><span class="attribute">PATH</span>=/tools/bin:/bin:/usr/bin </span><br><span class="line"><span class="builtin-name">export</span> LFS LC_ALL LFS_TGT PATH </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li><code>set +h</code>命令关闭了bash的哈希功能</li><li>设置用户文件新建时的掩码(umask)为 022，以确保新建的文件和目录只有其所有者可写，但任何人都可读可执行</li><li>LFS 变量应设置成选定的挂载点</li><li><code>LC_ALL变量</code>控制某些程序的本地化，使它们的消息遵循特定国家的惯例</li><li>设置<code>LC_ALL</code>为<code>POSIX</code>或<code>C</code>(两者是等价的)，以确保在chroot环境中一切能如期望的那样进行</li><li><code>LFS_TGT变量</code>设置了一个虽非默认，但在构建交叉编译器、连接器和交叉编译临时工作链时，用得上到的兼容的机器说明</li><li>通过把<code>/tools/bin</code>放在标准<code>PATH变量</code>的前面，使得所有在临时主机中安装的程序，一经安装shell便能马上使用</li><li>与之配合的关闭哈希功能，能在临时主机环境中的程序在可用的情况下，限制使用宿主机中旧程序的风险</li></ul><hr><ul><li>1.2.7 启用配置</li><li>最后，启用刚才创建的用户配置</li><li>为构建临时工具完全准备好环境:<blockquote><p><code>source ~/.bash_profile</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Mar 06 2020 12:39:55 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;LFS-1&quot;&gt;&lt;a href=&quot;#LFS-1&quot; class=&quot;headerlink&quot; title=&quot;LFS-1&quot;&gt;&lt;/a&gt;LFS-1&lt;/h3
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
