<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker Machine/Swarm-1.1</title>
    <url>/2020/02/09/Docker-Machine-1-1/</url>
    <content><![CDATA[<!-- build time:Sun Feb 09 2020 14:42:38 GMT+0800 (中国标准时间) --><h3 id="docker-machine-基本命令"><a href="#docker-machine-基本命令" class="headerlink" title="docker machine-基本命令"></a>docker machine-基本命令</h3><ul><li><p>虚拟机与容器的区别:虚拟机内可以定义容器</p></li><li><p>列出已有虚拟机</p><blockquote><p><code>docker-machine ls</code></p></blockquote></li><li><p>创建虚拟机</p><blockquote><p><code>docker-machine create --driver [virtualbox] [test]</code><br>参数–driver用于指定虚拟机驱动类型,这里是virtualbox</p></blockquote></li><li><p>虚拟机驱动一览<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/drivers/</code></p></blockquote></li><li><p>查看虚拟器的ip</p><blockquote><p><code>docker-machine ip [test]</code></p></blockquote></li></ul><hr><ul><li><p>管理命令</p><blockquote><p><code>docker-machine start/restart/stop test</code></p></blockquote></li><li><p>帮助与检阅命令</p><blockquote><p><code>version/help/info</code></p></blockquote></li><li><p>官方文档<a href="https://docs.docker.com/machine/reference/create/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/reference/create/</code></p></blockquote></li></ul><hr><p><strong>指令摘要</strong></p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">kill</td><td align="left">杀死指定主机</td></tr><tr><td align="left">rm</td><td align="left">删除指定主机</td></tr><tr><td align="left">ssh</td><td align="left">连接主机</td></tr><tr><td align="left">upgrade</td><td align="left">更新</td></tr><tr><td align="left">url</td><td align="left">获取监听url</td></tr><tr><td align="left">scp</td><td align="left">复制</td></tr><tr><td align="left">regenerate-certs</td><td align="left">刷新TLS</td></tr></tbody></table><hr><ul><li><p>工作节点(worker node)</p></li><li><p>管理节点(manager node)</p></li><li><p>在VMware里安装虚拟机的虚拟机驱动时需要</p></li><li><p>点开虚拟机设置里的处理器选项卡</p></li><li><p>勾选虚拟化引擎选项卡</p></li></ul><hr><h3 id="Docker-Swarm集群-基本命令"><a href="#Docker-Swarm集群-基本命令" class="headerlink" title="Docker Swarm集群-基本命令"></a>Docker Swarm集群-基本命令</h3><ul><li><p>创建管理节点(manager node)</p><blockquote><p><code>docker-machine create -d virtualbox swarm-manager</code></p></blockquote></li><li><p>连入机器后执行</p><blockquote><p><code>docker swarm init --advertise-addr [创建机器时分配的 ip]</code></p></blockquote></li><li><p>然后拷贝输出指令</p></li><li><p>创建工作节点(worker node)</p></li><li><p>进入工作节点运行拷贝的指令将其设置为工作节点</p></li></ul><hr><ul><li><p>随机部署服务到集群中</p></li><li><p><code>alpine</code>是操作系统</p><blockquote><p><code>docker service create --replicas 1 --name 服务名 alpine ping docker.com</code></p></blockquote></li><li><p>查看部署情况</p><blockquote><p><code>docker service ps [服务名]</code></p></blockquote></li><li><p>查看具体信息</p><blockquote><p><code>docker service inspect --pretty [服务名]</code></p></blockquote></li><li><p>扩展服务到多节点(两个)</p><blockquote><p><code>docker service scale [服务名=2]</code></p></blockquote></li><li><p>删除服务</p><blockquote><p><code>docker service rm [服务名]</code></p></blockquote></li><li><p>查看所有节点</p><blockquote><p><code>docker node ls</code></p></blockquote></li><li><p>关闭服务节点</p><blockquote><p><code>docker node update --availability drain swarm-worker1</code></p></blockquote></li><li><p>开启服务节点</p><blockquote><p><code>docker node update --availability active swarm-worker1</code></p></blockquote></li><li><p><code>Active/Drain</code>分别代表开启与关闭</p></li></ul><hr><p><strong>滚动升级</strong></p><ul><li><p>前提是已存在指定服务</p></li><li><p>创建服务</p><blockquote><p><code>docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</code></p></blockquote></li><li><p>滚动更新</p><blockquote><p><code>docker service update --image [服务名:版本号] [指定已有的服务镜像]</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Swarm-集群</title>
    <url>/2020/02/09/Docker-Swarm-1/</url>
    <content><![CDATA[<!-- build time:Sun Feb 09 2020 13:52:04 GMT+0800 (中国标准时间) --><h3 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h3><p><strong>概述:</strong></p><ul><li><p><code>Docker Swarm</code>是Docker的集群管理工具</p></li><li><p>它将<code>Docker主机池</code>转变为单个虚拟Docker主机</p></li><li><p><code>Docker Swarm</code>提供了标准的<code>Docker API</code></p></li><li><p>目的是使所有任何已经与Docker守护程序通信的工具都可以使用Swarm轻松地扩展到多个主机</p></li><li><p>支持的工具包括但不限于以下各项：</p></li><li><p>Dokku</p></li><li><p>Docker Compose</p></li><li><p>Docker Machine</p></li><li><p>Jenkins</p></li></ul><p><strong>原理概述:</strong></p><ul><li><code>swarm集群</code>由管理节点(manager)和工作节点(work node)构成</li><li><code>swarm mananger</code>:负责整个集群的管理工作包括集群配置,服务管理等所有跟集群有关的工作</li><li><code>work node</code>:即为<code>available node</code>,主要负责运行相应的服务来执行任务(task)</li><li>逻辑简述</li><li>管理节点(swarm manager)内存储着若干个服务(service)的副本(replicas)文件</li><li>工作节点(available/worker node)内存储这服务的标识与服务的镜像文件(container)</li><li>管理节点将所有的服务副本都分配到工作节点内，并管理与控制工作节点内的任务执行<blockquote><p>[swarm manager[service replicas]]-&gt;[available node[task[container(service:latest)]]]<br>swarm manager-&gt;available node-1/available node-2/available node-3/available node-N</p></blockquote></li></ul><hr><p><strong>应用</strong></p><ul><li><p>以<code>Docker Machine</code>与<code>virtualbox</code>进行实践，需要先确保主机已安装<code>virtualbox</code></p></li><li><p>创建docker机器:</p><blockquote><p><code>$ docker-machine create -d virtualbox swarm-manager</code></p></blockquote></li></ul><hr><ul><li><p>创建管理节点(manager node)</p></li><li><p>初始化<code>swarm</code>集群，进行初始化的这台机器，就是集群的管理节点</p><blockquote><p><code>$ docker-machine ssh swarm-manager</code><br><code>$ docker swarm init --advertise-addr 192.168.99.101</code><br><code>--advertise-addr</code>后的IP为创建机器时分配的ip</p></blockquote></li><li><p>当为机器分配IP之后，命令行会输出向集群内添加工作节点的指令(连接令牌)</p><blockquote><p><code>To add a worker to this swarm，runthe following command</code><br><code>docker swarm join --token [...]</code></p></blockquote></li></ul><hr><ul><li>创建工作节点(worker node)</li><li>复制上面输出的指令(会被自动截断)<blockquote><p><code>$ docker swarm join --token [...]</code><br>输出<code>The node joined a swarm as a worker</code></p></blockquote></li></ul><hr><ul><li>查看集群信息<blockquote><p><code>docker info</code><br>输出内容中<code>Swarm active</code>内的<code>managers</code>与<code>node</code>即为节点信息</p></blockquote></li></ul><hr><ul><li><p>部署服务器到集群中</p></li><li><p>跟集群管理有关的任何操作，都是在管理节点上操作的</p></li><li><p>随机指派任一工作节点，并于工作节点上创建任意的一个服务</p><blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name [service name] alpine ping docker.com</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li><li><p>查看<code>service</code>部署的具体信息:</p><blockquote><p><code>docker@swarm-manager:~$ docker service inspect --pretty [service name]</code></p></blockquote></li></ul><hr><ul><li><p>扩展集群服务</p></li><li><p>将service服务扩展到若干个节点</p><blockquote><p><code>docker@swarm-manager:~$ docker service scale [service name]=[节点数]</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>删除服务<blockquote><p><code>docker@swarm-manager:~$ docker service rm [service name]</code></p></blockquote></li><li>查看服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>滚动升级服务</li><li>将redis旧版本通过滚动升级至更高版本</li><li>创建一个3.0.6版本的redis<blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</code></p></blockquote></li><li>滚动升级redis<blockquote><p><code>docker@swarm-manager:~$ docker service update --image redis:3.0.7 redis</code></p></blockquote></li><li>查看redis服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps redis</code></p></blockquote></li></ul><hr><ul><li><p>停止某个节点接收新的任务</p></li><li><p>查看所有的节点：</p><blockquote><p><code>docker@swarm-manager:~$ docker node ls</code></p></blockquote></li><li><p>默认所有的节点都是<code>Active</code>, 可以接收新的任务分配</p></li><li><p>停止节点<code>swarm-worker1</code>:</p><blockquote><p><code>docker node update --availability drain swarm-worker1</code></p></blockquote></li><li><p>此时<code>swarm-worker1</code>状态变为<code>Drain</code></p></li><li><p>不会影响到集群的服务，只是<code>swarm-worker1</code>节点不再接收新的任务</p></li><li><p>会使集群的负载能力有所下降</p></li><li><p>重新激活节点指令:</p><blockquote><p><code>docker@swarm-manager:~$ docker node update --availability active swarm-worker1</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><ul><li><p>虚拟机驱动<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/drivers/</code></p></blockquote></li><li><p>官方文档<a href="https://docs.docker.com/machine/reference/create/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/reference/create/</code></p></blockquote></li></ul><hr><p><strong>其他资源</strong></p><ul><li><p>Docker官方主页<a href="https://www.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.docker.com</code></p></blockquote></li><li><p>Docker官方博客<a href="https://blog.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.docker.com/</code></p></blockquote></li><li><p>Docker官方文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/</code></p></blockquote></li><li><p>Docker Store<a href="https://store.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://store.docker.com</code></p></blockquote></li><li><p>Docker Cloud<a href="https://cloud.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://cloud.docker.com</code></p></blockquote></li><li><p>Docker Hub<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com</code></p></blockquote></li><li><p>Docker的源代码仓库<a href="https://github.com/moby/moby" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/moby/moby</code></p></blockquote></li><li><p>Docker发布版本历史<a href="https://docs.docker.com/release-notes/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/release-notes/</code></p></blockquote></li><li><p>Docker常见问题<a href="https://docs.docker.com/engine/faq/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/engine/faq/</code></p></blockquote></li><li><p>Docker远端应用 API<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/develop/sdk/</code></p></blockquote></li></ul><hr><p><strong>Docker国内镜像源</strong></p><ul><li><p>阿里云<a href="https://help.aliyun.com/document_detail/60750.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://help.aliyun.com/document_detail/60750.html</code></p></blockquote></li><li><p>网易云加速器</p><blockquote><p><code>http://hub-mirror.c.163.com</code></p></blockquote></li><li><p>中国官方加速器</p><blockquote><p><code>https://registry.docker-cn.com</code></p></blockquote></li><li><p>ustc的镜像</p><blockquote><p><code>https://docker.mirrors.ustc.edu.cn</code></p></blockquote></li><li><p>daocloud</p><blockquote><p><code>https://www.daocloud.io/mirror#accelerator-doc</code>(注册后使用)</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-1.1</title>
    <url>/2020/02/09/Docker-1-1/</url>
    <content><![CDATA[<!-- build time:Sun Feb 09 2020 03:12:54 GMT+0800 (中国标准时间) --><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul><li><p>查看已有镜像</p><blockquote><p><code>docker images</code></p></blockquote></li><li><p>参数:仓库源/标签/ID/创建时间/空间</p><blockquote><p><code>debian tag [镜像ID]</code> # 添加标签</p></blockquote></li><li><p>查看仓库内所有镜像文件</p><blockquote><p><code>docker search debian</code></p></blockquote></li><li><p>拉取仓库内默认版本的debian镜像<code>(debian:latest)</code></p><blockquote><p><code>docker pull debian</code></p></blockquote></li><li><p>查看所有已创建容器</p><blockquote><p><code>docker ps -a</code></p></blockquote></li><li><p>用容器启动所选镜像</p><blockquote><p><code>docker run -it --name [自定义命名] debian /bin/bash</code></p></blockquote></li></ul><hr><ul><li>启动，停止，重启所选容器<blockquote><p><code>docker start/stop/restart [容器ID]</code><br>参数:<code>·-i交互式操作</code>，<code>-t终端</code>，<code>-d后台运行</code></p></blockquote></li></ul><hr><ul><li>删除操作<blockquote><p><code>docker rmi debian</code>删除镜像<br><code>docker rm -f</code>删除容器<br><code>docker container prune</code>删除所有停止的容器</p></blockquote></li><li>容器必须停止才能进行删除</li></ul><hr><ul><li>进入后台后使用<code>docker attach</code>或<code>docker exec [容器ID]</code>进入该容器</li><li>前者暂时性，后者永久性</li><li>重新进入容器时还必须加入原来设置的启动参数</li><li>比如<code>/bin/bash和-it</code></li></ul><hr><ul><li><p>设置[service]端口映射与绑定IP</p><blockquote><p><code>docker run -p [可选的IP绑定]:[映射端口]:[原端口]/(udp/tcp) [镜像名] [启动脚本]</code><br>参数:<code>-P</code>是随机映射，<code>-p</code>是指定映射</p></blockquote></li><li><p>查看端口绑定情况</p><blockquote><p><code>docker port [服务名]</code></p></blockquote></li></ul><hr><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><ul><li><p>父子关系这里都称为上下层级关系，与阶级关系不同</p></li><li><p>上级容器可以看到下级容器的关系</p></li><li><p>建立容器网络</p><blockquote><p><code>docker network create -d bridge/overlay(网络类型) [网络命名]</code>overlay<code>应用于</code>swarm`</p></blockquote></li><li><p>后台运行一个命名为<code>test1</code>的容器并把它并入<code>test-net</code>内，并开启交互式终端系统</p><blockquote><p><code>docker run -itd --name test1 --network test-net debian /bin/bash</code></p></blockquote></li><li><p>任何加入此网络的容器都会达成互联的状态</p></li></ul><hr><ul><li><p>设定所有容器域名和DNS</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;&quot;dns&quot; : [&quot;111.111.111.111&quot;,&quot;1.1.1.1&quot;]&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看是否生效</p><blockquote><p><code>docker run -it rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>指定容器设置域名和DNS服务器</p><blockquote><p><code>docker run -it --rm _hostname=HOSTNAME --dns=IP_ADDRESS --dns-search=DOMAIN(搜索域) debian</code></p></blockquote></li><li><p>没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></li></ul><hr><ul><li><p>登陆<code>docker hub</code></p><blockquote><p><code>docker login</code></p></blockquote></li><li><p>退出<code>docker hub</code></p><blockquote><p><code>docker logout</code></p></blockquote></li><li><p>上传镜像</p><blockquote><p><code>docker tag 本地镜像名 username/远端镜像名</code></p></blockquote></li></ul><hr><ul><li><p>随笔</p><blockquote><p><code>Docker Engine</code> 引擎<br><code>REST API</code> 通用接口<br><code>Docker daemon</code> 守护进程</p></blockquote></li><li><p>自用简易指令集</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Machine</title>
    <url>/2020/02/08/Docker-Machine/</url>
    <content><![CDATA[<!-- build time:Sat Feb 08 2020 18:24:53 GMT+0800 (中国标准时间) --><h3 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h3><p><strong>概述:</strong></p><ul><li>可以实现在虚拟主机上安装Docker</li><li>并且可以使用<code>docker-machine</code>命令来管理主机</li><li><code>Docker Machine</code>管理的虚拟主机可以是机上的，也可以是云供应商的</li><li>使用<code>docker-machine</code>命令，可以用于启动，检查，停止和重新启动托管主机，也可以升级Docker客户端和守护程序</li><li>以及配置Docker客户端与本地主机进行通信</li><li>用于实现使用本地主机便可以操控远端的镜像容器集群</li></ul><p><strong>逻辑简述:</strong><br>[Client docker-machine[Client docker CLI[REST APT]]]-docker-machine create-&gt;[REST API[Server docker daemon]]</p><hr><p><strong>基于Linux安装Docker Machine</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ base&#x3D;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L $base&#x2F;docker-machine-$(uname -s)-$(uname -m) &gt;&#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  sudo mv &#x2F;tmp&#x2F;docker-machine &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure><ul><li>查看版本以验证是否安装成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version 0.16.0, build 9371605</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>对于machine version的使用</strong></p><ol><li><p>列出可用的机器</p><blockquote><p><code>$ docker-machine ls</code></p></blockquote></li><li><p>创建机器</p></li></ol><ul><li>创建一个名为serow的机器<blockquote><p><code>$ docker-machine create --driver virtualbox serow</code></p></blockquote></li><li>参数<code>--driver</code>用于指定用来创建机器的驱动类型，这里是<code>virtualbox</code></li></ul><ol start="3"><li><p>查看机器的 ip</p><blockquote><p><code>$ docker-machine ip serow</code></p></blockquote></li><li><p>停止机器</p><blockquote><p><code>$ docker-machine stop serow</code></p></blockquote></li><li><p>启动机器*</p><blockquote><p><code>$ docker-machine start serow</code></p></blockquote></li><li><p>进入机器*</p><blockquote><p><code>$ docker-machine ssh serow</code></p></blockquote></li></ol><hr><p><strong>docker-machine 命令参数明细</strong></p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">docker-machine active</td><td align="left">用于查看当前激活状态的Docker主机</td></tr><tr><td align="left">config</td><td align="left">查看当前激活状态Docker主机的连接信息</td></tr><tr><td align="left">creat</td><td align="left">创建Docker主机</td></tr><tr><td align="left">env</td><td align="left">显示连接到某个主机需要的环境变量</td></tr><tr><td align="left">inspect</td><td align="left">以<code>json</code>格式输出指定Docker的详细信息</td></tr><tr><td align="left">ip</td><td align="left">获取指定 Docker 主机的地址</td></tr><tr><td align="left">kill</td><td align="left">直接杀死指定的 Docker主机</td></tr><tr><td align="left">ls</td><td align="left">列出所有的管理主机</td></tr><tr><td align="left">provision</td><td align="left">重新配置指定主机</td></tr><tr><td align="left">regenerate-certs</td><td align="left">为某个主机重新生成TLS信息</td></tr><tr><td align="left">restart</td><td align="left">重启指定的主机</td></tr><tr><td align="left">rm</td><td align="left">删除某台Docker主机，对应的虚拟机也会被删除</td></tr><tr><td align="left">ssh</td><td align="left">通过SSH连接到主机上，执行命令</td></tr><tr><td align="left">scp</td><td align="left">在Docker主机之间以及Docker主机和本地主机之间通过<code>scp</code>远程复制数据</td></tr><tr><td align="left">mount</td><td align="left">使用SSHFS从计算机装载或卸载目录</td></tr><tr><td align="left">start</td><td align="left">启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td></tr><tr><td align="left">status</td><td align="left">获取指定Docker主机的状态(包括:<code>Running</code>,<code>Paused</code>,<code>Saved</code>,<code>Stopped</code>,<code>Stopping</code>,<code>Starting</code>,<code>Error</code>)等</td></tr><tr><td align="left">stop</td><td align="left">停止一个指定的Docker主机</td></tr><tr><td align="left">upgrade</td><td align="left">将一个指定主机的Docker版本更新为最新</td></tr><tr><td align="left">url</td><td align="left">获取指定Docker主机的监听URL</td></tr><tr><td align="left">version</td><td align="left">显示 Docker Machine 的版本或者主机Docker版本</td></tr><tr><td align="left">help</td><td align="left">显示帮助信息</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML-1</title>
    <url>/2020/02/08/YAML-1/</url>
    <content><![CDATA[<!-- build time:Sat Feb 08 2020 17:49:36 GMT+0800 (中国标准时间) --><h3 id="YAML-基本语法与简述"><a href="#YAML-基本语法与简述" class="headerlink" title="YAML 基本语法与简述"></a>YAML 基本语法与简述</h3><p><strong>概述:</strong></p><ul><li>YAML是”YAML Ain’t a Markup Language”(YAML 不是一种标记语言)的递归缩写</li><li>在开发的这种语言时，YAML的意思其实是:”Yet Another Markup Language”(仍是一种标记语言)</li><li>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态</li><li>它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲</li><li>YAML的配置文件后缀为<code>.yml</code></li></ul><hr><p><strong>YAML的基本语法规则</strong></p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用<code>tab</code>，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li><code>&#39;#&#39;</code>表示注释</li></ul><hr><p><strong>YAML的数据类型</strong></p><ul><li>YAML支持以下几种数据类型：</li><li>对象:键值对的集合，又称为映射(mapping)/哈希(hashes) /字典(dictionary)</li><li>数组:一组按次序排列的值，又称为序列(sequence)/列表(list)</li><li>纯量(scalars):单个的、不可再分的值</li></ul><hr><p><strong>YAML对象</strong></p><ul><li><p>对象键值对使用冒号结构表示<code>key: value</code>，冒号后面要加一个空格</p></li><li><p>也可以使用<code>key:{key1: value1, key2: value2, ...}</code></p></li><li><p>还可以使用缩进表示层级关系:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key: </span><br><span class="line">    child-key: value</span><br><span class="line">    child-key2: value2</span><br></pre></td></tr></table></figure></li><li><p>较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的<code>key</code>，配合一个冒号加一个空格代表一个<code>value</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">?  </span><br><span class="line">    - complexkey1</span><br><span class="line">    - complexkey2</span><br><span class="line">:</span><br><span class="line">    - complexvalue1</span><br><span class="line">    - complexvalue2</span><br></pre></td></tr></table></figure></li><li><p>意思即对象的属性是一个数组<code>[complexkey1,complexkey2]</code>，对应的值也是一个数组<code>[complexvalue1,complexvalue2]</code></p></li></ul><hr><p><strong>YAML数组</strong></p><ul><li>以<code>&#39;-&#39;</code>开头的行表示构成一个数组:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- A</span><br><span class="line">- B</span><br><span class="line">- C</span><br></pre></td></tr></table></figure></li><li>YAML 支持多维数组，可以使用行内表示:<blockquote><p><code>key: [value1, value2, ...]</code></p></blockquote></li><li>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line"> - A</span><br><span class="line"> - B</span><br><span class="line"> - C</span><br></pre></td></tr></table></figure></li><li>一个相对复杂的例子:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">companies:</span><br><span class="line">    -</span><br><span class="line">        id: 1</span><br><span class="line">        name: company1</span><br><span class="line">        price: 200W</span><br><span class="line">    -</span><br><span class="line">        id: 2</span><br><span class="line">        name: company2</span><br><span class="line">        price: 500W</span><br></pre></td></tr></table></figure></li><li>意思是<code>companies</code>属性是一个数组，每一个数组元素又是由<code>id</code>,<code>name</code>,<code>price</code>三个属性构成</li><li>数组也可以使用流式(flow)的方式表示:<blockquote><p><code>companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]</code></p></blockquote></li></ul><hr><p><strong>复合结构</strong></p><ul><li>数组和对象可以构成复合结构，例:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">languages:</span><br><span class="line">  - Ruby</span><br><span class="line">  - Perl</span><br><span class="line">  - Python </span><br><span class="line">websites:</span><br><span class="line">  YAML: yaml.org </span><br><span class="line">  Ruby: ruby-lang.org </span><br><span class="line">  Python: python.org </span><br><span class="line">  Perl: use.perl.org</span><br></pre></td></tr></table></figure></li><li>转换为 json 为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  languages: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39;],</span><br><span class="line">  websites: &#123;</span><br><span class="line">    YAML: &#39;yaml.org&#39;,</span><br><span class="line">    Ruby: &#39;ruby-lang.org&#39;,</span><br><span class="line">    Python: &#39;python.org&#39;,</span><br><span class="line">    Perl: &#39;use.perl.org&#39; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>纯量</strong></p><ul><li><p>纯量是最基本的，不可再分的值，包括：</p></li><li><p>字符串</p></li><li><p>布尔值</p></li><li><p>整数</p></li><li><p>浮点数</p></li><li><p>Null</p></li><li><p>时间</p></li><li><p>日期</p></li><li><p>使用一个例子来快速了解纯量的基本使用：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean: </span><br><span class="line">    - TRUE  #true,True都可以</span><br><span class="line">    - FALSE  #false，False都可以</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    - 6.8523015e+5  #可以使用科学计数法</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    - 0b1010_0111_0100_1010_1110    #二进制表示</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#39;node&#39;</span><br><span class="line">    parent: ~  #使用~表示null</span><br><span class="line">string:</span><br><span class="line">    - 哈哈</span><br><span class="line">    - &#39;Hello world&#39;  #可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - newline</span><br><span class="line">      newline2    #字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">date:</span><br><span class="line">    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">datetime: </span><br><span class="line">    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>引用</strong></p><ul><li><code>&amp;</code>锚点和<code>*</code>别名，可以用来引用:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure></li><li>相当于:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>&amp;</code>用来建立锚点(defaults)，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点</p></blockquote><ul><li><p>下面是另一个例子:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &amp;showell Steve </span><br><span class="line">- Clark </span><br><span class="line">- Brian </span><br><span class="line">- Oren </span><br><span class="line">- *showell</span><br></pre></td></tr></table></figure></li><li><p>转为<code>JavaScript</code>代码如下:</p><blockquote><p><code>[ &#39;Steve&#39;, &#39;Clark&#39;, &#39;Brian&#39;, &#39;Oren&#39;, &#39;Steve&#39; ]</code></p></blockquote></li></ul><hr><p><strong>参考资料:</strong></p><p>YMAL官方文档:<a href="https://yaml.org/" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/</code></p><p>YMAL1.2规范文档:<a href="https://yaml.org/spec/1.2/spec.html" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/spec/1.2/spec.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
  </entry>
  <entry>
    <title>Docker Compose-3</title>
    <url>/2020/02/08/Docker-Compose-3/</url>
    <content><![CDATA[<!-- build time:Sat Feb 08 2020 16:59:52 GMT+0800 (中国标准时间) --><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>接<a href="https://unit-serow.github.io/2020/02/08/Docker-Compose-2/">Docker Compose-2</a></li></ul><ol><li><strong>devices</strong></li></ol><ul><li>用于指定设备映射列表</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;&#x2F;dev&#x2F;ttyUSB0:&#x2F;dev&#x2F;ttyUSB0&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li><strong>dns</strong></li></ol><ul><li>用于自定义 DNS 服务器，可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="3"><li><strong>dns_search</strong></li></ol><ul><li>用于自定义 DNS 搜索域</li><li>可以是单个值或列表</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="4"><li><strong>entrypoint</strong></li></ol><ul><li>用于覆盖容器默认的<code>entrypoint</code></li><li>实现语法:<blockquote><p><code>entrypoint: /code/entrypoint.sh</code></p></blockquote></li><li>或以下的列表格式:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20100525&#x2F;xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit&#x3D;-1</span><br><span class="line">    - vendor&#x2F;bin&#x2F;phpunit</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="5"><li><strong>env_file</strong></li></ol><ul><li>用于从文件添加环境变量</li><li>可以是单个值或列表的多个值</li><li>实现语法:<blockquote><p><code>env_file: .env</code></p></blockquote></li><li>也可以是列表格式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - .&#x2F;common.env</span><br><span class="line">  - .&#x2F;apps&#x2F;web.env</span><br><span class="line">  - &#x2F;opt&#x2F;secrets.env</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="6"><li><strong>environment</strong></li></ol><ul><li>用于添加环境变量</li><li>可以使用数组或字典，任何布尔值，布尔值需要用引号引起来，以确保<code>YML解析器</code>不会将其转换为<code>True</code>或<code>False</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#39;true&#39;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="7"><li><strong>expose</strong></li></ol><ul><li>用于暴露端口，但不映射到宿主机，只被连接的服务访问</li><li>实现语法(仅可以指定内部端口为参数)：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="8"><li><strong>extra_hosts</strong></li></ol><ul><li>用于添加主机名映射</li><li>类似<code>docker client --add-host</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure></li><li>以上会在此服务的内部容器中<code>/etc/hosts</code>创建一个具有<code>ip地址</code>和主机名的映射关系:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="9"><li><strong>healthcheck</strong></li></ol><ul><li>用于检测 docker 服务是否健康运行</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="10"><li><strong>image</strong></li></ol><ul><li>用于指定容器运行的镜像</li><li>以下格式都可以:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum&#x2F;influxdb</span><br><span class="line">image: example-registry.com:4000&#x2F;postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="11"><li><strong>logging</strong></li></ol><ul><li><p>服务的日志记录配置</p></li><li><p><code>driver:</code>用于指定服务容器的日志记录驱动程序，默认值为<code>json-file</code></p></li><li><p>可以有以下这三种选项</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure></li><li><p>仅在<code>json-file</code>驱动程序下，可以使用以下参数，限制日志得数量和大小</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure></li><li><p>当达到文件限制上限，会自动删除旧得文件</p></li><li><p><code>syslog</code>驱动程序下，可以使用<code>syslog-address</code>指定日志接收地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="12"><li><strong>network_mode</strong></li></ol><ul><li><p>用于设置网络模式</p></li><li><p>实现语法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name&#x2F;id]&quot;</span><br></pre></td></tr></table></figure></li><li><p>networks</p><blockquote><p>配置容器连接的网络，引用顶级<code>networks</code>下的条目</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure></li><li><p><code>aliases:</code>同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务</p></li></ul><hr><ol start="13"><li><strong>restart</strong></li></ol><ul><li><p>使用示例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure></li><li><p>参数说明:</p><blockquote><p><code>no</code>:是默认的重启策略，在任何情况下都不会重启容器<br><code>always</code>:容器总是重新启动<br><code>on-failure</code>:在容器非正常退出时(退出状态非0)，才会重启容器<br><code>unless-stopped</code>:在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p></blockquote></li><li><p><code>swarm集群</code>模式下，必须改用<code>restart_policy</code></p></li></ul><hr><ol start="14"><li><strong>secrets</strong></li></ol><ul><li>用于存储敏感数据</li><li>例如密码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: .&#x2F;my_secret.txt</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="15"><li><strong>security_opt</strong></li></ol><ul><li>修改容器默认的<code>schema</code>标签</li><li>使用说明:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="16"><li><strong>stop_grace_period</strong></li></ol><ul><li>指定在容器无法处理<code>SIGTERM</code>(或者任何<code>stop_signal</code>的信号)，等待多久后发送<code>SIGKILL</code>信号关闭容器</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒</span><br></pre></td></tr></table></figure></li><li>默认的等待时间是 10 秒</li></ul><hr><ol start="17"><li><strong>stop_signal</strong></li></ol><ul><li>设置停止容器的替代信号</li><li>默认情况下使用<code>SIGTERM</code></li><li>以下示例，使用<code>SIGUSR1</code>替代信号<code>SIGTERM</code>来停止容器<blockquote><p><code>stop_signal: SIGUSR1</code></p></blockquote></li></ul><hr><ol start="18"><li><strong>sysctls</strong></li></ol><ul><li>设置容器中的内核参数，可以使用数组或字典格式</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn&#x3D;1024</span><br><span class="line">  - net.ipv4.tcp_syncookies&#x3D;0</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="19"><li><strong>tmpfs</strong></li></ol><ul><li>在容器内安装一个临时文件系统</li><li>可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tmpfs: &#x2F;run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - &#x2F;run</span><br><span class="line">  - &#x2F;tmp</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="20"><li><strong>ulimits</strong></li></ol><ul><li>覆盖容器默认的<code>ulimit</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="21"><li><strong>volumes</strong></li></ol><ul><li>将主机的数据卷或着文件挂载到容器里</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;postgres.sock:&#x2F;var&#x2F;run&#x2F;postgres&#x2F;postgres.sock&quot;</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose-2</title>
    <url>/2020/02/08/Docker-Compose-2/</url>
    <content><![CDATA[<!-- build time:Sat Feb 08 2020 14:51:59 GMT+0800 (中国标准时间) --><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>为了通过使用compose，来让docker自动化配置程序与服务，必须编写YML文件(脚本)</li></ul><ol><li><strong>version</strong></li></ol><ul><li>指定本yml依从于compose哪个版本制定的</li></ul><ol start="2"><li><strong>build</strong></li></ol><ul><li>指定为构建镜像上下文路径</li><li>例如nginx服务，指定为从上下文路径./dir/Dockerfile 所构建的镜像</li><li>参数明细:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">context</td><td align="left">上下文路径</td></tr><tr><td align="left">dockerfile</td><td align="left">指定构建镜像的Dockerfile文件命</td></tr><tr><td align="left">args</td><td align="left">添加构建参数，这是只能在构建过程中访问的环境变量</td></tr><tr><td align="left">labels</td><td align="left">设置构建镜像的标签</td></tr><tr><td align="left">target</td><td align="left">多层构建，可以指定构建哪一层</td></tr></tbody></table><hr><ol start="3"><li><strong>cap_add，cap_drop</strong><br>添加或删除容器拥有的宿主机的内核功能<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><strong>cgroup_parent</strong></li></ol><ul><li>为容器指定父<code>cgroup</code>组，意味着将继承该组的资源限制<blockquote><p><code>cgroup_parent: m-executor-abcd</code></p></blockquote></li></ul><ol start="5"><li><strong>command</strong></li></ol><ul><li>覆盖容器启动的默认命令<blockquote><p><code>cmmand: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</code></p></blockquote></li></ul><ol start="6"><li><strong>container_name</strong></li></ol><ul><li>指定自定义容器名称，而不是生成的默认名称<blockquote><p><code>container_name: my-web-container</code></p></blockquote></li></ul><hr><ol start="7"><li><strong>depends_on</strong></li></ol><ul><li>设置依赖关系</li></ul><blockquote><p><code>docker-compose up</code>:以依赖性顺序启动服务，在以下示例中，先启动<code>db</code>和<code>redis</code>，才会启动<code>web</code><br><code>docker-compose up SERVICE</code>:自动包含<code>SERVICE</code>的依赖项，在以下示例中，<code>docker-compose up web</code>还将创建并启动<code>db</code>和<code>redis</code><br><code>docker-compose stop</code>:按依赖关系顺序停止服务，在以下示例中，<code>web</code>在<code>db</code>和<code>redis</code>之前停止</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><ul><li>此时的<code>web</code>服务不会等待<code>redis</code>和<code>db</code>完全启动之后才启动</li></ul><hr><ol start="8"><li><strong>deploy</strong></li></ol><ul><li>指定与服务的部署和运行有关的配置</li><li>只在 swarm 模式下才会有用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;xxx&quot;  # 服务版本</span><br><span class="line">services:  # 服务配置</span><br><span class="line">  redis:  # redis服务</span><br><span class="line">    image: redis:alpine  # 指定容器运行的镜像</span><br><span class="line">    deploy:  # 开始定义与该镜像有关的配置</span><br><span class="line">      mode：replicated  # 定义需要使用此参数配置具体运行的节点数量</span><br><span class="line">      replicas: 6  </span><br><span class="line">      endpoint_mode: dnsrr  # 访问集群服务的方式，这里是dns轮询(DNSRR)</span><br><span class="line">      labels:  # 给服务设上标签</span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources: #配置服务器资源使用的限制，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用，从而避免占用资源过高出现异常</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#39;0.50&#39;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &#39;0.25&#39;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:  # 配置如何在退出容器时重新启动容器</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure></li></ul><p><strong>可选参数一览与对上述参数解释:</strong></p><ul><li><code>endpoint_mode</code>:访问集群服务的方式<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">endpoint_mode: vip</span><br><span class="line"># Docker 集群服务一个对外的虚拟ip，所有的请求都会通过这个虚拟ip到达集群服务内部的机器</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"># DNS 轮询(DNSRR)，所有的请求会自动轮询获取到集群ip列表中的一个ip地址</span><br></pre></td></tr></table></figure></li><li><code>labels</code>:在服务上设置标签，可以用容器上的<code>labels</code>(跟<code>deploy</code>同级的配置)覆盖<code>deploy</code>下的<code>labels</code></li><li><code>mode</code>:指定服务提供的模式<blockquote><p><code>replicated</code>:复制服务，复制指定服务到集群的机器上<br><code>global</code>:全局服务，服务将部署至集群的每个节点</p></blockquote></li></ul><p><strong><code>replicated</code>与<code>global</code>的区别</strong></p><ul><li>逻辑简述:</li><li>所有的节点副本都处于本地主机的集群网络内</li><li>当选择<code>replicated</code>时，服务的副本只会被复制到所选节点的机器上</li><li>而选择<code>global</code>时，服务的副本会被复制到节点的每一个机器上，包括控制节点(manager node)</li><li>工作节点(worker node)，控制节点(manager node)</li></ul><hr><ol start="9"><li><strong><code>replicas: mode</code></strong></li></ol><ul><li>当此选项后的参数为<code>replicated</code>时，需要使用此参数配置具体运行的节点数量</li></ul><ol start="10"><li><strong><code>resources:</code></strong></li></ol><ul><li>用于配置服务器资源使用的限制，例如上例子，配置<code>redis</code>集群运行需要的<code>cpu</code>的百分比和内存的占用，避免占用资源过高出现异常</li></ul><hr><ol start="11"><li><strong><code>restart_policy:</code></strong></li></ol><ul><li>用于配置如何在退出容器时重新启动容器</li><li>参数明细<blockquote><p><code>condition</code>:可选<code>none</code>，<code>on-failure</code>或者<code>any</code>(默认值:<code>any</code>)<br><code>delay</code>:设置多久之后重启(默认值:0)<br><code>max_attempts</code>:尝试重新启动容器的次数，超出次数，则不再尝试(默认值:一直重试)<br><code>window</code>:设置容器重启超时时间(默认值:0)</p></blockquote></li></ul><hr><ol start="12"><li><strong><code>rollback_config</code></strong></li></ol><ul><li>用于配置在更新失败的情况下应如何回滚服务</li><li>参数明细:<blockquote><p><code>parallelism</code>:一次要回滚的容器数，如果设置为0，则所有容器将同时回滚<br><code>delay</code>:每个容器组回滚之间等待的时间(默认为0s)<br><code>failure_action</code>:如果回滚失败的处理方法(下一条所描述的内容)，其中一个<code>continue</code>或者<code>pause</code>(默认<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在回滚期间可以容忍的故障率(默认为0)<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认<code>stop-first</code>)</p></blockquote></li></ul><hr><ol start="13"><li><strong><code>update_config</code></strong></li></ol><ul><li><p>用于配置应如何更新服务，对于配置滚动更新很有用</p></li><li><p>参数明细:</p><blockquote><p><code>parallelism</code>:一次更新的容器数<br><code>delay</code>:在更新一组容器之间等待的时间<br><code>failure_action</code>:如果更新失败的解决办法依旧是下一条所描述的内容，其中一个<code>continue</code>，<code>rollback</code>或者<code>pause</code>(默认:<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在更新过程中可以容忍的故障率<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认stop-first)</p></blockquote></li><li><p>有些低版本的服务可能不支持<code>docker compose</code>所提供的服务</p></li><li><p>还有一半，放在下一篇写</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose-1</title>
    <url>/2020/02/07/Docker-Compose-1/</url>
    <content><![CDATA[<!-- build time:Fri Feb 07 2020 16:49:04 GMT+0800 (中国标准时间) --><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p><strong>概述:</strong></p><ul><li>Compose是用于定义和运行多容器Docker应用程序的工具</li><li>通过Compose，可以使用YML文件来配置应用程序需要的所有服务</li><li>最后通过使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</li><li><a href="https://yaml.org/" target="_blank" rel="noopener">YAML</a>官方文档</li></ul><hr><p><strong>安装 Compose</strong></p><ul><li><p>Github地址:<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/docker/compose/releases</code></p></blockquote></li><li><p>下载源码包(二进制文件)</p></li><li><p>Docker Compose当前的稳定版本：</p><blockquote><p><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>其中的1.25.4为版本号，可用于指定版本</p></li><li><p>提权至可执行文件</p><blockquote><p><code>$ sudo chmod +x /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>设置环境变量的软链接</p><blockquote><p><code>$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></p></blockquote></li><li><p>查看版本，以测试是否安装成功</p><blockquote><p><code>$ docker-compose --version</code></p></blockquote></li><li><p>对于Alpine/Linux发行版，需要安装依赖包:<code>py-pip</code>，<code>python-dev</code>，<code>libffi-dev</code>，<code>openssl-dev</code>，<code>gcc</code>，<code>libc-dev</code>，以及<code>make</code></p></li></ul><hr><p><strong>使用</strong></p><ul><li>对Compose进行使用大概可分为三个步骤:<blockquote><p>使用Dockerfile定义应用程序的环境<br>使用<code>docker-compose.yml</code>文件定义构成应用程序的服务，使其可以在隔离环境中一起运行<br>最后，执行<code>docker-compose up</code>命令来启动并运行整个应用程序</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Dockefile-1</title>
    <url>/2020/02/07/Docker-Dockefile-1/</url>
    <content><![CDATA[<!-- build time:Fri Feb 07 2020 16:46:46 GMT+0800 (中国标准时间) --><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><strong>概述:</strong></p><ul><li>Dockerfile是用于构建镜像的文本文件</li><li>文本内容包含构建镜像所需的指令和说明</li></ul><p><strong>关于上下文的概念:</strong></p><ul><li>上下文路径，是指Docker在构建镜像时如果需要使用到本机内的文件(比如复制)，<code>docker build</code>命令得知所指定的路径后，会将该路径下的所有内容打包</li><li>Docker的运行模式是C/S，主机为C，Docker引擎是S</li><li>实际的构建过程是在Docker引擎内完成的，所以此时无法调用到本机内的文件，此时就需要人为的把本机指定目录下的所有文件打包，并提供给Docker引擎进行调用</li><li>如果未说明最后一个参数(未指定上下文所在路径)，那么默认上下文路径就是Dockerfile所在的目录下</li><li>上下文路径下所有的文件都会打包给Docker引擎，如果无用文件过多的话会造成执行过程缓慢</li></ul><hr><p><strong>Dockerfile内的基本指令</strong></p><ol><li><strong>FROM</strong></li></ol><ul><li>定制的镜像都是基于FROM的镜像，在选择完要定义的基础镜像之后，后续的操作都是基于该基础镜像的</li><li>格式:<blockquote><p><code>FROM &lt;所选基础镜像名&gt;</code></p></blockquote></li></ul><hr><ol start="2"><li><strong>RUN</strong></li></ol><ul><li>用于执行后面跟着的命令行命令，有两种格式<blockquote><p>Shell格式: RUN [命令行命令]<br>Exec格式: RUN [“可执行文件”, “参数一”, “参数二”]</p></blockquote></li><li>Dockefile每次执行指令都会在docker上新建一层，多余的层会造成镜像膨胀</li><li>可以用&amp;&amp;符号来连接命令，从而不进行指令的线性执行，目的就是让所有的指令都集成到一层内<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUN xxx \</span><br><span class="line">   &amp;&amp; xxx \</span><br><span class="line">   &amp;&amp; xxx</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>CMD</strong></li></ol><ul><li>类似于<code>RUN</code>指令，用于运行程序</li><li>二者的区别在于其运行的时间点不同:<blockquote><p><code>CMD</code>在<code>docker run</code>时运行<br><code>RUN</code>是在<code>docker build</code>时运行</p></blockquote></li><li>作用:<blockquote><p>为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束<br><code>CMD</code>指令指定的程序可被<code>docker run</code>命令行参数中指定要运行的程序所覆盖</p></blockquote></li><li>格式:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure><blockquote><p>第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是<code>.sh</code>，所以可以直接使用第二种格式<br><code>最后一种写法是为</code>ENTRYPOINT<code>指令指定的程序提供默认参数</code></p></blockquote></li></ul><ol start="4"><li><strong>ENTRYPOINT</strong></li></ol><ul><li><p>类似于<code>CMD</code>指令，但其不会被<code>docker run</code>的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>但如果运行<code>docker run</code>时使用了<code>--entrypoint</code>选项，此选项的参数可当作要运行的程序覆盖<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>特点就是在执行<code>docker run</code>的时候可以指定<code>ENTRYPOINT</code>运行所需的参数</p></li><li><p>但如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效</p></li><li><p>格式:</p><blockquote><p><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></p></blockquote></li><li><p>还可以搭配<code>CMD</code>命令使用:一般是变参才会使用<code>CMD</code>，这里的<code>CMD</code>等于是在给<code>ENTRYPOINT</code>传参</p></li><li><p>这里假设已有了某镜像</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM 某镜像</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&lt;某镜像&gt;&quot;, &quot;-c&quot;] #定参</span><br><span class="line">CMD [&quot;&lt;&#x2F;执行脚本所在文件目录&gt;&quot;] #变参</span><br></pre></td></tr></table></figure></li><li><p>不传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt;</code></p></blockquote></li><li><p>此时容器内会默认(等于)运行以下命令，启动主进程</p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>容器内会默认(等于)运行以下命令，启动主进程<code>(/执行脚本所在文件目录:假设容器内已有此文件)</code></p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>简述</p><blockquote><p>指定了参数以后可以选择以传参或不传参的模式启动<br>不用传参就是直接启动所键入命令，用传参就是使用已指定的参数</p></blockquote></li></ul><hr><ol start="5"><li><strong>COPY</strong></li></ol><ul><li>用于复制的指令，可以从上下文目录复制文件或者目录到容器内的指定路径</li><li>使用格式:<blockquote><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></blockquote></li><li>参数说明:<blockquote><p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>为可选参数，可以让用户改变复制到容器内文件的拥有者和属组<br><code>&lt;源路径&gt;</code>用于表示源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足Go的<code>filepath.Match</code>规则<br><code>&lt;目标路径&gt;</code>用于在容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p></blockquote></li></ul><ol start="6"><li><strong>ADD</strong></li></ol><ul><li>ADD和COPY的使用格式一致</li><li>同样需求下，官方推荐使用COPY</li><li>ADD的优缺点:<blockquote><p>ADD的优点:在执行<code>&lt;源文件&gt;</code>为<code>tar</code>压缩文件的话，压缩格式为<code>gzip</code>，<code>bzip2</code>以及<code>xz</code>的情况下，会自动复制并解压到<code>&lt;目标路径&gt;</code><br>ADD的缺点:在不解压的前提下，无法复制<code>tar</code>压缩文件，会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</p></blockquote></li><li>具体是否使用，可以根据所处情况是否需要自动解压来决定</li></ul><hr><ol start="7"><li><strong>ENV</strong></li></ol><ul><li><p>用于设置与定义环境变量，定义之后可以直接使用环境变量</p></li><li><p>使用格式:</p><blockquote><p><code>ENV &lt;key&gt; &lt;value&gt;</code><br><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p></blockquote></li><li><p>以下示例设置<code>NODE_VERSION = 7.2.0</code>，在后续的指令中可以直接通过<code>$NODE_VERSION</code>进行引用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>ARG</strong></li></ol><ul><li>构建参数，与<code>ENV</code>作用一致，不过作用域不一样，<code>ARG</code>设置的环境变量仅对<code>Dockerfile</code>内有效，也就是说只有<code>docker build</code>的过程中有效，构建好的镜像内不存在此环境变量</li><li>构建命令<code>docker build</code>中可以用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖</li><li>使用格式：<blockquote><p><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p></blockquote></li></ul><hr><ol start="9"><li><strong>VOLUME</strong></li></ol><ul><li>定义匿名数据卷</li><li>在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</li><li>可以避免重要的数据因容器重启而丢失</li><li>还可以避免容器不断变大</li><li>使用格式:<blockquote><p><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code><br><code>VOLUME &lt;路径&gt;</code></p></blockquote></li><li>在启动容器<code>docker run</code>的时候，可以使用参数<code>-v</code>修改挂载点</li></ul><hr><ol start="10"><li><strong>EXPOSE</strong></li></ol><ul><li>用于声明端口</li><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li><li>在运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口</li><li>使用格式:<blockquote><p><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></blockquote></li></ul><hr><ol start="11"><li><strong>WORKDIR</strong></li></ol><ul><li>用于指定工作目录</li><li>用<code>WORKDIR</code>指定的工作目录，会在构建镜像的每一层中都存在(<code>WORKDIR</code>指定的工作目录，必须是提前创建好的)</li><li>在使用<code>docker build</code>构建镜像过程中的，每一个<code>RUN</code>命令都是新建的一层，只有通过<code>WORKDIR</code>创建的目录才会一直存在</li><li>使用格式:<blockquote><p><code>WORKDIR &lt;工作目录路径&gt;</code></p></blockquote></li></ul><ol start="12"><li><strong>USER</strong></li></ol><ul><li>用于指定执行后续命令的用户和用户组，用于切换后续命令执行的用户(用户和用户组必须提前已经存在)</li><li>使用格式:<blockquote><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p></blockquote></li></ul><hr><ol start="13"><li><strong>HEALTHCHECK</strong></li></ol><ul><li>用于指定某个程序或者指令来监控Docker容器服务的运行状态</li><li>使用格式:<blockquote><p><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令<br><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code> : 这个<code>CMD</code>后面跟随的命令使用，可以参考<code>CMD</code>的用法</p></blockquote></li></ul><hr><ol start="14"><li><strong>ONBUILD</strong></li></ol><ul><li>用于延迟构建命令的执行</li><li>简述:<blockquote><p>在<code>Dockerfile</code>里用<code>ONBUILD</code>指定的命令，在本次构建镜像的过程中不会执行(假设镜像为test-build)<br>当有新的<code>Dockerfile</code>使用了之前构建的镜像<code>FROM test-build</code>，这是执行新镜像的<code>Dockerfile</code>构建时候，<code>会执行 test-build</code>的<code>Dockerfile</code>里的<code>ONBUILD</code>指定的命令</p></blockquote></li><li>使用格式:<blockquote><p><code>ONBUILD &lt;其它指令&gt;</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-4</title>
    <url>/2020/02/06/Docker-4/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 21:21:01 GMT+0800 (中国标准时间) --><h3 id="Docker-镜像，网络，连接以及仓库的使用"><a href="#Docker-镜像，网络，连接以及仓库的使用" class="headerlink" title="Docker-镜像，网络，连接以及仓库的使用"></a>Docker-镜像，网络，连接以及仓库的使用</h3><p><strong>Docker 容器镜像的使用</strong></p><ul><li>管理和使用本地的docker镜像</li><li>查看本地主机已有镜像<blockquote><p><code>$ docker images</code></p></blockquote></li><li>各参数说明:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">REPOSITORY</td><td align="left">表示镜像的仓库源</td></tr><tr><td align="left">TAG</td><td align="left">镜像的标签</td></tr><tr><td align="left">IMAGE ID</td><td align="left">镜像ID</td></tr><tr><td align="left">CREATED</td><td align="left">镜像创建时间</td></tr><tr><td align="left">SIZE</td><td align="left">镜像大小</td></tr></tbody></table><ul><li>同一仓库源可以有多个<code>TAG</code>，代表这个仓库源的不同个版本</li><li><code>REPOSITORY:TAG</code>用于定义不同的镜像</li><li>例如使用<code>debian</code>，如果不指定一个镜像的版本标签，Docker 将默认使用<code>debian:latest</code>镜像</li></ul><p><strong>获取镜像</strong></p><ul><li>执行命令拉取10.2.0版本的debian镜像<br><code>$ docker pull debian:10.2.0</code><blockquote><p>获取之后可直接基于此镜像来运行容器<br>还可以从<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>上获取镜像<br><code>https://hub.docker.com/</code></p></blockquote></li></ul><p><strong>搜索镜像</strong></p><ul><li><p>执行命令搜索指定镜像名的镜像</p><blockquote><p><code>$ docker search [镜像名]</code><br>比如搜索一个httpd的镜像来用作web服务<br><code>$ docker search httpd</code></p></blockquote></li><li><p>各参数说明:</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NAME</td><td align="left">镜像仓库源的名称</td></tr><tr><td align="left">DESCRIPTION</td><td align="left">镜像的描述</td></tr><tr><td align="left">OFFICIAL</td><td align="left">是否 docker 官方发布</td></tr><tr><td align="left">stars</td><td align="left">类似 Github 里面的star</td></tr><tr><td align="left">AUTOMATED</td><td align="left">是否支持自动构建</td></tr></tbody></table></li></ul><blockquote><p>然后直接拉取镜像<br><code>$ docker pull httpd</code></p></blockquote><p><strong>删除镜像</strong></p><ul><li>执行以下命令:<blockquote><p><code>$ docker rmi 镜像名</code></p></blockquote></li></ul><hr><p><strong>创建镜像/制作镜像</strong></p><ul><li>当docker的镜像仓库中没有所需求的docker镜像时，可以制作镜像或对镜像进行修改再上传</li></ul><p><strong>更新镜像</strong></p><ul><li>从已经创建的容器中更新镜像，并且提交此镜像<blockquote><p>更新镜像之前，基于所选镜像来创建一个容器<br><code>$ docker run -t -i debian:10.2.0 /bin/bash</code><br>在容器内使用<code>apt-get update</code>命令来进行更新<br>操作完成之后，键入<code>exit</code>退出容器</p></blockquote></li><li>使用<code>docker commit</code>来提交容器副本<br><code>$ docker commit -m=&quot;has update&quot; -a=&quot;name&quot; [Containers ID] /debian:v2</code><blockquote><p><code>参数-m</code>用于指定提交的描述信息<br><code>参数-a</code>用于指定镜像作者<br><code>Containers ID</code>:容器 ID<br><code>debian:v2:</code>指定要创建的目标镜像名</p></blockquote></li><li>最后<code>docker images</code>查看新镜像，并用其启动容器</li></ul><p><strong>构建镜像</strong></p><ul><li>使用命令<code>docker build</code>，创建一个新的镜像</li><li>创建名为<code>Dockerfile</code>的文件，其中包含的指令用来指示Docker如何构建所选镜像</li><li>编写完Dockerfile之后通过docker build命令来构建一个新的镜像<blockquote><p><code>docker build -t [目标镜像名] [指定绝对路径]</code><br><code>参数-t</code>用于指定要创建的目标镜像名<br><code>参数.</code>用于指定Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</p></blockquote></li></ul><p><strong>设置镜像标签</strong></p><ul><li><code>docker tag</code>命令，为镜像添加一个新的标签<blockquote><p><code>docker tag [镜像ID] [用户名称/镜像源名(repository name)]:[新的标签名(tag)]</code></p></blockquote></li></ul><hr><p><strong>Docker 容器连接</strong></p><ul><li>容器中可以运行一些网络应用，从实现而让任意机器可以通过网络端口访问运行在docker容器内部的服务</li><li>要实现让任意机器(内部与外部)可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射</li><li>还可以指定容器绑定的网络地址，比如绑定本地主机的<code>127.0.0.1</code></li></ul><p><strong>网络端口映射的管理</strong></p><blockquote><p><code>docker run -d -P [网络服务名称] [服务的启动脚本]</code></p></blockquote><ul><li>参数说明:</li><li>参数-P用于创建容器，此时该网络服务绑定本地主机的默认端口</li><li>参数-p用于指定容器端口所绑定的主机端口</li><li>具体区别<blockquote><p>参数-P是让容器内部端口随机映射到主机的高端口<br>参数-p是让容器内部端口绑定到指定的主机端口</p></blockquote></li></ul><blockquote><p><code>docker run -d -p [原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote><ul><li>然后执行docker ps 就会发现服务已改变端口映射</li></ul><p><strong>指定容器绑定的网络地址</strong></p><ul><li>这里绑定127.0.0.1:<blockquote><p><code>docker run -d -p [127.0.0.1:原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote></li><li>此时就可以通过绑定的IP地址，来访问容器被指定绑定的接口</li><li>默认都是绑定TCP端口，如果要绑定UDP端口，可以在端口后面加上<code>/udp</code></li><li><code>docker port</code>命令可以让我们快捷地查看端口的绑定情况</li></ul><hr><h3 id="Docker-容器互连"><a href="#Docker-容器互连" class="headerlink" title="Docker 容器互连"></a>Docker 容器互连</h3><ul><li>端口映射不是唯一把Docker连接到另一个容器的方法</li><li>Docker内有一个连接系统允许将多个容器进行连通，以此共享被连接容器的信息</li><li>Docker连接会创建一个子父关系，其中父容器可以看到子容器的信息</li><li>先给容器进行统一的命名，以方便管理<blockquote><p><code>docker run -d -P --name [自定义容器名] [应用程序名称] [程序的启动脚本]</code><br><code>参数--name</code>用于定义容器名</p></blockquote></li></ul><p><strong>创建docker网络</strong></p><blockquote><p><code>docker network create -d bridge [Containers-net]</code><br><code>参数-d</code>用于指定Docker的网络类型，有<code>bridge</code>与<code>overlay</code><br>其中<code>overlay</code>网络类型用于<code>Swarm mode</code></p></blockquote><p><strong>连接容器</strong></p><ul><li>运行一个容器并连接到新建的<code>Containers-net</code>网络<blockquote><p><code>$ docker run -itd --name test1 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>打开新的终端，再运行一个容器并加入到 test-net 网络:<blockquote><p><code>$ docker run -itd --name test2 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>使用test1和test2两个容器互相ping一下以测试是否建立联系，如果没有ping命令就进行安装<blockquote><p><code>apt install iputils-ping</code></p></blockquote></li><li>可以在一个容器里安装好之后把容器包装成镜像，再以新的镜像重新运行以上两个容器</li><li>如果有多个容器之间需要互相连接，可以使用<code>Docker Compose</code></li></ul><p><strong>配置容器DNS</strong></p><ul><li><p><code>/etc/docker/daemon.json</code>文件中增加以下内容来设置全部容器的DNS:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;111.111.111.111&quot;,</span><br><span class="line">    &quot;3.3.3.3&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置后，启动容器的DNS会自动配置为<code>111.111.111.111 和 3.3.3.3</code></p></li><li><p>配置完，需要重启Docker服务才能生效</p><blockquote><p><code>/etc/init.d/docker restart</code></p></blockquote></li><li><p>查看容器的DNS是否生效可以使用以下命令，它会输出容器的DNS信息:</p><blockquote><p><code>$ docker run -it --rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>只想在指定的容器设置 DNS，则可以使用以下命令</p><blockquote><p><code>docker run -it --rm host_debian --dns=111.111.111.111 --dns-search=test.com debian</code></p></blockquote></li><li><p>参数说明：</p><blockquote><p>参数<code>-h HOSTNAME</code>或<code>--hostname=HOSTNAME:</code>设定容器的主机名，它会被写到容器内的<code>/etc/hostname</code>和<code>/etc/hosts</code><br>参数<code>--dns=IP_ADDRESS:</code>添加DNS服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在<code>/etc/hosts</code>中的主机名<br>参数<code>--dns-search=DOMAIN:</code>设定容器的搜索域，当设定搜索域为<code>.example.com</code>时，在搜索一个名为<code>host</code>的主机时，DNS不仅搜索<code>host</code>，还会搜索<code>host.example.com</code><br>如果在容器启动时没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></blockquote></li></ul><hr><p><strong>仓库管理</strong></p><ul><li><p>仓库(Repository)用于集中存放镜像</p></li><li><p>目前Docker官方维护了一个公共仓库Docker Hub</p></li><li><p>大部分需求都可以通过在Docker Hub中直接下载镜像来实现</p></li><li><p>网址为<code>https://hub.docker.com</code>，<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p></li><li><p>使用之前需要注册账户</p></li><li><p>登陆Docker hub执行</p><blockquote><p><code>$ docker login</code></p></blockquote></li><li><p>退出 docker hub执行</p><blockquote><p><code>$ docker logout</code></p></blockquote></li><li><p>查找镜像</p><blockquote><p><code>$ docker search [镜像名]</code></p></blockquote></li><li><p>拉取镜像</p><blockquote><p><code>$ docker pull [镜像名]</code></p></blockquote></li></ul><p><strong>推送镜像</strong></p><ul><li>把本地的镜像推送到Docker Hub</li><li><code>username</code>为Docker账号的用户名<blockquote><p><code>$ docker tag [镜像名]:[版本] [username/镜像名:版本]</code><br><code>$ docker image ls</code><br><code>$ docker push [username/镜像名:版本]</code></p></blockquote></li><li>最后查看一下<blockquote><p><code>$ docker search [username/镜像名]</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><p>官方文档:<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Docker-3</title>
    <url>/2020/02/06/Docker-3/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 18:54:29 GMT+0800 (中国标准时间) --><h3 id="Docker容器的基本命令与基本应用"><a href="#Docker容器的基本命令与基本应用" class="headerlink" title="Docker容器的基本命令与基本应用"></a>Docker容器的基本命令与基本应用</h3><p><strong>基本操作命令</strong></p><p><strong>拉取镜像</strong><br><code>$ docker pull --help</code><br><code>$ docker pull [OPTIONS] NAME:[:TAG|@DIGEST]</code><br>如果本地没有镜像，用pull从仓库里拉个镜像用<br><code>$ docker pull debian</code></p><p><strong>基于已有镜像启动容器服务</strong><br><code>$ docker run --help</code><br><code>$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><br><code>$ docker run -i -t debian /bin/bash</code></p><ul><li><code>参数-i</code>启动交互式选项，<code>参数-t</code>启动终端选项</li><li><code>debian</code>:也就是debian镜像</li><li><code>/bin/bash</code>:放在镜像后的是被执行指令，这里用<code>/bin/bash</code>来启动交互式<code>Shell</code></li><li>退出当前容器内终端执行<code>exit</code></li></ul><hr><p><strong>查看所有容器</strong><br><code>$ docker ps -a</code></p><ul><li>查询最后一次创建的容器<br><code>$ docker ps -l</code></li></ul><p><strong>启动一个已停止的容器</strong><br><code>$ docker start [容器ID]</code></p><ul><li><code>参数-d</code>用于指定容器的运行模式，加了此参数的程序默认不会进入程序，进入容器需要使用指令<code>docker exec</code></li><li>在后台内利用容器debian运行debian-test程序</li><li><code>$ docker run -i -t -d --name debian-test debian /bin/bash</code></li></ul><p><strong>停止容器</strong><br><code>$ docker stop [容器 ID]</code></p><p><strong>重启容器</strong><br><code>$ docker restart [容器 ID]</code></p><p><strong>进入容器</strong><br><code>$ docker attach/exec --help</code></p><ul><li>在执行<code>参数-d</code>后，容器启动后会进入后台</li><li>此时想要进入容器，可以通过以下指令进入：<blockquote><p>docker attach<br>docker exec(使用docker exec命令时退出容器终端，不会导致容器的停止)<br><code>$ docker attach 容器ID</code>(如果从这个容器退出，会导致容器的停止)<br><code>$ docker exec -i -t 容器ID /bin/bash</code>(从这个容器退出，不会导致容器的停止)</p></blockquote></li></ul><p><strong>导出本地的某个容器</strong><br><code>$ docker export [容器ID] &gt; [生成的文件名(可以是tar或其他压缩文件)]</code></p><blockquote><p>把指定ID的容器快照导入到本地文件，保存地址是现在所处目录</p></blockquote><p><strong>导入容器快照</strong><br><code>$ docker import --help</code><br><code>$ docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></p><blockquote><p>将快照文件<code>debian.tar</code>导入到镜像<code>image-file/debian:v1</code>内<br><code>$ cat docket/debian.tar | docker import - image-test/debian:v1</code><br>还可以通过指定URL或者某个目录来导入<br><code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></p></blockquote><p><strong>删除容器</strong><br><code>$ docker rm -f [容器ID]</code></p><ul><li>清理所有已中止容器<br><code>$ docker container prune</code></li></ul><hr><p><strong>利用docker运行某个应用程序</strong></p><ul><li>拉取某个应用程序<br><code>$ docker pull [应用程序名]</code><br><code>$ docker run -d -P [被拉取的程序名] [运行脚本]</code><blockquote><p><code>参数-d</code>让容器在后台运行<br><code>参数-P</code>将容器内部使用的网络端口映射到我们使用的主机上<br>如果程序占用了某一端口，<code>docker ps</code>的时候会显示占用端口以及映射信息(PORST)</p></blockquote></li><li>通过<code>-p参数</code>来设置不一样的端口<br><code>$ docker run -d -p [原端口:指定端口] [被拉取的程序名] [运行脚本]</code></li></ul><p><strong>查看应用程序或容器使用的端口以及映射情况</strong><br><code>$ docker ps</code><br><code>$ docker port [容器ID/程序名]</code></p><p><strong>查看应用程序日志</strong><br><code>docker logs [容器ID/程序名]</code></p><blockquote><p>用于查看容器内部的标准输出<br><code>参数-f</code>用于让<code>docker logs</code>输出容器内部的标准输出，类似于Linux内的<code>tail -f</code>命令</p></blockquote><p><strong>查看应用程序进程</strong><br><code>$ docker top [容器ID/程序名]</code></p><p><strong>检查应用程序底层信息</strong><br><code>$ docker inspect [容器ID/程序名]</code></p><blockquote><p>会返回一个记录着关于选中应用程序的Docker容器配置和状态信息的文本</p></blockquote><p><strong>停止应用程序所在容器</strong><br><code>$ docker stop [容器ID/程序名]</code></p><p><strong>重启应用程序所在容器</strong><br><code>$ docker start [容器ID/程序名]</code></p><p><strong>移除应用程序所在容器</strong><br><code>$ docker rm [容器ID/程序名]</code></p><blockquote><p>删除容器时，容器必须是停止状态</p></blockquote><hr><p><strong>帮助命令:</strong></p><ul><li>直接执行<code>docker</code>，查看Docker客户端的所有可用指令选项</li><li>docker command –help，查看所选命令的帮助文件</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-2</title>
    <url>/2020/02/06/Docker-2/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 16:55:35 GMT+0800 (中国标准时间) --><h3 id="Docker-Engine-Community-install"><a href="#Docker-Engine-Community-install" class="headerlink" title="Docker Engine-Community install"></a>Docker Engine-Community install</h3><p><strong>Debian Docker 安装</strong></p><ul><li>Docker Engine-Community 支持版本:<br><code>Buster 10与Stretch 9 (stable) / Raspbian Stretch</code></li><li>Docker Engine-Community 支持架构:<br><code>x86_64(或amd64)armhf，和 arm64</code></li></ul><blockquote><p>选定主机的首次安装需要设置Docker仓库，用以从仓库安装和更新Docker，而Raspbian系统必须使用shell脚本安装</p></blockquote><p><strong>设置仓库</strong></p><p>安装apt依赖包，以通过HTTPS来获取仓库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">   apt-transport-https \</span><br><span class="line">   ca-certificates \</span><br><span class="line">   curl \</span><br><span class="line">   gnupg2 \</span><br><span class="line">   software-properties-common</span><br></pre></td></tr></table></figure><p><strong>添加Docker的官方GPG密钥</strong><br><code>$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></p><blockquote><p>通过搜索指纹的最后八个字符，验证目前主机是否拥有带指纹的密匙<br>密匙:<code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code><br>执行:<code>$ sudo apt-key fingerprint 0EBFCD88</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pub   4096R&#x2F;0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint &#x3D; 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R&#x2F;F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure><p><strong>设置稳定版仓库</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;debian \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lsb_release -cs</code>子命令用于返回Debian发行版的名称</li><li>Docker对未经测试和不受支持的Debian发行版不提供任何保证</li></ul><hr><p><strong>安装 Docker Engine-Community</strong></p><ul><li><p>更新apt包索引<br><code>$ sudo apt-get update</code></p></li><li><p>安装最新版本的 Docker Engine-Community和containerd<br><code>$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></p></li><li><p>安装指定版本的 Docker Engine-Community</p></li><li><p>列出仓库中的可用版本<br><code>apt-cache madison docker-ce</code></p></li><li><p>使用<code>docker-ce |</code>后所输出的字符串安装指定版本，然后执行:<br><code>$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</code></p></li></ul><p><strong>卸载主机上Docker的旧版本</strong></p><ul><li>Docker的旧版本被称为<code>docker</code>，<code>docker.io</code>或<code>docker-engine</code><br><code>$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></li></ul><p><strong>帮助指令</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker command --help</span><br><span class="line">man docker</span><br></pre></td></tr></table></figure><hr><p><strong>docker 镜像配置</strong></p><ul><li><p>Docker官方提供的中国镜像库:<code>https://registry.docker-cn.com</code></p></li><li><p>以添加Docker官方镜像库地址<code>https://registry.docker-cn.com</code>为例</p></li><li><p>upstart系统<br><code>$ emacs /etc/default/docker</code></p></li><li><p>修改其中<code>DOCKER_OPTS</code>的配置<br><code>DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;</code></p></li><li><p>重启服务<br><code>$ sudo service docker restart</code></p></li><li><p>systemd系统<br><code>emacs /etc/docker/daemon.json</code></p></li><li><p>如果没有就创建，在文件内添加:<br><code>{&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]}</code></p></li><li><p>重启服务<br><code>$ sudo systemctl daemon-reload</code><br><code>$ sudo systemctl restart docker</code></p></li><li><p>检查配置是否生效<br><code>$ docker info</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">   https:&#x2F;&#x2F;registry.docker-cn.com&#x2F;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>参考资料:</strong></p><p>官方手册:<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><p>官方安装手册:<a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/install/linux/docker-ce/debian/</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-1</title>
    <url>/2020/02/06/Docker-1/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 15:52:18 GMT+0800 (中国标准时间) --><h3 id="Docker的基本概述与原理简述"><a href="#Docker的基本概述与原理简述" class="headerlink" title="Docker的基本概述与原理简述"></a>Docker的基本概述与原理简述</h3><p><strong>概述:</strong></p><ul><li>基于google公司退出的Go语言实现</li><li>基于apache2.0协议，项目代码在github上进行维护</li><li>Docker项目的目标是实现轻量级的操作系统虚拟化解决方案</li><li>Docker的基础是linux容器(LXC)等技术，Docker在LXC<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的基础上Docter进行了进一步的封装，让用户不需要去关心容器的管理，从而使其操作更为简便</li></ul><p><strong>docker和传统虚拟化方式的不同之处</strong></p><ul><li>可见容器技术Docker是在操作系统层面上实现虚拟化，直接对本机的操作系统进行复用</li><li>而传统方式则是在硬件层面上实现虚拟化</li><li>引用自官方文档:<blockquote><p>传统的(virtual machines)虚拟化技术不仅需要包含应用程序本身和必要的依赖所需要的存储空间以及容量，还需要承受若干个完整的操作系统所占有的存储空间，这些操作系统所占有的存储空间往往以GB为单位<br>Docker容器引擎只包含了其应用程序以及依赖项，它在主机操作系统的用户空间内作为一个完全被隔离且独立的进程去运行，同时与其他容器共享内核，所以说它不仅拥有VM内资源隔离和分配技术所带来的优点，还拥有更强的可移植性和效率等优势</p></blockquote></li></ul><p><strong>Docker与传统虚拟化方式相比，所拥有的优势</strong></p><ul><li>拥有更快速的交付和部署<br>Docker允许开发者在装有应用和服务本地容器做开发，从而直接集成到可持续开发流程中，以在整个开发周期中都可以完美的辅助开发者实现快速交付</li><li>高效的部署和扩容<br>因docker容器引擎的高可移植性，使其可以在任何软硬件平台上运行<br>这种可兼容的移植性可以让开发者把任何应用程序从一个硬件平台上直接迁移到另外一个硬件平台上<br>Docker的可兼容移植性和轻量特性可以很轻松的实现负载的动态管理，使开发者可以快速扩容或方便的下线某一应用和服务，这种速度将趋近实时</li><li>更高的资源利用率<br>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小<br>以传统虚拟机的方式运行10个不同的应用就要起10个虚拟机，而Docker 只需要启动10个相互隔离的应用即可</li><li>更简单的管理<br>使用 Docker，只需要简易的修改，就可以替代以往大量的更新工作<br>所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理</li></ul><hr><p><strong>Docker引擎简述</strong></p><ul><li>Docker引擎是一个C/S结构的程序</li><li>简要流程:</li><li><code>(contiainer-manages/image-manages/network-manages/network-manages)-&gt;client docker CLI</code></li><li><code>client docker CLI-&gt;REST API-&gt;server doceker deamon</code></li><li>Server是一个常驻进程</li><li>REST API 实现了client和server间的交互协议</li><li>CLI 实现容器和镜像的管理，为用户提供统一的操作界面</li></ul><p><strong>Docker架构简述</strong></p><ul><li>Docker使用C/S架构</li><li>客户端，Docker程序与主机程序镜像由接口通信</li><li>指令由客户端发出，而Docker内部的镜像由主机经由接口提供</li><li>任何指令对镜像的操作都在Docker程序内部的独立化容器服务内完成</li></ul><p><strong>逻辑简述</strong></p><ul><li>最初由client发出管理指令</li><li>经由<code>DOCKER_HOST</code>接口操作docker daemon(程序)内的容器以及程序镜像(包括操作系统)</li><li>docker deamon中已存在其注册表内的程序由<code>DOCKER_HOST</code>接口返回给docker deamon内作为镜像使用</li><li>而程序及系统的镜像再被分布给docker deamon内部的独立容器服务所管理</li><li>简而言之就是命令最后被传输到所指定镜像的容器服务内，进入其容器，对其程序进行操作</li><li>简要流程:</li><li><code>Client(指令)-DOCKER_HOST-&gt;Docker deamon&lt;-DOCKER_HOST-Registry(注册表内已有程序)</code></li><li><code>Docker-&gt;Images(Rigistry)-&gt;Containers</code></li><li><code>从而实现Client-&gt;Containers</code></li></ul><hr><p><strong>关于Docker最基本的核心概念</strong></p><ul><li>镜像(Image)<br>Docker镜像(Image)，镜像其实就是一个只读的模板文件<br>例如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了Apache或用户需要的其它应用程序<br>镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器<br>Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户可以直接从其他人那里下载一个已经做好的镜像来直接使用<br>镜像(Image)就是一堆只读层(read-only layer)的统一视角<br>这些只读层堆叠在一起，除了最下面的只读层，其它的只读层都会由指针指向它所对应的下一层<br>这些层是Docker内部的实现细节，并且能够在docker宿主机统一的的文件系统<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>上访问到</li></ul><p>简要结构流程:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read-only layer:</span><br><span class="line">Images(union file system):</span><br><span class="line">read-only layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-&gt;...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read-write layer:</span><br><span class="line">Images(union file system):</span><br><span class="line">bash&#x2F;process-&gt;RW union file system</span><br><span class="line">read-write layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-&gt;...</span><br></pre></td></tr></table></figure><ul><li><p>仓库(repository)<br>仓库(Repository)是集中存放镜像文件的目录<br>仓库和仓库注册服务器(Registry)的区别不大<br>仓库注册服务器上通常存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)<br>仓库分为公开仓库(Public)和私有仓库(Private)两种形式，最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载<br>国内公开的镜像仓库有很多，在我设置的友情连接里有几个我常用的镜像源的地址<br>用户也可以在本地网络内创建一个私有仓库<br>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了<br>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务平台</p></li><li><p>容器(container)<br>Docker 利用容器(Container)来运行应用，容器是从镜像创建的运行实例<br>它可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台<br>容器的定义和镜像近乎相同，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的<br>一个运行态容器被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程<br>所以说一个容器中的进程可以对文件进行修改、删除、创建，这些改变都将作用于可读写层</p></li><li><p>Docker 客户端(Client)<br>Docker 客户端通过命令行或者其他工具与Docker的守护进程通信<br><a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker SDK</a><br><code>https://docs.docker.com/develop/sdk/</code></p></li><li><p>Docker 主机(Host)<br>一个物理或者虚拟的机器用于执行Docker守护进程和容器</p></li></ul><hr><p><strong>参考文献与获取方式</strong></p><p>官网<a href="https://www.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://www.docker.com/</code></p><p>文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><p>docker中国区镜像源<br><code>https://registry.docker-cn.com</code></p><p>获取<a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/get-docker/</code></p><p>获取Docker Engine-Debian<a href="https://hub.docker.com/editions/community/docker-ce-server-debian" target="_blank" rel="noopener">跳转</a><br><code>https://hub.docker.com/editions/community/docker-ce-server-debian</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">LXC，其名称来自Linux软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为Linux内核容器功能的一个用户空间接口，关于LXC更详细的内容这里先不做阐述</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">统一文件系统(Union File System)技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>makedown流程图-flowchart</title>
    <url>/2020/02/05/flowchart/</url>
    <content><![CDATA[<!-- build time:Wed Feb 05 2020 13:20:58 GMT+0800 (中国标准时间) --><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p><strong>概述:</strong></p><ul><li>流程图的语法大概可以分为两部分:定义元素与连接元素</li><li>定义变量所使用的语句大概结构是X=Y: Z</li><li>X是变量名，Y是操作模块名，Z是具体显示的文字内容，注意冒号后的空格，有空格的时候才能被识别</li></ul><p><strong>基本语法:</strong><br>由于渲染的问题，这里用&lt;.&gt;代替了&lt;`&gt;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">tag&#x3D;&gt;type: content:&gt;url</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">tag1(...)-&gt;tag2(...)-&gt;tag3(...)</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>括号内语句用逗号分隔</p><p><strong>定义元素语法:</strong></p><ul><li>tag=&gt;type: content:&gt;url</li><li>tag：标签，用于连接元素时使用</li><li>type：该标签的类型，共有6种类型如下</li><li>content：流程语句中放置的内容</li><li>type:与content之间有一个空格</li><li>url：链接，与流程语句绑定</li></ul><p><strong>连接元素语法:</strong></p><ul><li>使用-&gt;符号，-&gt;表示下一步要执行的操作：</li><li>st-&gt;in-&gt;op-&gt;cond</li><li>表示的是先从st转到in，然后再到op，最后到cond</li><li>可以连续写，也可以分开写</li></ul><p><strong>判断分支语法:</strong></p><ul><li>condition 是判断，可以取yes和no两种结果，对于不同结果可以有不同走向</li><li>cond(yes)-&gt;out 表示condition成立时转向out执行</li><li>cond(no)-&gt;op 表示condition不成立时转向op执行</li></ul><p><strong>操作模块说明:</strong><br>操作模块一共有以下六种:</p><table><thead><tr><th align="left">操作模块名</th><th align="left">表示含义说明</th></tr></thead><tbody><tr><td align="left">start</td><td align="left">开始</td></tr><tr><td align="left">end</td><td align="left">结束</td></tr><tr><td align="left">operation</td><td align="left">普通操作块</td></tr><tr><td align="left">subroutine</td><td align="left">子任务块</td></tr><tr><td align="left">condition</td><td align="left">判断块</td></tr><tr><td align="left">inputoutput</td><td align="left">输入输出块</td></tr></tbody></table><hr><p><strong>示例说明-1:</strong><br>竖向:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-0" class="flow-chart"></div><hr><p>示例说明-2:<br>横向:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-1" class="flow-chart"></div><hr><p>实例说明-3:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow   </span><br><span class="line">st&#x3D;&gt;start: 开始语句</span><br><span class="line">in&#x3D;&gt;inputoutput: 输入值</span><br><span class="line">e&#x3D;&gt;end: 结束语句</span><br><span class="line">op&#x3D;&gt;operation: 执行操作</span><br><span class="line">cond&#x3D;&gt;condition: 是否成立？</span><br><span class="line">out&#x3D;&gt;inputoutput: 输出值</span><br><span class="line"></span><br><span class="line">st-&gt;in-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;out</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">out-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-2" class="flow-chart"></div><hr><p>示例说明-4:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">e&#x3D;&gt;end: Why are you worried?</span><br><span class="line">cond1&#x3D;&gt;condition: Do you have a problem?</span><br><span class="line">cond2&#x3D;&gt;condition: Can you solve it?</span><br><span class="line">op&#x3D;&gt;operation: Since you can&#39;t solve it,</span><br><span class="line"></span><br><span class="line">st-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;cond2</span><br><span class="line">cond1(no)-&gt;e</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no)-&gt;op-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-3" class="flow-chart"></div><hr><p><strong>示例说明-5:</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start|past:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">e&#x3D;&gt;end: End:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">op1&#x3D;&gt;operation: My Operation|past</span><br><span class="line">op2&#x3D;&gt;operation: Stuff|current</span><br><span class="line">sub1&#x3D;&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?|approved:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">c2&#x3D;&gt;condition: Good idea|rejected</span><br><span class="line">io&#x3D;&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-4" class="flow-chart"></div><hr><p>参考资料:</p><p>参考资料:<a href="http://flowchart.js.org/" target="_blank" rel="noopener">跳转</a><br><code>http://flowchart.js.org/</code></p><p>获取方式:<br><code>npm install --save hexo-filter-flowchart</code></p><p>配置方式：<br>安装完成后进入根目录修改配置文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flowchart: </span><br><span class="line">#raphael:#optional, the source url of raphael.js </span><br><span class="line">#flowchart:#optional, the source url of flowchart.js</span><br><span class="line">options:#options used for &#96;drawSVG&#96;</span><br></pre></td></tr></table></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">st=>start: 开始框
op=>operation: 处理框
cond=>condition: 判断框(是或否?)
sub1=>subroutine: 子流程
io=>inputoutput: 输入输出框
e=>end: 结束框

st->op->cond
cond(yes)->io->e
cond(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script><textarea id="flowchart-1-code" style="display:none">st=>start: 开始框
op=>operation: 处理框
cond=>condition: 判断框(是或否?)
sub1=>subroutine: 子流程
io=>inputoutput: 输入输出框
e=>end: 结束框

st(right)->op(right)->cond
cond(yes)->io(bottom)->e
cond(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-1-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-1",options)</script><textarea id="flowchart-2-code" style="display:none">st=>start: 开始语句
in=>inputoutput: 输入值
e=>end: 结束语句
op=>operation: 执行操作
cond=>condition: 是否成立？
out=>inputoutput: 输出值

st->in->op->cond
cond(yes)->out
cond(no)->op
out->e</textarea><textarea id="flowchart-2-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-2-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-2",options)</script><textarea id="flowchart-3-code" style="display:none">st=>start: Start
e=>end: Why are you worried?
cond1=>condition: Do you have a problem?
cond2=>condition: Can you solve it?
op=>operation: Since you can't solve it,

st->cond1
cond1(yes)->cond2
cond1(no)->e
cond2(yes)->e
cond2(no)->op->e</textarea><textarea id="flowchart-3-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-3-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-3",options)</script><textarea id="flowchart-4-code" style="display:none">st=>start: Start|past:>http://www.baidu.com
e=>end: End:>http://www.baidu.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes or No?|approved:>http://www.baidu.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-4-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-4-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-4",options)</script><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式版本控制系统-Git-2</title>
    <url>/2020/02/04/Git-3/</url>
    <content><![CDATA[<!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第二章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第二章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第二章节"></a>分布式版本控制系统(Distributed Version Control) Git-第二章节</h3><p><strong>基本操作</strong></p><ul><li>上篇文章的末尾写了一点关于git创建新仓库和克隆项目的基本操作</li><li>这一章着重对暂存区内快照的管理与操作和分支的管理与操作进行说明</li><li>在<code>git init</code>后，在工作区的根目录会生成<code>.git</code>子目录，它就是本地主机的Git仓库，所有关于工作区项目的快照数据都存放在此目录下</li><li>Git主要工作就是创建和保存工作区中项目的快照及与其他时间段的快照进行对比</li></ul><ol><li><p><code>git add</code><br>用于将工作区修改或进行操作的任何文件添加到缓存目录，也就是暂存区<br><code>git add .</code><br>添加当前项目的所有文件</p></li><li><p><code>git status</code><br>用于查看工作区当前的状态，执行完<code>git status</code>就能看到工作区向暂存区进行的任何操作<br>可以添加参数，比如添加<code>-s参数</code>，以输出经过简化的结果<br><code>A/M filename</code>的意思是这个文件在添加到暂存区之后又有改动了</p></li><li><p><code>git diff</code><br>用以查看执行git status 输出结果的详细信息<br>参数信息</p></li></ol><ul><li><code>git diff</code>命令会输出暂存区以修改但尚未写入暂存区的改动的区别</li><li><code>git diff</code>尚未写入暂存区的改动</li><li><code>git diff --cached</code>查看已写如暂存区的改动</li><li><code>git diff HEAD</code>查看已写入暂存区的与未写入暂存区的所有改动</li><li><code>git diff --stat</code>输出简明的diff结果</li></ul><ol start="4"><li><p><code>git commit</code><br>将暂存区的内容添加到仓库中<br>因为每一次提交都要输入一次github的用户名和邮箱地址，所以可以先配置一下用户名和邮箱地址</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#39;用户名&#39;</span><br><span class="line">git config --global user.email 邮箱地址</span><br></pre></td></tr></table></figure><p><code>参数-m</code>在命令行中提供提交注释，如果没有此参数，Git就会自动打开一个编辑器以填写提交信息<br><code>参数-a</code>可以跳过<code>git add</code>提交至暂存区</p></li><li><p><code>git reset HEAD filename</code><br><code>filename</code>是指已提交到暂存区的内容<br>用于取消已缓存的内容<br>执行<code>git reset HEAD</code>以取消之前的<code>git add</code>，并且不包含下一个提交完成后的暂存区快照</p></li><li><p><code>git rm</code><br>从工作区删除某个文件，需要从已跟踪文件的清单中移除，然后再去提交<br><code>git rm filename</code><br>如果该文件修改过并且已经提交到暂存区而还要删除的话，必须使用强制删除<code>参数-f</code><br><code>git rm -f filename</code><br>把文件从暂存区删除，或者说是从跟踪清单中删除，使用<code>--cached</code>参数<br><code>git rm --cached filename</code><br>使用<code>-r</code>参数用以递归删除，删除该目录下的所有文件和子目录<br><code>git rm -r</code>文件目录</p></li><li><p><code>git mv</code><br>用于移动或重命名一个文件夹，目录或软链接<br><code>git mv filename newfilename</code></p></li><li><p><code>git push</code><br>用于将本地工作区的最新消息推送到远端仓库</p></li><li><p><code>git pull</code><br>用于从远端仓库拉取最新的版本到本地工作区，并且自动与工作区内部的项目与数据自动合并(merge)</p></li><li><p><code>git fetch</code><br>用于是从远端仓库拉取最新版本到本地工作区，并且不会自动合并</p></li><li><p><code>git merge</code><br>用于从指定的分支合并到当前的分支，从而合并两个分支<br><code>git pull</code>相当于<code>git fetch + git merge</code></p></li></ol><hr><p><strong>Git查看提交日志</strong><br>12. <code>git log</code></p><ul><li><code>参数--oneline</code>查看简明版本</li><li><code>参数--graph</code>查看分支，合并等操作的日志，并显示拓扑图</li><li><code>参数--reverse</code>逆向输入所有日志</li><li><code>参数--author=用户名</code>查看指定用户的提交日志</li><li><code>参数--since，--before，--after，--until</code>查看指定日期<br>日志命令参考<a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/docs/git-log</code></li></ul><ol start="13"><li>git 标签<br><code>git tag -a 标签名</code><br>用于给当前快照打上标签</li></ol><hr><p><strong>使用Git连接远端的Github仓库</strong></p><p>添加一个新的远程仓库<br>14. <code>git remote add shortname url</code></p><p>查看当前的远程库<br>15. <code>git remote</code></p><p>拉取远程库<br>从远程仓库克隆新分支与数据<br>16. <code>git fetch alias</code><br>然后执行git merge 将远程分支到本地工作区所在的分支<br>17. <code>git merge alias/branch</code><br>从远端仓库提取更新数据并尝试合并到当前分支<br>一般执行完<code>git fetch</code>之后就会紧接着执行<code>git merge</code>，前者去对数据进行过滤，获取当前工作区没有的新数据，后者用于将新数据合并到本地工作区当前分支的项目</p><p>推送到远程仓库<br>18. <code>git push alias branch</code><br>将本地(branch)分支中的暂存区文件推到(alias)远端仓库上的(branch)分支<br>用于将本地暂存区的新数据推到某个远端仓库</p><p>删除远端仓库<br>19. <code>git remote rm [别名]</code></p><p><strong>生成ssh key</strong><br>20. * <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><ul><li>会在<code>/root/.ssh</code>目录生成密匙文件，打开<code>id_rsa.pub</code>，复制里面的key</li><li>然后进入Github并登入Github，点击头像内的<code>setting</code>选项卡内的<code>SSH and GPG keys</code>中的<code>SSH Keys</code>选项卡</li><li>将文件里的key拷贝到key中，title随意，然后<code>add ssh key</code></li><li>验证是否成功<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi Unit-serow! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>具体可以参考一下<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="noopener">跳转</a><br><code>https://help.github.com/articles/generating-ssh-keys</code></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>2.应用与拓展</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式版本控制系统-Git-1</title>
    <url>/2020/02/04/Git-2/</url>
    <content><![CDATA[<!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第一章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第一章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第一章节"></a>分布式版本控制系统(Distributed Version Control) Git-第一章节</h3><p><strong>概述:</strong></p><ul><li>Git 是一个开源的分布式版本控制系统，用于帮助以群为单位的开发者们处理任何相同类型的项目(或称为同一项目)</li><li>Git 还可以指 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</li><li>Git 的性质使他不仅用于版本控制，还可用于内容管理 CMS 与工作管理等</li></ul><p><strong>关于 Git 的分布式</strong></p><ul><li>Git把内容按元数据的方式去存储，分布式的版本控制就是每个人都可以创建一个独立的代码仓库用于管理，各种版本的操作都可以再本地完成，每个人修改的代码都可以经过推送合并到另外一个代码仓库中，所以Git这种分布式的版本控制系统更适合个人的开发</li><li>因为分散式版本控制系统本质的关系，使得此类系统更重视对分支(branch)的支持，它们通常有较好的分支及合并的能力</li><li>在分散式版本控制系统中，开发者可以进行推(push)的动作，其意义是将自身档案库中的变更送至其他的档案库，也可以进行拉(pull)的动作，其意义是获取其他档案库的变更</li><li>处于分布式版本控制系统中的每个个体之间的关系是完全独立且自由的，他们完全自由并且完全可以参照自己的意愿来对远端的代码仓库进行实时的操作</li><li>学习Git时最重要的是对其分支管理系统的了解，这是它的本质与执行的逻辑核心</li></ul><p><strong>使用Git进行工作的通常流程</strong></p><ul><li>从远端仓库克隆代码到本地并作为工作目录</li><li>对克隆的资源进行操作</li><li>如果有人已经对其修改了，可以在本地更新资源</li><li>在提交前查看修改内容并提交修改内容</li><li>在修改完成后，如果发现错误，可以撤回并再次修改并提交</li></ul><hr><p><strong>最基本的使用</strong></p><p><code>git init</code><br>使用git init 创建或初始化一个仓库，通常是使用git的第一个命令<br>在执行完成git init命令后，git仓库会生成一个.git目录，该目录包含了所有资源的元数据，而其它项目的目录保持不变</p><p><code>git clone</code><br>从指定以存在的Git远端仓库中克隆项目<br><code>git clone repo(Git 仓库名)</code><br>还可以指定克隆的目录<br><code>git clone repo directory(本地目录)</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客文件远端备份与恢复</title>
    <url>/2020/02/03/hexo%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 19:05:26 GMT+0800 (中国标准时间) --><h3 id="hexo博客文件远端备份与恢复"><a href="#hexo博客文件远端备份与恢复" class="headerlink" title="hexo博客文件远端备份与恢复"></a>hexo博客文件远端备份与恢复</h3><ul><li>其实就是将本地工作区的数据上传到远端仓库</li><li>因为再创建一个代码仓库有点浪费，所以用再原仓库内建立新分支的方法去备份博客</li><li>在创建新分支之前先确保博客内有默认主分支master</li></ul><p><strong>按顺序执行以下指令:</strong></p><ul><li><code>git init //创建一个新的Git仓库或初始化一个现有的仓库</code><br>该命令创建一个空的Git版本库和暂存区，基本上具有对象库，指针(HEAD)库和模板文件等等的隐藏目录.git<br>现有存储库中运行git init命令是安全的，所以不会覆盖已经存在的数据</li><li><code>git add .</code><br>将本地文件依次添加到暂存区</li><li><code>git commit -m &#39;hexo&#39;(需要进行备份的文件名，比如说hexo的根目录)</code><br>将文件数据提交至本地暂存区文件内，然后再将暂存区的改动提交到本地的版本库</li><li><code>git branch hexo</code><br>创建一个名为hexo的新分支</li><li><code>git checkout hexo</code><br>切换到hexo分支上</li><li><code>git remote add origin Github仓库地址</code><br>让仓库地址/URL实现本地与远程Github仓库的对接</li><li><code>git push origin hexo(推送文件目录)</code><br>推送本地工作区(仓库)内容到远程仓库的hexo分支，远程仓库的默认命名是origin</li></ul><p>创建新的仓库时会默认建立.gitignore文件，用于将不需要备份的文件屏蔽</p><p>以后备份的时候只需要</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Backname&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g与hexo d</span><br></pre></td></tr></table></figure><hr><p><strong>恢复博客</strong></p><p>在本地机器上克隆博客文件的hexo分支<br><code>git clone https://github.com/yourgithubname/yourgithubname.github.io</code></p><p>分别执行以恢复博客</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><hr><p><strong>其他指令</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;分支名称 &#x2F;&#x2F;在所选仓库内设置默认分支</span><br><span class="line">git remote &#x2F;&#x2F;查看所有远程仓库</span><br><span class="line">gir remote rm origin &#x2F;&#x2F;删除所关联的远程仓库地址</span><br><span class="line">git remote add origin 新仓库地址 &#x2F;&#x2F;添加新仓库地址</span><br><span class="line">git push orign master &#x2F;&#x2F;提交到新仓库中的默认分支</span><br><span class="line">git submodule init &#x2F;&#x2F;初始化本地配置文件</span><br><span class="line">git submodule update &#x2F;&#x2F;抓取所有数据并检出项目中列出的合适的提交</span><br><span class="line">git rm --cached file &#x2F;&#x2F;从暂存区删除文件，工作区不做出改变</span><br><span class="line">git checkout . &#x2F;&#x2F;重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件</span><br><span class="line">git pull 参数[options]  仓库名[repository]  分支名[refspec...] &#x2F;&#x2F;从一个仓库或者本地的分支拉取并合并代码，相当于 git fetch 跟着一个 git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制系统 Git-分支</title>
    <url>/2020/02/03/Git-1/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 18:58:36 GMT+0800 (中国标准时间) --><h2 id="Git-版本控制系统"><a href="#Git-版本控制系统" class="headerlink" title="Git 版本控制系统"></a>Git 版本控制系统</h2><h3 id="远端分支的上传与本地分支的处理的执行逻辑与原理"><a href="#远端分支的上传与本地分支的处理的执行逻辑与原理" class="headerlink" title="远端分支的上传与本地分支的处理的执行逻辑与原理"></a>远端分支的上传与本地分支的处理的执行逻辑与原理</h3><p><strong>远端分支</strong></p><ul><li>在本地进行任何连接Git远端服务器或远端服务器分支的操作时，远端服务器内会创建一个默认分支，之后在本地会生成一个对应该默认分支的分支</li><li>下文描述说明:服务器的分支被称为<code>origin/master</code>，而本地的分支被称为<code>master</code></li></ul><p><strong>执行原理:</strong></p><ul><li>在本地执行<code>git clone</code>命令克隆远端数据之后，git的clone会自动将所连接远端服务器命名为origin(执行该命令就是克隆URL所指定服务器内的所有数据)</li><li>同时在远端origin服务器内创建了指向它默认主分支(master)的指针，并在远端的服务器内为分支命名为<code>origin/master</code>(默认仓库名与此仓库内的默认分支名)</li><li>然后远端的git服务器也会给本地主机添加本地的master指针，该指针与远端服务器origin的master分支指向同的目标</li><li>从而从本地就可以操作远程服务器origin的分支了(origin的任何分支-这里指master分支)，进而实现数据推送</li></ul><p><strong>逻辑关系的链接表示:</strong></p><blockquote><p>-表示线性执行的逻辑关系<br>本地主机-远程仓库-远程仓库内的若干个分支(分支也可以拥有分支)<br>默认远程仓库被命名为origin，而其下默认分支被默认命名为master<br>一般情况下，远程仓库内拥有最少一个默认分支，并将其默认定义为主分支，对主分支的定义可以进行改动</p></blockquote><hr><p><strong>本地分支</strong></p><p><strong>工作区，暂存区与版本库的概念与其中的关系介绍:</strong></p><ul><li>工作区就是本地主机的文件文件目录</li><li>暂存区(stage或index)，一般存放在隐藏目录.git下的<code>index</code>文件中,暂存区也可以被叫做索引(index)</li><li>版本库 工作区内的隐藏目录<code>.git</code>就被称之为版本库，其中包含了暂存区文件，对象库，游标(HEAD)文件与本地分支等等</li><li>正常情况下的操作都是由工作区发出命令然后传于版本库内进行各级执行</li></ul><p><strong>逻辑关系表示:</strong></p><blockquote><p>工作区-[版本库-(暂存区-本地分支/对象库)]-远端服务器<br>这里的-用于表示包含，链接与单向执行逻辑</p></blockquote><p><strong>逻辑关系:</strong></p><ul><li>当工作区内修改或新增文件之后执行git add 命令之后，暂存区的目录会被更新</li><li>同时工作区修改或新增文件的内容也被写入对象库中的一个新的对象库中，而该对象的ID也被记录在暂存区的文件索引中</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库中的对象库中</li><li>之后默认分支master或设置的本地分支经由游标(HEAD)的指向会对所选分支作出相应的更新</li><li>默认分支master或设置的本地分支指向的目录树就是提交至远端时暂存区的目录树</li><li>进而推送暂存区的目录树(也就是本地存储于所选分支内暂存区的所有数据)至远端</li></ul><p><strong>命令原理与版本库内目录简要介绍:</strong></p><ul><li><p>执行<code>git reset HEAD(游标名)</code>命令时，更新暂存区操作，暂存区的目录会被重写，而被master分支的游标所指向的目录树所交换，工作区不受影响</p></li><li><p>执行<code>git rm --cached filename</code>命令时 ，从暂存区删除文件，而工作区不做出改变</p></li><li><p>执行<code>git checkout .</code>命令时重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件，会清除工作区中未添加到暂存区的改动</p></li><li><p>执行<code>git checkout HEAD .</code>或<code>git checkout HEAD filename</code>命令时，会用游标(HEAD)指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件，不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动</p></li><li><p>执行<code>git fetch origin</code>命令用于同步数据，原理就是从中抓取本地没有的数据并且更新本地数据，同时游标(HEAD)也会更新</p></li><li><p>对象库位于<code>.git/objects</code>目录下，里面包含了创建的各种对象及内容</p></li><li><p>暂存库位于<code>.git/index</code>目录下</p></li><li><p>游标位于<code>.git/HEAD</code>目录下</p></li></ul><p>本文所描述的游标，也可以称之为指针，用指针去理解会更简单</p><h2 id="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"><a href="#论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考" class="headerlink" title="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"></a>论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考</h2><p>参考文案:</p><p>Git官网:<a href="https://git-scm.com/" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/</code></p><p>CN-Git 分支简介:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B</code></p><p>CN-Git 分支使用:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Binary File Descriptor/BFD</title>
    <url>/2020/02/02/BFD/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Binary-File-Descriptor"><a href="#GNU-Binary-File-Descriptor" class="headerlink" title="GNU Binary File Descriptor"></a>GNU Binary File Descriptor</h3><p><strong>GNU 二进制文件描述 BFD</strong></p><p><strong>概述:</strong></p><ul><li>目的是用于解决GNU项目中不同的目标文件的可移植性的主要机制</li><li>在GNU项目中对于不同目标文件可移植EFL<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>性问题的主要解决机制</li><li>BFD库还可以用来读取核心转储的结构化数据</li><li>截至至2003年，它支持25中不同体系结构的CPU上的大约50中文件格式</li></ul><p><strong>BFD的设计逻辑与执行逻辑:</strong></p><ul><li>BFD通过对目标文件<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>提供抽象视图来达成工作</li><li>BFD在内部将数据从抽象视图转到目标处理器所规定的文件格式所要求的节与数据结构/字节布局等细节</li><li>它关键的作用是处理字节序的差异<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>,包括寻址<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>算术等细节</li><li>BFD最初的设计目的是可以成为被各种工具所使用的通用库，但为了达成这一目的就需要频繁修补API来解决系统所带来的影响与容纳新系统的功能，从而限制了它的使用模式与功能</li><li>DFD的主要用户是<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GAS</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GDL</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GNU Binutils</a>和<a href="https://unit-serow.github.io/2020/02/01/Debugger/">GDB</a>，因此BFD不单独发行，所以它通常包括在Binutils和GDB的发行之中</li></ul><hr><p><strong>参考资料:</strong></p><p>参考网站-BFD的历史与故事<a href="https://www.oreilly.com/openbook/opensources/book/tiemans.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.oreilly.com/openbook/opensources/book/tiemans.html</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">ELF-可执行与可链接格式，Executable and Linkable Format简称为ELF ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">目标文件的结构:有一个有描述信息的“头”，可变量目的“段”，每个段都有一个名字，一些属性和一块数据，一个符号表，一组重定位入口顶等等</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display:inline-block;vertical-align:top;padding-right:10px">3.</span><span style="display:inline-block;vertical-align:top">比如在小端序主机和大端序目标之间，在32-bit和64-bit数据之间的正确转换和重定位入口项所指定的寻址算术的细节</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display:inline-block;vertical-align:top;padding-right:10px">4.</span><span style="display:inline-block;vertical-align:top">寻址是每种计算机中央处理器的指令集架构中的一部分，各个指令集下有不同的寻址模式，寻址模式决定了此架构下计算机语言指令所对应的运算数</span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU AutoGen</title>
    <url>/2020/02/02/AutoGen/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-AutoGen"><a href="#GNU-AutoGen" class="headerlink" title="GNU AutoGen"></a>GNU AutoGen</h3><p><strong>GNU 代码维护工具</strong></p><p><strong>概述:</strong></p><ul><li>AutoGen用于简化包含大量重复文本，指令集与宏定义的程序的创建和维护，所以在必须完全保持多个文本块同步的程序中，它能发挥很大的作用</li><li>除了CGL数据与已有的AutoGen定义之外，AutoGen还可以自定义格式或将XML文件作为输入定义</li><li>它经常被用于创建和维护处理程序选项所需的代码，处理选项需要在程序之间的不同位置同时维护多个构造，所以对于选件的维护是没有尽头的</li><li>因此，autogen带有一个名为autoopts的附加软件包，它用于简化程序选项的维护和文档编制</li><li>已知autogen可在GNU/Linux，BSD，OS/X，等其他操作系统上工作</li><li>它的最终目的是在任何具有ANSI C编译器的现代UNIX系统上运行</li></ul><hr><p><strong>参考资料:</strong></p><p>源码获取:<a href="http://autogen.sourceforge.net/data/" target="_blank" rel="noopener">跳转</a><br><code>http://autogen.sourceforge.net/data/</code></p><p>手册<a href="https://www.gnu.org/software/autogen/manual/html_node/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/manual/html_node/autogen.html</code></p><p>快捷参考<a href="https://www.gnu.org/software/autogen/man1-autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/man1-autogen.html</code></p><p>autogen官网<a href="https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html</code></p><p>开发者社区<a href="http://savannah.gnu.org/projects/autogen" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/projects/autogen</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Data Display Debugger</title>
    <url>/2020/02/02/DDD/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Data-Display-Debugger"><a href="#GNU-Data-Display-Debugger" class="headerlink" title="GNU Data Display Debugger"></a>GNU Data Display Debugger</h3><p><strong>GNU 调试器前端 DDD</strong></p><p><strong>概述:</strong></p><p>DDD:</p><ul><li>DDD基于GPL许可证发行</li><li>DDD是GNU计划的一个重要的组成部分</li><li>DDD主要用于Unix系统,并且有许多开源插件对其使用性的补充</li><li>GNU DDD是一个用于数据显示的调试器前端(Debugger front-end)，它使用motif工具包实现GUI</li><li>应用于诸如GDB,DBX,JDB,XDB,多种语言调试器和bash等命令行调试器的调试器前端，也包括GNU Make调试器等用于调试器的调试器前端</li><li>DDD拥有GUI前端的功能，可以查看源文本及其交互式图形数据的显示，将数据结构以图形化显示</li></ul><p>GCL:</p><ul><li>调试器前端就是所指调试器所使用的命令行解释器/命令行界面(CLI)，这里所指的调试器前端就是DDD</li><li>一个好的CLI可以最大程度的提高可移植性并最大程度地减少资源消耗</li><li>而最让开发者们青睐的还得是具备GUI的CLI，所以有一些GUI调试器的前端被设计成与各种GLI相兼容，还有一些GUI则针对某一个特定的GLI</li></ul><hr><p><strong>参考资料:</strong></p><p>文档<a href="https://www.gnu.org/software/ddd/manual/html_mono/ddd.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/manual/html_mono/ddd.html</code></p><p>官网<a href="https://www.gnu.org/software/ddd/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/</code></p><p>社区<a href="http://savannah.gnu.org/svn/?group=ddd" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/svn/?group=ddd</code></p><p><a href="https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html" target="_blank" rel="noopener">参考资料:</a><br><code>https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Common Lisp</title>
    <url>/2020/02/02/GCL/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Common-Lisp"><a href="#GNU-Common-Lisp" class="headerlink" title="GNU Common Lisp"></a>GNU Common Lisp</h3><p><strong>GNU Common Lisp编译器 GCL</strong></p><p><strong>概述:</strong></p><ul><li>不要与GNU CLISP和Common Lisp的概念混淆</li><li>GNU Common Lisp（GCL）是GNU计划中ANSI Common Lisp的编译器</li><li>它是Kyoto Common Lisp的演化版</li><li>它的执行过程通常是先生成C代码然后调用C的编译器来生成本机的目标代码</li><li>GCL是包括数学工具maxima，AXIOM,HOL88和ACL2在内的几个大型项目的首选实现</li><li>GCL可以在Linux或FreeBSD，microsoft windows等11种不同体系架构的系统下运行</li></ul><hr><p><strong>参考资料:</strong></p><p>FSF的GCL社区<a href="https://directory.fsf.org/wiki/Gcl" target="_blank" rel="noopener">跳转</a><br><code>https://directory.fsf.org/wiki/Gcl</code></p><p>官网社区<a href="https://www.gnu.org/software/gcl/gcl.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gcl/gcl.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU CLISP</title>
    <url>/2020/02/02/CLISP/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-ANSI-Common-Lisp"><a href="#GNU-ANSI-Common-Lisp" class="headerlink" title="GNU ANSI Common Lisp"></a>GNU ANSI Common Lisp</h3><p><strong>概述:</strong></p><p>摘要:</p><blockquote><p>用于实现 ANSI Common Lisp <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>中所描述的语言标准，并且拥有许多拓展<br>CLISP于大多数GNU与Unix系统上运行，还包括windows NT,ME等等，只需要4MB的RAM<br>common lisp是一种面向对象的通用高级编程语言<br>common lisp算是lisp语言的一种方言吧</p></blockquote><p>参考文献:<br>ANSI Common Lisp 中文翻译版<a href="https://acl.readthedocs.io/en/latest/" target="_blank" rel="noopener">跳转</a><br><code>https://acl.readthedocs.io/en/latest/</code></p><p>电子书版本<a href="https://web.archive.org/web/20020805060924/http://www.lisp.org/HyperSpec/FrontMatter/index.html" target="_blank" rel="noopener">跳转</a><br><code>https://web.archive.org/web/20020805060924/http://www.lisp.org/HyperSpec/FrontMatter/index.html</code></p><p>官方网站<a href="https://clisp.sourceforge.io/summary.html" target="_blank" rel="noopener">跳转</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;clisp.sourceforge.io&#x2F;summary.html</span><br><span class="line">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;clisp&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;clisp.sourceforge.io&#x2F;</span><br></pre></td></tr></table></figure><p>参考手册<a href="https://clisp.sourceforge.io/impnotes/clisp.html" target="_blank" rel="noopener">跳转</a><br><code>https://clisp.sourceforge.io/impnotes/clisp.html</code></p><p>获取:<br><a href="http/SF">跳转</a>/<a href="http://ftp.gnu.org/pub/gnu/clisp/" target="_blank" rel="noopener">跳转</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http&#x2F;SF</span><br><span class="line">http:&#x2F;&#x2F;ftp.gnu.org&#x2F;pub&#x2F;gnu&#x2F;clisp&#x2F;</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">基于ANSI标准的common lisp语言的实现(编译器、调试器和解释器) ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Gettext</title>
    <url>/2020/02/02/Gettext/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Gettext-第一章节"><a href="#GNU-Gettext-第一章节" class="headerlink" title="GNU Gettext 第一章节"></a>GNU Gettext 第一章节</h3><p><strong>GNU 国际化(i18n)库</strong></p><p><strong>概述:</strong></p><ul><li>国际化与本地化函数库</li><li>GNU gettext是GNU translation project中最重要的一步</li><li>GNU通用性翻译计划</li><li>这个项目的达成将会让GNU拥有更大的经济与用户结构，从而拥有更多的资本</li></ul><p><strong>引用自官方文档:</strong></p><blockquote><p>在以前，通常GNU内部或大量其它的自由软件中的程序源代码都是拿英文编写或记录的，并且在与用户交互的界面所使用的也是英语<br>当世界上所有的开发人员之间使用一种通用的语言去交流会让开发的过程变得极为方便<br>但是，在全世界范围内的大多数人对于英文的理解能力和学习深度远不如母语，所以它们更愿意使用母语进行日常工作<br>并且大多数人只是希望让屏幕上其它晦涩难懂的语言少一点，而自己的母语多一点<br>所以就有了GNU Gettext<br>该软件包为程序员，翻译人员与用户提供了一套完善的工具和文档集<br>更准确的说，gnu gettext所使用的程序是一组工具，提供了一个框架来帮助其他GNU软件包生成多语言的消息</p></blockquote><p><strong>这个工具包括了以下的一组程序:</strong></p><ul><li>一套如何编写程序，从而让消息目录支持的规则</li><li>一套如何为目录本身和文件命名的规则</li><li>一个运行时库，用于支持检索翻译后的消息</li><li>一些独立程序，以各种方式处理可翻译的字符串或已翻译字符串的集合</li></ul><p>GNU Emacs拥有实现这套程序的插件或拓展，感兴趣的可以去查询有关GNU Emacs的消息</p><hr><p>逻辑简述:<br>以下内容参考自:<a href="https://www.gnu.org/software/gettext/manual/html_node/Program-Index.html#Program-Index" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/manual/html_node/Program-Index.html#Program-Index</code></p><ul><li>xgettext程序从源代码生成.pot文件，作为源代码中序翻译内容的模板</li><li>而翻译者需要工作的对象是.po文件，它是有msginit程序从.pot模板文件生成的</li><li>翻译者用maginit初始化中文翻译文件时可以执行<code>msginit --locale=cn --input=name.pot</code></li><li>然后编辑所生成的.po文件</li><li>最后.po文件需要使用msgfmt编译为.mo文件以用作发布</li><li>使其运行需要使用UNIX操作系统中的用户需要修改环境变量中的<code>LC_MESSAGES</code>或<code>LANG</code>，程序将自动从相应的.mo文件中读取语言信息</li></ul><p>使用方法:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在使用gettext()方法的时候通常以标记别名_的形式使用</span><br><span class="line">如printf(gettext(&quot;name is %s. \n&quot;), first_name);</span><br><span class="line">可以写作printf(_(&quot;name is %s.\n&quot;), first_name);</span><br></pre></td></tr></table></figure><hr><p>参考资料:<br>官方网站<a href="https://www.gnu.org/software/gettext/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/</code><br>获取<a href="https://ftp.gnu.org/pub/gnu/gettext/gettext-0.20.1.tar.gz" target="_blank" rel="noopener">跳转</a><br><code>https://ftp.gnu.org/pub/gnu/gettext/gettext-0.20.1.tar.gz</code><br>社区<a href="https://savannah.gnu.org/projects/gettext/" target="_blank" rel="noopener">跳转</a><br><code>https://savannah.gnu.org/projects/gettext/</code><br>文档<a href="https://www.gnu.org/software/gettext/manual/gettext.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/manual/gettext.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Portable Threads/Pth</title>
    <url>/2020/02/02/Pth/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Portable-Threads-第一章节"><a href="#GNU-Portable-Threads-第一章节" class="headerlink" title="GNU Portable Threads 第一章节"></a>GNU Portable Threads 第一章节</h3><p><strong>GNU 可移植线程库 Pth</strong></p><p><strong>概述:</strong></p><ul><li>GNU计划重要的一部分</li><li>GNU Pth 是用于UNIX平台下基于POSIX与ANSI C的用户空间线程库</li><li>GNU Pth还包含了POSIX线程的API，以达成向后兼容的目的</li></ul><p>GNU Pth使用到内核空间线程的N:1映射，所以说调度完全将完全由GNU Pth库进行<br>内核将不会干涉用户空间中任何数量的线程，所以利用不到SMP<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所拥有的机制，因为SMP必须由内核派遣</p><p><strong>存在目的:</strong></p><ul><li>GNU Pth的目的是针对任意线程的处理达到高度的可移植性</li><li>其次是为了让多线程应用提供基于优先级的调度</li></ul><hr><p><strong>参考资料:</strong></p><p>官方网站<a href="https://www.gnu.org/software/pth/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth</code></p><p>官方手册<a href="https://www.gnu.org/software/pth/pth-manual.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth/pth-manual.html</code></p><p>多线程库列表<a href="https://www.gnu.org/software/pth/related.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth/related.html</code></p><p><a href="https://www.gnu.org/software/pth/related.html" target="_blank" rel="noopener">多线程库文档，包含了Unix系统中所有对于已知多线程库的调用</a><br><code>https://www.gnu.org/software/pth/related.html</code></p><p>关于OSSP pth<a href="http://www.ossp.org/pkg/lib/pth/" target="_blank" rel="noopener">跳转</a><br><code>http://www.ossp.org/pkg/lib/pth</code></p><p>论文引用:<br><a href="http://heather.cs.ucdavis.edu/~matloff/pth.html" target="_blank" rel="noopener">对于GNU pth的使用与描述</a><br><code>http://heather.cs.ucdavis.edu/~matloff/pth.html</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">均衡多处理架构</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU C libary/Libc</title>
    <url>/2020/02/02/Libc/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-C-Library-第一章节"><a href="#GNU-C-Library-第一章节" class="headerlink" title="GNU C Library 第一章节"></a>GNU C Library 第一章节</h3><p><strong>C 标准函数库 Libc</strong></p><p><strong>概述:</strong></p><ul><li>GNU/Linux操作系统一个重要的组成部分</li><li>FSF为GNU所写，作用是配合linux内核,是Linux下基于ANSI C<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>标准的GNU C<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>标准函数库</li></ul><p><strong>存在目的:</strong></p><ul><li>目的是为linux内核的操作系统提供核心库文件，库提供了关键的API，当然也包括Linux内核的API</li><li>虽说称为C的标准函数库，但还支持很多其他的程序语言</li></ul><hr><p><strong>其它C 标准库</strong></p><p>C POSIX library</p><ul><li>C 可移植标准接口库</li><li>包含了一些在C 标准库之外的函数，这里指ANSI所定制的C 标准库</li></ul><p>CRT/C Run-time Library</p><ul><li>C 运行时期库</li><li>C 程序运行时需要这些库中的函数</li><li>包含于程序运行时使用到的一些API集合，这里的API是预先编译后存放在linux系统中的二进制代码形式的文件</li><li>CRT通常作为C编译程序发布</li><li>CRT含有初始化代码，还有错误处理代码(例如divide by zero处理)</li></ul><hr><p><strong>其它资料:</strong><br>ANSI C库可以根据头文件划分为15个类别<br>其中包括:</p><ul><li>字符类型 ()</li><li>错误码()</li><li>浮点常数 ()</li><li>数学常数 ()</li><li>标准定义 ()</li><li>标准 I/O ()</li><li>工具函数 ()</li><li>字符串操作 ()</li><li>时间和日期 ()</li><li>可变参数表 ()</li><li>信号 ()</li><li>非局部跳转 ()</li><li>本地信息 ()</li><li>程序断言 () 等等</li><li>这在其他的C语言的IDE中都是有的</li></ul><h2 id="以上内容引用自百度百科条目"><a href="#以上内容引用自百度百科条目" class="headerlink" title="以上内容引用自百度百科条目"></a>以上内容引用自百度百科<a href="https://baike.baidu.com/item/libc" target="_blank" rel="noopener">条目</a></h2><p>参考资料:</p><p>GNU C Library连接<a href="https://www.gnu.org/software/libc/involved.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libc/involved.html</code></p><p>C POSIX库参考文献<a href="https://web.archive.org/web/20100724201155/http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/funcref.htm" target="_blank" rel="noopener">跳转</a><br><code>https://web.archive.org/web/20100724201155/http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/funcref.htm</code></p><p>C 标准函式库<a href="https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html" target="_blank" rel="noopener">跳转</a><br><code>https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html</code></p><p>C POSIX library-wiki<a href="https://zh.wikipedia.org/wiki/C_POSIX_library" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/C_POSIX_library</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">由美国国家标准局所制定的C语言发布标准-是最基本的C语言函数库，包含了C语言最基本的库函数并且是C语言最初的标准</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">由LGPL许可协议发布的，自由的，公开源代码并且方便下载的C编译程序</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Libtool</title>
    <url>/2020/02/01/Libtool/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-libtool-第一章节"><a href="#GNU-libtool-第一章节" class="headerlink" title="GNU libtool 第一章节"></a>GNU libtool 第一章节</h3><p><strong>GNU 构建系统</strong></p><p><strong>概述与解释:</strong></p><ul><li>GNU Libtool是一种属于<a href="https://unit-serow.github.io/2020/01/29/Autotools/">GNU构建系统</a>的GNU程序设计工具</li><li>GNU Libtool是一个用于支持通用库的脚本程序</li><li>用于解决在不同的操作系统中使用共享库进行代码移植的复杂性，在不同的系统中建立动态链接库，以隐藏不同系统之间的差异性</li><li>从而给开发人员提供一致的接口</li><li>但还是需要底层系统对所创建链接库的支持，所以libtool不能在不支持动态连接库的系统中创建动态链接库</li></ul><hr><p><strong>存在目的:</strong></p><ul><li>用于产生/建立便携式的库，它既可以建立动态链接库，也可以建立动态链接库，还可以包含两者</li><li>GNU libtool的目的是使每一个主机类型的完整功能都可以通过一个泛用接口来产生</li><li>GNU libtool的目标是使接口一致</li></ul><hr><p><strong>使用方法</strong><br>本章节不对应用进行过多阐述<br>libtool通常与GNU建构系统中的autoconf和automake这两个工具一起使用<br>需要参照系统手册（构建通用库所需要执行的命令）以及修改相应makefile的makefile.in或makefile.in文件<br>相关内容可查询<a href="https://www.gnu.org/software/libtool/manual/libtool.html" target="_blank" rel="noopener">libtool文档</a></p><hr><p>参考资料</p><p>GNU Libtool手册<a href="https://www.gnu.org/software/libtool/manual/libtool.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libtool/manual/libtool.html</code></p><p>使用GNU Libtoo创建库<a href="https://www.ibm.com/developerworks/cn/aix/library/1007_wuxh_libtool/index.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.ibm.com/developerworks/cn/aix/library/1007_wuxh_libtool/index.html</code></p><p>官方网站<a href="https://www.gnu.org/software/libtool/news.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libtool/news.html</code></p><p>autobook<a href="http://www.sourceware.org/autobook/" target="_blank" rel="noopener">跳转</a><br><code>http://www.sourceware.org/autobook/</code></p><p>获取:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http: http:&#x2F;&#x2F;ftpmirror.gnu.org&#x2F;libtool&#x2F;</span><br><span class="line">ftp: ftp:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;libtool&#x2F; </span><br><span class="line">克隆: git clone git:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;libtool.git</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Binutils</title>
    <url>/2020/02/01/Binutils/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Binutils-第一部分"><a href="#GNU-Binutils-第一部分" class="headerlink" title="GNU Binutils 第一部分"></a>GNU Binutils 第一部分</h3><p><strong>GNU 二进制工具包</strong></p><p><strong>工具包内包含程序</strong><br>主要包含ld与as，分别是GNU链接器-GAS与GNU汇编器-GLD</p><p><strong>其他程序</strong></p><ul><li>ar-用于建立，修改，提取归档文件(archive)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>/用于对归档/静态库做创建，修改和提取的操作</li><li>addr2line-将目标文件的虚拟地址转换为文件的行号或符号</li><li>c++filt-解码C++的符号</li><li>dlltool-用于构建与使用DLL文件，也就是创建windows动态库</li><li>gold-正在测试的功能，一个新型且效率更高的ELF的链接器</li><li>ELF是一种用于可执行文件，目标文件，共享库和核心转储的标准文件格式，可执行与可连接格式，ELF所产生的数据结构与工具不做阐述</li><li>gprof-用于显示性能的分析信息/性能分析工具</li><li>nlmconv-将目标代码转换为NetWare Loadable Module/NLM文件格式</li><li>nm-列出并显示目标文件中的符号</li><li>objcopy-复制并编译目标文件，其过程中可以修改</li><li>objdump-显示目标文件中的相关信息，可用于反汇编</li><li>ranlib-生成静态库索引</li><li>readelf-用于显示任何ELF格式文件的内容</li><li>size-列出对象总体或归档文件的节数/大小</li><li>strings-列出目标二进制文件中的可打印/可显示字符串</li><li>strip-从目标文件中移除符号</li><li>windmc-兼容windows消息的编译器，用于产生windows的消息资源</li><li>windres-windows资源文件的编译器</li></ul><hr><p><strong>杂项及存在意义</strong></p><ul><li>大部分的复杂代码都存于Binary File Descriptor library和libopcodes库内</li><li>所以它是一整套编程语言工具程序,用于处理许多格式的目标文件</li><li>这些程序大多数使用BFD-二进制文件描述库</li><li>主要的目的还是为GNU项目用于解决不同格式的目标文件的可移植性问题的主要机制</li></ul><hr><p><strong>参考:</strong></p><p>获取：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;binutils</span><br><span class="line">http:&#x2F;&#x2F;ftpmirror.gnu.org&#x2F;binutils</span><br><span class="line">apt-get install binutils*</span><br><span class="line">克隆：git clone git:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;binutils-gdb.git</span><br></pre></td></tr></table></figure><p>官网<a href="https://www.gnu.org/software/binutils/binutils.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/binutils/binutils.html</code></p><p>文档<a href="https://sourceware.org/binutils/docs-2.33.1/" target="_blank" rel="noopener">跳转</a><br><code>https://sourceware.org/binutils/docs-2.33.1/</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">archive是一个包含多个被包含文件的单一库文件,它可以保证从中检索到原始的被包含文件-mumber,而member用于保存archive的各种基本属性，当member被提取后，archive的属性将被还原到初始状态</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Make</title>
    <url>/2020/02/01/Make/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Make-第一部分"><a href="#GNU-Make-第一部分" class="headerlink" title="GNU Make 第一部分"></a>GNU Make 第一部分</h3><p><strong>GNU 自动化建构</strong></p><p><strong>概述:</strong></p><ul><li>在软件开发的过程中，make通常作为一个工具程序(unility software),经由makefile，从而实现自动化构建软件</li><li>在经由makefile时make工具会根据情况转换文件形式至target，转换的同时还会检查文件的依赖关系，检查依赖关系的方式本部分不做阐述</li><li>所以在编写软件时，应该先编写一个makefile，之后再让make去进行构建和安装</li></ul><p>或称为</p><ul><li><p>用于编译源代码，从而生成结果代码，然后将结果代码链接起来，最后生成可执行文件</p></li><li><p>其中名为makefile的文件用来确定某一target文件的以来关系，然后把生成target相关的命令转给机器的shell去执行</p></li><li><p>IDE通常包含了make，make多用于UNIX下的软件开发</p></li><li><p>本质如同UNIX底层的其他基本程序，批量执行生成目标的命令，同时检查文件的依赖关系</p></li></ul><hr><p>参考<br>官方网站<a href="https://www.gnu.org/software/make/make.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/make/make.html</code></p><p>获取<br><code>http: http://ftp.gnu.org/gnu/make/</code><br><code>ftp: ftp://ftp.gnu.org/gnu/make/</code></p><p>make手册<a href="https://www.gnu.org/software/make/manual/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/make/manual/</code></p><p>makefile手册<a href="https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions</code></p><p>make源码所在目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;make&#x2F;</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;doc&#x2F;make&#x2F;</span><br></pre></td></tr></table></figure><p>make帮助指令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make --help</span><br><span class="line">info make</span><br><span class="line">man make</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Compiler Collection</title>
    <url>/2020/02/01/GCC/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Compiler-Collection-第一部分"><a href="#GNU-Compiler-Collection-第一部分" class="headerlink" title="GNU Compiler Collection 第一部分"></a>GNU Compiler Collection 第一部分</h3><p><strong>GNU 编译器套装 GCC</strong></p><p><strong>概述:</strong></p><ul><li>它是GNU计划中关键的一环</li><li>基于GPL与LGPL软件许可,并且为free software-自由软件</li><li>UNIX-like，Linux，BSD类的操作系统都采用GCC为标准编译器</li><li>其他的C编译器LLVM,Clang</li><li>GCC通常是跨平台编译器的首选</li></ul><hr><p><strong>GCC的执行逻辑与过程</strong><br>GCC的作用是将源代码生成可执行文件大体需要四个步骤:</p><ul><li>预处理/预编译-preprocessing</li><li>编译-compilation</li><li>汇编-assembly</li><li>连接-linking</li></ul><p><strong>由下至上的处理过程</strong></p><ul><li>GCC先调用cpp进行预处理-预处理的作用是对源码文件中的文件包含-include,预编译语句-宏定义define等进行分析,预处理的主要功能大概分为三个:宏定义,文件包含,条件编译</li><li>然后调用cc1进行编译,这个阶段根据输入文件生成以.i为后缀的目标文件</li><li>然后调用as进行汇编工作,一般的汇编语言源码由.s为后缀,s为后缀的汇编语言文件经由编译器和汇编之后会生成.o后缀的目标文件</li><li>当所有目标文件都生成后,GCC就调用ld来完成最后阶段的工作-连接</li><li>在连接阶段,所有目标文件被自动生成并同时分配依赖条件/文件应该所处的位置</li><li>最后,该程序内所用的库函数也会被链接到所对应的位置</li></ul><hr><p><strong>GCC语言编译器的结构</strong><br>语言编译器的结构-由下至上/底层到顶层</p><ul><li>GCC内置了大量语言的编译器,每个语言的编译器都是独立的程序</li><li>编译器的作用是处理输入的源码,从而输出组合语言码</li><li>全部的语言编译器都有共同的中介架构</li><li>语言编译器的结构分为三个部分:前端接口,中介接口以及后端接口</li><li>前端接口负责解析符合此语言的原始码,并产生一个抽象语法树以及翻译此语法树,使其成为GCC的暂存器转换语言-RTL的后端，GCC编译器最佳化与静态程序解码技术应用于此时程序的代码上</li><li>最后适应于硬件架构的组合语言经由某一不可知算法产出</li></ul><hr><p><strong>参考:</strong></p><p>官方网站<a href="https://gcc.gnu.org" target="_blank" rel="noopener">跳转</a><br><code>https://gcc.gnu.org/</code></p><p>获取<br><code>apt-get install gcc*</code></p><p>涉及编译器深层原理的内容此章节不做阐述</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Debugger</title>
    <url>/2020/02/01/Debugger/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Debugger-第一部分"><a href="#GNU-Debugger-第一部分" class="headerlink" title="GNU Debugger 第一部分"></a>GNU Debugger 第一部分</h3><p><strong>GNU 调试工具 GDB</strong></p><p><strong>概述:</strong></p><p>存在的意义/作用:</p><ul><li>GDB大多数UNIX及UNIX-like下的调试工具</li><li>GDB可以根据自定义的要求启动所选程序</li><li>让被调试的程序在指定的调试断点停住，其断点可以是条件表达式，当程序被停住时可以去检查该程序中正在处理的事务</li><li>GDB还可以用于修改程序，以此来修复BUG所带来的影响</li><li>GDB相比于其他具有GUI的调式工具的优点就是具有修复网络断点以及恢复链接等功能</li><li>还可以把GDB理解为一个强大的命令行调试工具，命令行的优点就是可以形成一个完整的执行序列，以此来形成脚本程序<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li></ul><p><strong>使用方法简述:</strong></p><p><strong>启动</strong></p><ul><li>可以直接执行GDB以启动GDB命令行，<code>quit</code>退出GDB命令行</li><li>执行<code>gdb file name</code>来选中被调试的目标文件，并进入GDB命令行</li><li><code>run</code>用于执行程序，后面可以接GDB已有的缺省参数</li></ul><p><strong>断点</strong></p><ul><li>执行break命令，可以简写为b，用来给调试的程序中设置断点</li><li>从断电处继续运行执行continue命令</li><li>GDB还内置了断点的管理工具</li><li><code>info break</code> 用于显示当前GDB所有的断点信息</li><li><code>break breakpoint 编号</code> 用于删除指定编号的断点，如果不带编号将删除所有的断点</li><li><code>disable breakpoint 编号</code> 用于禁止使用指定编号的断点，同时info break的enb域变为n</li><li><code>enable breakpoint 编号</code> 允许指定断点，同时info break的enb域变为y</li></ul><p><strong>其他功能简述</strong></p><ul><li>单步执行：next不进入单步执行，step进入单步执行</li><li>函数调用：call function name调用和执行一个函数，执行finish结束当前的函数，如果有返回值就会显示其返回值</li><li>机器语言工具，信号处理与变量复制的检查</li></ul><hr><p><strong>参考资料:</strong></p><p>官方网站<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">跳转</a><br><a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">https://www.gnu.org/software/gdb/</a></p><p>GDB手册<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">跳转</a><br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p><p>深入GDB<a href="https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html" target="_blank" rel="noopener">跳转</a><br><a href="https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html" target="_blank" rel="noopener">https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html</a></p><p>开源程序的体系结构-GDB<a href="http://www.aosabook.org/en/gdb.html" target="_blank" rel="noopener">跳转</a><br><a href="http://www.aosabook.org/en/gdb.html" target="_blank" rel="noopener">http://www.aosabook.org/en/gdb.html</a><br><a href="http://www.aosabook.or" target="_blank" rel="noopener">http://www.aosabook.or</a></p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">因为UNIX下的软件基本上都是命令行的，所以它们具有天生的优势-可以很方便的把简单的已有工具的命令集成在一起，从而做出一个功能强大的程序 ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Lib</title>
    <url>/2020/01/30/Lib/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Lib-第一部分"><a href="#GNU-Lib-第一部分" class="headerlink" title="GNU Lib 第一部分"></a>GNU Lib 第一部分</h3><p><strong>GNU 可移植性库</strong></p><p><strong>概述:</strong></p><ul><li>GNU Lib 存在的意义是实现所有gnu代码关于移植性问题处理方法的统一化</li><li>使任何基于GNU标准的软件，可以顺利的移植到任何其他的操作系统上，关于操作系统移植问题的方法统一化</li><li>所以可以把GNU Lib理解为所有基于GNU标准的软件的子程序，这些子程序将GNU软件互相链接，从而实现GNU软件包之间的完全共享</li><li>其中gcc因为libiberty库的原因，很难脱离GNU的构建树，但GNU Lib与其完全不同，构成它的子程序会实现资源等级的划分，使所有基于GNU协议的软件实现代码共享，从而解决移植性问题，而绝非去构建，安装或者链接库</li><li>因此GNU Lib没有发行版的概念，只需要将GNU Lib的源码复制到使用者的代码树中即可</li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>官网<a href="https://www.gnu.org/software/gnulib" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib</code></p><p>手册<a href="https://www.gnu.org/software/gnulib/manual" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib/manual</code></p><p>获取<br><code>git clone git: //git.savannah.gnu.org/gnulib.git</code></p><p>GNU Lib模块列表<a href="https://www.gnu.org/software/gnulib/MODULES.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib/MODULES.html</code></p><p>社区<a href="http://git.savannah.gnu.org/gitweb/?=gnulib.get" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org</code><br><code>http://git.savannah.gnu.org/gitweb/?p=gnulib.get</code></p><p>帮助指令:<code>./gnulib-tool --help</code></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔 2020-1.30 pm1.23</title>
    <url>/2020/01/30/%E5%AF%B9%E4%BA%8E%E8%87%AA%E8%BA%AB%E7%9A%84%E4%B8%BB%E8%A7%82%E6%80%A7%E8%AF%84%E4%BB%B7/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="3cadc86da932ea4da12b65f8db825a68786b3bf5045b4b90c43098f202e405ae">0267ec72f19b8c198697a4f72870a3a800f27aefe3d5b0c2e7584ef9e154647d2e59d536d4062b11ce869819d847994131103c2d7fbe674488f9d12506f6ff5801241eabed5f099872fd9cef3006898caae24ed806efdf4a1235ed77e5e77ffc1d8078390afb3005987ad7bc876ee11b4cfc2f0e953f8e7e4a457136393d6c215cbf6fa6bf62cfe1cadd4455c84458ee920c329f84ee8414272f75b506bec6b39f6681a396b4dc6e27d9f22877d8699f6028da7fa90b9eefea79b7313073460d77980bddfe53c45684d423953ad44f66654315105dc5774ddd4fc87fbb26dd8382ddc27a865c55a05e2c61c0d073c03d2102d8481bc6e7904d190ea985fb64e34620d623fb4340d74bddb9fe5fd6e4d09b1576625a66b4ea2282aa8ff6764f7b01ef6f554a6069a129fc7fbfc0cbe2b39c4f3053d2cab4b96543cc316010521ca239d41dfced01d2b0792826dad4ecc0eff5f1f3d4db6f81d2663eb508cb5020921e199ab576a04d6867ceb7cb4543545cbad1351459e1445bfedc2a1645a298116a633ce4371588ef97da44f5d4f4736794b533afc73a4f63d195efa64a44d71220dd7c7f27b8cfb7cd7a369225feccaca9c18cd0ec0a53e4b72316428ad8863c9a45b66badc698d1780dbafcae4a9b5ff9cbdc3aa078a893ff8152c1c1e79e2141ad199e6a02bcefa769338c1d6009c3a10d7572d5645a1b2c5c468f47f8c12aabfaeae03ed41715a479e434777821b4a40d4e1f3d1f76a60424b42434695f16c699753f90164a0cf4999fefdea7a0beddb915deff4e04bb423ef25ad6cc9a0da295b04de4bd5416638b780ddbe02a19da27e031fa3445e9d71ebcb1c74e0ce8b295c2a0c06c396a200dd5251e3ea80f5e1c089277f84e90e75f0edc8773344f49ceeb36d5ba8fce8751670d957ff0c828c3c722d4478639fc3c115d984ae77f50a397fd051321b39478485fcecde3aa67c099c6f7e38770248892174b134c5103717598431437eea9806095decf6069dcb37ab8acf296cda0fd79ae783e94a812939365b95ff35048a8b769f6a59ba35919c16a52b3c06ef2abe0085e31b16b066e391833b5ba4e888a1d0b31d5d02f24d5aae02c7e5060645e3d348db6ba9ccdbb328ac6c75f6aa157ea7ec30ac514088b80824ed821dfd4305388dbb1bc1a85939c5208a8e7bef5cf952ca37387c020fbb9a7ea94a611cd4fb53925e1f49591ca64bc4e3b751f82e0870646f1c977005561ea59182b3324e7f0d7d0b1f6064e9d4e39ed84e724794fcbfa0cff7be69eed26a2a209d0ce36906047274fb90bd8e08b16fd3658ab6300e738a667e0e6d7d8dfd282c408043af49c80feb25a81f12dfa0b89b2cc0cc76b3b7392df6e3af7354d9f98c41e3a7942121e64e9c568cc3ab528082a8175c47bc9dfddee57135150360a9ccab3c2fcbc86855b9b6b4cfb6c4adc688f04059eccef0176d725586e51b7d9a9ad3b66b46b632a3456192bcfddee9b20f504e52e1d76a45ceaf9fc44b97ca4a317338ede137ada12f127f76af34727bb6fce35e8ab9953adaef63f87cd684f21e4bb4303cb6fbd5e108057b0fde03a446b3c75f674c45f22aada83907d67cf997b38f23d911de0e99dd33f873cdbc2cdec00265e765759591e966e656de13c78bfea8ddb676cad858a47079a072305cc6989ef059271afc9bfb5363001772f6da4a99ef2d2e00d7e904dccbf7ca6870a87264450b8dba64e37b3e93589e17731cb91643937e94d715f9cac38184b3e28d27474457ee3cc16be5a1d0ab5a315314bd707c7370fa202dba756d0d9bc8ddf9eab65a748dd0a65de94dd8f4f38fa84e81cab6c0ed44a8efbad49872afc978ba70b64dcfe31331abdef125633ad7d61ad0346806c0ecc88fba771e0e0f7e8c7d6bdc72eae8f3140d17911ef70d11cd545adfc4ed85b5c9d4ffc730a73284db3d1f09200c9347a2c911e72175c479389df1d830c46b0e2166186934a4981048d780fdd8005027c352454b8d8f5ffa7c36a3c1a67a6c5b71228741168f70075b215a2591117fd7874c1bd140ae7748b99f8725b6792b41355c147a48dce5c596202937c30e0bea95c9801d3c6161fa48cbcdf1b19cb34f6dd571e6e06bd6234e2963f5299e8cb373f1f71305567b80000efff1785117366772f243c1ad65f8e180d4e5c067c9b20034e262fda6e3fd2f8a0926938a1fc4ac2cc215227d4012643f6e2a4c37711a069cb8a395c9b959beadc5f6323e0c96a960da0dff210de9bd4547ead6d68873a34e1a7349d25d3d2ffcbc82c0beda9a71a36c90d05d3a1785937a5046dd6133da4cc794b6718d03b81587818045a5ca4e25ca4ece95cac0e1b3ed9eaa440e163068eb7700320b3eee7098a71882cfd991954f3f0c01643ab18118ab233188863b0124017522bac948f678669e03fad49dae5b297550f59094e23ab459af1843b44b4100d3dd677e0ec9e812194b201862b5af54a2f39d7d00c1995bf95b98ca3698d8d9cce9f5fbac66178d2d1b7c253bc3db23f86a425f03ab65d3bcae156d86d263f0d656f72dd5abb4623a6b38a9b066a010e1b5d25cb594bb2b5773171f5dab46e0efb651b2713d28b6af7c68c0f47bf1ea322472829600c5b3a7af5add307f23a13b82e44fdc52f616c4658fb8fd586eed698a124fab96385146b747d4b874776935766627d0b4ce9924aa26f41664797fe137b8e2ca82d0e21c5f9b5f96f8dea2a1395b9cef612d6b8357e3bb9cb1b6b2125df73d171acfbf6c16f4fcf8af9e906a7e9352c0018486655ff6f3f520fff4a9b860ed23c09e1e2e350d46791de30644a830cda85fa843ffab9ae41e18015cb7531174a31198cef25f100aaeba975867919b9587142897f5e72b53cde7fd700497edb73987aa649e2d59ff10f8b54144f8ef5196be944d3d377fdff3b0036db0995b3eb7ee65b6a0cb7483a6bdc37681cf107a2a054bab199fb331e523adbee9aff435e8dcee20c6fab116433495ea883668b3eee98b4c0935b4e6238c9963c67da6c1b7d09307326c78b481ea5ad3957cbb78c3f93d014a1d87c6126560836867dbb1a14b58c33b63c024a7cf2c048c1474837c1e2eb8098e3e41a61ac56e4e990792bf8545e3ba8d780f7cf12f3a6cc83e7cb55adf028b12ce3b98da5c4247947ce3b6c6ff403f19ddc7c9739cc0ddba8d4759aa7021773271cf05e9ff09668442908269b01f8f8581845ea32250fa47e5aa53f156eca297bc1e5fb03ccfa8b1d1082654af858a1e1aaed9dbdb25a1d79b375aa8593197312982121c2ca0891a6e3e617dc1ec3b9c0a1ac9bc4c0aa7759eff63dbca371e64162924acdd7553a85c619c8416ce6b72cd536df50461cdbd904e7a64f91edee2be49237dc665e975824259f1606579835738ac5e6632aecc4d334a8b69a43b4c6cfdef2ca8825fdd4fa8ca0f476f53260bc92066f03956180b4a907ec43bab3b6595b873e0cf3c6ee4907f0c746a1fd4517df4393c3ccfc62aa9d7172112708d097452e0140ced355c78e2fda4d1153cd8087b0c12ccae9afc295ddfa4d84d8c517bccf12501fcb00a31bab2b8ec4865aef16faaa3c37b21a07586b2fe3099dc3147423c8747017526d898f47a8a605abc089c587338d2374386f88c42e3f1dfc01214f1f13af93f2f1604148fd33da4b279bfafa65fca064a68d04a20153e4865bf201790f8e90a6580d9d5aae443cedc63eb0e5500807f43192b38e5a493365c2474d3f1be7c5c175100cb46ce4b2270854abb6be0da2f54c6bce7ad0c03efe8b023c0ec1a6915f00c56ea7a2b475a0024f3e16dd682307d7d1eed87218990a7b96821c594f4655a026df19947df2fa2efa80e1c541a7e72e5937ead3b1a7b2ca056793f411df80a483c5e56323fc4028402de676487ee3e8f2066904b0876c4d06567bc1b5c4a6722048eedcdf4ad7b253c97909d5561c45d404207e7f9a45cc6e85e14d4eb16270847a2094b867a3f8c34ebaa7881b791b4f61869d12b192e8f29c488934bcfca1c06167e4c8de86b947d7b99fd8c2a549f125edf7268dcd53c9dda779c1f570f9a6fe8b2397df82248b0a2128ed2f71e17f68fe931eec0261fc7daaa8ae71f2c0fdfc498230d539feceda8ac7fc4048a61cb4d27329075ece0140168b2bbf788c5dcc93b6e28a64238ec47abc545dc009854b9306bf2081664c2691e53afbea14594941de91738848e93f892bb5d4ccd43d8a72dce67c6c88dae6de76a55a2804d0c12e54a1e78a57842531cde449f27ebb5b4df2475c3984814a56129c79dfaf10a3d5051a1a28de20859205f4024a21999e412e31c949fde9893550720ffab1bbb4389fdb171a7d5229f824f6bc27304dd1c86246d74d7657e5028d4e53b146da4370f72b4f0fc404d9b1efa8b88d487363419ec45f885e42c9fb3663b8409cb5d7fb958efbca1a9a18ce0c0c9ac8b9f1691925f2826d1e428198d9f562d384c2878ad5b349f2d52fb5e7095441799ea80bf79d3fc5585e9e150b45a1895137ae127100f82df7d84d6ae50e262b513ae650853a1c9c0740be6516627f5d3cf73b1bb5e03d4331113ebd39982a4aea6da945ecf7bd79e7efc41744ea529dcfcc9b75a6856dc3fada4225d4be83e863eeccbca7c25fa700493dd758f7b09a6252e29111448e9331f8502541f8fc6d65b281eac0ac816644cabcb82108b5f0695a082ad4b9b02203366bbafae2c3d291f16237dc4aca119297ba3533c885a9546b40e370865f27d18c8cab7d47b7a10ee62d9d5121fd190c4a2d5cd51947abf9f46085a035c5ba3c9128ad6c682f267e76b02e0223bf4f2fceafdfd3db28db32b5a18e3c8c5bea30143332a8ae2a05ba056eb40dc94313363e0943ce0aa7096954c1b0175c9f168531d9b46f601510b57de0da3be472e048ce4c378fb2b5eb156f281367ec7bca4b3e13aa1782c39120c478b008f260e7895be8f43aae60c8cb66ab5437c082de889501dd1fa93b471c05dcfdd94029836e84886f04d5f13b732c24f85b444b3ba580e731e519982179b20a73bdff5e36357c7decd2891dcbeed8d7a7c4484b7dee9c7fa8c12fbd584e9c1b37a6c831efce21e1632b619335fc41d9b79c27d6647000f66f55d45d8dc459e917370810b4a74714fc5d732ee0fc097d421ab27de1d66b7b2a6b1b93e8041aadd55a3c47ab54f8057e9a2d86d8673dd74f8e4f0ba0bd93ecd1700d070695601a64869c78284fa6eabefc8451ccac0f688d7889367a676bf8956700f57521ed7bface6061da493792c016dde4520df433567f769f80ebff9b1a755579c6b4b0af9262dcdf05131555936f527de7689c059db443948141fe7e410d12d916309e2be8d34620ab72bd9f649da2b13d9c69329e9cecff86584e2c8d7cc1</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔，杂项</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU  Autotools</title>
    <url>/2020/01/29/Autotools/</url>
    <content><![CDATA[<!-- build time:Tue Feb 04 2020 19:42:10 GMT+0800 (中国标准时间) --><h3 id="GNU-Autotools-第一部分"><a href="#GNU-Autotools-第一部分" class="headerlink" title="GNU Autotools 第一部分"></a>GNU Autotools 第一部分</h3><p><strong>GNU 构建系统</strong></p><p><strong>概述:</strong><br>autotools存在的目的就是用于生成makefile，从而实现降低makefile的维护难度与开发难度<br>autotools是一个工具集，并它包含了以下程序</p><ul><li>aclocal</li><li>autoscan</li><li>autoconf</li><li>autoheader</li><li>automake</li></ul><hr><p><strong>aclocal</strong><br>aclocal(automake)</p><ul><li>根据已安装的宏，用户定义宏和aclocal.m4文件中的宏将configure.ac文件所需要的宏集中定义到文件aclocal.m4文件中</li><li>aclocal由perl脚本所编写，而aclocal的定义为 <code>aclocal - create aclocal.m4 by scanning configure.ac</code></li><li>aclocal是一个由perl编写的脚本程序</li><li>aclocal根据configure.in文件中的宏所定义的内容，自动生成aclocal.m4文件</li></ul><hr><p><strong>autoscan</strong><br>autoscan(autoconf)</p><ul><li>用于扫描源代码以搜寻普通的可移植性问题，如检查编译器，库，头文件等</li><li>从而生成文件configure.scan，它是configure.ac的原型之一<br>或<br>执行逻辑:</li><li>autoscan工具用来扫描文件目录，可以用目录名作为参数，如果不使用参数的话，autoscan将会扫描当前所使用的目录</li><li>之后autoscan将从所指定的扫描目录中，将由扫描得到此目录下的源代码文件，基于此源代码生成源代码的configure.scan文件</li><li>configure.scan文件用于当作configure.in文件的模板，以此来获取configure.in文件</li><li>而configure.in的内容是一些宏，这些宏将经由autoconf工具处理并生成configure脚本</li></ul><hr><p><strong>autoheader</strong><br>autoheader(autoconf)<br>根据configure.ac中的某些宏，运行m4,<br>如ccp宏定义则声称config.h.in</p><hr><p><strong>Automake</strong><br>automake工具用于处理由事先编写好且带有预定义宏的文件，并生成makefile<br>简述:</p><ul><li>首先使用automake工具根据configure.in和Makefile.am来生成Makefile.in</li><li>然后编写宏定义文件makefile.in，再然后根据autoconf生成的configure脚本文件，最后让configure依据makefile.in来生成一个与之源码对应的makefile文件<br>或</li><li>automake将makefile.am中定义的结构建立起makefile.in，然后configure脚本将生成的makefile.in文件转换为makefie</li><li>如果在configure.ac中有特殊定义的宏，比如AC-PROG-LIBTOOL,automake会调用libtoolize，否则产生config.guess和config.sub</li></ul><p>官方网站:<a href="https://www.gnu.org/software/automake/" target="_blank" rel="noopener">https://www.gnu.org/software/automake/</a><br><a href="https://www.gnu.org/software/automake/" target="_blank" rel="noopener">跳转</a></p><p>官方文档:<code>https://www.gnu.org/software/automake/manual/automake.html</code><br><a href="https://www.gnu.org/software/automake/manual/automake.html" target="_blank" rel="noopener">跳转</a></p><p>获取方式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp: ftp:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;automake&#x2F; </span><br><span class="line">http: http:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;automake&#x2F;</span><br></pre></td></tr></table></figure><p>帮助指令: <code>automake --help</code>与<code>man automake</code></p><hr><p><strong>Autoconf</strong></p><ul><li>autoconf工具用于根据configure.in文件和alocal.m4文件来产生configure文件</li><li>而此时的aclocal.m4需要用到GNU M4工具去处理</li><li>config是一个脚本，它能够设置源代码程序来适应各种不同的操作系统平台</li><li>并且根据不同的操作系统来产生合适的Makefile</li><li>从而使所扫描到的源代码程序能在不同的操作系统平台上被编译出来<br>或</li><li>作用是将configure.ac中的宏展开，生成configure脚本-一个shell脚本，此过程中可能需要用到aclocal.m4中定义的宏</li><li>以达成自动配置软件源代码包</li></ul><p>官方网站: <code>https://www.gnu.org/software/autoconf/autoconf.html</code><br><a href="https://www.gnu.org/software/autoconf/autoconf.html" target="_blank" rel="noopener">跳转</a></p><p>官方文档：<code>https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autconf.html</code><br><a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html" target="_blank" rel="noopener">跳转</a></p><p>获取方式:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ftp: ftp:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;autoconf&#x2F;</span><br><span class="line">http: http:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;autoconf&#x2F;</span><br><span class="line">git: git clone http:&#x2F;&#x2F;git.sv.gnu.org&#x2F;r&#x2F;autoconf.git</span><br><span class="line">apt-get: apt-get install autoconf*</span><br></pre></td></tr></table></figure><p>帮助指令: <code>autoconf --help</code>与<code>man autoconf</code></p><hr><p><strong>Autotools</strong></p><p>获取方式:<br><code>apt-get install autotools</code></p><hr><p><strong>逻辑简述:</strong></p><ul><li>利用autotool组件生成configure脚本后生成makefile的执行逻辑</li><li>要生成makefile之前需要编写makefile.am文件之后再让automake工具使用autoconf所生成的configure脚本来生成所选源码文件的makefile</li><li>第一步需要先执行autoscanf命令来扫描当前目录下的源码文件，然后autoscanf会基于源码文件生成一个configure.scan文件</li><li>基于源码生成的configure.scan文件被用于当做configure.in文件的模板而存在</li><li>第二步将configure.scan的文件名改为configure.in，并对configure.in内的各种宏定义进行修改，这些宏定义内包括了用于让指向让autoconf处理configure.in文件从而生成从configure脚本</li><li>第三步执行aclocal命令，生成alocal.m4文件，因为autoconf需要aclocal.m4文件来生成configure脚本文件</li><li>第四步执行autoconf命令，生成configure脚本文件(自动配置源代码脚本文件)</li><li>第五步编写makefile.am文件，makefile.am文件用于描述定义从而让automake生成指定的宏和目标</li><li>第六步运行automake命令，可以增加参数–add-missing，从而让automake自动添加一些脚本文件</li><li>第七步运行configure脚本，从而生成基于源代码的makefile文件</li><li>最后直接使用make工具，编译并编译安装makefile就可以了，make install将会直接把可执行文件安装再/usr/local/目录下，至此完毕</li></ul><p>以上五个程序皆可称为M4宏的扩展包,文件处理的步骤与顺序，逻辑关系，应用等深度刨析第一部分里不做赘述<br>以上内容仅为主观理解，仅供参考</p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU M4</title>
    <url>/2020/01/29/M4/</url>
    <content><![CDATA[<!-- build time:Thu Feb 06 2020 19:01:57 GMT+0800 (中国标准时间) --><h3 id="GNU-M4-第一部分"><a href="#GNU-M4-第一部分" class="headerlink" title="GNU M4 第一部分"></a>GNU M4 第一部分</h3><p><strong>GNU 宏处理器</strong></p><p><strong>概述:</strong></p><ul><li>GNU M4是一种宏处理器</li><li>将输入拷贝到输出，同时将宏展开</li><li>宏可以是内嵌的，也可以是用户定义的</li><li>除了可以展开宏，m4还有一些内建的函数，用来引用文件，执行命令，整数运算，文本操作，循环等</li><li>m4既可以作为编译器的前端，也可以单独作为一个宏处理器</li><li>因为基于POSIX标准，所以兼容大部分SVR4<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li><li>其主要作用于GNU Autoconf project，通常是在安装autoconf时需要m4依赖才会安装它</li></ul><p>获取途径:<br>git: <code>git clone http://git.savannah.gnu.org/r/m4.git</code><br>http: <code>http://ftp.gnu.org/gnu/m4</code><br>ftp: <code>ftp://ftp.gnu.org/gnu/m4</code><br>apt-get: <code>apt-get install m4-doc或m4*</code></p><hr><p><strong>学习途径</strong></p><p>官方文档:<br><code>https://www.gnu.org/software/m4/m4.html</code><br><a href="https://www.gnu.org/software/m4/m4.html" target="_blank" rel="noopener">跳转</a></p><p>M4 宏语言手册<br><code>http://mbreen.com/m4.html</code><br><a href="http://mbreen.com/m4.html" target="_blank" rel="noopener">跳转</a></p><p>GNU M4 社区<br><code>http://savannah.gnu.org/projects/m4/</code><br><a href="http://savanah.gnu.org/project/m4" target="_blank" rel="noopener">跳转</a></p><p>默认帮助文档<br><code>m4 --help与man m4</code></p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">SVR4: UNIX操作系统的一种内核标准</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>基于debian使用hexo框架-next主题搭建并配置博客</title>
    <url>/2020/01/28/%E5%9F%BA%E4%BA%8Edebian%E4%BD%BF%E7%94%A8hexo%E6%A1%86%E6%9E%B6-next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="对于debian的基本配置与hexo的安装"><a href="#对于debian的基本配置与hexo的安装" class="headerlink" title="对于debian的基本配置与hexo的安装"></a>对于debian的基本配置与hexo的安装</h3><p>apt源的设置与一些基本软件的配置和准备这里就不过多阐述了<br>先修改一下/etc/hosts内的所配置IP,保证机器能ping通github.com<br><code>vim /etc/hosts</code> 内添加 <code>192.30.253.113 github.com</code></p><p>接下来安装hexo所依赖的几个程序：npm，git，node.js<br><code>apt-get install npm*</code><br><code>apt-get install git*</code><br><code>apt-get install node.js*</code><br>安装完之后检查一下版本或者whereis一下看看所否健在<br>最后再安装hexo软件<br><code>npm install -g hexo-cli</code><br>安装完–version检查一下版本</p><hr><h3 id="hexo的基本操作"><a href="#hexo的基本操作" class="headerlink" title="hexo的基本操作"></a>hexo的基本操作</h3><p>hexo –help<br><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方中文文档与手册</a><br>hexo安装完毕后可以先进行一下测试<br>于任意目录下新建一个文件夹 <code>mkdir blog</code><br>进入文件夹后分别执行<code>hexo init,hexo g,hexo s</code><br>然后使用浏览器访问<u>localhost:4000</u>查看所否成功</p><hr><h3 id="hexo链接github库"><a href="#hexo链接github库" class="headerlink" title="hexo链接github库"></a>hexo链接github库</h3><p>利用npm安装hexo部署程序/插件<br><code>npm install --save hexo-deployer-git</code><br><code>vim /*/blog/_config.yml</code><br>修改最下方的#deployment配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;你所建立的仓库地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>执行<code>hexo d</code>开始远程部署，其中需要用户输入仓库所在帐号的帐号和密码</p><hr><h3 id="hexo修改主题"><a href="#hexo修改主题" class="headerlink" title="hexo修改主题"></a>hexo修改主题</h3><p>这里推荐两个个人感觉生态最好的两个hexo主题-next与yilia<br>进入blog目录下直接执行克隆命令<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>或<br><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code><br>此时的主题文件被存储于/blog/theme目录下<br><code>cd _condig.yml</code><br>修改#extensions中的theme，将原主题landscape修改为next或yilia</p><hr><h3 id="hexo安装搜索插件与RSS插件"><a href="#hexo安装搜索插件与RSS插件" class="headerlink" title="hexo安装搜索插件与RSS插件"></a>hexo安装搜索插件与RSS插件</h3><p>添加并配置RSS<br><code>npm install hexo-generator-feed --save</code><br>修改hexo配置文件为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;</span><br><span class="line">## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;</span><br><span class="line">        plugins:</span><br><span class="line">                hexo-generator-feed</span><br><span class="line">                #Feed Atom</span><br><span class="line">        feed:</span><br><span class="line">                type: atom</span><br><span class="line">                path: atom.xml</span><br><span class="line">                limit: 20</span><br></pre></td></tr></table></figure><p>对主题文件添加：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">        type: rss2</span><br><span class="line">        path: rss2.xml</span><br><span class="line">        limit: 5</span><br><span class="line">        hub:</span><br><span class="line">                content: &#39;true&#39;</span><br></pre></td></tr></table></figure><p>添加并配置search-搜索<br><code>npm install hexo-generator-searchdb --save</code><br>修改hexo配置文件为</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">  search:</span><br><span class="line">          path: search.xml</span><br><span class="line">          field: post</span><br><span class="line">          format: html</span><br><span class="line">          limit: 10000</span><br></pre></td></tr></table></figure><p>修改主题配置文件为<br>找到local search，然后把enable设置为true</p><p>其余类似于菜单，头像，链接与装饰的配置可以<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">参考官方文档</a></p><hr><h3 id="关于文章的书写格式与基本要求"><a href="#关于文章的书写格式与基本要求" class="headerlink" title="关于文章的书写格式与基本要求"></a>关于文章的书写格式与基本要求</h3><p>hexo文章书写的语法都来自于Markdown<br>Markdown所一种可以使用普通文本编辑器编写的标记语言<br>目的是通过简单的语法来让普通文本的内容具有一定的格式<br>详情参考: <a href="https://markdown-zh.readthedocs.io/en/latest" target="_blank" rel="noopener">Markdown中文文档</a></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
