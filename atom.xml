<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-12T15:57:04.002Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C-资源整合目录</title>
    <link href="https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/"/>
    <id>https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/</id>
    <published>2020-03-12T15:55:11.000Z</published>
    <updated>2020-03-12T15:57:04.002Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 12 2020 23:58:26 GMT+0800 (中国标准时间) --><h3 id="C-资源整合目录"><a href="#C-资源整合目录" class="headerlink" title="C 资源整合目录"></a>C 资源整合目录</h3><ul><li>电子书籍</li><li>URL地址</li><li>参考资料</li></ul><hr><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><ul><li>CN-C Primer Plus (第六版)<blockquote><p>C11标准<br>作者: Stephen Prata<br>译者: 姜佑</p></blockquote></li></ul><hr><p><strong>书籍目录:</strong></p><ul><li>第一章/第二章-基本概念与书籍介绍</li><li>第三章-数据和C</li><li>第四章-字符串和格式化输入/输出</li><li>第五章-运算符，表达式和语句</li><li>第六章-C控制语句：循环</li><li>第七章-C控制语句：分支和跳转</li><li>第八章-字符输入/输出和输入验证</li><li>第九章-函数</li><li>第十章-数组和指针</li><li>第十一章-字符串和字符串函数</li><li>第十二章-存储类别，链接和内存管理</li><li>第十三章-文件输入/输出</li><li>第十四章-结构和其它数据形式</li><li>第十五章-位操作</li><li>第十六章-C预处理器和C库</li><li>第十七章-高级数据表示</li></ul><p><strong>笔记归纳:</strong></p><ul><li>第一/二/三章被归纳于数据类型-1/2内</li><li>第四章被归纳于数据类型-3/4内</li><li>第五章被归纳于数据类型-5内</li><li>第六章被归纳于数据类型-6内</li><li></li></ul><hr><ul><li>本书一共十七个章节，预计使用最多50个笔记文本进行刨析归纳<blockquote><p><code>17*2+16=50</code></p></blockquote></li></ul><hr><ul><li><p>相关资源整合包</p></li><li><p><a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">百度网盘地址</a>:</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA</a><br>提取码: 0ez0</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Mar 12 2020 23:58:26 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;C-资源整合目录&quot;&gt;&lt;a href=&quot;#C-资源整合目录&quot; class=&quot;headerlink&quot; title=&quot;C 资源整合目录&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-5</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/</id>
    <published>2020-03-12T11:14:12.000Z</published>
    <updated>2020-03-12T11:16:20.592Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 12 2020 19:17:52 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-1</strong></center><a id="more"></a><h2 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型-5"></a>数据类型-5</h2><ul><li>语句与表达式-1<blockquote><p>C-控制语句/循环-While<br>C-控制语句/选择<br>关系运算及其关系运算符<br>条件表达式<br>真与假的概念<br>循环逻辑概念与原理</p></blockquote></li></ul><hr><ul><li>通常一门语言应该提供以下三种形式的程序流<blockquote><p>执行语句序列(即为线性的执行逻辑)<br>如果满足某些条件就进行重复执行的语句序列(循环)<br>通过测试选择执行哪一个语句序列(分支/控制)</p></blockquote></li></ul><hr><h2 id="C-控制语句-循环"><a href="#C-控制语句-循环" class="headerlink" title="C 控制语句-循环"></a>C 控制语句-循环</h2><h3 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h3><ul><li><p>while循环是入口条件循环</p><blockquote><p>或称其为while循环是使用入口条件的有条件循环<br>所谓的有条件指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)<br>该表达式是一个入口条件(entry condition)，因为必须满足条件才能进入循环体<br>如果条件一开始就为假，则绝对不会进入循环体，则跳过循环体代码块</p></blockquote></li><li><p>可以把下面的伪代码作为while循环的标准格式:</p></li></ul><p>1.利用循环外的语句对循环内的变量进行值传递<br>2. 获得第1个用于测试的值 (while (循环条件))<br>3. 当测试为真时<br>4. 处理值 (根据循环条件)<br>5. 获取下一个值 scanf()</p><ul><li><p>当被输入的值传递进循环并可以保证条件为真时，开始第一轮循环</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>); <span class="comment">/* 定义被输入值的变量 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">status</span> == <span class="number">1</span>) <span class="comment">/* 定义循环条件 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>);  <span class="comment">/* 定义循环行为，即接受被输入的值，当接受的值可以满足循环条件时则为真，开始迭代 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以写为</p><blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1){/* 循环行为 */}</code></p></blockquote></li><li><p>while循环的通用形式如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( expression )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>其中statement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句</p></li><li><p>在大部分的程序内，expression部分都使用关系表达式</p><blockquote><p>也就是说，expression是值之间的比较，可以使用任何表达式<br>如果expression为真(或者更一般地说，非零)，则执行statement部分一次，然后再次判断expression<br>在expression为假(0)之前，循环的判断和执行一直重复进行<br>每次循环都被称为一次迭代/循环一轮(iteration)</p></blockquote></li><li><p>while循环结构示意图:</p></li></ul><img src="/images/数据类型-5/C-循环语句-1.png" width="30%" height="30%"><ul><li><p>while循环有一点非常重要: 在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假</p><blockquote><p>否则，循环就不会终止(可以使用 break和if语句来终止循环)</p></blockquote></li><li><p>最大正值加一一般 会得到一个负值，类似地，最小负值减一一般会得到最大正值</p></li></ul><hr><h3 id="while的语法要点"><a href="#while的语法要点" class="headerlink" title="while的语法要点"></a>while的语法要点</h3><ul><li><p>使用while时，要牢记一点: 只有在测试条件后面的单独语句(简单语句或符合语句)才是循环部分</p><blockquote><p>while循环语句的格式应为while(){}，而绝非{while()}，陷入无限循环(infinite loop)是最常见的情况</p></blockquote></li><li><p>还有一点就是，即便while语句本身使用符合语句，while的本质依旧是一条单独的语句(或称为在语句构成上)</p><blockquote><p>该语句从while开始执行，到第一个分号结束，在使用复合语句的情况下，到右花括号结束，还需要注意分号的为止，一定要在语句结束时再写分号</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li><li><p>在使用while语句时，可以直接将分号写在条件表达式后面，即可以让程序直接进入下一个迭代，因为一个单独的分号被视为一条语句</p></li><li><p>如果在测试条件(条件表达式)的代码后面直接添加单独的分号</p><blockquote><p>此分号则代表为一个空语句(null statement)，它什么也不做<br>在 C 中，单独的分号表示空语句，而处理空语句最好的方法是使用continue语句</p></blockquote></li></ul><hr><h3 id="关系运算符与表达式"><a href="#关系运算符与表达式" class="headerlink" title="关系运算符与表达式"></a>关系运算符与表达式</h3><ul><li><p>用关系运算符和表达式来比较大小</p></li><li><p>以下关于关系表达式与关系运算符的概念在所有的循环类语句概念中都通用，这里的通用泛指计算机上所有的程序语言</p></li><li><p>while循环经常依赖测试表达式来作比较，这样的表达式被称之为关系表达式(relational expression)</p></li><li><p>而出现在关系表达式中间的运算符叫做关系运算符(relational operator)</p></li><li><p>以下表图片内列出了 C 的所有关系运算符，同时该表也涵盖了所有的数值关系</p></li><li><p>关系运算符:</p></li></ul><img src="/images/数据类型-5/关系运算符-1.png" width="30%" height="30%"><ul><li><p>PS: 数字之间的关系再复杂也没有人与人之间的关系复杂-来自原书</p></li><li><p>关系运算符常用于构造while语句和其他C语句中用到的关系表达式</p><blockquote><p>这些语句都会检查关系表达式为真还是为假</p></blockquote></li><li><p>所谓关系运算符，存在的意义就是对人为所描述的表达式的值进行确定，确定的结果只有0和1，即真与假</p></li><li><p>而在确定的过程中，最常见的确定方法就是与人为所规定的值进行字符的比较</p></li><li><p>如果要对浮点数进行比较，尽量要去只是用&lt;和&gt;，因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等</p></li><li><p>为了避免此类型错误的发生，C 内拥有fabs()函数，该函数声明在math.h头文件中</p><blockquote><p>使用该函数可以较为方便的比较浮点数，该函数返回一个浮点的绝对值(即为没有代数符号的值)</p></blockquote></li></ul><hr><p><strong>fabs()函数使用示范:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">double</span> response;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"What is the value of pi?\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"lf"</span>, &amp;response);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Try again!\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Close enough!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差 0.0001：</p></li><li><p>输出结果:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">is</span> the value of pi?</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">Try again!</span><br><span class="line"><span class="number">3.1416</span></span><br><span class="line">Close enough!</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="何为真"><a href="#何为真" class="headerlink" title="何为真"></a>何为真</h3><ul><li><p>这是一个古老的问题，但是对C而言还不算难、</p></li><li><p>在C中，表达式一定有 一个值，关系表达式也不例外</p></li><li><p>可以使用并输出两条简单的比较语句，比如说 <code>true_val=(10&gt;2);</code>和<code>false_val(10==2);</code>，前者为真，后者为假</p><blockquote><p>则输出的结果必定是true=1，而false=0</p></blockquote></li><li><p>所以说，对 C 而言，表达式为真的值为1，表达式为假的值为0</p></li><li><p>当 C 程序的循环结构的判断结果一直为真(即为1)时，则反复且永远进行条件及语句的迭代</p></li><li><p>所以一些C程序使用下面的结构，由于1为真，所以该循环会一直进行</p><blockquote><p><code>while (1){...}</code></p></blockquote></li></ul><p><strong>关于其它的真值:</strong></p><ul><li><p>在 C 中，所有的非零值都被视为真，只有0被视为假</p><blockquote><p>也就是说，只要测试条件的值为非零，就会执行while循环</p></blockquote></li><li><p>这是从数值方面而不是从真/假方面来看测试条件</p><blockquote><p>还有需要进行牢记的一点就是，关系表达式为真，求值得一，关系表达式为假，求值得零<br>因此，这些表达式实际上相当于数值，所以必须要去充分利用测试条件的这一特性<br>比如，用while(goats)替换while(goats !=0)，因为表达式goats !=0和goats都只有在goats的值为0时才为0或假，所以再增加一个不等于(!=)的比较运算符的毫无意义的<br>这里利用了 C 内自动判断真值与假值的性质，或称其为默认值与自然选择</p></blockquote></li><li><p>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编译代码，从而使代码更加整洁与美观</p></li><li><p>这个特点既为好处，也为坏处，C 由于对真的约束太少，会带来一些麻烦</p><blockquote><p>当循环的条件表达式中没有定义==1，而定义了=1时，此时的条件表达式中的变量的值为一<br>而且，整个赋值表达式的值就是赋值运算符左侧的值，所以变量=1的值也是1，既while(变量=1)实际上就相当于while(1)<br>也就是说，循环不会退出，此时如果人为的输入其它的符号，从而让变量的值归于0，但是循环的测试条件又把改变量重置为1，从而又进入了下一次迭代<br>此时程序中的循环一直运行着，用户在输如符号后完全没有机会输入，如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，以供下一次读取<br>当scanf()把输入的符号(这里的符号可以为任何不属于数字的数据类型)作为整数读取失败了，他将会把字符留下<br>在下一次循环时，scanf()从上次读取失败的地方(被输入字符)开始读取，scanf()把该输入的字符再次作为整数读取，然后又失败了<br>以此，就造成了一个无限的循环，而且还是失败的</p></blockquote></li><li><p>所以这里千万需要注意的一点就是，千万别把关系相等运算符==和赋值运算符=给弄错了</p></li><li><p>因为 C 不允许给常量赋值</p><blockquote><p>而且编译器会把赋值运算符的这种用法作为语法错误标记出来<br>可以在构建比较是否相等的表达式时，把常量放在左侧，比如<code>6 = canoes;</code></p></blockquote></li><li><p>好在计算机察觉不出来，因为对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样-来自原文</p></li><li><p>总之，关系运算符用于构成关系表达式</p><blockquote><p>关系表达式为真时值为1，为假时值为0<br>通常用关系表达式作为测试条件的语句(如while和if)可以使用任何表达式作为测试条件<br>即非零为真，零为假</p></blockquote></li><li><p>以类似于<code>while (条件表达式)</code>这样的格式为变量进行命名可以让while循环的测试变得简单易懂</p></li></ul><hr><h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a><code>_Bool</code>类型</h3><ul><li><p>在 C 中，一直用int类型的变量表示真/假值</p></li><li><p>C99专门针对这种类型 的变量新增了<code>_Bool</code>类型</p><blockquote><p>该类型是以英国数学家George Boole的名字命名 的，他开发了用代数表示逻辑和解决逻辑问题<br>在编程中，表示真或假的变量被称为布尔变量(Boolean variable)，所以<code>_Bool</code>是 C 中布尔变量的类型名<br>其中<code>_Bool</code>类型的变量只能储存1(真)或0(假)<br>如果把其他非零数值赋给<code>_Bool</code>类型的变量，该变量会被设置为1<br>这反映了C把所有的非零值都视为真<br>给布尔变量取一个能表示真或假值的变量名是一种常见的做法</p></blockquote></li><li><p>C99提供了<code>stdbool.h</code>头文件，该头文件让<code>bool</code>成为<code>_Bool</code>的别名</p><blockquote><p>而且还把true和false分别定义为1和0的符号常量<br>包含该头文件后，写出的代码可以与C++兼容<br>因为C++把bool，true和false定义为关键字<br>如果系统不支持<code>_Bool</code>类型，导致无法运行该程序<br>可以把<code>_Bool</code>替换成 int即可</p></blockquote></li></ul><hr><h3 id="优先级和关系运算符"><a href="#优先级和关系运算符" class="headerlink" title="优先级和关系运算符"></a>优先级和关系运算符</h3><ul><li><p>关系运算符的优先级比算术运算符(包括+和-)要更低，而比赋值运算符要高</p></li><li><p>关系运算符之间有两种不同的优先级。</p><blockquote><p>高优先级组: &lt;&lt;= &gt;&gt;=<br>低优先级组: == !=</p></blockquote></li><li><p>与其他大多数运算符一样，关系运算符的结合律也是从左往右</p></li><li><p>以下图片列表列出了常用的关系运算符优先级关系，具体可以参考-[C 运算符]，其中列出了全部运算符的完整优先级列表</p></li><li><p>运算符优先级:</p></li></ul><img src="/images/数据类型-5/C-关系运算符优先级-1.png" width="30%" height="30%"><hr><h3 id="关于不确定循环和计数循环"><a href="#关于不确定循环和计数循环" class="headerlink" title="关于不确定循环和计数循环"></a>关于不确定循环和计数循环</h3><ul><li><p>一些while循环是不确定循环(indefinite loop)</p><blockquote><p>所谓不确定循环，指 在测试表达式为假之前，预先不知道要执行多少次循环</p></blockquote></li><li><p>还有一类是计数循环(counting loop)</p><blockquote><p>这类循环在执行循环之前就知道要重复执行多少次</p></blockquote></li><li><p>在创建一个重复执行固定次数的循环中涉及了3个行为:</p></li></ul><p>1.必须初始化计数器<br>2.计数器与有限的值作比较<br>3.每次循环时递增计数器</p><ul><li>while循环的测试条件执行比较，递增运算符执行递增<blockquote><p>如果递增发生在循环的末尾，即可以防止不小心漏掉递增<br>因此，这样做比将测试和更新组合放在一起要好，但是计数器的初始化放在循环外，就有可能忘记初始化<br>此时可以用for循环来避免这种情况的发生</p></blockquote></li></ul><hr><p><strong>其它内容:</strong></p><ul><li>赋值运算符 用于将右值赋给左值，而左值通常为变量</li><li>赋值表达式</li><li>关系运算符 用于对左值和右值进行比较</li><li>条件运算符</li></ul><hr><h3 id="伪代码-pseudocode"><a href="#伪代码-pseudocode" class="headerlink" title="伪代码(pseudocode)"></a>伪代码(pseudocode)</h3><ul><li>是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应</li><li>伪代码有助于涉及程序的逻辑</li><li>确定程序的逻辑无误后，再把伪代码翻译成实际的代码</li><li>使用为伪代码的好处之一是，可以把注意力集中再程序的组织和逻辑上，不用在设计程序时还要分心去想如何用编程语言来表达自己的想法</li><li>例如可以用缩进来代表一块代码，不用考虑 C 的语法要用花括号把部分代码括起来</li></ul><hr><h3 id="其它理解"><a href="#其它理解" class="headerlink" title="其它理解"></a>其它理解</h3><hr><ul><li><p>程序按照序列逻辑进行线性执行</p></li><li><p>由主函数mian()开始</p><blockquote><p>然后线性执行主函数内所调用的函数和语句<br>而其它的函数也是相同的原理，函数内的任何语句都是根据线性逻辑来逐一执行<br>至于循环语句与控制语句也是由线性逻辑来执行的，即执行完该语句上面的所有语句，再进行对循环或控制语句的执行<br>各种基本数据对象根据逻辑构成语句(数据对象可以包括变量，数组，指针，运算符，关键字或对于其它函数的调用等等)</p></blockquote></li><li><p>语句构成函数</p></li><li><p>函数构成程序</p></li><li><p>在计算机内，构成任何数据对象的逻辑都是线性的，即逐一执行</p></li></ul><hr><ul><li>预处理器(对于头文件的处理方法，通常是在程序编译之前就已经将头文件中的内容处理完毕，处理的对象即为对于所指头文件内函数的对应调用)</li><li>头文件(给当前的程序本身提供外部函数的支持，即对于当前语言标准库的支持)</li></ul><ol><li>定义常量</li><li>定义全局变量</li><li>函数声明</li></ol><ul><li>主函数<code>main(){包括了对于其它函数的调用以及线性逻辑执行}</code><blockquote><p>对于其它函数的补充</p></blockquote></li></ul><hr><ul><li><p>声明函数的基本格式为: <code>void funtion_name (void) {函数内容}</code></p><blockquote><p>圆括号内所声明的参数可称其为形式参数，即为没有值，但有数据类型的变量数据类型<br>前者的void为函数本身的数据类型，最常用的是整形类型或长整型类型<br>函数的类型用于声明让函数实现的功能模块</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li><p>每个函数或每个花括号都可以被称为是代码块</p></li><li><p>写程序的大体逻辑</p></li></ul><ol><li>先将常量和全局变量声明完毕</li><li>进行函数声明</li><li>然后先写上主函数</li><li>再对函数进行补充，以实现其对应功能</li><li>最后再主函数中的内容进行补充(通常就是对已存在的函数进行进行逐一调用)</li><li>编译源代码并执行程序</li></ol><ul><li>在计算机内，一切的执行逻辑都是线性的</li></ul><hr><ul><li><p>条件表达式与条件语句的本质就是判断值的真假或称其为0或1，用更大的范围去描述则是0与任何实数，即0就是假，或称其为无，其它的任何数都是真，或称其为有</p></li><li><p>无论是循环语句，选择语句还是任何的控制语句(流程控制语句)，它们存在(或称其为存在)的意义都是为了对所选条件表达式的值进行判断，而判断的结果只有两个，即为0与1</p></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编写代码，从而使代码更加整洁与美观</li><li>千万不要忘了伪代码的概念，一般的思路梳理就是对所谓伪代码的实现</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 12 2020 19:17:52 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-4</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/</id>
    <published>2020-03-12T01:55:21.000Z</published>
    <updated>2020-03-12T11:17:45.381Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 12 2020 19:17:52 GMT+0800 (中国标准时间) --><center><strong>数据类型-运算符与表达式-1</strong></center><a id="more"></a><h2 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型-4"></a>数据类型-4</h2><ul><li>重点为运算符与表达式</li></ul><hr><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p><strong>涉及概念:</strong></p><ul><li>一元运算符</li><li>二元运算符</li><li>左值与右值</li><li>表达式和语句</li><li>基本循环及其符合语句</li><li>副作用与序列点</li></ul><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p><strong>右值</strong></p><ul><li><p>右值(rvale)，通常只能是字面常量</p><blockquote><p>而字面常量不能常量赋值，因为常量本身就是它的值<br>因此，在使用赋值运算符=时，左侧的项必须是一个变量名<br>实际上，赋值运算符左侧必须引用一个存储位置，而最简单方法就是使用变量名<br>不过指针也可用于指向一个存储位置<br>概括地说，C 使用可修改的左值(modifiable lvalue)标记那些可赋值的实体(物理内存)</p></blockquote></li><li><p>术语概览: 数值对象，左值，右值和运算符</p></li><li><p>赋值表达式语句的目的是把值存储到内存位置上</p></li><li><p>用于存储值的数据存储区域被称之为对象(data object)</p></li><li><p>C 标准中只有提到赋值的概念时，才有可能涉及到对象这个术语</p></li><li><p>使用变量名是表示对象的唯一方法，除此之外还有其它的方法，例如指定数组的元素，结构的成员，或者使用指针表达式(指针中存储的是它所指对象的地址)</p></li><li><p>相关的具体细节这里不做过多阐述</p></li></ul><p><strong>左值</strong></p><ul><li><p>左值(lvalue)是C的术语，用于表示特定数据对象的名称或表达式</p><blockquote><p>因此，对象指的是实际的数据存储，而左值是用于表示或定位存储位置的标签</p></blockquote></li><li><p>对于早期的C，左值所涉及的意义:</p></li></ul><ol><li>它指定一个对象，所以引用内存中的地址</li><li>它可以在赋值运算符的左侧，左值(lvalue)中的l源自left</li></ol><ul><li>但后来的C标准中新增了const限定符，用const创建的变量为只读变量，即为不可修改<blockquote><p>因此，const标识符可以满足上面的第一项，而无法满足第二项<br>一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧<br>有些左值不能用于赋值运算符的左侧，因此，标准对左值的定义已经不能满足当前的状况<br>为此，C标准新定义了一个术语: 可修改的左值(modifable lvalue)，此方法用于标识可修改的对象<br>所以，赋值运算符的左侧应该是可修改的值，当前标准建议，使用术语对象定位值(object locator value)更好</p></blockquote></li></ul><hr><p><strong>右值</strong></p><ul><li><p>右值(rvalue)指的是能赋值给可修改左值的量，且本身不是左值</p><blockquote><p>右值中的r源自right</p></blockquote></li><li><p>右值可以是常量，变量或其它可求值的表达式(如，函数调用)</p><blockquote><p>实际上，当前标准在描述这一概念时使用的是表达式的值(value of an expression)，而非右值<br>右值示例: bmw = 2002;，此时的2002则为右值</p></blockquote></li><li><p>左值就是用于引用某指定内存位置的标识符，而右值即为存储于该内存位置的值</p></li><li><p>在名称学习时，被称为”项”(如，赋值运算符左侧的项)的就是运算符对象(operand)</p><blockquote><p>运算对象指的就是运算符操作的对象<br>还可以类似的将”=运算符的左侧对象”称之为是”应该是可修改的左值”</p></blockquote></li></ul><hr><h2 id="基本的算术运算符-一元-二元运算符"><a href="#基本的算术运算符-一元-二元运算符" class="headerlink" title="基本的算术运算符-一元/二元运算符"></a>基本的算术运算符-一元/二元运算符</h2><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul><li>二元运算符最基本的定义是运算对象至少是两个值</li><li>最基本的二元运算符是四则运算标识符</li></ul><p><strong>加法运算符</strong></p><ul><li>加法运算符(addition operator)用于加法运算，使其两侧的值相加<blockquote><p>而相加的值(运算对象)可以是对象，也可以是常量<br>比如 icome = salary + bribes;，计算机会查看加法运算符右侧的两个变量，即为右值，将其相加，然后将相加的和(返回的结果)赋值给变量income<br>这里需要注意的一点是，income，salary，bribes都是可修改的左值，因为每个变量都标识了一个可被赋值的数据对象<br>但是，表达式salary + brives是一个右值</p></blockquote></li></ul><p><strong>减法运算符</strong></p><ul><li>减法运算符(subtraction operator)用于减法运算，使其左侧的数减去右侧的数<blockquote><p>例如，下面的语句把200.0赋给takehome：<br>takehome = 224.00 – 24.00;<br>+和-运算符都被称为二元运算符(binary operator)，即这些运算符需要两个运算对象才能完成操作</p></blockquote></li></ul><hr><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul><li>一元运算符(unary operator)</li><li>一元运算符就是符号运算符，即仅需要运算一个运算对象的运算符<blockquote><p>类似于赋值运算符=，数值标识符-，+(正值与负值)，指针标识符&amp;和*等等</p></blockquote></li></ul><p><strong>符号运算符:-和+</strong></p><ul><li><p>减号还可用于标明或改变一个值的代数符号</p><blockquote><p>rocky = -12;，以这种方式使用的负号被称之为一元运算符</p></blockquote></li><li><p>在C90标准中新增了一元+运算符，它不会改变运算对象的值或符号</p><blockquote><p>只能这样使用: dozen = +12;<br>此时编译器不会报错，但是在以前，这样做是不被允许的</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>二元运算符和一元运算符:</li></ul><img src="/images/数据类型-4/运算符-1.png" width="30%" height="30%"><hr><p><strong>乘法运算符</strong></p><ul><li>符号*表示乘法<blockquote><p><code>cm = 2.56 * inch;</code>，该语句就是用2.56乘以inch，并将结果赋值给cm<br>因为C 内没有平方函数与指数函数，所以只能用循环语句来实现平方与其它指数级增长</p></blockquote></li></ul><p><strong>除法运算符</strong></p><ul><li><p>C使用符号/来表示除法</p></li><li><p>符号/左侧的值是被除数，右侧的值是除数</p><blockquote><p>例如，此表达式中four的值是<code>4.0: four = 12.0/3.0;</code></p></blockquote></li><li><p>整数除法和浮点数除法不同</p><blockquote><p>浮点数除法的结果是浮点数，而整数除法的结果是整数<br>整数是没有小数部分的数<br>这使得5除以3很让人头痛，因为实际结果有小数部分</p></blockquote></li><li><p>在C语言中，整数除法结果的小数部分被丢弃</p><blockquote><p>这一过程被称为截断(truncation)</p></blockquote></li><li><p>一般情况下最好避免混合类型的出现，即同一个除法表达式内同时出现整数与浮点数</p><blockquote><p>因为计算机不能真正的使用浮点数去除以整数，所以编译器会把两个运算对象转换成相同的类型<br>即在进行出发运算之前，将整数转换为浮点数，或将浮点数转换为整数</p></blockquote></li><li><p>在C99标准以前，C语言给语言的实现者留有一些空间</p><blockquote><p>让他们来决定如何进行负数的整数除法<br>一种方法是，舍入过程采用小于或等于浮点数的最大整数<br>当然，对于<code>3.8</code>而言，处理后的3符合这一描述<br>但是当需要处理<code>-3.8</code>时，该方法建议四舍五入为<code>-4</code><br>因为<code>-4</code> 小于<code>-3.8</code><br>但是，另一种舍入方法是直接丢弃小数部分<br>这种方法被称为”趋零截断”，即把<code>-3.8</code>转换成<code>-3</code><br>在C99以前， 不同的实现采用不同的方法<br>但是C99规定使用趋零截断<br>所以，应把-<code>3.8</code>转换成<code>-3</code></p></blockquote></li></ul><hr><ul><li>当同一个表达式内出现了多种不同种类的运算符时，运算符会出现优先级限制</li></ul><p><strong>图片说明:</strong></p><ul><li>目前为止文章内涉及的运算符优先级(从低至高):</li></ul><img src="/images/数据类型-4/运算符优先级-1.png" width="30%" height="30%"><ul><li>优先级和求值顺序<blockquote><p>运算符的优先级为表达式中的求值顺序提供了重要的依据，但是并没有规定所有的顺序<br>所以 C 给实现者留出了选择的余地</p></blockquote></li></ul><hr><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><ul><li>C 中有大约40个运算符，有些运算符比其它运算符常用的多<blockquote><p>这里只对最常用的运算符进行讨论</p></blockquote></li></ul><p><strong>sizefo运算符与其相关类型</strong></p><ol><li>sizeof运算符和<code>size_t</code>类型<blockquote><p>sizeof运算符以字节为单位返回运算对象的大小(在C中，1字节定义为char类型占用的空间大小)<br>过去，1字节通常是8位，但是一些字符集可能使用更大的字节<br>运算对象可以是具体的数据对象(如，变量名)或类型<br>如果运算对象是类型(如， float)，则必须用圆括号将其括起来</p></blockquote></li></ol><ul><li>C 规定，sizeof返回<code>size_t</code>类型的值<blockquote><p>这是一个无符号整数类型， 但它不是新类型</p></blockquote></li><li><code>size_t</code>是语言定义的标准类型<blockquote><p>C 有一个typedef机制<br>允许程序员为现有类型创建别名<br>例如:<br><code>typedef double real;</code><br>这样，real就是double的别名</p></blockquote></li><li>现在，可以声明一个real类型的变量:<blockquote><p><code>real deal; // 使用typedef</code><br>编译器查看real时会发现，在typedef声明中real已成为double的别名<br>于是把deal创建为double 类型的变量<br>类似地，C 头文件系统可以使用typedef把<code>size_t</code>作为<code>unsigned int</code>或<code>unsigned long</code>的别名<br>这样，在使用<code>size_t</code>类型时，编译器会根据不同的系统替换标准类型</p></blockquote></li><li>C99 做了进一步调整，新增了<code>%zd</code>转换说明用于<code>printf()</code>显示<code>size_t</code>类型的值<blockquote><p>如果系统不支持<code>%zd</code>，可使用<code>%u</code>或<code>%lu</code>代替<code>%zd</code></p></blockquote></li></ul><hr><p><strong>求模运算符</strong></p><ol start="2"><li>求模运算符(modulus operator): <code>%</code></li></ol><ul><li><p>用于整数运算</p></li><li><p>求模运算符给出其左侧整数除以右侧整数的余数(remainder)</p><blockquote><p>例如，<code>13 % 5</code>(读作”13求模5”)得3，因为13比5的两倍多3，即13除以5的余数是3<br>求模运算符只能用于整数，不能用于浮点数</p></blockquote></li><li><p>求模运算符常用于控制程序流</p><blockquote><p>例如，假设此时正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用<br>这种情况可以在程序中对月份求 模3(即，month % 3)，并检查结果是否为0<br>如果为0，便加进额外的费用</p></blockquote></li><li><p>求模运算符作得出的结果就是所谓的取余运算所得出的结果</p></li><li><p>负数也可以进行求模运算，于C99开始支持了趋零截断</p></li></ul><hr><p><strong>递增运算符</strong></p><ul><li><p>递增运算符(increment operator)-即为’++’</p></li><li><p>用于执行简单的任务，将其运算对象递增1</p><blockquote><p>该运算符以两种方式出现<br>第1种方式，++出现在其作用的变量前面， 这是前缀模式<br>第2种方式，++出现在其作用的变量后面，这是后缀模式<br>两种模式的区别在于递增行为发生的时间不同</p></blockquote></li></ul><hr><p><strong>while循环的执行逻辑</strong></p><ul><li>根据所规定条件，对条件进行循环执行</li><li>例如规定了一个条件为<code>shoe &lt; 18</code>，并且每执行一次就进行一次递加(++)的表达式<blockquote><p>执行的逻辑是shoe的值递增1，然后和18进行比较，如果递增后的值小于18，则再次执行所规定的循环条件(即为所在花括号内的所有语句)<br>然后，shoe的值再递增1，以此重复刚才的不做，知道shoe的值不小于18为止</p></blockquote></li></ul><p><strong>图解示意:</strong></p><ul><li>执行一次循环:</li></ul><img src="/images/数据类型-4//images/while循环-1.png" width="30%" height="30%"><hr><p><strong>关于前缀递增和后缀递增</strong></p><ul><li><p>这里举一个例子:</p><blockquote><p><code>q = 2*++a;</code>，此语句为前缀形式递增，首先，a递增1，然后，2乘以a，并将结果赋给q<br><code>q =2*a++;</code>，此语句为后缀形式递增，首先，2乘以a，并将结果赋给q，然后，a递增1</p></blockquote></li><li><p>单独使用递增运算符时(如，ego++;)，使用哪种形式都没关系</p><blockquote><p>但是，当运算符和运算对象是更复杂表达式的一部分时(如上面的示例)<br>使用前缀或后缀的效果不同</p></blockquote></li></ul><hr><p><strong>递减运算符</strong></p><ul><li><p>每种形式的递增运算符都有一个递减运算符(decrement operator)与之对应</p></li><li><p>用–代替++即可:</p><blockquote><p><code>--count; // 前缀形式的递减运算符</code><br><code>count--; // 后缀形式的递减运算符</code></p></blockquote></li><li><p><code>&gt;</code>运算符表示”大于”，<code>&lt;</code>运算符表示”小于”，它们都是关系运算符(relational operator)</p></li></ul><hr><p><strong>递增运算符的优先级问题</strong></p><ul><li>递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高<blockquote><p>因此，<code>x*y++</code>表示的是<code>(x)*(y++)</code>，而不是<code>(x+y)++</code><br>不过后者无效，因为递增和递减运算符只能影响一个变量(或者更普遍地说，只能影响一个可修改的左值)<br>而组合<code>x*y</code>本身不是可修改的左值</p></blockquote></li></ul><hr><p><strong>不要自作聪明</strong></p><ul><li>如果一次用太多递增运算符，自己都会糊涂-CN-C Primer Plus-第5.3.6章节</li></ul><hr><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>术语: 表达式(expression)和语句(statement)</li><li>C 的基本程序步骤由语句组成，而大多数语句都由表达式构成</li></ul><p><strong>表达式:</strong></p><ul><li><p>表达式(expression)由运算符和运算对象组成(运算对象是运算符操作的对象)</p><blockquote><p>最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式</p></blockquote></li><li><p>运算对象可以是常量，变量或二者的组合</p><blockquote><p>一些表达式由子表达式(subexpression)组成(子表达式即较小的表达式)</p></blockquote></li><li><p>每个表达式都有一个值</p><blockquote><p>C 表达式的一个最重要的特性是，每个表达式都有一个值<br>要获得这个值，必须根据运算符优先级规定的顺序来执行操作<br>关于表达式的值的具体描述这里不做赘述，因为它是一个范围极大的纯粹性概念<br>计算机中表达式的概念与数学中的表达式相同，值即为表达式的结果</p></blockquote></li></ul><hr><p><strong>语句</strong></p><ul><li><p>语句(statement)是C程序的基本构建块</p><blockquote><p>一条语句相当于一条完整的计算机指令<br>在C中，大部分语句都以分号<code>&#39;;&#39;</code>结尾</p></blockquote></li><li><p>声明创建了名称和类型，并为其分配内存位置</p><blockquote><p>注意，声明不是表达式语句<br>也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值:<br><code>int port /* 不是表达式，没有值 */</code></p></blockquote></li><li><p>赋值表达式语句在程序中很常用: 它为变量分配一个值</p><blockquote><p>赋值表达式语句的结构是: 一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾<br>注意，在while循环中有一个赋值表达式语句<br>赋值表达式 语句是表达式语句的一个示例</p></blockquote></li><li><p>函数表达式语句会引起函数调用</p><blockquote><p>在该例中，调用printf()函数打印结果<br>while语句有3个不同的部分: 首先是关键字while，然后圆括号中是待测试的条件，最后如果测试条件为真，则执行while循环体中的语句<br>多条语句需要用花括号括起来</p></blockquote></li><li><p>图片-简单的while循环结构:</p></li></ul><img src="/images/数据类型-4/while循环-2.png" width="30%" height="30%"><ul><li>这种语句是复合语句<blockquote><p>该例的while循环中只有一条语句<br>可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句<br>while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂</p></blockquote></li></ul><hr><p><strong>关于副作用与序列点:</strong></p><ul><li>类似于while之类的迭代循环语句通常还会有副作用(side effect)和序列点(sequence point)等概念，这里不做过多赘述<blockquote><p>所谓的副作用，就是对于变量的赋值结果(此间的赋值结果由右值的表达式决定)<br>或称其为经由人工定义所得出的等式结果<br>所谓的序列点，就是程序执行的点，再该点上，所有的副作用都在进入下一步之前发生<br>C 中的语句用分号<code>&#39;;&#39;</code>来标记若干个序列点<br>其寓意就是在一个语句中，赋值运算符，递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成<br>还有一点就是，任何一个完整表达式的结束也是一个序列点</p></blockquote></li></ul><p><strong>关于完型表达式:</strong></p><ul><li>完整表达式(full expression)<blockquote><p>就是指这个表 达式不是另一个更大表达式的子表达式<br>例如，表达式语句中的表达式和while循环中的作为测试条件的表达式<br>都是完整表达式<br>序列点有助于分析后缀递增何时发生<br>千万要避免写出带有模棱两可逻辑的语句</p></blockquote></li></ul><p><strong>关于复合语句(块)</strong></p><ul><li><p>复合语句(compound statement)是用花括号括起来的一条或多条语句</p><blockquote><p>或称之为复合语句(或块)由花括号括起来的一条或多条语句组成<br>复合语句也称为块(block)<br>任何的程序都可以使用块以让while语句包含多条语句<br>在声明与描述复合语句的构成时，需要注意书写风格，其中最重要的是对于代码缩进的掌控</p></blockquote></li><li><p>图片-带有符合语句的while循环</p></li></ul><img src="/images/数据类型-4/while循环-3.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>一般函数的形式: void xxx(void)<br>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参<br>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)<br>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p><p>关于实参和形参的其它说明:</p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p>关于函数的调用:</p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-1-1"><a href="#补充内容-1-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p>一般函数的形式: void xxx(void)</p><blockquote><p>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p></blockquote></li><li><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参</p><blockquote><p>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p></blockquote></li><li><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)</p><blockquote><p>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p></blockquote></li></ul><p><strong>关于实参和形参的其它说明:</strong></p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p><strong>关于函数的调用:</strong></p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-2"><a href="#补充内容-2" class="headerlink" title="补充内容-2"></a>补充内容-2</h3><ul><li>C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符<blockquote><p>一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值<br>只需要一个 运算对象的运算符(如负号和sizeof)称为一元运算符，需要两个运算对象的运算符(如加法运算符和乘法运算符)称为二元运算符</p></blockquote></li><li>表达式由运算符和运算对象组成<blockquote><p>在C语言中，每个表达式都有一个 值，包括赋值表达式和比较表达式<br>运算符优先级规则决定了表达式中各项 的求值顺序<br>当两个运算符共享一个运算对象时，先进行优先级高的运算<br>如果运算符的优先级相等，由结合律(从左往右或从右往左)决定求值顺序</p></blockquote></li><li>大部分语句都以分号结尾<blockquote><p>最常用的语句是表达式语句</p></blockquote></li><li>用花括号括起 来的一条或多条语句构成了复合语句(或称为块)</li><li>while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句</li><li>在C语言中，许多类型转换都是自动进行的<blockquote><p>当char和short类型出现在 表达式里或作为函数的参数(函数原型除外)时，都会被升级为int类型<br>float类型在函数参数中时，会被升级为double类型<br>在K&amp;R C(不是ANSI C)下，表达式中的float也会被升级为double类型<br>当把一种类型的值赋给 另一种类型的变量时，值将被转换成与变量的类型相同<br>当把较大类型转换 成较小类型时(如，long转换成short，或 double 转换成 float)，可能会丢失数据<br>根据之前介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型</p></blockquote></li><li>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数<blockquote><p>然后，在函数调用中传入的值会被赋给这个变量<br>这样，在函数中 就可以使用该值了</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 12 2020 19:17:52 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-运算符与表达式-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-3</title>
    <link href="https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3/"/>
    <id>https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3/</id>
    <published>2020-03-11T12:31:21.000Z</published>
    <updated>2020-03-11T22:52:25.056Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 12 2020 06:54:10 GMT+0800 (中国标准时间) --><center><strong>数据类型-数组/字符串类型-1</strong></center><a id="more"></a><h3 id="数据类型-3"><a href="#数据类型-3" class="headerlink" title="数据类型-3"></a>数据类型-3</h3><ul><li>数据类型/派生类型/数组/字符串</li><li>字符串存储原理</li><li>数组存储原理</li></ul><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>概述:</strong></p><ul><li>字符串(character string)</li><li>本质上是一个或多个字符的序列，即为字符数据类型的数组，可表示为”xxx yyy”</li><li>双引号不是字符串的一部分，双引号只是用于告知编译器括起来的是字符串，正如单引号用于标识单个字符</li></ul><p><strong>char类型数组和null字符</strong></p><ul><li>因为 C 中没有专门用于存储字符串的变量类型，所以字符串都被存储在char类型的数组当中</li><li>数组由连续的存储单元构成，所以字符串中的字符类型都被存储在相邻的存储单元中，即每个单元存储一个字符</li></ul><p><strong>具体图示</strong></p><ul><li>数组中的字符串:</li></ul><img src="/images/字符串-1.png" width="30%" height="30%"><ul><li>这里需要注意的是图片中数组末尾的字符<code>\0</code><blockquote><p>这是空字符(null character)，C内用它来标记字符串的结束<br>空字符并非数字0，它是非打印字符，其ASCII码值是(或称其为等价于)0<br>所以C中的字符串一定以空字符结束，即意味着数组的容量必须比至少比带存储字符串中的字符数多1<br>因此，在一个有若干个存储单元的字符串中，只能存储若干字符串数量减一个字符，剩下一个字节留给空字符</p></blockquote></li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概述:</strong></p><ul><li>可以将数组看作是一行连续的多个存储单元</li><li>或称为数组是同类型数据元素的有序序列</li><li>这里用一个包含着40个存储单元(每个单元存储一个char类型的值)且已被创建(已存在)的数组来举例<blockquote><p><code>char name[40];</code><br>name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量，char用于表示每个元素的类型</p></blockquote></li></ul><p><strong>具体图解</strong></p><ul><li>声明一个变量和声明一个数组:</li></ul><img src="/images/字符串声明-1.png" width="30%" height="30%"><ul><li>字符串就是在拥有一个数组的前提下，把字符串中的字符逐个放入数组，同时还要记得在末尾加上一个<code>\0</code><blockquote><p>好在计算机可以自己去处理这些细节问题</p></blockquote></li></ul><hr><ul><li>用格式化输出标识符<code>%s</code>来格式化输出字符串类型，但scanf()函数只会读取字符串中的一个单词，而非整个句子<blockquote><p>此时需要用到其它的输入函数，如<code>fgets()</code>，以用于读取一般的字符串<br>因为本质是由基本字符类型构成的数组，所以字符串的打印顺序与所存储的内存地址也是与字符类型相同的<br>即为完全线性</p></blockquote></li></ul><hr><h3 id="字符串和字符的区别"><a href="#字符串和字符的区别" class="headerlink" title="字符串和字符的区别"></a>字符串和字符的区别</h3><ul><li>字符串常量”x”和字符常量’x’完全不同</li><li>区别之一是在于’x’是基本类型char<blockquote><p>而”x”是派生类型char 数组</p></blockquote></li><li>区别之二是”x”实际上是由两个字符组成的，即为’x’和空字符<code>\0</code></li></ul><p><strong>图片描述:</strong></p><ul><li>字符’x’和字符串”x”:</li></ul><img src="/images/字符和字符串的区别-1.png" width="30%" height="30%"><hr><h3 id="strlen-方法-函数"><a href="#strlen-方法-函数" class="headerlink" title="strlen()方法(函数)"></a>strlen()方法(函数)</h3><ul><li><p>用于输出给出字符串中的字符长度</p></li><li><p>因为1字节存储一个字符，所以给人最直观的感受就是与sizeof运算符(以字节为单位给出对象的大小)的输出相同，但事实绝非如此</p></li><li><p>使用<code>strlen()</code>方法(函数)时需要先对头文件<code>string.h</code>进行预处理<code>#include</code>，以对其进行支持</p></li><li><p>当被定义数组内有40个存储单元，但是只用了不到40个单元用于存储被输入字符串</p><blockquote><p>此时<code>strlen()</code>方法得出的结果是被存储字符串的字符长度，当为11时，即为11个<br>但数组内还需要多出来一个单元用于存储空字符，但<code>strlen()</code>方法并不会将其计入</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>strlen()函数知道在何处停止:</li></ul><img src="/images/strlen机制说明-1.png" width="30%" height="30%"><p><strong>strlen()与sizeof运算符方法的区别</strong></p><ul><li><p>假如让<code>strlen()</code>方法去存储一个常量字符串，<code>strlen()</code>方法将会只返回字符串中的字符(包括空格和标点符号)</p></li><li><p>但是<code>sizeof</code>运算符将会把字符串末尾不可见的空字符也算在内</p></li><li><p><code>sizeof</code>运算符和<code>strlen()</code>方法的格式化输出标识符是通用的，即为<code>%zd</code>转换说明</p><blockquote><p>并且<code>sizeof</code>和<code>strlen()</code>返回的实际类型通常是<code>unsigned</code>或<code>unsigned long</code></p></blockquote></li><li><p><code>sizefo</code>后加不加圆括号取决于运算对象是类型还是特定量</p><blockquote><p>对于类型需要写为类似于<code>sizeof(char)</code>的形式<br>而对于特定量，则可以写成<code>sizeof name</code>的形式<br>只不过每种形式都可以加上圆括号，可以为了增加可读性而去这么做</p></blockquote></li></ul><hr><h3 id="define"><a href="#define" class="headerlink" title="[#define]"></a>[#define]</h3><p><strong>常量和 C 预处理器</strong></p><ul><li><p>如果将全局变量当成常量，程序可能会在无意之间修改它的值</p></li><li><p>所以 C 中为此提供了C 预处理器，预处理器可以用来定义常量</p></li><li><p>基本语法与使用:</p><blockquote><p><code>#define NAME value</code><br><code>#define XXX 0.001</code><br>此时程序中的所有XXX都会被替换称0.001，这一过程被称之为编译时替换(compile-time substitution)<br>通常在运行程序时，程序中所有的替换就均已完成，这样定义常量可将其称之为明示常量(manifest constant)<br>因为预处理器处理的替换机制，所以末尾不用加分号</p></blockquote></li><li><p>在 C 中还有一个约定成俗的规定，常量的命名最好是大写，以便区分程序中其它的变量</p><blockquote><p>另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量(如，<code>c_level</code>或<code>k_line</code>)</p></blockquote></li><li><p>符号常量的命名规则与变量相同，即可以使用大小写的字母，数字，下划线和首位字符不能为数字</p></li><li><p><code>#define</code>指令还可用于定义字符和字符串常量，前者用单引号，后者用双引号</p><blockquote><p>即为<code>#define BEEP &#39;\a&#39;</code>或<code>#define TEE &#39;T&#39;</code><br>需要注意的就是符号常量后面的内容用来代替符号常量</p></blockquote></li></ul><hr><p><strong>const限定符</strong></p><ul><li><p>const关键字于C90标准添加，用于限定一个变量为只读</p></li><li><p>作用与<code>#define</code>相同，并且比其更灵活</p></li><li><p>基本语法:</p><blockquote><p><code>const int XXX = 10</code><br>此时XXX在程序中不可更改，其值为10</p></blockquote></li></ul><hr><p><strong>明示常量:</strong></p><h3 id="limits-h"><a href="#limits-h" class="headerlink" title="limits.h"></a>limits.h</h3><ul><li><p>C内的每个头文件都定义了一系列供实现使用的明示常量</p><blockquote><p>比如C的头文件<code>limits.h</code>和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息</p></blockquote></li><li><p>而<code>limits.h</code>头文件包含了以下类似的代码</p><blockquote><p><code>#define INT_MAX +32767</code><br><code>#define INT_MIN -32768</code><br>这些明示常量代表<code>int类型</code>可表示的最大值和最小值<br>如果系统使用32位的int，该头文件会为这些明示常量提供不同的值</p></blockquote></li><li><p>如果在程序中包含<code>limits.h</code>头文件，就可编写下面的代码:</p><blockquote><p><code>printf(&quot;Maximum int value on this system = %d\n&quot;, INT_MAX);</code><br>如果系统使用4字节的int，<code>limits.h</code>头文件会提供符合4字节int的<code>INT_MAX和INT_MIN</code><br>以下表图片内列出了<code>limits.h</code>中能找到的一些明示常量<br>文章内会对每个头文件的内部构成与使用方法进行刨析<br>每种类型的头文件在系统内的C标准库内都有明确的说明</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li><code>limits.h</code>中的一些明示常量</li></ul><img src="/images/C-头文件/C-limits.h头文件-1.png" width="30%" height="30%"><hr><h3 id="float-h"><a href="#float-h" class="headerlink" title="float.h"></a>float.h</h3><ul><li>类似地，<code>float.h</code>头文件中也定义一些明示常量<blockquote><p>如<code>FLT_DIG和 DBL_DIG</code>，分别表示<code>float类型</code>和<code>double类型</code>的有效数字位数<br>以下表图片内列出了<code>float.h</code>中的一些明示常量(可以使用文本编辑器打开并查看系统使用的float.h头文件)<br>表中所列都与float类型相关<br>把明示常量名中的FLT分别替换成DBL和LDBL<br>即可分别表示double和long double类型对应的明示常量(表中假设系统使用2的幂来表示浮点数)</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>float.h中的一些明示常量:</li></ul><img src="/images/C-头文件/C-float.h头文件-1.png" width="30%" height="30%"><ul><li>编译器要完全支持C99标准才能识别<code>LLONG_MIN</code>标识符</li></ul><hr><h3 id="printf-方法与scanf-方法"><a href="#printf-方法与scanf-方法" class="headerlink" title="printf()方法与scanf()方法"></a>printf()方法与scanf()方法</h3><p><strong>概述:</strong></p><ul><li><code>printf()</code>函数和<code>scanf()</code>函数能让用户可以与程序实现交互<blockquote><p>它们是基本/标准的输入/输出函数，或简称为I/O函数<br>其除了I/O功能，还有很多其它的功能<br>因为考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()，尽管如此，各版本之间偶尔有一些差异<br>而C90 和C99 标准规定了这些函数的标准版本<br>虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同<br>两个函数都使用格式字符串和参数列表</p></blockquote></li></ul><hr><p><strong>printf()</strong></p><ul><li><p>请求<code>printf()</code>函数打印数据的指令要与待打印数据的类型相匹配</p><blockquote><p>例如， 打印整数时使用<code>%d</code>，打印字符时使用<code>%c</code><br>这些符号被称为转换说明(conversion specification)，即为格式化输出标识符<br>它们指定了如何把数据转换成可显示的形式。</p></blockquote></li><li><p>以下列表图片为ANSI C标准为<code>printf()</code>提供的转换说明与搁置相对应的输出类型</p></li><li><p>转换说明及其打印的输出结果:</p></li></ul><img src="/images/C-标准库/C-printf函数-1.png" width="30%" height="30%"><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li>格式字符串包含两种形式不同的信息:<blockquote><p>实际要打印的字符<br>与转换说明</p></blockquote></li></ul><p><strong>图片说明:</strong></p><ul><li>printf()的参数</li></ul><img src="/images/printf格式-1.png" width="20%" height="20%"><ul><li>剖析格式字符串图片:</li></ul><img src="/images/字符串格式-1.png" width="20%" height="20%"><ul><li>格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果</li></ul><hr><p><strong>printf()的转换说明修饰符</strong></p><ul><li>在%和转换字符之间插入修饰符可修饰基本的转换说明</li><li>转换说明修饰符类型的可移植性需要特别注意</li><li>整数类型和浮点数类型使用不同类型的转换类型</li><li>关于转换说明修饰符的列表这里不做过多阐述</li><li>可参考[C Primer Plus 第6版-中文版]-第201页</li></ul><hr><p><strong>转换说明的意义:</strong></p><ul><li><p>转换说明把以二进制格式储存在计算机中的值转换成一系列字符(字符串)以便于显示</p><blockquote><p>例如，数字76在计算机内部的存储格式是二进制数01001100<br><code>%d</code>转换说明将其转换成字符7和6，并显示为76<br><code>%x</code>转换说明把相同的值(01001100)转换成十六进制记数法4c<br><code>%c</code>转换说明把01001100转换成字符L</p></blockquote></li><li><p>转换(conversion)可能会误导读者认为原始值被转替换成转换后的值</p><blockquote><p>实际上，转换说明是翻译说明<br><code>%d</code>的意思是”把给定的值翻译成十进制整数文本并打印出来”</p></blockquote></li></ul><hr><h3 id="scanf-方法简述"><a href="#scanf-方法简述" class="headerlink" title="scanf()方法简述"></a>scanf()方法简述</h3><ul><li><p>输入函数-scanf()</p><blockquote><p>scanf()是最通用的一个输入函数，因为其可以读取不同格式的数据</p></blockquote></li><li><p>如果要将其储 存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的</p></li><li><p>scanf()把输入的字符串转换成整数，浮点数，字符或字符串</p><blockquote><p>而printf()正好与它相反，把整数，浮点数，字符和字符串转换成显示在屏幕上的文本</p></blockquote></li><li><p>scanf()和printf()类似，也使用格式字符串和参数列表</p><blockquote><p>scanf()中的格式 字符串表明字符输入流的目标数据类型<br>两个函数主要的区别在参数列表中<br>printf()函数使用变量，常量和表达式，而scanf()函数使用指向变量的指针<br>关于指针的两条最简单的规则:<br>如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;<br>如果用scanf()把字符串读入字符数组中，不要使用&amp;</p></blockquote></li><li><p>scanf()函数使用空白(换行符，制表符和空格)把输入分成多个字段</p><blockquote><p>在依次把转换说明和字段匹配时跳过空白</p></blockquote></li><li><p>scanf()函数所用的转换说明与printf()函数几乎相同</p><blockquote><p>主要的区别是，对 于float类型和double类型<br>printf()都使用<code>%f</code>,<code>%e</code>,<code>%E</code>,<code>%g</code>和<code>%G</code>转换说明<br>而scanf()只把它们用于float类型，对于double类型时要使用l修饰符</p></blockquote></li><li><p>C99-ANSI C中scanf()的转换说明这里不做过多赘述，可参考书籍</p></li><li><p>scanf()进入输入的原理与对应的物理模式这里不做阐述，将来会对其进行补充</p><blockquote><p>转换符和I/O函数不需要学的特别细，具体的使用和记忆可以在实践中执行</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 12 2020 06:54:10 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-数组/字符串类型-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-2</title>
    <link href="https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/"/>
    <id>https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/</id>
    <published>2020-03-11T05:15:27.000Z</published>
    <updated>2020-03-11T12:36:44.806Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Mar 11 2020 20:36:49 GMT+0800 (中国标准时间) --><center><strong>存储原理-算术类型-1</strong></center><a id="more"></a><h2 id="基本数据类型存储原理"><a href="#基本数据类型存储原理" class="headerlink" title="基本数据类型存储原理"></a>基本数据类型存储原理</h2><ul><li>数据类型系统-基本类型</li><li>算术类型，其包含了整数类型与浮点类型</li><li>这里的数值大小以 C 的 C11 标准为例<blockquote><p>C 标准对基本数据类型只规定了允许的最小大小</p></blockquote></li></ul><hr><ul><li>常用基本数据类型占用空间(64位机器为例)</li></ul><ol><li>整数类型/char: 1个字节</li><li>整数类型/int: 4个字节</li><li>浮点类型/float: 4个字节</li><li>浮点类型/double: 8个字节</li></ol><ul><li>以 ISO C 标准为例<blockquote><p>此规定规定int的取值范围最小为<code>-32768～32767</code></p></blockquote></li></ul><hr><h2 id="整数存储原理"><a href="#整数存储原理" class="headerlink" title="整数存储原理"></a>整数存储原理</h2><ul><li>在计算机内的整数与数学一样，即为没有小数部分的实数</li><li>计算机以二进制数字的模式来存储整数</li><li>存储的位置即为变量标识符所对应的内存地址，与其指令集所指的CPU寄存器</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>同时还可将其称之为数据类型系统的基本类型部分</li><li>被归纳于算术类型，包括了整数类型与浮点类型</li><li>这里以C为例</li><li>C语言中的整数类型可表示不 同的取值范围和正负值，一般情况使用int类型即可，但是为满足特定任务和 机器的要求，还可以选择其他类型</li><li>int类型是有符号整型，即int类型的值必须是整数，可以是正整数，负整数或零</li><li>一般而言，储存一个int要占用一个 机器字长</li><li>声明之后便为被声明的若干个int大小的变量赋予名称并分配内存空间</li><li>可以赋值或初始化变量(initialize)</li><li>简而言之，声明为变量创建和标记存储空间，并为其指定初始值</li><li>C语言把大多数整型常量视为int类型，但是非 常大的整数除外</li><li>并且int类型拥有常量概念</li></ul><p><strong>声明执行逻辑图示:</strong></p><ul><li>定义并初始化变量:</li></ul><img src="/images/整数类型原理图片/数据类型声明-1.png" width="30%" height="30%"><p><strong>举例说明:</strong></p><ul><li>例如7则以对应的二进制111来存储<blockquote><p>因此，要在8位字节中储存 该数字，需要把前5位都设置成0，后3位设置成1</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>使用二进制编码储存整数7</li></ul><img src="/images/整数类型原理图片/整数类型-1.png" width="30%" height="30%"><hr><h3 id="关于整数值的范围"><a href="#关于整数值的范围" class="headerlink" title="关于整数值的范围"></a>关于整数值的范围</h3><p><strong>整数类型</strong></p><ul><li>下表列出了关于标准整数类型的存储大小和值范围的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr><tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr></tbody></table><ul><li>同时还可以使用sizeof运算符，即表达式sizeof(type)，以获取某个类型或某个变量对象或存储类型在特定硬件平台的准确存储字节大小</li></ul><p><strong>图解说明</strong></p><ul><li>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主<blockquote><p>以下列出了32位系统与64位系统的存储大小的差别(windows 相同):</p></blockquote></li></ul><img src="/images/整数类型原理图片/C-32-64.png" width="30%" height="30%"><hr><h2 id="浮点类型存储原理"><a href="#浮点类型存储原理" class="headerlink" title="浮点类型存储原理"></a>浮点类型存储原理</h2><ul><li><p>在计算机中，浮点数与数学中实数的概念差不多</p></li><li><p>比如<code>2.75</code>,<code>3.16E7</code>,<code>7.00</code>和<code>2e-8</code>都是浮点数，即在一个值后面加上一个小数点，该值就成为一个浮点值</p></li><li><p>所以7是整数，<code>7.00</code>是浮点数</p></li><li><p>e记数法简述: <code>3.16E7</code>表示<code>3.16×10^7</code>，其中E的作用就是10倍原数的对应指数级单位</p></li><li><p>浮点数和整数的储存方案不同</p></li><li><p>计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分</p></li><li><p>在十进制下，可以把7.0写成 0.7E1，但这里，0.7是小数部分，1是指数部分</p></li><li><p>当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂</p></li><li><p>整数没有小数部分，浮点数有小数部分</p></li><li><p>且浮点数可以表示的范围比整数大</p></li><li><p>对于一些算术运算(如，两个很大的数相减)，浮点数损失的精度更多</p></li></ul><p><strong>图示说明:</strong></p><ul><li>一个储存浮点数的例子，以浮点格式(十进制)储存π的值</li></ul><img src="/images/整数类型原理图片/浮点数类型.png" width="30%" height="30%"><ul><li>因为在任何区间内(如，1.0 到 2.0 之间)都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值</li><li>浮点数通常只是实际值的近似值</li><li>例如，7.0可能被储存为浮点值6.99999，稍后讨论精度</li><li>在过去，浮点运算比整数运算慢</li><li>不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距</li></ul><hr><h3 id="关于浮点值的范围"><a href="#关于浮点值的范围" class="headerlink" title="关于浮点值的范围"></a>关于浮点值的范围</h3><p><strong>浮点类型</strong></p><ul><li>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4 字节</td><td align="left">1.2E-38 到 3.4E+38</td><td align="left">6 位小数</td></tr><tr><td align="left">double</td><td align="left">8 字节</td><td align="left">2.3E-308 到 1.7E+308</td><td align="left">15 位小数</td></tr><tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">3.4E-4932 到 1.1E+4932</td><td align="left">19 位小数</td></tr></tbody></table><ul><li>头文件<code>float.h</code>定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节</li></ul><hr><h2 id="C-数据类型转换"><a href="#C-数据类型转换" class="headerlink" title="C 数据类型转换"></a>C 数据类型转换</h2><ul><li>C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型</li><li>在 C 语言中也可以对数据类型进行强制转换</li></ul><p><strong>自动转换规则:</strong></p><ol><li>浮点数赋给整型，该浮点数小数被舍去；</li><li>整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；</li></ol><ul><li>强制类型转换形式: [(类型说明符) (表达式)]</li></ul><hr><h3 id="关于不同进制的说明"><a href="#关于不同进制的说明" class="headerlink" title="关于不同进制的说明:"></a>关于不同进制的说明:</h3><ul><li><p>2进制，8进制和16进制</p></li><li><p>以0为前缀用于表示8进制</p><blockquote><p>比如十进制转换为8进制则为020</p></blockquote></li><li><p>以0x或0X为前缀用于表示16进制</p><blockquote><p>比如十进制数转为16进制则为0x10或0X10</p></blockquote></li><li><p>使用不同的进制是为了方便，其可以完全保证不会影响被存储的方式</p></li><li><p>可以使用标识符<code>%d</code>，<code>%o/%x</code>来分别显示(格式化输出)八进制与十六进制数字</p></li><li><p>而使用标识符<code>%#o</code>，<code>%#x</code>，<code>%#X</code>可以显示各进制的前缀(0，0x和0X)，也就是分别在转换(格式化输出)的说明中假如警号(#)</p></li></ul><hr><ul><li>整数类型还包括char-字符类型与其它的表示符类型，比如像long，short等等，这里先不做过多赘述</li><li>字符类型还包括了字符与字符串(String)的概念</li></ul><hr><p><strong>图片资料补充:</strong></p><ul><li>转义序列(转义标识符)图示:</li></ul><img src="/images/整数类型原理图片/转义标识符-1.png" width="30%" height="30%"><ul><li>int系列类型的常量写法示例:</li></ul><img src="/images/整数类型原理图片/int中的常量写法.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><ul><li><p><code>scanf()</code>函数中的&amp;标识符用于把输入的字符赋值给所对应变量</p><blockquote><p>相当于创建了一个指向变量其它数据对象位置的指针</p></blockquote></li><li><p>而格式化输出标识符(转换符)</p><blockquote><p>类似于<code>%c</code>，<code>%o</code>，<code>%d</code>，<code>%f</code>之类的<br>作用是决定数据的显示方式，而不是存储方式</p></blockquote></li><li><p>数据显示和数据存储的示例图片:</p></li></ul><img src="/images/格式化输出标识符-1.png" width="40%" height="40%"><hr><ul><li>编译器对char的实现也有不同，有的将其实现为有符号类型，即代表char可表示的范围是-<code>128~127</code></li><li>而有些C编译器把char实现为无符号类型，即为表示-<code>0~255</code></li><li>至于想要准确的确定正在使用的编译器是如何实现<code>char类型</code>的，可以去查询相应的编译器手册与<code>limits.sh</code>头文件</li><li>但是根据C90标准，C内允许在char关键字钱使用<code>signed</code>与<code>unsigned</code>标识符，以此来消除编译器对char默认类型的影响</li><li><code>signed char</code>表示有符号类型，而<code>unsigned char</code>表示无符号类型</li></ul><hr><h3 id="类型归纳列表"><a href="#类型归纳列表" class="headerlink" title="类型归纳列表"></a>类型归纳列表</h3><p><strong>基本数据类型</strong></p><ul><li>关键字:</li><li>基本数据类型由11个关键字组成: <code>int</code>、<code>long</code>、<code>short</code>、<code>unsigned</code>、<code>char</code>、 <code>float</code>、<code>double</code>、<code>signed</code>、<code>_Bool</code>、<code>_Complex</code>和<code>_Imaginary</code></li></ul><p><strong>有符号整型:</strong></p><blockquote><p>有符号整型可用于表示正整数和负整数</p></blockquote><ul><li><code>int</code>——系统给定的基本整数类型<blockquote><p>C语言规定<code>int类型</code>不小于16位</p></blockquote></li><li><code>short</code>或<code>short int</code>——最大的<code>short类型</code>整数小于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>short类型</code>至少占16位</p></blockquote></li><li><code>long</code>或<code>long int</code>——该类型可表示的整数大于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>long类型</code>至少占32位</p></blockquote></li><li><code>long long</code>或<code>long long int</code>——该类型可表示的整数大于或等于最大的<code>long类型</code>整数<blockquote><p>Long long类型至少占64位</p></blockquote></li></ul><hr><ul><li>一般而言，<code>long类型</code>占用的内存比<code>short类型</code>大<blockquote><p>int类型的宽度要么和<code>long类型</code>相同，要么和<code>short类型</code>相同<br>例如，旧DOS系统的PC提供16位的short和int，以及32位的long<br>Windows 95系统提供16位的short以及32位的int 和long</p></blockquote></li></ul><hr><p><strong>无符号整型：</strong></p><ul><li><p>无符号整型只能用于表示零和正整数</p><blockquote><p>因此无符号整型可表示的正整数 比有符号整型的大</p></blockquote></li><li><p>在整型类型前加上关键字<code>unsigned</code>表明该类型是无符号整型: <code>unsignedint</code>、<code>unsigned long</code>、<code>unsigned short</code></p><blockquote><p>单独的<code>unsigned</code>相当于<code>unsignedint</code></p></blockquote></li><li><p>字符类型:</p></li><li><p>可打印出来的符号(如A，&amp;和+)都是字符</p><blockquote><p>根据定义，<code>char类型</code>表示 一个字符要占用<code>1字节</code>内存<br>出于历史原因，<code>1字节</code>通常是8位，但是如果要表示基本字符集，也可以是<code>16位</code>或更大</p></blockquote></li><li><p>char——字符类型的关键字<br>》 有些编译器使用有符号的char，而有些则使用无符号的char<br>》 在需要时，可在char前面加上关键字<code>signed</code>或<code>unsigned</code>来指明具体使用哪一种类型</p></li><li><p>布尔类型:</p></li><li><p>布尔值表示<code>true</code>和<code>false</code></p><blockquote><p>C语言用1表示<code>true</code>，0表示<code>false</code></p></blockquote></li><li><p><code>_Bool</code>——布尔类型的关键字</p><blockquote><p>布尔类型是无符号<code>int类型</code>，所占用的空间只要能储存0或1即可</p></blockquote></li><li><p>实浮点类型:</p></li><li><p>实浮点类型可表示正浮点数和负浮点数</p></li><li><p>float——系统的基本浮点类型，可精确表示至少6位有效数字</p></li><li><p>double——储存浮点数的范围(可能)更大，能表示比<code>float类型</code>更多的有效数字(至少 10位，通常会更多)和更大的指数</p></li><li><p>long long——储存浮点数的范围(可能)比double更大，能表示比double更多的有效数字和更大的指数</p></li><li><p>复数和虚数浮点数:</p></li><li><p>虚数类型是可选的类型</p></li><li><p>复数的实部和虚部类型都基于实浮点类型来构成:</p><blockquote><p><code>float _Complex</code><br><code>double _Complex</code><br><code>long double _Complex</code><br><code>float _Imaginary</code><br><code>double _Imaginary</code><br><code>long long _Imaginary</code></p></blockquote></li></ul><hr><h3 id="打印出类型大小"><a href="#打印出类型大小" class="headerlink" title="打印出类型大小"></a>打印出类型大小</h3><ul><li><p><code>sizeof()</code>函数的使用</p></li><li><p>sizeof是 C 的内置运算符，用于以字节为单位给定指定的类型大小</p><blockquote><p>C99和C11提供<code>%zd</code>转换说明匹配sizeof的返回类型<br>而一些不支持C99和C11的编译器可以用<code>%u</code>或<code>%lu</code>来代替<code>%zd</code></p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type int has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type char has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type int has a size of 4 bytes.</span><br><span class="line">Type char has a size of 1 bytes.</span><br><span class="line">Type long has a size of 8 bytes.</span><br><span class="line">Type long long has a size of 8 bytes.</span><br><span class="line">Type double has a size of 8 bytes.</span><br><span class="line">Type long double has a size of 16 bytes.</span><br></pre></td></tr></table></figure></li><li><p>该程序列出了6种类型的大小，也可以把程序中类型换成的其他类型</p><blockquote><p>注意，因为C语言定义了<code>char类型</code>是1字节，所以<code>char类型</code>的大 小一定是1字节<br>而在<code>char类型</code>为16位，<code>double类型</code>为<code>64位</code>的系统中，<code>sizeof</code>给出的<code>double</code>是4字节</p></blockquote></li><li><p>在<code>limits.h</code>和<code>float.h</code>头文件中有类型限制的相关信息</p><blockquote><p>顺带一提，注意该程序最后几行<code>printf()</code>语句都被分为两行<br>只要不在引号内部或一个单词中间断行，就可以这样写</p></blockquote></li></ul><hr><h3 id="printf-方法与scanf-方法补充内容"><a href="#printf-方法与scanf-方法补充内容" class="headerlink" title="printf()方法与scanf()方法补充内容"></a>printf()方法与scanf()方法补充内容</h3><ul><li><p><code>printf()</code>和<code>scanf()</code>函数用第1个参数表明后续有多少个参数</p><blockquote><p>即第1个字 符串中的转换说明与后面的参数一一对应<br><code>printf(&quot;A %d B %f&quot;, xxx, yyy)</code><br>即A对应于xxx，B对应于yyy</p></blockquote></li><li><p>程序员要负责确保转换说明的数量，类型与后面参数的数量，类型相匹配</p><blockquote><p>现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确<br>但是，该机制对<code>printf()</code>和<code>scanf()</code>不起作用，因为这两个函数的参数个数可变</p></blockquote></li></ul><hr><ul><li><p>C语言提供了大量的数值类型，目的是为程序员提供方便</p><blockquote><p>那以整数类型为例，C认为一种整型不够，提供了有符号，无符号，以及大小不同的整型，以满足不同程序的需求</p></blockquote></li><li><p>计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别</p><blockquote><p>即使两个32位存储单元储存的位组合完全相同，但是一个解释为<code>float类型</code>，另一个解释为<code>long类型</code><br>这两个相同的位组合表示的值也完全不同。<br>例如，在PC中，假设一个位组合表示<code>float类型</code>的数256.0<br>如果将其解释为<code>long类型</code>，得到的值是113246208<br>C语言允许编写混合数据类型的表达式， 但是会进行自动类型转换<br>以便在实际运算时统一使用一种类型</p></blockquote></li><li><p>计算机在内存中用数值编码来表示字符</p><blockquote><p>美国最常用的是<code>ASCII码</code>，除此之外C也支持其他编码<br>字符常量是计算机系统使用的数值编码的符号表示<br>它表示为单引号括起来的字符，如<code>&#39;A&#39;</code></p></blockquote></li><li><p>需要完全理解通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型</p></li><li><p>浮点数可以写成固定的小数点的形式或指数形式，C99和C11提供了第三章的表示方法，即用十六进制数和二的幂来表示(如，<code>0xa.1fp10</code>)</p></li><li><p>C语言中用单引号<code>&#39; &#39;</code>来表示字符常量，还有转义序列的概念(<code>&#39;\n&#39;</code>)，另外，还可以在八进制和十六进制数前面加上一个反斜杠(如: ‘\007’)，用以表示ASCII码中的一个字符</p></li><li><p>还可可移植数据类型等概念</p><blockquote><p>C99新增了两个头文件<code>stdint.h</code>和<code>inttypes.h</code></p></blockquote></li><li><p><code>printf()</code>函数根据转换说明打印各种类型的值</p><blockquote><p>转换说明最简单的形式由一个百分号(%)和一个转换字符组成，如<code>%d</code>或<code>%f</code></p></blockquote></li></ul><hr><p><strong>转义序列(格式化输出标识符)-URL参考列表:</strong></p><ul><li><p>CN-CSDN-C语言中字符串的格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/hudashi/article/details/7080078</code></p></blockquote></li><li><p>CN-CSDN-C字符串格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/mcxfate/p/10618114.html</code></p></blockquote></li><li><p>CN-CSDN-C 和 C++ 字符串格式化<a href="https://blog.csdn.net/freeking101/article/details/78935559" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/freeking101/article/details/78935559</code></p></blockquote></li><li><p>c/c++的字符串格式化汇总<a href="https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Wed Mar 11 2020 20:36:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;存储原理-算术类型-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-10</title>
    <link href="https://unit-serow.github.io/2020/03/10/%E9%9A%8F%E7%AC%94-2020-03-10/"/>
    <id>https://unit-serow.github.io/2020/03/10/%E9%9A%8F%E7%AC%94-2020-03-10/</id>
    <published>2020-03-10T15:28:28.000Z</published>
    <updated>2020-03-12T15:57:33.768Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="a2825d91019d60d1c3054a61f5a0619ca5eeecbdb803d7292f1a5147ae51768e">0267ec72f19b8c198697a4f72870a3a85d6f2b84843dff726794cdd9eec1abc8b805e127e2a2b8925e05e7feb4154276a82fa22742e50d9b244aaa4a92afb11f32754d8567b99a7cf788d83a3b3a5f56504c782de52187c6c0d8186efdc72b7c1ad7282eb3914de20b309e9d697901d17622253fdb907ef148f28dadbd22a6ad58cb34749bb2cffbf4185925aabb61e4050020a1a231ad7ae4d6d9965443ba2cc7d95b35532a11e2980d88cb97eb1c8e7a6c62df54510387a990218905bf39bd9de2d6d313083f5943950c0b72990a28045f2948a0877e6f99d7ddba1b3ebe1ba4882c5dde3d6620375ecba28b15916a3396c4c7c21630598e36309fca9e9606cbd4f8e748195f3a5bb2616d25ad5319bfab2f36c2f64a441d18191a6035ad7f4e2616d66111e1213ce028eeab6b25ed1e2ad05f8fde5de4b8a4b2e96732b36d05e8a286a614845bde908eb659f2be758e8c8cf1353ac920a4fd040e09da3db68806fead2bf2150b3b17b08ae905aac8d0a01fd08f65a01ab54ee1060c15f341ff27f500e41b031655c34e6dad9e251446206dc2792075d5dbbc662fef569043d0f1695fcfc6e645f4382246da9a8a356f3194b9e50c703aec697526b9879d10165140f4b62b65473a848c9ad3da53138e4cc41bd5248d38b0947e0a92293873da1594a131983663dcacbc4555ce5e252d6cf5c1264128a6a5772b01cda50e7c59ef5a20f86eb1f64cbc30df2c1856a33e55285e16e9805dad87baada3caf4613c116d433380805ba53a42714de49d4aaf20f3032fdfede60bffab82d6c1c613bb0520f2a4dc0f4c16b7ea6f5bb229772a944a61cf88bfbdfcbece534f0c7c207bce593cbd3df5c15c4c0f31220f2ce5b7a6d8f0343f9ab284cfee9c56bd25543de32c5c9f41f861eed67fb5dee8728a89ec6255a7f4fc26d9bf82bcab515c56b07745d7fc6dacc06d61625410907471ec2024f87a5d9cb9a6dfc061c3cf9cef3c7828854dfa71898862cd418b81acc1bcab00dceae8021042ba0cb1898c7ef9a3b5b5f34ea297e71b96bf9933017aa5722ecad3a1f6ecef50c1abd531c59f346df8ece747e7e223439b5d1c434d0f6a277a29dddf7c0dca9294c2760cb0390c5b126e0ec4e2454a789dfa52eb55c7c12877827e800568b53ce76d02c1d44bc60d3bf1529026791c36b375fd566b46f3e15f29285ec6f0a740a0e03a0251b8d6f3e29304a8f5f03bd929846ae664087dfb33d2c6653469f8aa6b5f5e3be928a9e55f9fb634081657df37b7e50b43cfe9238b616db97da09005829436bd18ba7b7428832821c31f983471a671026515e6edc23a9337216b24e11d05870dccaac120bd0c3d26e8249379322f4bbd1d954deea919e8e2b972589efb3b2548a9663bac5ceaf172968ce62600287235cb7f72745b7b6d7e8789750d901f08f8d36ae23714549c65d95e102e795e9830f8f2c18b71de7cb576e947ab547cb887dddc9ac7b86b1a5292c362c00cf71daf0e6ad66844b87880aa5e48cfe074293559b811018c138c950efbaae7bd335d78378f8132d7199f0202749926ca1a356c1013b3cd134d3236a6a828fd95bf3be0d65c507222fcef06d9d4b00ffb36f5a0d309384490f3aaf2a71876a248ecc9cf56ebfb473e821ef4c1957b64a77a37d3d208eef14fbbd62e5d21a4c356689240290f01e686b95e569a237fc24bd6b2d35bff7bd3ff04de7002f3b881ac2fa35e0f5bf3c62fb62072ce4403aa79566659985c644712da825a059b5ae74f6ed8e808412e513d0662af71916a26accc31486c29c5eb012855511d4177a70978b07b38245435f60bb06ef7b75af18a9b2398806bfba56f31c019f3083b7f01a49d8783f12097f4d157c03be8714a66cee9c36ed0b985fcc1c61944818f540434497e1e9d41e50b1ac24d14d122ef523a268efc8041e0bf2e580fe10373f190b726c56db90e9d326c1a11aa26df0b76112bb010eff34b4aa5f5e5f7d9adc1a56b53f1b7aeb05c49b401508300b062319e0aaf3abdd479d29619a8cc7a244b35bb39ecdfcf4de8ec0b525970ad6cef0617245696717d0b8f39e9020ee34571de9b345e038f987c9ed726759319801aee66b19c0805b52f9ca91ac8c04782560f61269b5594c4c561188edcbab97135b0b3ab6d879a041d52ae988b638afe7d3f132b6ec103cfe8c033df23aa5c7de1f419c91ba96fe3d9abe63ee0d03a577604c309cfd013ea3b850b65ba86c45189aa3b0f0639bebcef75024f1150ad8caffcafcf699bf243f87fd225e2f89363e3ccbee969db9384b01ff1bc9cf40635cd574f1b2aefc9f55113ae3630ef86107f399306bfe9f79cf66228f2bdde206635f2dcbf7628ac9a9f0866bb000dc8dd1123590c845d601bba2e05d474901f22dde67a0ce83c30d312d6b155295676c436a84aa2cc95259c2cfbd05f70990d0a616e22c009615488ec11f2dd62f8b563607c8ec6179ecca64ba74e2cdc9edba12202cf80ccd65a483263908e3b8ccd75549319db7c3d484f60fb65f1df048d8f56c6300c88dfc4178eb1429b18d01b2826dc460d496ec721be213c7f9ae301c0685cbadfbc3e5f8e7816987079f11bb5d0c937ddf7482e4052979cc1bfd1ef1465c28e56f50b1f606b52a96f393226b7812c3c0e3e39d667349ee481976d98b17680c666b35c4f7df53af043125790c6ecfc2b59d9af903d0f1094b3b831f56a6128d880c5c8097b6c0f2e18ea7b7ffd7e07d17a967092d05d8271d02987e926d679a01d57671cb9612b3bbc6ff22aa5f651b7ec180004d3cbd277de9fe602b057358b283a2478207377ac4199472e827356c844a441efc6e0c05ff500c0caf526403bcff6e263139ea765f1cd900acce8fe68251d7b24922659c915e6d982b1b8f60f6feb27f7f9dc07150cd94e096909a497bf0ec813a85300148085a3796980c1bd313e0947e10020b2337139e451819833bf52b800089a0aebec9df4169b0db9e3edaf540e6b67c6c34f4a38b2722793ba79ffbc3fedf8b9317fde03c3d333b27cf3ac3f952d5de7a5780105dc98b4f6472c8356207218847cd45e1c436e1dc354fc1777fdb9d410cf8f4ee0596c5b9b77c965e64aa60395d7716b26e28642f3891eac1927295fc0a518faa2213034e707820a1287fc6009e64475de4728cc7d75752c9cab067e05f9e6877653e72275c610f1cf0fc1bcd2ebd5a5db2de4850a4a7a90725dff64daff802fd98b18ecbfe9f4a9e47836b2205873c3debaa281b0f6c1b288f0daac1e34aade4898bca1ac36ac9bf36cf6dfedc01f073f059e09bf0312361abe0d4f79917cb70884d7bfcab3cffcbc3dd66829e5692bd8a347c1a5bf8ee135e68d8568a83f78d726c5886df1af061e16b821f6a212072c272b1c7ec2f88df2dc8784c41d2c9fba40f9b679c45caf954254d12a69c3cd6d77492bd95420ef9aadcc6c80359be22b61e5aaabb185127204ad8dced2f57fc663b75e8fe8a23b9fde5784ac16ad5e90356e00cb7298e7939a9e34b7c5bf84fda19983824123d1e3dee7af52b572de9192152fcceb0ae401165b1dafdb9f4a631e461c562f8b196227ff5cb5f477dddcf9df869623d7d4d3c8fad624dee0d6f0fb8fa865bc1ee5014b72a5223c134429c2824ba08d8289e90956a9f2e6eddef32448ca488eb529eaf473c09bf52ee9363de93abce0207aa2470e1b0e85f9fd1aaab7a8cac929d6e5f56143fc7e8124a965f6e52af59cbb7a753283d7256cc96ef463963d3da95d6467818473ea0591425444ba16f420d07b5dae13a60ed0a5e4e4b65153e01b7dcb39b3d95c23e351b844c8fbc5dc1d34ed34603ce66e61310aef899df61abcd7f0290227a9ad392807edd9f2ea0683f3a7afe6bdabc6e31df0fd9994936012f60d3c653997a02ad8519ddf770013674be44ec8d3392415257c3d579ad7f3d76233d8a44e2bcb296930b5aac207761e7718d1f9702fa1ed0cedfb4cb03800776c651b4decaf6a24fbb7524efb23967277b4589a3d9045a7014a66187246e4ad5f54e1d5fa9196ed3a7238d562b2ecc2f50f6182464596c16b426bd38b75770d697ee67162ab3bcac2b37e1e3f6c5c9ae334c70addd2ef10ee1efe4d011f10873362e1275dc4a5bcc4cbfdcb75adb41ab128695e14243498294b0baba1ae4eac3450ed6cc31a462f2733d2d0b23e71706c343dc332b5eca6c49dc0586ad7a677f9d135c0ec19267abdc3467a317ebc62e7052145dd6797fdbb68b09a6d363c1a98b6e237f8df9882ffb725119405e91ffbc67559608625b3b9a3e0c15dcb1b003fa12bfd11bb8e73bd67ce7cf6379d20533fafd0a3ff14be56571d6dba1058ed1a2fc6d2dbcf4cb2c75376fe9c56e4c7bed0f097244a9f5ede8a837595492a37229f524c4de4d853b50af109d6a7100a159e392a7f3be6b0fcf9caae916e41403731991f17ec75e2d640e9b988c1e8d09c22d4236bf46bde84af98cdd18cc44534c39f704ca06db94baf43af30db472211e019cb5bdd3e7c584189eea623bc67b210b03a7d419611a596e9ae8ab3dcd7c1672409bd533372f9b2f491c2d0f57ba1b687085fa831f05780181388513bcf2151c7c80c79efa89a4e3ebd8c40c114ba5f4ddb0b324a05d04c01a84071ec772fb80202e4494507d1b519fd9db33f0f120d3b30857e0611a640c7dc279e7b64d5f563957f3f7d72d37f8d7cbd336b3ccc490d20b9d37197f1a9717ed071c9ffb6667a868842d880c933f23ec120ba5a5854da926e5ce56f1d141224566ff4ed1b81e8c207144170994aa7a51d28cdcc4f0cf0dc95e91249f287b88a45d3b5dcdee228552bb9a1896a4a257cf908c23346019490d10b574e6f727975eb5719d857eaa3593db16b6490fa5e5189842003ba9cd181af0f56e9051dd42df4216902fe6520d01d28bdff0c23c75e90507f1b5713d0b477d1f70d32f2b8e7701256376461716e5de38ba2765166897e42ddbbc0b2b90dbe40f57a65808dfdaabf4291528e78d0c6b052f3e56409dae4bbffd31074c8bc60ae0c81c77b2bb96d2616d6431f9ee3c773f5cb9d3e2fa48a587e732b2ec6f045a2e40ba7eed59b3578bb0a4671c5ac7383aaa1600e6afac5b26bbd87ea89443aad48a350af79864647b87314e137202834fee0ad2dffa2612efdbbfe20491e3f932954b4ba52f556c0a24da4c23c620fe2178a95c26b74e3896a7dec59814262b29c4d860940066590611d264810e2eb316dc3d615b7ebebdf3017369c3f888c4341b10d1292ca4821a043be86a7138ed3fa3cce555f584e4fa7da7ba312e13e8c7fbedc895cb0b9944f4ecc02388b5e0e26b582d4d340c597719ae7bb1b7463be6d4821da70fc4469348daeb89f76541e472ca7b099aa1a7680ce4d354a6ec52a7ec10ea9947b02531b504a799f254eeb596eacaae565a74f69b49f05a69c467f7dd2d3c948709ed182cdf28f6f6bebfe9be46dd99e07bd6d2f6f3db60671068233b89921bd596e3ca64a16fad5d8017c420e7ae9c799f551c2ab49c23cb21eae6381f3e56e996dc5f2d87f1e9e8befff4f9ecfe4c3210dc06888b2398168e386c55c2ad159279dbe3fc44f9ceeba231c13ed2ae331bf8c2efd35be9aea8b38e9805432a573171b6aab22e1d2d09f9b0304604b1315999ac7c528bcdfe213662f023ff1889d068a2546a5ec4a1c607a9d7eefaea9de717e11e4a491736dc0c22b971a20b6f40cb8e54568cf6765bb84dc5a8a5c83f2725f107bfb089152ac249e3f8f22905c08538a68cbb2bab8db38d12a73bfe8c408be4e311b08eb68b2f31c195e72278ae8a83cb2dc36e244574e9aa4e5f8f3f63090500629abe4868ee01a05c7f159facc4feddd5550562957caa25ed0a33feec7ff703940649487669cac4640826bac756420601c5595145edd9f96b6514d7c9f3712732702758c1802f628fd2dbe7b6422ad0d33b6116c89101e612fce260dcdeeb648364423762db9141679d66e3a618057576a630eadf5953c73ca88c34d73edf78d71242688593578ff501f10eabc7b24e8c9f261f20911c39343e3033d4f2cdcad1b2f551237f00dafff03ddd88ca275ba9b9de40b7488c9a0b271200161487fb518249a4ba2f0b65e3fc5b3ecb5cc8ea03e48163f8ea04c869b0ab6cfedb78a8b3efa2508092c7cfbbf15186a4dd4d6d5e6a90adc66e33e9e6760c89bc979fd4216db4078cbbcd4147d1362f9705af9e20c0df82deb2ed124d8d0aa5cc546f88d445ef7ed73f22dc472d7a941276cbd639c09c004d752032e256b5666b2de005778ff06255e01ec794c2e8e45c6fdc938a64c908e6a051c0dc66c2400eb00465fa5054176d2409ad43d937da99fa2775120ba3f715ac8146a208c786b66fb3d4a1aa5f66b24580f40ca56edbd26fcfc276991b9db9cf58f5e35ec871f86439212ca17232d3cd6bafc6ccd5af1a9329fa946a1d95b5cff6cba52d7075edd86980eec2ac037df31104da5f4627ce15da57b4bac70d23a8e508b607b099ad37c95adc84967ad04f5c698c0bb387e010a358406f708d1c6d366ac6fb3fa72a85abfc790d7f3a57e061ef0b291bbe04d2554172698878f32b5dca0959ebe5e03788ce1375d8c1197590b7a485905cf0154d48f9a8e86d1b17a33bc1e6d7750f04b004159251d9c0ebe126d44967b12917ddc1e6a4a0207c6e6c478f80068b0fb36daa0a99151e7bf6cf8c9af2de7f7a87680a6026409e8f6debd217628728f6149281cc8f59db58959b639580adbdaedc3420d615114f60453d591c996d5bb7157edb16e016985205139d31edc9d8fbe0dec8df5cb003cf220fd7c05bedb535f6662a6ce8b36c4bf3713de6a3e8fc697d5b8df2ae52d7231ab0a8c7eed0d83453c13136e034e54ac289a49246a8aaa2b5fb5db68085ae8734454cdf8353fa2a121612929841f78ce06eed00e0cb89e4eebabcafe64c19deec4f749ee5565abcb818695aa6310768bf72bfacb4c5c9a524b573504ab2db8cefa485ddfa62a0caf6051fc845cc2bdf90ad136069f64eec34a8794fcf2cc44a24731ab6c6623e1a0fe8c2da950832629cc34c538e701f6af49f8ca2e583dd8084024b430a9e4b7851d9eb21c8c4e6d416130052467d9d5cf2deb488b6fae3bbfafe3f5190be6ac3d5aa7880ea4a3a030cb66e355bc87351e2b118905722e8843fa4385a3210541eecab6d1cd55d1d41cd5573f233881830c198d5d962d491406b6f23c30327717f109b1db729e1509e1349b19cea05bcded48334d71d3b808e9a523c15261e75c6f463b6b56dba2eac61267b36b2cf9956c99fe9b913d44e86b8475f4e49655aaecb1f7f60c2774d9f8475e6047c29c178b32818ee1f5086207816299895da9e3aacc9fbfd4c6dbe83269db1f5c801e8e08ac806f58f517acb5cd3fa5fd875e5cb8a6a7463e02e338e13d2d6c323c828a398dc24c6d83863e3bc5c119364b74bcd6bcfbf9b65f0ff139dc7d28429a281a7cdc2bd90a3aac43e3fe87fcbaff79327ceab8a0ef7ac6ed81a44affb2b628b13becb7dde788d6fd3f14ae561f61efc53a308f4e6b8b2ddd289be4b930d8917c4edde6c6c3ac149a440d5db863f98eeadcf988447a032e41f782a14749dcf89aee4c93466a5f82175a03d2049515b849188da3561b9e5879085b3f93cf84c7aacf1532e0b7683a427b7420d12f5f585cee30d900aea0a494709c846cdefe2825d6bbd31a14e6f720e38d80e21e424f14be4ae21fda7d480c63fe37c39c840e274345973fc7f0c63d60f46a20f1caaf462fd2cb3e1293f94d9755d7e62f26c17ffb374cfc09f26500382ff95dcbd245103ddbf8c52c772a0ada8760a3a11979f06c7cace37e8eb4942f067f6af7700f0da692f54e71cb86b3b657c152b2a4780193ed309e8b25a37cf6f67fe5c9521072fd297ccc84fabf42bc66d8e6d2f11aace28f54aa8aef62a9acd4f55ae1b53c80bb340625d4f89b342457bc1e282ba83e0b645604f4d8dc468555a73480541f2bbb5b05b3fddef2906fb62dcbe5a3bd861db5809bce0775cd0b48d736f09d2b872675a066dd2759c1b0501e49dc242928d9e00d2644df65a628c8be0501d9a11d4eabd13d3dd30a47331e2211e4fd6af7a3bd1b78d80f133ef8084ddc44f70498e685a9a6db7ab14881fb8ff58f4445565aa6f5afb90f90a3b3f912cfa8c0e1ffbf89ded64b3c592ad883ed5e9a152e86495b0a3acd900aa916c6638b072526d97066f6c001d7c189a2502488c7327d02ed24f09bf14697c8c5be8b59d179692fcb1e14aa31bb94e9b8f751634f70d80d714212c0418e92177996a6bf4f55c65d1b01d9b38417ea77a215aa74a5a365b372e5c703b6fa4fcad5860caf2e08dd46b0d1cc1c722de236db15d39fe66b411e113bc8c67a7bbef460e7af7712bb7dccfe3c450d6771af24a409b636bc64e319d4dfddfd05d47359b3666b2262ec12e9e8c32ce6dae54d48a54d2e48f800a7b68982b5ed9a9aa467fdda34bc527f4bf2791b97e6f2c558ba2e6b47fd22fdd8ed0a09d453b5a76cf70da1f98908403859eaf7f7229f728675a21db7969662f49b13803373844baf5135bb05f598ec9dd3a4f0f63d5aa4e208d3ef7dfcbd105afb976b5860f5ca4031894d087d68cc53a1ab253f63d715aae21fd23efdf413f0b079ee04a69af51c44c6197ceb4c9d848b5012b45cc4a6aa3754178498b588f38843583c661128d877bc0c14017c8811a8195be5ee8d9c2003aa0ca76e92a9ccb2f08e3e8b06aa57b809c1df2f7be91bb85f826cc657331eb4f95f6f4d21a239d71bd0dae60153b589f79821379bc2089bbb5d818894d9f18a95902178b94d4d3f8cd08b7e60f9a31d2736465a00e48d01b82d94ae92592f7a9613d6cf3dfcc448816760248b8570591d5bed50d1a8d494a906b8baa51219263d6c22734ca9eef03c2e604a371a2d726d443a99d31431f8dcfce356bdd0950c8b56d19f17a6dfbbe85f66a3249f5a52fc95c01d1fb7ac12ec588054204ac875de34e436d49c9f58792dc46624cddae18d0a4da9868b0f78fe1e1385c8aadd18654c24b290ea31986d18f6cfdc112a367cbd33e6d898046b0d528663c2d0baa6e136cc97419d10ad923560112c2a62d832619cf9bb0e20291132144677d2c3218a63f08b006e6e528e9a5fe45e694be67688851a2144f1671b6079d3c8bd2755e86e4b4a8bb50b05f987689e0bc1fdde893bc940349d17ebc37913fb84a368282a66e89499ab6ee3c02bb5d41daf0151ffec1253f7ce14d5a8cf4f48bba5421eb06dcbc193bfd642c179cd4476f130a4ca6cb4ed40c5d74decce2757efb1133bc8b1eabc0f219d19c2431f951cb9d6c46a4394b435071a35e24b4eb4d3e1b80d773c98d988633697a5683c144341c7adc26d91e13d7b0c1492e97974a636fab063e84a20ebbe762ae2aaa7054da16e1ea52c202a02148683c635087df873890f81646226ecbb498ee13307c906f5fd11af2d41606604cb115ada67998994815484477daaf29e6e2068f7109e99e5269fba0974fd6c4b261ed385392ce59ab753d73fc6eb74239bf9db12140dcb687921bc1ec5538819140e425d6c95bec2640682e8fb25a82e90f0b4b9bbc9171c192b2e992eba969748708a4e12d24c1ad5dd5ba8799d5778b09cb3732dbfc540694ba4afb8482b567d143c659caf0770f9ab663a836b5d848a324c30c02c50a6702362a4d3d1e7cec1a734502de94edc22388a61e06e1e96d9b3953765be92497c8c80d562673c02d2bd8645ddff4dca23fe2d28887518f9f24b57679220d3cda417d1c20a3a6199d3db824382dfd9256b668833afe5f9476a2e6251e856d0459f5fcc028ab39b2c9bfcfcd4bdb698e5f2508b52e6343bbadb0eb99912ff068ef2d3c11df87b474b8481112683b91d618e4e43d868fc527c68bd319f4a515c8e8c8f93146dcf610b12858f56f275dd9967beb582e5d91b1efaa0b7e5eba9c0b9cc3fcae712175d4143ad5636592bb3f192046d2e2f9c060e47a4076829a0324a8fd16166b15afd85387aadcb53d953b8cb4b67ae6b6c9b6ffdf7eb19b2d9cdbde6b115bfdf653c696bb70581a4910300d23dac2dd5cdb2b7d84b8a074f851d68a0d7ad78545d31cfaea7672766ad7344428f9828daa610ffe239dea609f21c6886666e8efb48eaf1753eb80fe0d49852a1e8d58ef6f4b2ff5f7174c4fe89eed2e20c135301cc9122d67550f5289c3d2ec81350855543342877587f5eee3886ce1114241d3f623dc67984c997486d2724a9b56add77cc602aabd0eeec7d711940f38a500e83ebc2c3a667892066ba382835bcc9a4f56639231238f6e21a324fb48386d0ea70dff5756d2659639db4ad1c218e99b034c95853bf1fcb92b0e7ea65a9e36d406880b228d6cc12749acb48a6c9ed7e42ff30dbf0e892400d7f024f2669db13ba1a0c5ee8889b30cce1f22bf90c52117b6f5a5fe28bb654b3d9512fff6fa54e6d2efb33391d73f2a90db28388ef508c0c64ade51181acd8c1157d23c679d83cbb750b810f0c4b21be31df109a63cc256cebab67b04f17b6c087970339b5367e26605b93ed47422635dee244f6e4ed9c00379fc77d140170b1dfb1fbaa57b57821d361d02ede8305ed11e5beb37bf63a419c813eabab57d6fd123eb0c8afc2fe3b8673b0978c33aa716396c52b96df49b32c4c3462455270274010e36fa0d2b0352e46ef755c51755ea33cb615139ee96f8954abb8c8b44708f67cbbe8b110a6d5c25b3061bb635e14c68d15d004e33af84ae3d06f7ccfad202ca468958d503003c9e79892c2fd252087d15b92f42a57935d7eda4b808bd9ea7ca4d52ddf44c5909ef57d0ded1dc5397cecee3a4bd6a8842265073db6f0f338fa2f8e9ca4fad07fbbea164f6cdaa886e508a029d220e5377eea9fc27114cea5df17028011a7f30df032367a267b1c545ed662b5bdbc46bcbbb9900751f0d16fd7a5be4194d0581d7f5dd36b921f8763feb1668f7ebb694811885ca47415243ee255c3fa837ce999bff86fc8fbe3e8b162db94983cff9aee1673a48c03d1f60ebd3c0c0de4a0d824342f188254f95bc74b8dc5bbbdb435aaa234c3b05ed8840f4005b1d29e166f1f455967e9f9f2f82cc6a267e87c872fabffcae3cb523e64d8e513eec45ad5e005dfb5f79ec2bb8dc6efd7a15294adeb8217115b816f822c0f415c245f2d686cdc0802f54728d9b96714f2fdc1627348314a8e8418905a546e472b710d3a877b3ee07c6f052daf539366175a5b7587b0e55368052fa935d87fbec095884ee94d914e76824b818d42a3dcdcf599570844e0968aa05ac5271731ea54411d63ac8db4ad6a6c689a3d9f06ca5d9de244bacc033cbde325fae5e2a5ed32e8ae311ce2601b9cc711c1cee8b7d99513cd49fa04b900205c5eb379299d59603c47bd31ebb0f31b1ab89725c7ee4c7972815cddebabc4db643a44db647b4195af04008a53a0a095dc7d80047626aa076634cc74840db6079eb94ef9a752b2797b39342a13624400df2b8176d16b0ef0792b6d7ae7b06c311d4e853d6de71ff85b62569caf49d674543632c30c2bfecf1465290505d6b72370a5b04c01ce394e4b1e9b9cae180f72edf03521a293e01075e66a227e2d095a39bcf4914fd07a9da401f6d2f38a737f067e4476c6823c8435699bbdd4ece12d7b84f212069d896e0131d2c74f3dc0ea49e12777c1e82ba626b8e4d97111f6ade30bec4c4a2abe26e4d2400da7a57f3a497407b9e807b386696f56ebd0c48c09704fbd81789c3b7a03ae27ce8e7f48e137918b031841566afc0772fb6bf3240d0dde612084a45f999a55df61ea3180ace785a42b43f1601984470497243388346478a1481e1d7943f052b6519033581869555dc8d702959eff5edd059da9e082f2f43ad84d19dc49bdd8167669ca5e4e6219b26c2a6ceed9ac045cab890054c7f659bd128390898bdb5f05f8b37d98fb18142b16ce7190d589cc6ae687da056dcf22f46da974dee3aecba0318947a2a3fbc69e91c54365f8cb2155840ffcab83a93efc89e9aeefd4179658006a6311fa9b15192bb1e550d5d7b48401c32a5d9bcb698f9890692eb99b4819fcc3d97f29adc11cd6c55ee1d8e1335db3d3b8d403762aea90e28457ab458b208ddb16c68d584af350f97de082a38255bd7e77934c3f0b97dbccf37f17659e4a1f1501b81060fbd2fc0f8e83ac0a8f4969af72644dd72b59e3ae7c12ef7b6f16e114f2ef617f031dd437548a458b840beadd1f13762690457fb80f66633dc9c547fb75615314ea5ce7a6e8f5553c17fd9dfc7910a18f0710a62f35b4acc51f4e8fd13e708167801bb255fdd08c14ce1acfab4908c088de3b4f69934d5c6adf8710eace1326d747b8c01e907f4673c9fb495a05f1eb1cd0bd954f51958f15697b3325d81fea3ebcfd8a9f7bfb25e72c03299b84303815d059705b435df1aef60a91c235f00837583e0522266a85a3c598e59167a21354d8edc26d39b9aa4bdd77f3c60a3599438deb4ed2f806955b6ce33305e69afcba0111be2ea0ca9edc1007960d541467b28e58cd978674bce6d8173a777a638b15c64404035f81630742e361a00dfd0e5af65e0e2be05374ffbeddbcab8082749d8d411f22b4f12bb0843e407ebf1f806a30cc6022ca9e6d869bbad70beb3bcce053888db9a4f22387dbdc91705dbc7f0464627646bc1622fd01be8cb3729a838302b93f0923b3a6f211a08adad7beeabe1214011897c937c849926f00e180be3e19889ce8d95ad762ba88b40b8929a6e64c2bf0ceca92cbdda41f2301d2f17a9e5c55bbc930679c91c311754c21544a7c4a5a52f41c629e78f6b0a25295d4e5ba1aa716d00ae54cc4a9cd83ec1448988b0b35668078508acd92f6f1eedf67c3032ae793946e3b50401218f18be322115e655c470f162803a7b352ea1f257bceec96723c4b94c779ea2da926377c3d784b18f363a63b3b4068a99d2dfde36d5e032d5d4e26a21e5fb35103723bd5936a7ad9a75921980e1ab5355e462987700e82e541e9f7ee0d770b47d86843533922fc87a98c5c8a2583c424595726d125c5cf948e0676e3fd8e36425d0b3bb3df6cc03af55556606f2dc37df36e9db27299ac5e820b08c4e09a32a45e1f2f8e3fd8e1ee54309560f38a4ca021211d8e480bfd7de684957e9d884d4e1550e00ce20939a59e5d6b06e3af556bceee25baf86dfe849ac31bfb385e1bed92daebb07eb2d12d91fc18e58b51caa84a6464d2487009a3720243c4caa90d5b57929c6d8c213bfeae26d71ff0087aa53610c5d93a2d129c6cbb969bdd4a95302bd4acb3dccd45c3dc4f7fb9fe7d324431334cb921f1c692f1d99ecc72dedadf3fbaa8c66a9d733084cfbcb2201a68a9b545560032d1719f848c14f29718588b14b8d0b18e8cfaeb43fe8e7ec33c98340629a39c28605b1ee2d75a6d5ae96c58e1be02f4fb3fbfda9f5ea1ef8cc55b80cb189c41014eee70a7d95ab19d1bd26ed4f42bf267c601089a02760a8129b453228a932a823531958d89f62467c9235d1f8d99bd6490824fb02621327f595ff2ed4f358faaf9511e48732fe5d9cbb43bf682f07e70c34bd2fe96feb21887beeb389fd002871180dcddbf4e9daef7c462bc366a1a379c9cfe88d97be37afa2e5dbee907c6b6cd88693950f6dd2bd48422bad990f39f2d63bc3a77bad4782fa22e76a8e2848a2f2a7b41c1e9a98885ee65bb36de36ef610644e4a14c55420c4c446c4cba469bd7a15f242b9e2be6b490a4a751052b5a389099ea9f0fc17339e6e6e45ed3c97f73872bce32d1aad2ddf9ff811a840f6dffe228b22fa62e1124b1f57339b20281da0ce20c7a785d217b9afbb5bcb0da455a0b55a1350859865d2475f3b2269203a3e4c68921cddae7d8c43d2913e4ec2142a78b410caa2afa21e4764af2ecc3d7d3e1815abf08612fa7afff9efba37800fb207eedaa035764b14654f396766cbdf88b0e499539e05a425a96f3cebee04ca3cb583dde9680167e9701fab45162e2299d331773377ebb2a2837eac3872f5a8ef824dab287b35b3f880c659e53e4795d3327bbb5cc0376cf2e1773a6e92d07c3a13a65615d78a1a86c353ee139c8ba87635a298c558fc0bc827c57f5cbda62684929fd89aef985389990c8dfe68efb42fc81f9551b6540af2e01c8e2f8ef5ddb1d781a911bc52864f2ba888e7a755e313fef4d4b5d76b1a1c5f2983fbee039de45c67012af5827bebecaadda287f0d0481ed193ebe9d35a48a4aefd4eb065e22b40a15a74acdcf73e2e362e9e06f2b85cdf9e8e3bb15637042b7076f63f3f40efeeb206e1007babb5fbd25d41888d4fe5558587865ff2ea8af8dc58db23c187b9d71c3cbc77736c28a3c519389203c922721da5f25209aad7e902eb76921c0343236f8e6933969a591b942e0a317a942dff1284ad21e50f96f87022f5faf41fe1928e5067165bc786385082942a1c2df739f512a585c2d4baa27e68f913cbd939f306e044a197a116a4825a9c60d7b338967e2c8a5e22fcb5eeaf22bd53d22a35cf3050d2dd70625e24c1718e386add89b0c2e86177acd1271b892d98aa00dbee2a815b9de3454e97d4e0eb1eaabe899044aedf889db77b419d18f3aceb38e30ad39d401fbea4b837aa10a3a9ae0d61fb60231fb382088f04da36271945b0514bdd3e49dd99d30a61bf3c841e25f0f4ea5a4b5f3dd9c7586a040ca35c066565a1f27ffd943b83deae0975b4b28359067d72237b9d99047d6e0a7fc29bb02e8a670ddc75f059da95d01e69275c63b1b4b10ea694835aff8f0c7246fe2b4519b54dbd53c69770740b35b849a8315c087ab9a20ecb760d294f37c64e94307db7cefdae3ee228f480bf0d72e94bce47ddcb7770ffdbb8c5d66ec38dc47aa3c2044b834fbf52b2f6db7e9ac21c768d469bc0d8b68b785614aa6d748f5bf0e7642dfaa1b288cb97bda76aae7a05ee880d75462827620892edd3b30a061c479977fadcb305155919295232b17224cbde0d32086b0ec8df56e4b4b89afc833f63d01f54e10a7e7e1484edeb9ebe47ed3ea6bf9476defb9e420cb1465c63a0a7bdcf581b174c4c56a9c5f17d6733207843b282fa0ee9498eed4a4a7f6fa8990575734f94c8101a0cff1e77a1fa8efb0b16f70dfa127b442352d67cd6d495d2809e2cbb03a0ccf6b884202e8affb58351b6eacccf1d113ba2135d8d4212547acf40b2cc331ff312a81fe3dc50767ff586aecd24eb359dfc1ca7bd04831a9e0cd811a56c3221d23af3e262d71c4c051083ae2fd6b36431e93c399f8e16c8f43f5acf26bf38f3ca23d13104ad4acc64d4a964bdfcb2ef616c5b91ae65d2829ecf91f995500dcf7ba4f5733b34909f0beb75c390089515ffaeb3f64d48a161886836cf0abd136957e1ded96e27cb2c223570a76c4c5c68d877faa05ba1c90143265d3d4311e48a61b2b44891f3b85764934930c1b5c7886f70d1880431de731a3a41c63ba807e790d5073e72a00912ff8e2dc65c1cf9592ae539f464a02f5464eab0a6f00f923114c31e205655f2ed4e770ec29fdf56b517ebb018551a52a3217b261369b241a22077b9874099fca4f55d2a114209f78affe944accb56cf322ae18b38ff373c23a50fdb77e84d74c40f46ccbc057df607c32d09939f8733620b656b9e992e9c165ebd117edc53416ba5747e1d8b8daaa044e03b74b3bbc192ce671107a07ecbe932a490db29d389aca4ef014d07a5fc29bfc63afa711cebc85c4da636d3a179248920caa57ba335697c18613a098b3a6f8968b01277391fae71ba1cbe93122410e46aba3dc5d3fa97592a908edf7a5becb683361c0cfb5afacd4d2a5396a318c5cd9858d41c53364225ae984ac2ffca78ee22d33732050010eebe90ce986790d7e4433d62f8023f0058f9ff9aeee89622ba87dba5cb1e9fc4d67d2040f59cacf0a53ff3a0c16a3fa657aa2548bb9c0c4182c7b3e6edb01aa5a1f922d9ac058eb156d287ea6312db567223a89e8ed87d38bb11496a3c6c66a2e80cfebbfa30b19f583e9a346bd54954b3bfa5ae69bfd1393bcec6106855ea3f8a1418e0075d2767795bbb3a6240548e0072c5d82fa77c3ed584bf8978788cf304fe99931df32748708d3f01654b93ef82c5f27e33ae9a11bcfa605d9668e44f4349d6022f8bf30dd8fdaed9d821028a4130dfbef68185b75f0b9c0fcbf7306ce144ac4ab6be85700860c440f4e12ab78a123666c4d1eff31633e37824173ffedc1936c4f0851c0b74b43cf5042bf84b4daf92aae6ad3528b9ebfa6449549ab4755ebfba19fa99bb85fcf7833599066ad1db87ff4142f46078003f993462532b9c400c265ee0085a7f2d04c89ad3f9bf8aa56da2cce8cfb8fcda1cc4469894446a5d71a2582ddf7413ad351802cf4eacd860759d078cf64159692effa98546d0d2e18188e9ff0eadb29ba79cee81d05a38c57c4f6f6b4e0d5e83cafc4bfc959c4d5eb5e8eb00bf3bb18e198ca05b6a36c4e9f3204ca39c55dd6011c8346f30e977961feb0b0cc2d25df848173ff3eb9b0449b21ee6b51fe5e15e9d2d7fc4a460cc27206c9600343cafcac11a68f1c5ed8bc4416ea637b1b7efb81511b32b43fbfe0b8758757861c42d890b18094af495e69dc018e021a29e5d8e5bbc7ac2dedc5d65e0376cd746b9c0b320026ef575aa28ee93cfda8797b29622f0a8f0f8cf451a92bcb0f33df00958e4afc322e43bb9fbd56e303bf9eff2187522ce1a342903abc877ae20f1f948382df8dd726ce01fb1cdfebf8234c60ab045524556841f1b219afcb4698bc254324d39fb7012669217ee9e70d5cf95833f7b6f903f98045a489b53a0a919f541ecc45e9287c31866aa80428a937103e1681b009c8c024110bb078c2ae4631f4e79f0fc376d046f45916ba35843ae6b963e00f1dd995ed8c63bd40e9e8a0aa37d358b3aba1ece806ada7fac440ded407af9b147c50638c4a653c36bc32e1d5b5be9914fe868826fee1d7d91167745f52ce5fbbf25b05ce374c6e2a759c77498d8c43e3d6bcde90817520e74e6861a9b2f5b06109c836383b2b171bcb51fd5b3618bb59a3c0ce4fbd3faf966fd09ac9bb931315dd99d6ff2d9fb06e5ef96ee328cf5b04749e9a99d1d91c67f2b4f3f23f314178a95438545e3c36047e774dd243ba6143617f2a6a9f2428d1a00293ebdbe1217b56e23a3007433db3e0d769936f2832ac805054fe788d41dfbff5074c1070b481522dd24283a38bd1f579af4fb5014010b626fd40bc0e134731982ff2fe771994ef3cbe4e4fc9cfbe33e1cbdfbe8ce9935a0884f89d179921200d4ec708260add702d565ff1e4ebad659e4b5af8246ae88a1cc489d425192b34f3f2dae70e219e5c5023f54eacd6267bfa44240c5655934e87839698abff0d910776da3651b76626e11a20db3842ca05b6edde7448deede6258db7b571cd0f6e91ccc220f64ddcec2840a895b642c4b2afbfff97c8e2734795cbadfd0268e4306edbb57d0b7c0378cc4e8ff074fa54e36d7974f49835ab45cad49f52d2361073ee0987ddc32df78bdaf110c1c1769dcf1a4b82768bac3e0a360f5b2df20d01c8dfaff454ce3fb6c6ba11f77ea6965f7dc7f0fcd854bafbd3bfb8f8af5723153cddd02fb797e3bed2612c04a50386c25354dd89af43261da4d88efb91cbf08afb8443ddd09a0279b2c1fc679f64acb153e0b4c0b04af9cc95a6940f0461cc83abbd168a6d92b9e0cd5f61caab296d761acad50741367fabb3f3ffd4afd6f1df448adc936a1872bc24c543c99a2c1c0eca0cbff9e22c38bda484a33c5d5159b67acffb7f1602b731a20521a17e700bf8e837dc94c392135e5e214eb339b3605980f7f37f0859284d930d804fffa04fe0120b5ab075d7127e077eba7767b81214c4e6fb43ea3f24bc3ec3423d8be1a382552a6b835539b1264f6580eddae3ca6ff14c1f64dca397d4de4b49e36951449e1f51da3d8ae1549606c1fb438607b9235675b3839182747dfffd7e735cb0a58661652c49e8b7815d71746d68d447d68328ea5ba9729ef69dad41f448f947a7706765d347ab07c257bb6dd7d467c496f30f8615373dd7f63874ef6a0dc4e2c981b7516386290097561005f79479a5bc736980c592443160c2d20b89996aa18ba6fe20f983ad2f9e2016b3cc6d216d20bf3f20b13f625e630ae33c7d19d8bfb510f60e3405ed8f2e8b4f0b2e21fc3180c23d175522f2d1f8e5f369e099f85a480eaaa95e027255a3ecaf32f54710b7c7286aa408811a4a5702ec69b65ba11a18de61fac30fcd09f2ce7039636cc4cfdfe191510c5761ced0754ca32dee945d62c69da57e220627bcf0103c1b5ff5cdff9526ed9d05e830969145ddd3f9a80f5ecfe027c7b89b0533b7a5360af84b51415dfde4d43ed636c54125e26e9816c7b8104738a73ac6a34accb934be715dcf60ba3aa6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-09</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E9%9A%8F%E7%AC%94-2020-03-09/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E9%9A%8F%E7%AC%94-2020-03-09/</id>
    <published>2020-03-09T13:43:27.000Z</published>
    <updated>2020-03-11T22:54:03.465Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="89d5ba1096547522d3358fcf12fa747dcd6e2419c747c975abad0a7c6d10c70c">0267ec72f19b8c198697a4f72870a3a85d6f2b84843dff726794cdd9eec1abc8dbf379d72aff7f844f1c5967dd359a1e706d2d1efab533ffcd03ffda005d47dfd2a054c531d21d595d3485a79fad364b5365db24b898b7adfbe3d1e0922f0ac2df2967ddaddbd06844de126a3086ebe8eb799e9e39cd57031b50f4ae58897933d88f67b9aebeca7009401a198fe12f95ef75dba61c050a5800eeee7856de9be21c82ffdf80a9eca614a9bb865bdd2eaaea6b0071d193e0064c4e28eceb1bc1a45f370c468823d9931bed97e44193c80ef80b32c0c3d56bf2f2aeee1e8dd3c488b9697c8fb999f4ccf7973ac0bc30443fae3f2f5ca28f5321d4983e9f5b79c897c4f5e5d8b41a372e68cf78fe156757097b639aa0033d74694cb18864450a36a3ac69df0397da0bf4c840b15be6f517ecee98ab20105c1ae0d59a63562a32dd2b825612aacec994860abc62874eb7d2292862a02742614e4122242547c98b3fb6d4a53de728eb7c18a4388796c4b0a0f71b6fc67eb31d4f3bbd5ea460d4ad0e052f9378cf692db0c6eb5136d3215795c4b5aa81ed005360feee704a1f3868ee0e2d6d20c8eba9948b7869a23fa32e5bd140bb8980e762ca22988442f85bb8b2211fa3376d8963dbaf24d0e5b62fa5e7818f44cf6d72b1f51b52003c3092e28057328b5039ff8e4bca2509c86522615ccb9a88e0d88a69f5c1818ac1ae18c7dd2f603d51c25d2fdd99ff310a13ad49c448d7e437991d06bd2f1bcbbef30dd739f56329efa14974804fdc25928863117f91401ed295573f2f0e1fb297e0f6fcc31fb3fe6432db8f5b99e03b1790fe94342fa1d442e9f29f3ad41c40049cf99956291ef33e758a36ffe9febeb725db5906a749ef3fac0ab2c97074f8022ff0d9f0ed8ac89f87ce38c603252a17bbb113197362d97d29d4954a4edf2faa2b9eb8963e12e37b575a3f1bbcd864547fe46ec5c41c9b2e68fc6ccdd39bfb21b1c1a0cfcfb16e48440d7603fab918e250b6e09f70f69152a0261ab250f86a3a8271c4f40391c3a1eb72335237c192ca9bfc841afd435f44de2abe9b8d62785267f01e2ee0856a050fd9dcbae9a77027e5a27d1692fdef874aa787e2169ac5c4f8749dc9f719a8d87ced9fe8924078879056332c9efcd4f976aa3e9a91a5329053ada2510a3621abea3bf6f038721fb49d8609dfc92dac35893f53f9eacc3f8cdd3f9b51c278021ab2ebac5995aa11028a9f927a8840544d84a98e0658e18dc7d038f4247ed8671473f56d5e2efcec91a1ee73ea51afec11bfae5d5a88ddc80677c71f50139e80ac8b3028429990a46bc9b3dd2c12029e5feb33509a56a326fc17f5aa3d195ce9cd3eeb5aee8e3443d5df534b77b2ca173b70820f00573c13ee8f73dbf0f99cdea6b01d71e7ee1542d48c4b2a93de39856e2e57518d21e7adbf62f408932ba9b78ab7f387bc750edcfab0ecc105a1f2aba9d0e218763693481200f855f4883b0bb10f0bebae618a50d8aea4d457939ffa1a0981e9ca26cbc255d138f50a962e26f154bcf3ee32790b4ec5ee426424e64fa2242d36ae3af0fbc249370a6469af23d7021d64b33165a4bd61118357bf7594e68c985d7f3c3382798b9a6ce37d207996811de0396f154069223b0cace466b930360a3b2e74d159a9d4fab276684f8b8900a693e77f60b807367825da381f00f82351a16ffa3956455d11b1512036e8c5729727aa7d3fecc230efacb257a425803a6df809ece557e3b28a2b535807f1dc58dc4f89417eacba92a82ff5a127b8e56b547b6cfff68fe94668f820f78c3343f3aaff43803e47e4c28b6f2d83de2c776bcf890527e2081c934b2b597b9e66c618c75e57613f0f0bfe9e4f2baa052a89c53defe4a7084708aa5f15b80a1a954774a143bb607e7f2d69c2529b8b47ab17f562116f3c685c27b07eae2073ec40dcbc7d35061f8d22d3fa0b77f03da0877eee417a5f9bdc58f1a66e051b95b9127eb5485eebcee94955acd923de71d3f0c53214096646f97d2f8d0ba778f7c4afe643dd9a633aea1f950694161726fa45875feecf2b78e835a1998f2a1d8cec4960835eb3ded5ec5c4727531e5673d221c05dbf851e911b8a142d1cbcbf6b2b015f1e41484d0a56f56045cc4d1aa17892293c7a46bf7de2ee9cfa57ff7bd3215efde4fcf569d1b38f866a9895d237d413d5b224e82e646de1855505d222d7d39a060458d73a2a405b05101b60ca4658b4987cbf0787aec37c4480955f87ac0e06652b5f966a7509abd8d61c4cab9f8ea2a3525c1544b6a6363b19c8172e26b6ca4ffd2b9ba55954fb0ceb08e96d993ce6f2dbb9f5cc3c77811fe11da4083b0805b3b66e7f6d26847b59730d9258d15a7f2f8f3a8b0870ab3b434613ca9fa23a5eff5dd3f8eaa0c7505a0897a07e652cd9c0fb3548b5a940a3b6a9ef77ef7ba16c0d02a7fa197739c118bb4f4e7980e9f1790587e233eb613d8abfae0a96535caef5cae102789a28de0797da921b994a001cc354345f578fbffeb5b343e8be1f1eadf3078220363be601f15e0ee3900d7ada55ac1f6b99d3e31fc164b75ce3a55d0d375f587eff4e27d51ae3401f24736c429d1ad7ccfd40ad56bbd3bc573b2ba3467a675b1fc4269e472cfdb2bfc9d99d59ce84f7b364b3dbc75bafeea1f59df449b3eb04215fe8239b8139d6b099342b35bba3e0316fbc87f5d60120444c37e3325a4d59d273e6c10a130c41e0ffcc61b33a614ad6fd2dac1fbf09c366b042bbbc2073f252f75786a705a8d8f084e251e01f1f9d5b43f8254664921bdcdc2d5c067f8c55d953e533f932eda737756e61d74c9096e31ca4cfbd0943169657f520160f98a18a43817e64eefbcd76afcc5a2d62d0f8463387f68a31f4da764a08f6c81e0027dbb1246899d7908c2a86e483e5e670efbea7cee985f7a91dd994e6900c719e4c7d76cdac9fbf5d97f04bc99d0262990786ab9e7f16b3ba16b3600d8e6fdd04497d68f1a9b09f969db4dfada13006fad5119ab79db4e4568dd99162d3ee1cb334de95a2b18a16093c07ef99fa657b3aad77d02efa4a4bf4316f1de848a0926215ab19d6dc9f038e21bfc133ec10530af8beb0851331108759fe57f50b1cf18891a781d3f8fe5afdc61f15a55e5810d280efac76f65d8cb7973d727d3149a74dedb8a6087eeabd2411b3e9d3928013d84880d2d8df3660863837ab5a2afb7b4a0167f14cd57488848685f83a7c16bd924a74c532535bbbed53e0c900ce8a03dc947c8407bca468d3f5fc2f7b09795c85857dacfcfa38a332fcaf11efa9bfd6b03a48b692cd4c13eb6b9fa95ea5a903c24dacadcf5c0fd728b2f33049061856ceb38143695408ba27c6c5f6bedf6a7dfdc1e3945a5348d61811b10f1e2e8e95c72211b022056052367a99e34af0e892b358e6b00034b3989fa439f4ea2e922314b01dc9d6bf209e345f1003dd3f68ef0df2acff4c759aac5fb5f547413169e7db02d9cc690f26b8b569946282e44f04f1fa7b715612f4ed06419b8077e21111daa39652ea537d68523c324e506ee0e2efc09c611367d48774f12ce946e64a49bae08e34ab0c9b4aff350780f2e366ae458442131708b719dfc10949a637f5d4e18d19788270bae5a1817321fcaa4b3de3bd446bddac2e7d2a3c2def786b978640e018ebb2c5c5338df7146d3a6a4f311f6f50ca5f85d49a2b3d90ffc520bc498567a5489be7392f1cee1a5cba64fd739df0e64a0e1cd51a38f8e4edbbdec2cab40615bef3f242e16cda59e2dbb31daddcad3279d27d4d03517bc55a21cd961a5b444383b20b35c9085d16dedaf911db47d182d983b2d52dcc189983a14ee8ae50d6520aab456a5a9f485892c8d7fb164c0338129dbab279d58f6b3803b1f8f5a1b1b08c6490fda2013422760ee3678c72e9ba6e84520c673e0b85a3b4acaec31c3a7a899897535d456eca8e06ea909052bdbedb7818b34cbb55ab593fd5693860d8d93e47212ead1c23cfd92e41b20a9fcb7ba10c98130977b1def11f8704afe071ad5cedd9538c724d2bf4b882cc6d80c05edd745a9e0cabfc8f180d6ce20bec53a66e35e1b35b7f5d28e49670ca2eaca6624a3412cd5821349e8ce3623ec54180d4c30ae7bd2f760e59304ea00a5ae4f8cdc81cd6021a35d20eb954681cd668e6099441b8c6db631fb293798c6f443d2e4bce35e7d9c5953b6d7f757c345eab0202fe54eae8a532d3d1da421fbb538915f787f1ea7e1e49ed6c859e9ce1b64a1faa383b689d344d89e69e5b064a412123efc8506e99568905bcc37ed8bf5f65e49b3498c2518ade7e016cf5a30c7f29ff0a31e999b5248b281b7ac9c99073b56852af680dbb221407886cde6c77c31ab0ca23d5249746d42ccea008d6b778c83dd4e450be9467d6bf2eb7258444cda7416ac45d3f645d8c41c21a3b4f841fabb3380a9493d3f52695e5678ec0d184420e536fe7dae46076c52cfbb53d18b1d924646aeb6ba8503b815e17689e1e6921c642e7a0b11e9f78f7aec1657bd4aed374e410eaba998e3a052171aa31c67a946faa19cb66813510506bd381a84be907aab99646166f45668f6840ce2dd17823fc4d91f4c656e326bff4c02c54a242af77d044f290e55f729c16ef0d9bf6a91c7e333309a72c343c4c35128681e757bdac902eb25bddcb0154c01c00a15c17af927531bacd78c23cf2e8da19e6f08980bb8def0c3666e1d96a93897bafc58f8a593489e3fc34b5e125231b1f04336be01cebe9b7954b02f9fefcf82a0e6a88f7ca67673501ccd1018860531b71ca664f6f625dd6cd2211bef9f17d057dbbd23f843bf457be90cec492fc65f117f75e772790adf647821fb4260d859b8c57f5c2323d08838f493107330896a34bf5edf4a59c400cc586555fae6b7060c27f0f3f82a76949febfdd3deb14b7ff5d641d2ba15fccca6cd63ba853d787816ad33c165ec43b2bbc952d116924ccb5a6b40479564f22138450471d637ef100bf4b4ebbb3fc3368b0ec6598247440b918a9142966ddd923b3d21fcc5b5de1431b3804770531edf9eddd74a5dac41882703b45c83a55149a16049ee3caff8a64b1b1fd048a1c5d977c9e732746ac437048a6ae4f1f46305cb795a2460ef7c9ad809c9fe3371899c3dc381d89d792693336832e196e4cf61b2ab85f719f225a18241f0ba12086dbb0dfa8e431c91ade108074b6af36c901a565f0e80c0e9fd8f3267b4e201d96ba4c9589f98c486194edfa18ad7df77b5a7cbf00735c08dd2c729004a4e53acdccb668ddd90d0f62400dbc92764eec8fff3694fade5daab298dea7597105b849df775dc9bdc090ff851f182f8850f9fc4e41848827c70f4bbe88c4714c26f9e3d8124eb385dca15974f0e3446c26a0612ce03e4ee1e1e1e20ed323338f0c9ec9c7a489907bbf781040c341eb441e67eb14c6a87a8a7c9eeb8a4224514b637246beaa68a572ae0c9251d6fb821f49c49b5d6b22c24f71b5988ffa1e7eaedfcdc984a055e2e98949e6123448c233e1285403562310754e5dc1e563a0c3c3e5635056b3a3a49cef2d008b3cb59b21f373ae7d8cf349be446c4d4d69c9baa96b36551b6080b0f4b8607f2b9489ced7c1666096f38488e1a8369ea806771c4c8dac41abd93c56c035cda97cefd4a9818da05c1daf1393a594c82082e25cc914b61ce25c0827f087f2fcd189cd1e6aece19202997e243b282ce5a8ce1ad230b791191339c0bd59ff48ad1f02be128e0735e393264e63cd7c40b1601de9ddbab6b02182bf4993656a8a914198</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-1</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/</id>
    <published>2020-03-09T10:23:24.000Z</published>
    <updated>2020-03-09T13:46:42.334Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 21:46:49 GMT+0800 (中国标准时间) --><center><strong>数据类型概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-数据类型"><a href="#计算机科学-数据类型" class="headerlink" title="计算机科学-数据类型"></a>计算机科学-数据类型</h2><ul><li>数据类型-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li>数据类型</li><li>数据类型-变量</li><li>数据类型-函数</li><li>参数传递</li><li>形参与实参</li><li>内存</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><hr><ul><li>数据类型-变量</li><li>数据类型-存储类</li><li>数据类型-常量</li><li>数据类型-函数</li><li>数据类型-数组</li><li>数据类型-指针</li><li>数据类型-结构体</li><li>数据类型-共用体</li></ul><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>概念简述:</strong></p><ul><li>在计算机科学内，任何存在于客观概念与主观概念的现实或抽象世界内的一切概念，都可称为之为数据</li><li>在计算机内，一切皆为数据，数据即为数字与数理逻辑所构成的任何概念</li><li>这里所谈论的一切概念，都是基于 C 程序语言内的</li><li>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>数据类型的概念即为系统化的将任何存在于程序语言内数据进行准确的/系统化类型划分</li><li>还可以更直观的将其称为数据类型系统(相对于程序语言)</li></ul><p><strong>类别明细:</strong></p><ul><li>数据类型系统内包含于的数据类型可划分位四种类别，分别为:</li></ul><ol><li><p>基本类型</p><blockquote><p>被划分为算术类型，包含于两种类型: 整数类型与浮点类型<br>在整数类型内: 各种类型的存储大小与系统的位数和系统的类别有关，但目前通用的以64位为主<br>在浮点类型内: 可将浮点类型分为float-单精度浮点类型，double/long double-双精度浮点类型</p><blockquote><p>后续进行详细介绍</p></blockquote></blockquote></li><li><p>枚举类型</p><blockquote><p>被划分为算术类型，被用于定义在程序种只能赋予其一定的离散整数的变量<br>后续进行详细介绍</p></blockquote></li><li><p>void类型</p><blockquote><p>被划分为类型说明符，类型说明符void用于表明没有可用的值</p></blockquote></li></ol><p><strong>一般用于以下三种情况:</strong></p><ol><li>函数的返回值为空<blockquote><p>C 中有各种函数都不返回值，或者可以说它们返回空<br>不返回值的函数的返回类型为空<br>例如<code>void exit (int status);</code></p></blockquote></li><li>函数参数为空<blockquote><p>C 中有各种函数不接受任何参数<br>不带参数的函数可以接受一个 void<br>例如<code>int rand(void);</code></p></blockquote></li><li>指针指向void<blockquote><p>类型为<code>void *</code>的指针代表对象的地址，而不是类型<br>例如，内存分配函数<code>void *malloc( size_t size );</code><br>返回指向 void 的指针，可以转换为任何数据类型<br>后续进行详细介绍</p></blockquote></li></ol><hr><ol start="4"><li>派生类型<br>包含于: 指针类型，数组类型，结构类型，公用体类型和函数类型<blockquote><p>后续进行详细介绍</p></blockquote></li></ol><ul><li><p>关于聚合类型</p><blockquote><p>数组类型和结构类型被统称为聚合类型<br>函数的类型指的是函数返回值的类型</p></blockquote></li><li><p>在 C 程序语言内可以对数据类型进行转换或强制转换操作</p></li></ul><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>文章先进行正文归纳，再进行笔记归纳</li></ul><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h3><p><strong>对于涉及概念的系统化整理和解析</strong></p><ul><li><p>变量其实只不过是程序可操作的存储区的名称</p></li><li><p>C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局</p><blockquote><p>该范围内的值都可以存储在内存中，运算符可应用于变量上</p></blockquote></li><li><p>基于数据基本类型，有以下几种基本的变量类型:</p></li><li><p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等</p></li></ul><hr><ul><li><p>对于变量的概念，无非就是定义，声明，赋值，以及调用</p></li><li><p>其中声明和定义对于程序员来说是同时进行的，即在声明时就将其定义或不进行定义，只进行声明</p></li><li><p>定义即为为所定义变量分配内存空间</p></li><li><p>定义一个变量，就是告诉编译器在内存的何处创建属于当前被定义变量的存储区域</p><blockquote><p>变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表<br>并且定义变量时所指定的数据类型必须是有效的数据类型<br>在不带初始化的定义中，带有静态存储持续时间的变量会被隐式初始化NULL(所有字节的值皆为0)，其它所有变量的初始值是未定义的</p></blockquote></li><li><p>声明一个变量，变量声明的作用是向编译器保证变量以指定的类型和名称而存在，也可将其称之为专属于该变量的标识符，或变量标识符</p><blockquote><p>所以编译器在不需要知道变量完整细节的情况下也能进行进一步的编译<br>对于变量的声明，或称为将变量赋予专属的标识符，只在编译时有它的意义，在程序链接时编译器需要实际的变量声明</p></blockquote></li><li><p>对于变量声明有两种情况:</p></li></ul><ol><li>需要建立存储空间，例如 <code>int a</code>在声明的同时就建立了存储控件</li><li>不需要建立存储空间，通过使用extern关键字声明变量而不定义它，例如 <code>extern int a</code>其中变量a是可以在别的文件种定义的<blockquote><p>所以除非有extern关键字，否则都是对变量的定义</p></blockquote></li></ol><p><strong>关于 C 的左值(Lvalues)和右值(Rvalues)</strong></p><ul><li>C 中有两种类型的表达式:</li></ul><ol><li><p>左值(Lvalue):</p><blockquote><p>指向内存位置的表达式被称为左值(lvalue)表达式<br>左值可以出现在赋值号的左边或右边</p></blockquote></li><li><p>右值(Rvalue):</p><blockquote><p>术语右值(rvalue)指的是存储在内存中某些地址的数值<br>右值是不能对其进行赋值的表达式<br>也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边</p></blockquote></li></ol><p><strong>用途总结:</strong></p><ol><li>当需要保存数据的时候，需要lvalues</li><li>当需要读取数据的时候，需要rvalues</li></ol><ul><li>lvalues 和 rvalues 角色的相互转换<blockquote><p>根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为 rvalues<br>rvalues 永远不能转换为 lvalues</p></blockquote></li></ul><hr><p><strong>变量的全局变量与局部变量的概念简述:</strong></p><ul><li><p>全局变量就是在任何的函数外，整体的程序内所定义的变量，所以将会在整个程序内生效</p></li><li><p>而局部变量就是在函数内所声明的变量，所以只在函数内生效</p></li><li><p>在定义了全局变量后，在函数内调用该变量的方法:</p></li><li><p>为变量加上<code>extern</code>关键字即可跳过定义，直接使用:</p><blockquote><p><code>extern int a</code></p></blockquote></li></ul><hr><p><strong>全局变量和局部变量在内存中的区别</strong></p><ul><li><p>全局变量保存在内存的全局存储区中，占用静态的存储单元</p></li><li><p>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></li><li><p>C语言经过编译之后将内存分为以下几个区域：</p></li></ul><ol><li>栈(stack): 由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址<blockquote><p>操作方式类似数据结构中的栈</p></blockquote></li><li>堆(heap): 用于程序动态申请分配和释放空间<blockquote><p>C语言中的<code>malloc</code>和<code>free</code>，C++中的<code>new</code>和<code>delete</code>均是在堆中进行的<br>正常情况下，程序员申请的空间在使用结束后应该释放<br>若程序员没有释放空间，则程序结束时系统自动回收<br>注意: 这里的”堆”并不是数据结构中的”堆”</p></blockquote></li><li>全局(静态)存储区: 分为DATA段和BSS段<blockquote><p>DATA段(全局初始化区)存放初始化的全局变量和静态变量<br>BSS段(全局未初始化区)存放未初始化的全局变量和静态变量<br>程序运行结束时自动释放<br>其中BBS段在程序执行之前会被系统自动清0<br>所以未初始化的全局变量和静态变量在程序执行之前已经为0</p></blockquote></li><li>文字常量区: 存放常量字符串<blockquote><p>程序结束后由系统释放</p></blockquote></li><li>程序代码区: 存放程序的二进制代码。</li></ol><ul><li><p>所以C语言中的全局变量和局部变量在内存中是有区别的</p></li><li><p>C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中</p><blockquote><p>并且占用永久性的存储单元<br>局部变量，即自动变量，保存在栈中<br>只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元</p></blockquote></li><li><p>可以分析以下程序的运行结果，以便更直观的去了解其区别:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> k1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k2;</span><br><span class="line">static <span class="keyword">int</span> k3 = <span class="number">2</span>;</span><br><span class="line">static <span class="keyword">int</span> k4;</span><br><span class="line"><span class="keyword">int</span> main( )</span><br><span class="line">&#123;  staticint m1=<span class="number">2</span>, m2;</span><br><span class="line">    inti=<span class="number">1</span>;</span><br><span class="line">    char*p;</span><br><span class="line">    charstr[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    char*<span class="keyword">q</span> = <span class="string">"hello"</span>;</span><br><span class="line">    p= (char *)malloc( <span class="number">100</span> );</span><br><span class="line">    free(p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"栈区-变量地址  i：%p\n"</span>, &amp;i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                p：%p\n"</span>, &amp;p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"              str：%p\n"</span>, str);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                q：%p\n"</span>, &amp;<span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"堆区地址-动态申请：%p\n"</span>, p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"全局外部有初值 k1：%p\n"</span>, &amp;k1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外部无初值 k2：%p\n"</span>, &amp;k2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"静态外部有初值 k3：%p\n"</span>, &amp;k3);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外静无初值 k4：%p\n"</span>, &amp;k4);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态有初值 m1：%p\n"</span>, &amp;m1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态无初值 m2：%p\n"</span>, &amp;m2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"文字常量地址    ：%p, %s\n"</span>,<span class="keyword">q</span>, <span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"程序区地址      ：%p\n"</span>,&amp;main);</span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h3><ul><li><p>这里对于存储类的说明只针对于变量</p></li><li><p>存储类定义 C 程序中变量或函数的范围(可见性)和生命周期</p><blockquote><p>所谓的声明周期与可见性(范围)就是指定变量在程序或函数内所生效的时间，或将其称之为在内存内所产生存在意义的阶段</p></blockquote></li><li><p>这些说明符放置在它们所修饰的类型之前</p><blockquote><p>例如 <code>auto int mouth</code></p></blockquote></li><li><p>C 程序中可用的存储类:</p><blockquote><p>auto<br>register<br>static<br>extern</p></blockquote></li></ul><p><strong>C内各存储类明细:</strong></p><p><strong>auto 存储类</strong></p><ul><li>auto 存储类是所有局部变量默认的存储类</li><li>auto 只能用在函数内，即 auto 只能修饰局部变量</li></ul><p><strong>register 存储类</strong></p><ul><li><p>register 存储类用于定义存储在寄存器中而不是RAM中的局部变量</p><blockquote><p>这意味着变量的最大尺寸等于寄存器的大小(通常是一个词)，且不能对它应用一元的<code>&#39;&amp;&#39;</code>运算符(因为它没有内存位置)</p></blockquote></li><li><p>存在意义</p><blockquote><p>在寄存器只用于需要快速访问的变量时进行使用，比如计数器<br>还应注意的是，定义<code>&#39;register&#39;</code>并不意味着变量将被存储在寄存器中<br>它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制</p></blockquote></li></ul><hr><p><strong>static 存储类</strong></p><ul><li>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁<blockquote><p>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></blockquote></li></ul><ul><li><p>static 修饰符也可以应用于全局变量</p><blockquote><p>当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内</p></blockquote></li><li><p>全局声明的一个 static 变量或方法可以被任何函数或方法调用</p><blockquote><p>只要这些方法出现在跟 static 变量或方法同一个文件中</p></blockquote></li><li><p>即在程序内的任何函数内对任何经由此声明的变量，不会在任何此调用时时进行重置</p></li></ul><p><strong>extern 存储类</strong></p><ul><li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的</li><li>即为当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置</li><li>当有多个文件且定义了一个可以在其它文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用</li><li>可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数</li><li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</li></ul><hr><p><strong>存储类整合说明:</strong></p><ul><li>auto 是局部变量的默认存储类, 限定变量只能在函数内部使用</li><li>register 代表了寄存器变量，不在内存中使用</li><li>static是全局变量的默认存储类,表示变量在程序生命周期内可见</li><li>extern 表示全局变量，即对程序内所有文件可见，类似于Java中的public关键字</li></ul><hr><p><strong>C 语言中全局变量，局部变量，静态全局变量，静态局部变量的区别</strong></p><p><strong>从作用域进行区分:</strong></p><ol><li><p>全局变量具有全局作用域</p><blockquote><p>全局变量只需在一个源文件中定义，就可以作用于所有的源文件<br>当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量</p></blockquote></li><li><p>静态局部变量具有局部作用域</p><blockquote><p>它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在<br>它和全局变量的区别在于全局变量对所有的函数都是可见的<br>而静态局部变量只对定义自己的函数体始终可见</p></blockquote></li><li><p>局部变量也只有局部作用域</p><blockquote><p>它是自动对象(auto)<br>它在程序运行期间不是一直存在，而是只在函数执行期间存在<br>函数的一次调用执行结束后，变量被撤销<br>其所占用的内存也被收回</p></blockquote></li><li><p>静态全局变量也具有全局作用域</p><blockquote><p>它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里<br>不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域<br>这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</p></blockquote></li></ol><p><strong>从分配内存空间来区分</strong></p><ol><li><p>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间</p><blockquote><p>而局部变量在栈里分配空间</p></blockquote></li><li><p>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式</p><blockquote><p>这两者在存储方式上并无不同<br>这两者的区别虽在于，非静态全局变量的作用域是整个源程序<br>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的<br>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效<br>在同一源程序的其它源文件中不能使用它<br>由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br>因此可以避免在其它源文件中引起错误</p></blockquote></li></ol><ul><li><p>静态变量会被放在程序的静态数据存储区(全局可见)中</p><blockquote><p>这样可以在下一次调用的时候还可以保持原来的赋值<br>这一点是它与堆栈变量和堆变量的区别</p></blockquote></li><li><p>变量用static告知编译器，自己仅仅在变量的作用范围内可见</p><blockquote><p>这一点是它与全局变量的区别</p></blockquote></li><li><p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期</p><blockquote><p>把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围<br>因此static 这个说明符在不同的地方所起的作用是不同的，应予以注意</p></blockquote></li></ul><p><strong>其它说明:</strong></p><ul><li>A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度</li><li>B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</li><li>C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见</li><li>D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为: 带”内部存储器”功能的的函数)</li><li>E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针</li></ul><hr><ul><li><p>其它的相关概念与具体的使用在以后实践时会进行相应的补充</p></li><li><p>C语言最大的优势是对于底层硬件结构的管理，其指针和其它缺省变量是最接近于内存的</p></li></ul><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>涉及概念</strong></p><ul><li>数据结构</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><p><strong>未涉及概念</strong></p><ul><li>常量</li><li>运算符</li><li>判断</li><li>循环</li></ul><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><hr><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><strong>C 作用域规则及其概念</strong></p><ul><li><p>所谓的变量作用域，就是变量所能够产生作用的代码块所属区域</p></li><li><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问</p></li><li><p>C 语言中有三个地方可以声明变量:</p></li></ul><ol><li>在函数或块内部的局部变量</li><li>在所有函数外部的全局变量</li><li>在形式参数的函数参数定义中</li></ol><ul><li>相关概念: 局部变量，全局变量和形式参数</li></ul><p><strong>局部变量</strong></p><ul><li>在某个函数或块的内部声明的变量称为局部变量<blockquote><p>它们只能被该函数或该代码块内部的语句使用<br>局部变量在函数外部是不可知的</p></blockquote></li></ul><p><strong>全局变量</strong></p><ul><li><p>全局变量是定义在函数外部，通常是在程序的顶部</p><blockquote><p>全局变量在整个程序生命周期内都是有效的<br>在任意的函数内部能访问全局变量</p></blockquote></li><li><p>全局变量可以被任何函数访问</p><blockquote><p>也就是说，全局变量在声明后整个程序中都是可用的</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li><p>函数的参数，形式参数，被当作该函数内的局部变量</p><blockquote><p>如果与全局变量同名它们会优先使用</p></blockquote></li><li><p>全局变量与局部变量在内存中的区别：</p><blockquote><p>全局变量保存在内存的全局存储区中，占用静态的存储单元<br>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></blockquote></li><li><p>通常使用static修饰符/关键字来定义全局/局部变量</p></li></ul><p><strong>初始化局部/全局变量</strong></p><ul><li>在定义全局或局部变量时需要先对其进行初始化<blockquote><p>初始化局部变量和全局变量<br>当局部变量被定义时，系统不会对其初始化，必须人为/自行的对其初始化<br>定义全局变量时，系统会自动对其初始化<br>初始化即为对其变量进行赋值</p></blockquote></li></ul><p><strong>全局变量自动初始化的值如下所示:</strong></p><table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">‘\0’</td></tr><tr><td align="left">float</td><td align="left">0</td></tr><tr><td align="left">double</td><td align="left">0</td></tr><tr><td align="left">pointer</td><td align="left">NULL</td></tr></tbody></table><ul><li>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果<blockquote><p>比如因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值</p></blockquote></li></ul><hr><h3 id="数据类型-派生类型-函数类型"><a href="#数据类型-派生类型-函数类型" class="headerlink" title="数据类型-派生类型/函数类型"></a>数据类型-派生类型/函数类型</h3><ul><li><p>函数的本质是存储结构化语句的数据类型</p></li><li><p>语句可以由变量或其它任何的数据类型构成</p></li><li><p>还可以说，任何的C程序都是由函数数据类型构成的</p></li><li><p>函数是一组一起执行一个任务的语句</p><blockquote><p>每个C程序都至少有一个函数，即主函数<code>main()</code><br>所有简单的程序都可以定义其他额外的函数<br>还可以把代码划分到不同的函数中<br>如何划分代码到不同的函数中是由人为所的<br>但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的</p></blockquote></li><li><p>函数声明告诉编译器函数的名称，返回类型和参数</p><blockquote><p>函数定义提供了函数的实际主体</p></blockquote></li><li><p>C 标准库提供了大量的程序可以调用的内置函数</p><blockquote><p>例如，函数<code>strcat()</code>用来连接两个字符串，函数<code>memcpy()</code>用来复制内存到另一个位置</p></blockquote></li><li><p>函数还有很多叫法，比如方法，子例程或程序，等等</p></li></ul><p><strong>定义函数的基本语法-C:</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="keyword">function</span><span class="constructor">_name( <span class="params">parameter</span> <span class="params">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body <span class="keyword">of</span> the <span class="keyword">function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li>在 C 语言中，函数由一个函数头和一个函数主体组成<blockquote><p>下面列出一个函数的所有组成部分:</p></blockquote></li></ul><ol><li>返回类型: 一个函数可以返回一个值<blockquote><p><code>return_type</code>是函数返回的值的数据类型<br>有些函数执行所需的操作而不返回值<br>在这种情况下，<code>return_type</code>是关键字<code>void</code></p></blockquote></li><li>函数名称: 这是函数的实际名称<blockquote><p>函数名和参数列表一起构成了函数签名</p></blockquote></li><li>参数: 参数就像是占位符<blockquote><p>当函数被调用时，您向参数传递一个值，这个值被称为实际参数<br>参数列表包括函数参数的类型，顺序，数量<br>参数是可选的，也就是说，函数可能不包含参数</p></blockquote></li><li>函数主体: 函数主体包含一组定义函数执行任务的语句</li></ol><hr><p><strong>函数声明</strong></p><ul><li><p>函数声明会告诉编译器函数名称及如何调用函数</p><blockquote><p>函数的实际主体可以单独定义</p></blockquote></li><li><p>函数声明包括以下几个部分：</p><blockquote><p><code>return_type function_name( parameter list );</code></p></blockquote></li><li><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的</p></li><li><p>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的</p><blockquote><p>在这种情况下，您应该在调用函数的文件顶部声明函数</p></blockquote></li></ul><hr><p><strong>调用函数</strong></p><ul><li><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务</p></li><li><p>当程序调用函数时，程序控制权会转移给被调用的函数</p><blockquote><p>被调用的函数执行已定义的任务，当函数的返回语句被执行时<br>或到达函数的结束括号时，会把程序控制权交还给主程序</p></blockquote></li><li><p>调用函数时，传递所需参数</p><blockquote><p>如果函数返回一个值，则可以存储返回值</p></blockquote></li></ul><hr><p><strong>函数参数</strong></p><ul><li><p>如果函数要使用参数，则必须声明接受参数值的变量</p><blockquote><p>这些变量称为函数的形式参数</p></blockquote></li><li><p>形式参数就像函数内的其他局部变量</p><blockquote><p>在进入函数时被创建，退出函数时被销毁</p></blockquote></li><li><p>当调用函数时，有两种向函数传递参数的方式：</p></li></ul><ol><li>传值调用: 该方法把参数的实际值复制给函数的形式参数<blockquote><p>在这种情况下，修改函数内的形式参数不会影响实际参数</p></blockquote></li><li>引用调用: 通过指针传递方式，形参为指向实参地址的指针<blockquote><p>当对形参的指向操作时，就相当于对实参本身进行的操作</p></blockquote></li></ol><ul><li>默认情况下，C 使用传值调用来传递参数<blockquote><p>一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数</p></blockquote></li></ul><hr><p><strong>内部函数与外部函数</strong></p><ul><li>根据函数能否被其他源文件调用，可以将函数区分为内部函数和外部函数</li></ul><p><strong>内部函数</strong></p><ul><li><p>如果一个函数只能被本文件中其他函数所调用，它称为内部函数</p><blockquote><p>在定义内部函数时，在函数名和函数类型的前面加 static，即<br><code>static 类型名 函数名 (形参表)</code><br>例如，函数的首行：<br><code>static int max(int a,int b)</code></p></blockquote></li><li><p>内部函数又称静态函数</p><blockquote><p>使用内部函数，可以使函数的作用域只局限于所在文件<br>即使在不同的文件中有同名的内部函数，也互不干扰<br>提高了程序的可靠性</p></blockquote></li></ul><p><strong>外部函数</strong></p><blockquote><p>如果在定义函数时，在函数的首部的最左端加关键字 extern<br>则此函数是外部函数，可供其它文件调用<br>如函数首部可以为<br><code>extern int max (int a,int b)</code><br>C 语言规定，如果在定义函数时省略 extern，则默认为外部函数</p></blockquote><ul><li>在需要调用此函数的其他文件中，需要对此函数作声明(即使在本文件中调用一个函数，也要用函数原型来声明)<blockquote><p>在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数</p></blockquote></li></ul><hr><p><strong>内联函数</strong></p><ul><li><p>内联函数是指用inline关键字修饰的函数</p><blockquote><p>在类内定义的函数被默认成内联函数<br>内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质</p></blockquote></li><li><p>内联扩展是用来消除函数调用时的时间开销</p><blockquote><p>它通常用于频繁执行的函数，对于小内存空间的函数非常受益</p></blockquote></li><li><p>使用内联函数的时候要注意:</p><blockquote><p>递归函数不能定义为内联函数<br>内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数<br>内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数<br>对内联函数不能进行异常的接口声明</p></blockquote></li></ul><hr><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><ul><li><p>形参与实参出现在函数中</p></li><li><p>形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用</p></li><li><p>实参出现在主调函数中，进入被调函数后，实参变量也不能使用</p></li></ul><p><strong>关于调用:</strong></p><ul><li><p>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元</p><blockquote><p>因此，形参只在函数内部有效<br>函数调用结束返回主调用函数后则不能再使用该形参变量</p></blockquote></li><li><p>实参可以是常量，变量，表达式，函数等</p><blockquote><p>无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参<br>因此应预先用赋值，输入等办法使参数获得确定值</p></blockquote></li></ul><p><strong>指针影响:</strong></p><ul><li>不是指针类型在内存中位置不同:</li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量<blockquote><p>它们在内存中位于不同的位置，形参将实参的内容复制一份<br>在该函数运行结束的时候形参被释放，而实参内容不会改变</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li>形式参数即为只是作为某种形式而存在于程序种的参数<blockquote><p>此类参数即为未进行赋值或者使用的参数</p></blockquote></li></ul><p><strong>实际参数</strong></p><ul><li><p>实际参数即为已经对其赋值或已经进行使用的参数</p></li><li><p>从字面上理解，所谓形式参数即只只是声明了一个作为参数的变量，并未直接进行赋值使用，而实际参数则相反</p></li><li><p>关于C语言形参与实参的区别:</p><blockquote><p>实参可以是变量，变量与表达式，实参与形参<br>实参与形参类型相同或赋值兼容<br>在调用函数过程中发生的实参与形参之间的数据传递，常称为”虚实结合”</p></blockquote></li></ul><ol><li>在定义函数中制定的形参，在没有出现函数调用时不占用内存中的存储单元<blockquote><p>在函数调用时才分配内存</p></blockquote></li><li>将实参的值传递给形参</li><li>在执行函数时，由于形参已经有值<blockquote><p>可以用形参进行运算</p></blockquote></li><li>通过return语句将函数值返回，若无返回值，则无return</li><li>调用结束后，形参被释放掉，实参保留原值(单向传值)</li></ol><hr><ul><li>可能还需要对其进行大量的补充，实践时会进行说明</li></ul><hr><ul><li>数据类型-派生类型/数组</li><li>数据类型-派生类型/指针</li><li>数据类型-派生类型/结构体类型</li><li>数据类型-派生类型/共用体类型</li><li>数据类型-派生类型/函数类型</li></ul><hr><h2 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h2><h3 id="数据类型-派生类型-数组"><a href="#数据类型-派生类型-数组" class="headerlink" title="数据类型-派生类型/数组"></a>数据类型-派生类型/数组</h3><ul><li><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合</p><blockquote><p>数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量</p></blockquote></li><li><p>数组用于存放相同类型的变量，还可以称其本质即为变量</p></li><li><p>声明一个数组，就相当于声明一个变量的集合，并且此集合内的变量通常为相同的类型</p><blockquote><p>比如声明一个number[100]，就相当于声明了100个名为number的变量<br>而这些变量用number[1],number[2],…,number[100]来进行标识，即数组中的特定元素可以通过索引来访问</p></blockquote></li><li><p>所有的数组都是由连续的内存位置组成的，其中最低的地址对应第一个元素，而最高的地址对应最后一个元素</p></li><li><p>数组于内存间的结构图片:</p></li></ul><hr><ul><li><p>声明数组的基本语法</p><blockquote><p>C 中要声明一个数组，需要指定数组内元素的类型和元素的数量<br><code>type arryName [ arraySize ];</code></p></blockquote></li><li><p>此语法所声明的数组被称之为一维数组，<code>arrySize</code>必须是一个大于零的整数常量</p><blockquote><p>而type可以是任何有效的C 数据类型<br>例如 <code>int serow[10];</code></p></blockquote></li><li><p>初始化数组(给数组进行赋值):</p><blockquote><p><code>type arryName [ arraySize ] = {进行线性赋值，用&#39;,&#39;分隔}</code><br><code>{}</code>之中值的数目不能超过<code>[]</code>间所定义的元素枢数目</p></blockquote></li><li><p>数组的赋值规则与物理内存地址的定义与赋值规则是完全线性的</p></li><li><p>访问数组内元素:</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> serow = unit[<span class="number">9</span>]; <span class="comment">//将数组unit中的第10个元素的值赋给serow变量</span></span><br></pre></td></tr></table></figure><hr><p><strong>至此</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 21:46:49 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型概念理解-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>变量-1</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E5%8F%98%E9%87%8F-1/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E5%8F%98%E9%87%8F-1/</id>
    <published>2020-03-09T05:12:41.000Z</published>
    <updated>2020-03-09T05:29:31.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>变量概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-变量"><a href="#计算机科学-变量" class="headerlink" title="计算机科学-变量"></a>计算机科学-变量</h2><ul><li>变量-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li><p>基本概念</p></li><li><p>概念整合</p></li><li><p>操作原理</p></li><li><p>标识原理</p></li><li><p>类型明细</p></li><li><p>内存分配</p></li><li><p>别名实现</p></li><li><p>参数明细</p></li><li><p>作用域与生命周期</p></li><li><p>线性表</p></li><li><p>数据结构-顺序存储结构</p></li><li><p>线性存储原理</p></li><li><p>堆栈</p></li></ul><hr><p><strong>任何数据类型与概念皆可称为变量，而变量也可以数据类型区分</strong></p><p><strong>函数结构化了变量，或称函数由变量构成</strong></p><hr><h2 id="变量概念明细"><a href="#变量概念明细" class="headerlink" title="变量概念明细:"></a>变量概念明细:</h2><ul><li>文字内关于变量的概念特指计算机科学内的变量概念</li><li>与数学间变量的概念会加以区分</li></ul><hr><p><strong>概述:</strong></p><ul><li>变量用于具体指向存储器内的存储空间的数据类型<blockquote><p>并且存储于变量内的数据是跟随程序的变化而变化的，这里类似于数学种变量的概念<br>每个不同的变量在计算机内所占有硬件的资源(存储空间或内存)都是有对应标识的(此标识概念被归纳于变量定义的概念内)</p></blockquote></li></ul><hr><p><strong>详细描述:</strong></p><ul><li>在计算机内，任何被人为定义的任何变量概念都是为了用于指向电脑内存储器的存储空间<blockquote><p>或称为，在计算机科学上，变量可以指在电脑存储器里存在值的被命名的存储空间</p></blockquote></li><li>变量所存储的内容被包含于变量的定义内，而变量名则是对于该变量所占用物理空间或称区域的命名与标识</li></ul><p><strong>语言区别:</strong></p><ul><li><p>各个程序语言之间对于变量的概念有不同的定义，但本质上都是相同的</p><blockquote><p>变量通常是可被修改的，即可以用来表示可变的状态<br>这是许多语言(如Java)的基本概念之一<br>有的语言可能定义其它术语，如C语言的左值来精确地表示这里的(可能匿名的)存储空间的概念<br>而”变量”则在变量名的意义上被强调<br>而还有些编程语言中的变量必须带有类型</p></blockquote></li><li><p>当某个已宣告变量开始使用，解释器或编译器通常会设置一个空间来存储所给出的值</p><blockquote><p>稍后该变量不再使用时，那些空间可以回收</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>也有观点认为，变量应该和数学的原意/义一致<blockquote><p>不需要允许它储存的值可变，不需要有能力表示可变状态<br>Haskell的类型变量仍然符合这个含义</p></blockquote></li></ul><hr><h2 id="概念理解整合"><a href="#概念理解整合" class="headerlink" title="概念理解整合"></a>概念理解整合</h2><ul><li>变量(Variable，scalar)</li></ul><p><strong>在程序设计中的变量所涉及的概念:</strong></p><ul><li>变量是指一个包含部分已知或未知数值或信息(即一个值)之/的存储地址<blockquote><p>以及相对应之符号名称(识别字)<br>通常使用变量名称引用存储值</p></blockquote></li></ul><p><strong>别名的意义(接上文识别字的概念):</strong></p><ul><li>用以将名称和内容分开，以能让被使用的名称独立于，所表示的精确消息之外</li><li>电脑源代码中的识别字能在运行期间绑扎一个值，且该变量的值可能在程序运行期间改变<blockquote><p>程序设计中的变量不一定能直接对应到数学中所谓的变量之概念<br>在程序设计中，变量的值不一定要为方程或数学公式之一部分</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>计算机变量与数学变量的区别:<blockquote><p>程序设计中的变量可使用在一段可重复的程序: 在一处赋值，然后使用于另一处，接着在一次赋值，且以相同方式再使用一次(涉及迭代概念)<br>程序设计中的变量通常会给定一个较长的名称，以描述其用途<br>而数学中的变量通常较为简洁，只给定一、两个字母，以方便抄写及操作</p></blockquote></li></ul><p><strong>别名简述:</strong></p><p><strong>变量别名/命名的概念:</strong></p><ul><li><p>一个变量的存储地址可以被不同的识别字所引用，这种情况称之为别名</p><blockquote><p>使用其中一个识别字为变量赋值，将会改变透过另一个识别字访问的值</p></blockquote></li><li><p>编译器必须将代表变量的名称替代成该数据所在的实际地址</p><blockquote><p>变量的名称，类型及地址通常会维持固定<br>但该地址所存储之数据于程序运行期间则可能会改变</p></blockquote></li></ul><hr><h2 id="变量各级操作的原理"><a href="#变量各级操作的原理" class="headerlink" title="变量各级操作的原理"></a>变量各级操作的原理</h2><h3 id="对于变量的使用"><a href="#对于变量的使用" class="headerlink" title="对于变量的使用:"></a>对于变量的使用:</h3><ul><li><p>又称引用变量</p><blockquote><p>涉及到标识符的概念</p></blockquote></li><li><p>标识符即为字符(人为输入的，用于识别所定义，或称所存在变量的字符串/数据类型)</p></li><li><p>用标识符引用变量能对变量进行访问，从而读出变量的值，改变变量的值</p><blockquote><p>或者改变变量的属性(如访问权限、状态锁定等)</p></blockquote></li><li><p>例如:</p><blockquote><p>一个变量用标识符<code>unit_serow</code>来引用<br>设定这个变量的值为1000<br>如果该变量同时也用<code>标识符g</code>来引用<br>然后通过<code>标识符g</code>将变量值改变为2000<br>那么读取<code>unit_serow</code>的值就是2000而不是1000</p></blockquote></li></ul><hr><ul><li><p>如果某种编程语言只允许同一个变量用一个标识符引用</p><blockquote><p>那么讨论”该变量的名字”就是有意义的，否则将其称之为”该变量的名字之一”</p></blockquote></li><li><p>例如:</p><blockquote><p>在前面的那个例子当中，<code>unit_serow</code>是这个变量的名字之一<br>而<code>标识符g</code>是这个变量的另外一个名字</p></blockquote></li></ul><hr><h3 id="对于变量的操作"><a href="#对于变量的操作" class="headerlink" title="对于变量的操作:"></a>对于变量的操作:</h3><ul><li><p>还可称为对于变量的管理</p></li><li><p>在指令式编程语言中</p><blockquote><p>变量的值通常能够随时访问或重新赋值</p></blockquote></li><li><p>但在逻辑式编程语言中</p><blockquote><p>根据参数透明的需求，变量被绑定到表达式并且在它的整个生命周期中保持同一个值</p></blockquote></li><li><p>在指令式编程语言中</p><blockquote><p>同样的行为用常量来表达，它和通常的变量存在反差</p></blockquote></li></ul><p><strong>不同语言的区别:</strong></p><ul><li>根据编程语言的类型系统的不同<blockquote><p>变量可能只存储一种特定的数据类型(如整型或字符串型)</p></blockquote></li><li>而另外一种情况，变量的数据类型能根据当前赋值而改变<blockquote><p>从而允许单个变量存储该编程语言支持的任何数据类型</p></blockquote></li></ul><hr><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li><p>变量所涉及的不同类型</p></li><li><p>在静态类型语言中</p><blockquote><p>如Java或ML等<br>每个都变量有一个类型，也就是说只有给定种类的值能存储到该变量中<br>一个基本类型的变量只能保存基本类型的值<br>一个类类型的变量能保存空值NULL，或者保存该类型或其子类型的对象<br>一个接口类型的变量能保存空值NULL，或者该接口的任何一个实现<br>一个数组类型能保存空值NULL或者一个数组</p></blockquote></li><li><p>在动态类型语言中</p><blockquote><p>如Python等<br>便是是作为值而出现的，而不是变量来携带类型信息<br>在Common Lisp中，这两种情况同时存在:<br>变量在编译时具有一个类型(如果没有声明，就假设这个类型为超类型T)<br>值也有具有一个类型，该类型可以在运行时进行检查和识别</p></blockquote></li><li><p>变量的类型也允许在编译时多态决定</p><blockquote><p>但是，这和面向对象的函数调用(在C++中称为虚函数)的多态不同</p></blockquote></li><li><p>变量常常保存简单的数据，如整数和字符串</p><blockquote><p>但有些程序设计语言允许变量同时表示多种数据类型<br>这些语言一般也允许函数参数多态<br>其函数对变量的操作可同时适用于多种数据类型</p></blockquote></li><li><p>例如:</p><blockquote><p><code>函数length</code>可以求一个列表的长度<br>如果length的类型签名中包含一个类型变量，就可以实现参数多态<br>这样，求列表中的元素个数就与列表元素的类型无关了</p></blockquote></li></ul><hr><h3 id="变量的参数概念"><a href="#变量的参数概念" class="headerlink" title="变量的参数概念"></a>变量的参数概念</h3><ul><li><p>函数的形式参数也被称为变量</p></li><li><p>如下的C++代码段：</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> AddTwo(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddTwo(<span class="number">5</span>);  <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure><ul><li>其中变量x是”形参”<blockquote><p>因为当函数被调用时会被给定一个值</p></blockquote></li><li>整数5是”实参”<blockquote><p>它给x一个值</p></blockquote></li><li>在多数语言中，函数参数具有局部的作用域<blockquote><p>这里的变量x只能在<code>AddTwo函数</code>中有效(尽管如此，其他函数也可以使用自己的变量x)</p></blockquote></li></ul><hr><h3 id="变量所对应的内存-底层概念"><a href="#变量所对应的内存-底层概念" class="headerlink" title="变量所对应的内存-底层概念"></a>变量所对应的内存-底层概念</h3><ul><li>线性存储结构(堆栈原理)示意图:<blockquote><p>线性表的顺序存储示意图</p></blockquote></li></ul><img src="/images/内存-1.png" width="40%" height="40%"><hr><ul><li><p>变量的内存分配</p></li><li><p>变量的内存空间分配和它们值的表示方法是多种多样的，这种区别体现在语言之间</p><blockquote><p>也体现在给定语言的内部使用上<br>很多语言都实现了局部变量的空间分配方式<br>局部变量保存在调用堆栈上，其生存周期维持在单个函数中，函数返回时这些内存会自动被回收(更一般的讲，变量的名字是和一些特定的连续内存块的地址绑定，对变量的操作其实是对相应的内存块进行操作)<br>对于巨大或者编译时不知道大小的数据，更常用的方法是使用”引用”<br>这时记录是值的地址而不是值本身，它们是从一种被称为栈的内存池中分配的</p></blockquote></li><li><p>绑定的变量具有值，一个抽象的值</p><blockquote><p>在程序执行时，变量的值用计算机内存中存储的一些数据对象来表示<br>程序，或者说运行时环境，必须为每个数据对象设置内存<br>由于内存是有限的<br>为了安置每一个数据对象，当数据对象不再表示某个变量的值时，相应的内存会被回收并重新使用</p></blockquote></li><li><p>在堆中分配的对象必须被释放掉，特别是当对象不再被需要时</p><blockquote><p>在具有垃圾回收机制的语言(如C#、Java和Lisp)中<br>当变量出了其作用域再也不能被引用时运行环境会自动地回收对象<br>在不具有垃圾回收机制的语言当中<br>如C语言，程序(程序员)必须显式地分配内存，而且用完之后还要释放内存<br>如果没有这样做会造成内存泄漏<br>在这种情况下，程序运行过程中堆会逐渐消耗，最终因为内存耗尽而崩溃</p></blockquote></li><li><p>当一个变量指向动态创建的数据结构时</p><blockquote><p>可能其中一些部分只能通过变量间接的访问<br>在这种环境下，垃圾回收器(或者类似的语言特性)必须处理当变量回收时只有一部分内存能够获得的情况</p></blockquote></li></ul><hr><h3 id="变量命名的原理"><a href="#变量命名的原理" class="headerlink" title="变量命名的原理"></a>变量命名的原理</h3><ul><li><p>即为变量的命名规范</p></li><li><p>与数学当中的量不同，程序设计所用的变量和常量通常都采用多字符的名字，如<code>count</code>或者<code>size</code></p><blockquote><p>而单个字符的名字一般仅用于辅助性的变量，如<code>i</code>，<code>j</code>，<code>k</code>常作为数组索引的变量</p></blockquote></li><li><p>一些命名规范是作为语法在语言层面强制执行的</p><blockquote><p>在大多数语言当中，变量名不能以数字开头，不能包含空格符<br>而标点符号是否允许存在在变量名当中就要视具体语言而定了<br>很多语言仅仅允许<code>下划线&#39;_&#39;</code>存在在变量名当中，而禁止其他所有的标点符号<br>而有些编程语言，特殊字符作为前缀或后缀添加在变量标识符当中来表明变量的类型<br>变量名的大小写敏感性也要视具体语言而定<br>大多数现代语言是大小写敏感的，一些较老的语言则不敏感<br>一些语言保留特定形式的变量名用来内部使用<br>在很多语言中，以两根下划线开头<code>__</code>的变量名常充当这种角色</p></blockquote></li><li><p>在语言语法基本的限制以外，进一步的命名风格规范也很有必要</p><blockquote><p>在机器码层面，是不会使用变量名的<br>所以计算机并不关心是否采用了准确的名字<br>正因为如此，变量名完全是作为程序员的工具而存在<br>借助这个工具程序员能更容易的编写和理解程序<br>程序员通常创建编码规范，并且坚持这些规范<br>帮助对变量命名甚至提供精确的命名规划。较短的名字便于输入<br>但是描述能力较差<br>较长的名字使程序更容易读懂，变量的意图更容易理解<br>尽管如此，冗长的变量名也可能会导致更难理解的代码</p></blockquote></li></ul><hr><p><strong>不同情况下命名规范的区别:</strong></p><ul><li><p>在源代码中</p><blockquote><p>在源代码中，变量名是将变量和内存地址绑定的一种方式<br>变量值以数据对象的形式存储在相应的地址内<br>这样该数据对象就能通过变量的名字进行访问和修改了</p></blockquote></li><li><p>在电子表格中</p><blockquote><p>在电子表格中，一个单元格可能包含参考其他单元格的公式<br>这种被参考的单元格就是一种形式的变量<br>它的值就是被参考的单元格的值</p></blockquote></li></ul><hr><h3 id="变量的作用域和生存周期"><a href="#变量的作用域和生存周期" class="headerlink" title="变量的作用域和生存周期"></a>变量的作用域和生存周期</h3><p><strong>变量作用于生存周期域的概念:</strong></p><ul><li><p>变量的作用域表示变量在原程序的文本中能被使用的范围</p><blockquote><p>变量的生存周期表示变量在程序运行过程中具有实际意义的值的时间范围<br>变量的作用域事实上是变量名字的性质<br>而变量的生存周期是变量本身是性质</p></blockquote></li><li><p>变量名字的作用域会影响它的生存周期</p></li><li><p>作用域是变量语法方面的性质</p><blockquote><p>多数语言对每一个变量(和其他名目实体)定义明确的作用域<br>这些作用域在同一个程序中可能不同<br>变量的作用域是指程序中的特定区域，在这些区域中，该变量的名字是有意义的并且变量是”可见的”<br>在进入作用域时，变量通常开始它的生命周期<br>而在离开作用域时，变量往往结束了它的生命周期</p></blockquote></li><li><p>例如:</p><blockquote><p>某个变量的语法作用域仅在特定的语句块或者子程序中<br>只有在某个函数中能访问的变量则被称为局部变量<br>在程序的任何一个地方都能引用的变量被称为全局变量</p></blockquote></li><li><p>生存周期，则是变量在运行时的性质</p><blockquote><p>在运行时，每次变量与值的绑定都具有自己的生存周期<br>绑定的生存周期是程序执行过程中的一段时间<br>在这段时间内，变量始终被关联到相同的值或者内存位置<br>在闭包的情况中，运行中的程序可能进入和离开某个生存周期很多次</p></blockquote></li><li><p>在一些代码段中，在一个变量的作用域中可能未被赋值，或者它的值已经被销毁掉了</p><blockquote><p>这类变量常被称为”生存周期外”或者”未绑定”<br>在很多语言中，试图使用未绑定的变量是一个错误<br>在其他语言中，这种行为会产生不可预期的结果，这样的变量可能被分配一个新的值<br>与之对照的是，一个变量绑定到一个超过他作用域的生存周期是被允许的<br>如Lisp的闭包和C语言的静态局部变量<br>当程序再次执行到变量的作用域时<br>变量能再次被使用，但还保持上一次的值</p></blockquote></li><li><p>为了提高空间效率，变量需要的存储空间可能要等到变量第一次使用时才申请</p><blockquote><p>不再使用后就删除<br>为了避免浪费空间，如果变量声明了但不实际使用<br>编译器通常会向程序员发出警告</p></blockquote></li><li><p>使变量的作用域尽可能的小，被认为是一个好的编程方式</p><blockquote><p>这样程序的不同部分就不会因为意外的改变对方的变量而互相影响了<br>实现上述目标的通常技术是让程序的不同部分使用不同名字空间<br>或者通过动态变量作用使用各自的私有变量</p></blockquote></li><li><p>很多程序设计语言使用保留的值(如NULL)表示没有初始化的变量</p></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下参考资料皆源于中文维基</strong></p><ul><li><p>CN-分类:变量(<a href="https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</a>)</p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</code></p></blockquote></li><li><p>CN-分类:计算机编程<a href="https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B</code></p></blockquote></li><li><p>CN-变量<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8</code></p></blockquote></li><li><p>CN-变量 (程序设计)<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)</code></p></blockquote></li></ul><hr><h2 id="补充内容-C-C"><a href="#补充内容-C-C" class="headerlink" title="补充内容-C/C++"></a>补充内容-C/C++</h2><ul><li>C/C++内变量的意义与应用<blockquote><p>见下一篇文章</p></blockquote></li></ul><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><ul><li><p>相对于编程语言(程序语言)</p></li><li><p>调用各种函数，利用正确的逻辑，来构成一个完整的程序</p></li></ul><p><strong>大体逻辑:</strong></p><ul><li><p>在函数外，也就是整个程序的内部可以定义各种常量</p><blockquote><p>然后定义各种函数，函数内定义各种变量，由变量构成各种语句<br>所谓的函数就是存储这些由变量构成的语句的区块(块结构)</p></blockquote></li><li><p>一个函数便可以称之为一个程序，或是一个功能</p><blockquote><p>之后再由若干个函数来构成一个完整的程序<br>每个函数中都应当有返回值</p></blockquote></li><li><p>所谓的常量，就是在程序当中，可以被任何函数所调用的数据类型</p></li><li><p>调用就是(即为)使用，函数就是方法，指针就是指针，用来指向某种数据类型(函数，变量等)并直接调用</p></li></ul><hr><ul><li>数据类型构建了变量与表达式</li><li>变量与表达式构建了函数</li><li>函数构建了各级功能</li><li>各级功能构建了完整的程序</li><li>其中在构建各个不同级次的程序时需要完整且正确的逻辑</li><li>在函数内的表达式与变量亦是如此</li><li>表达式，变量与函数都可以被合称为数据类型，包括指针或空值</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;变量概念理解-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>NCRE-1</title>
    <link href="https://unit-serow.github.io/2020/03/08/NCRE-1/"/>
    <id>https://unit-serow.github.io/2020/03/08/NCRE-1/</id>
    <published>2020-03-08T06:24:42.000Z</published>
    <updated>2020-03-09T05:29:55.353Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>基础概念-数据结构与算法</strong></center><a id="more"></a><h2 id="NCRE-1"><a href="#NCRE-1" class="headerlink" title="NCRE-1"></a>NCRE-1</h2><hr><h3 id="公共基础知识-1"><a href="#公共基础知识-1" class="headerlink" title="公共基础知识-1"></a>公共基础知识-1</h3><ul><li><p>网课随堂笔记</p></li><li><p>二级公共基础知识-数据结构与算法</p></li></ul><hr><p><strong>数据结构与算法</strong></p><ul><li><p>包含内容于:</p><blockquote><p>算法复杂度<br>数据结构的概念<br>栈<br>二叉树的遍历<br>二分法查找</p></blockquote></li><li><p>涉及概念:</p><blockquote><p>算法的概念，算法时间复杂度及空间复杂度的概念<br>数据结构的定义，数据逻辑结构及物理结构的定义<br>栈的定义及其运算，线性链表的存储方式<br>树与二叉树的概念，二叉树的基本性质，完全二叉树的概念，二叉树的遍历<br>二分查找法<br>冒泡排序法</p></blockquote></li></ul><p>–</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h3><ul><li><p>计算机解题的过程实际上是在实施某种算法，这种算法称为计算机算法</p></li><li><p>算法即为为解决任何问题而产生出的必要方法，语言，思维或逻辑的本质也可称为算法</p></li><li><p>算法的基本特征：可行性，确定性，有穷性，拥有足够的情报</p></li></ul><p><strong>算法的基本要素:</strong></p><ol><li>算法中对数据的运算和操作</li></ol><ul><li><p>一个算法由两种基本要素组成：</p><blockquote><p>一是对数据对象的运算和操作<br>二是算法的控制结构</p></blockquote></li><li><p>在一般的计算机系统中，基本的运算和操作有以此四类：算术运算，逻辑运算，关系运算和数据传输</p></li></ul><ol start="2"><li>算法的控制结构：<blockquote><p>算法中各操作之间的执行顺序称为算法的控制结构</p></blockquote></li></ol><ul><li><p>描述算法的工具通常有：</p><blockquote><p>传统的流程图，N-S结构化流程图，算法描述语言等</p></blockquote></li><li><p>一个算法一般都可以用顺序，选择，循环3种基本控制结构组合而成</p></li></ul><hr><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>算法复杂度包括算法时间复杂度及空间复杂度的概念</li></ul><ol><li>算法的时间复杂度<blockquote><p>算法的时间复杂度是指执行算法所需要的计算工作量<br>同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行，效率均不同<br>这表明使用绝对的时间单位衡量算法的效率是不合适的<br>撇开这些与计算机硬件，软件有关的因素，可以认为一个特定算法”运行工作量”的大小，只依赖于问题的规模(通常用整数n表示)，它是问题规模的函数<br>即为<br><code>算法的工作量=f(n)</code></p></blockquote></li></ol><p>2.算法的空间复杂度</p><blockquote><p>算法的空间复杂度是指执行这个算法所需要的内存空间<br>一个算法所占用的存储空间包括算法程序所占的空间<br>输入的初始数据所占的存储空间以及算法执行过程中所需要的额外空间<br>其中额外空间包括算法程序执行过程中的工作单元以及某种数据结构所需要的附加存储空间<br>如果额外空间量相对于问题规模来说是常数，则称该算法是原地工作的<br>在许多实际问题中，为了减少算法所占的存储空间，通常采用压缩存储技术，以便尽量减少不必要的额外空间</p></blockquote><ul><li>算法的工作量用算法所执行的基本运算次数来计算，而算法所执行的基本运算次数是问题规模的函数，即算法的工作量=f(n)<blockquote><p>n为问题规模</p></blockquote></li></ul><hr><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><ul><li><p>数据的逻辑结构和存储结构的概念</p></li><li><p>数据结构作为计算机的一门学科，主要研究和讨论以下三个方面：</p></li></ul><ol><li>数据集合中个数据元素之间所固有的逻辑关系，即数据的逻辑结构</li><li>在对数据元素进行处理时，各数据元素在计算机中的存储关系，即数据的存储结构</li><li>对各种数据结构进行的运算</li></ol><ul><li><p>数据结构基本概念：</p><blockquote><p>数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称<br>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理<br>数据对象：是性质相同的数据元素的集合，是数据的一个子集</p></blockquote></li><li><p>数据的逻辑结构是对数据元素之间的逻辑关系的描述</p><blockquote><p>它可以用一个数据元素的集合和定义在此集合中的若干关系来表示<br>数据的逻辑结构有两个要素：<br>一是数据元素的集合，通常记为D<br>二是D上的关系，它反映了数据元素之间的前后件关系，通常记为R</p></blockquote></li><li><p>一个数据结构可以表示成：<code>B=(D,R)</code></p><blockquote><p>其中B表示数据结构<br>为了反映D中各数据元素之间的前后件关系，一般用二元组来表示</p></blockquote></li><li><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构(也称数据的物理结构)</p></li><li><p>由于数据元素在计算机存储空间中的位置关系可能与逻辑关系不同</p><blockquote><p>因此，为了表示存放在计算机存储空间中的各数据元素之间的逻辑关系(即前后件关系)<br>在数据的存储结构中，不仅要存放各数据元素的信息，还需要存放各数据元素之间的前后件关系的信息</p></blockquote></li><li><p>一种数据的逻辑结构根据需要可以表示成多种存储结构</p><blockquote><p>常用的存储结构有顺序，链接，索引等存储结构<br>而采用不同的存储结构，其数据处理的效率是不同的<br>因此，在进行数据处理时，选择合适的存储结构是很重要的</p></blockquote></li></ul><hr><h3 id="线性结构与非线性结构"><a href="#线性结构与非线性结构" class="headerlink" title="线性结构与非线性结构"></a>线性结构与非线性结构</h3><ul><li><p>根据数据结构中各数据元素之间前后件关系的复杂程度</p><blockquote><p>一般将数据结构分为两大类型：线性结构与非线性结构</p></blockquote></li><li><p>如果一个非空的数据结构满足下列两个条件：</p></li></ul><ol><li>有且只有一个根结点</li><li>每一个结点最多有一个前件，也最多有一个后件<blockquote><p>则称该数据结构为线性结构<br>线性结构又称线性表<br>在一个线性结构中插入或删除任何一个结点后还应是线性结构<br>如果一个数据结构不是线性结构，则称之为非线性结构</p></blockquote></li></ol><ul><li>空的数据结构被归于线性结构还是非线性结构的条件:<blockquote><p>一个空的数据结构究竟是属于线性结构还是属于非线性结构，这要根据具体情况来确定<br>如果对该数据结构的算法是按线性结构的规则来处理的，则属于线性结构<br>否则属于非线性结构</p></blockquote></li></ul><hr><h2 id="栈及线性链表"><a href="#栈及线性链表" class="headerlink" title="栈及线性链表"></a>栈及线性链表</h2><h3 id="栈及其基本运算"><a href="#栈及其基本运算" class="headerlink" title="栈及其基本运算"></a>栈及其基本运算</h3><ul><li>涉及栈的运算</li></ul><ol><li>栈的基本概念<blockquote><p>栈是限定只在一端进行插入与删除的线性表，通常称插入，删除的这一端为栈顶，另一端为栈底<br>当表中没有元素时称为空栈<br>栈顶元素总是后被插入的元素，从而也是最先被删除的元素<br>栈底元素总是最先被插入的元素，从而也是最后才能被删除的元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据的</li></ul><ol start="2"><li>栈的顺序存储及其运算</li></ol><ul><li>用一维数组<code>S(1 : m)</code>作为栈的顺序存储空间，其中m为最大容量<blockquote><p>在栈的顺序存储空间S<code>(1∶m)</code>中<br><code>S(bottom)</code>为栈底元素，<code>S(top)</code>为栈顶元素<br><code>top=0</code>表示栈空<br><code>top=m</code>表示栈满</p></blockquote></li></ul><p><strong>栈的基本运算</strong></p><ul><li>可将其归纳为三种: 入栈，退栈与读栈顶元素</li></ul><ol><li><p>入栈运算：入栈运算是指在栈顶位置插入一个新元素</p><blockquote><p>首先将栈顶指针加一(即top加1)，然后将新元素插入到栈顶指针指向的位置<br>当栈顶指针已经指向存储空间的最后一个位置时，说明栈空间已满，不可能再进行入栈操作<br>这种情况称为栈”上溢”错误</p></blockquote></li><li><p>退栈运算：退栈是指取出栈顶元素并赋给一个指定的变量</p><blockquote><p>首先将栈顶元素(栈顶指针指向的元素)赋给一个指定的变量，然后将栈顶指针减一(即top减1)<br>当栈顶指针为0时，说明栈空，不可进行退栈操作<br>这种情况称为栈的”下溢”错误</p></blockquote></li><li><p>读栈顶元素：读栈顶元素是指将栈顶元素赋给一个指定的变量</p><blockquote><p>这个运算不删除栈顶元素，只是将它赋给一个变量，因此栈顶指针不会改变<br>当栈顶指针为0时，说明栈空，读不到栈顶元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据，但是出栈方式有多种选择</li></ul><hr><h3 id="线性链表的基本概念"><a href="#线性链表的基本概念" class="headerlink" title="线性链表的基本概念"></a>线性链表的基本概念</h3><ul><li><p>涉及结点的组成</p></li><li><p>在链式存储方式中，要求每个结点由两部分组成：</p><blockquote><p>一部分用于存放数据元素值，称为数据域<br>另一部分用于存放指针，称为指针域<br>其中指针用于指向该结点的前一个或后一个结点(即前件或后件)</p></blockquote></li><li><p>链式存储方式既可用于表示线性结构，也可用于表示非线性结构</p></li></ul><p><strong>线性链表</strong></p><ul><li>线性表的链式存储结构称为线性链表<blockquote><p>在某些应用中，对线性链表中的每个结点设置两个指针<br>一个称为左指针，用以指向其前件结点<br>另一个称为右指针，用以指向其后件结点<br>这样的表称为双向链表</p></blockquote></li></ul><p><strong>带链的栈</strong></p><ul><li><p>栈也是线性表，也可以采用链式存储结构</p><blockquote><p>带链的栈可以用来收集计算机存储空间中所有空闲的存储结点<br>这种带链的栈称为可利用栈</p></blockquote></li><li><p>在链式结构中，存储空间位置关系与逻辑关系:</p><blockquote><p>在链式存储结构中，存储数据结构的存储空间可以不连续<br>各数据结点的存储顺序与数据元素之间的逻辑关系可以不一致<br>而数据元素之间的逻辑关系是由指针域来确定的</p></blockquote></li></ul><hr><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树与二叉树及其基本性质"><a href="#树与二叉树及其基本性质" class="headerlink" title="树与二叉树及其基本性质"></a>树与二叉树及其基本性质</h3><ul><li><p>涉及树及二叉树的性质</p></li><li><p>误区警示: 满二叉树也是完全二叉树，而完全二叉树一般不是满二叉树</p></li><li><p>结构示意图:</p></li></ul><img src="/images/二叉树-1.png" width="40%" height="40%"> <img src="/images/二叉树-2.png" width="40%" height="40%"><hr><p><strong>树的基本概念</strong></p><ul><li>树(tree)是一种简单的非线性结构<blockquote><p>在树结构中，每一个结点只有一个前件，称为父结点<br>没有前件的结点只有一个，称为树的根结点<br>每一个结点可以有多个后件，它们称为该结点的子结点<br>没有后件的结点称为叶子结点</p></blockquote></li></ul><ul><li>在树结构中，一个结点所拥有的后件个数称为该结点的度<blockquote><p>叶子结点的度为0<br>在树中，所有结点中的最大的度称为树的度</p></blockquote></li></ul><p><strong>二叉树的定义及其基本性质</strong></p><p><strong>二叉树的定义</strong></p><ul><li><p>二叉树是一种很有用的非线性结构</p></li><li><p>具有以下两个特点:</p><blockquote><p>1-非空二叉树只有一个根结点<br>2-每一个结点最多有两棵子树，且分别称为该结点的左子树和右子树</p></blockquote></li><li><p>由以上特点可以看出:</p><blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树（左子树或右子树）也均为二叉树<br>而树结构中的每一个结点的度可以是任意的<br>另外，二叉树中的每个结点的子树被明显地分为左子树和右子树</p></blockquote></li><li><p>在二叉树中，一个结点可以只有左子树而没有右子树</p><blockquote><p>也可以只有右子树而没有左子树<br>当一个结点既没有左子树也没有右子树时，该结点即为叶子结点</p></blockquote></li></ul><hr><p><strong>二叉树的基本性质</strong></p><ul><li><p>二叉树具有以下几个性质：</p><blockquote><p>性质1：在二叉树的第k层上，最多有<code>2k-1 (k≥1)</code>个结点<br>性质2：深度为m的二叉树最多有<code>2m-1</code>个结点<br>性质3：在任意一棵二叉树中，度为0的结点(即叶子结点)总是比度为2的结点多一个<br>性质4：具有n个结点的二叉树，其深度至少为<code>[log2n]+1</code><br>其中[log2n]表示取log2n的整数部分<br>因为文本无法输入下标，所以本文中所有log2n都用于表示已2为底n的对数</p></blockquote></li><li><p>在二叉树的遍历中，无论是前序遍历，中序遍历还是后序遍历，二叉树的叶子结点的先后顺序都是不变的</p></li></ul><hr><p><strong>满二叉树与完全二叉树</strong></p><p><strong>满二叉树</strong></p><ul><li><p>满二叉树是指这样的一种二叉树:</p><blockquote><p>除最后一层外，每一层上的所有结点都有两个子结点<br>在满二叉树中，每一层上的结点数都达到最大值<br>即在满二叉树的第k层上有<code>2k-1</code>个结点，且深度为m的满二叉树有<code>2m-1</code>个结点</p></blockquote></li><li><p>完全二叉树是指这样的二叉树:</p><blockquote><p>除最后一层外，每一层上的结点数均达到最大值<br>在最后一层上只缺少右边的若干结点</p></blockquote></li><li><p>对于完全二叉树来说，叶子结点只可能在层次最大的两层上出现：</p><blockquote><p>对于任何一个结点，若其右分支下的子孙结点的最大层次为p<br>则其左分支下的子孙结点的最大层次或为p，或为<code>p+1</code></p></blockquote></li></ul><p><strong>完全二叉树</strong></p><ul><li><p>完全二叉树具有以下两个性质(接上文二叉树的基本性质):</p><blockquote><p>性质5: 具有n个结点的完全二叉树的深度为`[log2n]+1</p></blockquote></li><li><p>性质6: 设完全二叉树共有n个结点</p><blockquote><p>如果从根结点开始，按层次(每一层从左到右)用自然数<code>1，2，……，n</code>给结点进行编号<br>则对于编号为k（k=1，2，……，n）的结点有以下结论:<br>1-若<code>k=1</code>，则该结点为根结点，它没有父结点<br>若<code>k&gt;1</code>，则该结点的父结点编号为<code>INT(k/2) 2-若</code>2k≤n<code>，则编号为k的结点的左子结点编号为2k 否则该结点无左子结点(显然也没有右子结点) 3-若</code>2k+1≤n<code>，则编号为k的结点的右子结点编号为</code>2k+1`<br>否则该结点无右子结点</p></blockquote></li></ul><hr><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>涉及遍历的具体算法，以及能由两种遍历的结果推导另一种遍历的结果</p></li><li><p>在遍历二叉树的过程中，一般先遍历左子树，再遍历右子树</p></li><li><p>在先左后右的原则下，根据访问根结点的次序，二叉树的遍历分为三类:</p><blockquote><p>前序遍历，中序遍历和后序遍历</p></blockquote></li></ul><ol><li><p>前序遍历：先访问根结点、然后遍历左子树，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先访问根结点<br>然后遍历左子树，最后遍历右子树</p></blockquote></li><li><p>中序遍历：先遍历左子树、然后访问根结点，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后访问根结点，最后遍历右子树</p></blockquote></li><li><p>后序遍历：先遍历左子树，然后遍历右子树，最后访问根结点</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后遍历右子树，最后访问根结点</p></blockquote></li></ol><ul><li>树与二叉树的不同之处<blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树(左子树或右子树)也均为二叉树<br>而树结构中的每一个结点的度可以是任意的</p></blockquote></li></ul><hr><h2 id="查找技术"><a href="#查找技术" class="headerlink" title="查找技术"></a>查找技术</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><ul><li><p>涉及顺序查找的算法</p></li><li><p>查找是指在一个给定的数据结构中查找某个指定的元素</p><blockquote><p>从线性表的第一个元素开始，依次将线性表中的元素与被查找的元素相比较<br>若相等则表示查找成功<br>若线性表中所有的元素都与被查找元素进行了比较但都不相等<br>则表示查找失败</p></blockquote></li><li><p>在下列两种情况下也只能采用顺序查找：</p></li></ul><ol><li>如果线性表为无序表，则不管是顺序存储结构还是链式存储结构，只能用顺序查找</li><li>即使是有序线性表，如果采用链式存储结构，也只能用顺序查找</li></ol><hr><h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><ul><li><p>涉及二分查找法的算法</p></li><li><p>二分法只适用于顺序存储的，按非递减排列的有序表，其方法如下：</p><blockquote><p>设有序线性表的长度为n，被查找的元素为i<br>1-将i与线性表的中间项进行比较<br>2-若i与中间项的值相等，则查找成功<br>3-若i小于中间项，则在线性表的前半部分以相同的方法查找<br>4-若i大于中间项，则在线性表的后半部分以相同的方法查找</p></blockquote></li><li><p>二分查找法适用情况</p><blockquote><p>二分查找法只适用于顺序存储的有序表<br>在此所说的有序表是指线性表中的元素按值非递减排列(即从小到大，但允许相邻元素值相等)<br>这个过程一直进行到查找成功或子表长度为0为止<br>对于长度为n的有序线性表，在最坏情况下，二分查找只需要比较<code>log2n</code>次</p></blockquote></li></ul><hr><h3 id="排序技术"><a href="#排序技术" class="headerlink" title="排序技术"></a>排序技术</h3><ul><li><p>交换类排序法</p></li><li><p>涉及排序算法的基本过程</p></li><li><p>冒泡排序法和快速排序法都属于交换类排序法</p></li></ul><p><strong>冒泡排序法</strong></p><ol><li><p>首先，从表头开始往后扫描线性表，逐次比较相邻两个元素的大小</p><blockquote><p>若前面的元素大于后面的元素，则将它们互换，不断地将两个相邻元素中的大者往后移动<br>最后最大者到了线性表的最后</p></blockquote></li><li><p>然后，从后到前扫描剩下的线性表，逐次比较相邻两个元素的大小，若后面的元素小于前面的元素，则将它们互换</p><blockquote><p>不断地将两个相邻元素中的小者往前移动<br>最后最小者到了线性表的最前面</p></blockquote></li><li><p>对剩下的线性表重复上述过程，直到剩下的线性表变空为止，此时已经排好序</p><blockquote><p>在最坏的情况下，冒泡排序需要比较次数为<code>n(n－1)/2</code>次</p></blockquote></li></ol><p><strong>快速排序法</strong></p><ul><li><p>它的基本思想是：</p><blockquote><p>任取待排序序列中的某个元素作为基准(一般取第一个元素)<br>通过一趟排序，将待排元素分为左右两个子序列<br>左子序列元素的排序码均小于或等于基准元素的排序码<br>右子序列的排序码则大于基准元素的排序码<br>然后分别对两个子序列继续进行排序<br>直至整个序列有序。</p></blockquote></li><li><p>冒泡排序和快速排序的平均执行时间:</p><blockquote><p>冒泡排序法的平均执行时间是O(n2)<br>而快速排序法的平均执行时间是O(nlog2n)</p></blockquote></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下内容参考自中文维基:</strong></p><ul><li><p>CN-具体数学<a href="https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8</code></p></blockquote></li><li><p>CN-线性代数<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0</code></p></blockquote></li><li><p>CN-离散数学<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6</code></p></blockquote></li><li><p>CN-概率论<a href="https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA</code></p></blockquote></li><li><p>CN-二分查找算法<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-算法分析<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90</code></p></blockquote></li><li><p>CN-排序算法<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-数据结构<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</code></p></blockquote></li><li><p>CN-二叉树<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li><li><p>CN-Category:Binary trees<a href="https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn</code></p></blockquote></li><li><p>CN-分类-二叉树<a href="https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li></ul><p><strong>以下为已使用电子书籍资源:</strong></p><ul><li><p>全国计算机二级考试公共基础知识完整版整合</p></li><li><p>计算机二级公共基础知识完整</p></li><li><p>二级公共基础知识电子书</p></li><li><p>公共基础知识总和本(无密)</p></li><li><p>资源获取-百度网盘(永久链接)<a href="https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w" target="_blank" rel="noopener">跳转</a></p><blockquote><p>链接: <code>https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w</code><br>提取码: aynj</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;基础概念-数据结构与算法&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MS-SQL-1</title>
    <link href="https://unit-serow.github.io/2020/03/07/MS-SQL-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/MS-SQL-1/</id>
    <published>2020-03-07T08:43:29.000Z</published>
    <updated>2020-03-07T08:59:01.899Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>Access/MS SQL基本概念归纳</strong></center><a id="more"></a><h2 id="MS-SQL-1"><a href="#MS-SQL-1" class="headerlink" title="MS SQL-1"></a>MS SQL-1</h2><ul><li><p>网课随堂笔记</p></li><li><p>Access</p></li><li><p>MS SQL</p></li><li><p>数据库基础概念相关知识(数据抽象/数据模型/关系模型/各级关系运算)</p></li></ul><hr><h3 id="1-数据抽象"><a href="#1-数据抽象" class="headerlink" title="1. 数据抽象"></a>1. 数据抽象</h3><ul><li>设计数据库就是对数据的抽象过程:<blockquote><p><code>用户需求-抽象-&gt;概念模型-转换-&gt;[逻辑数据模型(外部模型)]-&gt;物理模型-&gt;数据库</code></p></blockquote></li><li>物理模型用于实现在数据库中对数据的存储</li><li>设计数据库的主要工作是构造数据模型</li><li>数据模型是对现实世界中数据特征的抽象</li><li>数据抽象中的数据模型主要有四种</li><li>概念模型 实体联系模型，可用于表达用户需求观点的数据全局逻辑结构的模型</li><li>ER图表示，ER图通常需要进行优化<blockquote><p><code>局部概念模型-&gt;全局概念模型</code></p></blockquote></li><li>ER图通常十分直观且形象</li></ul><hr><ul><li>逻辑模型<blockquote><p>用于表达计算机实现观点的数据库全局逻辑结构的模型<br>以树结构组织数据被称为层次模型<br>以网状结构组织数据称为网状模型<br>以二维表组织数据称之为关系模型(通常为主流数据模型)<br>ER图转化为逻辑模型<br>一对多，多对多，一对一，数据结构中存在几个实体对象，就将之称为几元联系<br>关系模式-(关系名-&gt;属性名)</p></blockquote></li><li>所有实体对象的集合被称之为关系</li></ul><hr><ul><li>内部模型<blockquote><p>即为物理模型<br>是用于表达数据库物理结构的数据库全局模型<br>以概念模型为基础，而转换处物理模型(内部模型)<br>有了物理模型，即可以在数据库中建立与之相对应的表结构</p></blockquote></li></ul><hr><ul><li>外部模型<blockquote><p>是用于表达用户使用观点的数据库局部逻辑结构的模型<br><code>[逻辑模型(若干外部模型)]</code><br>数据抽象过程</p></blockquote></li></ul><hr><ul><li><p>关系模型</p><blockquote><p>数据模型是一种严格定义的概念模型<br>关系模型精准的定义了数据结构，以及表与表之间可能发生的各种数据操作与管理，包括数据完整性操作<br>关系模型是以二维表的形式来组织数据<br>支持关系模型的数据库即为关系数据库<br>它使用若干个数据表来存储数据，此间可将一张二维表称之为关系<br>而关系的集合即为关系数据库</p></blockquote></li><li><p>关系模型的有关概念</p><blockquote><p>元组:表中的行，或称为记录<br>属性:表中的列，或称为字段与数据项<br>域:属性的取值范围<br>分量:一个属性的值<br>码:表中某个属性或属性组唯一标识一个元组<br>比如在一个表内，ID字符标识了所在行的整个元组，则称ID为码，即为关系模式约束<br><code>概念模型-&gt;逻辑模型-&gt;物理模型(内部模型)</code></p></blockquote></li><li><p>同种类型的实体集合被称之为实体型</p></li><li><p>在逻辑模型中所设计的一切概念，都被称之为关系模式</p><blockquote><p>关系模式由关系名及其属性的集合构成<br>在逻辑模型中将其称之为关系</p></blockquote></li><li><p>在内部模型中，也就是表结构，实体集为同一类型的表所属的数据集合</p><blockquote><p>在关系模型中将其称之为表</p></blockquote></li><li><p>为何把表称之为关系</p><blockquote><p>数学上把一系列域上的笛卡尔积的子集称为关系<br>而表正符合此定义</p></blockquote></li><li><p>域是一组具有相同类型的值的集合</p><blockquote><p>比如: 整型，实型或指定长度的字符串集合<br>而关系中属性的域可以被理解为属性的取值范围<br>比如学生中的性别属性，它的域就是男与女两个字符串</p></blockquote></li><li><p>笛卡尔积</p><blockquote><p>所有域的所有取值的任意集合<br>在数学中，以乘号来描述此概念<br>即<code>A*B={(x,y)|x∈A^y∈B}</code></p></blockquote></li><li><p>设集<code>A={a,b}</code>，集<code>B={0,1,2}</code></p><blockquote><p>即A的两个值乘以B的三个值<br>则两个集合的笛卡尔积为<code>{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}</code><br>如果A表示某学校学生的集合，B表示改学校所有课程的集合<br>则A与B的笛卡尔积可以用于表示所有的选课情况<br>A如果表示声母集合，B如果表示所有的声母集合，则A与B的笛卡尔积则可表示所有汉字的读音组合</p></blockquote></li><li><p>笛卡尔积并不都是有意义的</p><blockquote><p>设集<code>A={01,02}</code>,集<code>B={张三,李四}</code><br>则两个集合的笛卡尔积为<code>{(01,张三),(01,李四),(02,张三),(02,李四)}</code><br>如果A代表学号，B代表姓名，假设张三的学号是一号，而李四是二号<br>所以该笛卡尔积的结果集中，01的李四与02的张三是没有意义的</p></blockquote></li><li><p>数学上将一系列域上的笛卡尔积的子集称之为关系</p></li><li><p>而笛卡尔积中具有意义的那些元组则才被称之为关系</p></li><li><p>不是所有的二维表都是关系，关系是有以下特性的:</p><blockquote><p>关系必须规范化，比如: 每个表有多行，每个行有多列，每个行列单元都是不能再分的原子值<br>在同一关系中不允许出现相同的属性名<br>而关系中不允许有完全相同的元组<br>并且同一关系中元组及其属性的顺序可以随意</p></blockquote></li><li><p>严格的去定义表的具体规则与基本要求</p></li></ul><hr><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul><li><p>关系操作与数据查询操作可以用关系代数与关系逻辑的方法描述</p></li><li><p>或用具体的数据库语言，如SQL-结构化查询语言来描述与实现</p></li><li><p>最基本的方法是代数方法，即关系代数</p><blockquote><p><code>关系A&lt;-运算集合-&gt;关系B=关系C</code><br>代数是数学概念，同时关系代数也同为数学概念<br>运算符包括一系列运算集合<br>两个不同的关系通过一个运算符的运算来获得一个新的关系结果</p></blockquote></li><li><p>关系运算的运算符有两类，即为集合运算符和专门的关系运算符</p></li><li><p>选择运算</p><blockquote><p>选择运算是从关系中找出满足条件的元组的元组的操作<br>将其记为: <code>σ[(下标)&lt;条件表达式&gt;] (R)</code><br>用处于右下角的谓词来写条件表达式<br>其中，σ是选择运算符，R是关系名</p></blockquote></li><li><p>选择运算是根据给定的条件选择关系R中的若干元组而组成的新关系，是对关系的元组进行筛选</p><blockquote><p>结果关系与原关系有着相同的模式<br>可以将其表示为: <code>σ[(下标)sex]=R(tables_name)</code><br>在<code>tables_name</code>表中，找出sex字段等于R的所有记录<br>所以选择运算是对于行的操作</p></blockquote></li></ul><hr><p><strong>投影运算</strong></p><ul><li><p>投影运算是从关系中选取若干属性组成新的关系</p></li><li><p>投影运算是从列的角度进行计算，相当于对关系进行垂直分解</p></li><li><p>投影运算符用π来表示</p><blockquote><p><code>π[(下标)A] (R)</code><br>A用于表示投影属性或属性组，R是关系名</p></blockquote></li><li><p>例子: <code>π[(下标)A], π[(下标)A1](R)</code></p><blockquote><p>在R表中对A与A1两个字段进行投影，形成新的关系，同时去掉结果关系中重复的元组</p></blockquote></li><li><p>关系代数是把表看作元组集合的关系，既然是集合就不包括重复元组</p></li><li><p>也就是说，关系代数的每个运算都是去重复的</p></li></ul><hr><p><strong>并运算</strong></p><ul><li><p>并运算属于集合运算</p><blockquote><p>集合运算的两个关系必须拥有相同的关系模式，即相同的结构<br>两个关系包含属性的个数一致<br>两个关系对应属性的域应该相同或包容</p></blockquote></li><li><p>两个已知关系R和S的并将产生一个包含R，S中所有不同元组的新关系</p><blockquote><p>将其记为: <code>R∪S</code><br>则为R并S，因此并运算可以将其理解为现实中的或者</p></blockquote></li><li><p>两个已知关系R和S的交，是属于R而且也属于S的元组组成的新关系</p><blockquote><p>将其极为: <code>R∩S</code></p></blockquote></li><li><p>实例:</p><blockquote><p>设有两张不同的表<code>tables_A</code>与<code>tables_B</code>，并且设这两个表中分别有字段a，b，c，d，其值分别为拥有4行分别1，2，3，4的矩阵数列<br>首先找表<code>tables_A</code>中的a字段，即为:<br>先在<code>tables_A</code>表中进行选择运算，寻找的条件是a字段等于1，即为找出所有a等于1类型的数据记录，然后再进行投影运算，只取c字段(基于字段/列c来对a=1进行投影计算，也可称之为映射计算)<br>并且再<code>tables_B</code>表中进行选择运算，寻找的条件是b小于3的所有记录，然后进行投影运算<br>再将表<code>tables_A</code>与表<code>tables_B</code>进行差运算<br>此时的输出数据就是<br>将表<code>tables_A</code>中将所有已经排除了表<code>tables_B</code>中b小于三的数值类型的所有数值类型<br>因此得到想要查询的类型</p></blockquote></li><li><p>可将SQL语句具体描述为</p><blockquote><p><code>(π[(下标)c], π[(下标)a=1](tables_A))) - (π[(下标)c], π[(下标)b&gt;3](tables_B)))</code></p></blockquote></li><li><p>此时应输出的查询值即为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>笛卡尔积运算</strong></p><ul><li><p>设A和B是两个关系，如果A是m元关系，有i个元组</p></li><li><p>B是n元关系，有j个元组，则笛卡尔积为<code>A*B</code>是一个<code>m+n</code>元关系，则有<code>i*j</code>个元组</p></li><li><p>实例:</p></li><li><p>数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>此时A关系有三个元组，同时B关系有三个元组</p></li><li><p>此时的笛卡尔积则为<code>3*3</code>，则为9个元组</p><blockquote><p>A关系的第一个元组与B关系的所有元组进行连接<br>A关系的第二个元组与B关系的所有元组进行连接<br>A关系的第三个元组与B关系的所有元组进行连接</p></blockquote></li><li><p>此结果即为此笛卡尔运算的乘积结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a，b，c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积运算可以把两个运算连接到一起，从而形成一个新的关系</p><blockquote><p>由此引出连接运算与笛卡尔积的关系与区别</p></blockquote></li></ul><hr><p><strong>连接运算</strong></p><ul><li><p>连接运算是将两个关系的若干属性值拼接成一个新的关系的操作</p></li><li><p>对应的新关系中，包含满足连接条件的所有元组</p></li><li><p>即可将其记为: <code>R 连接(AθB) S</code> (连接符号于普通文本间无法输入)</p></li><li><p>其中，R与S是关系名</p><blockquote><p>A，B分别是R和S上度相等且可比的属性组<br>θ是比较运算符</p></blockquote></li><li><p>实例:</p></li><li><p>数据结构模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，a2，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，1</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li><li><p>对表<code>tables_A</code>与表<code>tables_B</code>进行以下比较连接</p></li><li><p><code>tables_A 连接(c&lt;E) tables_B</code>，即为<code>tables_A</code>中的c属性小于<code>tables_B</code>中的E属性</p></li><li><p>连接所输出的结果集为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C，E</span><br><span class="line"><span class="number">3</span>，<span class="number">8</span></span><br><span class="line"><span class="number">4</span>，<span class="number">9</span></span><br><span class="line"><span class="literal">null</span>，<span class="number">6</span></span><br></pre></td></tr></table></figure></li><li><p>此例为比较连接</p></li></ul><hr><ul><li>当比较运算符为等号时，可分为等值连接与自然连接</li></ul><p><strong>等值连接:</strong></p><ul><li>当连接条件为”=”时的连接运算 <code>R 连接(R.C=S.E) S</code>，此条件即可描述为R的C属性等于S的E属性</li></ul><p><strong>自然连接</strong></p><ul><li><p>自然连接是一种特殊的等值连接</p><blockquote><p>它要求两个关系中进行变焦的分量是相同的属性组，并且在结果中把重复的属性列去掉，可表示为: <code>R 连接 S</code></p></blockquote></li><li><p>此间的连接符号皆使用文字描述</p></li><li><p>如果将上述数据模型进行自然连接，即为将量表中的B列所拥有且相等的所有分量进行连接</p></li><li><p>连接运算与笛卡尔积运算的区别</p></li><li><p>连接运算是笛卡尔积运算和特定选择运算合并而成的一个运算</p></li><li><p>以此数据模型为例:</p></li></ul><ol><li>等值连接<blockquote><p>当<code>tables_A 连接(tables_A.C=tables_B.E) tables_b</code><br>即为将量表进行等值运算，运算条件与输出的值则为量表中分别<code>C=E</code>的值</p></blockquote></li></ol><ul><li>结果即为:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，tables_B.B，E</span><br><span class="line">a1，b1，<span class="number">3</span>，a2，<span class="number">3</span></span><br><span class="line">a2，b3，<span class="number">6</span>，a1，<span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>自然连接</li></ol><ul><li><p><code>tables_A 连接 tables_B</code></p><blockquote><p>此间无任何条件</p></blockquote></li><li><p>结果即为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，E</span><br><span class="line">a1，b1，<span class="number">8</span>，<span class="number">8</span></span><br><span class="line">a1，b2，<span class="number">3</span>，<span class="number">9</span></span><br><span class="line">a2，b3，<span class="number">6</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，3</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>等值连接</strong></p><ul><li><code>tables_A</code>中的C属性与<code>tables_B</code>中的E属性进行比较，一直比较到有相同的元组相等时，将所在元组进行连接<blockquote><p>比如在此实例中3，6，相等，即连接结果为以上两条元组</p></blockquote></li></ul><p><strong>自然连接</strong></p><ul><li><code>tables_A</code>中的B属性和<code>tables_B</code>中的B属性进行等值比较<blockquote><p>此时b1=b1，b2=b2，b3=b3都互为相等，则互相连接，则输出结果为以上两个元组</p></blockquote></li></ul><hr><ul><li>从运算过程可以总结规律: 自然连接必定是等值连接，自然连接与等值连接的区别则在于自然连接所比较的属性必须为公共属性，或者是属性组<blockquote><p>还有一点就是自然连接所形成的新关系会自动将重复的属性去掉<br>在上例中就把<code>tables_B</code>中的B属性去掉了，因为同样的属性所产生的值也必然是相同的，所以会将重复复的值去掉</p></blockquote></li></ul><hr><p><strong>外连接</strong></p><ul><li><p>有些元组不能跟另外关系的任何一个元组匹配，一些实际应用中希望在结果中保留悬浮元组，因此就产生了外连接机制</p></li><li><p>外连接包括了左外连接，右外连接以及全外连接的概念</p></li><li><p>外连接运算的逻辑</p></li></ul><ol><li>计算内连接(比较连接，等值连接与自然连接)</li><li>然后根据左外连接，右外连接或全外连接再加上左侧关系或者右侧关系或者两侧关系中的没有匹配到的元组及悬浮元组</li><li>最后加上悬浮元组用控制NULL来填充相对与另一侧属性的属性值</li></ol><ul><li><p>实例:</p><blockquote><p>自然连接符号的右上角会标识有连接标识L左外连接，R右外连接，F全外连接</p></blockquote></li><li><p>数据模型结构:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a3，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line">D，E</span><br><span class="line">b1，<span class="number">8</span></span><br><span class="line">b2，<span class="number">9</span></span><br><span class="line">a1，<span class="number">3</span></span><br><span class="line">a2，<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>计算机会先计算出自然连接的结果</li><li>之后再进行认为所指定的连接运算规则</li><li>然后再将所有乘积的属性置为空(NULL)</li><li>最后输出的数据集合变为结果</li></ol><ul><li>其它的运算都可以从这些基本关系的运算合并而成</li></ul><hr><ul><li><p>更多的实例这里不做过多阐述了，因为是Access与MS SQL，因此没有什么对其进行过多抽象描述的必要</p></li><li><p>知识图谱图片:</p></li></ul><img src="images/MS-SQL-2.png" width="30%" height="30%"><ul><li>相关概念图片:</li></ul><img src="images/MS-SQL-1.png" width="30%" height="30%"><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>参考URL</strong></p><ul><li><p>数据抽象级别<a href="https://blog.csdn.net/LetsStudy/article/details/79095315" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/LetsStudy/article/details/79095315</code></p></blockquote></li><li><p>数据科学的核心问题：现实问题的数据抽象与程序表达<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://new.qq.com/omn/20181003/20181003A0XITF00</code></p></blockquote></li><li><p>数据库关系模型范式总结<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36616602/article/details/85345295</code></p></blockquote></li><li><p>数据库之父对实现关系型数据库管理系统的12条建议<a href="https://blog.csdn.net/happmaoo/article/details/83075287" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/happmaoo/article/details/83075287</code></p></blockquote></li><li><p>数据库关系运算<a href="http://baijiahao.baidu.com/s?id=1602887097860809528&wfr=spider&for=pc" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://baijiahao.baidu.com/s?id=1602887097860809528&amp;wfr=spider&amp;for=pc</code></p></blockquote></li></ul><p><strong>参考书籍:</strong></p><ul><li><p>数据库原理及应用 (2017.06-郭春生，方昕)</p></li><li><p>数据库应用技术 (2018.1-栾志军，吕海洋，付海娟主编)</p></li><li><p>数据库技术与应用-2020年春季</p><blockquote><p>第一章-数据库基础知识<br>1.4节-1.6节(数据抽象/关系模型/关系运算)</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;Access/MS SQL基本概念归纳&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="数据库" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="RDBMS" scheme="https://unit-serow.github.io/tags/RDBMS/"/>
    
  </entry>
  
  <entry>
    <title>规则</title>
    <link href="https://unit-serow.github.io/2020/03/07/%E8%A7%84%E5%88%99/"/>
    <id>https://unit-serow.github.io/2020/03/07/%E8%A7%84%E5%88%99/</id>
    <published>2020-03-06T22:14:44.000Z</published>
    <updated>2020-03-06T22:18:47.872Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>规则-主观</strong></center><a id="more"></a><hr><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><p>目的是引人思考，而绝非让人理解，即便能够理解，也必然不够全面</p></li><li><p>论题核心: 规则/规律/逻辑</p></li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>逻辑</li><li>规律</li><li>规则</li><li>秩序</li><li>智慧</li></ul><hr><p><strong>论题及其导论:</strong></p><ul><li>何为规则？</li><li>规则由何而来？</li><li>何为秩序？</li><li>秩序从何而来？</li><li>秩序与规则的关系与本质？</li><li>规则与秩序的对立概念？</li><li>为何要追求规则与秩序？</li><li>追求规则与秩序所带来的必然结果为何种概念？</li></ul><hr><h3 id="人类-2"><a href="#人类-2" class="headerlink" title="人类-2"></a>人类-2</h3><p><strong>规则与秩序</strong></p><ul><li><p>基于规则，实现秩序</p><blockquote><p>智慧于逻辑铸就规则<br>且相对于秩序<br>规则于现实铸就秩序<br>本能与自由相对秩序<br>本质与现实相对规则</p></blockquote></li><li><p>存在即现实</p><blockquote><p>人类的社会性的前提<br>无智规则<br>无智逻辑</p></blockquote></li><li><p>规则于现实中实现的方式可分为两类</p><blockquote><p>前者为完全/绝对且纯粹的基于智慧<br>其次为基于无智逻辑，即自然规则(自然法则)，此间的规则被称为规律<br>基于智慧的规则产生了可将其称之为法则的规则与规律，法律的概念这里不做阐述<br>自然规则来源于世界与现实，是一切存在于现实的物质与概念的基础<br>自然规则定义了生命，铸就了无智逻辑<br>规则/规律铸就逻辑<br>规则与逻辑皆来源于现实/世界与空</p></blockquote></li><li><p>纯粹性规则/纯粹性秩序的实现</p><blockquote><p>即为拥有纯粹智慧的社会性形态<br>并非纯粹的共产主义<br>而是绝对的纯粹意识形态<br>无即为一切，一切终究归于无，而又源于无<br>即为规则与秩序的根源<br>无规则即为纯粹规则，无逻辑即为纯粹逻辑<br>且<br>无意识即为纯粹意识<br>但智慧是存在于现实的<br>将一切归根结底的答案，都将归于无<br>在此所讨论的一切，都将不产生任何意义<br>理智与智慧是不应存于现实的，理智与智慧是最为荒谬的概念且为最不接近(或称其为抛离/脱离)于现实/世界的概念<br>人类/智慧生物在理智状态下做做出的一切行动都是最为荒谬的…</p></blockquote></li><li><p>顺天应人，随心而行，终究是最终且最合理的结果</p><blockquote><p>纯粹的纯粹唯物主义也莫过于如此<br>但大多或称所有，所谓的存在于现实中的顺天应人的智慧<br>都为主观结果，而非空或无所产生/带来的结果<br>纯粹且绝对性的概率如果存在，顺天应人则绝对不存在<br>光凭人类的智慧恐怕是完全无法做到所谓的顺天应人<br>追求规则与秩序所带来的必然结果即为无结果(绝对追求/追求绝对的规则与秩序)</p></blockquote></li><li><p>平衡</p><blockquote><p>针对平衡的概念与深层理解与思考<br>一切概念的最优解结尾平衡，平衡即为存于现实间最美好且最完全的概念<br>为何要去追求规则与秩序<br>一切都是为了将世界/现实达到或保持所谓的平衡，无论客观与主观<br>弱者与强者间的平衡，本能与理智间的平衡，本质与智慧之间的平衡，有与无(空)之间的平衡…</p></blockquote></li></ul><hr><h3 id="相关主观概念"><a href="#相关主观概念" class="headerlink" title="相关主观概念"></a>相关主观概念</h3><ul><li>现实/世界中所存在的一切皆可对立且皆成逻辑与规则</li><li>现实层面概念所产生与存在的现实概念:</li><li>现实/世界/自然因智慧/理智的存在而产生了最荒谬的结果</li><li>因此自然/世界将永远无法达到平衡(现实/世界存在智慧)</li></ul><p><strong>而人类社会更是与其相同</strong></p><ul><li><p>人与人之间于智慧层面的差距是人类永远也无法去主观进行理解的概念</p></li><li><p>而人与人之间所产生的智慧的差距皆来源于世界</p><blockquote><p>这里也可以将世界的概念称之为自然环境与绝对性概率所产生的环境差异</p></blockquote></li><li><p>正常状态下的人类皆拥有智慧？</p><blockquote><p>不<br>所谓的智慧，并非是所有人都在乞求得到的事物<br>沉迷于精神世界或沉迷于现实世界间的智慧将永远都不配将其称之为智慧(对于无限接近于纯粹的智慧而言)<br>有的人拥有的智慧接近于纯粹，而有的人则接近于无(此类人与无智慧生物相近，也就是猿猴)<br>但无论是任何形式的智慧，无论是拥有这两种绝对的概念其中的哪一个<br>所带来的结果都是绝对荒谬的<br>而接近于纯粹智慧的智慧永远都达不到且无法拥有纯粹的智慧，因为他们存在于现实间<br>而平衡，往往是于现实间所存在的最完美智慧<br>接近于纯粹智慧的智慧(按理/此处为主观愚解)应当理解这些基本的概念<br>接近于纯粹智慧的智慧会去无限的接近于平衡的智慧，而并非一味的去追求纯粹<br>一味的去追求纯粹的智慧并非为接近纯粹智慧的智慧<br>疯子与精神病患者可能会聪明绝顶，但其拥有的绝对不是接近于绝对纯粹的智慧<br>接近于绝对纯粹的智慧会尽力的去保持应有且为原有应当的平衡<br>即为将同时存在于现实与精神世界的人体意识时刻保持平衡<br>现实/世界间应只存在”最”的概念，而不应存在”绝对”的概念<br>无<br>纯粹</p></blockquote></li><li><p>此间只可意会，无法以言语相传</p></li><li><p>此间概念应有丢失，待今后进行相应补充</p></li></ul><p><strong>死循环<del>(嵌套循环)</del></strong></p><p><strong>即永远无法到达的平衡与纯粹</strong></p><p><strong>至此</strong></p><hr><h3 id="不精之精，而至纯粹"><a href="#不精之精，而至纯粹" class="headerlink" title="不精之精，而至纯粹"></a>不精之精，而至纯粹</h3><ul><li><p>改意之于-元精者，不精之精，其体纯粹，发而为智</p></li><li><p>此句来源于易经-周易阐真-序-先天五元，发为五得</p><blockquote><p>元性者（甲），无性之性，其体柔慈，发而为仁。<br>元神者（丙），不神之神，其体圆通，发而为礼。<br>元气者（戊），无气之气，其体纯一，发而为信。<br>元情者（庚），无情之情，其体刚烈，发而为义。<br>元精者（壬），不精之精，其体纯粹，发而为智。</p></blockquote></li></ul><hr><ul><li>而之即有其词-后天五浊，感生五贼<blockquote><p>游魂（乙）主生，其性善，感则生喜。<br>识神（丁）至灵，其性贪，感则生乐。<br>妄意（己）至动，其性乱，感则生欲。<br>鬼魂（辛）主死，其性恶，感则生怒。<br>浊精（癸）至浮，其性痴，感则生哀。</p></blockquote></li></ul><hr><p><strong>其它:</strong></p><ul><li>万物皆为相生相克，此存在于现实的概念恐怕8000年前的古中国就早已经有智慧提出了</li><li>而由进现代的相对论(狭义/广义)/质能守恒定律所产生的质能方程E=mc^2则完全且绝对的证明了此存在于现实的逻辑与观点</li><li>存在于现实的纯粹唯物主义的一切/绝对基本条件即为纯粹性概率/完全性概率，此概念将对应于现代所产生的量子理论</li><li>我虽自称沉醉于纯粹的纯粹唯物主义，但我对本质即为存在于现实世界的物理学一无所知</li><li>即便是纯粹的理论物理，而能令我沉迷的只有比其更接近于纯粹的纯粹数学</li></ul><hr><p><strong>下一论题:</strong></p><ul><li>智慧的起源/根源及其本质<blockquote><p>即为一切论题的基础，一切存在(唯心主义)于现实间的根源与基础<br>智慧绝非凭空产生或来于它类，进化论于唯物主义理论中是完全存在的<br>存在于现实的一切概念与生命都不可能拥有纯粹的智慧，因为纯粹的自由完全不属于现实(精神或意识形态)</p></blockquote></li></ul><hr><ul><li>文章内所涉及的一切现实与精神概念的相关内容皆基于主观理解与描述</li><li>相对于自身有限的智慧层次而对其客观进行的理解与描述</li><li>并且我将会尽量的做到绝对存在于现实的客观，但终究有限</li></ul><hr><ul><li>Because it is there-(因为山在那里)</li><li>我所拥有的一切皆来源于现实与世界，因此我终将一无所有</li></ul><hr><ul><li>补充一点: 0与1即为无与有，此时应当联想到何物？<blockquote><p>二进制……与机械智能……</p></blockquote></li></ul><hr><p><strong>相关资料:</strong></p><ul><li>中国哲学书电子化计划 -《周易阐真》<a href="https://ctext.org/wiki.pl?if=gb&res=904129&remap=gb" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://ctext.org/wiki.pl?if=gb&amp;res=904129&amp;remap=gb</code></p></blockquote></li></ul><blockquote><p>周易闡真（易道心法真傳）- 卷首-河圖<a href="https://www.eee-learning.com/book/eee-shinfa-ch3" target="_blank" rel="noopener">跳转</a><br><code>https://www.eee-learning.com/book/eee-shinfa-ch3</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;规则-主观&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LSP-2.2</title>
    <link href="https://unit-serow.github.io/2020/03/07/LSP-2-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/LSP-2-1/</id>
    <published>2020-03-06T17:59:36.000Z</published>
    <updated>2020-03-06T18:01:30.453Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用与库函数调用的执行检查与错误处理</strong></center><center><strong>UNIX/Linux-2.2</strong></center><a id="more"></a><h2 id="LSP-2-2"><a href="#LSP-2-2" class="headerlink" title="LSP-2.2"></a>LSP-2.2</h2><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-2</li></ul><hr><p><strong>涉及概念一览:</strong></p><ul><li>库函数基本检查</li><li>系统调用检查与错误处理</li><li>库函数调用检查与错误处理</li></ul><hr><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><ul><li><p>库函数即为存在于C 标准库内的任何函数，也可以称其为函数</p><blockquote><p>设计库函数的目的是为了提供比底层系统调用更方便的调用接口</p></blockquote></li><li><p>标准C语言函数库: GNU C 语言函数库(Glibc)</p><blockquote><p>标准C语言函数库的实现跟随UNIX的实现而异<br>GNU C语言函数库即为Linux上最常用的实现</p></blockquote></li><li><p>除了标准的函数之外通常还有其它的拓展函数uClibc与dietlibc</p><blockquote><p>uClibc: htttp://<a href="http://www.ulibc.org" target="_blank" rel="noopener">www.ulibc.org</a><br>dietlibc: <a href="http://www.fefe.de/detlibc" target="_blank" rel="noopener">http://www.fefe.de/detlibc</a></p></blockquote></li><li><p>因为Linux开发的大多数开发都只能用到Glibc，所以这里将不会对其它的拓展函数库进行过多讨论</p></li><li><p>查看当前系统的Glibc版本</p><blockquote><p>直接运行其glibc的共享库文件(可执行文件)，以获取版本<br><code>$ /lib/libc.so.6</code></p></blockquote></li><li><p>确定改库存放位置的方法之一:</p><blockquote><p>针对某个与glibc动态链接的可执行文件，运行ldd程序<br>然后再检查已输出的库依赖列表，便能发现glibc共享库所处于的位置<br><code>$ ldd myprog | grep libc</code></p></blockquote></li></ul><hr><ul><li>应用程序可以通过测试常量和调用函数库这两种方法来确定系统所安装的glibc版本及其详细信息<blockquote><p>从版本2.0开始，glibc定义了两个常量<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>，以供程序再编译时(在<code>#ifdef</code>语句中)测试使用<br>为了避免在同步机器上造成的版本不同而产生的参数差异所带来的种种问题，可以在程序内调用<code>gnu_get_libc_version()</code>来确定运行时的glibc版本</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/libc-version&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gnu_get_libc_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>而对于获取glibc版本信息，还有一种方法，即为使用<code>confstr()</code>函数来获取(glibc特有的)<code>_CS_GNU_LIBC_VERSION</code>配置变量的值<blockquote><p>其返回的字符串与上述实例相同</p></blockquote></li></ul><hr><h3 id="如何处理来自系统调用的错误与如何处理来自库函数的错误"><a href="#如何处理来自系统调用的错误与如何处理来自库函数的错误" class="headerlink" title="如何处理来自系统调用的错误与如何处理来自库函数的错误"></a>如何处理来自系统调用的错误与如何处理来自库函数的错误</h3><ul><li>几乎每个系统调用和库函数都会返回某类状态值，用以表明调用成功与否<blockquote><p>如果想要深入的了解调用是否成功，必须检查对状态值进行检查<br>若调用失败，则采取相应行动<br>所以让程序显示错误消息，以防止有意想不到的时间发生，是非常有必要的<br>但是还有少数几个系统调用函数在调用时从不会失败(例如<code>getppid()</code>总是能成功返回<code>进程的ID</code>，而<code>_exit()</code>总能终止进程，则无需对此类系统调用的返回值进行检查)</p></blockquote></li></ul><hr><p><strong>如何处理来自系统调用的错误:</strong></p><ul><li>每个系统调用的手册页记录有调用可能的返回值，并指出了哪些值表示错误<blockquote><p>通常，返回值为-1则表示出错，当处于此种情况下，可以使用下列代码对系统调用进行检查</p></blockquote></li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="keyword">open</span>(pathname, flags, mode); <span class="comment">/* system call to open a file */</span></span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to handle the error */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">close</span>(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to heandle the error */</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>当系统调用失败时，会将全局整形变量<code>errno</code>设为一个正值，以标识具体的错误</p><blockquote><p>程序(<code>#include</code>)包含<code>&lt;errno.h&gt;</code>头文件，该文件提供了对<code>errno</code>的声明，以及一组针对各种错误编号而定义的常量<br>所有这些符号名都以子字母E打头，在每个手册页内标题为<code>ERRORS</code>的章节内，都刊载有一份相应系统调用可能返回的<code>errno值</code>列表</p></blockquote></li><li><p>这里是利用<code>errno</code>来诊断系统调用错误的一个简单实例:</p></li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cnt</span> = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">cnt</span> == -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">errno</span> == EINTR)</span><br><span class="line">fpintf(stderr, <span class="string">"read was interrupted by a signal\n"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Some other error occurred */</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>如果调用系统函数和函数库成功，<code>errno</code>绝不会被重置为0，故此改变了值不为0，还有可能是因为之前的调用失败造成的</p><blockquote><p>此外，<code>SUSv3</code>允许在函数调用成功时，将<code>errno</code>设置为非零值(但是基于没有函数会这么做)<br>因此，在进行错误检查时，必须检查首先检查函数的返回值是否表明调用出错，然后再检查<code>errno</code>确定错误原因<br>少数系统调用(比如<code>getpriority()</code>)在调用成功后，也会<code>返回-1</code><br>所以在要判断此类系统调用是否发生错误，应在调用前将<code>errno</code>设置为0，并在调用后进行检查(以上所描述的手法同样适用于某些库函数)</p></blockquote></li><li><p>系统调用失败后，常见的做法之一就是根据<code>errno</code>值来打印错误消息，提供的库函数<code>perror()</code>和<code>strerror()</code>，就是处于此目的</p><blockquote><p>此实例中函数<code>perror()</code>会打印出其<code>msg参数</code>所指向的字符串，紧跟一条与当前<code>errno值</code>相对应的消息</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>以下是对系统调用错误进行错误的一种简单方式:</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(pathname, flags, mode);</span><br><span class="line"><span class="keyword">if</span> (fd == -<span class="number">1</span>) &#123;</span><br><span class="line">perror(<span class="string">"open"</span>)</span><br><span class="line"><span class="keyword">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>strerror()</code>会针对其<code>errnum</code>参数中所给定的错误号，返回相应的错误字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>由<code>strerror()</code>所返回的字符串可以是静态分配的，这意味着后续对<code>sterror()</code>的调用可能会覆盖该字符串</p><blockquote><p>若无法识别<code>errnum</code>所含的错误编号，则<code>strerror()</code>会返回<code>&quot;Unknown error nnn&quot;</code>形式的字符串<br>在某些其它的视线中，在这种情况下，<code>strerror()</code>会返回<code>NULL</code></p></blockquote></li><li><p>由于<code>perror()</code>和<code>sterror()</code>都属于对语言环境敏感(locale-sensitive)的函数，故而错误描述中使用的都是本地语言</p></li></ul><hr><p><strong>处理来自库函数的错误</strong></p><ul><li>不同的库函数在调用发生错误时，所返回的数据类型和值也各不相同(可以参见每个函数的手册页)</li><li>从错误的角度来讲，可以分为以下几类:</li></ul><ol><li>某些库函数返回错误信息的方式与系统调用完全相同，则<code>返回值为-1</code>，伴之以<code>errno号</code>来标识具体错误<blockquote><p><code>remove()</code>便是其中一例，可使用该库函数来删除文件(调用<code>unlink()</code>相同调用)或目录(调用<code>rmdir()</code>相同调用)<br>对此类函数所发生的错误进行诊断，其方式与系统调用完全相同</p></blockquote></li><li>某些库函数在出错时会<code>返回-1</code>之外的其他值，但仍会设置<code>errno</code>来表明具体的出错情况<blockquote><p>例如，<code>fopen()</code>在出错时会返回一个<code>NULL指针</code>，还会根据出错的具体底层相同调用来设置<code>errno</code><br>函数<code>perror()</code>和<code>sterror()</code>都可用来诊断此类错误</p></blockquote></li><li>还有一些函数根本不使用<code>errno</code>，对此类函数来说，确定错误存在与否及其起因的方法各不相同<blockquote><p>同样可见诸于相应函数的手册页中，不应使用<code>errno</code>，<code>perror()</code>或<code>strerror()</code>来诊断错误</p></blockquote></li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li>Linux/UNIX系统编程(上册)</li><li>参考自原书3.3-3.4章节</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用与库函数调用的执行检查与错误处理&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.2&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="软件" scheme="https://unit-serow.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LSP-2-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-2/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-2/</id>
    <published>2020-03-06T10:39:20.000Z</published>
    <updated>2020-03-06T10:48:01.174Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用概念及其执行逻辑叙述</strong></center><center><strong>UNIX/Linux-2.1</strong></center><a id="more"></a><h2 id="LSP-2-1"><a href="#LSP-2-1" class="headerlink" title="LSP-2.1"></a>LSP-2.1</h2><ul><li>LSP/Linux System Prorgramming-2</li></ul><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-1</li><li>系统编程先决条件及其执行逻辑整合文案-1</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>系统调用及其执行逻辑刨析</li><li>对已执行的调用进行检查</li><li>逻辑简述</li></ul><hr><ul><li>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律</li></ul><hr><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li><p>系统调用是受控的内核入口，因此机制，进程可以请求内核以自己的名义去执行某些动作</p></li><li><p>以应用程序编程接口(API)的形式，内核提供有一系列服务提供程序访问(包括创建新进程，执行I/O，以及为进程间通信创建管道等)</p></li><li><p>在深入系统调用的运作方式之前，需要对其进行关注的几个问题点</p></li></ul><ol><li>系统调用是将处理器从用户态切换到和心态，以便CPU访问受到保护的内核内存</li><li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识(程序通过名称来标识系统调用，此编号机制通常与其无关)</li><li>每个系统调用可辅之以一套参数，对用户空间(亦即进程的虚拟地址空间)与内核空间之间(相互)传递的信息加以规范</li></ol><ul><li><p>从编程的角度去理解，系统调用与C语言函数的调用很相似</p><blockquote><p>然而在系统调用时，其幕后会经理诸多步骤，接下来将会对该步骤的具体逻辑进行叙述:</p></blockquote></li><li><p>这里将硬件平台-<code>x86-32</code>为例，按事件发生的顺序对这些步骤加以分析</p></li></ul><ol><li>应用程序通过调用C语言函数库中的外壳(wrapper)函数，以发起系统调用</li><li>对系统调用中断处理的例程来说，外壳函数必须保证所有的系统调用参数可用<blockquote><p>通过堆栈，这些参数传入外壳函数，但内核却希望这些参数置于特定的寄存器<br>因此，外壳函数会将上述参数复制到寄存器</p></blockquote></li><li>由于所有系统调用进入内核的方式相同，内核需要设法区分每个相同调用<blockquote><p>为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器(%eax)中</p></blockquote></li><li>外壳函数执行一条中断机器指令(<code>int 0x80</code>)，引发处理器从用户态切换到和心态，并执行系统终端<code>0x80</code>(十进制数为128)的终端矢量所指向的代码<blockquote><p>在较新的<code>x86-32</code>硬件平台实现了<code>sysenter指令</code>，较之传统的<code>int 0x80</code>中断指令，sysenter指令进入内核的速度更快，2.6内核与glibc2.3.2以后的版本都支持<code>sysenter指令</code></p></blockquote></li><li>为相应中断<code>0x80</code>，内核会调用<code>system_all()</code>例程(位于汇编文件<code>arch/i386/entry.S</code>中)来处理这次中断，具体的处理逻辑与步骤如下:<blockquote><p>1-在内核栈中保存寄存器值(这里先不做阐述)<br>2-审核系统调用编号的有效性<br>3-以系统调用编号对存放所有调用服务例程的列表(内核变量<code>sys_call_table</code>)并进行索引，发现并调用相应的系统系统调用服务例程<br>3.1-若系统调用服务例程带有参数，那么将会首先检查参数的有效性<br>3.2-例如，会检查地址指向用户空间的内存位置是否有效<br>3.3-随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改<br>3.4-以及在用户内存和内核内存间传递数据(比如在I/O操作中)<br>3.5-最后，该服务例程会将结果状态返回给<code>system_call()</code>例程<br>4.-从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中<br>5.-返回值外壳函数，同时将处理器切换回用户态</p></blockquote></li><li>若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno<blockquote><p>然后，外壳函数返回一个整型值，以表明系统调用是否成功<br>在Linux上，系统调用服务例程所遵循的惯例是调用成功则返回负值<br>发生错误时，例程会对相应erron常量取反，则返回一个负值<br>C语言函数库的外壳函数即对其再次取反(此时负负得正)，将此结果拷贝至 errno<br>同时以-1作为外壳函数的返回值返回，以此向调用程序表明有错误发生<br>上述惯例所依赖的先决条件是系统调用服务例程，若调用成功则不会返回负值<br>可是对于少数例程来说，这一前提并不成立<br>一般情况下，这也不会有问题，因为取反的errno值范围不会与调用成功返回负值的范围有交集<br>不过还有一种情况沿用这个惯例确实会出问题: 系统调用<code>fcntl()</code>的<code>F_GETOWN</code>操作，这里先不做阐述</p></blockquote></li></ol><hr><ul><li>以相同调用<code>execve()</code>为例，此图片展示了上文叙述及事件的发生序列</li><li>在<code>Linux/x86-32</code>上，<code>execve()</code>的系统调用号为<code>11(__NR_execve)</code><blockquote><p>因此，在<code>sys_call_table</code>向量中，<code>条目11</code>包含了该系统调用的服务例程<code>sys_execve()</code>的地址</p></blockquote></li><li>在Linux中，系统调用服务例程的命名通常会采取<code>sys_xyz()</code>的形式，其中<code>xyz()</code>则是所论及的系统调用</li></ul><p><strong>系统调用的执行步骤图例</strong></p><img src="/images/系统调用-1.png" width="40%" height="40%"><hr><ul><li><p>在系统调用的实际情况中，通常不需要将概念掌握并理解的如此深刻</p><blockquote><p>但即便对于一个简单的系统调用，仍要完成相当多的工作<br>因此系统调用的开销虽然很小，却也不容忽视</p></blockquote></li><li><p>这里可以将getppid()系统调用为例，研判一下发起系统调用的开销:</p><blockquote><p>该系统调用只是简单地返回调用进程的父进程ID<br>此时在一台运行着<code>Linux 2.6.25</code>的<code>x86-32</code>系统上，调用<code>getppid()</code>一千万次大约需要<code>2.2秒</code>钟，每次调用大致需要<code>0.3微秒</code><br>相形之下，在同一系统上，调用某个只返回整数的C语言函数一千万次，仅需0.11秒，约为<code>getppid()</code>耗费时间的<code>1/20</code><br>当然，大多数系统调用的开销都明显高于<code>getppid()</code></p></blockquote></li></ul><hr><ul><li>因此，从C 语言编程的角度去看，调用C语言函数库的外壳函数等同于调用相应的系统调用服务例程<blockquote><p>在今后的章节里，调用系统调用<code>xyz()</code>这类说法即意味着: 调用外壳函数，然后再由外壳函数去调用系统调用<code>xyz()</code></p></blockquote></li><li>为调试程序，或是研究程序的运作机制，可以使用<code>stace命令</code>，以便对程序发起的系统调用进行跟踪</li><li>有关与Linux系统调用机制有关的信息可参见其它书籍: [Love，2010]，[Bovet &amp; Cesati，2005]以及[Maxwell，1999]</li></ul><hr><p><strong>相关概念整合:</strong></p><ul><li><p>系统编程概念</p></li><li><p>系统编程先决条件及其执行逻辑整合文案</p></li><li><p>系统编程概念</p><blockquote><p>系统编程先决条件整合文案<br>系统调用<br>执行逻辑<br>库函数<br>GNU Libc (Glibc-GNU C 标准库)<br>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律<br>已执行调用检查<br>库函数错误<br>系统条用错误<br>可移植性<br>特性测试宏<br>SUSv3中定义的标准系统数据类型</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>可参考URL目录</p></li><li><p>CN-CSDN-Linux系统调用手册<a href="https://blog.csdn.net/xtx1990/article/details/8173950" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/xtx1990/article/details/8173950</code></p></blockquote></li><li><p>CN-CSDN-linux常用系统调用简介<a href="https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>CN-个人博客-[译] Linux 系统调用权威指南（2016）<a href="https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/</code></p></blockquote></li><li><p>CN-百度文库-系统调用手册<a href="https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html</code></p></blockquote></li><li><p>CN-IBM-Linux系统调用列表<a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</code></p></blockquote></li></ul><p>CN-个人博客-Linux系统调用(syscall)原理<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://gityuan.com/2016/05/21/syscall/</code></p></blockquote><hr><ul><li><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a><blockquote><p>第三章节内容<br>PDF资源可参考文章OS-1<br>手册页-Linux系统调用<br>书籍-附录A</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用概念及其执行逻辑叙述&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LSP-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-1/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-1/</id>
    <published>2020-03-06T07:41:05.000Z</published>
    <updated>2020-03-06T07:56:52.591Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux内核与操作系统基本概念归纳</strong></center><center><strong>UNIX/Linux-1</strong></center><a id="more"></a><h2 id="LSP-1"><a href="#LSP-1" class="headerlink" title="LSP-1"></a>LSP-1</h2><ul><li>LSP/Linux System Prorgramming</li></ul><hr><h3 id="UNIX-Linux-1"><a href="#UNIX-Linux-1" class="headerlink" title="UNIX/Linux-1"></a>UNIX/Linux-1</h3><ul><li>内核与操作系统的相关基本概念归纳</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><p><strong>内核</strong></p><ul><li><p>内核概念</p><blockquote><p>操作系统的核心<br>内核在狭义范围内被理解为用于管理与分配计算机硬件资源(即CPU，RAM，设备等)的核心层软件<br>在没有内核的情况下，计算机也能运行程序<br>内核的作用是对其它程序的编写和使用进行简化(通常会产生极大的简化效果)<br>者一切都要归功于内核为管理计算机的有限资源所提供的软件层</p></blockquote></li><li><p>内核文件命名机制</p><blockquote><p><code>vmunix/</code><br><code>boot/vmlinuz</code><br>内核为经由压缩的可执行文件</p></blockquote></li></ul><p><strong>内核的存在意义与职责</strong></p><ul><li><p>进程调度</p><blockquote><p>通常计算机内存在着若干个CPU(中央处理单元)以执行程序命令<br>UNIX kernel system与UNIX-like(Linux) kernel system属于抢占式多任务系统<br>多任务意指多个进程(即运行中的程序)可同时驻留于内存，且每个进程都能够获得对CPU的使用权<br>抢占用于泛指一组规则，这组规则控制着指定进程对CPU的使用权与使用时间<br>以上两者均有内核进程调度程序(而非程序本身)决定</p></blockquote></li><li><p>内存管理</p><blockquote><p>由于硬件资源的有限且软件对其硬件资源的占用，使得物理内存(RAM)被定义为有限资源<br>内核的作用就是以公平且高效的方式在进程间共享这一资源<br>多数的现代操作系统(包括Linux)采用了虚拟内存管理机制<br>使得进程与进程之间，进程与内核之间彼此隔离，以防止进程读取或修改内核或其它进程中的内存内容<br>只需将进程的一部分保存在内存中，以降低每个进程对内存的需求量与实现在RAM中同时加载更多的进程<br>此方法大幅提升了在任意时刻的CPU都有至少一个进程可以执行，以使得对CPU资源的利用更加充分的情况</p></blockquote></li><li><p>文件系统提供</p><blockquote><p>内核在磁盘之上有提供文件系统，并且允许对文件系统执行创建，获取，更新以及删除等管理操作</p></blockquote></li><li><p>创建和终止进程</p><blockquote><p>内核可以将新程序载入内存，以为其提供运行所需的资源(比如CPU，内存以及对文件的访问等)<br>这样一个处于运行状态下的程序被称之为进程<br>一旦进程执行完毕，内核还要确保释放其占用的资源，以备后续程序重新使用</p></blockquote></li><li><p>对设备与其硬件的访问</p><blockquote><p>计算机的外界设备(人体学输入设备，磁盘或磁带驱动器等)可实现计算机与外部世界的通信<br>此通信机制包括输入，输出或两者兼而有之<br>内核即为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问</p></blockquote></li><li><p>联网的机制与其实现</p><blockquote><p>内核以用户进程的名义收发网络消息(数据包)<br>该任务包括将网络数据表路由至目标系统</p></blockquote></li><li><p>提供系统调用应用编程接口(API)</p><blockquote><p>进程可利用内核入口点(也可称其为系统调用)请求内核去执行各种任务<br>衍生概念: Linux系统内核调用API的方法与步骤，此概念将会在以后章节内进行详细刨析与实践</p></blockquote></li><li><p>通常情况下，多用户操作系统(例如Linux等)会为用户提供一种名为: 虚拟私有计算机(virtual private computer)的抽象概念</p></li><li><p>即为每个用户都可以登陆操作系统，并且其独立的操作与其它的用户大致无干(包括独立访问设备，独立运行程序，CPU，磁盘及其硬件资源独立分配等等)</p></li><li><p>此时的内核用于负责解决(多进程)访问硬件资源时可能引发的冲突，并且不对用户和进程产生任何层面的影响</p></li></ul><hr><p><strong>内核态与用户态</strong></p><blockquote><p>现代处理器架构一般允许CPI至少在两者不同的状态下允许<br>即为用户态与核心态(有时也可称之为监管态supervisor mode)<br>执行硬件执行可使得CPU在两者状态间来回切换<br>与之相对应的虚拟内存区域也可划分(标记)为用户空间部分与内核空间部分<br>在用户状态下运行时: CPU只能访问被标记为用户空间的内存，视图访问属于内核空间的内存会引发硬件异常<br>在内核状态下运行时: CPU既能访问用户空间内存，也能访问内核空间内存<br>内核状态下运行的处理器通常可以完成某些特定操作: 此特定操作包括了执行宕机(halt)，访问内存管理硬件，以及设备I/O操作的初始化等等<br>实现者们通常会利用这一硬件设计将操作系统置于内核空间以确保用户进程不能访问内核指令和数据结构，保证了其无法对操作系统执行不利于操作系统运行的操作<br>而程序员在进行日常的编程任务时有必要去习惯于利用面向进程(process-oriented)的思维方式来考虑编程问题<br>即以进程及内核的视角来检视系统</p></blockquote><hr><h3 id="Shell相关"><a href="#Shell相关" class="headerlink" title="Shell相关"></a>Shell相关</h3><ul><li>shell是用于读取用户输入指令并将其相对应的程序进行执行并相应的软件程序<blockquote><p>也可将其称之为命令解释器<br>术语: 登陆shell(login shell)用于特质用户刚登陆系统时，由系统创建，用以运行shell的进程<br>在某些操作系统内会将命令解释器集成于内核中，对于UNIX系统而言，shell只是一个用户进程<br>在UNIX系统的历史中出现过的重要shell: Bourne shell (sh)，C shell (csh)，Korn shell (ksh，bash)等等<br>分别对应了UNIX，BSD，Linux等等</p></blockquote></li></ul><hr><h3 id="操作系统层面相关概念列表"><a href="#操作系统层面相关概念列表" class="headerlink" title="操作系统层面相关概念列表"></a>操作系统层面相关概念列表</h3><ul><li>用户和组-操作系统层面概念</li><li>单根目录层级-操作系统层面概念</li><li>目录-操作系统层面概念</li><li>链接/路径和链接/符号链接-操作系统层面概念</li><li>文件/链接文件/文件类型/文件命名/文件的所有权与权限(相对于用户与操作系统)-操作系统层面概念</li><li>路径/路径命名-操作系统层面概念</li><li>当前工作目录-操作系统层面概念</li><li>文件[I/O模型]/文件描述符-操作系统层面概念</li><li>stdio函数库(C语言在执行文件I/O操作时，通常会调用C标准库内的I/O函数，也可将I/O函数称为stdio函数库)，stdio函数位于I/O系统调用层之上-操作系统层面概念</li></ul><hr><p><strong>程序-操作系统层面概念</strong></p><ul><li><p>程序的存在形式与概念:</p><blockquote><p>程序在现实中的实现可分为两种形式: 源码文件与二进制文件<br>源码文件在执行程序时需要先将其转换(编译和链接处理)为二进制文件，即机器可以理解的二进制机器语言指令</p></blockquote></li><li><p>脚本</p><blockquote><p>脚本是包含命令的文本文件，它可以由shell或其它命令解释器之类的程序直接处理</p></blockquote></li><li><p>有关程序的相关概念列表:</p><blockquote><p>过滤器<br>命令行参数</p></blockquote></li></ul><hr><p><strong>进程</strong></p><ul><li><p>进程的概念与存在意义:</p><blockquote><p>进程即为正在执行的程序实例<br>在程序执行时，内核会将程序的源码载入虚拟内存，以为程序变量分配空间，建立内核记账(bookkeeping)数据结构<br>由此记录进程有关的各种信息(如: 进程ID，用户ID，组ID及其终止状态等)</p></blockquote></li><li><p>在内核的角度去观察进程</p><blockquote><p>进程是一个个实体，内核必须在它们之间共享各种计算机资源<br>以实现让所有的可再生资源在进程间进行平等的资源共享</p></blockquote></li><li><p>进程相关概念列表</p><blockquote><p>进程的内存布局</p></blockquote></li><li><p>逻辑上可以将某一个内存划分为这几部分(也可称为几段):</p><blockquote><p>文本: 程序的指令<br>数据: 程序使用的静态变量<br>堆: 程序可以从该区域动态分配额外内存<br>栈: 随机函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间</p></blockquote></li><li><p>进程相关的基础概念列表:</p></li><li><p>创建进程</p></li><li><p>创建可执行程序</p></li><li><p>进程ID</p></li><li><p>父进程ID</p></li><li><p>进程终止与终止状态</p></li><li><p>进程的用户和组标识符</p></li><li><p>特权进程</p></li><li><p>能力(概念-Capabilities/始于Linux kernel-v2.2)</p></li><li><p>init进程</p></li><li><p>守护进程</p></li><li><p>环境列表</p></li><li><p>资源限制</p></li></ul><hr><p><strong>内存映射</strong></p><ul><li>内存映射基本概念及其实现方法:<blockquote><p>调用系统函数<code>mmap()</code>的进程，会在其虚拟地址空间中创建一个新的内存映射</p></blockquote></li><li>内存映射可分为以下两类:</li></ul><ol><li>文件映射: 将文件的部分区域映射入调用进程的虚拟内存<blockquote><p>调用一旦完成，对文件映射内容的访问则转化为对应相应内存区域的字节操作，映射页面对按需自动从文件中加载</p></blockquote></li><li>相映成趣的是并无文件与之相应的匿名映射，其映射页面的内容会被初始化为0</li></ol><ul><li>由某一进程所映射的内存可以与其它进程的映射共享，而共享的方式通常有两个:</li></ul><ol><li>两个进程都针对某一文件的相同部分加以映射</li><li>由<code>fork()</code>创建的子进程自父进程处继承映射</li></ol><ul><li>内存映射有关概念:<blockquote><p>内存内容填充量分配<br>文件(I/O)，即映射内存I/O<br>进程间通信(通过内存共享映射)</p></blockquote></li></ul><hr><p><strong>静态库和共享库</strong></p><ul><li><p>所特指目标库的概念:</p><blockquote><p>所谓的目标库文件就是: 将(通常是逻辑相关的)一组函数代码加以编译，并置于一个文件中，以供其它程序调用的文件<br>此方法通常有利于程序的开发与维护</p></blockquote></li><li><p>现代UNIX系统提供两种类型的对象库: 静态库和共享库</p></li><li><p>静态库</p><blockquote><p>有时也可称之为档案文件[archives]，是早期UNIX系统中唯一的一种目标库<br>从本质上来讲，可以将静态库描述为: 是对已编译目标模块的一种结构化整合<br>使用静态库时需要在创建程序的链接命令中指定相应的库<br>主程序会在之后对静态库中隶属于各目标模块的不同函数加以引用<br>对于细节这里先不做过多描述，此后的章节内会对其进行具体且完整的刨析与使用和实践</p></blockquote></li><li><p>共享库</p><blockquote><p>共享库存在的意义亦在解决静态库所存在的问题<br>如果将程序链接到共享库，那么此时的链接器就不会把库中的目标模块复制到执行行文件中，而是在可执行文件中写入一条记录，用以表名可执行文件在运行时需要使用该共享库<br>在运行时将可执行文件载入内存的同时会由一个名为动态链接器的程序进行同步执行，以确保将可执行文件所需的动态库找到，并载入内存<br>随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中的函数定义相关联起来<br>在运行时的共享库代码在内存中秩序保存一份，且可供所有运行中的程序使用<br>且经过编译处理的函数仅在共享库内保存一份以解决磁盘空间<br>此设计还能确保各类程序在编译时会及时使用到函数的最新版本，即只需将带有函数新定义的共享库重新加以编译即可，程序将会在下次执行时自动使用新函数</p></blockquote></li></ul><hr><p><strong>进程间通信及其同步</strong></p><ul><li><p>Linux系统上运行有多个进程，其中许多都是独立运行</p><blockquote><p>然而有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制</p></blockquote></li><li><p>读写磁盘文件中的信息是进程通信的方法之一</p><blockquote><p>可是这种方法对于许多程序来说既慢又缺乏灵活性<br>因此，Linux像所有现代UNIX系统所实现的那样去提供了丰富进程间通信的IPC机制</p></blockquote></li><li><p>IPC机制相关概念列表/相关作用及其存在意义:</p><blockquote><p>信号(signal)，用于表示实践的发生<br>管道(即shell用户中的”|”)操作符和FIFO，用于在进程间传递数据<br>套接字，用于为同一台主机或是联网的不同主机上所允许的进程之间传递数据<br>文件锁定，用于防止其它进程读取或更新文件内容，同时运行某进程对文件的部分区域加以锁定<br>消息队列，用于在进程之间交换消息(数据包)<br>信号量(semaphore)，用于同步进程动作<br>共享内存，用于运行两个及两个以上的进程共享同一块内存</p></blockquote></li><li><p>就本质而言，FIFO和UNIX套接字的功能几近相同，即允许统一系统上并无关联的进程间彼此交换数据</p></li><li><p>两种可以并存于现在UNIX系统之中是由于FIFO来自System V，而套接字则源于BSD</p></li><li><p>IPC相关概念:</p><blockquote><p>对于信号及对其的深入刨析与讨论(依旧在后续章节对其实现与刨析)</p></blockquote></li></ul><hr><p><strong>线程</strong></p><ul><li><p>线程的基本概念描述:</p><blockquote><p>在现代UNIX实现中，每个进程都可执行多个线程<br>可将线程的概念比喻为共享同一虚拟内存及一干其它属性的进程<br>每个线程都会执行相同的程序代码，共享同一数据区域和堆<br>并且在同时，每个线程都拥有属于自己的栈，用以装载本地变量和函数调用等链接信息<br>线程之间可通过共享的全局变量进行通信<br>此外，利用上面所描述的IPC和同步机制，线程之间也能够彼此通信</p></blockquote></li><li><p>线程的优点:</p><blockquote><p>线程的优点就在于协同线程之间的数据共享(通过全局变量)更为容易<br>而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然<br>再者就是多线程应用能从多处理器硬件的并行处理中受益匪浅</p></blockquote></li><li><p>有关线程的相关概念列表:</p><blockquote><p>进程组<br>shell任务控制机制<br>会话机制<br>控制终端机制<br>控制进程机制</p></blockquote></li></ul><hr><p><strong>其它操作系统层面的相关概念:</strong></p><ul><li><p>伪终端，是一对相互连接的虚拟设备，也可称之为主从设备</p><blockquote><p>在这对设备之间，设有一条IPC信道以供数据之间进行双向传递<br>并且从设备(slave device)所提供的接口，其行为方式与终端相类似<br>最知名的伪终端要数telnet和ssh之类提供网络登陆服务的应用，以及 x window 系统所提供的终端窗口实现</p></blockquote></li><li><p>日期和时间</p><blockquote><p>进程涉及两种类型时间: 真实时间与进程时间(即为CPU时间，指自进程启动而来，所占有的CPU时间总量)<br>还可进一步的将CPU时间划分为系统CPU时间和用户CPU时间，前者用于指内核模式中执行代码所占用的时间，后者用于指在用户模式中执行代码所占用的时间<br>time命令会显示出真实时间，系统CPU时间，以及执行管道中的多个线程而花费的用户CPU时间</p></blockquote></li><li><p>客户端/服务器架构</p><blockquote><p>即C/S架构<br>这里不做过多赘述</p></blockquote></li><li><p>实时性</p><blockquote><p>纯粹性概念，字面理解<br>关于实时性概念的实现与对其的具体定义这里不做过多赘述</p></blockquote></li><li><p><code>/proc</code>文件系统</p><blockquote><p>在Linux中实现并且提供了类似于其它的现代UNIX系统中的<code>/proc</code>文件系统<br>由一组目录和文件所组成，装配(mount，或称其为挂载)于<code>/proc</code>目录下<br><code>/proc</code>文件系统是一种虚拟文件系统，以文件系统目录和文件形式来提供一个指向内核数据结构的接口<br>以用于用户查看，改变和管理各种系统属性<br>关于/proc文件系统的内容这里先不做过多赘述，今后的章节内会进行刨析与实践</p></blockquote></li></ul><hr><p><strong>本章节所涉及的相关概念归纳</strong></p><ul><li>涉及概念一览(完整版本)</li><li>UNIX/Linux kernel</li><li>操作系统</li><li>shell/shell任务控制</li><li>文件</li><li>I/O模型</li><li>程序</li><li>进程/进程间通信与进程间同步</li><li>信号</li><li>线程</li><li>进程组</li><li>会话</li><li>内存/内存映射</li><li>静态库</li><li>共享库</li><li>终端控制</li><li>进程控制</li><li>伪终端</li><li>日期及时间</li><li>C/S-客户端/服务器架构</li><li>实时性</li><li><code>/proc</code>文件系统</li></ul><p><strong>本章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>所有涉及的文献资料皆来源于电子书籍</p></li><li><p><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a></p><blockquote><p>第二章节内容<br>PDF资源可参考文章OS-1</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux内核与操作系统基本概念归纳&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>自由</title>
    <link href="https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/"/>
    <id>https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/</id>
    <published>2020-03-06T04:32:03.000Z</published>
    <updated>2020-03-06T04:33:29.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>自由-主观</strong></center><a id="more"></a><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><ul><li>论题三大核心: 自由/纯粹/智慧</li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>自由/纯粹自由</li><li>理智/纯粹理智</li><li>本能/纯粹本能</li><li>智慧/纯粹智慧</li></ul><hr><p><strong>论题:</strong></p><ul><li>什么是自由</li><li>自由从从何而来</li><li>自由的本质是什么</li></ul><hr><p><strong>引论:</strong></p><ul><li>如何定义自由</li><li>对于自由的主观定义</li><li>所谓的自由</li><li>自由于精神层面的理解</li><li>自由于现实层面的实现</li><li>为何要去实现或追求自由</li></ul><hr><h3 id="人类-1"><a href="#人类-1" class="headerlink" title="人类-1"></a>人类-1</h3><p><strong>论题推论:</strong></p><ul><li>什么是自由</li><li>自由从何而来</li><li>自由的本质是什么</li></ul><p><strong>什么是自由?/自由从何而来?/自由的本质是什么?</strong></p><ul><li><p>自由源于人类的本质与天性，所谓天性，即为因存在于现实世界而产生的本能性质的无智逻辑(如果以具备智慧层面的生物来定义，也可称此为无逻辑)</p></li><li><p>但世事皆有因果，万物皆成逻辑(这里将不会过多的带入无的相关与衍生概念)</p></li><li><p>无智逻辑(亦可将其称之或理解为环境逻辑与自然逻辑)</p></li><li><p>存在即现实</p><blockquote><p>世界(即环境)源于空，空源于无<br>任何现实事物的本质来源于世界与环境，包括生命与智慧<br>生命是一切存在于现实的前提，但生命不会定义存在，而智慧可以定义存在<br>存在只是作为存在而存在于现实，概念将归于空-0<br>而当现实的存在被[定义]为存在于现实时，概念将归于世界，即为有-1<br>无即为无</p></blockquote></li><li><p>对于自由的主观定义</p><blockquote><p>在人类的存在还没有被定义之时，生物(即现实层面)的本质就早已被世界或环境所定义<br>此概念的逻辑为无智慧逻辑，也可将其定义于空，将不会产生任何讨论意义<br>此层面逻辑定义了人类于现实层面(世界)内最基本的性质，即存在(生命)<br>而伴随生命而存在的其它事物-现实，世界，无智逻辑(环境逻辑)<br>此间的现实中不存在于秩序，规则与存在等智慧层面的逻辑与概念</p></blockquote></li><li><p>存在即现实</p><blockquote><p>而自由与自由的概念所产生的本质皆来源于此刻<br>为什么会存在自由，有关自由的一切概念从何而来<br>自由来源于本质，而本质来源于环境与世界，世界源于空</p></blockquote></li><li><p>至此，引出我对自由的主观定义</p><blockquote><p>自由虽源于空，但绝不是凭空出现的<br>自由只是人类/生物于现实世界间所产生与拥有的本质<br>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面<br>或称为自由存在于现实层面，由此被智慧定义</p></blockquote></li><li><p>自由有可能可以被归于纯粹层面，即纯粹自由/本质(本能)自由</p><blockquote><p>自由是无智的逻辑，归于本质与本能，是人类永远不可能抛离的概念与本质<br>但人类拥有智慧，智慧可以定义与控制本质与本能<br>智慧存在于现实或精神层面之间的意义，即为定义本能或称[一切存在于世界之间的概念]<br>自由源于空，源于世界，源于本质，但绝对不会[源]于智慧<br>追求本质也是人类作为生物而存在于现实间的本质<br>一切概念与现实皆源于空，即存在-源于空</p></blockquote></li><li><p>存在即现实</p><blockquote><p>存在于现实间的本质与基本的条件/逻辑/概念—即为生命<br>即-生命归于现实，现实归于本质(人类)，本质归于空<br>至此自由是同存在/生命而存在与现实的<br>即人类/生物的本质即为存在，存在则为自由-[无规则(无秩序)/空-无]<br>人类源于空/无，人类/生物的本质即为空/无<br>自由是无概念概念，前者的概念为无，后者的概念为智慧所定义的概念<br>由源于空/源于无，自由是由无智时期就存在于现实间的概念</p></blockquote></li><li><p>生命与自由是人存在于现实的本质，本质即为无智逻辑</p><blockquote><p>于空或无间定义的概念，存在于现实间的人类或生物将永远无法抛离<br>不存在即为无意义，将不会产生任何讨论的意义<br>但不存在于现实可以进行讨论，这里先不进行讨论</p></blockquote></li><li><p>我目前还没有找到我想要找到的答案……</p><blockquote><p>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面 <?>自由存在于现实层面，由此被智慧定义 <?> 迷惑概念<br>主观的现实逻辑混乱，有一些概念只可意会，无法言传<br>或称为我的主观智慧层次与逻辑层次未到足矣将其以言传之的境界</p></blockquote></li></ul><hr><p><strong>引论答案:</strong></p><ul><li><p>如何定义自由</p></li><li><p>对于自由的主观定义</p><blockquote><p>自由于主观智慧被定义为无逻辑概念</p></blockquote></li><li><p>所谓的自由</p></li><li><p>自由于精神层面的理解</p></li><li><p>自由于现实层面的实现</p></li><li><p>为何要去实现或追求自由</p><blockquote><p>自由源于本质，本质源于现实，讨论于智慧层面间的存在等概念将不会产生任何存在意义<br>现实源于空，空源于无</p></blockquote></li></ul><hr><ul><li><p>一切皆归于无，一切皆可定义为无</p><blockquote><p>逻辑漏洞/逻辑死角/逻辑缺口<br>或称为现实(世界/环境)漏洞/现实缺陷<br>世界也可将其主观的定义为宇宙(现实)</p></blockquote></li><li><p>无</p><blockquote><p>现实逻辑漏洞，有待思考……</p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li><p>如何实现自由，现实间的自由为何物？</p></li><li><p>为何要去实现与追求自由？</p></li><li><p>自由来源于本能，同时将终于智慧</p><blockquote><p>智慧与理智的产物-规则与秩序<br>限制了所谓的自由(即本能)<br>自由所带来的结果必然与智慧(最基本且必然的产物: 规则/秩序)相对<br>当然，由资本所带来的规则与秩序是极度不堪与肮脏的<br>纯粹的智慧终究会产生最精密的逻辑与最极端的规则与秩序<br>而拥有与持续规则与秩序的最基本的条件与概念为-[理智]<br>理智是完全相对于本能的，相对于生物的(与之完全对立且相反，这里称其为相对)<br>或称其是完全且绝对相对于低等/低智能或无智能生物的</p></blockquote></li><li><p>规则与秩序的最基本条件是理智，同时来源于智慧</p><blockquote><p>一味的追求本能与自由的后果即为-停止前进/进化<br>本能与智慧-自由与秩序-滞留与进化<br>自由在理智与智慧的层面是无意义的，是愚昧的，是与之完全/绝对相对的<br>但在本质与本能的层面是完全合理的，是必然的，是完全符合无智逻辑的，是完全正确的</p></blockquote></li><li><p>人类的本质是社会性的</p><blockquote><p>而现有/现实存在的人类/生物的最高进化概念即为-共产主义<br>智慧，理智与秩序最高的社会性形态即为共产主义社会<br>共产主义不会脱离社会性(或称共产主义就是完全建立在社会性的基础上的)，即绝对且完全不会去尝试抛离本能(抛离本能的概念将不存在于现实)<br>而共产主义的弊端即为-此概念是近乎抛离本能的(非本质)，所以成为纯粹共产主义者的前提-就是拥有绝对且成熟的理智与纯粹的智慧<br>抛离本能带来的最终结果即为-抛离自由-共产主义者的自由将必然会被社会性/所处共产主义社会形态所完全(或称绝对)剥夺</p></blockquote></li><li><p>纯粹共产主义社会没有自由可言</p><blockquote><p>因为每一个独立者都将拥有最绝对的理智与最纯粹的智慧<br>它们将不乞求于自由<br>它们将抛离生物的本能(非本质)<br>目前看来…<br>它们…注定不会是存在于现实间的人类…<br>生产力完全充足之时，将有可能实现？<br>不<br>只有当人类完全抛离生而为人/为生物的本质之时<br>才有可能实现<br>此概念将抛离于现实</p></blockquote></li><li><p>人类实现共产主义…</p><blockquote><p>机械智能能否实现共产主义？<br>只有纯粹的精神意识体，能够实现所谓的纯粹共产主义-即纯粹理想主义<br>纯粹理想主义的概念为非现实概念(即便有可能存在于现实)</p></blockquote></li><li><p>纯粹-纯粹自由/纯粹共产主义</p></li></ul><p><strong>至此</strong></p><hr><ul><li>下一论题<blockquote><p>规则与秩序</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;自由-主观&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>UNIX/PIPE-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/PIPE-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/PIPE-1/</id>
    <published>2020-03-05T06:37:00.000Z</published>
    <updated>2020-03-06T08:00:26.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>UNIX-PIPES概述</strong></center><a id="more"></a><h2 id="UNIX-PIPE-1"><a href="#UNIX-PIPE-1" class="headerlink" title="UNIX/PIPE-1"></a>UNIX/PIPE-1</h2><hr><h3 id="Unix-Pipeline-Pipes-1"><a href="#Unix-Pipeline-Pipes-1" class="headerlink" title="Unix-Pipeline/Pipes-1"></a>Unix-Pipeline/Pipes-1</h3><p><strong>概述:</strong></p><ul><li>管道(Pipeline)是一系列将标准输入输出链接起来的进程</li><li>其中每一个进程的输出被直接作为下一个进程的输入</li><li>每一个链接都由匿名管道实现</li><li>管道中的组成元素也被称作过滤程序</li><li>通常被用于类Unix操作系统(以及一些其他借用了这个设计的操作系统，如Windows)中</li><li>其他操作系统的这个特色源自于Unix，例如Taos和MS-DOS<blockquote><p>最终成为软件工程的管道与过滤器设计样本</p></blockquote></li><li>这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名</li><li>UNIX管道技术需要注意的一点就是需要将管道与管线区分开来(两种截然不同的概念)</li></ul><hr><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述:"></a>具体描述:</h3><p><strong>管道概念:</strong></p><ol><li>管道是用于将一系列的标准输入输出指令(代码)链接起来，从而形成进程的最基本条件</li><li>并且被链接的每一个进程的输出被直接作为下一个进程的输入</li></ol><p><strong>还可以将其描述为:</strong></p><ol><li><p>管道是将一系列标准输入输出链接起来的进程</p></li><li><p>其中每一个进程的输出被直接作为下一个进程的输入</p></li><li><p>其中每一个链接都由匿名管道实现</p></li><li><p>管道中的组成元素也被称作过滤程序</p></li></ol><ul><li><p>其概念模型非常类似于现实世界种的管道</p></li><li><p>该图片描述了某一文字终端上一个包含三个程序的管道:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>管线:</strong></p><ul><li><p>是指将计算机指令处理过程拆分为多个步骤</p></li><li><p>并通过多个硬件处理单元并行执行来加快指令执行速度</p></li><li><p>亦可称之为流水线</p><blockquote><p>因为其具体执行过程类似工厂中的流水线，并因此得名<br>可以将计算机指令比喻为流水线传送带上的产品<br>而各个硬件处理单元就是流水线旁的工人<br>每个不同的产品都需要细分为几个互不相同的部门来实现其各部件的所需<br>所以流水线中所属部门不同的工人会为了同一个产品而同时工作</p></blockquote></li></ul><hr><ul><li>微处理器</li><li>在使用流水线的处理器中一个指令不是在处理器的一个定时器信号中完成的<blockquote><p>而是被分到多个信号中去完成，但是与此同时多个指令的分任务被同时处理</p></blockquote></li><li>由于这些分任务比整个指令要简单，因此可以通过使用流水线提高定时器频率<blockquote><p>虽然每个指令需要多个信号后才能完成<br>但是通过多个指令的并行运算每个信号内一个指令可以完成<br>因此通过这个方法整个速度可以提高</p></blockquote></li></ul><hr><ul><li>流水线级</li><li>一条流水线的每个分步骤被称为流水线级<blockquote><p>它们被流水线寄存器分开除指令流水线外在现代系统中还有其它流水线<br>比如用来计算浮点数的算术流水线</p></blockquote></li></ul><hr><ul><li>管线危障(pipeline hazards)</li><li>假如，一个指令在执行的时候，需要等待流水线上前一个指令先执行完毕的话<blockquote><p>那么这两个指令相互之间彼此有依赖关系<br>这可能导致流水线冲突的现象发生<br>即为管线危障</p></blockquote></li><li>常见情况可分为四种: 资源冲突/数据冲突(指令层的数据冲突/传输层的数据冲突)/控制流冲突</li><li>通过分支预测器可以避免控制冲突<blockquote><p>在这里处理器预测性地继续运算，直到正式预测是正确为止</p></blockquote></li></ul><hr><p><strong>网络管线:</strong></p><ul><li>Unix哲学: “一切皆文件”<blockquote><p>netcat和socat这样的工具可以将管道连接到TCP/IP套接字</p></blockquote></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>管道(UNIX)</li><li>具名管道</li><li>命名管道</li><li>匿名管道</li><li>匿名命名管道</li><li>哈特曼管道</li><li>管线(流水线)</li><li>管线/流水线(计算机)</li><li>管线危障(pipeline hazards)</li><li>重定向(计算机)</li><li><code>tee指令</code><blockquote><p>该程序用于从管线内取出数据</p></blockquote></li><li>XML管道即为处理XML的管线</li><li>网络管线</li><li>UNIX</li><li>进程间通信</li><li>数字通信技术<blockquote><p>计算机通信技术</p></blockquote></li><li>管道协议</li><li>并发计算</li><li>协同控制</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>EN-System Interfaces<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html" target="_blank" rel="noopener">跳转</a></p></li><li><p>单一UNIX规范第7期，由国际开放标准组织发布</p><blockquote><p><code>https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html</code></p></blockquote></li><li><p>EN-Pipes: A Brief Introduction by The Linux Information Project (LINFO)<a href="http://www.linfo.org/pipe.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linfo.org/pipe.html</code></p></blockquote></li><li><p>获取管道的doc文案: <a href="http://www.cs.rit.edu/~swm/history/DTSS.doc" target="_blank" rel="noopener">http://www.cs.rit.edu/~swm/history/DTSS.doc</a></p></li></ul><hr><ul><li><p>以下内容参考自中文维基:</p></li><li><p>CN-分类:</p><blockquote><p>进程通信<a href="https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">跳转</a><br>进程间通信<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</code><br><code>https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A</code></p></blockquote></li><li><p>CN-分类: UNIX<a href="https://zh.wikipedia.org/wiki/Category:Unix" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Unix</code></p></blockquote></li><li><p>CN-分类: 并发计算<a href="https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97</code></p></blockquote></li><li><p>CN-分类: 协同控制<a href="https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6</code></p></blockquote></li><li><p>EN-分类: 指令处理<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><ul><li>CN-维基百科-点对点隧道协议: <a href="https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0</a></li><li>CN-维基百科-管道机制: <a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)</a></li><li>CN-维基百科-管道流: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-IDC: <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83</a></li><li>CN-维基百科-管线: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-命名管道: <a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93</a></li><li>EN-维基百科-管道(计算机): <a href="https://en.wikipedia.org/wiki/Pipeline_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pipeline_(computing)</a></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX-PIPES概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>OS-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/OS-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/OS-1/</id>
    <published>2020-03-05T03:34:05.000Z</published>
    <updated>2020-03-05T05:12:06.302Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>OS-PDF/URL资源整合目录</strong></center><a id="more"></a><h2 id="Operating-System-1"><a href="#Operating-System-1" class="headerlink" title="Operating System-1"></a>Operating System-1</h2><ul><li>操作系统</li><li>Operating System/OS</li></ul><hr><h3 id="电子书资源整合目录"><a href="#电子书资源整合目录" class="headerlink" title="电子书资源整合目录"></a>电子书资源整合目录</h3><ul><li><p>可能还会利用持续利用此文本进行URL资源整合</p></li><li><p>操作系统概念</p></li><li><p>操作系统原理</p></li><li><p>操作系统设计</p></li><li><p>操作系统制作</p></li><li><p>操作系统实现</p></li></ul><hr><ul><li>操作系统分析与理解<blockquote><p>Unix操作系统<br>FreeBSD(Unix-Like)操作系统<br>Linux(Unix-Like)操作系统</p></blockquote></li></ul><hr><ul><li>中文维基-<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</code></p></blockquote></li></ul><hr><p><strong>使用资源目录:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)<a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/297382.html</code><br><code>https://pan.baidu.com/s/1ntzHejv</code></p></blockquote></li><li><p>CN-Linux系统编程手册上册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p></li><li><p>CN-Linux系统编程手册下册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2016-10/135953.htm</code></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)<a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/232150.html</code></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)<a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://pan.baidu.com/s/1gdKdxlT</code></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)<a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/90585.html</code></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)<a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/294083.html</code></p></blockquote></li></ul><hr><p><strong>资源相关URL补充:</strong></p><ul><li><p>Linux/UNIX编程手册(分卷压缩文件)</p><blockquote><p><code>https://download.csdn.net/download/js_gary/10216486</code><br><code>https://download.csdn.net/download/js_gary/10216495</code></p></blockquote></li><li><p>FreeBSD解析</p><blockquote><p><a href="https://download.csdn.net/download/starry225/6223229" target="_blank" rel="noopener">https://download.csdn.net/download/starry225/6223229</a></p></blockquote></li></ul><hr><p><strong>整合包获取:</strong></p><ul><li>以上PDF资源整合文件的压缩包(一共七本电子书，rar格式):</li><li>百度网盘地址<a href="https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w" target="_blank" rel="noopener">永久链接</a><blockquote><p><code>https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w</code></p></blockquote></li><li>提取码: j3qc</li></ul><hr><p><strong>资源汇总:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)</p><blockquote><p><a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">https://www.jb51.net/books/297382.html</a><br><a href="https://pan.baidu.com/s/1ntzHejv" target="_blank" rel="noopener">https://pan.baidu.com/s/1ntzHejv</a></p></blockquote></li><li><p>CN-Linux系统编程手册上册</p></li><li><p>CN-Linux系统编程手册下册</p><blockquote><p><a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-10/135953.htm</a></p></blockquote></li><li><p>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</p><blockquote><p><a href="http://www.downcc.com/soft/302635.html" target="_blank" rel="noopener">http://www.downcc.com/soft/302635.html</a></p></blockquote></li><li><p>CN-现代操作系统 (原书第四版)</p><blockquote><p><a href="https://www.jb51.net/books/655464.html" target="_blank" rel="noopener">https://www.jb51.net/books/655464.html</a></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)</p><blockquote><p><a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">https://www.jb51.net/books/232150.html</a></p></blockquote></li><li><p>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</p></li><li><p>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</p><blockquote><p><a href="https://www.jb51.net/books/483820.html" target="_blank" rel="noopener">https://www.jb51.net/books/483820.html</a></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</p><blockquote><p><a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">https://pan.baidu.com/s/1gdKdxlT</a></p></blockquote></li><li><p>CN-深入理解UNIX系统内核 (瓦哈利亚)</p><blockquote><p><a href="https://www.jb51.net/books/609170.html" target="_blank" rel="noopener">https://www.jb51.net/books/609170.html</a></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</p><blockquote><p><a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">https://www.jb51.net/books/294083.html</a></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)</p><blockquote><p><a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">https://www.jb51.net/books/90585.html</a></p></blockquote></li></ul><hr><p><strong>书籍参考目录:</strong></p><ul><li>CN-操作系统概念 (原书第九版)</li><li>CN-操作系统概念 (2007-第七版，西尔伯查茨)</li><li>CN-操作系统概念 (原书第7版，清大出版)</li><li>CN-操作系统概念精要 (原书第二版)</li></ul><hr><ul><li>CN-Linux系统编程手册上册</li><li>CN-Linux系统编程手册下册</li><li>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</li></ul><hr><ul><li>CN-现代操作系统 (原书第四版)</li><li>CN-现代操作系统 (原书第三版)</li></ul><hr><ul><li>CN-操作系统精髓与设计原理 (原书第六版)</li><li>CN-计算机系统: 核心概念及软硬件实现 (原书第四版)</li><li>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</li><li>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</li><li>CN-操作系统设计与实现 (2008版，ANDREW S.TANENBAUM/ALBERT S.WOODHULL)</li></ul><hr><ul><li>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</li><li>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</li><li>CN-30天自制操作系统 (2012版，川和秀实)</li><li>CN-深入理解UNIX系统内核 (瓦哈利亚)</li></ul><hr><p><strong>其它:</strong></p><ul><li>书不重要</li><li>问题在于看书的人所拥有的能力</li><li>同种类型的书的本质都是相同的</li><li>找出，理解并且完全记住其中的关键字</li><li>至于对于电子书的版号的选择也无所谓的</li><li>译版与原版随意，有译版最好读译版</li><li>通常EN版的寻找难度比CN版小很多</li></ul><hr><ul><li>系统化学习目录</li><li>Operating System kernel</li><li>数字理论基础</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;OS-PDF/URL资源整合目录&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>VPS/KVM-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/VPS-KVM-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/VPS-KVM-1/</id>
    <published>2020-03-04T20:28:57.000Z</published>
    <updated>2020-03-05T06:53:16.497Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>VPS/KVM简要概述</strong></center><a id="more"></a><h2 id="VPS-KVM-1"><a href="#VPS-KVM-1" class="headerlink" title="VPS/KVM-1"></a>VPS/KVM-1</h2><hr><h3 id="虚拟专用服务器-Virtual-private-server"><a href="#虚拟专用服务器-Virtual-private-server" class="headerlink" title="虚拟专用服务器 (Virtual private server)"></a>虚拟专用服务器 (Virtual private server)</h3><p><strong>简述:</strong></p><ul><li>简称VPS</li><li>由容器技术或虚拟机技术实现</li><li>在容器或虚拟机中，每个VPS都拥有独立的公网IP，操作系统，磁盘空间，内存与处理器资源<blockquote><p>同时进程与系统配置之间也相互隔离<br>目的就是为了让用户和应用程序在同一个主机上模拟出完全不同，独立且相互隔离的资源占用与控制<br>以此让VPS可以完全拥有独立服务器的所有功能</p></blockquote></li><li>并且VPS为用户提供了管理配置的自由</li><li>VPS多用于企业虚拟化于IDC资源租用</li><li>VPS拥有完全的独立性，包括可以在容器内自行安装任何程序与其它对于虚拟硬件的操作<blockquote><p>远端服务器-&gt;容器/虚拟机-&gt;容器/虚拟机-&gt;用户</p></blockquote></li></ul><hr><h3 id="基于内核的虚拟机-Kernel-based-Virtual-Machine"><a href="#基于内核的虚拟机-Kernel-based-Virtual-Machine" class="headerlink" title="基于内核的虚拟机 (Kernel-based Virtual Machine)"></a>基于内核的虚拟机 (Kernel-based Virtual Machine)</h3><p><strong>简述:</strong></p><ul><li>可简称为KVM</li><li>是一种用于Linux内核中的虚拟化基础设施，可将Linux内核转化为一个虚拟机监视器</li><li>KVM于2007年2月5日被导入Linux 2.6.20核心中，基于C</li><li>KVM需要支持硬件虚拟化拓展特性的处理器</li><li>对于操作系统支持的范围较为广泛</li><li>基于多个GNY协议授权<blockquote><p>包括KVM内核模块: GPL v2<br>KVM用户模块: LGPL v2<br>QEMU虚拟CPU内核库(libqemu.a)和QEMU PC系统模拟器: LGPL<br>Linux用户模式QEMU模拟器: GPL<br>BIOS文件(bios.bin，vgabios.bin和vgabios-cirrus.bin): LGPL v2或更新</p></blockquote></li><li>KVM现由保罗·邦齐尼(Paolo Bonzini)维护</li><li>KVM 支持VirtIO半虚拟化技术-平行虚拟化技术(paravirtualization)</li></ul><hr><p><strong>内部结构:</strong></p><ul><li>KVM提供抽象的设备，但不模拟处理器</li><li>它开放了<code>/dev/kvm</code>接口，供使用者模式的主机使用:</li></ul><ol><li>设置客户虚拟机的地址空间<blockquote><p>宿主机同样也需用户可用于引导进主操作系统的固件镜像(通常为模拟PC时的自定义BIOS)</p></blockquote></li><li>为客户机模拟I/O</li><li>将客户机的视频显示映射回系统宿主机上</li></ol><ul><li><p>在Linux上，QEMU版本0.10.1及更新版就是一个用户层主机</p><blockquote><p>QEMU使用KVM以近乎原生的速度虚拟化客户机，若无KVM的话则将仅使用软件模拟</p></blockquote></li><li><p>KVM内部使用SeaBIOS作为对16位x86 BIOS的开源模拟</p></li><li><p>KVM/QEMU环境的高级概述:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>相关GUI(图形化管理)工具:</strong></p><ul><li>Kimchi – 网页版KVM虚拟化管理工具</li><li>Virtual Machine Manager – 支持创建、编辑、开始于关闭基于KVM的虚拟机，同时也支持对宿主之间的实时或冷拖拽虚拟机迁移</li><li>Proxmox虚拟环境 – 一项开源的虚拟化管理包，包括KVM与LXC<blockquote><p>同时它还有裸机安装器、网页版远程管理界面、HA集群堆栈、统一存储、柔性网络及可选的商业支持</p></blockquote></li><li>OpenQRM – 用于管理不同数据中心基础设施的平台</li><li>GNOME 机柜 – Linux上用于管理libvirt客户机的Gnome界面</li><li>oVirt – 用于管理基于libvirt的KVM开源工具</li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>VPS</li><li>KVM</li><li>Virtual</li><li>CN2</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-Redhat-KVM官方网站<a href="https://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux-kvm.org/page/Main_Page</code></p></blockquote></li><li><p>CN-CN2线路是什么，有哪些CN2线路的VPS<a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</code></p></blockquote></li></ul><p><strong>维基百科参考内容:</strong></p><ul><li><p>CN-虚拟主机<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA</code></p></blockquote></li><li><p>CN-虚拟专用服务器<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-服务器<a href="https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-虚拟化<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>CN-硬件虚拟化<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96</code></p></blockquote></li><li><p>CN-KVM-基于内核的虚拟机<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA</code></p></blockquote></li></ul><hr><h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><ul><li><p>境外KVM类型的VPS大约360RMB/年(美国)</p><blockquote><p>最便宜的</p></blockquote></li><li><p>官网地址: <a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">https://shadowsocks.org/en/index.html</a></p></li><li><p>仓库地址: <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></p></li></ul><hr><p><strong>可用参考:</strong></p><ul><li><p>CN-Github-SS教程</p><blockquote><p><a href="https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B</a><br><a href="https://ssr.tools/252" target="_blank" rel="noopener">https://ssr.tools/252</a></p></blockquote></li><li><p>搬瓦工 (Bandwagon Host)</p><blockquote><p>VPS供应商，支持支付宝支付<br><a href="https://bwh88.net/cart.php?gid=1" target="_blank" rel="noopener">https://bwh88.net/cart.php?gid=1</a><br><a href="https://bwg.net/" target="_blank" rel="noopener">https://bwg.net/</a></p></blockquote></li><li><p>CN2: <a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</a></p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;VPS/KVM简要概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Text</title>
    <link href="https://unit-serow.github.io/2020/03/04/text/"/>
    <id>https://unit-serow.github.io/2020/03/04/text/</id>
    <published>2020-03-03T23:18:27.000Z</published>
    <updated>2020-03-04T01:11:38.154Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>常驻Text文档</strong></center><a id="more"></a><p><strong>常驻随笔文档</strong></p><ul><li>无<blockquote><p>无很容易理解<br>但很难做到<br>很难在现实中实现?<br>不<br>无不属于现实<br>无则为无<br>空源于无<br>世界源于空<br>思维源于世界<br>而思维终将归于无</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;常驻Text文档&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
