<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-02-09T05:51:59.816Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker Swarm-集群</title>
    <link href="https://unit-serow.github.io/2020/02/09/Docker-Swarm-1/"/>
    <id>https://unit-serow.github.io/2020/02/09/Docker-Swarm-1/</id>
    <published>2020-02-09T05:47:40.000Z</published>
    <updated>2020-02-09T05:51:59.816Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 09 2020 13:52:04 GMT+0800 (中国标准时间) --><h3 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h3><p><strong>概述:</strong></p><ul><li><p><code>Docker Swarm</code>是Docker的集群管理工具</p></li><li><p>它将<code>Docker主机池</code>转变为单个虚拟Docker主机</p></li><li><p><code>Docker Swarm</code>提供了标准的<code>Docker API</code></p></li><li><p>目的是使所有任何已经与Docker守护程序通信的工具都可以使用Swarm轻松地扩展到多个主机</p></li><li><p>支持的工具包括但不限于以下各项：</p></li><li><p>Dokku</p></li><li><p>Docker Compose</p></li><li><p>Docker Machine</p></li><li><p>Jenkins</p></li></ul><p><strong>原理概述:</strong></p><ul><li><code>swarm集群</code>由管理节点(manager)和工作节点(work node)构成</li><li><code>swarm mananger</code>:负责整个集群的管理工作包括集群配置,服务管理等所有跟集群有关的工作</li><li><code>work node</code>:即为<code>available node</code>,主要负责运行相应的服务来执行任务(task)</li><li>逻辑简述</li><li>管理节点(swarm manager)内存储着若干个服务(service)的副本(replicas)文件</li><li>工作节点(available/worker node)内存储这服务的标识与服务的镜像文件(container)</li><li>管理节点将所有的服务副本都分配到工作节点内，并管理与控制工作节点内的任务执行<blockquote><p>[swarm manager[service replicas]]-&gt;[available node[task[container(service:latest)]]]<br>swarm manager-&gt;available node-1/available node-2/available node-3/available node-N</p></blockquote></li></ul><hr><p><strong>应用</strong></p><ul><li><p>以<code>Docker Machine</code>与<code>virtualbox</code>进行实践，需要先确保主机已安装<code>virtualbox</code></p></li><li><p>创建docker机器:</p><blockquote><p><code>$ docker-machine create -d virtualbox swarm-manager</code></p></blockquote></li></ul><hr><ul><li><p>创建管理节点(manager node)</p></li><li><p>初始化<code>swarm</code>集群，进行初始化的这台机器，就是集群的管理节点</p><blockquote><p><code>$ docker-machine ssh swarm-manager</code><br><code>$ docker swarm init --advertise-addr 192.168.99.101</code><br><code>--advertise-addr</code>后的IP为创建机器时分配的ip</p></blockquote></li><li><p>当为机器分配IP之后，命令行会输出向集群内添加工作节点的指令(连接令牌)</p><blockquote><p><code>To add a worker to this swarm，runthe following command</code><br><code>docker swarm join --token [...]</code></p></blockquote></li></ul><hr><ul><li>创建工作节点(worker node)</li><li>复制上面输出的指令(会被自动截断)<blockquote><p><code>$ docker swarm join --token [...]</code><br>输出<code>The node joined a swarm as a worker</code></p></blockquote></li></ul><hr><ul><li>查看集群信息<blockquote><p><code>docker info</code><br>输出内容中<code>Swarm active</code>内的<code>managers</code>与<code>node</code>即为节点信息</p></blockquote></li></ul><hr><ul><li><p>部署服务器到集群中</p></li><li><p>跟集群管理有关的任何操作，都是在管理节点上操作的</p></li><li><p>随机指派任一工作节点，并于工作节点上创建任意的一个服务</p><blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name [service name] alpine ping docker.com</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li><li><p>查看<code>service</code>部署的具体信息:</p><blockquote><p><code>docker@swarm-manager:~$ docker service inspect --pretty [service name]</code></p></blockquote></li></ul><hr><ul><li><p>扩展集群服务</p></li><li><p>将service服务扩展到若干个节点</p><blockquote><p><code>docker@swarm-manager:~$ docker service scale [service name]=[节点数]</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>删除服务<blockquote><p><code>docker@swarm-manager:~$ docker service rm [service name]</code></p></blockquote></li><li>查看服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>滚动升级服务</li><li>将redis旧版本通过滚动升级至更高版本</li><li>创建一个3.0.6版本的redis<blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</code></p></blockquote></li><li>滚动升级redis<blockquote><p><code>docker@swarm-manager:~$ docker service update --image redis:3.0.7 redis</code></p></blockquote></li><li>查看redis服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps redis</code></p></blockquote></li></ul><hr><ul><li><p>停止某个节点接收新的任务</p></li><li><p>查看所有的节点：</p><blockquote><p><code>docker@swarm-manager:~$ docker node ls</code></p></blockquote></li><li><p>默认所有的节点都是<code>Active</code>, 可以接收新的任务分配</p></li><li><p>停止节点<code>swarm-worker1</code>:</p><blockquote><p><code>docker node update --availability drain swarm-worker1</code></p></blockquote></li><li><p>此时<code>swarm-worker1</code>状态变为<code>Drain</code></p></li><li><p>不会影响到集群的服务，只是<code>swarm-worker1</code>节点不再接收新的任务</p></li><li><p>会使集群的负载能力有所下降</p></li><li><p>重新激活节点指令:</p><blockquote><p><code>docker@swarm-manager:~$ docker node update --availability active swarm-worker1</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><ul><li><p>虚拟机驱动<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/drivers/</code></p></blockquote></li><li><p>官方文档<a href="https://docs.docker.com/machine/reference/create/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/reference/create/</code></p></blockquote></li></ul><hr><p><strong>其他资源</strong></p><ul><li><p>Docker官方主页<a href="https://www.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.docker.com</code></p></blockquote></li><li><p>Docker官方博客<a href="https://blog.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.docker.com/</code></p></blockquote></li><li><p>Docker官方文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/</code></p></blockquote></li><li><p>Docker Store<a href="https://store.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://store.docker.com</code></p></blockquote></li><li><p>Docker Cloud<a href="https://cloud.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://cloud.docker.com</code></p></blockquote></li><li><p>Docker Hub<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com</code></p></blockquote></li><li><p>Docker的源代码仓库<a href="https://github.com/moby/moby" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/moby/moby</code></p></blockquote></li><li><p>Docker发布版本历史<a href="https://docs.docker.com/release-notes/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/release-notes/</code></p></blockquote></li><li><p>Docker常见问题<a href="https://docs.docker.com/engine/faq/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/engine/faq/</code></p></blockquote></li><li><p>Docker远端应用 API<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/develop/sdk/</code></p></blockquote></li></ul><hr><p><strong>Docker国内镜像源</strong></p><ul><li><p>阿里云<a href="https://help.aliyun.com/document_detail/60750.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://help.aliyun.com/document_detail/60750.html</code></p></blockquote></li><li><p>网易云加速器</p><blockquote><p><code>http://hub-mirror.c.163.com</code></p></blockquote></li><li><p>中国官方加速器</p><blockquote><p><code>https://registry.docker-cn.com</code></p></blockquote></li><li><p>ustc的镜像</p><blockquote><p><code>https://docker.mirrors.ustc.edu.cn</code></p></blockquote></li><li><p>daocloud</p><blockquote><p><code>https://www.daocloud.io/mirror#accelerator-doc</code>(注册后使用)</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 09 2020 13:52:04 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Swarm-集群管理&quot;&gt;&lt;a href=&quot;#Swarm-集群管理&quot; class=&quot;headerlink&quot; title=&quot;Swarm 集群管理
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-1.1</title>
    <link href="https://unit-serow.github.io/2020/02/09/Docker-1-1/"/>
    <id>https://unit-serow.github.io/2020/02/09/Docker-1-1/</id>
    <published>2020-02-08T19:11:01.000Z</published>
    <updated>2020-02-08T19:12:50.026Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 09 2020 03:12:54 GMT+0800 (中国标准时间) --><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul><li><p>查看已有镜像</p><blockquote><p><code>docker images</code></p></blockquote></li><li><p>参数:仓库源/标签/ID/创建时间/空间</p><blockquote><p><code>debian tag [镜像ID]</code> # 添加标签</p></blockquote></li><li><p>查看仓库内所有镜像文件</p><blockquote><p><code>docker search debian</code></p></blockquote></li><li><p>拉取仓库内默认版本的debian镜像<code>(debian:latest)</code></p><blockquote><p><code>docker pull debian</code></p></blockquote></li><li><p>查看所有已创建容器</p><blockquote><p><code>docker ps -a</code></p></blockquote></li><li><p>用容器启动所选镜像</p><blockquote><p><code>docker run -it --name [自定义命名] debian /bin/bash</code></p></blockquote></li></ul><hr><ul><li>启动，停止，重启所选容器<blockquote><p><code>docker start/stop/restart [容器ID]</code><br>参数:<code>·-i交互式操作</code>，<code>-t终端</code>，<code>-d后台运行</code></p></blockquote></li></ul><hr><ul><li>删除操作<blockquote><p><code>docker rmi debian</code>删除镜像<br><code>docker rm -f</code>删除容器<br><code>docker container prune</code>删除所有停止的容器</p></blockquote></li><li>容器必须停止才能进行删除</li></ul><hr><ul><li>进入后台后使用<code>docker attach</code>或<code>docker exec [容器ID]</code>进入该容器</li><li>前者暂时性，后者永久性</li><li>重新进入容器时还必须加入原来设置的启动参数</li><li>比如<code>/bin/bash和-it</code></li></ul><hr><ul><li><p>设置[service]端口映射与绑定IP</p><blockquote><p><code>docker run -p [可选的IP绑定]:[映射端口]:[原端口]/(udp/tcp) [镜像名] [启动脚本]</code><br>参数:<code>-P</code>是随机映射，<code>-p</code>是指定映射</p></blockquote></li><li><p>查看端口绑定情况</p><blockquote><p><code>docker port [服务名]</code></p></blockquote></li></ul><hr><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><ul><li><p>父子关系这里都称为上下层级关系，与阶级关系不同</p></li><li><p>上级容器可以看到下级容器的关系</p></li><li><p>建立容器网络</p><blockquote><p><code>docker network create -d bridge/overlay(网络类型) [网络命名]</code>overlay<code>应用于</code>swarm`</p></blockquote></li><li><p>后台运行一个命名为<code>test1</code>的容器并把它并入<code>test-net</code>内，并开启交互式终端系统</p><blockquote><p><code>docker run -itd --name test1 --network test-net debian /bin/bash</code></p></blockquote></li><li><p>任何加入此网络的容器都会达成互联的状态</p></li></ul><hr><ul><li><p>设定所有容器域名和DNS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;&quot;dns&quot; : [&quot;111.111.111.111&quot;,&quot;1.1.1.1&quot;]&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看是否生效</p><blockquote><p><code>docker run -it rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>指定容器设置域名和DNS服务器</p><blockquote><p><code>docker run -it --rm _hostname=HOSTNAME --dns=IP_ADDRESS --dns-search=DOMAIN(搜索域) debian</code></p></blockquote></li><li><p>没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></li></ul><hr><ul><li><p>登陆<code>docker hub</code></p><blockquote><p><code>docker login</code></p></blockquote></li><li><p>退出<code>docker hub</code></p><blockquote><p><code>docker logout</code></p></blockquote></li><li><p>上传镜像</p><blockquote><p><code>docker tag 本地镜像名 username/远端镜像名</code></p></blockquote></li></ul><hr><ul><li><p>随笔</p><blockquote><p><code>Docker Engine</code> 引擎<br><code>REST API</code> 通用接口<br><code>Docker daemon</code> 守护进程</p></blockquote></li><li><p>自用简易指令集</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 09 2020 03:12:54 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;基本指令&quot;&gt;&lt;a href=&quot;#基本指令&quot; class=&quot;headerlink&quot; title=&quot;基本指令&quot;&gt;&lt;/a&gt;基本指令&lt;/h3&gt;&lt;ul
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Machine</title>
    <link href="https://unit-serow.github.io/2020/02/08/Docker-Machine/"/>
    <id>https://unit-serow.github.io/2020/02/08/Docker-Machine/</id>
    <published>2020-02-08T10:23:23.000Z</published>
    <updated>2020-02-08T10:24:47.570Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 08 2020 18:24:53 GMT+0800 (中国标准时间) --><h3 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h3><p><strong>概述:</strong></p><ul><li>可以实现在虚拟主机上安装Docker</li><li>并且可以使用<code>docker-machine</code>命令来管理主机</li><li><code>Docker Machine</code>管理的虚拟主机可以是机上的，也可以是云供应商的</li><li>使用<code>docker-machine</code>命令，可以用于启动，检查，停止和重新启动托管主机，也可以升级Docker客户端和守护程序</li><li>以及配置Docker客户端与本地主机进行通信</li><li>用于实现使用本地主机便可以操控远端的镜像容器集群</li></ul><p><strong>逻辑简述:</strong><br>[Client docker-machine[Client docker CLI[REST APT]]]-docker-machine create-&gt;[REST API[Server docker daemon]]</p><hr><p><strong>基于Linux安装Docker Machine</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ base&#x3D;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L $base&#x2F;docker-machine-$(uname -s)-$(uname -m) &gt;&#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  sudo mv &#x2F;tmp&#x2F;docker-machine &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure><ul><li>查看版本以验证是否安装成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version 0.16.0, build 9371605</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>对于machine version的使用</strong></p><ol><li><p>列出可用的机器</p><blockquote><p><code>$ docker-machine ls</code></p></blockquote></li><li><p>创建机器</p></li></ol><ul><li>创建一个名为serow的机器<blockquote><p><code>$ docker-machine create --driver virtualbox serow</code></p></blockquote></li><li>参数<code>--driver</code>用于指定用来创建机器的驱动类型，这里是<code>virtualbox</code></li></ul><ol start="3"><li><p>查看机器的 ip</p><blockquote><p><code>$ docker-machine ip serow</code></p></blockquote></li><li><p>停止机器</p><blockquote><p><code>$ docker-machine stop serow</code></p></blockquote></li><li><p>启动机器*</p><blockquote><p><code>$ docker-machine start serow</code></p></blockquote></li><li><p>进入机器*</p><blockquote><p><code>$ docker-machine ssh serow</code></p></blockquote></li></ol><hr><p><strong>docker-machine 命令参数明细</strong></p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">docker-machine active</td><td align="left">用于查看当前激活状态的Docker主机</td></tr><tr><td align="left">config</td><td align="left">查看当前激活状态Docker主机的连接信息</td></tr><tr><td align="left">creat</td><td align="left">创建Docker主机</td></tr><tr><td align="left">env</td><td align="left">显示连接到某个主机需要的环境变量</td></tr><tr><td align="left">inspect</td><td align="left">以<code>json</code>格式输出指定Docker的详细信息</td></tr><tr><td align="left">ip</td><td align="left">获取指定 Docker 主机的地址</td></tr><tr><td align="left">kill</td><td align="left">直接杀死指定的 Docker主机</td></tr><tr><td align="left">ls</td><td align="left">列出所有的管理主机</td></tr><tr><td align="left">provision</td><td align="left">重新配置指定主机</td></tr><tr><td align="left">regenerate-certs</td><td align="left">为某个主机重新生成TLS信息</td></tr><tr><td align="left">restart</td><td align="left">重启指定的主机</td></tr><tr><td align="left">rm</td><td align="left">删除某台Docker主机，对应的虚拟机也会被删除</td></tr><tr><td align="left">ssh</td><td align="left">通过SSH连接到主机上，执行命令</td></tr><tr><td align="left">scp</td><td align="left">在Docker主机之间以及Docker主机和本地主机之间通过<code>scp</code>远程复制数据</td></tr><tr><td align="left">mount</td><td align="left">使用SSHFS从计算机装载或卸载目录</td></tr><tr><td align="left">start</td><td align="left">启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td></tr><tr><td align="left">status</td><td align="left">获取指定Docker主机的状态(包括:<code>Running</code>,<code>Paused</code>,<code>Saved</code>,<code>Stopped</code>,<code>Stopping</code>,<code>Starting</code>,<code>Error</code>)等</td></tr><tr><td align="left">stop</td><td align="left">停止一个指定的Docker主机</td></tr><tr><td align="left">upgrade</td><td align="left">将一个指定主机的Docker版本更新为最新</td></tr><tr><td align="left">url</td><td align="left">获取指定Docker主机的监听URL</td></tr><tr><td align="left">version</td><td align="left">显示 Docker Machine 的版本或者主机Docker版本</td></tr><tr><td align="left">help</td><td align="left">显示帮助信息</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 08 2020 18:24:53 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Docker-Machine&quot;&gt;&lt;a href=&quot;#Docker-Machine&quot; class=&quot;headerlink&quot; title=&quot;Do
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>YAML-1</title>
    <link href="https://unit-serow.github.io/2020/02/08/YAML-1/"/>
    <id>https://unit-serow.github.io/2020/02/08/YAML-1/</id>
    <published>2020-02-08T09:48:07.000Z</published>
    <updated>2020-02-08T09:49:31.760Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 08 2020 17:49:36 GMT+0800 (中国标准时间) --><h3 id="YAML-基本语法与简述"><a href="#YAML-基本语法与简述" class="headerlink" title="YAML 基本语法与简述"></a>YAML 基本语法与简述</h3><p><strong>概述:</strong></p><ul><li>YAML是”YAML Ain’t a Markup Language”(YAML 不是一种标记语言)的递归缩写</li><li>在开发的这种语言时，YAML的意思其实是:”Yet Another Markup Language”(仍是一种标记语言)</li><li>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态</li><li>它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲</li><li>YAML的配置文件后缀为<code>.yml</code></li></ul><hr><p><strong>YAML的基本语法规则</strong></p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用<code>tab</code>，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li><code>&#39;#&#39;</code>表示注释</li></ul><hr><p><strong>YAML的数据类型</strong></p><ul><li>YAML支持以下几种数据类型：</li><li>对象:键值对的集合，又称为映射(mapping)/哈希(hashes) /字典(dictionary)</li><li>数组:一组按次序排列的值，又称为序列(sequence)/列表(list)</li><li>纯量(scalars):单个的、不可再分的值</li></ul><hr><p><strong>YAML对象</strong></p><ul><li><p>对象键值对使用冒号结构表示<code>key: value</code>，冒号后面要加一个空格</p></li><li><p>也可以使用<code>key:{key1: value1, key2: value2, ...}</code></p></li><li><p>还可以使用缩进表示层级关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key: </span><br><span class="line">    child-key: value</span><br><span class="line">    child-key2: value2</span><br></pre></td></tr></table></figure></li><li><p>较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的<code>key</code>，配合一个冒号加一个空格代表一个<code>value</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?  </span><br><span class="line">    - complexkey1</span><br><span class="line">    - complexkey2</span><br><span class="line">:</span><br><span class="line">    - complexvalue1</span><br><span class="line">    - complexvalue2</span><br></pre></td></tr></table></figure></li><li><p>意思即对象的属性是一个数组<code>[complexkey1,complexkey2]</code>，对应的值也是一个数组<code>[complexvalue1,complexvalue2]</code></p></li></ul><hr><p><strong>YAML数组</strong></p><ul><li>以<code>&#39;-&#39;</code>开头的行表示构成一个数组:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- A</span><br><span class="line">- B</span><br><span class="line">- C</span><br></pre></td></tr></table></figure></li><li>YAML 支持多维数组，可以使用行内表示:<blockquote><p><code>key: [value1, value2, ...]</code></p></blockquote></li><li>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line"> - A</span><br><span class="line"> - B</span><br><span class="line"> - C</span><br></pre></td></tr></table></figure></li><li>一个相对复杂的例子:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">companies:</span><br><span class="line">    -</span><br><span class="line">        id: 1</span><br><span class="line">        name: company1</span><br><span class="line">        price: 200W</span><br><span class="line">    -</span><br><span class="line">        id: 2</span><br><span class="line">        name: company2</span><br><span class="line">        price: 500W</span><br></pre></td></tr></table></figure></li><li>意思是<code>companies</code>属性是一个数组，每一个数组元素又是由<code>id</code>,<code>name</code>,<code>price</code>三个属性构成</li><li>数组也可以使用流式(flow)的方式表示:<blockquote><p><code>companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]</code></p></blockquote></li></ul><hr><p><strong>复合结构</strong></p><ul><li>数组和对象可以构成复合结构，例:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">languages:</span><br><span class="line">  - Ruby</span><br><span class="line">  - Perl</span><br><span class="line">  - Python </span><br><span class="line">websites:</span><br><span class="line">  YAML: yaml.org </span><br><span class="line">  Ruby: ruby-lang.org </span><br><span class="line">  Python: python.org </span><br><span class="line">  Perl: use.perl.org</span><br></pre></td></tr></table></figure></li><li>转换为 json 为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  languages: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39;],</span><br><span class="line">  websites: &#123;</span><br><span class="line">    YAML: &#39;yaml.org&#39;,</span><br><span class="line">    Ruby: &#39;ruby-lang.org&#39;,</span><br><span class="line">    Python: &#39;python.org&#39;,</span><br><span class="line">    Perl: &#39;use.perl.org&#39; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>纯量</strong></p><ul><li><p>纯量是最基本的，不可再分的值，包括：</p></li><li><p>字符串</p></li><li><p>布尔值</p></li><li><p>整数</p></li><li><p>浮点数</p></li><li><p>Null</p></li><li><p>时间</p></li><li><p>日期</p></li><li><p>使用一个例子来快速了解纯量的基本使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean: </span><br><span class="line">    - TRUE  #true,True都可以</span><br><span class="line">    - FALSE  #false，False都可以</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    - 6.8523015e+5  #可以使用科学计数法</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    - 0b1010_0111_0100_1010_1110    #二进制表示</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#39;node&#39;</span><br><span class="line">    parent: ~  #使用~表示null</span><br><span class="line">string:</span><br><span class="line">    - 哈哈</span><br><span class="line">    - &#39;Hello world&#39;  #可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - newline</span><br><span class="line">      newline2    #字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">date:</span><br><span class="line">    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">datetime: </span><br><span class="line">    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>引用</strong></p><ul><li><code>&amp;</code>锚点和<code>*</code>别名，可以用来引用:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure></li><li>相当于:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>&amp;</code>用来建立锚点(defaults)，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点</p></blockquote><ul><li><p>下面是另一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &amp;showell Steve </span><br><span class="line">- Clark </span><br><span class="line">- Brian </span><br><span class="line">- Oren </span><br><span class="line">- *showell</span><br></pre></td></tr></table></figure></li><li><p>转为<code>JavaScript</code>代码如下:</p><blockquote><p><code>[ &#39;Steve&#39;, &#39;Clark&#39;, &#39;Brian&#39;, &#39;Oren&#39;, &#39;Steve&#39; ]</code></p></blockquote></li></ul><hr><p><strong>参考资料:</strong></p><p>YMAL官方文档:<a href="https://yaml.org/" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/</code></p><p>YMAL1.2规范文档:<a href="https://yaml.org/spec/1.2/spec.html" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/spec/1.2/spec.html</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 08 2020 17:49:36 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;YAML-基本语法与简述&quot;&gt;&lt;a href=&quot;#YAML-基本语法与简述&quot; class=&quot;headerlink&quot; title=&quot;YAML 基
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker Compose-3</title>
    <link href="https://unit-serow.github.io/2020/02/08/Docker-Compose-3/"/>
    <id>https://unit-serow.github.io/2020/02/08/Docker-Compose-3/</id>
    <published>2020-02-08T08:51:05.000Z</published>
    <updated>2020-02-08T08:59:18.619Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 08 2020 16:59:52 GMT+0800 (中国标准时间) --><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>接<a href="https://unit-serow.github.io/2020/02/08/Docker-Compose-2/">Docker Compose-2</a></li></ul><ol><li><strong>devices</strong></li></ol><ul><li>用于指定设备映射列表</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;&#x2F;dev&#x2F;ttyUSB0:&#x2F;dev&#x2F;ttyUSB0&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li><strong>dns</strong></li></ol><ul><li>用于自定义 DNS 服务器，可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="3"><li><strong>dns_search</strong></li></ol><ul><li>用于自定义 DNS 搜索域</li><li>可以是单个值或列表</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="4"><li><strong>entrypoint</strong></li></ol><ul><li>用于覆盖容器默认的<code>entrypoint</code></li><li>实现语法:<blockquote><p><code>entrypoint: /code/entrypoint.sh</code></p></blockquote></li><li>或以下的列表格式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20100525&#x2F;xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit&#x3D;-1</span><br><span class="line">    - vendor&#x2F;bin&#x2F;phpunit</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="5"><li><strong>env_file</strong></li></ol><ul><li>用于从文件添加环境变量</li><li>可以是单个值或列表的多个值</li><li>实现语法:<blockquote><p><code>env_file: .env</code></p></blockquote></li><li>也可以是列表格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - .&#x2F;common.env</span><br><span class="line">  - .&#x2F;apps&#x2F;web.env</span><br><span class="line">  - &#x2F;opt&#x2F;secrets.env</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="6"><li><strong>environment</strong></li></ol><ul><li>用于添加环境变量</li><li>可以使用数组或字典，任何布尔值，布尔值需要用引号引起来，以确保<code>YML解析器</code>不会将其转换为<code>True</code>或<code>False</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#39;true&#39;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="7"><li><strong>expose</strong></li></ol><ul><li>用于暴露端口，但不映射到宿主机，只被连接的服务访问</li><li>实现语法(仅可以指定内部端口为参数)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="8"><li><strong>extra_hosts</strong></li></ol><ul><li>用于添加主机名映射</li><li>类似<code>docker client --add-host</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure></li><li>以上会在此服务的内部容器中<code>/etc/hosts</code>创建一个具有<code>ip地址</code>和主机名的映射关系:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="9"><li><strong>healthcheck</strong></li></ol><ul><li>用于检测 docker 服务是否健康运行</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="10"><li><strong>image</strong></li></ol><ul><li>用于指定容器运行的镜像</li><li>以下格式都可以:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum&#x2F;influxdb</span><br><span class="line">image: example-registry.com:4000&#x2F;postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="11"><li><strong>logging</strong></li></ol><ul><li><p>服务的日志记录配置</p></li><li><p><code>driver:</code>用于指定服务容器的日志记录驱动程序，默认值为<code>json-file</code></p></li><li><p>可以有以下这三种选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure></li><li><p>仅在<code>json-file</code>驱动程序下，可以使用以下参数，限制日志得数量和大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure></li><li><p>当达到文件限制上限，会自动删除旧得文件</p></li><li><p><code>syslog</code>驱动程序下，可以使用<code>syslog-address</code>指定日志接收地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="12"><li><strong>network_mode</strong></li></ol><ul><li><p>用于设置网络模式</p></li><li><p>实现语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name&#x2F;id]&quot;</span><br></pre></td></tr></table></figure></li><li><p>networks</p><blockquote><p>配置容器连接的网络，引用顶级<code>networks</code>下的条目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure></li><li><p><code>aliases:</code>同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务</p></li></ul><hr><ol start="13"><li><strong>restart</strong></li></ol><ul><li><p>使用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure></li><li><p>参数说明:</p><blockquote><p><code>no</code>:是默认的重启策略，在任何情况下都不会重启容器<br><code>always</code>:容器总是重新启动<br><code>on-failure</code>:在容器非正常退出时(退出状态非0)，才会重启容器<br><code>unless-stopped</code>:在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p></blockquote></li><li><p><code>swarm集群</code>模式下，必须改用<code>restart_policy</code></p></li></ul><hr><ol start="14"><li><strong>secrets</strong></li></ol><ul><li>用于存储敏感数据</li><li>例如密码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: .&#x2F;my_secret.txt</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="15"><li><strong>security_opt</strong></li></ol><ul><li>修改容器默认的<code>schema</code>标签</li><li>使用说明:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="16"><li><strong>stop_grace_period</strong></li></ol><ul><li>指定在容器无法处理<code>SIGTERM</code>(或者任何<code>stop_signal</code>的信号)，等待多久后发送<code>SIGKILL</code>信号关闭容器</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒</span><br></pre></td></tr></table></figure></li><li>默认的等待时间是 10 秒</li></ul><hr><ol start="17"><li><strong>stop_signal</strong></li></ol><ul><li>设置停止容器的替代信号</li><li>默认情况下使用<code>SIGTERM</code></li><li>以下示例，使用<code>SIGUSR1</code>替代信号<code>SIGTERM</code>来停止容器<blockquote><p><code>stop_signal: SIGUSR1</code></p></blockquote></li></ul><hr><ol start="18"><li><strong>sysctls</strong></li></ol><ul><li>设置容器中的内核参数，可以使用数组或字典格式</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn&#x3D;1024</span><br><span class="line">  - net.ipv4.tcp_syncookies&#x3D;0</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="19"><li><strong>tmpfs</strong></li></ol><ul><li>在容器内安装一个临时文件系统</li><li>可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: &#x2F;run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - &#x2F;run</span><br><span class="line">  - &#x2F;tmp</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="20"><li><strong>ulimits</strong></li></ol><ul><li>覆盖容器默认的<code>ulimit</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="21"><li><strong>volumes</strong></li></ol><ul><li>将主机的数据卷或着文件挂载到容器里</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;postgres.sock:&#x2F;var&#x2F;run&#x2F;postgres&#x2F;postgres.sock&quot;</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 08 2020 16:59:52 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Compose内的YML指令参考&quot;&gt;&lt;a href=&quot;#Compose内的YML指令参考&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose-2</title>
    <link href="https://unit-serow.github.io/2020/02/08/Docker-Compose-2/"/>
    <id>https://unit-serow.github.io/2020/02/08/Docker-Compose-2/</id>
    <published>2020-02-08T06:42:09.000Z</published>
    <updated>2020-02-08T06:51:53.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 08 2020 14:51:59 GMT+0800 (中国标准时间) --><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>为了通过使用compose，来让docker自动化配置程序与服务，必须编写YML文件(脚本)</li></ul><ol><li><strong>version</strong></li></ol><ul><li>指定本yml依从于compose哪个版本制定的</li></ul><ol start="2"><li><strong>build</strong></li></ol><ul><li>指定为构建镜像上下文路径</li><li>例如nginx服务，指定为从上下文路径./dir/Dockerfile 所构建的镜像</li><li>参数明细:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">context</td><td align="left">上下文路径</td></tr><tr><td align="left">dockerfile</td><td align="left">指定构建镜像的Dockerfile文件命</td></tr><tr><td align="left">args</td><td align="left">添加构建参数，这是只能在构建过程中访问的环境变量</td></tr><tr><td align="left">labels</td><td align="left">设置构建镜像的标签</td></tr><tr><td align="left">target</td><td align="left">多层构建，可以指定构建哪一层</td></tr></tbody></table><hr><ol start="3"><li><strong>cap_add，cap_drop</strong><br>添加或删除容器拥有的宿主机的内核功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><strong>cgroup_parent</strong></li></ol><ul><li>为容器指定父<code>cgroup</code>组，意味着将继承该组的资源限制<blockquote><p><code>cgroup_parent: m-executor-abcd</code></p></blockquote></li></ul><ol start="5"><li><strong>command</strong></li></ol><ul><li>覆盖容器启动的默认命令<blockquote><p><code>cmmand: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</code></p></blockquote></li></ul><ol start="6"><li><strong>container_name</strong></li></ol><ul><li>指定自定义容器名称，而不是生成的默认名称<blockquote><p><code>container_name: my-web-container</code></p></blockquote></li></ul><hr><ol start="7"><li><strong>depends_on</strong></li></ol><ul><li>设置依赖关系</li></ul><blockquote><p><code>docker-compose up</code>:以依赖性顺序启动服务，在以下示例中，先启动<code>db</code>和<code>redis</code>，才会启动<code>web</code><br><code>docker-compose up SERVICE</code>:自动包含<code>SERVICE</code>的依赖项，在以下示例中，<code>docker-compose up web</code>还将创建并启动<code>db</code>和<code>redis</code><br><code>docker-compose stop</code>:按依赖关系顺序停止服务，在以下示例中，<code>web</code>在<code>db</code>和<code>redis</code>之前停止</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><ul><li>此时的<code>web</code>服务不会等待<code>redis</code>和<code>db</code>完全启动之后才启动</li></ul><hr><ol start="8"><li><strong>deploy</strong></li></ol><ul><li>指定与服务的部署和运行有关的配置</li><li>只在 swarm 模式下才会有用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;xxx&quot;  # 服务版本</span><br><span class="line">services:  # 服务配置</span><br><span class="line">  redis:  # redis服务</span><br><span class="line">    image: redis:alpine  # 指定容器运行的镜像</span><br><span class="line">    deploy:  # 开始定义与该镜像有关的配置</span><br><span class="line">      mode：replicated  # 定义需要使用此参数配置具体运行的节点数量</span><br><span class="line">      replicas: 6  </span><br><span class="line">      endpoint_mode: dnsrr  # 访问集群服务的方式，这里是dns轮询(DNSRR)</span><br><span class="line">      labels:  # 给服务设上标签</span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources: #配置服务器资源使用的限制，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用，从而避免占用资源过高出现异常</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#39;0.50&#39;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &#39;0.25&#39;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:  # 配置如何在退出容器时重新启动容器</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure></li></ul><p><strong>可选参数一览与对上述参数解释:</strong></p><ul><li><code>endpoint_mode</code>:访问集群服务的方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endpoint_mode: vip</span><br><span class="line"># Docker 集群服务一个对外的虚拟ip，所有的请求都会通过这个虚拟ip到达集群服务内部的机器</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"># DNS 轮询(DNSRR)，所有的请求会自动轮询获取到集群ip列表中的一个ip地址</span><br></pre></td></tr></table></figure></li><li><code>labels</code>:在服务上设置标签，可以用容器上的<code>labels</code>(跟<code>deploy</code>同级的配置)覆盖<code>deploy</code>下的<code>labels</code></li><li><code>mode</code>:指定服务提供的模式<blockquote><p><code>replicated</code>:复制服务，复制指定服务到集群的机器上<br><code>global</code>:全局服务，服务将部署至集群的每个节点</p></blockquote></li></ul><p><strong><code>replicated</code>与<code>global</code>的区别</strong></p><ul><li>逻辑简述:</li><li>所有的节点副本都处于本地主机的集群网络内</li><li>当选择<code>replicated</code>时，服务的副本只会被复制到所选节点的机器上</li><li>而选择<code>global</code>时，服务的副本会被复制到节点的每一个机器上，包括控制节点(manager node)</li><li>工作节点(worker node)，控制节点(manager node)</li></ul><hr><ol start="9"><li><strong><code>replicas: mode</code></strong></li></ol><ul><li>当此选项后的参数为<code>replicated</code>时，需要使用此参数配置具体运行的节点数量</li></ul><ol start="10"><li><strong><code>resources:</code></strong></li></ol><ul><li>用于配置服务器资源使用的限制，例如上例子，配置<code>redis</code>集群运行需要的<code>cpu</code>的百分比和内存的占用，避免占用资源过高出现异常</li></ul><hr><ol start="11"><li><strong><code>restart_policy:</code></strong></li></ol><ul><li>用于配置如何在退出容器时重新启动容器</li><li>参数明细<blockquote><p><code>condition</code>:可选<code>none</code>，<code>on-failure</code>或者<code>any</code>(默认值:<code>any</code>)<br><code>delay</code>:设置多久之后重启(默认值:0)<br><code>max_attempts</code>:尝试重新启动容器的次数，超出次数，则不再尝试(默认值:一直重试)<br><code>window</code>:设置容器重启超时时间(默认值:0)</p></blockquote></li></ul><hr><ol start="12"><li><strong><code>rollback_config</code></strong></li></ol><ul><li>用于配置在更新失败的情况下应如何回滚服务</li><li>参数明细:<blockquote><p><code>parallelism</code>:一次要回滚的容器数，如果设置为0，则所有容器将同时回滚<br><code>delay</code>:每个容器组回滚之间等待的时间(默认为0s)<br><code>failure_action</code>:如果回滚失败的处理方法(下一条所描述的内容)，其中一个<code>continue</code>或者<code>pause</code>(默认<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在回滚期间可以容忍的故障率(默认为0)<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认<code>stop-first</code>)</p></blockquote></li></ul><hr><ol start="13"><li><strong><code>update_config</code></strong></li></ol><ul><li><p>用于配置应如何更新服务，对于配置滚动更新很有用</p></li><li><p>参数明细:</p><blockquote><p><code>parallelism</code>:一次更新的容器数<br><code>delay</code>:在更新一组容器之间等待的时间<br><code>failure_action</code>:如果更新失败的解决办法依旧是下一条所描述的内容，其中一个<code>continue</code>，<code>rollback</code>或者<code>pause</code>(默认:<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在更新过程中可以容忍的故障率<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认stop-first)</p></blockquote></li><li><p>有些低版本的服务可能不支持<code>docker compose</code>所提供的服务</p></li><li><p>还有一半，放在下一篇写</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 08 2020 14:51:59 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Compose内的YML指令参考&quot;&gt;&lt;a href=&quot;#Compose内的YML指令参考&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Compose-1</title>
    <link href="https://unit-serow.github.io/2020/02/07/Docker-Compose-1/"/>
    <id>https://unit-serow.github.io/2020/02/07/Docker-Compose-1/</id>
    <published>2020-02-07T08:47:40.000Z</published>
    <updated>2020-02-07T08:48:59.435Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 07 2020 16:49:04 GMT+0800 (中国标准时间) --><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p><strong>概述:</strong></p><ul><li>Compose是用于定义和运行多容器Docker应用程序的工具</li><li>通过Compose，可以使用YML文件来配置应用程序需要的所有服务</li><li>最后通过使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</li><li><a href="https://yaml.org/" target="_blank" rel="noopener">YAML</a>官方文档</li></ul><hr><p><strong>安装 Compose</strong></p><ul><li><p>Github地址:<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/docker/compose/releases</code></p></blockquote></li><li><p>下载源码包(二进制文件)</p></li><li><p>Docker Compose当前的稳定版本：</p><blockquote><p><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>其中的1.25.4为版本号，可用于指定版本</p></li><li><p>提权至可执行文件</p><blockquote><p><code>$ sudo chmod +x /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>设置环境变量的软链接</p><blockquote><p><code>$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></p></blockquote></li><li><p>查看版本，以测试是否安装成功</p><blockquote><p><code>$ docker-compose --version</code></p></blockquote></li><li><p>对于Alpine/Linux发行版，需要安装依赖包:<code>py-pip</code>，<code>python-dev</code>，<code>libffi-dev</code>，<code>openssl-dev</code>，<code>gcc</code>，<code>libc-dev</code>，以及<code>make</code></p></li></ul><hr><p><strong>使用</strong></p><ul><li>对Compose进行使用大概可分为三个步骤:<blockquote><p>使用Dockerfile定义应用程序的环境<br>使用<code>docker-compose.yml</code>文件定义构成应用程序的服务，使其可以在隔离环境中一起运行<br>最后，执行<code>docker-compose up</code>命令来启动并运行整个应用程序</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Feb 07 2020 16:49:04 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Docker-Compose&quot;&gt;&lt;a href=&quot;#Docker-Compose&quot; class=&quot;headerlink&quot; title=&quot;Do
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker Dockefile-1</title>
    <link href="https://unit-serow.github.io/2020/02/07/Docker-Dockefile-1/"/>
    <id>https://unit-serow.github.io/2020/02/07/Docker-Dockefile-1/</id>
    <published>2020-02-07T08:44:44.000Z</published>
    <updated>2020-02-07T08:46:40.721Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Feb 07 2020 16:46:46 GMT+0800 (中国标准时间) --><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><strong>概述:</strong></p><ul><li>Dockerfile是用于构建镜像的文本文件</li><li>文本内容包含构建镜像所需的指令和说明</li></ul><p><strong>关于上下文的概念:</strong></p><ul><li>上下文路径，是指Docker在构建镜像时如果需要使用到本机内的文件(比如复制)，<code>docker build</code>命令得知所指定的路径后，会将该路径下的所有内容打包</li><li>Docker的运行模式是C/S，主机为C，Docker引擎是S</li><li>实际的构建过程是在Docker引擎内完成的，所以此时无法调用到本机内的文件，此时就需要人为的把本机指定目录下的所有文件打包，并提供给Docker引擎进行调用</li><li>如果未说明最后一个参数(未指定上下文所在路径)，那么默认上下文路径就是Dockerfile所在的目录下</li><li>上下文路径下所有的文件都会打包给Docker引擎，如果无用文件过多的话会造成执行过程缓慢</li></ul><hr><p><strong>Dockerfile内的基本指令</strong></p><ol><li><strong>FROM</strong></li></ol><ul><li>定制的镜像都是基于FROM的镜像，在选择完要定义的基础镜像之后，后续的操作都是基于该基础镜像的</li><li>格式:<blockquote><p><code>FROM &lt;所选基础镜像名&gt;</code></p></blockquote></li></ul><hr><ol start="2"><li><strong>RUN</strong></li></ol><ul><li>用于执行后面跟着的命令行命令，有两种格式<blockquote><p>Shell格式: RUN [命令行命令]<br>Exec格式: RUN [“可执行文件”, “参数一”, “参数二”]</p></blockquote></li><li>Dockefile每次执行指令都会在docker上新建一层，多余的层会造成镜像膨胀</li><li>可以用&amp;&amp;符号来连接命令，从而不进行指令的线性执行，目的就是让所有的指令都集成到一层内<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN xxx \</span><br><span class="line">   &amp;&amp; xxx \</span><br><span class="line">   &amp;&amp; xxx</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>CMD</strong></li></ol><ul><li>类似于<code>RUN</code>指令，用于运行程序</li><li>二者的区别在于其运行的时间点不同:<blockquote><p><code>CMD</code>在<code>docker run</code>时运行<br><code>RUN</code>是在<code>docker build</code>时运行</p></blockquote></li><li>作用:<blockquote><p>为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束<br><code>CMD</code>指令指定的程序可被<code>docker run</code>命令行参数中指定要运行的程序所覆盖</p></blockquote></li><li>格式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure><blockquote><p>第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是<code>.sh</code>，所以可以直接使用第二种格式<br><code>最后一种写法是为</code>ENTRYPOINT<code>指令指定的程序提供默认参数</code></p></blockquote></li></ul><ol start="4"><li><strong>ENTRYPOINT</strong></li></ol><ul><li><p>类似于<code>CMD</code>指令，但其不会被<code>docker run</code>的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>但如果运行<code>docker run</code>时使用了<code>--entrypoint</code>选项，此选项的参数可当作要运行的程序覆盖<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>特点就是在执行<code>docker run</code>的时候可以指定<code>ENTRYPOINT</code>运行所需的参数</p></li><li><p>但如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效</p></li><li><p>格式:</p><blockquote><p><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></p></blockquote></li><li><p>还可以搭配<code>CMD</code>命令使用:一般是变参才会使用<code>CMD</code>，这里的<code>CMD</code>等于是在给<code>ENTRYPOINT</code>传参</p></li><li><p>这里假设已有了某镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM 某镜像</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&lt;某镜像&gt;&quot;, &quot;-c&quot;] #定参</span><br><span class="line">CMD [&quot;&lt;&#x2F;执行脚本所在文件目录&gt;&quot;] #变参</span><br></pre></td></tr></table></figure></li><li><p>不传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt;</code></p></blockquote></li><li><p>此时容器内会默认(等于)运行以下命令，启动主进程</p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>容器内会默认(等于)运行以下命令，启动主进程<code>(/执行脚本所在文件目录:假设容器内已有此文件)</code></p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>简述</p><blockquote><p>指定了参数以后可以选择以传参或不传参的模式启动<br>不用传参就是直接启动所键入命令，用传参就是使用已指定的参数</p></blockquote></li></ul><hr><ol start="5"><li><strong>COPY</strong></li></ol><ul><li>用于复制的指令，可以从上下文目录复制文件或者目录到容器内的指定路径</li><li>使用格式:<blockquote><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></blockquote></li><li>参数说明:<blockquote><p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>为可选参数，可以让用户改变复制到容器内文件的拥有者和属组<br><code>&lt;源路径&gt;</code>用于表示源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足Go的<code>filepath.Match</code>规则<br><code>&lt;目标路径&gt;</code>用于在容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p></blockquote></li></ul><ol start="6"><li><strong>ADD</strong></li></ol><ul><li>ADD和COPY的使用格式一致</li><li>同样需求下，官方推荐使用COPY</li><li>ADD的优缺点:<blockquote><p>ADD的优点:在执行<code>&lt;源文件&gt;</code>为<code>tar</code>压缩文件的话，压缩格式为<code>gzip</code>，<code>bzip2</code>以及<code>xz</code>的情况下，会自动复制并解压到<code>&lt;目标路径&gt;</code><br>ADD的缺点:在不解压的前提下，无法复制<code>tar</code>压缩文件，会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</p></blockquote></li><li>具体是否使用，可以根据所处情况是否需要自动解压来决定</li></ul><hr><ol start="7"><li><strong>ENV</strong></li></ol><ul><li><p>用于设置与定义环境变量，定义之后可以直接使用环境变量</p></li><li><p>使用格式:</p><blockquote><p><code>ENV &lt;key&gt; &lt;value&gt;</code><br><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p></blockquote></li><li><p>以下示例设置<code>NODE_VERSION = 7.2.0</code>，在后续的指令中可以直接通过<code>$NODE_VERSION</code>进行引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>ARG</strong></li></ol><ul><li>构建参数，与<code>ENV</code>作用一致，不过作用域不一样，<code>ARG</code>设置的环境变量仅对<code>Dockerfile</code>内有效，也就是说只有<code>docker build</code>的过程中有效，构建好的镜像内不存在此环境变量</li><li>构建命令<code>docker build</code>中可以用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖</li><li>使用格式：<blockquote><p><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p></blockquote></li></ul><hr><ol start="9"><li><strong>VOLUME</strong></li></ol><ul><li>定义匿名数据卷</li><li>在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</li><li>可以避免重要的数据因容器重启而丢失</li><li>还可以避免容器不断变大</li><li>使用格式:<blockquote><p><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code><br><code>VOLUME &lt;路径&gt;</code></p></blockquote></li><li>在启动容器<code>docker run</code>的时候，可以使用参数<code>-v</code>修改挂载点</li></ul><hr><ol start="10"><li><strong>EXPOSE</strong></li></ol><ul><li>用于声明端口</li><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li><li>在运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口</li><li>使用格式:<blockquote><p><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></blockquote></li></ul><hr><ol start="11"><li><strong>WORKDIR</strong></li></ol><ul><li>用于指定工作目录</li><li>用<code>WORKDIR</code>指定的工作目录，会在构建镜像的每一层中都存在(<code>WORKDIR</code>指定的工作目录，必须是提前创建好的)</li><li>在使用<code>docker build</code>构建镜像过程中的，每一个<code>RUN</code>命令都是新建的一层，只有通过<code>WORKDIR</code>创建的目录才会一直存在</li><li>使用格式:<blockquote><p><code>WORKDIR &lt;工作目录路径&gt;</code></p></blockquote></li></ul><ol start="12"><li><strong>USER</strong></li></ol><ul><li>用于指定执行后续命令的用户和用户组，用于切换后续命令执行的用户(用户和用户组必须提前已经存在)</li><li>使用格式:<blockquote><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p></blockquote></li></ul><hr><ol start="13"><li><strong>HEALTHCHECK</strong></li></ol><ul><li>用于指定某个程序或者指令来监控Docker容器服务的运行状态</li><li>使用格式:<blockquote><p><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令<br><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code> : 这个<code>CMD</code>后面跟随的命令使用，可以参考<code>CMD</code>的用法</p></blockquote></li></ul><hr><ol start="14"><li><strong>ONBUILD</strong></li></ol><ul><li>用于延迟构建命令的执行</li><li>简述:<blockquote><p>在<code>Dockerfile</code>里用<code>ONBUILD</code>指定的命令，在本次构建镜像的过程中不会执行(假设镜像为test-build)<br>当有新的<code>Dockerfile</code>使用了之前构建的镜像<code>FROM test-build</code>，这是执行新镜像的<code>Dockerfile</code>构建时候，<code>会执行 test-build</code>的<code>Dockerfile</code>里的<code>ONBUILD</code>指定的命令</p></blockquote></li><li>使用格式:<blockquote><p><code>ONBUILD &lt;其它指令&gt;</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Feb 07 2020 16:46:46 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-4</title>
    <link href="https://unit-serow.github.io/2020/02/06/Docker-4/"/>
    <id>https://unit-serow.github.io/2020/02/06/Docker-4/</id>
    <published>2020-02-06T13:17:20.000Z</published>
    <updated>2020-02-06T13:20:57.282Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 06 2020 21:21:01 GMT+0800 (中国标准时间) --><h3 id="Docker-镜像，网络，连接以及仓库的使用"><a href="#Docker-镜像，网络，连接以及仓库的使用" class="headerlink" title="Docker-镜像，网络，连接以及仓库的使用"></a>Docker-镜像，网络，连接以及仓库的使用</h3><p><strong>Docker 容器镜像的使用</strong></p><ul><li>管理和使用本地的docker镜像</li><li>查看本地主机已有镜像<blockquote><p><code>$ docker images</code></p></blockquote></li><li>各参数说明:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">REPOSITORY</td><td align="left">表示镜像的仓库源</td></tr><tr><td align="left">TAG</td><td align="left">镜像的标签</td></tr><tr><td align="left">IMAGE ID</td><td align="left">镜像ID</td></tr><tr><td align="left">CREATED</td><td align="left">镜像创建时间</td></tr><tr><td align="left">SIZE</td><td align="left">镜像大小</td></tr></tbody></table><ul><li>同一仓库源可以有多个<code>TAG</code>，代表这个仓库源的不同个版本</li><li><code>REPOSITORY:TAG</code>用于定义不同的镜像</li><li>例如使用<code>debian</code>，如果不指定一个镜像的版本标签，Docker 将默认使用<code>debian:latest</code>镜像</li></ul><p><strong>获取镜像</strong></p><ul><li>执行命令拉取10.2.0版本的debian镜像<br><code>$ docker pull debian:10.2.0</code><blockquote><p>获取之后可直接基于此镜像来运行容器<br>还可以从<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>上获取镜像<br><code>https://hub.docker.com/</code></p></blockquote></li></ul><p><strong>搜索镜像</strong></p><ul><li><p>执行命令搜索指定镜像名的镜像</p><blockquote><p><code>$ docker search [镜像名]</code><br>比如搜索一个httpd的镜像来用作web服务<br><code>$ docker search httpd</code></p></blockquote></li><li><p>各参数说明:</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NAME</td><td align="left">镜像仓库源的名称</td></tr><tr><td align="left">DESCRIPTION</td><td align="left">镜像的描述</td></tr><tr><td align="left">OFFICIAL</td><td align="left">是否 docker 官方发布</td></tr><tr><td align="left">stars</td><td align="left">类似 Github 里面的star</td></tr><tr><td align="left">AUTOMATED</td><td align="left">是否支持自动构建</td></tr></tbody></table></li></ul><blockquote><p>然后直接拉取镜像<br><code>$ docker pull httpd</code></p></blockquote><p><strong>删除镜像</strong></p><ul><li>执行以下命令:<blockquote><p><code>$ docker rmi 镜像名</code></p></blockquote></li></ul><hr><p><strong>创建镜像/制作镜像</strong></p><ul><li>当docker的镜像仓库中没有所需求的docker镜像时，可以制作镜像或对镜像进行修改再上传</li></ul><p><strong>更新镜像</strong></p><ul><li>从已经创建的容器中更新镜像，并且提交此镜像<blockquote><p>更新镜像之前，基于所选镜像来创建一个容器<br><code>$ docker run -t -i debian:10.2.0 /bin/bash</code><br>在容器内使用<code>apt-get update</code>命令来进行更新<br>操作完成之后，键入<code>exit</code>退出容器</p></blockquote></li><li>使用<code>docker commit</code>来提交容器副本<br><code>$ docker commit -m=&quot;has update&quot; -a=&quot;name&quot; [Containers ID] /debian:v2</code><blockquote><p><code>参数-m</code>用于指定提交的描述信息<br><code>参数-a</code>用于指定镜像作者<br><code>Containers ID</code>:容器 ID<br><code>debian:v2:</code>指定要创建的目标镜像名</p></blockquote></li><li>最后<code>docker images</code>查看新镜像，并用其启动容器</li></ul><p><strong>构建镜像</strong></p><ul><li>使用命令<code>docker build</code>，创建一个新的镜像</li><li>创建名为<code>Dockerfile</code>的文件，其中包含的指令用来指示Docker如何构建所选镜像</li><li>编写完Dockerfile之后通过docker build命令来构建一个新的镜像<blockquote><p><code>docker build -t [目标镜像名] [指定绝对路径]</code><br><code>参数-t</code>用于指定要创建的目标镜像名<br><code>参数.</code>用于指定Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</p></blockquote></li></ul><p><strong>设置镜像标签</strong></p><ul><li><code>docker tag</code>命令，为镜像添加一个新的标签<blockquote><p><code>docker tag [镜像ID] [用户名称/镜像源名(repository name)]:[新的标签名(tag)]</code></p></blockquote></li></ul><hr><p><strong>Docker 容器连接</strong></p><ul><li>容器中可以运行一些网络应用，从实现而让任意机器可以通过网络端口访问运行在docker容器内部的服务</li><li>要实现让任意机器(内部与外部)可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射</li><li>还可以指定容器绑定的网络地址，比如绑定本地主机的<code>127.0.0.1</code></li></ul><p><strong>网络端口映射的管理</strong></p><blockquote><p><code>docker run -d -P [网络服务名称] [服务的启动脚本]</code></p></blockquote><ul><li>参数说明:</li><li>参数-P用于创建容器，此时该网络服务绑定本地主机的默认端口</li><li>参数-p用于指定容器端口所绑定的主机端口</li><li>具体区别<blockquote><p>参数-P是让容器内部端口随机映射到主机的高端口<br>参数-p是让容器内部端口绑定到指定的主机端口</p></blockquote></li></ul><blockquote><p><code>docker run -d -p [原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote><ul><li>然后执行docker ps 就会发现服务已改变端口映射</li></ul><p><strong>指定容器绑定的网络地址</strong></p><ul><li>这里绑定127.0.0.1:<blockquote><p><code>docker run -d -p [127.0.0.1:原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote></li><li>此时就可以通过绑定的IP地址，来访问容器被指定绑定的接口</li><li>默认都是绑定TCP端口，如果要绑定UDP端口，可以在端口后面加上<code>/udp</code></li><li><code>docker port</code>命令可以让我们快捷地查看端口的绑定情况</li></ul><hr><h3 id="Docker-容器互连"><a href="#Docker-容器互连" class="headerlink" title="Docker 容器互连"></a>Docker 容器互连</h3><ul><li>端口映射不是唯一把Docker连接到另一个容器的方法</li><li>Docker内有一个连接系统允许将多个容器进行连通，以此共享被连接容器的信息</li><li>Docker连接会创建一个子父关系，其中父容器可以看到子容器的信息</li><li>先给容器进行统一的命名，以方便管理<blockquote><p><code>docker run -d -P --name [自定义容器名] [应用程序名称] [程序的启动脚本]</code><br><code>参数--name</code>用于定义容器名</p></blockquote></li></ul><p><strong>创建docker网络</strong></p><blockquote><p><code>docker network create -d bridge [Containers-net]</code><br><code>参数-d</code>用于指定Docker的网络类型，有<code>bridge</code>与<code>overlay</code><br>其中<code>overlay</code>网络类型用于<code>Swarm mode</code></p></blockquote><p><strong>连接容器</strong></p><ul><li>运行一个容器并连接到新建的<code>Containers-net</code>网络<blockquote><p><code>$ docker run -itd --name test1 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>打开新的终端，再运行一个容器并加入到 test-net 网络:<blockquote><p><code>$ docker run -itd --name test2 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>使用test1和test2两个容器互相ping一下以测试是否建立联系，如果没有ping命令就进行安装<blockquote><p><code>apt install iputils-ping</code></p></blockquote></li><li>可以在一个容器里安装好之后把容器包装成镜像，再以新的镜像重新运行以上两个容器</li><li>如果有多个容器之间需要互相连接，可以使用<code>Docker Compose</code></li></ul><p><strong>配置容器DNS</strong></p><ul><li><p><code>/etc/docker/daemon.json</code>文件中增加以下内容来设置全部容器的DNS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;111.111.111.111&quot;,</span><br><span class="line">    &quot;3.3.3.3&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置后，启动容器的DNS会自动配置为<code>111.111.111.111 和 3.3.3.3</code></p></li><li><p>配置完，需要重启Docker服务才能生效</p><blockquote><p><code>/etc/init.d/docker restart</code></p></blockquote></li><li><p>查看容器的DNS是否生效可以使用以下命令，它会输出容器的DNS信息:</p><blockquote><p><code>$ docker run -it --rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>只想在指定的容器设置 DNS，则可以使用以下命令</p><blockquote><p><code>docker run -it --rm host_debian --dns=111.111.111.111 --dns-search=test.com debian</code></p></blockquote></li><li><p>参数说明：</p><blockquote><p>参数<code>-h HOSTNAME</code>或<code>--hostname=HOSTNAME:</code>设定容器的主机名，它会被写到容器内的<code>/etc/hostname</code>和<code>/etc/hosts</code><br>参数<code>--dns=IP_ADDRESS:</code>添加DNS服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在<code>/etc/hosts</code>中的主机名<br>参数<code>--dns-search=DOMAIN:</code>设定容器的搜索域，当设定搜索域为<code>.example.com</code>时，在搜索一个名为<code>host</code>的主机时，DNS不仅搜索<code>host</code>，还会搜索<code>host.example.com</code><br>如果在容器启动时没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></blockquote></li></ul><hr><p><strong>仓库管理</strong></p><ul><li><p>仓库(Repository)用于集中存放镜像</p></li><li><p>目前Docker官方维护了一个公共仓库Docker Hub</p></li><li><p>大部分需求都可以通过在Docker Hub中直接下载镜像来实现</p></li><li><p>网址为<code>https://hub.docker.com</code>，<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p></li><li><p>使用之前需要注册账户</p></li><li><p>登陆Docker hub执行</p><blockquote><p><code>$ docker login</code></p></blockquote></li><li><p>退出 docker hub执行</p><blockquote><p><code>$ docker logout</code></p></blockquote></li><li><p>查找镜像</p><blockquote><p><code>$ docker search [镜像名]</code></p></blockquote></li><li><p>拉取镜像</p><blockquote><p><code>$ docker pull [镜像名]</code></p></blockquote></li></ul><p><strong>推送镜像</strong></p><ul><li>把本地的镜像推送到Docker Hub</li><li><code>username</code>为Docker账号的用户名<blockquote><p><code>$ docker tag [镜像名]:[版本] [username/镜像名:版本]</code><br><code>$ docker image ls</code><br><code>$ docker push [username/镜像名:版本]</code></p></blockquote></li><li>最后查看一下<blockquote><p><code>$ docker search [username/镜像名]</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><p>官方文档:<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 06 2020 21:21:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Docker-镜像，网络，连接以及仓库的使用&quot;&gt;&lt;a href=&quot;#Docker-镜像，网络，连接以及仓库的使用&quot; class=&quot;heade
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Docker-3</title>
    <link href="https://unit-serow.github.io/2020/02/06/Docker-3/"/>
    <id>https://unit-serow.github.io/2020/02/06/Docker-3/</id>
    <published>2020-02-06T10:44:34.000Z</published>
    <updated>2020-02-06T10:54:24.799Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 06 2020 18:54:29 GMT+0800 (中国标准时间) --><h3 id="Docker容器的基本命令与基本应用"><a href="#Docker容器的基本命令与基本应用" class="headerlink" title="Docker容器的基本命令与基本应用"></a>Docker容器的基本命令与基本应用</h3><p><strong>基本操作命令</strong></p><p><strong>拉取镜像</strong><br><code>$ docker pull --help</code><br><code>$ docker pull [OPTIONS] NAME:[:TAG|@DIGEST]</code><br>如果本地没有镜像，用pull从仓库里拉个镜像用<br><code>$ docker pull debian</code></p><p><strong>基于已有镜像启动容器服务</strong><br><code>$ docker run --help</code><br><code>$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><br><code>$ docker run -i -t debian /bin/bash</code></p><ul><li><code>参数-i</code>启动交互式选项，<code>参数-t</code>启动终端选项</li><li><code>debian</code>:也就是debian镜像</li><li><code>/bin/bash</code>:放在镜像后的是被执行指令，这里用<code>/bin/bash</code>来启动交互式<code>Shell</code></li><li>退出当前容器内终端执行<code>exit</code></li></ul><hr><p><strong>查看所有容器</strong><br><code>$ docker ps -a</code></p><ul><li>查询最后一次创建的容器<br><code>$ docker ps -l</code></li></ul><p><strong>启动一个已停止的容器</strong><br><code>$ docker start [容器ID]</code></p><ul><li><code>参数-d</code>用于指定容器的运行模式，加了此参数的程序默认不会进入程序，进入容器需要使用指令<code>docker exec</code></li><li>在后台内利用容器debian运行debian-test程序</li><li><code>$ docker run -i -t -d --name debian-test debian /bin/bash</code></li></ul><p><strong>停止容器</strong><br><code>$ docker stop [容器 ID]</code></p><p><strong>重启容器</strong><br><code>$ docker restart [容器 ID]</code></p><p><strong>进入容器</strong><br><code>$ docker attach/exec --help</code></p><ul><li>在执行<code>参数-d</code>后，容器启动后会进入后台</li><li>此时想要进入容器，可以通过以下指令进入：<blockquote><p>docker attach<br>docker exec(使用docker exec命令时退出容器终端，不会导致容器的停止)<br><code>$ docker attach 容器ID</code>(如果从这个容器退出，会导致容器的停止)<br><code>$ docker exec -i -t 容器ID /bin/bash</code>(从这个容器退出，不会导致容器的停止)</p></blockquote></li></ul><p><strong>导出本地的某个容器</strong><br><code>$ docker export [容器ID] &gt; [生成的文件名(可以是tar或其他压缩文件)]</code></p><blockquote><p>把指定ID的容器快照导入到本地文件，保存地址是现在所处目录</p></blockquote><p><strong>导入容器快照</strong><br><code>$ docker import --help</code><br><code>$ docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></p><blockquote><p>将快照文件<code>debian.tar</code>导入到镜像<code>image-file/debian:v1</code>内<br><code>$ cat docket/debian.tar | docker import - image-test/debian:v1</code><br>还可以通过指定URL或者某个目录来导入<br><code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></p></blockquote><p><strong>删除容器</strong><br><code>$ docker rm -f [容器ID]</code></p><ul><li>清理所有已中止容器<br><code>$ docker container prune</code></li></ul><hr><p><strong>利用docker运行某个应用程序</strong></p><ul><li>拉取某个应用程序<br><code>$ docker pull [应用程序名]</code><br><code>$ docker run -d -P [被拉取的程序名] [运行脚本]</code><blockquote><p><code>参数-d</code>让容器在后台运行<br><code>参数-P</code>将容器内部使用的网络端口映射到我们使用的主机上<br>如果程序占用了某一端口，<code>docker ps</code>的时候会显示占用端口以及映射信息(PORST)</p></blockquote></li><li>通过<code>-p参数</code>来设置不一样的端口<br><code>$ docker run -d -p [原端口:指定端口] [被拉取的程序名] [运行脚本]</code></li></ul><p><strong>查看应用程序或容器使用的端口以及映射情况</strong><br><code>$ docker ps</code><br><code>$ docker port [容器ID/程序名]</code></p><p><strong>查看应用程序日志</strong><br><code>docker logs [容器ID/程序名]</code></p><blockquote><p>用于查看容器内部的标准输出<br><code>参数-f</code>用于让<code>docker logs</code>输出容器内部的标准输出，类似于Linux内的<code>tail -f</code>命令</p></blockquote><p><strong>查看应用程序进程</strong><br><code>$ docker top [容器ID/程序名]</code></p><p><strong>检查应用程序底层信息</strong><br><code>$ docker inspect [容器ID/程序名]</code></p><blockquote><p>会返回一个记录着关于选中应用程序的Docker容器配置和状态信息的文本</p></blockquote><p><strong>停止应用程序所在容器</strong><br><code>$ docker stop [容器ID/程序名]</code></p><p><strong>重启应用程序所在容器</strong><br><code>$ docker start [容器ID/程序名]</code></p><p><strong>移除应用程序所在容器</strong><br><code>$ docker rm [容器ID/程序名]</code></p><blockquote><p>删除容器时，容器必须是停止状态</p></blockquote><hr><p><strong>帮助命令:</strong></p><ul><li>直接执行<code>docker</code>，查看Docker客户端的所有可用指令选项</li><li>docker command –help，查看所选命令的帮助文件</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 06 2020 18:54:29 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Docker容器的基本命令与基本应用&quot;&gt;&lt;a href=&quot;#Docker容器的基本命令与基本应用&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-2</title>
    <link href="https://unit-serow.github.io/2020/02/06/Docker-2/"/>
    <id>https://unit-serow.github.io/2020/02/06/Docker-2/</id>
    <published>2020-02-06T08:40:10.000Z</published>
    <updated>2020-02-06T08:55:30.856Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 06 2020 16:55:35 GMT+0800 (中国标准时间) --><h3 id="Docker-Engine-Community-install"><a href="#Docker-Engine-Community-install" class="headerlink" title="Docker Engine-Community install"></a>Docker Engine-Community install</h3><p><strong>Debian Docker 安装</strong></p><ul><li>Docker Engine-Community 支持版本:<br><code>Buster 10与Stretch 9 (stable) / Raspbian Stretch</code></li><li>Docker Engine-Community 支持架构:<br><code>x86_64(或amd64)armhf，和 arm64</code></li></ul><blockquote><p>选定主机的首次安装需要设置Docker仓库，用以从仓库安装和更新Docker，而Raspbian系统必须使用shell脚本安装</p></blockquote><p><strong>设置仓库</strong></p><p>安装apt依赖包，以通过HTTPS来获取仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">   apt-transport-https \</span><br><span class="line">   ca-certificates \</span><br><span class="line">   curl \</span><br><span class="line">   gnupg2 \</span><br><span class="line">   software-properties-common</span><br></pre></td></tr></table></figure><p><strong>添加Docker的官方GPG密钥</strong><br><code>$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></p><blockquote><p>通过搜索指纹的最后八个字符，验证目前主机是否拥有带指纹的密匙<br>密匙:<code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code><br>执行:<code>$ sudo apt-key fingerprint 0EBFCD88</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub   4096R&#x2F;0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint &#x3D; 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R&#x2F;F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure><p><strong>设置稳定版仓库</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;debian \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure><ul><li><code>lsb_release -cs</code>子命令用于返回Debian发行版的名称</li><li>Docker对未经测试和不受支持的Debian发行版不提供任何保证</li></ul><hr><p><strong>安装 Docker Engine-Community</strong></p><ul><li><p>更新apt包索引<br><code>$ sudo apt-get update</code></p></li><li><p>安装最新版本的 Docker Engine-Community和containerd<br><code>$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></p></li><li><p>安装指定版本的 Docker Engine-Community</p></li><li><p>列出仓库中的可用版本<br><code>apt-cache madison docker-ce</code></p></li><li><p>使用<code>docker-ce |</code>后所输出的字符串安装指定版本，然后执行:<br><code>$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</code></p></li></ul><p><strong>卸载主机上Docker的旧版本</strong></p><ul><li>Docker的旧版本被称为<code>docker</code>，<code>docker.io</code>或<code>docker-engine</code><br><code>$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></li></ul><p><strong>帮助指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker command --help</span><br><span class="line">man docker</span><br></pre></td></tr></table></figure><hr><p><strong>docker 镜像配置</strong></p><ul><li><p>Docker官方提供的中国镜像库:<code>https://registry.docker-cn.com</code></p></li><li><p>以添加Docker官方镜像库地址<code>https://registry.docker-cn.com</code>为例</p></li><li><p>upstart系统<br><code>$ emacs /etc/default/docker</code></p></li><li><p>修改其中<code>DOCKER_OPTS</code>的配置<br><code>DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;</code></p></li><li><p>重启服务<br><code>$ sudo service docker restart</code></p></li><li><p>systemd系统<br><code>emacs /etc/docker/daemon.json</code></p></li><li><p>如果没有就创建，在文件内添加:<br><code>{&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]}</code></p></li><li><p>重启服务<br><code>$ sudo systemctl daemon-reload</code><br><code>$ sudo systemctl restart docker</code></p></li><li><p>检查配置是否生效<br><code>$ docker info</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Registry Mirrors:</span><br><span class="line">   https:&#x2F;&#x2F;registry.docker-cn.com&#x2F;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>参考资料:</strong></p><p>官方手册:<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><p>官方安装手册:<a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/install/linux/docker-ce/debian/</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 06 2020 16:55:35 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Docker-Engine-Community-install&quot;&gt;&lt;a href=&quot;#Docker-Engine-Community-ins
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker-1</title>
    <link href="https://unit-serow.github.io/2020/02/06/Docker-1/"/>
    <id>https://unit-serow.github.io/2020/02/06/Docker-1/</id>
    <published>2020-02-06T06:42:25.000Z</published>
    <updated>2020-02-06T07:52:13.333Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 06 2020 15:52:18 GMT+0800 (中国标准时间) --><h3 id="Docker的基本概述与原理简述"><a href="#Docker的基本概述与原理简述" class="headerlink" title="Docker的基本概述与原理简述"></a>Docker的基本概述与原理简述</h3><p><strong>概述:</strong></p><ul><li>基于google公司退出的Go语言实现</li><li>基于apache2.0协议，项目代码在github上进行维护</li><li>Docker项目的目标是实现轻量级的操作系统虚拟化解决方案</li><li>Docker的基础是linux容器(LXC)等技术，Docker在LXC<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的基础上Docter进行了进一步的封装，让用户不需要去关心容器的管理，从而使其操作更为简便</li></ul><p><strong>docker和传统虚拟化方式的不同之处</strong></p><ul><li>可见容器技术Docker是在操作系统层面上实现虚拟化，直接对本机的操作系统进行复用</li><li>而传统方式则是在硬件层面上实现虚拟化</li><li>引用自官方文档:<blockquote><p>传统的(virtual machines)虚拟化技术不仅需要包含应用程序本身和必要的依赖所需要的存储空间以及容量，还需要承受若干个完整的操作系统所占有的存储空间，这些操作系统所占有的存储空间往往以GB为单位<br>Docker容器引擎只包含了其应用程序以及依赖项，它在主机操作系统的用户空间内作为一个完全被隔离且独立的进程去运行，同时与其他容器共享内核，所以说它不仅拥有VM内资源隔离和分配技术所带来的优点，还拥有更强的可移植性和效率等优势</p></blockquote></li></ul><p><strong>Docker与传统虚拟化方式相比，所拥有的优势</strong></p><ul><li>拥有更快速的交付和部署<br>Docker允许开发者在装有应用和服务本地容器做开发，从而直接集成到可持续开发流程中，以在整个开发周期中都可以完美的辅助开发者实现快速交付</li><li>高效的部署和扩容<br>因docker容器引擎的高可移植性，使其可以在任何软硬件平台上运行<br>这种可兼容的移植性可以让开发者把任何应用程序从一个硬件平台上直接迁移到另外一个硬件平台上<br>Docker的可兼容移植性和轻量特性可以很轻松的实现负载的动态管理，使开发者可以快速扩容或方便的下线某一应用和服务，这种速度将趋近实时</li><li>更高的资源利用率<br>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小<br>以传统虚拟机的方式运行10个不同的应用就要起10个虚拟机，而Docker 只需要启动10个相互隔离的应用即可</li><li>更简单的管理<br>使用 Docker，只需要简易的修改，就可以替代以往大量的更新工作<br>所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理</li></ul><hr><p><strong>Docker引擎简述</strong></p><ul><li>Docker引擎是一个C/S结构的程序</li><li>简要流程:</li><li><code>(contiainer-manages/image-manages/network-manages/network-manages)-&gt;client docker CLI</code></li><li><code>client docker CLI-&gt;REST API-&gt;server doceker deamon</code></li><li>Server是一个常驻进程</li><li>REST API 实现了client和server间的交互协议</li><li>CLI 实现容器和镜像的管理，为用户提供统一的操作界面</li></ul><p><strong>Docker架构简述</strong></p><ul><li>Docker使用C/S架构</li><li>客户端，Docker程序与主机程序镜像由接口通信</li><li>指令由客户端发出，而Docker内部的镜像由主机经由接口提供</li><li>任何指令对镜像的操作都在Docker程序内部的独立化容器服务内完成</li></ul><p><strong>逻辑简述</strong></p><ul><li>最初由client发出管理指令</li><li>经由<code>DOCKER_HOST</code>接口操作docker daemon(程序)内的容器以及程序镜像(包括操作系统)</li><li>docker deamon中已存在其注册表内的程序由<code>DOCKER_HOST</code>接口返回给docker deamon内作为镜像使用</li><li>而程序及系统的镜像再被分布给docker deamon内部的独立容器服务所管理</li><li>简而言之就是命令最后被传输到所指定镜像的容器服务内，进入其容器，对其程序进行操作</li><li>简要流程:</li><li><code>Client(指令)-DOCKER_HOST-&gt;Docker deamon&lt;-DOCKER_HOST-Registry(注册表内已有程序)</code></li><li><code>Docker-&gt;Images(Rigistry)-&gt;Containers</code></li><li><code>从而实现Client-&gt;Containers</code></li></ul><hr><p><strong>关于Docker最基本的核心概念</strong></p><ul><li>镜像(Image)<br>Docker镜像(Image)，镜像其实就是一个只读的模板文件<br>例如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了Apache或用户需要的其它应用程序<br>镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器<br>Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户可以直接从其他人那里下载一个已经做好的镜像来直接使用<br>镜像(Image)就是一堆只读层(read-only layer)的统一视角<br>这些只读层堆叠在一起，除了最下面的只读层，其它的只读层都会由指针指向它所对应的下一层<br>这些层是Docker内部的实现细节，并且能够在docker宿主机统一的的文件系统<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>上访问到</li></ul><p>简要结构流程:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">read-only layer:</span><br><span class="line">Images(union file system):</span><br><span class="line">read-only layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-&gt;...</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read-write layer:</span><br><span class="line">Images(union file system):</span><br><span class="line">bash&#x2F;process-&gt;RW union file system</span><br><span class="line">read-write layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-&gt;...</span><br></pre></td></tr></table></figure><ul><li><p>仓库(repository)<br>仓库(Repository)是集中存放镜像文件的目录<br>仓库和仓库注册服务器(Registry)的区别不大<br>仓库注册服务器上通常存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)<br>仓库分为公开仓库(Public)和私有仓库(Private)两种形式，最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载<br>国内公开的镜像仓库有很多，在我设置的友情连接里有几个我常用的镜像源的地址<br>用户也可以在本地网络内创建一个私有仓库<br>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了<br>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务平台</p></li><li><p>容器(container)<br>Docker 利用容器(Container)来运行应用，容器是从镜像创建的运行实例<br>它可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台<br>容器的定义和镜像近乎相同，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的<br>一个运行态容器被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程<br>所以说一个容器中的进程可以对文件进行修改、删除、创建，这些改变都将作用于可读写层</p></li><li><p>Docker 客户端(Client)<br>Docker 客户端通过命令行或者其他工具与Docker的守护进程通信<br><a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker SDK</a><br><code>https://docs.docker.com/develop/sdk/</code></p></li><li><p>Docker 主机(Host)<br>一个物理或者虚拟的机器用于执行Docker守护进程和容器</p></li></ul><hr><p><strong>参考文献与获取方式</strong></p><p>官网<a href="https://www.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://www.docker.com/</code></p><p>文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><p>docker中国区镜像源<br><code>https://registry.docker-cn.com</code></p><p>获取<a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/get-docker/</code></p><p>获取Docker Engine-Debian<a href="https://hub.docker.com/editions/community/docker-ce-server-debian" target="_blank" rel="noopener">跳转</a><br><code>https://hub.docker.com/editions/community/docker-ce-server-debian</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">LXC，其名称来自Linux软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为Linux内核容器功能的一个用户空间接口，关于LXC更详细的内容这里先不做阐述</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">统一文件系统(Union File System)技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 06 2020 15:52:18 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;Docker的基本概述与原理简述&quot;&gt;&lt;a href=&quot;#Docker的基本概述与原理简述&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="Docker" scheme="https://unit-serow.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>makedown流程图-flowchart</title>
    <link href="https://unit-serow.github.io/2020/02/05/flowchart/"/>
    <id>https://unit-serow.github.io/2020/02/05/flowchart/</id>
    <published>2020-02-05T05:15:51.000Z</published>
    <updated>2020-02-05T05:20:50.890Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Feb 05 2020 13:20:58 GMT+0800 (中国标准时间) --><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p><strong>概述:</strong></p><ul><li>流程图的语法大概可以分为两部分:定义元素与连接元素</li><li>定义变量所使用的语句大概结构是X=Y: Z</li><li>X是变量名，Y是操作模块名，Z是具体显示的文字内容，注意冒号后的空格，有空格的时候才能被识别</li></ul><p><strong>基本语法:</strong><br>由于渲染的问题，这里用&lt;.&gt;代替了&lt;`&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">tag&#x3D;&gt;type: content:&gt;url</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">tag1(...)-&gt;tag2(...)-&gt;tag3(...)</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>括号内语句用逗号分隔</p><p><strong>定义元素语法:</strong></p><ul><li>tag=&gt;type: content:&gt;url</li><li>tag：标签，用于连接元素时使用</li><li>type：该标签的类型，共有6种类型如下</li><li>content：流程语句中放置的内容</li><li>type:与content之间有一个空格</li><li>url：链接，与流程语句绑定</li></ul><p><strong>连接元素语法:</strong></p><ul><li>使用-&gt;符号，-&gt;表示下一步要执行的操作：</li><li>st-&gt;in-&gt;op-&gt;cond</li><li>表示的是先从st转到in，然后再到op，最后到cond</li><li>可以连续写，也可以分开写</li></ul><p><strong>判断分支语法:</strong></p><ul><li>condition 是判断，可以取yes和no两种结果，对于不同结果可以有不同走向</li><li>cond(yes)-&gt;out 表示condition成立时转向out执行</li><li>cond(no)-&gt;op 表示condition不成立时转向op执行</li></ul><p><strong>操作模块说明:</strong><br>操作模块一共有以下六种:</p><table><thead><tr><th align="left">操作模块名</th><th align="left">表示含义说明</th></tr></thead><tbody><tr><td align="left">start</td><td align="left">开始</td></tr><tr><td align="left">end</td><td align="left">结束</td></tr><tr><td align="left">operation</td><td align="left">普通操作块</td></tr><tr><td align="left">subroutine</td><td align="left">子任务块</td></tr><tr><td align="left">condition</td><td align="left">判断块</td></tr><tr><td align="left">inputoutput</td><td align="left">输入输出块</td></tr></tbody></table><hr><p><strong>示例说明-1:</strong><br>竖向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-0" class="flow-chart"></div><hr><p>示例说明-2:<br>横向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-1" class="flow-chart"></div><hr><p>实例说明-3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···flow   </span><br><span class="line">st&#x3D;&gt;start: 开始语句</span><br><span class="line">in&#x3D;&gt;inputoutput: 输入值</span><br><span class="line">e&#x3D;&gt;end: 结束语句</span><br><span class="line">op&#x3D;&gt;operation: 执行操作</span><br><span class="line">cond&#x3D;&gt;condition: 是否成立？</span><br><span class="line">out&#x3D;&gt;inputoutput: 输出值</span><br><span class="line"></span><br><span class="line">st-&gt;in-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;out</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">out-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-2" class="flow-chart"></div><hr><p>示例说明-4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">e&#x3D;&gt;end: Why are you worried?</span><br><span class="line">cond1&#x3D;&gt;condition: Do you have a problem?</span><br><span class="line">cond2&#x3D;&gt;condition: Can you solve it?</span><br><span class="line">op&#x3D;&gt;operation: Since you can&#39;t solve it,</span><br><span class="line"></span><br><span class="line">st-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;cond2</span><br><span class="line">cond1(no)-&gt;e</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no)-&gt;op-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-3" class="flow-chart"></div><hr><p><strong>示例说明-5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start|past:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">e&#x3D;&gt;end: End:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">op1&#x3D;&gt;operation: My Operation|past</span><br><span class="line">op2&#x3D;&gt;operation: Stuff|current</span><br><span class="line">sub1&#x3D;&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?|approved:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">c2&#x3D;&gt;condition: Good idea|rejected</span><br><span class="line">io&#x3D;&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-4" class="flow-chart"></div><hr><p>参考资料:</p><p>参考资料:<a href="http://flowchart.js.org/" target="_blank" rel="noopener">跳转</a><br><code>http://flowchart.js.org/</code></p><p>获取方式:<br><code>npm install --save hexo-filter-flowchart</code></p><p>配置方式：<br>安装完成后进入根目录修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart: </span><br><span class="line">#raphael:#optional, the source url of raphael.js </span><br><span class="line">#flowchart:#optional, the source url of flowchart.js</span><br><span class="line">options:#options used for &#96;drawSVG&#96;</span><br></pre></td></tr></table></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st->op->condcond(yes)->io->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script><textarea id="flowchart-1-code" style="display:none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st(right)->op(right)->condcond(yes)->io(bottom)->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-1-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-1",options)</script><textarea id="flowchart-2-code" style="display:none">st=>start: 开始语句in=>inputoutput: 输入值e=>end: 结束语句op=>operation: 执行操作cond=>condition: 是否成立？out=>inputoutput: 输出值st->in->op->condcond(yes)->outcond(no)->opout->e</textarea><textarea id="flowchart-2-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-2-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-2",options)</script><textarea id="flowchart-3-code" style="display:none">st=>start: Starte=>end: Why are you worried?cond1=>condition: Do you have a problem?cond2=>condition: Can you solve it?op=>operation: Since you can't solve it,st->cond1cond1(yes)->cond2cond1(no)->econd2(yes)->econd2(no)->op->e</textarea><textarea id="flowchart-3-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-3-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-3",options)</script><textarea id="flowchart-4-code" style="display:none">st=>start: Start|past:>http://www.baidu.come=>end: End:>http://www.baidu.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yes or No?|approved:>http://www.baidu.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e</textarea><textarea id="flowchart-4-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-4-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-4",options)</script><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Feb 05 2020 13:20:58 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;语法结构&quot;&gt;&lt;a href=&quot;#语法结构&quot; class=&quot;headerlink&quot; title=&quot;语法结构&quot;&gt;&lt;/a&gt;语法结构&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="杂项" scheme="https://unit-serow.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>分布式版本控制系统-Git-2</title>
    <link href="https://unit-serow.github.io/2020/02/04/Git-3/"/>
    <id>https://unit-serow.github.io/2020/02/04/Git-3/</id>
    <published>2020-02-04T06:13:34.000Z</published>
    <updated>2020-02-04T06:16:56.277Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第二章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第二章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第二章节"></a>分布式版本控制系统(Distributed Version Control) Git-第二章节</h3><p><strong>基本操作</strong></p><ul><li>上篇文章的末尾写了一点关于git创建新仓库和克隆项目的基本操作</li><li>这一章着重对暂存区内快照的管理与操作和分支的管理与操作进行说明</li><li>在<code>git init</code>后，在工作区的根目录会生成<code>.git</code>子目录，它就是本地主机的Git仓库，所有关于工作区项目的快照数据都存放在此目录下</li><li>Git主要工作就是创建和保存工作区中项目的快照及与其他时间段的快照进行对比</li></ul><ol><li><p><code>git add</code><br>用于将工作区修改或进行操作的任何文件添加到缓存目录，也就是暂存区<br><code>git add .</code><br>添加当前项目的所有文件</p></li><li><p><code>git status</code><br>用于查看工作区当前的状态，执行完<code>git status</code>就能看到工作区向暂存区进行的任何操作<br>可以添加参数，比如添加<code>-s参数</code>，以输出经过简化的结果<br><code>A/M filename</code>的意思是这个文件在添加到暂存区之后又有改动了</p></li><li><p><code>git diff</code><br>用以查看执行git status 输出结果的详细信息<br>参数信息</p></li></ol><ul><li><code>git diff</code>命令会输出暂存区以修改但尚未写入暂存区的改动的区别</li><li><code>git diff</code>尚未写入暂存区的改动</li><li><code>git diff --cached</code>查看已写如暂存区的改动</li><li><code>git diff HEAD</code>查看已写入暂存区的与未写入暂存区的所有改动</li><li><code>git diff --stat</code>输出简明的diff结果</li></ul><ol start="4"><li><p><code>git commit</code><br>将暂存区的内容添加到仓库中<br>因为每一次提交都要输入一次github的用户名和邮箱地址，所以可以先配置一下用户名和邮箱地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#39;用户名&#39;</span><br><span class="line">git config --global user.email 邮箱地址</span><br></pre></td></tr></table></figure><p><code>参数-m</code>在命令行中提供提交注释，如果没有此参数，Git就会自动打开一个编辑器以填写提交信息<br><code>参数-a</code>可以跳过<code>git add</code>提交至暂存区</p></li><li><p><code>git reset HEAD filename</code><br><code>filename</code>是指已提交到暂存区的内容<br>用于取消已缓存的内容<br>执行<code>git reset HEAD</code>以取消之前的<code>git add</code>，并且不包含下一个提交完成后的暂存区快照</p></li><li><p><code>git rm</code><br>从工作区删除某个文件，需要从已跟踪文件的清单中移除，然后再去提交<br><code>git rm filename</code><br>如果该文件修改过并且已经提交到暂存区而还要删除的话，必须使用强制删除<code>参数-f</code><br><code>git rm -f filename</code><br>把文件从暂存区删除，或者说是从跟踪清单中删除，使用<code>--cached</code>参数<br><code>git rm --cached filename</code><br>使用<code>-r</code>参数用以递归删除，删除该目录下的所有文件和子目录<br><code>git rm -r</code>文件目录</p></li><li><p><code>git mv</code><br>用于移动或重命名一个文件夹，目录或软链接<br><code>git mv filename newfilename</code></p></li><li><p><code>git push</code><br>用于将本地工作区的最新消息推送到远端仓库</p></li><li><p><code>git pull</code><br>用于从远端仓库拉取最新的版本到本地工作区，并且自动与工作区内部的项目与数据自动合并(merge)</p></li><li><p><code>git fetch</code><br>用于是从远端仓库拉取最新版本到本地工作区，并且不会自动合并</p></li><li><p><code>git merge</code><br>用于从指定的分支合并到当前的分支，从而合并两个分支<br><code>git pull</code>相当于<code>git fetch + git merge</code></p></li></ol><hr><p><strong>Git查看提交日志</strong><br>12. <code>git log</code></p><ul><li><code>参数--oneline</code>查看简明版本</li><li><code>参数--graph</code>查看分支，合并等操作的日志，并显示拓扑图</li><li><code>参数--reverse</code>逆向输入所有日志</li><li><code>参数--author=用户名</code>查看指定用户的提交日志</li><li><code>参数--since，--before，--after，--until</code>查看指定日期<br>日志命令参考<a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/docs/git-log</code></li></ul><ol start="13"><li>git 标签<br><code>git tag -a 标签名</code><br>用于给当前快照打上标签</li></ol><hr><p><strong>使用Git连接远端的Github仓库</strong></p><p>添加一个新的远程仓库<br>14. <code>git remote add shortname url</code></p><p>查看当前的远程库<br>15. <code>git remote</code></p><p>拉取远程库<br>从远程仓库克隆新分支与数据<br>16. <code>git fetch alias</code><br>然后执行git merge 将远程分支到本地工作区所在的分支<br>17. <code>git merge alias/branch</code><br>从远端仓库提取更新数据并尝试合并到当前分支<br>一般执行完<code>git fetch</code>之后就会紧接着执行<code>git merge</code>，前者去对数据进行过滤，获取当前工作区没有的新数据，后者用于将新数据合并到本地工作区当前分支的项目</p><p>推送到远程仓库<br>18. <code>git push alias branch</code><br>将本地(branch)分支中的暂存区文件推到(alias)远端仓库上的(branch)分支<br>用于将本地暂存区的新数据推到某个远端仓库</p><p>删除远端仓库<br>19. <code>git remote rm [别名]</code></p><p><strong>生成ssh key</strong><br>20. * <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><ul><li>会在<code>/root/.ssh</code>目录生成密匙文件，打开<code>id_rsa.pub</code>，复制里面的key</li><li>然后进入Github并登入Github，点击头像内的<code>setting</code>选项卡内的<code>SSH and GPG keys</code>中的<code>SSH Keys</code>选项卡</li><li>将文件里的key拷贝到key中，title随意，然后<code>add ssh key</code></li><li>验证是否成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi Unit-serow! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>具体可以参考一下<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="noopener">跳转</a><br><code>https://help.github.com/articles/generating-ssh-keys</code></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;分布式版本控制系统-Distributed-Version-Control-Git-第二章节&quot;&gt;&lt;a href=&quot;#分布式版本控制系统-Di
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Git" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Git/"/>
    
    
      <category term="2.应用与拓展" scheme="https://unit-serow.github.io/tags/2-%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8B%93%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式版本控制系统-Git-1</title>
    <link href="https://unit-serow.github.io/2020/02/04/Git-2/"/>
    <id>https://unit-serow.github.io/2020/02/04/Git-2/</id>
    <published>2020-02-04T06:11:42.000Z</published>
    <updated>2020-02-04T06:15:23.087Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第一章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第一章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第一章节"></a>分布式版本控制系统(Distributed Version Control) Git-第一章节</h3><p><strong>概述:</strong></p><ul><li>Git 是一个开源的分布式版本控制系统，用于帮助以群为单位的开发者们处理任何相同类型的项目(或称为同一项目)</li><li>Git 还可以指 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</li><li>Git 的性质使他不仅用于版本控制，还可用于内容管理 CMS 与工作管理等</li></ul><p><strong>关于 Git 的分布式</strong></p><ul><li>Git把内容按元数据的方式去存储，分布式的版本控制就是每个人都可以创建一个独立的代码仓库用于管理，各种版本的操作都可以再本地完成，每个人修改的代码都可以经过推送合并到另外一个代码仓库中，所以Git这种分布式的版本控制系统更适合个人的开发</li><li>因为分散式版本控制系统本质的关系，使得此类系统更重视对分支(branch)的支持，它们通常有较好的分支及合并的能力</li><li>在分散式版本控制系统中，开发者可以进行推(push)的动作，其意义是将自身档案库中的变更送至其他的档案库，也可以进行拉(pull)的动作，其意义是获取其他档案库的变更</li><li>处于分布式版本控制系统中的每个个体之间的关系是完全独立且自由的，他们完全自由并且完全可以参照自己的意愿来对远端的代码仓库进行实时的操作</li><li>学习Git时最重要的是对其分支管理系统的了解，这是它的本质与执行的逻辑核心</li></ul><p><strong>使用Git进行工作的通常流程</strong></p><ul><li>从远端仓库克隆代码到本地并作为工作目录</li><li>对克隆的资源进行操作</li><li>如果有人已经对其修改了，可以在本地更新资源</li><li>在提交前查看修改内容并提交修改内容</li><li>在修改完成后，如果发现错误，可以撤回并再次修改并提交</li></ul><hr><p><strong>最基本的使用</strong></p><p><code>git init</code><br>使用git init 创建或初始化一个仓库，通常是使用git的第一个命令<br>在执行完成git init命令后，git仓库会生成一个.git目录，该目录包含了所有资源的元数据，而其它项目的目录保持不变</p><p><code>git clone</code><br>从指定以存在的Git远端仓库中克隆项目<br><code>git clone repo(Git 仓库名)</code><br>还可以指定克隆的目录<br><code>git clone repo directory(本地目录)</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;分布式版本控制系统-Distributed-Version-Control-Git-第一章节&quot;&gt;&lt;a href=&quot;#分布式版本控制系统-Di
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Git" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Git/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客文件远端备份与恢复</title>
    <link href="https://unit-serow.github.io/2020/02/03/hexo%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    <id>https://unit-serow.github.io/2020/02/03/hexo%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</id>
    <published>2020-02-03T12:47:37.000Z</published>
    <updated>2020-02-06T11:05:19.072Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 06 2020 19:05:26 GMT+0800 (中国标准时间) --><h3 id="hexo博客文件远端备份与恢复"><a href="#hexo博客文件远端备份与恢复" class="headerlink" title="hexo博客文件远端备份与恢复"></a>hexo博客文件远端备份与恢复</h3><ul><li>其实就是将本地工作区的数据上传到远端仓库</li><li>因为再创建一个代码仓库有点浪费，所以用再原仓库内建立新分支的方法去备份博客</li><li>在创建新分支之前先确保博客内有默认主分支master</li></ul><p><strong>按顺序执行以下指令:</strong></p><ul><li><code>git init //创建一个新的Git仓库或初始化一个现有的仓库</code><br>该命令创建一个空的Git版本库和暂存区，基本上具有对象库，指针(HEAD)库和模板文件等等的隐藏目录.git<br>现有存储库中运行git init命令是安全的，所以不会覆盖已经存在的数据</li><li><code>git add .</code><br>将本地文件依次添加到暂存区</li><li><code>git commit -m &#39;hexo&#39;(需要进行备份的文件名，比如说hexo的根目录)</code><br>将文件数据提交至本地暂存区文件内，然后再将暂存区的改动提交到本地的版本库</li><li><code>git branch hexo</code><br>创建一个名为hexo的新分支</li><li><code>git checkout hexo</code><br>切换到hexo分支上</li><li><code>git remote add origin Github仓库地址</code><br>让仓库地址/URL实现本地与远程Github仓库的对接</li><li><code>git push origin hexo(推送文件目录)</code><br>推送本地工作区(仓库)内容到远程仓库的hexo分支，远程仓库的默认命名是origin</li></ul><p>创建新的仓库时会默认建立.gitignore文件，用于将不需要备份的文件屏蔽</p><p>以后备份的时候只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Backname&quot;</span><br><span class="line">git push origin hexo</span><br><span class="line">hexo g与hexo d</span><br></pre></td></tr></table></figure><hr><p><strong>恢复博客</strong></p><p>在本地机器上克隆博客文件的hexo分支<br><code>git clone https://github.com/yourgithubname/yourgithubname.github.io</code></p><p>分别执行以恢复博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><hr><p><strong>其他指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;分支名称 &#x2F;&#x2F;在所选仓库内设置默认分支</span><br><span class="line">git remote &#x2F;&#x2F;查看所有远程仓库</span><br><span class="line">gir remote rm origin &#x2F;&#x2F;删除所关联的远程仓库地址</span><br><span class="line">git remote add origin 新仓库地址 &#x2F;&#x2F;添加新仓库地址</span><br><span class="line">git push orign master &#x2F;&#x2F;提交到新仓库中的默认分支</span><br><span class="line">git submodule init &#x2F;&#x2F;初始化本地配置文件</span><br><span class="line">git submodule update &#x2F;&#x2F;抓取所有数据并检出项目中列出的合适的提交</span><br><span class="line">git rm --cached file &#x2F;&#x2F;从暂存区删除文件，工作区不做出改变</span><br><span class="line">git checkout . &#x2F;&#x2F;重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件</span><br><span class="line">git pull 参数[options]  仓库名[repository]  分支名[refspec...] &#x2F;&#x2F;从一个仓库或者本地的分支拉取并合并代码，相当于 git fetch 跟着一个 git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 06 2020 19:05:26 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;hexo博客文件远端备份与恢复&quot;&gt;&lt;a href=&quot;#hexo博客文件远端备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Git" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Git/"/>
    
    
      <category term="hexo" scheme="https://unit-serow.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>版本控制系统 Git-分支</title>
    <link href="https://unit-serow.github.io/2020/02/03/Git-1/"/>
    <id>https://unit-serow.github.io/2020/02/03/Git-1/</id>
    <published>2020-02-03T10:51:45.000Z</published>
    <updated>2020-02-06T10:58:31.195Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Feb 06 2020 18:58:36 GMT+0800 (中国标准时间) --><h2 id="Git-版本控制系统"><a href="#Git-版本控制系统" class="headerlink" title="Git 版本控制系统"></a>Git 版本控制系统</h2><h3 id="远端分支的上传与本地分支的处理的执行逻辑与原理"><a href="#远端分支的上传与本地分支的处理的执行逻辑与原理" class="headerlink" title="远端分支的上传与本地分支的处理的执行逻辑与原理"></a>远端分支的上传与本地分支的处理的执行逻辑与原理</h3><p><strong>远端分支</strong></p><ul><li>在本地进行任何连接Git远端服务器或远端服务器分支的操作时，远端服务器内会创建一个默认分支，之后在本地会生成一个对应该默认分支的分支</li><li>下文描述说明:服务器的分支被称为<code>origin/master</code>，而本地的分支被称为<code>master</code></li></ul><p><strong>执行原理:</strong></p><ul><li>在本地执行<code>git clone</code>命令克隆远端数据之后，git的clone会自动将所连接远端服务器命名为origin(执行该命令就是克隆URL所指定服务器内的所有数据)</li><li>同时在远端origin服务器内创建了指向它默认主分支(master)的指针，并在远端的服务器内为分支命名为<code>origin/master</code>(默认仓库名与此仓库内的默认分支名)</li><li>然后远端的git服务器也会给本地主机添加本地的master指针，该指针与远端服务器origin的master分支指向同的目标</li><li>从而从本地就可以操作远程服务器origin的分支了(origin的任何分支-这里指master分支)，进而实现数据推送</li></ul><p><strong>逻辑关系的链接表示:</strong></p><blockquote><p>-表示线性执行的逻辑关系<br>本地主机-远程仓库-远程仓库内的若干个分支(分支也可以拥有分支)<br>默认远程仓库被命名为origin，而其下默认分支被默认命名为master<br>一般情况下，远程仓库内拥有最少一个默认分支，并将其默认定义为主分支，对主分支的定义可以进行改动</p></blockquote><hr><p><strong>本地分支</strong></p><p><strong>工作区，暂存区与版本库的概念与其中的关系介绍:</strong></p><ul><li>工作区就是本地主机的文件文件目录</li><li>暂存区(stage或index)，一般存放在隐藏目录.git下的<code>index</code>文件中,暂存区也可以被叫做索引(index)</li><li>版本库 工作区内的隐藏目录<code>.git</code>就被称之为版本库，其中包含了暂存区文件，对象库，游标(HEAD)文件与本地分支等等</li><li>正常情况下的操作都是由工作区发出命令然后传于版本库内进行各级执行</li></ul><p><strong>逻辑关系表示:</strong></p><blockquote><p>工作区-[版本库-(暂存区-本地分支/对象库)]-远端服务器<br>这里的-用于表示包含，链接与单向执行逻辑</p></blockquote><p><strong>逻辑关系:</strong></p><ul><li>当工作区内修改或新增文件之后执行git add 命令之后，暂存区的目录会被更新</li><li>同时工作区修改或新增文件的内容也被写入对象库中的一个新的对象库中，而该对象的ID也被记录在暂存区的文件索引中</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库中的对象库中</li><li>之后默认分支master或设置的本地分支经由游标(HEAD)的指向会对所选分支作出相应的更新</li><li>默认分支master或设置的本地分支指向的目录树就是提交至远端时暂存区的目录树</li><li>进而推送暂存区的目录树(也就是本地存储于所选分支内暂存区的所有数据)至远端</li></ul><p><strong>命令原理与版本库内目录简要介绍:</strong></p><ul><li><p>执行<code>git reset HEAD(游标名)</code>命令时，更新暂存区操作，暂存区的目录会被重写，而被master分支的游标所指向的目录树所交换，工作区不受影响</p></li><li><p>执行<code>git rm --cached filename</code>命令时 ，从暂存区删除文件，而工作区不做出改变</p></li><li><p>执行<code>git checkout .</code>命令时重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件，会清除工作区中未添加到暂存区的改动</p></li><li><p>执行<code>git checkout HEAD .</code>或<code>git checkout HEAD filename</code>命令时，会用游标(HEAD)指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件，不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动</p></li><li><p>执行<code>git fetch origin</code>命令用于同步数据，原理就是从中抓取本地没有的数据并且更新本地数据，同时游标(HEAD)也会更新</p></li><li><p>对象库位于<code>.git/objects</code>目录下，里面包含了创建的各种对象及内容</p></li><li><p>暂存库位于<code>.git/index</code>目录下</p></li><li><p>游标位于<code>.git/HEAD</code>目录下</p></li></ul><p>本文所描述的游标，也可以称之为指针，用指针去理解会更简单</p><h2 id="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"><a href="#论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考" class="headerlink" title="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"></a>论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考</h2><p>参考文案:</p><p>Git官网:<a href="https://git-scm.com/" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/</code></p><p>CN-Git 分支简介:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B</code></p><p>CN-Git 分支使用:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Feb 06 2020 18:58:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Git-版本控制系统&quot;&gt;&lt;a href=&quot;#Git-版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;Git 版本控制系统
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Git" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Git/"/>
    
    
      <category term="Git" scheme="https://unit-serow.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>GNU Binary File Descriptor/BFD</title>
    <link href="https://unit-serow.github.io/2020/02/02/BFD/"/>
    <id>https://unit-serow.github.io/2020/02/02/BFD/</id>
    <published>2020-02-02T13:33:28.000Z</published>
    <updated>2020-02-02T13:40:59.170Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Binary-File-Descriptor"><a href="#GNU-Binary-File-Descriptor" class="headerlink" title="GNU Binary File Descriptor"></a>GNU Binary File Descriptor</h3><p><strong>GNU 二进制文件描述 BFD</strong></p><p><strong>概述:</strong></p><ul><li>目的是用于解决GNU项目中不同的目标文件的可移植性的主要机制</li><li>在GNU项目中对于不同目标文件可移植EFL<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>性问题的主要解决机制</li><li>BFD库还可以用来读取核心转储的结构化数据</li><li>截至至2003年，它支持25中不同体系结构的CPU上的大约50中文件格式</li></ul><p><strong>BFD的设计逻辑与执行逻辑:</strong></p><ul><li>BFD通过对目标文件<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>提供抽象视图来达成工作</li><li>BFD在内部将数据从抽象视图转到目标处理器所规定的文件格式所要求的节与数据结构/字节布局等细节</li><li>它关键的作用是处理字节序的差异<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>,包括寻址<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>算术等细节</li><li>BFD最初的设计目的是可以成为被各种工具所使用的通用库，但为了达成这一目的就需要频繁修补API来解决系统所带来的影响与容纳新系统的功能，从而限制了它的使用模式与功能</li><li>DFD的主要用户是<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GAS</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GDL</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GNU Binutils</a>和<a href="https://unit-serow.github.io/2020/02/01/Debugger/">GDB</a>，因此BFD不单独发行，所以它通常包括在Binutils和GDB的发行之中</li></ul><hr><p><strong>参考资料:</strong></p><p>参考网站-BFD的历史与故事<a href="https://www.oreilly.com/openbook/opensources/book/tiemans.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.oreilly.com/openbook/opensources/book/tiemans.html</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">ELF-可执行与可链接格式，Executable and Linkable Format简称为ELF ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">目标文件的结构:有一个有描述信息的“头”，可变量目的“段”，每个段都有一个名字，一些属性和一块数据，一个符号表，一组重定位入口顶等等</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display:inline-block;vertical-align:top;padding-right:10px">3.</span><span style="display:inline-block;vertical-align:top">比如在小端序主机和大端序目标之间，在32-bit和64-bit数据之间的正确转换和重定位入口项所指定的寻址算术的细节</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display:inline-block;vertical-align:top;padding-right:10px">4.</span><span style="display:inline-block;vertical-align:top">寻址是每种计算机中央处理器的指令集架构中的一部分，各个指令集下有不同的寻址模式，寻址模式决定了此架构下计算机语言指令所对应的运算数</span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Binary-File-Descriptor&quot;&gt;&lt;a href=&quot;#GNU-Binary-File-Descriptor&quot; clas
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU AutoGen</title>
    <link href="https://unit-serow.github.io/2020/02/02/AutoGen/"/>
    <id>https://unit-serow.github.io/2020/02/02/AutoGen/</id>
    <published>2020-02-02T09:10:25.000Z</published>
    <updated>2020-02-02T09:37:35.267Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-AutoGen"><a href="#GNU-AutoGen" class="headerlink" title="GNU AutoGen"></a>GNU AutoGen</h3><p><strong>GNU 代码维护工具</strong></p><p><strong>概述:</strong></p><ul><li>AutoGen用于简化包含大量重复文本，指令集与宏定义的程序的创建和维护，所以在必须完全保持多个文本块同步的程序中，它能发挥很大的作用</li><li>除了CGL数据与已有的AutoGen定义之外，AutoGen还可以自定义格式或将XML文件作为输入定义</li><li>它经常被用于创建和维护处理程序选项所需的代码，处理选项需要在程序之间的不同位置同时维护多个构造，所以对于选件的维护是没有尽头的</li><li>因此，autogen带有一个名为autoopts的附加软件包，它用于简化程序选项的维护和文档编制</li><li>已知autogen可在GNU/Linux，BSD，OS/X，等其他操作系统上工作</li><li>它的最终目的是在任何具有ANSI C编译器的现代UNIX系统上运行</li></ul><hr><p><strong>参考资料:</strong></p><p>源码获取:<a href="http://autogen.sourceforge.net/data/" target="_blank" rel="noopener">跳转</a><br><code>http://autogen.sourceforge.net/data/</code></p><p>手册<a href="https://www.gnu.org/software/autogen/manual/html_node/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/manual/html_node/autogen.html</code></p><p>快捷参考<a href="https://www.gnu.org/software/autogen/man1-autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/man1-autogen.html</code></p><p>autogen官网<a href="https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html</code></p><p>开发者社区<a href="http://savannah.gnu.org/projects/autogen" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/projects/autogen</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-AutoGen&quot;&gt;&lt;a href=&quot;#GNU-AutoGen&quot; class=&quot;headerlink&quot; title=&quot;GNU Auto
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Data Display Debugger</title>
    <link href="https://unit-serow.github.io/2020/02/02/DDD/"/>
    <id>https://unit-serow.github.io/2020/02/02/DDD/</id>
    <published>2020-02-02T08:25:37.000Z</published>
    <updated>2020-02-02T10:07:38.843Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Data-Display-Debugger"><a href="#GNU-Data-Display-Debugger" class="headerlink" title="GNU Data Display Debugger"></a>GNU Data Display Debugger</h3><p><strong>GNU 调试器前端 DDD</strong></p><p><strong>概述:</strong></p><p>DDD:</p><ul><li>DDD基于GPL许可证发行</li><li>DDD是GNU计划的一个重要的组成部分</li><li>DDD主要用于Unix系统,并且有许多开源插件对其使用性的补充</li><li>GNU DDD是一个用于数据显示的调试器前端(Debugger front-end)，它使用motif工具包实现GUI</li><li>应用于诸如GDB,DBX,JDB,XDB,多种语言调试器和bash等命令行调试器的调试器前端，也包括GNU Make调试器等用于调试器的调试器前端</li><li>DDD拥有GUI前端的功能，可以查看源文本及其交互式图形数据的显示，将数据结构以图形化显示</li></ul><p>GCL:</p><ul><li>调试器前端就是所指调试器所使用的命令行解释器/命令行界面(CLI)，这里所指的调试器前端就是DDD</li><li>一个好的CLI可以最大程度的提高可移植性并最大程度地减少资源消耗</li><li>而最让开发者们青睐的还得是具备GUI的CLI，所以有一些GUI调试器的前端被设计成与各种GLI相兼容，还有一些GUI则针对某一个特定的GLI</li></ul><hr><p><strong>参考资料:</strong></p><p>文档<a href="https://www.gnu.org/software/ddd/manual/html_mono/ddd.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/manual/html_mono/ddd.html</code></p><p>官网<a href="https://www.gnu.org/software/ddd/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/</code></p><p>社区<a href="http://savannah.gnu.org/svn/?group=ddd" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/svn/?group=ddd</code></p><p><a href="https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html" target="_blank" rel="noopener">参考资料:</a><br><code>https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Data-Display-Debugger&quot;&gt;&lt;a href=&quot;#GNU-Data-Display-Debugger&quot; class=
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
</feed>
