<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据类型-9.1</title>
    <url>/2020/03/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-9-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 21:18:32 GMT+0800 (中国标准时间) --><center><strong>数据类型-函数-1</strong></center><a id="more"></a><h3 id="数据类型-9-1"><a href="#数据类型-9-1" class="headerlink" title="数据类型-9.1"></a>数据类型-9.1</h3><ul><li>函数-基本概念</li></ul><hr><h3 id="函数-基本概念"><a href="#函数-基本概念" class="headerlink" title="函数-基本概念"></a>函数-基本概念</h3><p><strong>涉及概念:</strong></p><ul><li>return关键字</li><li>一元运算符</li><li>方法的类型，定义，参数，及其返回值</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>函数参数内对指针类型变量的调用</li><li>ANSI C 原型</li><li>递归</li></ul><hr><p><strong>结构化组织程序:</strong></p><ul><li>C 的设计思想<blockquote><p>在 C 内，函数用作构件块，而所谓的程序即为由代码块拼接而成<br>至今为止所涉及的C 标准库的函数有如: printf()，scanf()，getchar()，putchar()和strlen()<br>C 内还允许创建函数</p></blockquote></li></ul><hr><p><strong>关于函数:</strong></p><ul><li><p>函数(function)是完成特定任务的独立程序代码单元</p><blockquote><p>语法规则定义了函数的结构和使用方式<br>虽然C中的函数和其他语言中的函数，子程序，过程作用相同，但是细节上略有不同<br>一些函数执行某些动作，如printf()把数据打印到屏幕上<br>一些函数找出一个值供程序使用， 如strlen()把指定字符串的长度返回给程序<br>一般而言，函数可以同时具备以上两种功能</p></blockquote></li><li><p>关于使用函数:</p><blockquote><p>使用函数可以省去编写重复代码的苦差<br>如果程序要多次完成某项任务，那么只需编写一个合适的函数<br>就可以在需要时使用这个函数，或者在不同的程序中使用该函数<br>就像许多程序中使用putchar()一样<br>其次，即使程序只完成某项任务一次，也值得使用函数<br>因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改并完善</p></blockquote></li><li><p>这里假设已经定义了若干个函数声明，并于主函数mian()内进行了符合逻辑的功能性调用</p><blockquote><p>接下来要做事就是将这若干个函数声明进行定义补充，还称其为为其进行细节描述<br>描述性的函数名能清楚地表达函数的用途和组织结构<br>然后，单独设计和测试每个函数，直到函数都能正常完成任务<br>如果这些函数够通用，还可以用于其他程序</p></blockquote></li></ul><p><strong>其它内容:</strong></p><ul><li><p>许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的”黑盒”</p><blockquote><p>如果不是自己编写函数，根本不用关心黑盒的内部行为<br>例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及printf()生成的输出<br>无需了解 printf()的内部代码<br>以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上<br>因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务， 以及函数和程序整体的关系</p></blockquote></li><li><p>为了解函数而需要做到的基本理解: 正确地定义函数，如何调用函数和如何建立函数间的通信</p></li></ul><hr><h3 id="函数-基本使用"><a href="#函数-基本使用" class="headerlink" title="函数-基本使用"></a>函数-基本使用</h3><ul><li><p>以下的说明都基于该程序:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"GIGATHINK, INC."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">"101 Megabuck Plaza"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">"Megapolis, CA 94904"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	starbar();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, NAME);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ADDRESS);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, PLACE);</span><br><span class="line">	starbar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">	<span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= WIDTH; count++)</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其输出结果为:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line">GIGATHINK, INC.</span><br><span class="line">101 Megabuck Plaza</span><br><span class="line">Megapolis, CA 94904</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>程序分析:</strong></p><ul><li><p>程序在三处使用了starbar标识符: 函数原型(function prototype)告诉编译器函数starbar()的类型</p><blockquote><p>函数调用(function call)表明在此处执行函数<br>函数定义(function definition)明确地指定了函数要做什么</p></blockquote></li><li><p>函数和变量一样，有多种类型</p><blockquote><p>任何程序在使用函数之前都要声明该函数的类型<br>因此，在main()函数定义的前面出现了下面的ANSI C风格的函数</p></blockquote></li><li><p>原型：</p><blockquote><p><code>void starbar(void);</code><br>圆括号表明starbar是一个函数名<br>第1个void是函数类型，void类型表明函数没有返回值<br>第2个void(在圆括号中)表明该函数不带参数<br>分号表明这是在声明函数，不是定义函数<br>也就是说，这行声明了程序将使用一个名为starbar()，没有返回值，没有参数的函数，并告诉编译器在别处查找该函数的定义</p></blockquote></li><li><p>对于不识别ANSI C风格原型的编译器，只需声明函数的类 型，如下所示：</p><blockquote><p><code>void starbar();</code><br>注意，一些老版本的编译器甚至连void都识别不了<br>如果使用这种编译器，就要把没有返回值的函数声明为int类型<br>当然，最好还是换一个新的编译器</p></blockquote></li><li><p>一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型</p><blockquote><p>这些信息称为该函数的签名(signature)<br>对于starbar()函数而言，其签名是该函数没有返回值，没有参数<br>程序把 starbar()原型置于 main()的前面<br>当然，也可以放在main()里面的声明变量处，放在哪个位置都可以</p></blockquote></li><li><p>在main()中，执行到下面的语句时调用了starbar()函数：</p><blockquote><p><code>starbar();</code><br>这是调用void类型函数的一种形式<br>当计算机执行到starbar();语句时， 会找到该函数的定义并执行其中的内容<br>执行完starbar()中的代码后，计算机返回主调函数(calling function)继续执行下一行(本例中，主调函数是main())<br>更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码</p></blockquote></li><li><p>程序中strarbar()和main()的定义形式相同</p><blockquote><p>首先函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以右花括号结束<br>注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()<br>而不是调用函数或声明函数原型</p></blockquote></li><li><p>程序把starbar()和main()放在一个文件中</p><blockquote><p>当然，也可以把它们分别放在两个文件中<br>把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数<br>如果把函数放在一个单独的文件中，要把#define和#include指令也放入该文件<br>稍后会讨论使用多个文件的情况<br>现在，先把所有的函数都放在一个文件中<br>main()的右花括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器starbar()是一个函数</p></blockquote></li></ul><hr><p><strong>图解说明:</strong></p><ul><li>以上程序所属的程序流:</li></ul><img src="/images/数据类型-9/函数-基本流程-1.png" width="40%" height="40%"><ul><li>一个简单函数的结构:</li></ul><img src="/images/数据类型-9/一个简单函数的结构-1.png" width="40%" height="40%"><ul><li><p>starbar()函数中的变量count是局部变量(local variable)</p><blockquote><p>意思是该变量只属于starbar()函数<br>可以在程序中的其他地方(包括main()中)使用 count，这不会引起名称冲突，它们是同名的不同变量<br>如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号<br>不用给该函数提供任何输入，因为调用它不需要其他信息<br>而且，它没有返回值，所以也不给 main()提供(或返回)任何信息<br>简而言之，starbar()不需要与主调函数通信</p></blockquote></li><li><p>关于函数间的通信稍后进行阐述</p></li></ul><hr><p><strong>待补充</strong></p><hr><p>561~640/79</p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-03-19</title>
    <url>/2020/03/19/%E9%9A%8F%E7%AC%94-2020-03-19/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="56cc13fd0e9d99d43a772a7597d4c7e0268e3b0f6b781698b8c04df59a07db26">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f0877c94d96a9f6e8b16d5370e02e803b328e30f780b1b6c7f57f6272ddf0a2f8b2b6beac45ca28a4c142e42208aa1b3f9ffc4cd865e3f370e482cb0cd66483e982c89f5f8dcab55d323eb544886ce39fc287e573f6a5aaba4b4434602bd28011c0d39ab298e7b47505f62095ff84f7f8db170364924b29bad358ee2ecf5256ebf9e41e998a3c196a95c4bfc0e42ac289964c021d7a995227e33d84893c0ee73c8573c822fba9ad0911563f4ed363e9f40437b003742e060c44da98953197e7946189f43bae5a1ee96bd7040b01d0e8c7aef9f46e47b52dc5503c1793db7cabb949ad3fa71898361b509666c814e0e60346fae0470a36bb3a9dca85fbfae11c5a4e76252c1d0d140e000b69885a70f69ada66b5b4957e8bf96fc3b04d6bc3f17e07e2344ab1a3817455fc32c92a8db57a0b27e88c13cac4879fce01d94c15682a2b3b01abdd5d34f2b7c959ad62bee5db90ea1fa0d26720dd5c86f1de6ee763946aa1f61189058a9e787796154902b294d497a4b6717d73cbb504483f56a8db42e8e3f1553576b85e8addef75946cbc91c8fb5f39dfe30297429aa288fe32ec0e1c689e206df5cd2899cdde9d6b61544848d555c8bb3a534c97e19d818714b66ddc4203c8d680a9041b14cc5ae63879a25ab9e13f980f649a494539f7678f58473985626863e8c2aa4bbbc97bf12019e3720802de7f4cbcd86a77bf95f64e92e79f26d1794084d9c857acf5290ee2e86cad796a2fae74ee30e40c078cbf7ec402d984703633ac6ff5ef193fbf078e3b0c17ccc6a5f5adbf5bea8d5599b4bf7892f32829b55c38b1a2fbde71fd3b5fbedd55adf728c8de0803771039302aa07aa94e39579271491478c0dced374e1c63f4ec5f218e1ee08a293cc0a9af3436942555bdd23569cdf92034b639c8bdb03f5b2e8b69741f7f493159dc1c2db9e6a3f134ed1c76726c9f2a8ccad9143a37d4df6c47a106e056e682db602e3758930cf6aaf923a71660b881097f04a25da48cdb0e78f3dde3f0891a1ab76939d8f7466c55d5a95b25bc7f34b053b7febb97dd69bd71b55c71c7a4e5ea979915c76ccad789831013be10b81fdb0b7587fa8e91db1aee780d8917f1c5b86b96b7d5e5e7aff08d2afd02c4090bd376898abe7f4daec74fa4bc7653b8fbda52c7781631a2bd1ece279bb5505fe4c2a1f1d82b5dfc5cc20b99144d8aea22edcc88ff7ffe07ded14da66e3b00fb5ccb2f19d9d283ba7a21a467d46d429ff600710bbc6fd2b6c3f6fa58106870a3df7f9e53329b6f14f8a597a1a71d82223b5ed52afb8a47756836e64d59585c2c8dd01475f72308cfa7e492d4699e00909816eaa9db269f2316a1e86a1fafd93f7a4f8377adb2de26e51649a5c5e1341c7bf931d675e09fb486a1e940e1aed45371103252787f91b7f194d76a9c592e7cf7818389ffece0f01069246e733848e4f79f4f5a63bb26f0c124b6fa8dbe86fe6184f8cc653c528c304a921dab80153ea4dbb6607f39de868ff26202389b58502306a00b4ac0abc35eab8335c90f4b605f97560c5e4592a3c976d6f813b56a07edf62b5461af210c463e45c1a1c25713e0f1747ac959dca8333e57c0265c20149547add4a6047c29a7aa69746e19b656524bdf60e62165c4e16b0b5cc900d66f35a0cd5112559074c2ccd653b08348c2e81e4c69423e07d950a724275bacd760e3649b8f9464d3f199f823c3a69509c1c11a55fe4a87a67b7155f5d0d3433a3958d74ed32dcd71ee573de8c35510551b14a3f9cec72b6bd81991decaddd1b9918a2a32dc036678552aef6f0e3ce82a233d523b593c621e8addce5041132327658ff6096e68c54065a2061c76d57bae2952d356d5f6a876ceb59bf5fa6a33539c6e26aeff594d78a33a6911533274922f9606e873f449fd671b1e61a36f707e10bc6536d11c8b3f92d92f64fef30fdab6ea4e435b3181d19a9206bfd02bafdadd96d037388a2ac73275cb203a7e889b886d71a17c18ece87a6d85eadaf89313dda17f86fe365cab4cb22a49a737ef52697521dc6e33e67405ce90503efb9efa793c7ee917444190f370fc01bf731c7bbf721fde2847f097c1805c304ed58108d278644cd09c74fb28489d36cddd3ec17952913168be6b857e026da0457be80a52fcb2cb61d3eae3ed2abae0de230655fcfd1b09ebf336131b0e2d958131440e050fca4977f76ae440f8d39367bd7df0ab0fba5ff257a674c5eaf4139040627353667455d4e49adff0d9ea43bf7d01da46c549a15588d61f57dcf9d386bec16786c8ffc7c8884dc0fedf83e159db2492b4b19a2c89f3d27f5a02171001fbcc60631ea53ce18a826502b0f61f980078c1100bb6d6868a248456f4162d0b2911c91759e96c70891e1e7cf6fcc36db918e9dece00e5e860091d1a409601cda697d1e6ea1f7a3e3849d3c7ffb81c04a5b95a7eb966ec6f75e60f1e0782dafa712b7ecb3ca092eec2cd706444d2df90010bb19e801e5f96f38bac1fef479b6c6e20c32091f0b505c88a6f20c0230b129e5809f7cc5379be0133d168becaede9473197b144c2ff9500d053b64707777ea7ab0c6b3391fe4090fafe7069156119b4eea57fa6302718d84cf95f23c22bb16286de16c2e074d9d7ae7a914312683858d8b8fd55e58ed5fbbfa9454d712d40f3f904535ca7bd2a6e86571704bab2037f124b8f8d32c11aefcefdce2d5ee499487166014962e90337898406f0cebc7e93c809dbd80fcb4bbb5aba8c645c28b527e53be8ef107c0c22e2a48d90c3c569a950f582ef46b3ef98b8793cf71e240cf658b5a177f8086e6ee75f6a218cbed01a539eddaecb072e264c3cf4d2a3ed447558217d134546af3278d5949b8d3fc208a25d11a6ebdb279e74a20871041f12b0965393e9720564666cf0aae8d2b2bbc91b1cbaf9384faae9f1eaaea69e3fd298387a0607133e1e1691da70f83016d234714f82fda3bcb2a6c9d044c6cad7286a59c3d63767cb335ff7d6d5c7757e1a1b6f0f131e1e92ea8e868b6bd084556cffa66916a7403200f5397df64ec9538c37ce376ad3302e30161b01366d0dca86fefeb5dad024cfc638b85d7290226e3c7812acad4f511eb25ebc271162e46e90c5e352cc78f40af1b59507b434d490352e0bde29f0fb274a32671172631d42af686ed05b87411fab454165befe17505193865f8868af877352a75e496c36e2fe57f6854cbcf412540a2850aedee5f77a0cac23c22bad488c9f133da8c7e8e5a4e448597c1d60b40a711270a038df7c411793d3fc2067c99dfdf7ee10273b016204ad2f154174bff2a32047ade309bdf7695bf34baa4978d874779338c471cb2b4751da1b15f36c1d6bf0f8a42b3f7d8f21046c3eaf57c5457023ba50c910f8fc285a099a42ff22b70e43fb23a0bc80cb15b998cd2e0bceeb8dee1bb855bd69566ed912a039558b2c83a088fffd5732fc712211c44ccd2eac1fdc44c99384011258d83de5edf2c83c9f46474637851b75056e3c3d5fcbbfeea4a46e2e80f3220b2e75cd4521e7e15470461c32e0bde9d9b01e37a0067a550eae8e20bdf5430be5ccf967b7ce21fd27b6ae9b922ce957af31fd0d6ce15b5a3fd0681f704a2d86baf8ddf6ccbfa1ad6c48d8bdad613ea4448fa5010f58af65d47a30bb24cbc547479e1c65faa36854cf0761e71b1fdbae6274cd85850a0f61d41ec51b62cac64d85945166179b1801c79f333007631c17dabcca2388b657b6e79e7e41c8a1e222f393735e9f68dc3ee0ef2b2605a1f7606df83e3b87d4b46dc1094bd8a2be123995011306634ab46e2fb172973ada3bf2e45f3311b976053be6149ef28c033fe33d8f3248bd0fa558f4d7d8db7a714d985856f121830c668ad2558e46826ff67e8a49cd0bdcd404790c973f691bde6efa603c9764cf970ce440d72440ec4ead38ad1e008f9bc193ea024cc46887279a59f3f5ca3133a0072f31d9782fd911b212831f3aa467b27c67e7fd465cc23afa538b1a6187e4af889ff826b9eb476bc0b1eb2057d13f4639abe0b458e8b1ac2905fcab5f3221cfb44c5f0f151ace76fd617956ada801027241a120fb018e9724afefcab829f2b7d1995a5c26ac57ac18d8719458d353df7f096e6900c19e5f62f6471a1a4c04fb2640f6bd766659de416dafa5a444415f0de9c7002755d2b72953a022b92ab15907af99f688fc51e9c77d54f0e286e628eee59ac8d7155d258c89f400f9ed416cd3dae92dbf17ab36f6b9dc297a6fe9630d606079ee19da39fc8e40d5921e9f388457f6859a92116a6392a860f318f11f725219e7391882956ffdb6cde6a6749001e6cab880b67c88994710a7e24dc0d647d03c51f700bdb35924cda3dd9b6e754eddc3e70c1eb11e18f374e3da1c0e615c5efba1bb5f8283b6d321d062fb701a286b8fd3745bf357a7b1865790a12595b5f9ae808cc70d38da1ae935b344e2fcfa26e139809448252373adb64e7dda2d100ab9f584e3f66314def6ab9f00551d9dbced81f57f75dd4fbbf554699df22ccc44f11b7aeb7f6e0715653ac4122866a96b0eadc143c9514b109ea3b24a587ff5023c5024751d4a8dbfe80183892793e45bef462a5a6185a00c4b4764904b9721280f201d9e3e6c4c4344fe116ab51540fbb79083614e6fbd50c282a13f34e1879aeea985b4ec8c4fdddb9cb9758322afb9d24676318b4e1125425dbc386d570d377eb8130ecfc855e70a5fcc906fc04ef6f06c26630f852793d8c8f187772635e1a71e4d1f296dfde6802b45d7ed9d3a5da36544ecd4ee71449605a2961b4e65130805952d641a2af4beb09f0d66384ad5b97a7b37dbe73d928d64d3e7e1d91f2c03397a6a921487cbff617be2f22bfdf423a92dcabbb9a215653bf576f78afda0c589b0ca9116b2c140f37a464be3798a4da4f7cfb8b62669958d7396c11097087adcb95ee2ebf9e45e52f4eaed44f034c20bf8329af619565542c5da789555029a2ded7d1c0071528b641435f67ddf6354f77770a26cb13c78cf3e40e5d0992438ceba7d55c17539df349e9751c717a06bad2de7548e9d3fc7d51784e64b3f461509c4098f0ad7e62df33163d9a80f7926c9f597e375c0c02dcfdf3285bfbff69e6f032aee43c466c68ed90d5c59f40f3d1c43f0d9da0861f477df9a51517666c30984821701ef798e8c5ec605bb3605221274cbc075ee834776d0a01a70bcb5d3d154ef132f91d4d7c4850354f139ae4f1e42fdf12e5fe26584a5aa6d94632b4829de8d7104885f59f53f95243b35c61bec26662bc7dc73e547f4f16733cf8d8c13488482090145bfa5da3343b8852a596cf19940cdd91f0f24581f0a218f7d918fd416a4014c483d9150b03c09be274feae55ca56a4f8d1fe207d3049e390ebbebbf824157757b8a6fce99fc031ef03a017d764e0146b6290a55714a264980df9c7a88564965cab465acb2ba9486a7171ddfbe3ecc735376297136d7c47fc41fda87bbe2f653c07e43ead50109ffb6c7b0f71360f07870b7e1f5302c1dcdd80d4ef1f41e3a50e2a2e5ec2c130eb70a7c1e32e3e79b6699cdca9c23de84bcf89b7273f4e02c8ce391aab38a4016d3c390484f8b9a3d45866f3286aa1d72d26d17173cad08a4437c5d83167cc50ef0c110e4227226c52b1291c1dd2a6a59a6e932f04389389b4c49003db287b9829d9b18906f8bff2d0d2fa1c83abae4f8ba5742988ef136f39964db7ebeff787219790ce8c7eac837baf26be3bc64fd5ca27ada7e7b871608f5b4d30715033bc8a171e5b28fdaea4cca06cf82193b51b2cb146fa20487e6c4fbc80ba30b5c439fbff9ae03a09918a1d6c38afec27a2600a4e7f612442a8ad3a42e6ae8c0227f8f218706e7a1384cccc3aad4e6b8c9b3cf38350316964dddf82566090cf8d88d0b11310704318d9663cd0331bc40be502f736eec7ff98e47f7a5be421b032fff00521040c68f956917ff066105d096a946d9264794fa8447385af245e28614fe46b88563daf2dd0dcbc7db485822521970377b330b28941470240057b054f5b3fca1a2549722798dea8c793241b24d3cd9d2aab5c171064238f61f8b806e65ea6ad5c700de6ebb29847212135cbe3644edc83fe49322eb2f16b4db7315f720b0c78c134774c64dac63277a11b9bd42c8f61757742280e00db2dd9740e584831eba247123c80e8e5f516e7e7e5950eae9901ef8222587e32fa9080b1c304ac24c38f7f55d03aa3f457bb3ddbc393823d888b7acb5fda60d7c19fad12f3c117f7fc23c8dfc1faeb3c42ecf2ed15ea00790a39cc5aa630dfb79dbf70ff46f32b3e73d28d1bc1a514eab532f2c74141e41ecb591ef43cc2c4e1ab72a2332fa73a6b9311b5ac7853e290434be8bc9c91cd7fd8902d73193f00aa68dc97459dab3698641794fb5e4740cb1cb91032d5e15fdee0bea82d988b6f741a2e0c1c160c28d4ab4c9faf97cae657df0cce6e3f4ec195da4b904b7357690a591cfeb7e3fccac1353dce02125c39660e810195be8c12606f7b8ede91510971a27af4971b7dfd3f33429dccd8adf36c64b9dc8743e5fadac8e05e1573d5d99854cfbb2b1c3db875be22016ddc79ff8de8fc006cfd473a6464c166c3b1ae57e88681fd8d54d290d4f90c7181d0c8226ca230daad4f5174c6174be21cbc72b3da0a1f388fafe852a169575015a441cd8a952d0a6ba64f17ec66a9d018dcd02fd2051dbe6d564c4bf33a48e57c093f5fb0e4e10b2fd85ba45900e1f66be8837306d78b615cd920702247561001593f1fb0ac8ed40dc6082b1d9fb240d469e2a07409a9edbc154db31891982457012405d3718749fd61ff03dca8301731c14bb02436bf0537539e583f22c9ee84cc80b527f53e7a06f65326a1bac8c6436ee3a589cf6252446c3a50c389974ad1e41296f2ed53de14ebcca402710b36a97052dfc87b48d595926f7332429ed5b1118dbf43e9de33a0c1a01f166a40ec9a1eb2d047c0dfecbdc98ddb58ac221345588aad45bd39f9e69cb6e7c61d838e731bc5465adfc6bbfacc3b721218674d59f440180040239198ef5b3c79f20e0029577de588f9adfa6430874d1d51234c358b0a2a10a78e712b6f373d672ddfedd2cda33e454de65e9a1a8c9c4c1e29e033f012e8e318f4a030a3eb75a4e97d38758221b2e46ec2f3b7b4457d9e6a35ea882467465d28f948dcb155c79c2ffd6aca423d64bf698dd4e0a5f24924c80c95ab85425cabef3317d9a03c15a98b5cc2b585813fc6b541c741df7c3af40347cf8ef3ec14131afda8cabd066921a911156a43bdc2ffd3fce22a3323b235b29560e058a2f36d855e00c1c9b51c57e489b82a199055685a8c70873c2900082487d848ea209e81f53b41930d17311959a3319c15ceeef76b98b0d2539d75eb296c96c978c06a3e64e23d73c594647d6f77a436136313407014278f1608f45a1fa840fde3e3806fd4a60396e4afa3b88c683489ebb0d44724df2619d45c3f838c541f0fb9d05459a9c5f79cd4003f60712d3d61e9c6f4fd31a47c787c43d11c9542bb83e7ecb45e34e1b8b72d60df79c9291bdda9cbd42ad197834d3782a832a6daa65e7db255328d0864c2fd1e5f0cb352c7c19c185278863d4244c251dead531adc1ef82a2498c3f0c55154bfa1388885eaad168f434f6533d14559a919d6998a83848b58f1725f604cf304defb9cc39db4a964ce4d3cceecc266dac099e67e8633834f8f39f5462c5f972c2e506f516b973594b0c01998a574cda4e690a65c2f9bae4930689ed8fe971faa66769e7d62d13fb90a2c91a4ab50a5eb4474de0b20338560534ca69cb947156efc2c6689609a447837cc7cad210d1b62e47258d958b2d2fcd4f9adde2e97dea2ca5317bbee9970becab9e3d6534e220ec7659b3051df513e1054bdf480f1c10054e1655b929971147b323f104eae</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>无</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-03-16</title>
    <url>/2020/03/17/%E9%9A%8F%E7%AC%94-2020-03-16/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="8116ac38fab485852be3541712d96fb071694491cde8fb6671ff5b03488be843">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e5bfc96044c62cf099706e61fd2bb0de2b982aeaa6c1addf26bccbf89281d3e351d52c977096fa17fee498a72ba24e0be01a31b030642292984296ef84aab71f8bac934e9a0daf69751f6902a5a21cec00187c54153ec988ea220a53a52e9118eaa1942200abbc64c18f8c99fd3a35c59cb7ff48f6372a22b933802dd98674a37855039e56238b0ebdfc40e5c698735cf529835538443eff6b3996440ceb726308da3fb383d7ab4cbef54e79c6ef2be1fdcebc890109a8e637b5ffa693f26154cbd348a6d2476ec7ca186a99a39dc28378f8da0459b7247c06adabf1dd8c6aca8929f5ef644715104cf60d2c7ff1178430de8561f830e7233b628b98fda9bf06cc4603bf6ab5768a18036df6bbe72cb5357d4dbe8a8cf7951901e910d1321af69776eef93d88d10d575aaa38296d1622fcc2620efc9b2b0f719e3dd0f940ac4d9777b1842ed886aaad91af685c89e11b7f4d8048c43d23bf69a15c30ad03e38b0bc995813f7772a24b61e6bae96a3a13d3237004de98067d849db58417e2dbe64e2aae62caec2eacf579d3e62173dbbc84b7bb179a2bd8ceb095a396bafecd19831c09ee7159ce60d20f59c54596271a650bf0a790e42f3e698b6afbf25ca4711915046796ef297ca8d0dddb3d9ba3fb6883ac9a6ad5150d93a6f7aa9c8e458f461f4e6d7edbe305cf4a0ea86ff5853bde6d298188077929c9041df84c68a206e1c794df2fb0ce1392d5d29cf3ae33ec7f1eeb08fd2e6c6756c508369e78ef97f90dbdab38cc2f2d02e19ccf7ec05759c672c0f6cc22bc6da45592f9a739649635aab55b39f6e8677fc6dd03b1996c1be41adc7fa8bd18fdb75b7ffdf58a3162e293dba7d71a922886bdd7d64cf83c16fc0544cf613a43c3ff9f635e4b14c2852068443af955229402d163ca7090512ecf5567ee96b9c4d3084154f2997937046a634de6a27d362a572d2d448fb11f7859df7ee3181448049a825cf38e647a0e8be7e51e64d226eba59e0a77638ce7d9e69266fad3a52fa7351ac1096f4d2a59644ee233429173a3bf51940151eb7799c790d83976ae41e05bcfeec5ad50a9f26726306c9a435be85ffff5c446ef0ca5d1c02aee74d1a167a757ead55b213fcf00df86379453419c145bbdc4152bb13ad9c45ad3d2cbd5c412ca37aafd8915bf084b59b99c449ba4339bc6a55b7d464b0ac5f583b62ad5d7196ab12459071c4fd19e75dde1f4077b2fa8eccdbf73433515587ca030a7082f66ef2d3b27a7a9e79fd93d3135858aca7b7f4468b8db37a1427f03ea492fecaf4f3916491347a5d53c0c5ffd0c18ad546de46ebe75cd93eb88c56b50ec04a95f83053fde26444b8efddfa4f5c8bcce6c24cbc7c2dfc052e0ee2e9e66f4ee29f3f1c50832f333fdd836e6413e42c7e434ecd8923332dc378d744a91d02020781d398a0ccfb525d2da04f79990c174c4509b5d200d03f674d7a156d9f6caf93d3644672f82805adbb42be38f49ebc4790a5d46ff0a32b56f32f72f852be6bb3463bcd141d0504ff4c431e1b30e932449ad5612bd9e2e6889c8ffbf2618ca46cfa7d886e24278acbbc3f56ee34fccf746df4dd3ac8132f0d8a3a0738800d5cc9dcdb01c46ae966359decf04da1d9d6bab874e568bcdf285d2961cd7d88ed548cd05b78673299dc590a73969fbaa61b13b31fc5be218d01eb7366cb51868b7c3e2d366b897c661e55def3d48c0247385c3eddbdd18e7c45b87a1570187d2da7514b0c81c3c44dbfc7675f920f5d5f0cca3242641cab7bc72c352850133c7bf87677d8fd00e65b560a9002939576532eefbea69ba2ce5c734ff93ab85679645e5a3287f10cffc0f853e0c347f38fcd2258f563822af89e8825507531d1acd62d5829d23a1a37cd7bba0c74b7e8fa2bd622a3a7540f6c4cf203fdba7f17cab641c6b5a2b34d1fc1511288d6bf30ca328e6d50db66c1c614ab1d801ab8116329ae2e4a377d73e2d65b6b63ec11f9d72f720dc7ec111048f300d398cbebd700de996abffb899214d2a2a4b45c529ca77262b26c15882b8e6098a12e794fdf7d6d01d3c4a1464b48213a10cc3be2d53524f8ab91e7176e70c94c79f82bb1af883784a8eb1724c779b822c9d73a94a5aae5cc6c6c7fd5d289ae1dfd9a6aa7c403267b2d6acb1eab8799a91a6073462b51d71bdd7cfce278445857584a75e197415467f89be59462d256f30d89c82755d79f349b1c792d2532f2b1ae727ff644286836825b8dd815a904c862ef3b82b3fa564c525c5168d89859903c299acdc78c757ca06be161ecb1ed03a04b13b714c58900932354c645e3bf1926381909003bc8469373e1f252bceedd93e289a571e3c81bad99663af1700a0a21a948f670798b1f5e8723430c6d37b48227cddeef79d4d7e5c4863acf84ecbbf6063b4f943a9b2a34d64116469bda91007288cdeb8dff16927748fa2e44ca8cece21dfe71ebf2f577f3363ff72f2122bbdf9a9a1ac1b8eea4740b19d7980f6b33b934e9823191b75e36a208ad850de8b95aa5e8fb2ffa9a6ef004737ffc26e5381053b4168280a039991277f79b411b4d960c474b2acebfd952f2784cf3052d0e7b43279732cb94f00f75111bf59dd4beda0f47da6eb29e8dd53733420bd15011fd5ef01753b4f9c2449be37a5a543379dbee6644f415450411ced99072b2330f0b1a9b2316d27df0d959c29536c40e909786a22ca7bc1b148c5745e83ac1a9e99eb71f53307c709a755d0b1c809113f23c6362f77cef6c7ce06b77b1d7bb99367221e061f7807c219b2d3b025f921cb42573284b72f0afc55dd79dd5aa10d064f2d7f8939f90c236244a73f79dc1f77c6c0f811c956e38ea33a7e2ecd3a6cd4478312375b10f27764d08f6903dbe9cad4fd91482bb3361c2443aca87dea4c1b3b4afa0ae9babdc1795f42b473b0726c8408bccf35fcee36d7f94e06f71a4205fbb5bee8f1393b88e1a71ff47c31e7685b7a145f2ddb09d54bb8770dafa4814611899ea9e923e1e6d30bb58befa17cce9220c853b43ebd019f468d2150cefd8cc4bc055f953e1312a3793042be5a4663a65019e6ee111b067b3871fc87a43e8a2c83b36d6263d430c0b75e293bd2eb99e48245b1368b6716df2c3ad650c9aa613a767f8fd6f43c2a073f45f20bed7cabff1639273ebf107a233c76177f60d3e714b05d6e0817d4c5ba00e192bdac3585979b226f21be6e3a63e6549ed9259f1ab38125025936ae5fa7b3af9975ba6137162f0b46dee92f337c89a33968b90fcfb6d47363f222e56a1af9dfa2c2cda604f77f624bf1851e3810215336cbe10d5807f0c9f60ddea69db7cbf27744d179a69445f1e00bbd24c8a5432bfe5d172a0eafeab45b99b1f232b9764ea564a102d50833dc3923ece25c930ce61a78204b24c7b367a1d2db63624d04fad7f81ef0ded59eece6345da2610013c7a118407f2fa28c4db3e357bcd9346cab6b8c9e7499fb312714d278c089f352c4ced492eaa501127f381b214dc9ae061ae87d811fcc5b1f59060d2b87db95ca51d3b311906daf9aadee3d68b0db6f3485503ba0448d2cb07167d72da46005469c32de88fdd570e4e08bf618e52af07eccd52dad20e9ba30338dba15b4001182d00906b4c05ab038b357623b2583c32883e64448e0e0c95c8155baaeb6235d295588c1af7adb710d0e48f28621873424d26f4f529f36511781549d6669d2283b1bedb4b90cb5d9f8a19d4dc63e269ce225763f3b08a07e4cf44e714ec354a5640fa79197468101e1690b976db61da459ac42df68f33f45a35b50ba54038d7168096574004e95257f36781a663dbcaf6cacc07c941e66dc2380a6f5b3cc5fa000029745a6225176d6f6eb5e4f2104f260e640af8a7fb888462e3693ef198e2fd84e66cde5ae9adff5e7273f8407d1b42faf12c2feaf8e33c1b0d5bec23ee79abc8dfc8e1e3ebae1743cf2da990542410c448c062537acaa965c08511306c2bb3845a821076a93fbee14fa51d7f542a3d960d0b405144d5ac962efa4f367a07e97f384198afafe7931253e2221048330da4902a040c6a74136de037ab9376a68f5ab51a57e22d57f423a1c3fe12dddfc43b5866608b7aaae9ad0aede8068574cbe584f55d1761c7c4bcbe1520b0070bb816cb4470faf80ba3b8fd5a1e38bc32bf1d21cf0687a9586a1b90bc16689d49534c8cd6c7bb59cb65f5d8ba12524459f5c8bc92791750fef4aaef955bd7f04f84762e32c28cdad25f14716bdc5567be350420f31449aa692dfc196a65ef2aa7e780c6e0ddc14bf01f629d9bad66dd1cab2f39b17bc7d1301eae625fc696cfd7baf968504f7d209b31e763f61e927ea5e0e7b1e56296b5a0f7865e08c05e4e32aa8cc72e313324ec2acca7a5d167a9d9396048bf280e5f3aec5a91d212b9b6acfef5a41f0f0a3feeaa41fbb23c7f84cef838efdfb153c226ebf489eb5ad779b7b0f6ee8298db560f4d4e9bcfe903a7680319bc5631f71b30ed1f722d200a8837e81bc424ebf62d7d80aa6e868b08c5ef062ddd214607a0932234792afeb8e4aa7eb83c32c9b757d731542ba93d1f4771ce20652eb79810563a6409822f3f748e1282551649d1593589ac63e4669de6812f6a0ac9a63eb7fc00a094bbd8b8e878150813ee86c2f3711be8b31d4e923d03cb85daf338a78b2be80a6810de7513ce0ffa9450851ad93c086ddcf035118894709c75c3a5eea868a7c3d5ec20b934cb79309b5fc886ca76518365491a91e93b1e9d3f3bbe614fb74d55a1c4929eecc6284ab8ecf3b3afa9b8df6b589068fa2d4d4a499b122978ffe7fadfd87e6847afaba65528d5831c4d67064cfd17c4600e2112227a0b8591eb14da3feb67900d2d9f436f1ade8d5562b677a6a6849d3381a6496baadf3460f51bd58d572db226236d88ea841ec3a3edad8856f4634db97e538c1ba4c47a5af2f5df94bc2343a1566d8044ebe392dcad144b1dfe8e9e9c3f416e74b15eb35b7c1b5ff6a30a87fcfb64a2d5bc25ee8c60cb2af07b882ffdd20e703dc909c72ab24bb0545f50aa597a5687795da2b727ce4d866fe302270203b141aea2acf79a71a067d0864e225b6c1342a58fcd8d44277e794f0814ecd54f0c409440d6a83188cf39875e61b761b60d7c436030f75a82012c377d89b016d22d8ac6c750ff001c4d645936c0cfef3b1c5bc2be465a8321c67b9eb337688c471e4b3d476fc3d0c7ecefb0f00b7c8b9993561bc2a71f8f290f8fb7e21a0f500994d961a52ebc24e4d2c09049c7f7237c811b5bfbceae553e624ce17de5278a35b66ba805b9e26b1c70940725cec2532dda387d52d0eec699b8d84734646cf40086eed0fd14124f336191068b044e31c5862927e58e8593cdce0d64693f725cdd4bf8890d17ec04dcc1fe06afafbab639e0839ef3c2ddba0abf1a7f474be4860e99a008dc73137484a95158bdc95c0a160fb8452e20f3d5b928b482f29f154058a0b85b8a71bf2c6bf803c23e53a83faa22ccc39ca8ba8a2eaea2d41636e9cbe55173a1362f8c491a936928d2e57c58dbf6db5ea46681dbfffab5656d6ad9f88cc96846be19f595754c0aa4e71359d1e1b41f23c515d5b9cf5f7e66367e06e21cbc39778c2b149227f0939c91cf7161c46a176cc9213d0315d014e137d77ca16812f1fc382e3b7a5bf19ba39602cf40c6a457a03a8356f4f164a3001f825774b4852d4b59b775ac1d11456f76c7561662b74ea328d5a543b5d376a59d1c6c541031ad8adabda8ce12fd6259cad61614441b15262a0dcb22878ec50970324eacc41bc7d16887e01ff133d41dd4190ef625d98d88cf11f7f3072738544d6e0d3127e6dbe1fe6657a079fedbeb0958bafb3f189f8906637238f0007cb84d772ca6bba5b72ada30c686fe865c043a97ca0e3dccaf89e98200b6b9805499a14e4649b7dcd7ea56c24ee757e516a4e45305ac85e6115bc9e81485226be2a808ae616f4ad91bfd719bc86967ce56e1c812edbab6e375ee80a478c68a5c035c9013094f7857113cdc0d68e7e7dc56bc0ddc007f5a89f8257d3e078f34bad8eadb71a60b4a892ff1e02804fae0562b7dcff1159f294a07b5986ff63ae1c473ca58d60f5826df209a9dfbde253484ed11a73776c4dc0c330be34fe681ba3919d83dcbc9ea177edc20457900bc9407184d5f4789cafb4b3c11399d4ec6ff533a2322c4b5cfdb3bb137fbe7c58375f5fae959ed450c86a87f89b4b0f25e72285b6f94f1089e1ef3fb6f3bd0f1b2a2efb9a9d298337badf7adc3f704f1435b9e9f9f090bc3c086c24c314a34648431d00e5e32bfcc59c922ea04f3b9c9504c08917301ba1a2987841a1d1ff82b2f5d6ffc6111bca2c8daae5d76c370329840d2a7093693be3ee367e886d132b1b9c4f55ffd247ab746954f593c22898a772618965e7cef8f20b3972d903e237828d885a87e7c99bd28849816634f4890ba07f6851567d080acbc5935f45421348d8f370a9f332e8bdc9c43dcc906b981ce6a3e39b3774e380bd28f328aac7e5017722c1c1332b6d70040c529a46ad2c5089ff0a74ac73376d8685d4cc0a307bfc6cdb235e4ab2734d73f0bf802f7c0cb39e4e3fc467ebdfcaa0bde8605d06bf471e717fcee3ff0fd201c5667e836960361725226dc425159c1b44ae1ac8d22ee6560c9a79052ff23ee62738cde361ecae61e2d84875e0ccd7cedd734b501c3cbc6e7a2de7d70d68a0451bb35c0a9d7aadb89012eac860edfe2a69b31b3279a669138a73a9309b1869370dc2dedf162838433e00e16a9153636a1440e2262626dc3f0746e4c24b6809f76d6f726070e5a0f511c7ba4bc6c6632edcf5c7acd1367006a356933547a95dac2a1d48d3229885a3906ec453e84c00e86cee24adef55a29af33b9c48f7d5a34bfd7892b7775db85bc03202d2a561640c5afbd2505dd9ce8babca2170b0414aac08463c0cd67aed4a4a904cd045bb2a16a5d5f94987c1c6b97053403cbc64e52ed4f535399926e3324eaf42692fb849dd47603f74c595bd351167079e2a0b1f644426f63c76f288816cb14a7ad6451e768eddd0a700a412ed40be2653f658882a0b92b7fd33bfb689fdd2ab881fdaaf4712486d4e6c70695266b87f5e2807cad1d4e4fe166ce2eebf9005dd471f9aad276bc69af8a5b66bbf00f23b7d67a3f11d0caae019aaa1b21bbca2128d35648b698adb1badd968c7a2d6c2dbf1faa0492b691eec6ef2fbe6087813b6f5429d2e83511a16e8a1e1e4d46bd07c09fe37299f139362e57051fbfd55454ed6b3be8f258d442465e5afa230857fd6d470833b7a2ac27def375fc754164aeb5dd03f3971ed2f37e09f76474daf7bb739ab5b1b06cbc55374de05340502a9769865f6314267d3f95fcc00536a89853f2759865b426b633057ce185ebd01206433ff293434889e95289efa72999ef2ac3ba4d2c4b53071a34604fb0d56b13dbadf07d1f5f357d9c07056628f990c5ae95cf1f2369742c00afd11e44fc1eea8160934bbfeab9ab40de71c038a1aadb45ba39ef0fa61b97a37b33e083c6de5e25c4e18f900377db5d9cb52aee997c6804f6d2430dda69db53bbabd58479c3cfbd96cd5fce0521ef631971324ef5d29a35fa72738ed9d108208a82d474dfeef540fa76ec7a462fa4c6905b4bc2f846644473372cb6ac925dba750d0e9a041347ee70cda23808aa8922fcb003156a43533fcbfe7a7d4be6437a8a759b1eef1aeb033d746f565bd8a2af38d8f4c52d296df2e6aa1ad45d252afe4f4b4bdf3e1d8c63fbc54a86a4e8582581743f96c74eea6a9a1d3b74ea62bfdf07d73e029f56f7776beff8df09f97a2ddb7c302de0b4915f4fa27e9e4dffad3af961533a27df2d0bf36b0cf3d4f1b11c3c2895ef0ce84b17fd446c11d8165e1fd27d70eb678f38ee2132fae852bbe70de4b4dbddb65a273b5cd1a8b23bfcd265a809f2e3fc700dcfa415446a952974a6729fe3ee7ce11a487123b7622939521fd63eb5596bdb352ce8298ede76c7762d7925a3c3c41875d6e74cad5030702c1a92194fc359f15dc30013290d93149a8733d222a333598d082a04b406b535883c5caf65a39decf52b381afe43db342127021ebde09908d7ee6c0b08344a1c04c596b78c52865ac34ba4f6d9fe4585e79c3612b8e8fbb4c3e31827458dd7c3c8ce3c52a4044809ac4a73b8a8eb6a4c9fe040be5910fa709f7f8007b88372fdc756f5a4998fe7f7df3e2cd602be2fecb49d1e6efbd31d6322701fd8703bbb075200fd4887d9728693dd5434ebc423b2d8222fb8710dfc7662661cec791edd63ad56207372ad046c5683c2b4ee45b6689087293152f92326551cae944450bd8cce98a958985fe133d311f3e87b7f319320fb0f3afd800223279dd936906112dd395f4a13b66e54d8cb599eb4b403313f7952f53544163a703886d19cbee4a0051f84d4baba8c7360dd52270b68df2463e064bb96e21fa9d0fa0afa4d4a2ae8733a38df359f946df9ce6daefd5a9892483250cd981b5e77b0e6559d2317a571df6fcfcbbd43e2a84602b121cb13968f935b2888f2cf137f822d69544fd31f93af081778a8b1bbb6c3120ccec13bb66adbc484053991a4441ea73704e226c15093fe427944d3c70e94f83abe6e0755a157572a42618cf4b9c431379b52639708f1bf034cd69f78ce67fdec9e9146bc1ee514c9cce427c6e58032ca7dce411f781c4b6b3d111eea9ff18d32395bf6dcad26a0cfc5a5a10ac73cfdcef0c1edfe739dfc440999c98f5c6be84bf2d31268f1f5b370adfcb81350ec9c214ce9f2f196c42a7834a298c362e5ff52fcd94bf9aee62419dea906da6f4b4a5dd2e17fc60eadef3f9d5ae13514a8ff1d664fe22dc61a668aa55d1d75c4771027aba203795230bc31d1ca1b3690a75da2db046336bade5782764f8d0c0956a07f975ca2ecd513dc44556fd421adb651db9fc29486896d1b78364834bf054f0c012c24ad8ffe578f32a06795c134d262de549d284f75bbea3590946a8dd7ffc205d9c2ae0c42ecab0191ae3ac6c3a2bd6d4a6ad1397878a8ceeb5c5b3d7eb1de1b08af6edabfdb885f20d063b59bc828b5815cee27bc919076615068e2b609e49a55ca02a6c5c6185b72131a3d2260af77c0bf23bf447ab77d8ba8690c71e5864c3be35ba874ee2972f9ef76a8572cd98ed8dc6413caf73de283fca430ef656b61bba821d88e35332447a04bb344dcd2b0e0e555f1fb5e7653ed077798fbbe1232434e881006189223fb0e3089f6a4ed4a50f7f8b347bffceb7773b4c75231d89f9e2f6b95a72ff8b0610c674855e114794ad16ba212e6da2aece95bdc3a654b60e9a0fce920998b725cbe01a2c0e102f9b267eedbc03d91e974fbdd21645e751c78aa72b0972cca113e2496e1f06fd8a8fa98a7c1bf4093106196902c8efe841a7b88b0361497839bd13ba1c63d84c1dd471d89038e56a4b48777bd93f007000e</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-8</title>
    <url>/2020/03/17/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 17:01:07 GMT+0800 (中国标准时间) --><center><strong>数据类型-I/O-1</strong></center><a id="more"></a><h3 id="数据类型-8"><a href="#数据类型-8" class="headerlink" title="数据类型-8"></a>数据类型-8</h3><ul><li>C I/O 原理解析-1</li></ul><hr><h3 id="字符输入-输出与输入验证"><a href="#字符输入-输出与输入验证" class="headerlink" title="字符输入/输出与输入验证"></a>字符输入/输出与输入验证</h3><hr><p><strong>相关内容:</strong></p><ul><li>输入，输出以及缓冲输入和无缓冲输入的区别</li><li>通过键盘模拟文件结尾条件</li><li>使用重定向将程序与文件相连接</li><li>创建更完善的用户界面</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>输入(input)&amp;输出(output)</li><li>常见的输入和输出设备<blockquote><p>包括如键盘，U盘，扫描仪和激光打印机等</p></blockquote></li><li>如何处理输入数据和输出数据</li><li>执行输入和输出任务的函数<blockquote><p>即用于输入和输出的函数(简称I/O函数)</p></blockquote></li><li>I/O函数(如printf()，scanf()，getchar()，putchar()等)<blockquote><p>其负责将信息传送到程序中<br>I/O函数的基本概念解析</p></blockquote></li><li>关于设计与用户交互的界面</li></ul><hr><p><strong>关于C 的 I/O 函数</strong></p><ul><li>最初，输入/输出函数不是C定义的一部分<blockquote><p>C把开发这些函数的任务留给编译器的实现者来完成<br>在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型<br>ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些极为常用的<br>由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性<br>因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数<br>其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面<br>这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序<br>这里所提及的 I/O函数 是所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统<br>处理文件输入/输出 的程序也可以使用这些函数<br>许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配，此时则需要输入验证相关的问题和解决方案</p></blockquote></li></ul><hr><h3 id="单字符I-O"><a href="#单字符I-O" class="headerlink" title="单字符I/O"></a>单字符I/O</h3><ul><li><p>即为getchar()和putchar()</p><blockquote><p>getchar()和putchar()每次只处理一个字符<br>虽然效率对于人为编写与阅读的不佳，但这种方法很适合计算机<br>并且这是绝大多数文本(即，普通文字)处理程序所用的核心方法<br>这里会提到有关这些函数的工作方式</p></blockquote></li><li><p>自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联</p><blockquote><p>这就是为什么程序中要包含这个头文件的原因<br>实际上getchar()和putchar()都不是真正的函数，它们被定义为供预处理器使用的宏</p></blockquote></li><li><p>如果在程序中同时使用了getchar()和putchar()函数</p><blockquote><p>在运行程序后，getchar()函数会将用户以键盘输入的值传递至程序中的putchar()函数<br>然后putchar()函数会将值直接显示/输出在/至屏幕上<br>其涉及概念即为关于C的键盘输入处理，缓冲和标准输入文件</p></blockquote></li></ul><hr><h3 id="C-缓冲区"><a href="#C-缓冲区" class="headerlink" title="C 缓冲区"></a>C 缓冲区</h3><ul><li><p>在老式操作系统中运行getchar()函数的输入循环并以putchar()进行输出</p><blockquote><p>其系统在回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入<br>即正在等待的程序可立即使用输入的字符<br>而现在的大部分系统在用户按下Enter键之前不会重复打印刚输入的字符<br>这种输入形式属于缓冲输入</p></blockquote></li><li><p>此时用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区</p><blockquote><p>按下Enter键后，程序才可使用用户输入的字符</p></blockquote></li><li><p>以下图片比较了这两种输入:</p></li><li><p>缓冲输入和无缓冲输入:</p></li></ul><img src="/images/数据类型-8/缓冲输入和无缓冲输入-1.png" width="40%" height="40%"><hr><p><strong>关于缓冲区的存在意义:</strong></p><ul><li><p>首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间</p><blockquote><p>其次，如果用户打错字符，可以直接通过键盘修正错误<br>即当最后按下Enter键时，传输的是正确的输入</p></blockquote></li><li><p>虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入</p><blockquote><p>例如在游戏中，玩家通常希望按下一个键就执行相应的指令<br>因此，缓冲输入和无缓冲输入都有用武之地</p></blockquote></li><li><p>缓冲分为两类: 完全缓冲I/O和行缓冲I/O</p></li><li><p>完全缓冲 I/O</p><blockquote><p>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)<br>其通常出现在文件输入中<br>缓冲区的大小取决于系统，常见的大小是512字节和4096字节</p></blockquote></li><li><p>行缓冲 I/O</p><blockquote><p>行缓冲I/O指的是在出现换行符时刷新缓冲区<br>键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区</p></blockquote></li></ul><p><strong>关于使用缓冲输入还是无缓冲输入</strong></p><ul><li>ANSI C和后续的C标准都规定输入是缓冲的<blockquote><p>不过最初K&amp;R把这个决定权交给了编译器的编写者<br>ANSI C决定把缓冲输入作为标准的原因是: 一些计算机不允许无缓冲输入<br>如果当前使用的计算机允许无缓冲输入，那么当前所用的C编译器很可能会提供一个无缓冲输入的选项<br>例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数<br>其原型都在conio.h头文件中<br>这些函数包 括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数(回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击 键后对应的字符不显示)<br>UNIX系统使用另一种不同的方式控制缓冲<br>在UNIX系统中，可以使用ioctl()函数(该函数属于UNIX库，但是不属于C标准)指定待输入的类型，然后用getchar()执行相应的操作<br>在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用<br>总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统<br>这里假设所有的输入都是缓冲输入，即不会涉及无缓冲输入</p></blockquote></li></ul><hr><p><strong>有关结束键盘输入</strong></p><ul><li>在某些程序中，只要输入的字符中不含#，那么程序在读到#时才会结束<blockquote><p>同时#也是一个普通的字符，有时在程序中不免会用到<br>所以应该用一个文本中用不到的字符来标记输入完成<br>此时就实现了让这样的字符不会无意间出现在输入中，即在不希望结束程序的时候终止程序时</p></blockquote></li></ul><hr><h3 id="文件-amp-流-amp-键盘-输入"><a href="#文件-amp-流-amp-键盘-输入" class="headerlink" title="文件&amp;流&amp;键盘-输入"></a>文件&amp;流&amp;键盘-输入</h3><p><strong>文件输入:</strong></p><ul><li><p>文件(file)是存储器中储存信息的区域</p><blockquote><p>通常，文件都保存在某种永久存储器中(如，硬盘，U盘或DVD等)<br>毫无疑问，文件对于计算机系统 相当重要<br>例如编写的C程序就保存在文件中，同时用来编译C程序的程序也保存在文件中<br>后者说明，某些程序需要访问指定的文件<br>当编译储存在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容<br>当编译器处理完后，会关闭该文件<br>其他程序，例如文字处理器，不仅要打开，读取和关闭文件，还要把数据写入文件</p></blockquote></li><li><p>C 是一门强大且灵活的语言，有许多用于打开，读取，写入和关闭文件的库函数</p><blockquote><p>从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件<br>这些直接调用操作系统的函数被称为底层 I/O (low-level I/O)<br>由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做<br>然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件<br>这涉及创建用于处理文件的标准模型和一套标准I/O函数<br>在这一层面上，具体的C实现负责处理不同系统的差 异，以便用户使用统一的界面</p></blockquote></li></ul><p><strong>有关 I/O 的差异问题:</strong></p><ul><li><p>例如，不同的系统储存文件的方式不同</p><blockquote><p>有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处<br>而有些系统在文件中创建一份文件描述</p></blockquote></li><li><p>在处理文件方面</p><blockquote><p>有些系统使用单个换行符标记行末尾<br>而其他系统可能使用回车符和换行符的组合来表示行末尾</p></blockquote></li><li><p>文件大小方面</p><blockquote><p>有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量</p></blockquote></li><li><p>如果使用标准I/O包，就不用考虑这些差异</p><blockquote><p>此时可以使用<code>if(ch == &#39;\n&#39;)</code>来检查换行符<br>即使用系统实际用的是回车符和换行符的组合来标记行末尾<br>I/O函数会在两种表达式法之间相互转换</p></blockquote></li><li><p>从概念上看，C程序处理的是流而不是直接处理文件</p><blockquote><p>流(stream)是一个实际输入或输出映射的理想化数据流<br>这意味着不同属性和不同种类的输入，由属性更统一的流来表示<br>于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成</p></blockquote></li><li><p>这里着重理解 C 把输入和输出设备视为存储设备上的普通文件</p><blockquote><p>尤其是把键盘和显示设备视为每个C程序自动打开的文件<br>有关对于文件的深入讨论这里不做多余赘述</p></blockquote></li><li><p>stdin流表示键盘输入，stdout流表示屏幕输出</p><blockquote><p>getchar()，putchar()，printf()和scanf()函数都是标准I/O包的成员，负责处理这两个流<br>以上的内容则说明了可以用处理文件的方式来处理键盘输入<br>例如， 程序读文件时要能检测文件的末尾才知道应在何处停止<br>因此，C 的输入函数内置了文件结尾检测器<br>既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入<br>下面会从文件开始讨论如何结束文件</p></blockquote></li></ul><hr><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><ul><li><p>计算机操作系统要以某种方式判断文件的开始和结束</p><blockquote><p>检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾<br>CP/M，IBMDOS和MS-DOS的文本文件曾经用过这种方法<br>如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾<br>这曾经是操作系统使用的唯一标记， 不过现在有一些其他的选择，例如记录文件的大小<br>所以现代的文本文件不 一定有嵌入的Ctrl+Z<br>但是如果有，该操作系统会将其视为一个文件结尾标记</p></blockquote></li><li><p>以下图片演示了这种方法:</p></li><li><p>带文件结尾标记的文件:</p></li></ul><img src="/images/数据类型-8/带文件结尾标记的文件-1.png" width="40%" height="40%"><hr><ul><li><p>操作系统使用的另一种方法是储存文件大小的信息</p><blockquote><p>如果文件有3000字节，程序在读到3000字节时便达到文件的末尾<br>MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z<br>新版的DOS也使用这种方法处理文本文件<br>UNIX使用这种方法处理所有的文件<br>无论操作系统实际使用何种方法检测文件结尾<br>在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值<br>即EOF(end of file的缩写)<br>scanf()函数检测到文件结尾时也返回EOF<br>通常， EOF定义在stdio.h文件中:<br><code>#define EOF (-1)</code></p></blockquote></li><li><p>为什么是-1?</p><blockquote><p>因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集<br>但是，如果系统能识别扩展字符集，该函数的返回值可能在 0～255之间<br>无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 文件结尾<br>某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同<br>如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题<br>这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号</p></blockquote></li></ul><p><strong>关于如何在程序中使用EOF</strong></p><ul><li><p>把getchar()的返回值和EOF作比较</p><blockquote><p>如果两值不同，就说明没有到达文件结尾<br>也就是说，可以使用下面这样的表达式:<br><code>while ((ch = getchar()) != EOF)</code><br>如果正在读取的是键盘输入不是文件的情况:<br>绝大部分系统(不是全部)都有办法通过键盘模拟文件结尾条件</p></blockquote></li><li><p>这里以该程序举例(echo_eof.c):</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ch;</span><br><span class="line">	<span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line">		<span class="built_in">putchar</span>(ch);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在使用EOF时需要注意下面几点:</li></ul><ol><li>不用定义EOF，因为stdio.h中已经定义过了</li><li>不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值</li><li>变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数<blockquote><p>但是EOF的值是-1<br>还好，getchar()函数实际返回值的类型是 int，所以它可以读取EOF字符<br>如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式</p></blockquote></li><li>由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据<blockquote><p>ch是整数不会影响putchar()，该函数仍然会打印等价的字符<br>使用该程序进行键盘输入，要设法输入EOF字符<br>不能只输入字符 EOF，也不能只输入-1(输入-1会传送两个字符: 一个连字符和一个数字 1)</p></blockquote></li><li>正确的方法是，必须找出当前系统的要求<blockquote><p>例如，在大多数UNIX和 Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号<br>许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号<br>一些系统把任意位置 的Ctrl+Z解释成文件结尾信号</p></blockquote></li></ol><ul><li><p>下面是在UNIX系统下运行echo_eof.c程序的缓冲示例:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Lord　<span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">Lord　</span><span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">[Ctrl+D]</span></span><br></pre></td></tr></table></figure></li><li><p>每次按下Enter键，系统便会处理缓冲区中储存的字符</p><blockquote><p>并在下一行打印该输入行的副本<br>这个过程一直持续到以UNIX风格模拟文件结尾(按下Ctrl+D)<br>在PC中，要按下Ctrl+Z</p></blockquote></li><li><p>既然<code>echo_eof.c</code>程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么</p><blockquote><p>假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止<br>或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据<br>用<code>echo_eof.c</code>来储存在文件中输入的内容<br>假设同时使用这两种方法: 把输入从一个文件定向到<code>echo_eof.c</code>中，并把输出发送至另一个文件<br>然后便可以使用<code>echo_eof.c</code>来拷贝文件<br>这个小程序有查看文件内容，创建一个新文件，拷贝文件的潜力<br>关键是要控制输入流和输出流</p></blockquote></li><li><p>注意模拟EOF和图形界面</p><blockquote><p>模拟EOF的概念是在使用文本界面的命令行环境中产生的<br>在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号<br>但是在一些实际应用中，却不能很好地转换成图形界面(如Windows和Macintosh)<br>这些用户界面包含更复杂的鼠标移动和按钮点击<br>程序要模拟EOF的行为依赖于编译器和项目类型<br>例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的 设置</p></blockquote></li></ul><hr><p><strong>待补充</strong></p><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><hr><h3 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h3><ul><li><p>输入和输出涉及函数，数据和设备</p><blockquote><p>例如，假设某一个程序内使用输入函数getchar()用作被设定内容的输出方法<br>输出设备这里将其假设为键盘，输入数据流由字符组成</p></blockquote></li><li><p>假设此时希望输入函数和数据类型不变，仅改变程序查找数据的位置</p></li><li><p>程序判断查找输入的位置的方法与逻辑:</p><blockquote><p>在默认情况下，C程序使用标准I/O包查找标准输入作为输入源<br>即为stdin流，它是把数据读入计算机的常用方式<br>它可以是一个过时的设备，如磁带，穿孔卡或电传打印机<br>或者(假设)是键盘，甚至是一 些先进技术，如语音输入<br>然而，现代计算机非常灵活，可以让它到别处查找输入<br>尤其是，可以让一个程序从文件中查找输入，而不是从键盘</p></blockquote></li><li><p>程序可以通过两种方式使用文件</p><blockquote><p>第一种方法:<br>显式使用特定的函数打开文件，关闭文件，读取文件，写入文件，诸如此类，这里不对此种方法进行过多赘述<br>第二种方法:<br>设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出<br>换言之，把stdin流重新赋给文件<br>继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么 位置获取数据<br>虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，一般会用于普通的文件处理技术<br>重定向的一个主要问题与操作系统有关，与C无关<br>尽管如此，许多C 环境中(包括UNIX，Linux和Windows命令提示模式)都有重定向特性<br>而且一些C实现还在某些缺乏重定向特性的系统中模拟它<br>在UNIX上运行苹果 OS X，可以用UNIX命令行模式启动Terminal应用程序</p></blockquote></li></ul><hr><h3 id="UNIX-amp-Linux-amp-Windows-重定向"><a href="#UNIX-amp-Linux-amp-Windows-重定向" class="headerlink" title="UNIX&amp;Linux&amp;Windows-重定向"></a>UNIX&amp;Linux&amp;Windows-重定向</h3><p><strong>UNIX</strong></p><ul><li>UNIX(运行命令行模式时)，Linux(ditto)和Window命令行提示(模仿旧式DOS命令行环境)都能重定向输入，输出<blockquote><p>重定向输入让程序使用文件而不是键盘来输入<br>重定向输出让程序输出至文件而不是屏幕</p></blockquote></li></ul><ol><li>重定向输入</li></ol><ul><li><p>假设已经编译了<code>echo_eof.c</code>程序，并把可执行版本放入一个名为<code>echo_eof</code>(或者在Windows系统中名为<code>echo_eof.exe</code>)的文件中</p><blockquote><p>运行该程序，输入可执行文件名: <code>echo_eof</code><br>该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入<br>现在，假设要用该程序处理名为words的文本文件<br>文本文件(text file)是内含文本的文件，其中储存的数据是人类可识别的字符<br>文件的内容可以是 一篇散文或者C程序<br>内含机器语言指令的文件(如储存可执行程序的文 件)不是文本文件<br>由于该程序的操作对象是字符，所以要使用文本文件<br>只需用此命令代替上面的命令即可: <code>echo_eof &lt; words</code><br>符号是UNIX和DOS/Windows的重定向运算符<br>该运算符使words文件与stdin流相关联，把文件中的内容导入<code>echo_eof</code>程序<br><code>echo_eof</code>程序本身并不知道(或不关心)输入的内容是来自文件还是键盘<br>它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾<br>因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备</p></blockquote></li><li><p>重定向需要注意的几点</p><blockquote><p>对于UNIX，Linux和Windows命令提示，&lt;两侧的空格是可选的<br>一些系统，如AmigaDOS(那些喜欢怀旧的人使用的系统)，支持重定向<br>但是在重定向符号和文件名之间不允许有空格</p></blockquote></li><li><p>下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示符</p><blockquote><p>在Windows/DOS系统中见到的DOS提示可能是A&gt;或C&gt;</p></blockquote><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ echo_eof &lt; <span class="built_in">words</span></span><br><span class="line">The world <span class="keyword">is</span> too much <span class="keyword">with</span> us: late <span class="keyword">and</span> soon,</span><br><span class="line">Getting <span class="keyword">and</span> spending, we lay waste our powers:</span><br><span class="line">Little we see <span class="keyword">in</span> Nature <span class="keyword">that</span> <span class="keyword">is</span> ours;</span><br><span class="line">We have <span class="keyword">given</span> our hearts away, a sordid boon!</span><br><span class="line">$</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li>重定向输出</li></ol><ul><li>现在假设要用<code>echo_eof</code>把键盘输入的内容发送到名为mywords的文件中<blockquote><p>然后，输入以下命令并开始输入:<br><code>echo_eof &gt; mywords</code></p><blockquote><p>符号是第2个重定向运算符<br>? 它创建了一个名为mywords的新文件，然后把<code>echo_eof</code>的输出(即为人为去输入字符的副本)重定向至该文件中<br>重定向把stdout从显示设备(即为显示器)赋给mywords文件<br>如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容(但是，许多操作系统有保护现有文件的选项，使其成为只读文件)<br>所有出现在屏幕的字母都是人为进行输入的，其副本储存在文件中<br>在下一行的开始处按下Ctrl+D(UNIX)或Ctrl+Z(DOS)即可结束该程序<br>还有一点就是必须在每行的末尾单击Enter键才能把缓冲区的内容发送给程序</p></blockquote></blockquote></li></ul><hr><ol start="3"><li>组合重定向</li></ol><ul><li><p>现在假设希望制作一份mywords文件的副本，并命名为savewords</p><blockquote><p>只需输入以下命令即可:<br><code>echo_eof &lt; mywords &gt; savewords</code><br>下面的命令也起作用，因为命令与重定向运算符的顺序无关:<br><code>echo_eof &gt; savewords &lt; mywords</code><br>注意: 在一条命令中，输入文件名和输出文件名不能相同<br><code>echo_eof &lt; mywords &gt; mywords....&lt;--错误</code><br>原因是&gt; mywords在输入之前已导致原mywords的长度被截断为0</p></blockquote></li><li><p>总之，在UNIX，Linux或Windows/DOS系统中使用两个重定向运算符(&lt;和&gt;)时，要遵循以下原则:</p><blockquote><p>重定向运算符连接一个可执行程序(包括标准操作系统命令)和一个数据文件<br>不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序<br>使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件<br>通常，文件名和运算符之间的空格不是必须的<br>除非是偶尔在UNIX shell，Linux shell或Windows命令行提示模式中使用的有特殊含义的字符<br>例如刚才的<code>echo_eof&lt;words</code></p></blockquote></li><li><p>以上介绍的都是正确的例子，下面来看一下错误的例子:</p><blockquote><p>addup和count 是两个可执行程序，fish和beets是两个文本文件:</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">fish &gt; <span class="keyword">beets	</span>	←违反第<span class="number">1</span>条规则</span><br><span class="line"><span class="keyword">addup </span>&lt; <span class="built_in">count</span>		←违反第<span class="number">1</span>条规则</span><br><span class="line"><span class="keyword">addup </span>&lt; fish &lt; <span class="keyword">beets	</span>←违反第<span class="number">2</span>条规则</span><br><span class="line"><span class="built_in">count</span> &gt; <span class="keyword">beets </span>fish		←违反第<span class="number">2</span>条规则</span><br></pre></td></tr></table></figure></li><li><p>UNIX，Linux或Windows/DOS还有&gt;&gt;运算符，该运算符可以把数据添加到现有文件的末尾</p><blockquote><p>而 | 运算符能把一个文件的输出连接到另一个文件的输入<br>其它更加深入的内容可参考书籍: UNIX Primer Plus，Third Edition(Wilson，Pierce和Wessler合著)</p></blockquote></li></ul><p><strong>其它内容:</strong></p><ul><li><p>绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序</p><blockquote><p>或只在C编译器允许的情况下重定向C程序<br>假设prog是可执行程序名，file1和file2是文件名</p></blockquote></li><li><p>把输出重定向至文件: &gt;</p><blockquote><p><code>prog &gt;file1</code></p></blockquote></li><li><p>把输入重定向至文件: &lt;</p><blockquote><p><code>prog &lt;file2</code></p></blockquote></li><li><p>组合重定向:</p><blockquote><p><code>prog　&lt;file2　&gt;file1</code><br><code>prog　&gt;file1　&lt;file2</code></p></blockquote></li><li><p>这两种形式都是把file2作为输入，file1作为输出</p></li><li><p>一些系统要求重定向运算符左侧有一个空格，右侧没有空格</p><blockquote><p>而其他系 统(如UNIX)允许在重定位运算符两侧有空格或没有空格</p></blockquote></li></ul><hr><p><strong>关于创建更友好的用户界面:</strong></p><ul><li>大部分人偶尔会写一些中看不中用的程序<blockquote><p>还好，C提供了大量工具让输入更顺畅，处理过程更顺利<br>不过，学习这些工具会导致新的问题<br>最基本的要求是让交互数据输 入更方便<br>并且减少错误输入的影响</p></blockquote></li></ul><hr><p><strong>关于使用缓冲输入:</strong></p><ul><li>缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入<blockquote><p>但是，在使用输入的字符时，它也会给程序员带来麻烦<br>一般的缓冲输入会要求用户按下Enter键发送输入<br>但同时这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符</p></blockquote></li></ul><hr><p><strong>关于混合数值和字符输入:</strong></p><ul><li><p>假设程序要求用getchar()处理字符输入，用scanf()处理数值输入</p><blockquote><p>这两个函数都能很好地完成任务，但是不能把它们混用<br>因为getchar()读取每个字符，包括空格，制表符和换行符<br>而scanf()在读取数字时则会跳过空格，制表符和换行符</p></blockquote></li><li><p>要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格</p><blockquote><p>另外，如果该程序不在getchar()测试时<br>而在scanf()阶段终止程序会更好</p></blockquote></li></ul><hr><p><strong>关于输入验证:</strong></p><ul><li>在实际应用中，用户不一定会按照程序的指令行事<blockquote><p>用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败<br>作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误<br>这样才能编写出能检测并处理这些问题的程序</p></blockquote></li></ul><hr><h3 id="输入流和数字"><a href="#输入流和数字" class="headerlink" title="输入流和数字"></a>输入流和数字</h3><ul><li><p>在编写处理错误输入的代码时应该很清楚C是如何处理输入的</p></li><li><p>考虑下面的输入:</p><blockquote><p><code>is 28 12.4</code><br>在人类的眼中，它就像是一个由字符，整数和浮点数组成的字符串<br>但是对 C 程序而言，这是一个字节流<br>第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等<br>所以，如果<code>get_long()</code>函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字<br>因为这些数字只是该输入行中的其他字符:</p></blockquote><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">while ((<span class="name">ch</span> = getchar()) != '\n')</span><br><span class="line">putchar(<span class="name">ch</span>)<span class="comment">; // 处理错误的输入</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值</p></blockquote></li><li><p>例如，考虑下面的输入:</p><blockquote><p><code>42</code><br>如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中<br>如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中<br>如果使用%d转换说明，scanf()同样会读取两个字符<br>但是随后会计算出它们对应的整数值: 4×10+2，即42，然后将 表示该整数的二进制数储存在int类型的变量中<br>如果使用%f转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0<br>用内部的浮点表示法表示该值，并将结果储存在float类型的变量中</p></blockquote></li><li><p>简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值</p><blockquote><p>使用转换说明(如%d或%f)限制了可接受输入的字符类型<br>而getchar()和使用%c的scanf()接受所有的字符</p></blockquote></li></ul><hr><p><strong>关于菜单浏览:</strong></p><ul><li><p>许多计算机程序都把菜单作为用户界面的一部分</p><blockquote><p>菜单给用户提供方便的同时，却给程序员带来了一些麻烦</p></blockquote></li><li><p>将会涉及的问题:</p></li><li><p>菜单给用户提供了一份响应程序的选项</p><blockquote><p>假设有下面一个例子:</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Enter the letter of your choice:</span><br><span class="line">a. advice <span class="keyword">b. </span><span class="keyword">bell</span></span><br><span class="line"><span class="keyword">c. </span><span class="built_in">count</span> q. quit</span><br></pre></td></tr></table></figure></li><li><p>理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务</p><blockquote><p>作为一名程序员，自然希望这一过程能顺利进行<br>因此，第1个目标是: 当用户遵循指令时程序顺利运行<br>第2个目标是: 当用户没有遵循指令时，程序也能顺利运行<br>显而易见，要实现第2个目标难度较大，因为很难预料用户在使用程序时的所有错误情况<br>现在的应用程序通常使用图形界面，可以点击按钮，查看对话框，触摸图标<br>而不是示例中的命令行模式<br>但是，两者的处理过程大致相同: 给用户提供选项，检查并执行用户的响应，保护程序不受误操作的影响<br>除了界面不同，它们底层的程序结构也几乎相同<br>但是，使用图形界面更容易通过限制选项控制输入</p></blockquote></li></ul><hr><p><strong>关于任务</strong></p><ul><li>这里将更具体地分析一个菜单程序需要执行哪些任务</li><li>它要获取用户的响应，根据响应选择要执行的动作<blockquote><p>另外，程序应该提供返回菜单的选项</p></blockquote></li><li>C 的switch语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签<blockquote><p>使用while语句可以实现重复访问菜单的功能<br>因此写出以下伪代码:<br>获取选项<br>当选项不是’q’时<br>转至相应的选项并执行<br>获取下一个选项</p></blockquote></li></ul><hr><p><strong>关于让使执行更顺利</strong></p><ul><li><p>当决定实现某个程序时</p><blockquote><p>就要开始考虑如何让程序顺利运行(顺利运 行指的是，处理正确输入和错误输入时都能顺利运行)<br>例如，能做的是让”获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch<br>这表明需要为输入过程提供一个只返回正确响应的函数</p></blockquote></li><li><p>混合字符和数值输入会产生一些问题，创建菜单也有这样的问题</p></li><li><p>还要注意在处理较复杂的任务时，如何让函数把任务委派给另一个函数</p><blockquote><p>这样让程序更模块化</p></blockquote></li></ul><hr><p><strong>关键概念:</strong></p><ul><li><p>C程序把输入作为传入的字节流</p><blockquote><p>getchar()函数把每个字符解释成一个字符编码<br>scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值<br>许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出</p></blockquote></li><li><p>程序通常接受特殊形式的输入</p><blockquote><p>可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况<br>让程序更强健更友好</p></blockquote></li><li><p>对于一个小型程序，输入验证可能是代码中最复杂的部分</p><blockquote><p>处理这类问题有多种方案<br>例如，如果用户输入错误类型的信息，可以终止程序<br>也可以给用户提供有限次或无限次机会重新输入</p></blockquote></li></ul><hr><p><strong>本章小结:</strong></p><ul><li><p>许多程序使用 getchar()逐字符读取输入</p><blockquote><p>通常，系统使用行缓冲输入， 即当用户按下Enter键后输入才被传送给程序<br>按下Enter键也传送了一个换行符，编程时要注意处理这个换行符<br>ANSI C把缓冲输入作为标准</p></blockquote></li><li><p>通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同文件形式，是C语言的特性之一</p><blockquote><p>getchar()和scanf()函数也属于这一系列<br>当检测到文件结尾时，这两个函数都返回EOF(被定义在stdio.h头文件中)<br>在不同系统中模拟文件结尾条件的方式稍有不同<br>在UNIX系统中，在一行开始处按下Ctrl+D可以模拟文件结尾条件<br>而在DOS系统中则使用Ctrl+Z</p></blockquote></li><li><p>许多操作系统(包括UNIX和DOS)都有重定向的特性，因此可以用文件代替键盘和屏幕进行输入和输出</p><blockquote><p>读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号，或者用于重定向文件<br>混合使用getchar()和scanf()时，如果在调用getchar()之前，scanf()在输 入行留下一个换行符会导致一些问题<br>不过，意识到这个问题就可以在程序中妥善处理</p></blockquote></li><li><p>编写程序时，要认真设计用户界面</p><blockquote><p>事先预料一些用户可能会犯的错误<br>然后设计程序妥善处理这些错误情况</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>时间-1</title>
    <url>/2020/03/15/%E6%97%B6%E9%97%B4-1/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="1e21f81d830478451ab63f438cd662ef35255d39e958191606f76d01fb97b0ea">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98a62b73e77af59b9cd3454122c1346448074168c988fe0e33b625d06400df3f78fc4a87f846afa70aefd1c403d0e13605c4bce5de651a0842f943d7167d9920047b4de52c3b7581d3d85a379edd6972074d02a2db031f367601791f4a6f0aff711c83caa86aa5b637945d3df6a6b317e392d0db246bbacb41987b5b1741c9c37a26ce7bb04077c07d1fa590e516919d0c06582b3c087b57819f8324be3ebdd5fb6e6b3508685652df38c4c9522ecdf2638a622fc55920b7fb0d843ba6591b627ea878b1200a6ff3e981e96416b4d8b1a283b9172e1bfb6d102aec191174f884fe13baa17de3c1d3201dea6daee52744e83ee0c518aeaaba3bab81213e65f37121130908d356a7dddf857467b315e90609472cb6d6d2493bf110ed74f1feacba2131a35282dabb80a4d3f159b84c84eaf63336736c8cab3e8fa2995590ca481c16e2178530e751ca08c3018645328317c2d03237c5f4b577cb5941d691363e7dcaaf8597ef2a29560b515e8e18aa8be404ba96ae3a1c12017fb4cdca58f27c751032033d4ec14886ad25ffce845cdc8fd726c9230b3b54a8f0aece6fb8da3d8190a605acdf2feb3846882425d1c2126f8bcaea1c2743afbdc2e30a182ffcc5552ee9afbd354ca05fc38bb79beb51ffa5b9d27f42ae7f47dad62631f84bc72fdd9bf6947f80506599265e47ae180b01196d470230bb207c1db4f0702827b1d8009367689418b9fcff526b30a25ce3e434cd92e3ee2267e27585130bd51542e7acaad36f95087be2a85fefac1be66e087028565cb322d7086ac7bd6da0a62c600933324f1a336103ef0b25eefbf3904c79ace1ec1c471527c86db545e288db84639f321a3008621f37500488bf7651353536cd420512862f75a4703ddd2120b452658a7b05a22f499ba084e916cdd3a3919c6eea5e5d9f77db126aeca194ee5f1d635cf0aa790c3872863e0e10a06dc29d5b45295c70e2a6b42ff246de3bdec7016881851d3b2c6255eb4c3516f8aeade02abca9917eea16e791f78540adcebd874bb6f3d2d869aa6fc4199202acee7f4a90352b5567334824aae1a350b5659cbb0b33807419e5b493d6b903f4d7460fe305f8dbb1e9431df9cb8976064af6866696411d151f809ac84fef89afdbbca3d2456f950d82a2b8455e401e1a0b0b9d9f6f864b750c56e0453719f23cc6fd6e7e74883e8b23c164058417fd3ad2cf8e8f18379ed70cfd0dfcc40670fa268d67d5b98bf427259983610c2df8a61bad29fa51e62899a249752bddf7ecfb577980cc684a7fad0ffc7bd186835aa078375fac0f12024abdf3103943227c4bc33d1d39d02dd27f2d0a09da4eb9e16283741f522fb5a79ecc1c05f99d188e7152d20cd8dbd0c431f42d2768dc4b38861d3826116b8dbb31bb62d8cf7518a8836e6adf23935cacac4c17f1062cfaf1f3183d1c5aa49ae96f5fb5c43e87ddb25e0bb816b5a57d0713c5a7d6aea43796d317f4cfa8c06418ad8f2b3a953186b0a491572f1bffc1e03ad2378f5116d5c9ce8e56777e719e4502230eff0b495c97c0a6cf7b0452be3107566d480edd8ca2131cb3ce24d654d4cf460d175ca0afaac313aab64d179e709a9ea75e52fa35f6d3631f7312cccc9f33299288e7de015737f57288c089cf1ccf721f7f41f1aaa88acbd5fe4ca658f44ae61e8698cbb3794bf34b8a3ee88f39bd935a5ee5caf724878588d1e77ae1ae49250295cd5ce2fdabcd39aec45f01442a72a4d55f8ed956c534a117bc32a47702523fc0320c90159ea6433d6a8ecf22a77355fe32a2bb46c83864cd4825551bf2cf86202484e20bba6b927e94b9bd74a25d011b15491f45c98880a5f99ce26fcf1bf9297c54595159c824f6825b7e9de0c53477b2232b32a4e5daecd8021aa40dc345f9a8cb5b104bcdbfed98db6d032f4d0e797a01ab068cfe535f7bacc1f8d1e874f69d51e3e787f10344834cc927cfa6b71002baf7d584bfc7d2d2d6463255af4ce2e10331e8fb2a91efa83569e528b80ce51063e5a7961dd4218dbe0a5dd22a73e8186f0d905ae90e5743bf16066ebd89e1488782d3a445457dd2b01cdede2d6167c21ed678faf35d63af7a271cc1f463203aee772e0d758a954859c8f7640e25f2cd072444ff2c340f5b637b16178580f3288ddcce18c3c6b86ad50ad7aa9903a3e1298769665b3fbf35832632198b49a3f5ed3ed779ce21a211731f6360531bfed46cab66052c43d4bd2964aa23bcfe4a639a6e097a1b1d25b7bea177e20590a0fc161fbb232b2f9fb7fe85bb00aa8266e3b566030ea564dc306757853ad2a54fbae5b99ae05248ca8c374c228a9e33f0b2fd221d49b6fd4b81db238c95dc62c272fe822d30fbe596b1ae12b7c07f3f79cfad05f41dd9ff08aa22549b469ed355be74e421e20bf850797544e19a93c2d8f69e2e644079758977f4f9a6bd428c0cda664351e455e03dab299b03717bb718d3db985feac86eba29bc908cb7fc788ab2c1aa80506ffd616d302e7a5eb3e60f3e472802abe96ac1f3fab556ec796628c75893de11239055f929e01e789b2cf6e4e5314ff13c045be12c3ca8ebf0fc6684873bb4697bfc9424f911f035ea4eebe49369c514dc11e363151cba68e08a9616caef0821146e4bc04cbc634976e6809374478601f8c10d206dc45300f494bd2037a93e2d31b8476792a29ee3e9d7cbda8c8cb5bd71d32475b97c9c0ada122f4f88826e4614a21fd35f19c059b3c2c75b73ad9bfe137471a64fa2422216e080aa466352b269ca08d02e20052ab66fcd34ce8b5f162755a228dffc13126a0a39fabd56d93a72952d80eda1ea0b055034eb769f5f3d73cd67154dcbfbe8a20dd63ada28dd958d07e07ffa59c1009b26afe841f4370d4fa0b31bdc68b0927976fadd68f894dd04361bb7784a958458f09b66cb356eb8c4587a1de4b30e6fc3a6ef16d71e2df8bcd26ec0c7224cae2caecc8262a0a313fdecd785ab73e382c69105bd582a24631b9c55b4b753897b1a639aba323b7ced8a59d1bb708dda908b442226dca9ed8fa40bd6fbd840a80b75962d95b54b995ff5319da730675ba3f92431a7c0641684f188c1ba04f94b29f27cf0f824538e534fcea62efb459af42c29030c7429fef17b719a5ed97bb3edfd70f090069ddd2eccfa38644dd4fafb2d008d72b93f39386812383494b1d68de06647ccac4388bb72c50f0ac36d852b413a621c36b306203087c0073b012ea4e2bda3b8beace60282f10af11164172ef204eb1a95136e1092c74b5466ef08063cac36478183b6a991cbcd30cd6ca572598f8db2488909cabe77cd21c6adb87f0385c221ba5a4e09662facd5af79050dd93c86fb6d7ed49b24152f4f03ee669540c52b714fd95905135639b9dc8c9353c02b2cf75d6c6e0a789641c26c4d9b0e00713c0669049c3886b95b26bfbfdc84ce253368f48d0e88ba27188f5096da3d919db51e906069bc4b1cb800ca534a2396f245ff1877500e3201a0d6b0bca76104a3298961a57f22c27d690ccaa56e8a1aee1fbd3a705218dc0159d5cf755010077aa5be7c87957632b2fbf1c8a5080985ef02ba89a0703f8ee4b2da5f986e78d30be0e348e0690118e8151e44e41700b6bb2cf178099ccba10cfd40ef90dd9bda9e4ea9256ae559447e2a09111e06a83970e08df7fdc0f4cabc1b83efc742eb38d789281afd290d372518127055c256696b901326e58f2fc48b3c2c85d83061ee10199087d2e9458a954b3cb126156a2ad562ef52cba8a3e02f8e4ceb38c62f73f287b149f86957eaf56eb3c6b81c7d560b89d9f72bfbae15db3ac0f326876543e20658f40f1a80acac9d8185a0f6791ebbbe2b4be599a34aa61c831c4f0749097c0e54c1e6aca28849cf274e3937ee5bb8cd12a923e518a03188d32ce895ea8821adcba9abcc1390d3f519ff912dfe1ab7b01ac18457cad6d7cd4bbe2afe91450f6675db19e67b08537be530febd23f046ed35aeb1c09059ab186bd293671d6e333ac6429a2f7472e388c535b03917156073d25280e729b9945067f0798c3137ad7197df179670f6be5f1146e906b10cc0708dffd633b31b1e9e5456f6112551ce7b0668fb290e91b8979d680551f9414332f46c4d77ce122a12be465c612d5926f7e06386516921fbf22b5619505b38cf3e75218049e136980fd51fa0a74c1978a735dda2abb868c73686ac5</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>无</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-永驻</title>
    <url>/2020/03/15/%E9%9A%8F%E7%AC%94-%E6%B0%B8%E9%A9%BB/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="e1e9d050c57dc6aed9cb50b87a6af810eeb46ece5014e353c9866f4059545448">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e4b111f26008856c0c71c2ee88709c9d3fca2aa2ef07e8647af39698611e12a42d264395d4770391c21c34c0a0db83d500093e747a2396d36a455924b65eea808fef3e1845a1d53ecc278a5af52b7de8f30a783f6fb2b1a670a2e367d804075451f848830bd63fccd36e7f238aa298cc8438b2feb96270df88f9e038a3ca63f240ade0670624cb0dddb8639d87ac0e1dc526ed9db7472e8581a5656d088db7511a8248f2443b6403699af9a699b7947a35ccc2ca4df8a41a2bb7d3b8609dc069d7710ed11c25c526add731c1dce2a0b481c65a317b791f0cf8984ffa072a41e8da1a97455d9a3238b343a0d89e114e88bb8c8ba976cebe32602453685993472d64a3efc51132f77e51b1120d50541854eee2861c5a7b88e6cdf1fdeeee5844ffe52e7aba36e36bfb84e63ed8fc1cf0053b8579859a29fdf93bb7de80d9dac5bd41d4955605bf1f386426a2141b52219655503f1f199284081e551b0d1f1bc3304429b5e339a3e7790043c36e97aefc640021935f364ee237c7310bde415fe4f8a5bba43fb17537ce3dc83d2806be5bce554486e02d5e1a54807d2da36273877eb081b8ab2d1e0df267042555a365c16b9335dccceaea1d333597ad41bdbceb908c72540f9abad51342d398e84b512a45d2155fffeaf568da892e8f857f536cd87a3af6ea3b21bb5b40371f48b9f0abad76a5632eb2601f7de16c9d6b95699ee444a2eb2b5bf397d33f0349427a4be52fcf37c598a5305720cf3e5031eabe2c10f99b75ee51c7902d1bfc89871e3c52ebed6ddb0a5a3d84028835b00d30a290ec893f0e55ea1ed9d92b2daa353a28865fb24e49d091e4a53093989127a6cf12175de6f9da26e40d82a460dd501831e5466023434fbb6f888fd24b91f40fdd0b08d7c403d8d25fe76c6842422dda27c9abfeb7f1b7724fb6d238d248a3d964dd93da7f69a77bd518b99f58ddc30fbaa68be55111fdc90f171258d4793da1b6422074d2a52bb03ec506df54aad9b99326816ada7431b2f44879cb41397fbf89cabb63cd9e0db420c249d3713e3cdaf117cbe5b87c95e1fa1734fd1e00c04b617e38044e302531905ff3c286678399eb7031a9a27cbc6a23f90ee7a07bdd87e67b17f3edfbdd611222997c54c0979b205b8850ff4764ecbe9102d041d8547fbb726534e66a3a7a2f8ca09e65bb307871450a7b15c9448852a41dec6fbbb09e926bdd63ec32bcc6f0fb12baa9d30000166ba2d2afd67c69dc3c49c1b67f2c00a15cb03f07a59aaf4d9a67620897603705d634de329a95ebabdc687fb5d41621f11d201ae70fba0af13ef8fad52a45dcc382208478642c3612198e4013f89f419822c1686a09c6a17dddbc35e6b5f420a029a92988bae4792d5798a7aba727b1251852ebc7e48883a5d6170bc6c6d76878b3be1ab6d8c630a4ab7a48016df086a56e3b5fb1c72e366380cd6d831dbfbfe69a470578e77c9e47946fa1e5eebbb2470d686d44d2493c3cbad54b3d478b6bf6a4f6e4920d117f13b621f0436018d727dd5c195abb5343c2030c13606c68bc55ad6c6d981c0ffc526858e9239e3080f11013c3b2c785b433857ff1030041ad02d5ece7793d06d9149536474dde8a4370479fe3d0cc62e1d20f1e1165715d77abba2463483648e0dc04f7a4cda3cc021b8fde2088bd5a80d68b504de94e02ac26a74d431890e7afcc1683a1651beb82af5edf387362300cac61a3a1202e8da019daaf10356dc760bd7be59209d6e8dca6da7e34d72327bff05e8b3fca73bb2da86d98d9fda452caf7d8bfbb8bd0c41d3673e5f51e3de13f1e00fb7ca0c4c07f9f16099dd31e5876bcda0dca3400846508e03e75b50676b8cd0adee37f70c6bd5d1b2fc9a08fc868a12a8571a2eb96f5014f8d55a331bb110a74e98ef9b055015e3203b24a5cf9eff64d46395b7112e46a614eee5db4092560328040c2bda6aecb48bebad830e500e6e3c8cdb56a3a337fac42d4e477a168a4e5da642dd7d86d1f2d64e63e9a5bcf21ae25cfc6bd6c0edeeb6769ab093e26a77df6c40980cebfd67d9b59514f8ccd4714dff7769e92a5e302b3c9ea01b0b1bc4b1f5529327599509e119c421184dde32fbda898bd8eaf0dda8952821a2171518b9e97dfddd652889e9063d99b87a7be00e24e8cbe934ba7c80dd47d8ef4f2a0ea095dc5442f45df0d6d14924a667131203f55cd4c4338ada69a43af9924d34185d8c2e46493ef9187b60c00fc9bfd135dfe902bab31c495b46f23a77f80f3234ef4a9be073b1a9a4b549c7aad37b908be7c9ee9b3de0239274ff67a11de70378d1cede10b8239203f87e85a59d9cfd4d3c9c200db1f22d8178e5595d03b5d92aa39945e2f032687b7852b720abc9a81c02a6fadaa16ce0c6153ac3295d842bbd75dad08affd10511f30044044505ed20704df8f3268e33dff8015a46755a3be119d6162f7d25236a7130bc58aa5d4f8d4c886e1763e795c3378756a1aeeda4656053b862781eeef56854caa35b0f46a7e7d63f3a0775d2d353348b13585fb7abed8a2d58726f011ad5e05fc96c3c9e3c05db482d26a0b87469e062ec72394c7190e0e6ee67a124dee888</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>无</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Coding-1</title>
    <url>/2020/03/15/coding-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>ASCII-1</strong></center><a id="more"></a><h3 id="编码-coding-1"><a href="#编码-coding-1" class="headerlink" title="编码(coding)-1"></a>编码(coding)-1</h3><ul><li>ASCII (American Standard Code for Information Interchange)</li><li>美国信息交换标准代码</li><li>美国标准信息交换代码是由美国国家标准学会 (American National Standard Institute/可简称为ANSI)所制定的标准</li><li>是一种标准的单字节字符编码方案，用于基于文本的数据</li><li>后来它被国际标准化组织 (International Organization for Standardization)，可简称为ISO，定为国际标准，称为ISO 646标准</li><li>适用于所有拉丁文字字母</li><li>ASCII标准表可参考下方文献</li><li>其存在的目的是为统一计算机领域的所有编码规则</li></ul><p><strong>编码</strong></p><ul><li>在计算机中，所有的数据在存储和运算时都要使用二进制数表示(因为计算机用高电平和低电平分别表示1和0)</li><li>例如，像a，b，c，d这样的52个字母(包括大写)以及0，1等数字还有一些常用的符号(例如<code>*</code>，<code>#</code>，<code>@</code>等)在计算机中存储时也要使用二进制数来表示</li><li>而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套，即为编码</li></ul><hr><ul><li>ASCII码使用指定的7位或8位的二进制组合来表示128或256种可能的字符</li><li>标准ASCII码也叫基础ASCII码，使用7位二进制数(剩下的1位二进制为0)来表示所有的大写和小写字母，数字0到9，标点符号，以及在美式英语中使用的特殊控制字符</li><li>按照指定的格式与规则给输入输出的信息进行指定的编码，本质就是将计算机内一切的数据和信息转换为二进制代码的不同组合，以便给予机器并让机器执行相应的指令</li></ul><hr><p><strong>ASCII码的基本规律:</strong></p><ul><li><p>0～31及127(共33个)是控制字符或通信专用字符(其余为可显示字符)，如控制符: LF(换行),CR(回车),FF(换页),DEL(删除),BS(退格),BEL(响铃)等</p><blockquote><p>通信专用字符: SOH(文头),EOT(文尾),ACK(确认)等<br>ASCII值为8,9,10和13分别转换为退格，制表，换行和回车字符<br>它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响</p></blockquote></li><li><p>32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字</p></li><li><p>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号，运算符号等</p></li><li><p>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位</p><blockquote><p>所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种<br>奇校验规定: 正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1<br>偶校验规定: 正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1</p></blockquote></li><li><p>后128个称为扩展ASCII码</p><blockquote><p>许多基于x86的系统都支持使用扩展(或”高”)ASCII<br>扩展ASCII码允许将每个字符的第8位用于确定附加的128个特殊符号字符，外来语字母和图形符号</p></blockquote></li></ul><hr><p><strong>涉及概念:</strong></p><ul><li>点阵</li><li>字库</li><li>点阵字库/字模(数据)</li><li>格式问题(UCS-2等)</li><li>码点</li><li>编码</li><li>Little endian/Big endian</li></ul><hr><p><strong>其它的编码系统</strong></p><ul><li>非ASCII编码</li><li>Unicode</li><li>UTF-8</li><li>中文编码</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>中文维基</strong></p><ul><li>ASCII<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/ASCII</code></p></blockquote></li><li>分类:字符集<a href="https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86</code></p></blockquote></li><li>分类: 编码<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>字符编码<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>晶体结构<a href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84</code></p></blockquote></li></ul><p><strong>百度百科</strong></p><blockquote><p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/ASCII/309296?fr=aladdin</code><br><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin</code></p></blockquote><p><strong>CSDN</strong></p><blockquote><p><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/exbob/article/details/6532772?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code><br><a href="https://blog.csdn.net/yuanwofei/article/details/12846331" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/yuanwofei/article/details/12846331</code><br><a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/Deft_MKJing/article/details/79460485</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>学习</title>
    <url>/2020/03/14/%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>主观-学习</strong></center><a id="more"></a><h3 id="开放性随笔"><a href="#开放性随笔" class="headerlink" title="开放性随笔"></a>开放性随笔</h3><ul><li>所谓的智商来源于学识</li><li>而智慧来源于环境，世界，精力/经验其次是学识</li><li>然而所谓的智商，只不过是给予懒惰者的万千个借口之一而已</li><li>只是强者给予弱者的某一个心里安慰或者是弱者自己寻求的理由而已</li><li>学习不仅要勤奋，还要明志，指向明确，方向稳定</li><li>明确自己的定位，明确自己所能接受的范围，明确自己当前的能力限制</li><li>在步步为营的前提下，去进行逻辑性的累积</li><li>利用绝对的理智去找对方向与指明道路，珍惜时间，时刻行动</li></ul><hr><ul><li>学习的本质只不过就是机械化的练习，记忆，理解与实践</li><li>伴随机械化记忆而形成的是对所学概念或知识的通透性理解</li><li>而学习和练习即为行动</li></ul><hr><ul><li>哲学不是存在于现实的，或称不是存在于现代的<blockquote><p>或称存在于现实间的哲学，对于现代人类最基本的生存，生命与现实存在的保证而言(生存的本能)，没有任何意义和相关性</p></blockquote></li><li>纯粹的哲学家可能早就被饿死了</li><li>任何学识和智慧都要提现和实现在现实层面之上</li><li>最基本的条件是需要保证自己于现实间的实际存在</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>无</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-03-14</title>
    <url>/2020/03/14/%E9%9A%8F%E7%AC%94-2020-03-14/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="d6d6a2999ed2b5806014791837ffd7465230f852ec5d4ebaab6339cf199c34d1">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e7c1bd18033e860c02eae01ececb3cd90765749322ebace55430fcdf86104656899641018d61d7c738eee3315f3be6f5bcda46abf4f67eed4014492852823871d04c14858b500be819800797f0ffd35f33e86e9a02faf22bf82cfa4998da57edc9abd6547de34d4889ce4dffe79deca01b8e7d19961098027ebce9fa9f30321922b5de21615aa2ae48b2b354ff85dcfac34a467874dc0c77e076023051c964ed04e0a28417e0eeebb4d8b2c6ff45a140ac241e61f66bc7f88fc899f01991974a321b5a718e1cc83fd8b3bc746de619290652a9becf6f6a15dee17bb9009cc44155f90959279d4e8418d95e07232a5f76d9cbff17b3a0eb812055cde658353ae85cf192921c5066144493f5aedbee028d67efa32d109bb36b661e059e669b82d4cb2f7e7609ea1eaff6d1650da272b20e31150365be5aebc6a91444d237496da72b14c9b3a74d039ed982fba1564e4b9151451cf28c329939298e79f0fcb976306c0421f65e1ade0aa0fc32a79057f4fbdf78795c4cb9cda5de6d515d630f89c0500c38d84aa0c0bb4f20c9a9f09640ef6bdd1f99c49846b5c2b6dd82e0b23ad34ac68cbad3d40824b61a14c0a73d7b1d45afb5218cd3366217ca4479eb16586f7a547a059d2fa3e571cb8bd7f9285d2198886106e1893a25bf7b40a9ccaa00cf82a9fbcbbcc494f5ac4a8ec66de44f9dd54a2fdf3dbad0975bf90f6ebd9aa72458c80c362ded2941b429ca5c9886b3680169ee73513610e37ded3c07f5090bc6c8d5c89d8bea22382dbadbf7bdb2cdc6f7bdbec4d29243433a12f450d3bd3dc4b8caf3ce76b6249b9b063953add3808846786103b8b46d36ff52e13b15820ed164204b9fff3d2f17d1f696c6d5f6bbe2ed194f3fa6bc5b4ca84409f17b8355829a3e8a3a810aa5a7bf3c98a566f13c152ed4fb254e8d554ec5f0f360946555c306966b7255a00a76044cf602a664ab3853560547c6aeaeeacf2694fab24b796f2575feb56808366fe64894f1f87d5222aca955f97f962d69a237d129769621e059bfe4344b8a916f02978a93d456073f11753ebd0d1945408b8c1858288bf4aafab7a401ed3db9eefca5bd5b15b777050d4783846199934e03ec6720517db4bef0ecb1f802ec95c6a7b6a18acb79a90e62b2bbc3976a8abaccb5d74f93c3b786c5c00fe30aefb0d068ef7e2927ecb1eff7e0aefffd9a186a71c4a059d903965188a260d43c126fd3dc216a3a43db44caed7ab7594042605801c137c7092607eb0e06483a8ebf4c289de5ad3aca59a65e1e017d142f2ac16fedce88c338be7eb8386dae658097a758462d79c12e70d6efdf0ee7095769694fe46a90468cec81bbb9192ab37edd8361311eedecc140b87ccabe5d3ce4809b480776026a4d01d1220ea5a3ac34c9ad8eb3d035e9b08fc21ec98254647fed9c1e375af4d3def8d2d4a12cefea87dc469b1bdb1902f24dbf496e0e4c849ab2960a5c752f4d8a73ee6d74793d4a220716a3c28ada255e652468f3d1801fb0d3ac3ea869748790fa0581e2c784d6a0b24a23487ec4a007516360acf3a28daa251de513786b563b3359d20f1ec6126fa273876eaa235b0b2ae29472ec1448bf779e2418e8fd2128ecfbcc1371308ef32189d843cbd1be887772535790857da9e4ebc1a3dce9ed15d98f5d7247b7529ebdae751ec78e14ecd3a212954c26a8d61f8aca239dd007a2be2db8ac0cdc80a9be8e91c6560045aa2d8435e35fe1b414d26488e18eb3e6b5b4395fff563a265829bc9e1211d10810222c72f543092641455d704f2acf720c84092f98268c0beef25e240addece76a3d71691adef5201104a797b56993251baee23e158521545d2faf5f417b44125e19b8b3d46accca96e100650bd87a7223115b49b01c79a0e15db0d14b2f141d4b728cf5708fbdc4394ea42808d9ebf1ec1c7066a58acffe051e5b3c29a95891fc2aff9ede45d1a6139cf73c2cc9a68db8893122044eb494dfe3514b9ee11efa4f4e11013a66c16f6697961adebeb40648bdf5a4fdec417bf9163a75234e5bf8a9b42a3c02babefea5db0ba5b2f191466d32e7e4ab5e27937799217a78cc448ac541ac0d749532deffc3ef1056537388385ef9f6ae990a676b90347f5cfd1a34563057cb5f6589d0831ae25b7dace6b0b430b036a9f3a232f22615fcfa4c551be41e74b669b673230c93f334367494e28e65fbb640c62c0ab7e397fb635bd79a3c01de83edbad58f97b1e59cccec2d751aac2636004bf17411567a281a4fc8e09ccd9b3ceecd83b6b9273d01fe726c09f6f0487d56f9348fc1d819031c30eb2934f63b515e26164ef8a12513941c8ad9c836b52af580595bdd2c9957185aa32ab8aac9bf9a6fd19d2ac93e68cc66acfa5178fc86db07c9647c50c249b251d01cf8bcc150dd3a4a34940ef8928ab7bd528e687fc0e0354d126d168b6856f0ed2b592d662ff6bf140b778589ad9be5a81f762125ed29c09b62e863648234ec8f7ff30e9c366a40092db26aba448f8a479a198d472710740f1b4b1df3a2ab6c493275d399c4741a1d31eade77e65c2b0728472affcd5e0618ad6477db6cd1f15062c5ce1a4c2aa4ca904ead3b860738c1e2b29f763aeb2b6578b7421b2e68130f54e832f9e96b0b6204d49866730eed03b719883b909fbe0f06a874a90d9613448663039cd193dbe350f50de5a90ace20943b9afcd22ce342bf4c67844ff1f7a7a6cd8553cc1fffe44644fa920c030c3ad2f5e22c86739ae1342702da1c320d9b47bd71af4ca2774f9b015f5fcb632c08f0307892064bd1ee4c3534ae54f6fbb92fb37bb72d732fcec27b65abb6aa46cc83daf689f29ea01523fca6c902ef24af7d1a76c2a15bbc69c6b1d7ff1ae2bd32d79194c07bbeb7db5fff99131e3d876a5fc4cfdd8df35473decd070daac2407a93b8d3b4506871ec47cf8f7a58258f46300104daae5e0f0cf920cd65f5f10f263f64c0f5093c1159ef15b9b25740c82fd1543289eed0c20365a5ce91033d38cbcb9b9211f3e1d0b62a5200f7b743526c798aef1cc80e76e85ff1dce92b2d8f5291d13a97980afb60181a2f4cb8216dad717033d36eee33a0a4ce7147db670895dc5bce0ec2a2bc841764cdc42346b57f4d9c18736af69b9dc132302839a22d860c32850e747845b69606863c648636bc878587009937d8e5ace14fc8bfe6f4401236aaade9e33a83ecb30aa8ee9e9271cbc45f67f632069c94bb947c067fddd9389b06bcfe004bec45e9207b2d3c359749f9cf1ce68de5805bc2abae97e88b364868e94a9a6186404aa9f7cc87f22d0d814b48fb953ad4bacac43f83fb9add41df57406931b89dd6f28b381ee1de31e57d7ecbe06b15abbf1c3bdea008d9b1aaeeb7e89618004025bef857938d877cfe3c1294291c1b586b319bbb9ab302cee0a1e292e104674074a5e700ed5d4fb378c095a08dd346f57b12c73e61ac5ba30cae5d0cc3a60654162f6a1cdb4d39f9b8cadae9b6031a4f8c364a448375fb9a7ed5fda8570d9053c0b1c3fb8574011ce08837a4b92e0fada1093528e3fe1029606f64bb81c0ad321995cf6578cf4776889bc3d9821ca728fbe3ebe4f8fe0c98fa9f6c8587b14636a964b708ffec2b4e13e0cbf79fd08a53128f188a096c5b3a0a7587f6e0cf6985e819e3a5d2f636b0e24e3ba9d031bcc128e8ee4470d7e47093597656fd6037ffd17e857a91b9eae408e330f65c6e02d0b97696a4e1c35b524c823124f2d6e3e03eb6cb35947c33466f2a9b6997f2e879347a2a00032059d1774158cbbc5a31ad87884796369837ead4aa71e27104db350d2f17d2de3ba597b98a174d3b2097ea4d87ed9f9330c170b4409bf53dc3daaf9e0561629c9f4ce674eff08651240d64c310662d29ea4be0c8130a5165361a5e83cc1e6c40743faa53a14f6bc3dd160b1c01be385b8031efe5dfb2bd155be1883cb57ff1574a48d9c162861381e48164529af8dbd76f2677d4fbf578fc83d46e89d402bb2965a8bcd17f48dcfbe5e442134c5617c342de0bcabdd96cf3f0fc1cd401beeb0312912d151469d4bc2362d77806aa2188092fccf965b36fe9f6723e361be063d00370ed72aa675be221c817d89e1f6ef41526e4c79a90f5991bbeaaf04155ab545838d36f7f67ec4bac0400569610cb07019768e67684f8493d2bc82aa1c91f019c534440136345a4961caffb68915036ba49b124bfde72a159f1b72ace04456009f3a19f0b0d6ffb8459f303e5080888ecfb9a687d41b7468c8ce4e4d49826742e44132a18d7d22841d49fc20e69639268af08e082cc4c3d35e2b04fce958465da2a6ad1aa69fd3c700d2de53718483479ddf72e07e0f737ec76b32dcf8835825a9b17bb0e69e9334ce95990e0eac7199c0968dcd497f71a613f7f06caada3b7ee924f315721eb4d49caed338c17ff91938a55eb9462f03030f132981b88bfa811763077d79da52d37098aa740a1e4bd4850231f11b2ffa6553ca3e17f6f5c293d174ffa2cf5ac283c7ea3014df95589fd12a87b325f96d11a450dcbad52a5d5ab2c1d3003212c08dc68a08fff9eabc6cfd9c6add9c24a07253334b58f904670fbb1a09129a51b8337ab6e3c23201aef303ca1d38e211aa2e0058987f55b4d8e6fcf9691265ffe6eaa52ddcbf2402e2b673a1fcdd0c4b4bef0f6d30fb3a797142521c522de1a2ce415e091c05f85f4e98ba7b315a9e49ec5c51627d0967f924ed6d799872465e1b0b4a9d0031d0345c7a637c28e0c385138344e30ea23b5b0cc071dcd167e49f325b35e6a0448e0d9bc0031a7a9693954a6112c2b5b3f8e56625c0de9da2dc4b728024f3708b8402fbf8c2cca16ac636d654abf1119b12e92f32c5b4de307b2f564cfd6105c8a7c5cc7e24a065e64edf0f489b227ca3f1ffaf6696a59fbbcb6cc576973e3972f6d6e902d3b5262dd557f21a71d1867ac428fc3fd4c741be3b5865287b458ddbae5d7e3899ac0735a36410c2205b93acb59c611628dc9833dc06800cece57367e2dbffafd5c8de7382cf8a3c063f0b02867597db5084aa6ec0033b5153b9b3e2402f2740e9f9157392c3cc0061ad06384602e5c52719bdbf09f9cc679040f155517001ac652f46fc6490b5397305b3e5362427b09ff90bae761f93b0900b20f863b1834dc651096890059c529c89526d8e69362e131d73ee26357ce41552e6b0fd15af0927573d696d5c3ab5f7166da04f732473c1cfe7302e704c976c371a0ec32485deb236605852484d07102412ff9ee499b00a9e151748c7026fe60313129df71c2949b76ec903e99baaadbceb25674d57a7308bee0082322ff75815d4fb465af930584df2546d6157bae11e03d32d5a1a5ed9c7a82373dcc5b69368dc6fb2da8f4cf8c6fb78b21b6d770bfb0650eefdfa1b23d7e1f1c0e6592de9694219735c259a7ae7a6578fe6707df768fb43f4e534fb03919637ce49d98371a0f3ae0addfb4edbe0b28960c4034e10ae6b1b9982636d4b527b86c0c48779fecc7e4f3a5816b7df129305bd796d3964fd0458ff722209bc25a6308a7f04d8a62a104dd1b1cc85337916fea7443640291a047f3c5a98266ace00da5cdc968fb9cfecf7824f1e5efcd719e21a8f8b83eb29d363d92f31d9f1f39449f83b52764d5ebe436f3c225bb757363f5d6f45da1022b43e37f23b7a3103d38feb4ed0f4ed7a9fecc8d16214a9418772797b6b1c180ff4e075a8169ae55654aaf8041e3fa8dd46da750d1d7ba62b84ed59612f87e2346aa92200314ae6b978ee235b26a142326c2281dff214e4a69c6e7a5473270e5acff21409fafc16881fd4885dac12cb46c121bae6beb0dece6c2b7b48f18576dd2b08c1a4ea48569fd4aabf64e30e60292c71c671c63693e461d9f4267d507c2cee92768b854b00db18cbd3f42cc3d4d884837313a1e4335c1c4485614d1faf3912a6a27787a21ed9b26bcfab03c4311473116374f8f45892c4820a3711f2ef28b68ea0e5c68d981fc280eb099ff112b71e3bb41a4107755bbfa577a8edec3d4f4cbcc1363aaa41bfb8f9d6534badfb61862f6608a12f68530e79b042926558459a892b8b7ecc29b9cbe993f94b70a806cb2fa4f4f22976aa39ca1cf52f19e0a317017a22607063ae372f989a699cdb547aea5df6918969187cb7d78c479142f6bcf9f757ed8b329b10754cda69406a9a0e4f6b15d2c64446ebafc88323cfd92f95b7296613189a63dbe64be88675a7d58b2aa009c193a898ebf7e73be922201ea18ba9a64a7de959e05efcd01724c1ca745deead261094d40be899eba86bf7000422a350dc63f37f3d9cf8f4447502654852c01dfca5e4dd1da56a604cfc54f739b76870ad6c5a4fc699f7d9edc205ee0e416a7bee69f8827aa75c6900bb77d34e3e607ab363ddc7bb51f20a0c10569f7ad7f8d5c9c1ffb36578b75adb072603846e76e706b951a8d4d0eb6d1dfd57ec4703bef88d8cf635aa3b91f057a2302b9c86f35f3844568bea69ce84aa3497c9d72319583de3b8b2ed7b9058ffd88ac77a8b3c0b48dd326b0a686cafdb13aab124124452fcf2a2f476033c0a782691befd9023e8b3f714f9f379845cbb11636c4bd019ef53a4bc0305947a9964687d309d859c01116719fadfbed62a500ce041a68e5f20d1d61e751772e70ef6ad489000798e43db3b2cc60392f49fa4352ad54fb908dad7e4f22aea69bf64d66cac629605503f95a2804601f3e5ab7e5b817152b7f4c642707f00a9bbe65efa360312b262aab7d7c2ec908db32e4e61155eb84b962b9c8b6ce9d42704e86456137891a1776889bd51a55a1dfbb28fa4b46ee529bd211ee938a0fd77c98769428767bbfb1ecac2958fbd463cbff122a95bc2a6d37e47b733bf32cb66d9b3b84a2a818fcdee7b6ce7c6a9f018ec548baf688c37fd9594b0ac91a1e50d43c8531ee580c46642ddfb1be8bb275f38c4e7b65eee63fe9787320186ce326e21c7442ca86e3e67b3bc1b33bc0688d68fdc85a5ade9939df24f61491c6dbe27c15e3c145f127848ea746a21cf5e0ea99f6a6b8b0c3ff52c1f378b28cb49a4ff6e6c99b5f00acc457441cb364fae88cbd419fea3c9ef67df9926621abaa54fd20af094c354f1aa32728dc5bc9f97833e9e46079f8c80861ab4791d8e711400a6989fd748a961362db091caf2788e68d41e9a9836a79909b8b42dd3456eeb91456edd731769c7d80c6dc28f8dee02166bb7041aac8660131319d266b2a91a2a2bbab5585b39ffd0402dfda0f8d6efe8f4440b7ad1455a3487c2759322ca8d3220b48be770d89193111865562d31ad164f8c25202474e0a67270dd45ae97bd4a24730779bfeed07d6147d3d13cec84061f8357a5d606acffa7002512938408eaf33e139fae011546c465fc657d39174add1da4152e74b44bf48548701e8c86b9e16145a2915e802402db5def51b45888eba32d5337a256269c4c388ae5fc6af68226ffa96f06807a52191c7247a6abe7757c0d6339abb6e479f5bdca1e70973fcdd4c2b344e15eadb6766b93cab35afefa31fa2be9b0a59a804c01c4423b1f5c704d676b513292ba3f9f6e4f87a205590114119c7d3f9ab720c65d7ad49dda7d0d4b9bf62ef76935f93debb63a8ddcddfd91ac3476b388ffe5900610ce78b06a54b006bc3c6689445b8b4fc3b647be5cffcb54db672705aab637b3a979b75aa701e37266cdb8980c2b09d54d4b89a9ab37e0d477f13a7ded50f36e34ceb46c51af6f5a185c48fba822e8d6a6a0f77b38687b51e54220505bd708a80558a588fa2fd76a3041b206fa0808fddaf351735a983b587501cfe51800d001b6a21f27ec2d642a4183090b4409d1dc27b1c8ba07607341a63438247f624b833bb6822cc5cfd6db4e18299ae3cd4516b9fee0beec10b9937d49d0877158bfb009acdfeb4498859029757a04bde37b7c9491f6d5cff66c3b2ff11f26dabebab62607ca127b0c66cedf439d1cb38ae3b0c2551dd732fe2ce7eb57ce59dc116bdc55aa083bb14b38cedff78bb0b9b1f20920a23db1f7a5aa0a8f084cc4d4e4941b47e6e71518f176087e02fd019d7e29bf035007775b207d2fc0833ccd533cdb214109b0f8bbc36d7b38f02ac087cb98d7ae9e51058f5468f136257c199001402ac44cf684884b6aec6d76ed5fc8d99a8f2de6e5450bd305a4ade1079f4f7e0686190629a559dc9ccb034b8e42c2947d9e8332e55a21167a8d56ddb476ab20be3a9d52787e609377c558950c30590f24b597d88a5daf80ff634fafa093fc5b90e045aac8a2f96027468eb384c721155c48e9e671ae6f0e26189ea3c59d6a88935e5e5200a4dab33afb41c5894b912481fc64e749a97dba0134eb3917078b440240772e0ecad9ced634476ea62b7adc3fdd8e36b3596f4e28daacc0f9d1499cb4338a263ccabb6aa78d6e1d9862a6ac31b34c10db3f02fbedfb3ec24907f8742b7efa826a3ef2fe9ffa7c9e790633d89609be3e43c07e61cc6333ecb8f16740714e4406bc49945489adcff2fc650a32cef271e938d417c7944c1a60fdf5890b7f9b6bb1ffdd29d9dcbd2efd9a206482002fcf7ecb27f8a140be3fb98dd3cd218b0d9eb9bc3d6bcb76f56d55b463b4b96669a7fdb0e7f707381a2e8f3e8106499bbdea8d6979cce9ba9a4fda0779ffbb17cb2074d8804b121bdb5681b9fce23d82afbc17d30a04faba584e8aa3dc64b96d2eb47a7e4e687e68e3a5de81504e5b07def923b63d38ed1fd537bfba17d0c99225085c66a79996695b0e28d94a40437f72fa18b1b796ed9b6cb9967464a57070ec48f75c939688fe2e88a38a80e423fc983915710db19f4f76adaadbc185a9cedb89f734c3d7fabd30db37ec51da9912ac0b60c1676bd650e4bacb28d08c1bf95a096acb64f71b05701270f22fe1377b8e1614648e507128bc8b4d0e812a46d6d35ae8cb8dcc10c53b80fc8ede09473fe62be9723bd5eb61d09f9cb944c0346edf31ef743c7b3da53c3e34ad217a1430fcdbd3ca85843ab92a06c1cce9a5d95ed2eb09f79994dadd5dc52ace2e894b761f09e5b7e2feba75bfefd82deee1ca69838ffc6cb217c73b6e6b14b91d9c4cb373a67191b3935645c5953783af1027789686d0b48842a773a24c4c8fe590118e626157be3214ed211e47271785132dc9de500860f8b6008f087fbe75647000c2bef330516ba6dc9ac50f535266b012ba863b4325fb6f575c0da8640e69c35f9c3a038e50eafbd04d7c91456626c9d727899fdeb85ce2fb40f2c8673576722c37709d4abedb9e7e28b6cc6cd3beae9d42a382483c7e1a8b009acc5d99fcbf804413859ec535f80792d76e515c01996acd1af1c829276ec8270f2bde5cec8a272d704e3ef0b6f46be3a93a60169d8bf07bf53c06699a58cb38221c59cf460535435560c2148be12a2aeca8071bfa1457d563e913a41ea28e5a7ceab2330b</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-7</title>
    <url>/2020/03/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-3</strong></center><a id="more"></a><h3 id="数据类型-7"><a href="#数据类型-7" class="headerlink" title="数据类型-7"></a>数据类型-7</h3><ul><li><p>条件选择语句(控制语句)</p><blockquote><p>if，if…else，else…if，switch，switch…break，switch…if…else语句<br>continue…break<br>goto</p></blockquote></li><li><p>头文件及函数</p><blockquote><p>ctype.h，iso646.h<br>getchar()，putchar()</p></blockquote></li><li><p>其它概念</p></li></ul><hr><p><strong>涉及内容:</strong></p><ul><li>条件选择语句-if/if…else</li><li>getchar()与putchar()方法</li><li>ctype.h头文件/iso646.h头文件</li><li>多重选择语句-else…if</li><li>选择语句配对规则</li><li>逻辑运算符及其优先级，求值顺序与范围</li><li>条件运算符-?:</li><li>循环辅助: continue语句和break语句</li><li>多重选择: switch语句和break语句</li><li>多重标签: switch语句和if…else语句</li><li>跳转标识符: goto</li><li>其它内容(补充内容/关键概念梳理/文章内涉及概念总结)</li><li>有可能会在数据结构-8内进行补充</li></ul><hr><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><ul><li><p>IF语句</p></li><li><p>if语句被称为分支语句(branching statement)或选择语句(selection statement)</p><blockquote><p>因为它相当于一个交叉点，程序要在两条分支中选择一条执行</p></blockquote></li><li><p>if语句的通用形式如下:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if ( <span class="name">expression</span> )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>如果对expression求值为真(非0)，则执行statement</p><blockquote><p>否则，跳过statement</p></blockquote></li><li><p>与while循环一样，statement可以是一条简单语句或复合语句</p></li><li><p>if语句的结构和while语句很相似</p><blockquote><p>它们的主要区别是: 如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次</p></blockquote></li><li><p>通常，expression是关系表达式</p><blockquote><p>即比较两个量的大小(如，表达式 x &gt; y 或 c == 6)<br>如果expression为真(即x大于y，或c == 6)，则执行statement<br>否则，忽略statement</p></blockquote></li><li><p>概括地说，可以使用任意表达式，表达式的值为0则为假</p></li><li><p>statement部分可以是一条简单语句或者是一条用花括号括起来的复合语句(或块)</p></li></ul><hr><h3 id="IF…ELSE"><a href="#IF…ELSE" class="headerlink" title="IF…ELSE"></a>IF…ELSE</h3><ul><li><p>简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句</p></li><li><p>C 还提供了if else形式，可以在两条语句之间作选择</p></li><li><p>if else语句的通用形式是：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">( expression )</span></span><br><span class="line">   stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">   stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure></li><li><p>如果expression为真(非0)，则执行statement1</p><blockquote><p>如果expression为假或 0，则执行else后面的statement2<br>statement1和statement2可以是一条简单语句或复合语句<br>C并不要求一定要缩进，但这是标准风格<br>缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然</p></blockquote></li><li><p>如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块</p><blockquote><p>下面的代码结构违反了C语法，因为在if和else之间只允许有一 条语句(简单语句或复合语句):</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line"><span class="keyword">else</span>　　　<span class="comment">// 将产生一个错误</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句</p><blockquote><p>它不是if语句的一部分<br>然后，编译器发现else并没有所属的if，这是错误的</p></blockquote></li><li><p>上面的代码应该这样写:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择</p></li><li><p>if语句和if else语句的执行逻辑示意图</p></li></ul><img src="/images/数据类型-7/IF语句1.png" width="30%" height="30%"> <img src="/images/数据类型-7/IF...ELSE语句-1.png" width="30%" height="30%"><hr><p><strong>未完成</strong></p><hr><h3 id="getchar-putchar"><a href="#getchar-putchar" class="headerlink" title="getchar()/putchar()"></a>getchar()/putchar()</h3><ul><li>字符输入/输出函数getchar()和putchar()<blockquote><p>同样可用作输入/输出的函数还有scanf()和printf()根据%c转换说明来进行对字符的读写</p></blockquote></li></ul><p><strong>getchar()</strong></p><ul><li><p>getchar()函数不带任何参数，它从输入队列中返回下一个字符</p><blockquote><p>例如: ch=getchar();，它与scanf(“%c”, &amp;ch);的作用相同</p></blockquote></li><li><p>putchar()函数用于打印它的参数</p><blockquote><p>例如: putchar(ch);，该语句用于将之前赋给ch的值作为字符打印出来<br>该语句与printf(“%c”, ch);相同</p></blockquote></li><li><p>由于这些函数只用于处理字符，所以它们比通用的scanf()和printf()函数更快，更简介</p><blockquote><p>而且还有一点，getchar()和putchar()函数不需要进行转换说明，因为它们只处理字符<br>这两个函数通常定义在stdio.h头文件中(而且它们通常是预处理宏，而不是真正在宏观意义上的函数，这里先不对类似于宏的函数进行深入赘述)</p></blockquote></li><li><p>语句putchar(ch + 1);</p><blockquote><p>表示了字符实际上是作为整数而存储于内存之中的<br>为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()<br>该函数只根据最后一个字节确定显示哪个字符</p></blockquote></li></ul><hr><h3 id="ctype-h系列的字符函数"><a href="#ctype-h系列的字符函数" class="headerlink" title="ctype.h系列的字符函数"></a>ctype.h系列的字符函数</h3><ul><li><p>斜杠字符对应的ASCII码比点号的ASCII码多1</p><blockquote><p>如果程序 只转换字母，保留所有的非字母字符(不只是空格)会更好</p></blockquote></li><li><p>C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型</p><blockquote><p>这些函数接受一个字符作为参数，如果该字符属于某特殊的类 别，就返回一个非零值(真)<br>否则，返回0(假)<br>例如，如果isalpha()函数的参数是一个字母，则返回一个非零值</p></blockquote></li><li><p>有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具(例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为 123,45)</p><blockquote><p>注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值</p></blockquote></li><li><p>ctype.h头文件中的字符测试函数列表和头文件中的字符映射函数这里不做赘述</p></li></ul><hr><p><strong>多重选择else…if</strong></p><ul><li>else if 是 if else 语句的变式</li><li>else部分包含另一个if else语 句，该if else语句的else部分又包含另一个if else语句<blockquote><p>第2个if else语句嵌套 在第 1个if else语句中<br>第3个if else语句嵌套在第2个if else语句中</p></blockquote></li><li>对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌</li></ul><hr><p><strong>else…if的配对机制</strong></p><ul><li>规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来</li></ul><p><strong>图片说明:</strong></p><ul><li>if else匹配的规则:</li></ul><img src="/images/数据类型-7/if else匹配的规则-1.png" width="40%" height="40%"> <img src="/images/数据类型-7/if else匹配的规则-2.png" width="40%" height="40%"><ul><li>注意: 要缩进”语句”，”语句”可以是一条简单语句或复合语句</li></ul><hr><p><strong>多层嵌套的if语句</strong></p><ul><li>if…else if…else序列是嵌套if的一种形式，从一系列选项中选 择一个执行<blockquote><p>有时，选择一个特定选项后又引出其他选择，这种情况可以使 用另一种嵌套if</p></blockquote></li></ul><hr><ul><li><p>小结：用if语句进行选择</p><blockquote><p>关键字：if，else</p></blockquote></li><li><p>一般注解:</p><blockquote><p>下面各形式中，statement可以是一条简单语句或复合语句<br>表达式为真说明其值是非零值</p></blockquote></li><li><p>形式1:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if (<span class="name">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，则执行statement部分</p></blockquote></li><li><p>形式2：</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，执行statement1部分<br>否则，执行statement2部分</p></blockquote></li><li><p>形式3:</p><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression1)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else <span class="keyword">if</span> <span class="comment">(expression2)</span></span><br><span class="line">stateme<span class="symbol">nt2</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt3</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果expression1为真，执行statement1部分<br>如果expression2为真，执行 statement2部分<br>否则，执行statement3部分</p></blockquote><ul><li>示例:</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (legs == <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It might be a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (legs &gt; <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It is not a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span>　　 <span class="comment">// 如果legs &lt; 4 </span></span><br><span class="line">&#123;</span><br><span class="line">   legs++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Now it has one more leg.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p>if语句和while语句通常使用关系表达式作为测试条件</p><blockquote><p>有时则需要将多个关系表示组合起来用，此时则需要使用逻辑运算符，并使用点符号<code>&#39;.&#39;</code>来标识句子的末尾</p></blockquote></li><li><p>逻辑运算符两侧的条件必须都为真，整个表达式才为真</p><blockquote><p>逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号</p></blockquote></li><li><p>C 内有三种逻辑运算符，如下表图片:</p></li><li><p>三种逻辑运算符:</p></li></ul><img src="/images/数据类型-7补充图片/三种逻辑运算符-1.png" width="40%" height="40%"><hr><ul><li>举例说明:</li><li>假设exp1和exp2是两个简单的关系表达式(如car &gt; rat或debt == 1000)<blockquote><p>那么:<br>当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真<br>如果exp1或exp2为真，则exp1 || exp2为真<br>如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假</p></blockquote></li></ul><hr><p><strong>iso646.h头文件</strong></p><ul><li><p>C 是在美国用标准美式键盘开发的语言，但在世界各地，并非所有键盘都有和美式键盘一样的符号</p><blockquote><p>因此，C99标准增加了可代替逻辑运算符的拼写，并且将其定义于iso646.h头文件中<br>如果在程序中包含该头文件，便 可用and代替&amp;&amp;、or代替||、not代替!</p></blockquote></li><li><p>逻辑运算符对应的拼写如下表图片:</p></li><li><p>逻辑运算符的备选拼写:</p></li></ul><img src="/images/数据类型-7补充图片/逻辑运算符的备选拼写-1.png" width="40%" height="40%"><ul><li><p>在新增的C99和C11的标准ANSI C库内列出了一些其它运算符的备选拼写</p></li><li><p>!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低</p></li><li><p>&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高</p><blockquote><p>因此，表达式a &gt; b &amp;&amp; b &gt; c || b &gt; d相当于((a &gt; b) &amp;&amp; (b &gt; c)) || (b &gt; d)<br>也就是说，b介于a和c之间，或者b大于d<br>尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第2种写法<br>这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚</p></blockquote></li></ul><hr><p><strong>有关求值顺序</strong></p><ul><li><p>除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值</p></li><li><p>例如下面的语句，可能先对表达式5+3求值，也可能先对表达式9+6求值:</p><blockquote><p><code>apples = (5 + 3) * (9 + 6);</code></p></blockquote></li><li><p>C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计</p><blockquote><p>但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右<br>&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效<br>而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值<br>正是由于有这些规定，才能写出这样结构的代码:<br><code>while ((c = getchar()) != &#39; &#39; &amp;&amp; c != &#39;\n&#39;)</code><br>如上代码所示，读取字符直至遇到第1个空格或换行符<br>第1 个子表达 式把读取的值赋给c，后面的子表达式会用到c的值<br>如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值</p></blockquote></li><li><p>这里还有一个例子:</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">if (<span class="name">number</span> != <span class="number">0</span> <span class="symbol">&amp;&amp;</span> <span class="number">12</span>/number == <span class="number">2</span>)</span><br><span class="line">printf(<span class="string">"The number is 5 or 6.\n"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值<br>这样避免了把0作为除数<br>许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件</p></blockquote></li><li><p>最后，考虑这个例子：</p><blockquote><p><code>while ( x++ &lt; 10 &amp;&amp; x + y &lt; 20)</code><br>实际上，&amp;&amp;是一个序列点，这保证了在对&amp;&amp;右侧的表达式求值之前已经递增了x</p></blockquote></li></ul><hr><p><strong>内容简述:</strong></p><ul><li><p>逻辑表达式:</p><blockquote><p>当且仅当expression1和expression2都为真，expression1 &amp;&amp; expression2才为真<br>如果 expression1 或 expression2 为真，expression1 || expression2 为 真<br>如果expression为假，!expression则为真，反之亦然</p></blockquote></li><li><p>求值顺序:</p></li><li><p>逻辑表达式的求值顺序是从左往右</p><blockquote><p>一旦发现有使整个表达式为假的因 素，立即停止求值</p></blockquote></li><li><p>示例：</p><blockquote><p><code>6 &gt; 2 &amp;&amp; 3 == 3</code> 真<br><code>!(6 &gt; 2 &amp;&amp; 3 == 3)</code> 假<br><code>x != 0 &amp;&amp; (20 / x) &lt; 5</code> 只有当x不等于0时，才会对第2个表达式求值</p></blockquote></li><li><p>有关范围问题:</p><blockquote><p>&amp;&amp;运算符与islower()函数可用于测试范围</p></blockquote></li></ul><hr><h3 id="条件运算符-三元运算符"><a href="#条件运算符-三元运算符" class="headerlink" title="条件运算符/三元运算符"></a>条件运算符/三元运算符</h3><ul><li><p>C 提供条件表达式(conditional expression)作为表达if else语句的一种便捷方式</p></li><li><p>该表达式使用<code>? :</code>条件运算符</p><blockquote><p>该运算符分为两部分，需要三个运算对象<br>带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符<br>以此类推，带三个运算对象的运算符称为三元运算符<br>条件运算符是 C 中唯一的三元运算符</p></blockquote></li><li><p>条件表达式的通用形式如下:</p><blockquote><p><code>expression1 ? expression2 : expression3</code><br>如果 expression1 为真(非 0)，那么整个条件表达式的值与 expression2 的值相同<br>如果expression1为假(0)，那么整个条件表达式的值与 expression3的值相同</p></blockquote></li><li><p>需要把两个值中的一个赋给变量时，就可以用条件表达式</p><blockquote><p>典型的例子是，把两个值中的最大值赋给变量:<br><code>max = (a &gt; b) ? a : b;</code><br>如果a大于b，那么将max设置为a<br>否则，设置为b<br>通常，条件运算符完成的任务用 if else 语句也可以完成<br>但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码</p></blockquote></li></ul><hr><h3 id="循环辅助-continue-amp-break"><a href="#循环辅助-continue-amp-break" class="headerlink" title="循环辅助-continue&amp;break"></a>循环辅助-continue&amp;break</h3><ul><li>一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句</li><li>而continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环</li></ul><p><strong>continue语句</strong></p><ul><li><p>3种循环都可以使用continue语句</p><blockquote><p>执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代<br>如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环</p></blockquote></li><li><p>有两种方法可以避免使用continue</p><blockquote><p>一是省略continue，即为把剩余部分放在一个else块中<br>这种情况下，使用continue的好处是减少主语句组中的一级缩进<br>当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性<br>另一种方式是把if的测试条件的关系反过来便可避免使用continue<br>需要根据程序的实际情况而定</p></blockquote></li><li><p>continue还可用作占位符</p><blockquote><p>例如将循环读取并丢弃输入的数据， 直至读到行末尾<br>当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便<br>问题是，一般很难注意到一个单独的分号<br>如果使用continue，可读性会更高<br>如果用了continue没有简化代码反而让代码更复杂，就不要使用continue</p></blockquote></li><li><p>从何处开始继续循环:</p><blockquote><p>以上介绍了continue语句让程序跳过循环体的余下部分<br>对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值</p></blockquote></li></ul><p><strong>break语句</strong></p><ul><li><p>程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段</p><blockquote><p>但如果break语句位于嵌套循环内，它只会影响包含它的当前循环</p></blockquote></li><li><p>以下两张图片比较了break和continue</p></li></ul><img src="/images/数据类型-7补充图片/break和continue-1.png" width="40%" height="40%"> <img src="/images/数据类型-7补充图片/break和continue-2.png" width="40%" height="40%"><ul><li>break还可用于因其他原因退出循环的情况</li><li>和continue一样，如果用了break代码反而更复杂，就不要使用break</li><li>break语句对于稍后讨论的switch语句而言至关重要<blockquote><p>在for循环中的break和continue的情况不同<br>执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过<br>嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break</p></blockquote></li></ul><hr><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><ul><li>使用条件运算符和 if else 语句很容易编写二选一的程序<blockquote><p>然而，有时程序需要在多个选项中进行选择<br>可以用if else if…else来完成<br>但是大多数情况下使用switch语句更方便</p></blockquote></li></ul><p><strong>switch的工作原理分析</strong></p><ul><li><p>要对紧跟在关键字 switch 后圆括号中的表达式求值</p><blockquote><p>break语句让程序离开switch语句，跳至switch语 句后面的下一条语句<br>如果没有break语句，就会从匹配标签开始执行到switch末尾</p></blockquote></li><li><p>break语句可用于循环和switch语句中，但是continue只能用于循环中</p><blockquote><p>尽管如此，如果switch语句在一个循环中，continue便可作为 switch语句的一部分<br>这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分</p></blockquote></li><li><p>switch语句和Pascal的case语句类似</p><blockquote><p>它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句<br>另外，C 的case一般都指定一个值，不能使用一个范围</p></blockquote></li><li><p>switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)</p></li><li><p>case标签必须是整数类型(包括char类型)的常量或整型常量表达式(即表达式中只包含整型常量)</p><blockquote><p>不能用变量作为case标签</p></blockquote></li><li><p>switch的构造如下：</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">switch ( 整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句	&lt;--可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句	&lt;--可选</span><br><span class="line">default :	&lt;--可选</span><br><span class="line">语句	&lt;--可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于程序只读每行的首字符的情况这里不做多余赘述</p></li></ul><hr><p><strong>有关多重标签</strong></p><ul><li>可以在switch语句中使用多重case标签</li><li>如果使用ctype.h系列的toupper()函数可以避免 使用多重标签</li></ul><hr><p><strong>有关switch和if else</strong></p><ul><li>关于何时使用switch与何时使用if else<blockquote><p>如果是根据浮 点类型的变量或表达式来选择，就无法使用 switch<br>如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦<br>这种情况用if就很方便:<br><code>if (integer &lt; 1000 &amp;&amp; integer &gt; 2)</code></p></blockquote></li><li>使用switch要涵盖以上范围，需要为每个整数(3～999)设置case标签<blockquote><p>但是，如果使用switch，程序通常运行快一些，生成的代码少一些</p></blockquote></li></ul><hr><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><ul><li><p>早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用</p><blockquote><p>但 是C和其他两种语言不同，没有goto语句C程序也能运行良好<br>Kernighan和 Ritchie提到goto语句”易被滥用”，并建议”谨慎使用，或者根本不用”</p></blockquote></li><li><p>goto语句有两部分: goto和标签名</p></li><li><p>标签的命名遵循变量命名规则如下所示:</p><blockquote><p><code>goto part2;</code></p></blockquote></li><li><p>要让这条语句正常工作，函数还必须包含另一条标为part2的语句</p><blockquote><p>该语句以标签名后紧跟一个冒号开始:<br><code>part2: printf(&quot;Refined analysis:\n&quot;);</code></p></blockquote></li></ul><p><strong>避免使用goto</strong></p><ul><li><p>原则上，根本不用在C程序中使用goto语句</p><blockquote><p>但在FORTRAN或BASIC内，goto对这两种语言而言都必不可少，而且还会依赖用goto来编程<br>对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if<br>不能使用块或复合语句</p></blockquote></li><li><p>跳转至循环末尾，并开始下一轮迭代</p><blockquote><p>C使用continue语句代替跳出循环</p></blockquote></li><li><p>C使用break语句</p><blockquote><p>实际上，break和continue是goto的特殊形式<br>使用break和continue的好处是: 其名称已经表明它们的用法，而且这些语句不使用标签<br>所以不用担心把标签放错位置导致的危险<br>胡乱跳转至程序的不同部分</p></blockquote></li><li><p>但是，C程序员可以接受一种goto的用法: 出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)</p></li><li><p>不去使用goto的多个理由:</p><blockquote><p>程序中使用其他形式比使用goto的条理更清晰<br>当多种情况混在一起时，这种差异更加明显<br>哪些goto语句可以帮助if 语句? 哪些可以模仿if else? 哪些控制循环?<br>哪些是因为程序无路可走才不得已放在那里?<br>过度地使用goto语句，会让程序错综复杂<br>如果不熟悉goto语句，就不要使用它<br>如果已经习惯使用goto语句，试着改掉这个毛病<br>讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用<br>因为 C允许在标签中使用描述性的单词而不是数字</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>CN/PDF-C Primer Plus【第6版】</p><blockquote><p>[美] Stephen Prata | 著/姜佑 | 译<br>截止至原书第七章末尾-496页(一共1635页)<br>C 控制语句: 分支和跳转-7.10/7.12</p></blockquote></li><li><p>数据类型-1~数据类型-7</p><blockquote><p>C11/ANSI C/ISO C</p></blockquote></li></ul><hr><ul><li>接下来的内容会以 C 冠名</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-6</title>
    <url>/2020/03/13/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-2</strong></center><a id="more"></a><h2 id="数据类型-6"><a href="#数据类型-6" class="headerlink" title="数据类型-6"></a>数据类型-6</h2><ul><li>循环结构内容补充(控制结构)<blockquote><p>for循环<br>do while循环<br>数组与循环<br>函数与循环<br>其它赋值运算符</p></blockquote></li></ul><hr><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul><li><p>for循环将循环语句最基本的三种行为(初始化，测试和更新)组合在一处</p><blockquote><p>其基本的语法格式为: <code>for (xxx;xxx;xxx){}</code></p></blockquote></li><li><p>关键字for后面的圆括号中的若干个表达式用分号相隔，一般在圆括号中会有至少三个表达式</p></li><li><p>即为初始化表达式，测试条件表达式，更新执行表达式</p><blockquote><p>还可将其称之为包含了循环所需的所有信息: 所选变量的初值，所选变量的终值，所选变量的循环条件(条件表达式或为自增或自减)</p></blockquote></li><li><p>在花括号内可以添加简单语句和复合语句</p></li><li><p>测试表达式的值为真时则继续循环，为假时则停止循环，其它关于的循环基本概念在<a href="http://unit-serow.com/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/#more" target="_blank" rel="noopener">数据类型-5</a>内有详细介绍</p></li><li><p>还可以将for语句圆括号内的表达式称之为控制表达式，它们都是完整的表达式，所以每个表达式的副作用(例如递增变量之类的)都发生在对下一个表达式求值之前</p></li></ul><p><strong>for循环的结构图示</strong></p><ul><li>for循环的结构:</li></ul><img src="/images/数据结构-6/for循环的结构-1.png" width="40%" height="40%"><hr><p><strong>利用C 内 for的灵活性</strong></p><ul><li><p>虽然for循环看上去和FORTRAN的DO循环，Pascal的FOR循环，ASIC 的FOR…NEXT循环类似</p><blockquote><p>但是for循环比这些循环灵活<br>这些灵活性源于如何使用for循环中的3个表达式<br>即为: 1-初始值(变量经由初始化得到的值)，2-条件表达式，3-返回类型所需要执行的某种方法(或称其为每次迭代需要执行的条件)<br>第3个表达式可以使用任意合法的表达式<br>无论是什么表达式，每次迭代都会更新该表达式的值<br>for循环中的3个表达式可以是不同的变量(注意，虽然该例可以正常运行，但是编程风格不太好，如果不在更新部分加入代数计算，程序会更加清楚)<br>可以省略一个或多个表达式(但是不能省略分号)，只要在循环中包含能结束循环的语句即可<br>这句话的意思就是，可以不在圆括号内写条件的表达式，而在for()代码行下对for语句进行说明，此时被进行说明的语句必须带有结束表示分号<br>有没有花括号无所谓，添加花括号的理由是为了让代码更整洁且直观<br>这样使用for循环确实很像其他语言的循环<br>除此之外，C 的for循环还有其他9种用法</p></blockquote></li><li><p>需要注意的要点-1: 在执行循环的其他部分之前，只对第一个表达式求值一次或执行一次</p></li><li><p>同时对于循环体中的行为可以改变循环头中的表达式，此时需要用到if语句与选择语句的概念，即为在for语句中添加复合语句，该复合语句用于执行if等条件选择语句，也可称该复合语句为代码块</p></li><li><p>for语句的一般形式</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( initialize; test; <span class="keyword">update</span> )</span><br><span class="line"><span class="keyword">statement</span></span><br></pre></td></tr></table></figure><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例语句:</p><figure class="highlight excel"><table><tr><td class="code"><pre><span class="line">for (<span class="built_in">n</span> = <span class="number">0</span>; <span class="built_in">n</span> &lt; <span class="number">10</span> ; <span class="built_in">n</span>++)</span><br><span class="line">printf(<span class="string">" %d %d\n"</span>, <span class="built_in">n</span>, <span class="number">2</span> * <span class="built_in">n</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="其它赋值运算符"><a href="#其它赋值运算符" class="headerlink" title="其它赋值运算符"></a>其它赋值运算符</h2><ul><li><p>包括<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code></p></li><li><p>C有许多赋值运算符</p><blockquote><p>最基本，最常用的是=，它把右侧表达式的值赋给左侧的变量<br>其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式<br>赋给变量的新值是根据右侧表达式的值调整后的值<br>而确切的调整方案取决于具体的运算符</p></blockquote></li><li><p>例如:</p><blockquote><p><code>scores += 20</code> 与 <code>scores = scores + 20</code> 相同<br><code>dimes -= 2</code> 与 <code>dimes = dimes - 2</code> 相同<br><code>bunnies *= 2</code> 与 <code>bunnies = bunnies * 2</code> 相同<br><code>time /= 2.73</code> 与 <code>time = time / 2.73</code> 相同<br><code>reduce %= 3</code> 与 <code>reduce = reduce % 3</code> 相同</p></blockquote></li><li><p>上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式</p></li><li><p>例如：</p><blockquote><p><code>x *= 3 * y + 12 与 x = x * (3 * y + 12)</code> 相同</p></blockquote></li><li><p>以上提到的赋值运算符与<code>=</code>的优先级相同，即比<code>+</code>或<code>*</code>优先级低</p><blockquote><p>上面最后一个例子也反映了赋值运算符的优先级，<code>3 * y</code>先与<code>12</code>相加，再把计算结果与<code>x</code>相乘，最后再把乘积赋给x<br>并非一定要使用这些组合形式的赋值运算符<br>但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效<br>当需要在<code>for</code>循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用</p></blockquote></li><li><p>通常在for的循环头内就能完成大量的工作</p></li></ul><hr><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><ul><li><p>逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式</p></li><li><p>基本使用语法:</p><blockquote><p><code>for (ounces = 1, cost = FIRST_OZ; ounces &lt;= 16; counces++,cost += NEXT_OZ)</code><br>这里的<code>FIRST_OZ</code>和<code>NEXT_OZ</code>是常量数据类型，<code>NEXT_O</code>的值是20<br>在初始化表达式中使用了逗号来对ounces和cost都进行了初始化<br>同时也在更新表达式中使用逗号来表示每次执行迭代时ounces递增1与cost递增20(因为<code>NEXT_Z</code>的值是20)</p></blockquote></li><li><p>逗号运算符的作用就是在同一个表达式区块内进行多组条件的声明</p><blockquote><p>比如在初始化表达式区块中，同时对两个变量进行初始化，或者在更新表达式中声明两个不同的变量在迭代时使用的规则与条件</p></blockquote></li><li><p>逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方</p><blockquote><p>逗号运算符有两个其他性质<br>首先，它保证了被它分隔的表达式从左往右求值(换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生)<br>因此，ounces在cost之前被初始化<br>在该例中， 顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要<br>例如，假设有下面的表达式:<br><code>ounces++, cost = ounces * FIRST_OZ</code><br>在该表达式中，先递增ounce，然后在第2个子表达式中使用ounce的新值<br>作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生</p></blockquote></li><li><p>其次，整个逗号表达式的值是右侧项的值</p></li></ul><p><strong>图解说明逗号表达式的执行逻辑</strong></p><ul><li>逗号运算符和for循环:</li></ul><img src="/images/数据结构-6/逗号运算符和for循环-1.png" width="40%" height="40%"><ul><li>在进行复杂的计算之前，可以先看看数学上是否有简单的方法可用</li></ul><hr><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><ul><li><p>出口条件循环</p></li><li><p>while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所有有可能根本不执行循环体中的内容</p></li><li><p>C 中的出口条件循环(exit-condition loop)的作用是在循环的每次迭代后检查测试条件，以保证至少执行循环体中的内容以此，这种循环被称为do while循环</p></li><li><p>do while循环的通用形式：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">statement</span></span><br><span class="line"><span class="keyword">while</span> ( expression );</span><br></pre></td></tr></table></figure></li><li><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例程序:</p><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">scanf(<span class="string">"%d"</span>,　&amp;<span class="built_in">number</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span>　(<span class="built_in">number</span>　!=　<span class="number">20</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>statement可以是一条简单语句或复合语句</p><blockquote><p>注意，do while循环以分号结尾<br>do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次<br>而for循环或while循环都是在执行循环体之前先执行测试条件<br>dowhile循环适用于那些至少要迭代一次的循环<br>例如，对用户输入的密码进行测试的程序</p></blockquote></li><li><p>do while循环的结构示意图:</p></li></ul><img src="/images/数据类型-6/do while循环结构-1.png" width="40%" height="40%"><ul><li>其它注解:</li><li>do while语句创建一个循环，在expression为假或0之前重复执行循环体中的内容<blockquote><p>do while语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环<br>因此，该循环至少必须执行一次<br>statement部分可是一条简单语句或复合语句</p></blockquote></li></ul><hr><h3 id="关于对循环的选择"><a href="#关于对循环的选择" class="headerlink" title="关于对循环的选择"></a>关于对循环的选择</h3><ul><li><p>首选需要确定是需要入口条件循环还是出口条件循环</p></li><li><p>通常，入口条件循环用的比较多</p></li><li><p>有几个原因:</p><blockquote><p>其一，一般原则是在执行循环之前测试条件比较好<br>其二，测试放在循环的开头，程序的可读性更高<br>另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环<br>那么，假设需要一个入口条件循环，用for循环还是while循环取决于个人喜好，因为二者皆可</p></blockquote></li><li><p>要让for循环看起来像while循环，可以省略第1个和第3个表达式</p><blockquote><p><code>for ( ; test ; )</code>与此的while效果相同: <code>while ( test )</code></p></blockquote></li><li><p>要让while循环看起来像for循环，可以在while循环的前面初始化变量， 并在while循环体中包含更新语句</p></li><li><p>例如:</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">初始化;</span><br><span class="line"><span class="keyword">while</span> ( 测试 )</span><br><span class="line">&#123;</span><br><span class="line">其他语句</span><br><span class="line">更新语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与下面的for循环效果相同:</p><blockquote><p><code>for ( 初始化 ;测试 ; 更新 )</code></p></blockquote></li></ul><p><strong>其他语句:</strong></p><ul><li>一般而言，当循环涉及初始化和更新变量时，用for循环比较合适<blockquote><p>而在其他情况下用while循环更好</p></blockquote></li><li>对于下面这种条件，用while循环就很合 适：<blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1)</code></p></blockquote></li><li>对于涉及索引计数的循环，用for循环更适合</li><li>例如:<blockquote><p><code>for (count = 1; count &lt;= 100; count++)</code></p></blockquote></li></ul><hr><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><ul><li><p>嵌套循环(nested loop)指在一个循环内包含另一个循环</p><blockquote><p>嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行</p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHARS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> row;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">for</span> (row=<span class="number">0</span>;row&lt;ROWS;row++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (ch=<span class="string">'A'</span>;ch&lt;(<span class="string">'A'</span>+CHARS);ch++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br></pre></td></tr></table></figure></li><li><p>程序分析:</p><blockquote><p>第10行开始的for循环被称为外层循环(outer loop)<br>第12行开始的for循环被称为内层循环(inner loop)<br>外层循环从row为0开始循环，到row为6时结束<br>因此，外层循环要执行6次，row的值从0变为5<br>每次迭代要执行的第1条语句是内层的for循环，该循环要执行10次，在同一行打印字符A～J<br>第2条语句是外层循环的printf(“\n”);<br>该语句的效果是另起一行，这样在 下一次运行内层循环时，将在下一行打印的字符<br>注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环<br>在程序中，内层循环一行打印10个字符，外层循环创建6行</p></blockquote></li><li><p>此实例中，内层循环和外层循环所做的事情相同</p></li><li><p>可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务</p><blockquote><p>比如可以根据上面的程序来修改内层循环条件<br>比如让row和A相加，而因为ch是char类型的，所以每次迭代所带来的结果就是将其初始化为不同的字符，所以程序每次对字符的打印数量都会比上一行少一个，如果没有改变测试条件，每行依旧会以F结尾<br>还可称其为依赖外部循环的嵌套循环，只不过不应该存在这种说法，因为这只是最基本的线性逻辑</p></blockquote></li></ul><hr><h3 id="关于在循环中使用数组"><a href="#关于在循环中使用数组" class="headerlink" title="关于在循环中使用数组"></a>关于在循环中使用数组</h3><ul><li><p>因为循环内经常需要用到数组，这里先对数组进行简单的说明</p><blockquote><p>数组可以作为一种存储多个相关项的便利方式</p></blockquote></li><li><p>数组(array)是按顺序存储一系列类型相同的值，如10个char类型的字符或15个int类型的值</p><blockquote><p>整个数组有一个数组明，通过整数下标来访问数组中单独的项或元素(element)</p></blockquote></li><li><p>以下是对数组进行声明的基本语法格式:</p><blockquote><p>float debts[20];</p></blockquote></li><li><p>声明debts是一个内含20个元素的数组，每个元素都可以存储float类型的值</p><blockquote><p>数组的第一个元素是debts[0]，第二个元素是debts[1]，以此类推，直到debts[19]<br>这里需要进行注意的一点就是，数组元素的编号从0开始，而非1<br>此时可以给每个元素赋float类型的值</p></blockquote></li><li><p>赋值的基本语法格式:</p><blockquote><p>debt[6] = 32.49;<br>debt[7] = 1.2e+21;</p></blockquote></li><li><p>实际上，使用数组元素和使用同类型的变量意义</p><blockquote><p>例如，可以这样把值读入指定的元素之中:<br>scanf(“%f”, &amp;debts[4]);</p></blockquote></li><li><p>这里要注意个潜在的陷阱，考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确</p><blockquote><p>所以千万不要书写和使用数组中不存在的元素，因为编译器不会查找这样的错误<br>当运行程序时，这种情况会导致数据被放在在已被其它数据占用的地方，可能会破坏程序的结果甚至导致程序因异常而中断</p></blockquote></li><li><p>数组的类型可以是任意的数据类型</p><blockquote><p>int nannies[22];<br>char actors[26];<br>long big[500];</p></blockquote></li><li><p>可以把字符串存储在char类型的数组中(一般而言，char类型数组的所有元素都存储char类型的值)</p><blockquote><p>如果char类型的数组末尾包含了一个表示字符串末尾的空字符\0，则该数组的内容就构成了一个字符串</p></blockquote></li><li><p>图解字符串数组和字符串:</p></li></ul><img src="/images/数据类型-6/字符串和字符串数组.png" width="40%" height="40%"><ul><li><p>用于识别数组元素的数字被称为下标(subscript)，索引(indice)或偏移量(offset)</p><blockquote><p>下标必须是整数，而且要从0开始计数<br>数组内的元素依次被存储在内存中相邻的为止</p></blockquote></li><li><p>图解内存中的char和int类型的数组:</p></li></ul><img src="/images/数据类型-6/内存中的char和int类型的数组.png" width="40%" height="40%"><ul><li><p>在for循环中可以使用数组，也就是使用循环来处理数组</p></li><li><p>在调整循环语句的逻辑描述时，要时刻遵守模块化(modularity)原则</p><blockquote><p>模块化原则的思想就是: 应把程序划分为一些独立的单元，每个单元执行一个任务<br>这样做能够提升程序的可读性<br>最重要的是，模块化使程序的不同部分彼此独立，方便以后更新或修改程序<br>还可以将每个执行任务的单元放进函数中，提高程序的模块化</p></blockquote></li></ul><hr><ul><li>在循环内使用函数的返回值</li><li>使用带返回值的函数</li><li>此部分可能会被补充</li></ul><hr><h3 id="概念归纳"><a href="#概念归纳" class="headerlink" title="概念归纳"></a>概念归纳</h3><ul><li>循环是一个强大的编程工具<blockquote><p>在创建循环时，要特别注意以下3个方面:</p></blockquote></li></ul><ol><li>注意循环的测试条件要能使循环结束</li><li>确保循环测试中的值在首次使用之前已初始化</li><li>确保循环在每次迭代都更新测试的值</li></ol><ul><li><p>C通过求值来处理测试条件，结果为0表示假，非0表示真</p><blockquote><p>带关系运算符的表达式常用于循环测试，它们有些特殊<br>如果关系表达式为真，其值为 1<br>如果为假，其值为0<br>这与新类型<code>_Bool</code>的值保持一致</p></blockquote></li><li><p>数组由相邻的内存位置组成，只储存相同类型的数据</p><blockquote><p>记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少1<br>C编 译器不会检查数组下标值是否有效，自己要多留心</p></blockquote></li><li><p>使用函数涉及3个步骤:</p></li></ul><ol><li>通过函数原型声明函数</li><li>在程序中通过函数调用使用函数</li><li>定义函数</li></ol><ul><li>函数原型是为了方便编译器查看程序中使用的函数是否正确<blockquote><p>函数定义描述了函数如何工作<br>现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义<br>接口部分描述了如何使用一个特性，也就是函数原型所做的<br>实现部分描述了具体的行为，这正是函数定义所做的</p></blockquote></li></ul><hr><ul><li>在便于理解的前提下，对代码的总体大小进行优化<blockquote><p>易于理解和维护的代码才是好代码<br>没必要去理解或书写一些逻辑严谨到夸张的地步和使用一大片符号类型的代码<br>可以将一句逻辑严谨的代码写成两句或三句便于理解的代码，当然是在保持美观的前提下<br>即模块化原则</p></blockquote></li></ul><hr><p><strong>内容来自原书第六章节</strong></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>C-资源整合目录</title>
    <url>/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>C-资源整合目录</strong></center><a id="more"></a><h3 id="C-资源整合目录"><a href="#C-资源整合目录" class="headerlink" title="C 资源整合目录"></a>C 资源整合目录</h3><ul><li>电子书籍</li><li>URL地址</li><li>参考资料</li></ul><hr><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><ul><li>EN-C Primer Plus</li><li>CN-C 程序设计语言</li><li>CN-数据结构与算法分析-C 语言实现</li><li>CN-C Primer Plus (第六版)<blockquote><p>C11标准<br>作者: Stephen Prata<br>译者: 姜佑</p></blockquote></li></ul><hr><p><strong>书籍目录:</strong></p><ul><li>第一章/第二章-基本概念与书籍介绍</li><li>第三章-数据和C</li><li>第四章-字符串和格式化输入/输出</li><li>第五章-运算符，表达式和语句</li><li>第六章-C控制语句：循环</li><li>第七章-C控制语句：分支和跳转</li><li>第八章-字符输入/输出和输入验证</li><li>第九章-函数</li><li>第十章-数组和指针</li><li>第十一章-字符串和字符串函数</li><li>第十二章-存储类别，链接和内存管理</li><li>第十三章-文件输入/输出</li><li>第十四章-结构和其它数据形式</li><li>第十五章-位操作</li><li>第十六章-C预处理器和C库</li><li>第十七章-高级数据表示</li></ul><p><strong>笔记归纳:</strong></p><ul><li>第一/二/三章被归纳于数据类型-1/2内</li><li>第四章被归纳于数据类型-3/4内</li><li>第五章被归纳于数据类型-5内</li><li>第六章被归纳于数据类型-6内</li><li></li></ul><hr><ul><li>本书一共十七个章节，预计使用最多50个笔记文本进行刨析归纳<blockquote><p><code>17*2+16=50</code></p></blockquote></li></ul><hr><ul><li><p>相关资源整合包</p></li><li><p><a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">百度网盘地址</a>:</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA</a><br>提取码: 0ez0</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-5</title>
    <url>/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-1</strong></center><a id="more"></a><h2 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型-5"></a>数据类型-5</h2><ul><li>语句与表达式-1<blockquote><p>C-控制语句/循环-While<br>C-控制语句/选择<br>关系运算及其关系运算符<br>条件表达式<br>真与假的概念<br>循环逻辑概念与原理</p></blockquote></li></ul><hr><ul><li>通常一门语言应该提供以下三种形式的程序流<blockquote><p>执行语句序列(即为线性的执行逻辑)<br>如果满足某些条件就进行重复执行的语句序列(循环)<br>通过测试选择执行哪一个语句序列(分支/控制)</p></blockquote></li></ul><hr><h2 id="C-控制语句-循环"><a href="#C-控制语句-循环" class="headerlink" title="C 控制语句-循环"></a>C 控制语句-循环</h2><h3 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h3><ul><li><p>while循环是入口条件循环</p><blockquote><p>或称其为while循环是使用入口条件的有条件循环<br>所谓的有条件指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)<br>该表达式是一个入口条件(entry condition)，因为必须满足条件才能进入循环体<br>如果条件一开始就为假，则绝对不会进入循环体，则跳过循环体代码块</p></blockquote></li><li><p>可以把下面的伪代码作为while循环的标准格式:</p></li></ul><p>1.利用循环外的语句对循环内的变量进行值传递<br>2. 获得第1个用于测试的值 (while (循环条件))<br>3. 当测试为真时<br>4. 处理值 (根据循环条件)<br>5. 获取下一个值 scanf()</p><ul><li><p>当被输入的值传递进循环并可以保证条件为真时，开始第一轮循环</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>); <span class="comment">/* 定义被输入值的变量 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">status</span> == <span class="number">1</span>) <span class="comment">/* 定义循环条件 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>);  <span class="comment">/* 定义循环行为，即接受被输入的值，当接受的值可以满足循环条件时则为真，开始迭代 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以写为</p><blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1){/* 循环行为 */}</code></p></blockquote></li><li><p>while循环的通用形式如下：</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ( expression )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>其中statement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句</p></li><li><p>在大部分的程序内，expression部分都使用关系表达式</p><blockquote><p>也就是说，expression是值之间的比较，可以使用任何表达式<br>如果expression为真(或者更一般地说，非零)，则执行statement部分一次，然后再次判断expression<br>在expression为假(0)之前，循环的判断和执行一直重复进行<br>每次循环都被称为一次迭代/循环一轮(iteration)</p></blockquote></li><li><p>while循环结构示意图:</p></li></ul><img src="/images/数据类型-5/C-循环语句-1.png" width="30%" height="30%"><ul><li><p>while循环有一点非常重要: 在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假</p><blockquote><p>否则，循环就不会终止(可以使用 break和if语句来终止循环)</p></blockquote></li><li><p>最大正值加一一般 会得到一个负值，类似地，最小负值减一一般会得到最大正值</p></li></ul><hr><h3 id="while的语法要点"><a href="#while的语法要点" class="headerlink" title="while的语法要点"></a>while的语法要点</h3><ul><li><p>使用while时，要牢记一点: 只有在测试条件后面的单独语句(简单语句或符合语句)才是循环部分</p><blockquote><p>while循环语句的格式应为while(){}，而绝非{while()}，陷入无限循环(infinite loop)是最常见的情况</p></blockquote></li><li><p>还有一点就是，即便while语句本身使用符合语句，while的本质依旧是一条单独的语句(或称为在语句构成上)</p><blockquote><p>该语句从while开始执行，到第一个分号结束，在使用复合语句的情况下，到右花括号结束，还需要注意分号的为止，一定要在语句结束时再写分号</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li><li><p>在使用while语句时，可以直接将分号写在条件表达式后面，即可以让程序直接进入下一个迭代，因为一个单独的分号被视为一条语句</p></li><li><p>如果在测试条件(条件表达式)的代码后面直接添加单独的分号</p><blockquote><p>此分号则代表为一个空语句(null statement)，它什么也不做<br>在 C 中，单独的分号表示空语句，而处理空语句最好的方法是使用continue语句</p></blockquote></li></ul><hr><h3 id="关系运算符与表达式"><a href="#关系运算符与表达式" class="headerlink" title="关系运算符与表达式"></a>关系运算符与表达式</h3><ul><li><p>用关系运算符和表达式来比较大小</p></li><li><p>以下关于关系表达式与关系运算符的概念在所有的循环类语句概念中都通用，这里的通用泛指计算机上所有的程序语言</p></li><li><p>while循环经常依赖测试表达式来作比较，这样的表达式被称之为关系表达式(relational expression)</p></li><li><p>而出现在关系表达式中间的运算符叫做关系运算符(relational operator)</p></li><li><p>以下表图片内列出了 C 的所有关系运算符，同时该表也涵盖了所有的数值关系</p></li><li><p>关系运算符:</p></li></ul><img src="/images/数据类型-5/关系运算符-1.png" width="30%" height="30%"><ul><li><p>PS: 数字之间的关系再复杂也没有人与人之间的关系复杂-来自原书</p></li><li><p>关系运算符常用于构造while语句和其他C语句中用到的关系表达式</p><blockquote><p>这些语句都会检查关系表达式为真还是为假</p></blockquote></li><li><p>所谓关系运算符，存在的意义就是对人为所描述的表达式的值进行确定，确定的结果只有0和1，即真与假</p></li><li><p>而在确定的过程中，最常见的确定方法就是与人为所规定的值进行字符的比较</p></li><li><p>如果要对浮点数进行比较，尽量要去只是用&lt;和&gt;，因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等</p></li><li><p>为了避免此类型错误的发生，C 内拥有fabs()函数，该函数声明在math.h头文件中</p><blockquote><p>使用该函数可以较为方便的比较浮点数，该函数返回一个浮点的绝对值(即为没有代数符号的值)</p></blockquote></li></ul><hr><p><strong>fabs()函数使用示范:</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line">	<span class="keyword">double</span> response;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"What is the value of pi?\n"</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"lf"</span>, &amp;response);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Try again!\n"</span>);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;response);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Close enough!\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差 0.0001：</p></li><li><p>输出结果:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">What <span class="keyword">is</span> the value of pi?</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">Try again!</span><br><span class="line"><span class="number">3.1416</span></span><br><span class="line">Close enough!</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="何为真"><a href="#何为真" class="headerlink" title="何为真"></a>何为真</h3><ul><li><p>这是一个古老的问题，但是对C而言还不算难、</p></li><li><p>在C中，表达式一定有 一个值，关系表达式也不例外</p></li><li><p>可以使用并输出两条简单的比较语句，比如说 <code>true_val=(10&gt;2);</code>和<code>false_val(10==2);</code>，前者为真，后者为假</p><blockquote><p>则输出的结果必定是true=1，而false=0</p></blockquote></li><li><p>所以说，对 C 而言，表达式为真的值为1，表达式为假的值为0</p></li><li><p>当 C 程序的循环结构的判断结果一直为真(即为1)时，则反复且永远进行条件及语句的迭代</p></li><li><p>所以一些C程序使用下面的结构，由于1为真，所以该循环会一直进行</p><blockquote><p><code>while (1){...}</code></p></blockquote></li></ul><p><strong>关于其它的真值:</strong></p><ul><li><p>在 C 中，所有的非零值都被视为真，只有0被视为假</p><blockquote><p>也就是说，只要测试条件的值为非零，就会执行while循环</p></blockquote></li><li><p>这是从数值方面而不是从真/假方面来看测试条件</p><blockquote><p>还有需要进行牢记的一点就是，关系表达式为真，求值得一，关系表达式为假，求值得零<br>因此，这些表达式实际上相当于数值，所以必须要去充分利用测试条件的这一特性<br>比如，用while(goats)替换while(goats !=0)，因为表达式goats !=0和goats都只有在goats的值为0时才为0或假，所以再增加一个不等于(!=)的比较运算符的毫无意义的<br>这里利用了 C 内自动判断真值与假值的性质，或称其为默认值与自然选择</p></blockquote></li><li><p>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编译代码，从而使代码更加整洁与美观</p></li><li><p>这个特点既为好处，也为坏处，C 由于对真的约束太少，会带来一些麻烦</p><blockquote><p>当循环的条件表达式中没有定义==1，而定义了=1时，此时的条件表达式中的变量的值为一<br>而且，整个赋值表达式的值就是赋值运算符左侧的值，所以变量=1的值也是1，既while(变量=1)实际上就相当于while(1)<br>也就是说，循环不会退出，此时如果人为的输入其它的符号，从而让变量的值归于0，但是循环的测试条件又把改变量重置为1，从而又进入了下一次迭代<br>此时程序中的循环一直运行着，用户在输如符号后完全没有机会输入，如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，以供下一次读取<br>当scanf()把输入的符号(这里的符号可以为任何不属于数字的数据类型)作为整数读取失败了，他将会把字符留下<br>在下一次循环时，scanf()从上次读取失败的地方(被输入字符)开始读取，scanf()把该输入的字符再次作为整数读取，然后又失败了<br>以此，就造成了一个无限的循环，而且还是失败的</p></blockquote></li><li><p>所以这里千万需要注意的一点就是，千万别把关系相等运算符==和赋值运算符=给弄错了</p></li><li><p>因为 C 不允许给常量赋值</p><blockquote><p>而且编译器会把赋值运算符的这种用法作为语法错误标记出来<br>可以在构建比较是否相等的表达式时，把常量放在左侧，比如<code>6 = canoes;</code></p></blockquote></li><li><p>好在计算机察觉不出来，因为对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样-来自原文</p></li><li><p>总之，关系运算符用于构成关系表达式</p><blockquote><p>关系表达式为真时值为1，为假时值为0<br>通常用关系表达式作为测试条件的语句(如while和if)可以使用任何表达式作为测试条件<br>即非零为真，零为假</p></blockquote></li><li><p>以类似于<code>while (条件表达式)</code>这样的格式为变量进行命名可以让while循环的测试变得简单易懂</p></li></ul><hr><h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a><code>_Bool</code>类型</h3><ul><li><p>在 C 中，一直用int类型的变量表示真/假值</p></li><li><p>C99专门针对这种类型 的变量新增了<code>_Bool</code>类型</p><blockquote><p>该类型是以英国数学家George Boole的名字命名 的，他开发了用代数表示逻辑和解决逻辑问题<br>在编程中，表示真或假的变量被称为布尔变量(Boolean variable)，所以<code>_Bool</code>是 C 中布尔变量的类型名<br>其中<code>_Bool</code>类型的变量只能储存1(真)或0(假)<br>如果把其他非零数值赋给<code>_Bool</code>类型的变量，该变量会被设置为1<br>这反映了C把所有的非零值都视为真<br>给布尔变量取一个能表示真或假值的变量名是一种常见的做法</p></blockquote></li><li><p>C99提供了<code>stdbool.h</code>头文件，该头文件让<code>bool</code>成为<code>_Bool</code>的别名</p><blockquote><p>而且还把true和false分别定义为1和0的符号常量<br>包含该头文件后，写出的代码可以与C++兼容<br>因为C++把bool，true和false定义为关键字<br>如果系统不支持<code>_Bool</code>类型，导致无法运行该程序<br>可以把<code>_Bool</code>替换成 int即可</p></blockquote></li></ul><hr><h3 id="优先级和关系运算符"><a href="#优先级和关系运算符" class="headerlink" title="优先级和关系运算符"></a>优先级和关系运算符</h3><ul><li><p>关系运算符的优先级比算术运算符(包括+和-)要更低，而比赋值运算符要高</p></li><li><p>关系运算符之间有两种不同的优先级。</p><blockquote><p>高优先级组: &lt;&lt;= &gt;&gt;=<br>低优先级组: == !=</p></blockquote></li><li><p>与其他大多数运算符一样，关系运算符的结合律也是从左往右</p></li><li><p>以下图片列表列出了常用的关系运算符优先级关系，具体可以参考-[C 运算符]，其中列出了全部运算符的完整优先级列表</p></li><li><p>运算符优先级:</p></li></ul><img src="/images/数据类型-5/C-关系运算符优先级-1.png" width="30%" height="30%"><hr><h3 id="关于不确定循环和计数循环"><a href="#关于不确定循环和计数循环" class="headerlink" title="关于不确定循环和计数循环"></a>关于不确定循环和计数循环</h3><ul><li><p>一些while循环是不确定循环(indefinite loop)</p><blockquote><p>所谓不确定循环，指 在测试表达式为假之前，预先不知道要执行多少次循环</p></blockquote></li><li><p>还有一类是计数循环(counting loop)</p><blockquote><p>这类循环在执行循环之前就知道要重复执行多少次</p></blockquote></li><li><p>在创建一个重复执行固定次数的循环中涉及了3个行为:</p></li></ul><p>1.必须初始化计数器<br>2.计数器与有限的值作比较<br>3.每次循环时递增计数器</p><ul><li>while循环的测试条件执行比较，递增运算符执行递增<blockquote><p>如果递增发生在循环的末尾，即可以防止不小心漏掉递增<br>因此，这样做比将测试和更新组合放在一起要好，但是计数器的初始化放在循环外，就有可能忘记初始化<br>此时可以用for循环来避免这种情况的发生</p></blockquote></li></ul><hr><p><strong>其它内容:</strong></p><ul><li>赋值运算符 用于将右值赋给左值，而左值通常为变量</li><li>赋值表达式</li><li>关系运算符 用于对左值和右值进行比较</li><li>条件运算符</li></ul><hr><h3 id="伪代码-pseudocode"><a href="#伪代码-pseudocode" class="headerlink" title="伪代码(pseudocode)"></a>伪代码(pseudocode)</h3><ul><li>是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应</li><li>伪代码有助于涉及程序的逻辑</li><li>确定程序的逻辑无误后，再把伪代码翻译成实际的代码</li><li>使用为伪代码的好处之一是，可以把注意力集中再程序的组织和逻辑上，不用在设计程序时还要分心去想如何用编程语言来表达自己的想法</li><li>例如可以用缩进来代表一块代码，不用考虑 C 的语法要用花括号把部分代码括起来</li></ul><hr><h3 id="其它理解"><a href="#其它理解" class="headerlink" title="其它理解"></a>其它理解</h3><hr><ul><li><p>程序按照序列逻辑进行线性执行</p></li><li><p>由主函数mian()开始</p><blockquote><p>然后线性执行主函数内所调用的函数和语句<br>而其它的函数也是相同的原理，函数内的任何语句都是根据线性逻辑来逐一执行<br>至于循环语句与控制语句也是由线性逻辑来执行的，即执行完该语句上面的所有语句，再进行对循环或控制语句的执行<br>各种基本数据对象根据逻辑构成语句(数据对象可以包括变量，数组，指针，运算符，关键字或对于其它函数的调用等等)</p></blockquote></li><li><p>语句构成函数</p></li><li><p>函数构成程序</p></li><li><p>在计算机内，构成任何数据对象的逻辑都是线性的，即逐一执行</p></li></ul><hr><ul><li>预处理器(对于头文件的处理方法，通常是在程序编译之前就已经将头文件中的内容处理完毕，处理的对象即为对于所指头文件内函数的对应调用)</li><li>头文件(给当前的程序本身提供外部函数的支持，即对于当前语言标准库的支持)</li></ul><ol><li>定义常量</li><li>定义全局变量</li><li>函数声明</li></ol><ul><li>主函数<code>main(){包括了对于其它函数的调用以及线性逻辑执行}</code><blockquote><p>对于其它函数的补充</p></blockquote></li></ul><hr><ul><li><p>声明函数的基本格式为: <code>void funtion_name (void) {函数内容}</code></p><blockquote><p>圆括号内所声明的参数可称其为形式参数，即为没有值，但有数据类型的变量数据类型<br>前者的void为函数本身的数据类型，最常用的是整形类型或长整型类型<br>函数的类型用于声明让函数实现的功能模块</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li><p>每个函数或每个花括号都可以被称为是代码块</p></li><li><p>写程序的大体逻辑</p></li></ul><ol><li>先将常量和全局变量声明完毕</li><li>进行函数声明</li><li>然后先写上主函数</li><li>再对函数进行补充，以实现其对应功能</li><li>最后再主函数中的内容进行补充(通常就是对已存在的函数进行进行逐一调用)</li><li>编译源代码并执行程序</li></ol><ul><li>在计算机内，一切的执行逻辑都是线性的</li></ul><hr><ul><li><p>条件表达式与条件语句的本质就是判断值的真假或称其为0或1，用更大的范围去描述则是0与任何实数，即0就是假，或称其为无，其它的任何数都是真，或称其为有</p></li><li><p>无论是循环语句，选择语句还是任何的控制语句(流程控制语句)，它们存在(或称其为存在)的意义都是为了对所选条件表达式的值进行判断，而判断的结果只有两个，即为0与1</p></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编写代码，从而使代码更加整洁与美观</li><li>千万不要忘了伪代码的概念，一般的思路梳理就是对所谓伪代码的实现</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-4</title>
    <url>/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-运算符与表达式-1</strong></center><a id="more"></a><h2 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型-4"></a>数据类型-4</h2><ul><li>重点为运算符与表达式</li></ul><hr><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p><strong>涉及概念:</strong></p><ul><li>一元运算符</li><li>二元运算符</li><li>左值与右值</li><li>表达式和语句</li><li>基本循环及其符合语句</li><li>副作用与序列点</li></ul><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p><strong>右值</strong></p><ul><li><p>右值(rvale)，通常只能是字面常量</p><blockquote><p>而字面常量不能常量赋值，因为常量本身就是它的值<br>因此，在使用赋值运算符=时，左侧的项必须是一个变量名<br>实际上，赋值运算符左侧必须引用一个存储位置，而最简单方法就是使用变量名<br>不过指针也可用于指向一个存储位置<br>概括地说，C 使用可修改的左值(modifiable lvalue)标记那些可赋值的实体(物理内存)</p></blockquote></li><li><p>术语概览: 数值对象，左值，右值和运算符</p></li><li><p>赋值表达式语句的目的是把值存储到内存位置上</p></li><li><p>用于存储值的数据存储区域被称之为对象(data object)</p></li><li><p>C 标准中只有提到赋值的概念时，才有可能涉及到对象这个术语</p></li><li><p>使用变量名是表示对象的唯一方法，除此之外还有其它的方法，例如指定数组的元素，结构的成员，或者使用指针表达式(指针中存储的是它所指对象的地址)</p></li><li><p>相关的具体细节这里不做过多阐述</p></li></ul><p><strong>左值</strong></p><ul><li><p>左值(lvalue)是C的术语，用于表示特定数据对象的名称或表达式</p><blockquote><p>因此，对象指的是实际的数据存储，而左值是用于表示或定位存储位置的标签</p></blockquote></li><li><p>对于早期的C，左值所涉及的意义:</p></li></ul><ol><li>它指定一个对象，所以引用内存中的地址</li><li>它可以在赋值运算符的左侧，左值(lvalue)中的l源自left</li></ol><ul><li>但后来的C标准中新增了const限定符，用const创建的变量为只读变量，即为不可修改<blockquote><p>因此，const标识符可以满足上面的第一项，而无法满足第二项<br>一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧<br>有些左值不能用于赋值运算符的左侧，因此，标准对左值的定义已经不能满足当前的状况<br>为此，C标准新定义了一个术语: 可修改的左值(modifable lvalue)，此方法用于标识可修改的对象<br>所以，赋值运算符的左侧应该是可修改的值，当前标准建议，使用术语对象定位值(object locator value)更好</p></blockquote></li></ul><hr><p><strong>右值</strong></p><ul><li><p>右值(rvalue)指的是能赋值给可修改左值的量，且本身不是左值</p><blockquote><p>右值中的r源自right</p></blockquote></li><li><p>右值可以是常量，变量或其它可求值的表达式(如，函数调用)</p><blockquote><p>实际上，当前标准在描述这一概念时使用的是表达式的值(value of an expression)，而非右值<br>右值示例: bmw = 2002;，此时的2002则为右值</p></blockquote></li><li><p>左值就是用于引用某指定内存位置的标识符，而右值即为存储于该内存位置的值</p></li><li><p>在名称学习时，被称为”项”(如，赋值运算符左侧的项)的就是运算符对象(operand)</p><blockquote><p>运算对象指的就是运算符操作的对象<br>还可以类似的将”=运算符的左侧对象”称之为是”应该是可修改的左值”</p></blockquote></li></ul><hr><h2 id="基本的算术运算符-一元-二元运算符"><a href="#基本的算术运算符-一元-二元运算符" class="headerlink" title="基本的算术运算符-一元/二元运算符"></a>基本的算术运算符-一元/二元运算符</h2><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul><li>二元运算符最基本的定义是运算对象至少是两个值</li><li>最基本的二元运算符是四则运算标识符</li></ul><p><strong>加法运算符</strong></p><ul><li>加法运算符(addition operator)用于加法运算，使其两侧的值相加<blockquote><p>而相加的值(运算对象)可以是对象，也可以是常量<br>比如 icome = salary + bribes;，计算机会查看加法运算符右侧的两个变量，即为右值，将其相加，然后将相加的和(返回的结果)赋值给变量income<br>这里需要注意的一点是，income，salary，bribes都是可修改的左值，因为每个变量都标识了一个可被赋值的数据对象<br>但是，表达式salary + brives是一个右值</p></blockquote></li></ul><p><strong>减法运算符</strong></p><ul><li>减法运算符(subtraction operator)用于减法运算，使其左侧的数减去右侧的数<blockquote><p>例如，下面的语句把200.0赋给takehome：<br>takehome = 224.00 – 24.00;<br>+和-运算符都被称为二元运算符(binary operator)，即这些运算符需要两个运算对象才能完成操作</p></blockquote></li></ul><hr><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul><li>一元运算符(unary operator)</li><li>一元运算符就是符号运算符，即仅需要运算一个运算对象的运算符<blockquote><p>类似于赋值运算符=，数值标识符-，+(正值与负值)，指针标识符&amp;和*等等</p></blockquote></li></ul><p><strong>符号运算符:-和+</strong></p><ul><li><p>减号还可用于标明或改变一个值的代数符号</p><blockquote><p>rocky = -12;，以这种方式使用的负号被称之为一元运算符</p></blockquote></li><li><p>在C90标准中新增了一元+运算符，它不会改变运算对象的值或符号</p><blockquote><p>只能这样使用: dozen = +12;<br>此时编译器不会报错，但是在以前，这样做是不被允许的</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>二元运算符和一元运算符:</li></ul><img src="/images/数据类型-4/运算符-1.png" width="30%" height="30%"><hr><p><strong>乘法运算符</strong></p><ul><li>符号*表示乘法<blockquote><p><code>cm = 2.56 * inch;</code>，该语句就是用2.56乘以inch，并将结果赋值给cm<br>因为C 内没有平方函数与指数函数，所以只能用循环语句来实现平方与其它指数级增长</p></blockquote></li></ul><p><strong>除法运算符</strong></p><ul><li><p>C使用符号/来表示除法</p></li><li><p>符号/左侧的值是被除数，右侧的值是除数</p><blockquote><p>例如，此表达式中four的值是<code>4.0: four = 12.0/3.0;</code></p></blockquote></li><li><p>整数除法和浮点数除法不同</p><blockquote><p>浮点数除法的结果是浮点数，而整数除法的结果是整数<br>整数是没有小数部分的数<br>这使得5除以3很让人头痛，因为实际结果有小数部分</p></blockquote></li><li><p>在C语言中，整数除法结果的小数部分被丢弃</p><blockquote><p>这一过程被称为截断(truncation)</p></blockquote></li><li><p>一般情况下最好避免混合类型的出现，即同一个除法表达式内同时出现整数与浮点数</p><blockquote><p>因为计算机不能真正的使用浮点数去除以整数，所以编译器会把两个运算对象转换成相同的类型<br>即在进行出发运算之前，将整数转换为浮点数，或将浮点数转换为整数</p></blockquote></li><li><p>在C99标准以前，C语言给语言的实现者留有一些空间</p><blockquote><p>让他们来决定如何进行负数的整数除法<br>一种方法是，舍入过程采用小于或等于浮点数的最大整数<br>当然，对于<code>3.8</code>而言，处理后的3符合这一描述<br>但是当需要处理<code>-3.8</code>时，该方法建议四舍五入为<code>-4</code><br>因为<code>-4</code> 小于<code>-3.8</code><br>但是，另一种舍入方法是直接丢弃小数部分<br>这种方法被称为”趋零截断”，即把<code>-3.8</code>转换成<code>-3</code><br>在C99以前， 不同的实现采用不同的方法<br>但是C99规定使用趋零截断<br>所以，应把-<code>3.8</code>转换成<code>-3</code></p></blockquote></li></ul><hr><ul><li>当同一个表达式内出现了多种不同种类的运算符时，运算符会出现优先级限制</li></ul><p><strong>图片说明:</strong></p><ul><li>目前为止文章内涉及的运算符优先级(从低至高):</li></ul><img src="/images/数据类型-4/运算符优先级-1.png" width="30%" height="30%"><ul><li>优先级和求值顺序<blockquote><p>运算符的优先级为表达式中的求值顺序提供了重要的依据，但是并没有规定所有的顺序<br>所以 C 给实现者留出了选择的余地</p></blockquote></li></ul><hr><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><ul><li>C 中有大约40个运算符，有些运算符比其它运算符常用的多<blockquote><p>这里只对最常用的运算符进行讨论</p></blockquote></li></ul><p><strong>sizefo运算符与其相关类型</strong></p><ol><li>sizeof运算符和<code>size_t</code>类型<blockquote><p>sizeof运算符以字节为单位返回运算对象的大小(在C中，1字节定义为char类型占用的空间大小)<br>过去，1字节通常是8位，但是一些字符集可能使用更大的字节<br>运算对象可以是具体的数据对象(如，变量名)或类型<br>如果运算对象是类型(如， float)，则必须用圆括号将其括起来</p></blockquote></li></ol><ul><li>C 规定，sizeof返回<code>size_t</code>类型的值<blockquote><p>这是一个无符号整数类型， 但它不是新类型</p></blockquote></li><li><code>size_t</code>是语言定义的标准类型<blockquote><p>C 有一个typedef机制<br>允许程序员为现有类型创建别名<br>例如:<br><code>typedef double real;</code><br>这样，real就是double的别名</p></blockquote></li><li>现在，可以声明一个real类型的变量:<blockquote><p><code>real deal; // 使用typedef</code><br>编译器查看real时会发现，在typedef声明中real已成为double的别名<br>于是把deal创建为double 类型的变量<br>类似地，C 头文件系统可以使用typedef把<code>size_t</code>作为<code>unsigned int</code>或<code>unsigned long</code>的别名<br>这样，在使用<code>size_t</code>类型时，编译器会根据不同的系统替换标准类型</p></blockquote></li><li>C99 做了进一步调整，新增了<code>%zd</code>转换说明用于<code>printf()</code>显示<code>size_t</code>类型的值<blockquote><p>如果系统不支持<code>%zd</code>，可使用<code>%u</code>或<code>%lu</code>代替<code>%zd</code></p></blockquote></li></ul><hr><p><strong>求模运算符</strong></p><ol start="2"><li>求模运算符(modulus operator): <code>%</code></li></ol><ul><li><p>用于整数运算</p></li><li><p>求模运算符给出其左侧整数除以右侧整数的余数(remainder)</p><blockquote><p>例如，<code>13 % 5</code>(读作”13求模5”)得3，因为13比5的两倍多3，即13除以5的余数是3<br>求模运算符只能用于整数，不能用于浮点数</p></blockquote></li><li><p>求模运算符常用于控制程序流</p><blockquote><p>例如，假设此时正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用<br>这种情况可以在程序中对月份求 模3(即，month % 3)，并检查结果是否为0<br>如果为0，便加进额外的费用</p></blockquote></li><li><p>求模运算符作得出的结果就是所谓的取余运算所得出的结果</p></li><li><p>负数也可以进行求模运算，于C99开始支持了趋零截断</p></li></ul><hr><p><strong>递增运算符</strong></p><ul><li><p>递增运算符(increment operator)-即为’++’</p></li><li><p>用于执行简单的任务，将其运算对象递增1</p><blockquote><p>该运算符以两种方式出现<br>第1种方式，++出现在其作用的变量前面， 这是前缀模式<br>第2种方式，++出现在其作用的变量后面，这是后缀模式<br>两种模式的区别在于递增行为发生的时间不同</p></blockquote></li></ul><hr><p><strong>while循环的执行逻辑</strong></p><ul><li>根据所规定条件，对条件进行循环执行</li><li>例如规定了一个条件为<code>shoe &lt; 18</code>，并且每执行一次就进行一次递加(++)的表达式<blockquote><p>执行的逻辑是shoe的值递增1，然后和18进行比较，如果递增后的值小于18，则再次执行所规定的循环条件(即为所在花括号内的所有语句)<br>然后，shoe的值再递增1，以此重复刚才的不做，知道shoe的值不小于18为止</p></blockquote></li></ul><p><strong>图解示意:</strong></p><ul><li>执行一次循环:</li></ul><img src="/images/数据类型-4//images/while循环-1.png" width="30%" height="30%"><hr><p><strong>关于前缀递增和后缀递增</strong></p><ul><li><p>这里举一个例子:</p><blockquote><p><code>q = 2*++a;</code>，此语句为前缀形式递增，首先，a递增1，然后，2乘以a，并将结果赋给q<br><code>q =2*a++;</code>，此语句为后缀形式递增，首先，2乘以a，并将结果赋给q，然后，a递增1</p></blockquote></li><li><p>单独使用递增运算符时(如，ego++;)，使用哪种形式都没关系</p><blockquote><p>但是，当运算符和运算对象是更复杂表达式的一部分时(如上面的示例)<br>使用前缀或后缀的效果不同</p></blockquote></li></ul><hr><p><strong>递减运算符</strong></p><ul><li><p>每种形式的递增运算符都有一个递减运算符(decrement operator)与之对应</p></li><li><p>用–代替++即可:</p><blockquote><p><code>--count; // 前缀形式的递减运算符</code><br><code>count--; // 后缀形式的递减运算符</code></p></blockquote></li><li><p><code>&gt;</code>运算符表示”大于”，<code>&lt;</code>运算符表示”小于”，它们都是关系运算符(relational operator)</p></li></ul><hr><p><strong>递增运算符的优先级问题</strong></p><ul><li>递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高<blockquote><p>因此，<code>x*y++</code>表示的是<code>(x)*(y++)</code>，而不是<code>(x+y)++</code><br>不过后者无效，因为递增和递减运算符只能影响一个变量(或者更普遍地说，只能影响一个可修改的左值)<br>而组合<code>x*y</code>本身不是可修改的左值</p></blockquote></li></ul><hr><p><strong>不要自作聪明</strong></p><ul><li>如果一次用太多递增运算符，自己都会糊涂-CN-C Primer Plus-第5.3.6章节</li></ul><hr><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>术语: 表达式(expression)和语句(statement)</li><li>C 的基本程序步骤由语句组成，而大多数语句都由表达式构成</li></ul><p><strong>表达式:</strong></p><ul><li><p>表达式(expression)由运算符和运算对象组成(运算对象是运算符操作的对象)</p><blockquote><p>最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式</p></blockquote></li><li><p>运算对象可以是常量，变量或二者的组合</p><blockquote><p>一些表达式由子表达式(subexpression)组成(子表达式即较小的表达式)</p></blockquote></li><li><p>每个表达式都有一个值</p><blockquote><p>C 表达式的一个最重要的特性是，每个表达式都有一个值<br>要获得这个值，必须根据运算符优先级规定的顺序来执行操作<br>关于表达式的值的具体描述这里不做赘述，因为它是一个范围极大的纯粹性概念<br>计算机中表达式的概念与数学中的表达式相同，值即为表达式的结果</p></blockquote></li></ul><hr><p><strong>语句</strong></p><ul><li><p>语句(statement)是C程序的基本构建块</p><blockquote><p>一条语句相当于一条完整的计算机指令<br>在C中，大部分语句都以分号<code>&#39;;&#39;</code>结尾</p></blockquote></li><li><p>声明创建了名称和类型，并为其分配内存位置</p><blockquote><p>注意，声明不是表达式语句<br>也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值:<br><code>int port /* 不是表达式，没有值 */</code></p></blockquote></li><li><p>赋值表达式语句在程序中很常用: 它为变量分配一个值</p><blockquote><p>赋值表达式语句的结构是: 一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾<br>注意，在while循环中有一个赋值表达式语句<br>赋值表达式 语句是表达式语句的一个示例</p></blockquote></li><li><p>函数表达式语句会引起函数调用</p><blockquote><p>在该例中，调用printf()函数打印结果<br>while语句有3个不同的部分: 首先是关键字while，然后圆括号中是待测试的条件，最后如果测试条件为真，则执行while循环体中的语句<br>多条语句需要用花括号括起来</p></blockquote></li><li><p>图片-简单的while循环结构:</p></li></ul><img src="/images/数据类型-4/while循环-2.png" width="30%" height="30%"><ul><li>这种语句是复合语句<blockquote><p>该例的while循环中只有一条语句<br>可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句<br>while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂</p></blockquote></li></ul><hr><p><strong>关于副作用与序列点:</strong></p><ul><li>类似于while之类的迭代循环语句通常还会有副作用(side effect)和序列点(sequence point)等概念，这里不做过多赘述<blockquote><p>所谓的副作用，就是对于变量的赋值结果(此间的赋值结果由右值的表达式决定)<br>或称其为经由人工定义所得出的等式结果<br>所谓的序列点，就是程序执行的点，再该点上，所有的副作用都在进入下一步之前发生<br>C 中的语句用分号<code>&#39;;&#39;</code>来标记若干个序列点<br>其寓意就是在一个语句中，赋值运算符，递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成<br>还有一点就是，任何一个完整表达式的结束也是一个序列点</p></blockquote></li></ul><p><strong>关于完型表达式:</strong></p><ul><li>完整表达式(full expression)<blockquote><p>就是指这个表 达式不是另一个更大表达式的子表达式<br>例如，表达式语句中的表达式和while循环中的作为测试条件的表达式<br>都是完整表达式<br>序列点有助于分析后缀递增何时发生<br>千万要避免写出带有模棱两可逻辑的语句</p></blockquote></li></ul><p><strong>关于复合语句(块)</strong></p><ul><li><p>复合语句(compound statement)是用花括号括起来的一条或多条语句</p><blockquote><p>或称之为复合语句(或块)由花括号括起来的一条或多条语句组成<br>复合语句也称为块(block)<br>任何的程序都可以使用块以让while语句包含多条语句<br>在声明与描述复合语句的构成时，需要注意书写风格，其中最重要的是对于代码缩进的掌控</p></blockquote></li><li><p>图片-带有符合语句的while循环</p></li></ul><img src="/images/数据类型-4/while循环-3.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>一般函数的形式: void xxx(void)<br>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参<br>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)<br>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p><p>关于实参和形参的其它说明:</p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p>关于函数的调用:</p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-1-1"><a href="#补充内容-1-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p>一般函数的形式: void xxx(void)</p><blockquote><p>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p></blockquote></li><li><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参</p><blockquote><p>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p></blockquote></li><li><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)</p><blockquote><p>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p></blockquote></li></ul><p><strong>关于实参和形参的其它说明:</strong></p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p><strong>关于函数的调用:</strong></p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-2"><a href="#补充内容-2" class="headerlink" title="补充内容-2"></a>补充内容-2</h3><ul><li>C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符<blockquote><p>一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值<br>只需要一个 运算对象的运算符(如负号和sizeof)称为一元运算符，需要两个运算对象的运算符(如加法运算符和乘法运算符)称为二元运算符</p></blockquote></li><li>表达式由运算符和运算对象组成<blockquote><p>在C语言中，每个表达式都有一个 值，包括赋值表达式和比较表达式<br>运算符优先级规则决定了表达式中各项 的求值顺序<br>当两个运算符共享一个运算对象时，先进行优先级高的运算<br>如果运算符的优先级相等，由结合律(从左往右或从右往左)决定求值顺序</p></blockquote></li><li>大部分语句都以分号结尾<blockquote><p>最常用的语句是表达式语句</p></blockquote></li><li>用花括号括起 来的一条或多条语句构成了复合语句(或称为块)</li><li>while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句</li><li>在C语言中，许多类型转换都是自动进行的<blockquote><p>当char和short类型出现在 表达式里或作为函数的参数(函数原型除外)时，都会被升级为int类型<br>float类型在函数参数中时，会被升级为double类型<br>在K&amp;R C(不是ANSI C)下，表达式中的float也会被升级为double类型<br>当把一种类型的值赋给 另一种类型的变量时，值将被转换成与变量的类型相同<br>当把较大类型转换 成较小类型时(如，long转换成short，或 double 转换成 float)，可能会丢失数据<br>根据之前介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型</p></blockquote></li><li>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数<blockquote><p>然后，在函数调用中传入的值会被赋给这个变量<br>这样，在函数中 就可以使用该值了</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-3</title>
    <url>/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-数组/字符串类型-1</strong></center><a id="more"></a><h3 id="数据类型-3"><a href="#数据类型-3" class="headerlink" title="数据类型-3"></a>数据类型-3</h3><ul><li>数据类型/派生类型/数组/字符串</li><li>字符串存储原理</li><li>数组存储原理</li></ul><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>概述:</strong></p><ul><li>字符串(character string)</li><li>本质上是一个或多个字符的序列，即为字符数据类型的数组，可表示为”xxx yyy”</li><li>双引号不是字符串的一部分，双引号只是用于告知编译器括起来的是字符串，正如单引号用于标识单个字符</li></ul><p><strong>char类型数组和null字符</strong></p><ul><li>因为 C 中没有专门用于存储字符串的变量类型，所以字符串都被存储在char类型的数组当中</li><li>数组由连续的存储单元构成，所以字符串中的字符类型都被存储在相邻的存储单元中，即每个单元存储一个字符</li></ul><p><strong>具体图示</strong></p><ul><li>数组中的字符串:</li></ul><img src="/images/字符串-1.png" width="30%" height="30%"><ul><li>这里需要注意的是图片中数组末尾的字符<code>\0</code><blockquote><p>这是空字符(null character)，C内用它来标记字符串的结束<br>空字符并非数字0，它是非打印字符，其ASCII码值是(或称其为等价于)0<br>所以C中的字符串一定以空字符结束，即意味着数组的容量必须比至少比带存储字符串中的字符数多1<br>因此，在一个有若干个存储单元的字符串中，只能存储若干字符串数量减一个字符，剩下一个字节留给空字符</p></blockquote></li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概述:</strong></p><ul><li>可以将数组看作是一行连续的多个存储单元</li><li>或称为数组是同类型数据元素的有序序列</li><li>这里用一个包含着40个存储单元(每个单元存储一个char类型的值)且已被创建(已存在)的数组来举例<blockquote><p><code>char name[40];</code><br>name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量，char用于表示每个元素的类型</p></blockquote></li></ul><p><strong>具体图解</strong></p><ul><li>声明一个变量和声明一个数组:</li></ul><img src="/images/字符串声明-1.png" width="30%" height="30%"><ul><li>字符串就是在拥有一个数组的前提下，把字符串中的字符逐个放入数组，同时还要记得在末尾加上一个<code>\0</code><blockquote><p>好在计算机可以自己去处理这些细节问题</p></blockquote></li></ul><hr><ul><li>用格式化输出标识符<code>%s</code>来格式化输出字符串类型，但scanf()函数只会读取字符串中的一个单词，而非整个句子<blockquote><p>此时需要用到其它的输入函数，如<code>fgets()</code>，以用于读取一般的字符串<br>因为本质是由基本字符类型构成的数组，所以字符串的打印顺序与所存储的内存地址也是与字符类型相同的<br>即为完全线性</p></blockquote></li></ul><hr><h3 id="字符串和字符的区别"><a href="#字符串和字符的区别" class="headerlink" title="字符串和字符的区别"></a>字符串和字符的区别</h3><ul><li>字符串常量”x”和字符常量’x’完全不同</li><li>区别之一是在于’x’是基本类型char<blockquote><p>而”x”是派生类型char 数组</p></blockquote></li><li>区别之二是”x”实际上是由两个字符组成的，即为’x’和空字符<code>\0</code></li></ul><p><strong>图片描述:</strong></p><ul><li>字符’x’和字符串”x”:</li></ul><img src="/images/字符和字符串的区别-1.png" width="30%" height="30%"><hr><h3 id="strlen-方法-函数"><a href="#strlen-方法-函数" class="headerlink" title="strlen()方法(函数)"></a>strlen()方法(函数)</h3><ul><li><p>用于输出给出字符串中的字符长度</p></li><li><p>因为1字节存储一个字符，所以给人最直观的感受就是与sizeof运算符(以字节为单位给出对象的大小)的输出相同，但事实绝非如此</p></li><li><p>使用<code>strlen()</code>方法(函数)时需要先对头文件<code>string.h</code>进行预处理<code>#include</code>，以对其进行支持</p></li><li><p>当被定义数组内有40个存储单元，但是只用了不到40个单元用于存储被输入字符串</p><blockquote><p>此时<code>strlen()</code>方法得出的结果是被存储字符串的字符长度，当为11时，即为11个<br>但数组内还需要多出来一个单元用于存储空字符，但<code>strlen()</code>方法并不会将其计入</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>strlen()函数知道在何处停止:</li></ul><img src="/images/strlen机制说明-1.png" width="30%" height="30%"><p><strong>strlen()与sizeof运算符方法的区别</strong></p><ul><li><p>假如让<code>strlen()</code>方法去存储一个常量字符串，<code>strlen()</code>方法将会只返回字符串中的字符(包括空格和标点符号)</p></li><li><p>但是<code>sizeof</code>运算符将会把字符串末尾不可见的空字符也算在内</p></li><li><p><code>sizeof</code>运算符和<code>strlen()</code>方法的格式化输出标识符是通用的，即为<code>%zd</code>转换说明</p><blockquote><p>并且<code>sizeof</code>和<code>strlen()</code>返回的实际类型通常是<code>unsigned</code>或<code>unsigned long</code></p></blockquote></li><li><p><code>sizefo</code>后加不加圆括号取决于运算对象是类型还是特定量</p><blockquote><p>对于类型需要写为类似于<code>sizeof(char)</code>的形式<br>而对于特定量，则可以写成<code>sizeof name</code>的形式<br>只不过每种形式都可以加上圆括号，可以为了增加可读性而去这么做</p></blockquote></li></ul><hr><h3 id="define"><a href="#define" class="headerlink" title="[#define]"></a>[#define]</h3><p><strong>常量和 C 预处理器</strong></p><ul><li><p>如果将全局变量当成常量，程序可能会在无意之间修改它的值</p></li><li><p>所以 C 中为此提供了C 预处理器，预处理器可以用来定义常量</p></li><li><p>基本语法与使用:</p><blockquote><p><code>#define NAME value</code><br><code>#define XXX 0.001</code><br>此时程序中的所有XXX都会被替换称0.001，这一过程被称之为编译时替换(compile-time substitution)<br>通常在运行程序时，程序中所有的替换就均已完成，这样定义常量可将其称之为明示常量(manifest constant)<br>因为预处理器处理的替换机制，所以末尾不用加分号</p></blockquote></li><li><p>在 C 中还有一个约定成俗的规定，常量的命名最好是大写，以便区分程序中其它的变量</p><blockquote><p>另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量(如，<code>c_level</code>或<code>k_line</code>)</p></blockquote></li><li><p>符号常量的命名规则与变量相同，即可以使用大小写的字母，数字，下划线和首位字符不能为数字</p></li><li><p><code>#define</code>指令还可用于定义字符和字符串常量，前者用单引号，后者用双引号</p><blockquote><p>即为<code>#define BEEP &#39;\a&#39;</code>或<code>#define TEE &#39;T&#39;</code><br>需要注意的就是符号常量后面的内容用来代替符号常量</p></blockquote></li></ul><hr><p><strong>const限定符</strong></p><ul><li><p>const关键字于C90标准添加，用于限定一个变量为只读</p></li><li><p>作用与<code>#define</code>相同，并且比其更灵活</p></li><li><p>基本语法:</p><blockquote><p><code>const int XXX = 10</code><br>此时XXX在程序中不可更改，其值为10</p></blockquote></li></ul><hr><p><strong>明示常量:</strong></p><h3 id="limits-h"><a href="#limits-h" class="headerlink" title="limits.h"></a>limits.h</h3><ul><li><p>C内的每个头文件都定义了一系列供实现使用的明示常量</p><blockquote><p>比如C的头文件<code>limits.h</code>和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息</p></blockquote></li><li><p>而<code>limits.h</code>头文件包含了以下类似的代码</p><blockquote><p><code>#define INT_MAX +32767</code><br><code>#define INT_MIN -32768</code><br>这些明示常量代表<code>int类型</code>可表示的最大值和最小值<br>如果系统使用32位的int，该头文件会为这些明示常量提供不同的值</p></blockquote></li><li><p>如果在程序中包含<code>limits.h</code>头文件，就可编写下面的代码:</p><blockquote><p><code>printf(&quot;Maximum int value on this system = %d\n&quot;, INT_MAX);</code><br>如果系统使用4字节的int，<code>limits.h</code>头文件会提供符合4字节int的<code>INT_MAX和INT_MIN</code><br>以下表图片内列出了<code>limits.h</code>中能找到的一些明示常量<br>文章内会对每个头文件的内部构成与使用方法进行刨析<br>每种类型的头文件在系统内的C标准库内都有明确的说明</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li><code>limits.h</code>中的一些明示常量</li></ul><img src="/images/C-头文件/C-limits.h头文件-1.png" width="30%" height="30%"><hr><h3 id="float-h"><a href="#float-h" class="headerlink" title="float.h"></a>float.h</h3><ul><li>类似地，<code>float.h</code>头文件中也定义一些明示常量<blockquote><p>如<code>FLT_DIG和 DBL_DIG</code>，分别表示<code>float类型</code>和<code>double类型</code>的有效数字位数<br>以下表图片内列出了<code>float.h</code>中的一些明示常量(可以使用文本编辑器打开并查看系统使用的float.h头文件)<br>表中所列都与float类型相关<br>把明示常量名中的FLT分别替换成DBL和LDBL<br>即可分别表示double和long double类型对应的明示常量(表中假设系统使用2的幂来表示浮点数)</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>float.h中的一些明示常量:</li></ul><img src="/images/C-头文件/C-float.h头文件-1.png" width="30%" height="30%"><ul><li>编译器要完全支持C99标准才能识别<code>LLONG_MIN</code>标识符</li></ul><hr><h3 id="printf-方法与scanf-方法"><a href="#printf-方法与scanf-方法" class="headerlink" title="printf()方法与scanf()方法"></a>printf()方法与scanf()方法</h3><p><strong>概述:</strong></p><ul><li><code>printf()</code>函数和<code>scanf()</code>函数能让用户可以与程序实现交互<blockquote><p>它们是基本/标准的输入/输出函数，或简称为I/O函数<br>其除了I/O功能，还有很多其它的功能<br>因为考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()，尽管如此，各版本之间偶尔有一些差异<br>而C90 和C99 标准规定了这些函数的标准版本<br>虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同<br>两个函数都使用格式字符串和参数列表</p></blockquote></li></ul><hr><p><strong>printf()</strong></p><ul><li><p>请求<code>printf()</code>函数打印数据的指令要与待打印数据的类型相匹配</p><blockquote><p>例如， 打印整数时使用<code>%d</code>，打印字符时使用<code>%c</code><br>这些符号被称为转换说明(conversion specification)，即为格式化输出标识符<br>它们指定了如何把数据转换成可显示的形式。</p></blockquote></li><li><p>以下列表图片为ANSI C标准为<code>printf()</code>提供的转换说明与搁置相对应的输出类型</p></li><li><p>转换说明及其打印的输出结果:</p></li></ul><img src="/images/C-标准库/C-printf函数-1.png" width="30%" height="30%"><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li>格式字符串包含两种形式不同的信息:<blockquote><p>实际要打印的字符<br>与转换说明</p></blockquote></li></ul><p><strong>图片说明:</strong></p><ul><li>printf()的参数</li></ul><img src="/images/printf格式-1.png" width="20%" height="20%"><ul><li>剖析格式字符串图片:</li></ul><img src="/images/字符串格式-1.png" width="20%" height="20%"><ul><li>格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果</li></ul><hr><p><strong>printf()的转换说明修饰符</strong></p><ul><li>在%和转换字符之间插入修饰符可修饰基本的转换说明</li><li>转换说明修饰符类型的可移植性需要特别注意</li><li>整数类型和浮点数类型使用不同类型的转换类型</li><li>关于转换说明修饰符的列表这里不做过多阐述</li><li>可参考[C Primer Plus 第6版-中文版]-第201页</li></ul><hr><p><strong>转换说明的意义:</strong></p><ul><li><p>转换说明把以二进制格式储存在计算机中的值转换成一系列字符(字符串)以便于显示</p><blockquote><p>例如，数字76在计算机内部的存储格式是二进制数01001100<br><code>%d</code>转换说明将其转换成字符7和6，并显示为76<br><code>%x</code>转换说明把相同的值(01001100)转换成十六进制记数法4c<br><code>%c</code>转换说明把01001100转换成字符L</p></blockquote></li><li><p>转换(conversion)可能会误导读者认为原始值被转替换成转换后的值</p><blockquote><p>实际上，转换说明是翻译说明<br><code>%d</code>的意思是”把给定的值翻译成十进制整数文本并打印出来”</p></blockquote></li></ul><hr><h3 id="scanf-方法简述"><a href="#scanf-方法简述" class="headerlink" title="scanf()方法简述"></a>scanf()方法简述</h3><ul><li><p>输入函数-scanf()</p><blockquote><p>scanf()是最通用的一个输入函数，因为其可以读取不同格式的数据</p></blockquote></li><li><p>如果要将其储 存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的</p></li><li><p>scanf()把输入的字符串转换成整数，浮点数，字符或字符串</p><blockquote><p>而printf()正好与它相反，把整数，浮点数，字符和字符串转换成显示在屏幕上的文本</p></blockquote></li><li><p>scanf()和printf()类似，也使用格式字符串和参数列表</p><blockquote><p>scanf()中的格式 字符串表明字符输入流的目标数据类型<br>两个函数主要的区别在参数列表中<br>printf()函数使用变量，常量和表达式，而scanf()函数使用指向变量的指针<br>关于指针的两条最简单的规则:<br>如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;<br>如果用scanf()把字符串读入字符数组中，不要使用&amp;</p></blockquote></li><li><p>scanf()函数使用空白(换行符，制表符和空格)把输入分成多个字段</p><blockquote><p>在依次把转换说明和字段匹配时跳过空白</p></blockquote></li><li><p>scanf()函数所用的转换说明与printf()函数几乎相同</p><blockquote><p>主要的区别是，对 于float类型和double类型<br>printf()都使用<code>%f</code>,<code>%e</code>,<code>%E</code>,<code>%g</code>和<code>%G</code>转换说明<br>而scanf()只把它们用于float类型，对于double类型时要使用l修饰符</p></blockquote></li><li><p>C99-ANSI C中scanf()的转换说明这里不做过多赘述，可参考书籍</p></li><li><p>scanf()进入输入的原理与对应的物理模式这里不做阐述，将来会对其进行补充</p><blockquote><p>转换符和I/O函数不需要学的特别细，具体的使用和记忆可以在实践中执行</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-2</title>
    <url>/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>存储原理-算术类型-1</strong></center><a id="more"></a><h2 id="基本数据类型存储原理"><a href="#基本数据类型存储原理" class="headerlink" title="基本数据类型存储原理"></a>基本数据类型存储原理</h2><ul><li>数据类型系统-基本类型</li><li>算术类型，其包含了整数类型与浮点类型</li><li>这里的数值大小以 C 的 C11 标准为例<blockquote><p>C 标准对基本数据类型只规定了允许的最小大小</p></blockquote></li></ul><hr><ul><li>常用基本数据类型占用空间(64位机器为例)</li></ul><ol><li>整数类型/char: 1个字节</li><li>整数类型/int: 4个字节</li><li>浮点类型/float: 4个字节</li><li>浮点类型/double: 8个字节</li></ol><ul><li>以 ISO C 标准为例<blockquote><p>此规定规定int的取值范围最小为<code>-32768～32767</code></p></blockquote></li></ul><hr><h2 id="整数存储原理"><a href="#整数存储原理" class="headerlink" title="整数存储原理"></a>整数存储原理</h2><ul><li>在计算机内的整数与数学一样，即为没有小数部分的实数</li><li>计算机以二进制数字的模式来存储整数</li><li>存储的位置即为变量标识符所对应的内存地址，与其指令集所指的CPU寄存器</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>同时还可将其称之为数据类型系统的基本类型部分</li><li>被归纳于算术类型，包括了整数类型与浮点类型</li><li>这里以C为例</li><li>C语言中的整数类型可表示不 同的取值范围和正负值，一般情况使用int类型即可，但是为满足特定任务和 机器的要求，还可以选择其他类型</li><li>int类型是有符号整型，即int类型的值必须是整数，可以是正整数，负整数或零</li><li>一般而言，储存一个int要占用一个 机器字长</li><li>声明之后便为被声明的若干个int大小的变量赋予名称并分配内存空间</li><li>可以赋值或初始化变量(initialize)</li><li>简而言之，声明为变量创建和标记存储空间，并为其指定初始值</li><li>C语言把大多数整型常量视为int类型，但是非 常大的整数除外</li><li>并且int类型拥有常量概念</li></ul><p><strong>声明执行逻辑图示:</strong></p><ul><li>定义并初始化变量:</li></ul><img src="/images/整数类型原理图片/数据类型声明-1.png" width="30%" height="30%"><p><strong>举例说明:</strong></p><ul><li>例如7则以对应的二进制111来存储<blockquote><p>因此，要在8位字节中储存 该数字，需要把前5位都设置成0，后3位设置成1</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>使用二进制编码储存整数7</li></ul><img src="/images/整数类型原理图片/整数类型-1.png" width="30%" height="30%"><hr><h3 id="关于整数值的范围"><a href="#关于整数值的范围" class="headerlink" title="关于整数值的范围"></a>关于整数值的范围</h3><p><strong>整数类型</strong></p><ul><li>下表列出了关于标准整数类型的存储大小和值范围的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr><tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr></tbody></table><ul><li>同时还可以使用sizeof运算符，即表达式sizeof(type)，以获取某个类型或某个变量对象或存储类型在特定硬件平台的准确存储字节大小</li></ul><p><strong>图解说明</strong></p><ul><li>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主<blockquote><p>以下列出了32位系统与64位系统的存储大小的差别(windows 相同):</p></blockquote></li></ul><img src="/images/整数类型原理图片/C-32-64.png" width="30%" height="30%"><hr><h2 id="浮点类型存储原理"><a href="#浮点类型存储原理" class="headerlink" title="浮点类型存储原理"></a>浮点类型存储原理</h2><ul><li><p>在计算机中，浮点数与数学中实数的概念差不多</p></li><li><p>比如<code>2.75</code>,<code>3.16E7</code>,<code>7.00</code>和<code>2e-8</code>都是浮点数，即在一个值后面加上一个小数点，该值就成为一个浮点值</p></li><li><p>所以7是整数，<code>7.00</code>是浮点数</p></li><li><p>e记数法简述: <code>3.16E7</code>表示<code>3.16×10^7</code>，其中E的作用就是10倍原数的对应指数级单位</p></li><li><p>浮点数和整数的储存方案不同</p></li><li><p>计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分</p></li><li><p>在十进制下，可以把7.0写成 0.7E1，但这里，0.7是小数部分，1是指数部分</p></li><li><p>当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂</p></li><li><p>整数没有小数部分，浮点数有小数部分</p></li><li><p>且浮点数可以表示的范围比整数大</p></li><li><p>对于一些算术运算(如，两个很大的数相减)，浮点数损失的精度更多</p></li></ul><p><strong>图示说明:</strong></p><ul><li>一个储存浮点数的例子，以浮点格式(十进制)储存π的值</li></ul><img src="/images/整数类型原理图片/浮点数类型.png" width="30%" height="30%"><ul><li>因为在任何区间内(如，1.0 到 2.0 之间)都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值</li><li>浮点数通常只是实际值的近似值</li><li>例如，7.0可能被储存为浮点值6.99999，稍后讨论精度</li><li>在过去，浮点运算比整数运算慢</li><li>不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距</li></ul><hr><h3 id="关于浮点值的范围"><a href="#关于浮点值的范围" class="headerlink" title="关于浮点值的范围"></a>关于浮点值的范围</h3><p><strong>浮点类型</strong></p><ul><li>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4 字节</td><td align="left">1.2E-38 到 3.4E+38</td><td align="left">6 位小数</td></tr><tr><td align="left">double</td><td align="left">8 字节</td><td align="left">2.3E-308 到 1.7E+308</td><td align="left">15 位小数</td></tr><tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">3.4E-4932 到 1.1E+4932</td><td align="left">19 位小数</td></tr></tbody></table><ul><li>头文件<code>float.h</code>定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节</li></ul><hr><h2 id="C-数据类型转换"><a href="#C-数据类型转换" class="headerlink" title="C 数据类型转换"></a>C 数据类型转换</h2><ul><li>C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型</li><li>在 C 语言中也可以对数据类型进行强制转换</li></ul><p><strong>自动转换规则:</strong></p><ol><li>浮点数赋给整型，该浮点数小数被舍去；</li><li>整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；</li></ol><ul><li>强制类型转换形式: [(类型说明符) (表达式)]</li></ul><hr><h3 id="关于不同进制的说明"><a href="#关于不同进制的说明" class="headerlink" title="关于不同进制的说明:"></a>关于不同进制的说明:</h3><ul><li><p>2进制，8进制和16进制</p></li><li><p>以0为前缀用于表示8进制</p><blockquote><p>比如十进制转换为8进制则为020</p></blockquote></li><li><p>以0x或0X为前缀用于表示16进制</p><blockquote><p>比如十进制数转为16进制则为0x10或0X10</p></blockquote></li><li><p>使用不同的进制是为了方便，其可以完全保证不会影响被存储的方式</p></li><li><p>可以使用标识符<code>%d</code>，<code>%o/%x</code>来分别显示(格式化输出)八进制与十六进制数字</p></li><li><p>而使用标识符<code>%#o</code>，<code>%#x</code>，<code>%#X</code>可以显示各进制的前缀(0，0x和0X)，也就是分别在转换(格式化输出)的说明中假如警号(#)</p></li></ul><hr><ul><li>整数类型还包括char-字符类型与其它的表示符类型，比如像long，short等等，这里先不做过多赘述</li><li>字符类型还包括了字符与字符串(String)的概念</li></ul><hr><p><strong>图片资料补充:</strong></p><ul><li>转义序列(转义标识符)图示:</li></ul><img src="/images/整数类型原理图片/转义标识符-1.png" width="30%" height="30%"><ul><li>int系列类型的常量写法示例:</li></ul><img src="/images/整数类型原理图片/int中的常量写法.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><ul><li><p><code>scanf()</code>函数中的&amp;标识符用于把输入的字符赋值给所对应变量</p><blockquote><p>相当于创建了一个指向变量其它数据对象位置的指针</p></blockquote></li><li><p>而格式化输出标识符(转换符)</p><blockquote><p>类似于<code>%c</code>，<code>%o</code>，<code>%d</code>，<code>%f</code>之类的<br>作用是决定数据的显示方式，而不是存储方式</p></blockquote></li><li><p>数据显示和数据存储的示例图片:</p></li></ul><img src="/images/格式化输出标识符-1.png" width="40%" height="40%"><hr><ul><li>编译器对char的实现也有不同，有的将其实现为有符号类型，即代表char可表示的范围是-<code>128~127</code></li><li>而有些C编译器把char实现为无符号类型，即为表示-<code>0~255</code></li><li>至于想要准确的确定正在使用的编译器是如何实现<code>char类型</code>的，可以去查询相应的编译器手册与<code>limits.sh</code>头文件</li><li>但是根据C90标准，C内允许在char关键字钱使用<code>signed</code>与<code>unsigned</code>标识符，以此来消除编译器对char默认类型的影响</li><li><code>signed char</code>表示有符号类型，而<code>unsigned char</code>表示无符号类型</li></ul><hr><h3 id="类型归纳列表"><a href="#类型归纳列表" class="headerlink" title="类型归纳列表"></a>类型归纳列表</h3><p><strong>基本数据类型</strong></p><ul><li>关键字:</li><li>基本数据类型由11个关键字组成: <code>int</code>、<code>long</code>、<code>short</code>、<code>unsigned</code>、<code>char</code>、 <code>float</code>、<code>double</code>、<code>signed</code>、<code>_Bool</code>、<code>_Complex</code>和<code>_Imaginary</code></li></ul><p><strong>有符号整型:</strong></p><blockquote><p>有符号整型可用于表示正整数和负整数</p></blockquote><ul><li><code>int</code>——系统给定的基本整数类型<blockquote><p>C语言规定<code>int类型</code>不小于16位</p></blockquote></li><li><code>short</code>或<code>short int</code>——最大的<code>short类型</code>整数小于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>short类型</code>至少占16位</p></blockquote></li><li><code>long</code>或<code>long int</code>——该类型可表示的整数大于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>long类型</code>至少占32位</p></blockquote></li><li><code>long long</code>或<code>long long int</code>——该类型可表示的整数大于或等于最大的<code>long类型</code>整数<blockquote><p>Long long类型至少占64位</p></blockquote></li></ul><hr><ul><li>一般而言，<code>long类型</code>占用的内存比<code>short类型</code>大<blockquote><p>int类型的宽度要么和<code>long类型</code>相同，要么和<code>short类型</code>相同<br>例如，旧DOS系统的PC提供16位的short和int，以及32位的long<br>Windows 95系统提供16位的short以及32位的int 和long</p></blockquote></li></ul><hr><p><strong>无符号整型：</strong></p><ul><li><p>无符号整型只能用于表示零和正整数</p><blockquote><p>因此无符号整型可表示的正整数 比有符号整型的大</p></blockquote></li><li><p>在整型类型前加上关键字<code>unsigned</code>表明该类型是无符号整型: <code>unsignedint</code>、<code>unsigned long</code>、<code>unsigned short</code></p><blockquote><p>单独的<code>unsigned</code>相当于<code>unsignedint</code></p></blockquote></li><li><p>字符类型:</p></li><li><p>可打印出来的符号(如A，&amp;和+)都是字符</p><blockquote><p>根据定义，<code>char类型</code>表示 一个字符要占用<code>1字节</code>内存<br>出于历史原因，<code>1字节</code>通常是8位，但是如果要表示基本字符集，也可以是<code>16位</code>或更大</p></blockquote></li><li><p>char——字符类型的关键字<br>》 有些编译器使用有符号的char，而有些则使用无符号的char<br>》 在需要时，可在char前面加上关键字<code>signed</code>或<code>unsigned</code>来指明具体使用哪一种类型</p></li><li><p>布尔类型:</p></li><li><p>布尔值表示<code>true</code>和<code>false</code></p><blockquote><p>C语言用1表示<code>true</code>，0表示<code>false</code></p></blockquote></li><li><p><code>_Bool</code>——布尔类型的关键字</p><blockquote><p>布尔类型是无符号<code>int类型</code>，所占用的空间只要能储存0或1即可</p></blockquote></li><li><p>实浮点类型:</p></li><li><p>实浮点类型可表示正浮点数和负浮点数</p></li><li><p>float——系统的基本浮点类型，可精确表示至少6位有效数字</p></li><li><p>double——储存浮点数的范围(可能)更大，能表示比<code>float类型</code>更多的有效数字(至少 10位，通常会更多)和更大的指数</p></li><li><p>long long——储存浮点数的范围(可能)比double更大，能表示比double更多的有效数字和更大的指数</p></li><li><p>复数和虚数浮点数:</p></li><li><p>虚数类型是可选的类型</p></li><li><p>复数的实部和虚部类型都基于实浮点类型来构成:</p><blockquote><p><code>float _Complex</code><br><code>double _Complex</code><br><code>long double _Complex</code><br><code>float _Imaginary</code><br><code>double _Imaginary</code><br><code>long long _Imaginary</code></p></blockquote></li></ul><hr><h3 id="打印出类型大小"><a href="#打印出类型大小" class="headerlink" title="打印出类型大小"></a>打印出类型大小</h3><ul><li><p><code>sizeof()</code>函数的使用</p></li><li><p>sizeof是 C 的内置运算符，用于以字节为单位给定指定的类型大小</p><blockquote><p>C99和C11提供<code>%zd</code>转换说明匹配sizeof的返回类型<br>而一些不支持C99和C11的编译器可以用<code>%u</code>或<code>%lu</code>来代替<code>%zd</code></p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">" Type int has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">" Type char has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">" Type long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">" Type long long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">" Type double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">" Type long double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Type int has a size of 4 bytes.</span><br><span class="line">Type char has a size of 1 bytes.</span><br><span class="line">Type long has a size of 8 bytes.</span><br><span class="line">Type long long has a size of 8 bytes.</span><br><span class="line">Type double has a size of 8 bytes.</span><br><span class="line">Type long double has a size of 16 bytes.</span><br></pre></td></tr></table></figure></li><li><p>该程序列出了6种类型的大小，也可以把程序中类型换成的其他类型</p><blockquote><p>注意，因为C语言定义了<code>char类型</code>是1字节，所以<code>char类型</code>的大 小一定是1字节<br>而在<code>char类型</code>为16位，<code>double类型</code>为<code>64位</code>的系统中，<code>sizeof</code>给出的<code>double</code>是4字节</p></blockquote></li><li><p>在<code>limits.h</code>和<code>float.h</code>头文件中有类型限制的相关信息</p><blockquote><p>顺带一提，注意该程序最后几行<code>printf()</code>语句都被分为两行<br>只要不在引号内部或一个单词中间断行，就可以这样写</p></blockquote></li></ul><hr><h3 id="printf-方法与scanf-方法补充内容"><a href="#printf-方法与scanf-方法补充内容" class="headerlink" title="printf()方法与scanf()方法补充内容"></a>printf()方法与scanf()方法补充内容</h3><ul><li><p><code>printf()</code>和<code>scanf()</code>函数用第1个参数表明后续有多少个参数</p><blockquote><p>即第1个字 符串中的转换说明与后面的参数一一对应<br><code>printf(&quot;A %d B %f&quot;, xxx, yyy)</code><br>即A对应于xxx，B对应于yyy</p></blockquote></li><li><p>程序员要负责确保转换说明的数量，类型与后面参数的数量，类型相匹配</p><blockquote><p>现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确<br>但是，该机制对<code>printf()</code>和<code>scanf()</code>不起作用，因为这两个函数的参数个数可变</p></blockquote></li></ul><hr><ul><li><p>C语言提供了大量的数值类型，目的是为程序员提供方便</p><blockquote><p>那以整数类型为例，C认为一种整型不够，提供了有符号，无符号，以及大小不同的整型，以满足不同程序的需求</p></blockquote></li><li><p>计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别</p><blockquote><p>即使两个32位存储单元储存的位组合完全相同，但是一个解释为<code>float类型</code>，另一个解释为<code>long类型</code><br>这两个相同的位组合表示的值也完全不同。<br>例如，在PC中，假设一个位组合表示<code>float类型</code>的数256.0<br>如果将其解释为<code>long类型</code>，得到的值是113246208<br>C语言允许编写混合数据类型的表达式， 但是会进行自动类型转换<br>以便在实际运算时统一使用一种类型</p></blockquote></li><li><p>计算机在内存中用数值编码来表示字符</p><blockquote><p>美国最常用的是<code>ASCII码</code>，除此之外C也支持其他编码<br>字符常量是计算机系统使用的数值编码的符号表示<br>它表示为单引号括起来的字符，如<code>&#39;A&#39;</code></p></blockquote></li><li><p>需要完全理解通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型</p></li><li><p>浮点数可以写成固定的小数点的形式或指数形式，C99和C11提供了第三章的表示方法，即用十六进制数和二的幂来表示(如，<code>0xa.1fp10</code>)</p></li><li><p>C语言中用单引号<code>&#39; &#39;</code>来表示字符常量，还有转义序列的概念(<code>&#39;\n&#39;</code>)，另外，还可以在八进制和十六进制数前面加上一个反斜杠(如: ‘\007’)，用以表示ASCII码中的一个字符</p></li><li><p>还可可移植数据类型等概念</p><blockquote><p>C99新增了两个头文件<code>stdint.h</code>和<code>inttypes.h</code></p></blockquote></li><li><p><code>printf()</code>函数根据转换说明打印各种类型的值</p><blockquote><p>转换说明最简单的形式由一个百分号(%)和一个转换字符组成，如<code>%d</code>或<code>%f</code></p></blockquote></li></ul><hr><p><strong>转义序列(格式化输出标识符)-URL参考列表:</strong></p><ul><li><p>CN-CSDN-C语言中字符串的格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/hudashi/article/details/7080078</code></p></blockquote></li><li><p>CN-CSDN-C字符串格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/mcxfate/p/10618114.html</code></p></blockquote></li><li><p>CN-CSDN-C 和 C++ 字符串格式化<a href="https://blog.csdn.net/freeking101/article/details/78935559" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/freeking101/article/details/78935559</code></p></blockquote></li><li><p>c/c++的字符串格式化汇总<a href="https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>无</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-03-10</title>
    <url>/2020/03/10/%E9%9A%8F%E7%AC%94-2020-03-10/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="b8fa5e3a7370ceafdd683447a837b843d5c40e9697d8f58957433ca20701db48">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546eb57a7aedb992ebf8d61f9bf4179540a67b24eba202d8da36defce2e3c83376cd737a38d8e3cd8ef21820898fa3d9a87c0311e97bf2c1cb7b1b4bd5a06e8854adc40112e0336489dba20e16c4eb8a4a441f9b31f3937722d4812c6cb85497679b3b5f648f7251f747c00428a3851dff6ee04e8d7ccb2dbdfb864c97ba18256586ca76d9bca2e8ba622869b0f5859703fd39f4e18010de815d068bcf3e458f6d2237a46740ce3720a9bddd97861f21605b9112ebfe1e2a2e1334478af69065b12c0351a3637a85861f2b44290292c70889cc1a560b6e34094c2ca0c21b15743a113ef56333cc2878a9cc1821c14784ba54929b165106109eee060ed163bd64c84a1df5497c9998ba233c2796018ef26d49092e780522e0b6b20bd20c5235340c466c6f97b9a8f9afb0b43966112385f49aae5b89c897342b9d21b66a5f6a2f96a6fbfc4396e37adbe66e8cfbdf89e8c26867f7c4b7660b839945038ea743b969bc01e9af277d02e7071e71c646bbe72da2890e1a64c71b843d6322431d27262787a322a0b2142bba220125fbd16e89fd9e55df8637c867b1e2eae48e76351e9b81b7d56186585f5fea079e7b7adf940409561ed15c7d9b350cc833a3c11e9d95e2fc202553278b6463aa100ac40b916253cc62761f012fbb2506964e4568c355e5bfd23bc77cbca28c8364d8fc2c4731c29ffe60b918f3d2585a25183330e519d02eee3529795de16c896a2ecfd7edcbd16e476c7a32a0f7fa76097e8c68a69769791f36f33f080f48b66814bc6209b12e06b2dae5a21a010a6194025c91e6740d342c35c35ae465e33c00ff93684370737e70cc578fc1fee457eeb0318471f8ad8ba5ec793000ce4849a686e454c7026cf8bc3599e5b2454d6d0238f1cda8becea4f3bb9dc5aacde48f0ca9400cfd146036c578c64bc83a39276ddc58b190ac060e47a5b44c9c15d9aed1b1cbc65b0d7b1203aea29f7185c3969fe2ea79dd8000d6340390b6a77a932688b8866dce1e4b66597d8ed281777b2f735886ffb3c93c044341e8abf681df5117bbd9a91426066dc462db58f8018797387f86681083678a258ff7d72d65ea8989444e1f4e1daf71675bd4f55e724689d82deb9a700f3600bf3c78eb963aba145a68c264ece55766ce007d79965eec772d3db9d157ce5f1ade849a7bfbbb40e52a9824c178aac93adaa95b471f84917530bf1e61479cfff579dcabf3b01c6430d6ef6ead8053d4566c341a02a621e3f1ea7ad7968781f4127572fa8fe7d25abf9c1c2050326f880f69bf4fb01eebc356bccaeb1721dea753b406dae4edbccb2702851751efc64ed7c03658064dfdedf83ad42407c2b1cfba5d4e1fc95a9610261ccc4f9845cf7abf47b57094a7c3aac374f10a2b834a4fde2d8915f5531d8c8d57abd8d5771f12c9288736a5751685a037efb1df1527d7a47700fde583543effb83e1f6c5241349aeb1eddb67ce3e0a5ae6675a4fa78942a9afb2852fe497aca91e9c6f4be069ab1a70e1924e67aaa3e998ac50c493787753b3307e53337525370aa36ea520174d21297da2d2c2680908dd514a06c18392501f7bf797da2bbcedf4b4f5d9e21bb8bd7c1afb1271fbefec6701108a034235251d46893c4cd8b1553166ad80db8a0c0db09a88adf584889bcc1dff424761b14c5f46541cce44017def2ab37835bcf11aadcc7efb555fcc5f45be5af6b691c40dfd1f6f71885c60997caf51c1ccdc5b31d1d01502aed037cb3e7c1030524d90194c470aac79c3bcc1706f52ecd6d6f811dd08648b225893f7941c7337b0a08657165da7fc3748fc88ecec4de7ac1c5cb55424f68c3827add4f1f7f1784fd4cdd8a4fc6d29f27bf9f9f4cb1abb1aa1e07394e35a717e4c6f2deb2b356608ea8d5fa3cb7beb71cd0d1124aaeb3af2f570b0d56cb0093abe558dab4fb018afa4164fe473cca7a0eeb83ee77d80049af82717ab697d4f33dff7da96b2f66b10b4483abe07f9149b20eb75ecfb1136173bf65d7e2b5b657706ffde63d01111430eeb25c4aa1b4114fa9da830993320720d272500e22ac3d100dbf53cc812c5b42a7684f87f70cea6628b57d5ada20b3c603f4fda3639689f852e76496299ca69d90a4f1cc5d84b9dc091e5f9b55d9ab29fc1ec67a369a2d484c32a47ed8794bfff7b5a87eeddfce0379c7319b34bbdc59e9546cc8fab104b27fab4fd0d58617a2692e0e6394981187f45f15ed15e186307f3b746a94e212f722f51df6e88b488fcad0a30d3a272e68bc923d28766ab0a3a65d4008aac97dec2f44eda9af6a3880cd9902beb7b2cce6b770c19fff7b3c6f32d0d72e674df5b17621483edbf061d7e7caf4153bb622363a5a79ab3df5b227f7bf0bec75981e558e19c9f84228724e6097630e52233738a47bd851603b26e1774faff6ac2e6048df55dc92fdf2d1ec996b9787c4a59179c93049571dca848f8f24730b842774c227bd74fa02b3c8017e682e5bf4880f8e93fe50cc3a64865b068ae47919d4acf09ed768d1e2a260a12e552e7464c154052d7ac80025115414f6fda8f3e96d082720912499a42f8e5cd9ced4c65b43340cbd032aa834b5f89b23eb5f0717123299a95d2b50809b89c1e255602429fd22b9990c7ba48fab07b1fd5d1953ee0bd67e0646e5c454cac402085063a3350f5ce161fe05bd7af62f0f2a2021c9a1a11195dda1d64a7d60c414fff7d83fea6405ef4288fdcee5a71a1dfc10f19bbd8e2dd062ff65f7b7a292c62a0646ac6a6ff8e65dd04e22a4ca18aaa8d13b8d7e64576c0b375e057228d2f933b588683aa1026a12e8eb960ed2f4068d3902cc83d7d75d9e65460a529be569b69a8483d0d26886cb65cea455c02c439dd446f157343564f71c92d0d004d40e09c158d8c94b511ddc925e1b364501796e876252648b03ec85589060d27128f603f83f0ae58fb2d6b461cc4cb7562cc3cf7324858e707ec6399e03ab4eac58b16c926b2422299c79b6869c2cc52300e6d51b9c0c09febef2e583c596a097af44cd57d25e847eb2fd2c9140e467e590c23a60e28510a672477a459dfa3de59f070f8533a9d5f997cb326b86cfc4c93f7a3af6cc6e67fe2bdc45d9cbf0c22772a6df3b139ee028d95724b41eb5625ac30ad3c4bf575ba493055736feb1446670f8fb824150c177459b6383570bf1f7ffe96f8e5854136e630b3eaa09f853a596ae17685cd9a4867d6acd2588c9b087ed6365a1cf4607fb92124b62cb54e4f495c3e4361771d07b61e4c5fb748dbae023d281e389b8cd794a4363561ca9102c884319f56b3fff58145c27286e976dff176d89d547b2fe2f9d10b5e1ccbb8e92e687012aa55ff66faf6194eee020ea4d8480a02e7109e52ea6f8f0f26730c21eeac9f59891612900d2f59772322b8a041f6eb207f2ec062c06d052c4e65aaffc89cf45ee7387016776801bf7959370a8aa8562bed00c9b9d7150acef7988dad3860f3e9b958df39eb24c90e702a46fe93fe236ee84d48e8083cb51a0d86b1dcd1bbd41310d53b8ba929d8187381df3c8ac1e3805a0295b2e7e9b5dbebcfc71471a6ffd4e2c0aff37bda62d70afd374248625bb95297bc88bfb6dc3ed6a88e374a7eb882868f0fa9a1bae6e8a085d8394b8cf2b5b1574b37da60046ca552eaee292021b8eb5eb9b4173e91ec6a499e86f153680f93934c60423cd7e3b681600ce0f127b1de6c79433fd6d7b32986a9f616f39265077a23bf4d42d405145a160e91b7215393003f649ca1aaa5f2ac671ddf708ca4a49c7b715f1cc1e771bf828a50259b86af7570cc29df90b4123385eeddd862c11f4047ae8fd64d6f5fb0afdc5cec0210c4e4b44576962e0124b45d6f9c94be0bd42fdf49984c62e1d120b445698a58b088b99b72c09267568fbf5d997741a44ec5c45df0f3803386069295255538823c70c3977f54c68505cbb6998a0d7c383e1d16cdcc199bddfb2df6861e3f204d1e68aba78884cfb2357cbb94caa74bf5afccd8773f81d7c77c948c785b0c842fa2b31a271b80929685ced7072a388f13547889fd8d3336ea8466fa8060afd4f27409b3ed1f9ee3dff83656a43f81c387f42009f661bcd7cb374eeb8320d797e7797720b9a325069dc2a861ee2c69b8020e84ba9dbda6aa05204e29adaab9f7e718d3ecca9189cd87fbe68a7d5059c416bbf123ac8daed5069be624f93d662a17007d8bacceeea490d26958ab336e9aa1b34a4a12ba321323e399eddf837ab6d04d002be7b31a6c8824b2ebf5aff02e36fc456dae631923ae03eb38b90a4f7f2b75cfe74cc7784b7773daee9d07f77391ceecddee3700db79a1fb9a17dc3cf17604d0906b3a96cac9e7dbc690ef61627d73f13e21cb4a1055b9acb20b7864fa120f28c74aee261e4635b43e2fbe509d0b601be38ba67f28644d55f8d09b964013ffc21e76cbffd6b6047efa2f138fbaf027c65dd11316c54631ef60159214b8e949c9bd3c4fab5e23b65360d6b0d7dd733a21ff9fb2e1bc73d06c75de0fa746b79efca6667d5f77c6bba77cc125d380934fe846d684f4d1363bbf8aef3abac4b4fb8ccef9a32606250b002fa023447a1a8d190652f931e8f39c2f774b3a8f831bb6130e33fabc49e0976f26222ac535b3ec4d9eb0ee82418e0f6239643bf443cbe34be7228084faaf3e311e0058d06938dacab9a6ee47f1f67988db5ccc260ca1114b784a1fbe24b38cca1fa05ab37660ce05c86be31ebff0129e194c9d5c1fe8ed0ca0e13c8629bca640bfa9ff20e1103e892a058a1961e44e0bce4bc8f012300d71dfaf78a0b4ecda2f5665e76c0b08467f5e3b6843d1dd25a9f46912874d18af90f6047451069e22934a416150c4ebb318833b233478ae9aa5d8c9981d6a7328b9851780c5ad158503848b52c374974a474bf37f0293ca2e5ddcf714e6bb1fabbc62a3866bfa89a1e7dee7ae78688c9add84cc0d0469bb3d787364f9cdd27435335d4ad1c421e037ccde04a88179c682e56ba404b4fbc23981a1ccb3c4e86fc27f79209bf1767e5ebfe4e376058134066b8499178f15638fb21e13dcd7feb4dfbb9b5182b326f82b9a6c2002abdef0dc4dd8bd1da6664d412814e027e2f8c1c5e05d836fac793dbf79f6e3b1b19cd8a100914183ff84e2aca70d12972ba0e675fa643337c09aee2600609a6692b0843fba28fbba82bb0c7a95afe211d39e3a1df24ecc3fe71d3bd3b6dde226eb2731f500e6fe677bdd192dcc43056d0f03420f50296cd39d752b534395d3afdf797908def50fb40fface30cd9cfbf563fb9c8e58ed900d9325b3074c64fb4da8a56e8e87b9b09aa9633dcedb7bca73105453ccbe431ce2545c01b9558273eea5f0faf0b2799393d57f50c719e106017d9f385de4bd77bda15c28a00b6ece1b98ffc09ab75c6a694e447987a6fbf64af51224f576b891efcdd59c91cd6dcde0bc803c05c96a38e0799728a1c05a97681d1914b409ca195bcec4b4f49ae11b05bc3d17475eafb16cfb3657b9c1606be864dee817a2177ff749ab85c063e97da45942a4661954b52a369c2a39921f9591243dfd5fff0de0a7fc6e12e4ce393ea88d1816f675c347793ed5f2e35ae131851502f7894267aaf0db05e6174139af02856ec30e1d1664a4c37e270b7ca0db15e00f77b435fbc485ade4cca2a6b3c0cc841e49a5ae333b17f55cc0cbf40eeec59695578e6d1e27a506ccd516ad014c49e85311a069e7567fe5b188fc299ffa8f38425bdb06634840b19d6f828b27702d77e28f0995ac65247ddd2819b89dd1914da9b5f5ccdac11f9dc8603cc84105c4774a662bf85641cef1e2a0e1dca33e9a79436abe4a6e10e447d34e4750f33d180d97bb54ead07745b5af805946a7d712b288f39f74cc93ba7643ca488c5677b230b2f3b3c2e098e206f6125a0b746b3f06f6a73f0aa1f13db5d45a0a54cc6241e1b5b78448b7311d9b67f56ff6475281a78a2cefd3dba3c253aa9f9956a38a2616364d68304f9d2f51333c8041fb36a83b62d117d79006f1458a6c75f2d4c36c973037ff324253da00c5792aec7e81b0d707c5d9a24c6ab47523b659055cd94000b7120c266da4d5100d377ce27510894f72af0edb011a04769a760c2d891a839313a5b99cec46d411fa567e8f559a48fe17cf1d94c264e2dbb269751a726361f674a2da799e203ba07c69a53e329060f3d4fde857328dcca1f3d0b49fd5118b1f0e8848929c06ea5c34c16aa220aac0231cfef415696abb3a40d6d76f2e5e67beb96d9de08d707a13928926c7c077ab0eea6cfe5e2f0dc9d45de9da4a1edd76d39c1687a37fe3da73785b0e28d527d1d0415007018199eecfbceaed98e283ee26c9171fccc7221f69093f877a8149f50c199ccc304d1a7c6218558127339cfc032045cb729c1cb0c0668923aaeab3bc10ec5a37d13b878264f3b21f30802a70caec3e4de45c74aea62c212eedb263cba4bff30973dfc698bab07ef24278bb7015b5d4c6a9b6b6c8a8f6903f17891d0ef21130e964e1708364ccc5e18b9490f50d1029096c986f810761bdea485af0dcf65e79ef2161426d83a7dfa279754d9da07a480ad2f8113dff62416d4e419aa01179e5dcaefcdfa45590aa814266c50a6a5f6a46910e774d1db054f319287d2b29c3e48aad16b3fb89f220cb1fe0d604c76d0c9e1b190f9e59d28a910ed95c2e236c2521103921c75ae7397ad1393a3299c5cf3c38285d805aafc8c7d9d3a11399be8e1a7c288d12944f8db85f5e5a2183843fa86c60c7e98b9444aaab2e0b1fa05ac81caaae7bbde891fdc69936fa7317c33b05c332aa6cfd7ce408a4cb05b31372cef1f4a253b3549d503eec56a1a7873d8c855678d8e061b2b6b58906b47d1a6fba648f852be888dc11fdfda8a030efbb5f034c19d41b6f33b473bb47c5473a215c3c0edd59df2fdae4a766a5d52c7e1856b14c50f8c5a79561229ec1aee7e658460a7f78c66a69a0c7da291ea0ace35369485bbf369f956ea787c68be043efbc119ca157ae92993882e6a8dfe978d59c4b59dbcdbcc941fba7a011e1a40cf88ecf00aec5a54327ca2f72b7d66b6fbd22e116d9b8ac691cff14b630356d257beb65399d0fcb368cb8beee604143899dfdcf8f9ace7af8430808b16dfde6fea4e49b4bdda0588c4673ed0cc8c8341b0dc8d06239c94739b9bd30751f443d61febfa15e69f2fec268956dbea56b805dad4cf5f90bea7540b86b52b9c264539a67170d018b5027efa39c998ff5978c07aaa516c6d204686801c918d472bd87466a5de5838ac4609c8e68dd73b0d458c70f5102523e8a117db3bc1092be94dd6cb0dc0ef7f8c099528007f7bcdea4a83a112d47cc5db0be31931384e5dbda07788d75c0db2e1442958241a85ec9c34a6488f2d984eadb3f3908142d2c1d080f52cdfa4adc0e6be6879e392fece501ff1b280e194b9a49e87f21839f7d3f973aa04c95b08ced52c059e1e05598c4c43a376f851356d31501155937e7dc425df92fda7554ec8cc919fb288240b057e34de7ceea87269607318a580188e7bf33a74a643522645bd7e648f1a74be4724457bf6e0c15aeae1340e7cf1265d9163329759fe4c6c1d33a55911ca2e7a29c1f0985c1f22344072bde5acbc6a10f7010e5111c25897dd1c94c0410d0850cf3723cc62c5f68433d22e4c179363683a58a4265fed6bbbe03ef78c9d2accdaf454aff28056777a7396a4955efac9f71932fce9fcef5c31f2b3688bbc49a9ccc6423bfdb9e686657965ed9b6315a52050d3648bc97a21d1dac749068f7d5ba881192950112eeeab2a1a9b7d1fd29b323f3eec8deda620d1e1f5df4609e35ce7a4db5f3236ccecb136f010027e4d7e7ba8e5331e92c31d9d341aeb9513ca88b6abc6cc994219c0cf17182b86a0640e0e42fb023205e0071b807ad21d76eba947ea044ddd4de467e30088febaa234f923710a2398014f6d31b5d200e75e748b51ed74a2c1d68bc76796c5162978daeedb1b6ed3885726d89ecda6f990cff680df36509bb8e98bb330508ed22e30e79dffc05d05539b725d6b0c4ddf924a1143437d9b7f9d6c237415693a18c01854916b467897ca309f5876a80617521e290559137f0bc20a0a5bbcc397a866361bd797d9f17a3cdd637725c62b46a85242087a85f645ce9c31d749e7cb97165e4425fae59655693afaeea81238831a6899c77b0863b45cdb834e2e625b05e3ca44d1ff9ab4304a92231a91275098c1a26efa0d371ac412f77deca735e0d6330a98721f7114f3cc76dc464c6ceae096bd3231d9cad7f0aea96fb5ddbd3b9036d0ca90d0f483cad9174e8f5ff653989547aadb27053a5b8249750cf3c32544000c2975f5c04f4e9482ecfcb1e6ac3402f51acd1923ca3aa795c9041763dc3c1fdcc2e3f9a1f77d4564eb75cce1da13360c2fb96d370052b12cbb025f55691b5af947472eee7cf8d195635dfd433f277e657753f4b1fa2758767ddb94651dbea2d4131ad51fad1ea4a326d8e7b9a3e1b82686c386da9f89149f6d5a6d9fb58dd7e73c3951b4ebcd376619877fb3104f4bbdb55d84cad8fa449a6bbc3a55e7b362cbea133aca47b3d9b02ee367bb756687c71d2813731098290ceb96a8e09b922685e7723b179eaa162a8ab6a57d857243b57dc2f2275be7626a917318e10f3885195233890f4e2a9e0c185716127ad074173978e6b13aac2c5ea5281010fd0168921e9fe395e5fb9d77358b76dbfa7a2f71bf140b140a2d69a02fffbe6940914510e5149a65c92505f9c5d3f66980193edaa52d7f9b51d9f85b33051492d0c4eca66033f9b795fb37405de95df04bd6856ff6280bc56d48cdf5cbdceb2341b0d1237b3aee9e33c37fad07c460bc46b9285482cfd461bcba14a9e083424bd3c6bd0ecfc4333b567153af7dc8bf6cc7502f847fd90fe0a778cc0bf1c4daf26df6b8f9791d2dfb868348fab9c59b8a77d86b15d956dfbfc7b46c40526cfe24f9b4e625d62083fb883f478f657705acfb881ff400e9519f5d7c97c267344b019e4bbc3acd4563d9ff00651ec93da23c6b1048445a87896f3f0bc506e812e4a3896431dadffa6c4197621807a69197fa9cd50d742e9d7f8e49927eccaf7f1343023a2815970c8e3d0e3dc2ba10dcb51df50d03de37f13db27494dc85df8fb8ece5de7544a6501fb8b32f97f031394e69a63822d2b23941df7b9e4377f5befc8fef3f7cf304cfc3922f82b6fa1829eb79d6d54bb3e82b0f9cb7561ea9c93c19ebfc4a66d512083f63db9d772f0369dc5d6fbf58fa745d9c7f7f17ccd6da86f5692f01c0d8ec9fe631ed571cb9027d460697ba650adfc155dcea6c1a2107c78c8915ed327a040892e2e2778535e92da45e2a4c60140203f06ca7a9ef8be7163bfeead90280283192aa8295dedba9c38b7c221dde6c10f7aa1266ae3f16f9e7f9bbdab870a64724f1997969e9d93e95a071425dcd61b5fa59201c01af31ef405dfbbf3969bca26c7f4e7cdd2914ec9bba3adc626342afa4a4a806f13d446b443702ae9a9b195c82efd34338edd563b25d2ddfbf8ec4b6475b104f33c9456b4dbc40ec6441188976a8add75047c50355bfe1f3da91173b1e550a33833009624b588696aecb984859ba0913f53b6f947e5d3830f8c57916d134fe42826d113a353da17ec12bdf83a1517252a7aeb00d7a37988b02908d06f31f36ed16d3be001c606f542b05adaadd0d3d440cd29b457bc65cc5bb927bfec237ba3e7a7e6dc4a7b8149c30fe91d76c038485f33c31f38136f8aed4215216d5abb95cbbfcd72ce6d358d251819668dc15892a3be514924f880e8c882d18710bb5e2b56bb348eec40b7391c35304d09e508879d972d43f7ba88087e38ea7338ede4e9b1fe4ea953995b9a2ac5b215212fd784a5ad4736a8c28745430109921390efcb6386cf947526e8be0e41081aefbcd8f0ba092db0a5655054c4484b350cd08382ff2ce1bffbaf8b9281743e66fca736fcadf6c28f5ae45ab76fb0209013a0d36c35bac87058552eb81f1e49ccd97705d962f13399cb3c42ffbe2e23a0c1bfe1d5cf099661213a971bb94895a76ca6055c2f416b69095c2a6a9ac8ade1057c81bbf90ec162b0c09da4fb86fecc16ddc438629720ebf48ec723124f6a58b5f078c439355a9299f59ad92dde14f7b40df22070d91dc6394b7b847ae2ed04ef5e30b65bf06bc6efad0ee2b1a3e18a99da19ff6a76822d7cd9a41f6285c78a71dbf856bea0bca4ea6c772d541aa23d1e2ffcb61fdddde54f541084d81d94a36b389ff6023ab20d24a6b54ac60ff6ce1b304706b661438fa38de3a5548d2d4ac1b103d94e27ee0e2e6ff0ab53223b5b75c099864c8fdd4a4e8b9fe18adf3711f9727baf11ef830c5952881724aeba642475ea45e3938a70382f5c11b8ff79d3d7d5c340ae693725be8609ef37e9d57223cdf7d64163d4920d58a024c7eb88316a22a3bffbf6685a763f0ed74e1d7e3a80d4dfd91ce6c41b2ace9ec89b0c401e8b9427ebfd2a55d5a3707f8dfb735d1ad19e46620daf4d83d4b32b7a98e779fdacfce7d3c91b026987018e47bd6b3b19155a93381ff1a0c17b5925380b834397882f1f3660d88d229114addc3151122f176d8ab5704cb78ac42a96c888a9386cf348373055368f98325f01d4f3be8c8a8dff13d79cf79dc6364794d4629662a5468aab9cf6a9c71be0735772548d69b4236be8e090d5086c1c945bbbad0062d75ebc03771dfd8b7b5985517e98d31959d7bfb837ab185c3c79f24d220593d936507425425852619ea0a3c05898f8edd6d8ab23ebba0ded64a9f1675c310d0ceb389f89f4736ef0138d53ce0ba47dbbbbeff367f39016624909bee3b4537b2d89060263e0351c441009dc2a89ed014d8a08deabea50632782e8f1bf627265ffd8c3094eca01ffbabd2c4f512b825c56c035d3a066d1891f214260352b6c08faa5ea29a1e598af7441767c211f6eb6fb8e829509b5bd3ca32291e7eb001a96325c29fc6e984ac82b38976454be53402dc821e5b7c7785b5ad87bb3f879c7b204bfc432c2bad3c8af55c7090b13deeeaa7b36606814533d19c772cbbe79770dc9780a5f5418c1a628a363836b165aacd5363105d462bcb34e7989530464740df6192ac9306f65d9284eb7be0989c2291dd2b9200a1d484c5080b8cb99e2271005dcc701e98229394e77eaafc42f8aa8aab997c9948301448d043ed2f931cf4d17eec572e177b38aa17cb4375b49717c61dcaa473bb39db464d9b2252608c04f6a1c47a18c61b58c3f2eb6824349fc78f9044bce454a65c72d8bd07a354b46319ffe3078cb0d6b6ee96e869febfe00f39c65c43b4306f6c91a6df96e2b47b5ca4b2689541a9f208c7dd3543a2112fd4217b67b8929b33766f9e11a8b72e5e1726bb6f6e93a2661e816844cae2d48eb81283e9dced57f20c296b4ea6d3917474dbb3e7fc8db4453678532c134b0a78ce8127e47c84987771acf8d2217eb362a816474e1eb22eeeffc8bd6b935fbf6da00919409f9c4dfc5f1b2f0af131c15aa32860a3e9d9a0a9485fc7a5dd34bfa11409aa373a1a2376115d2277dbd7c81abd44466c2b2c5a9ad3ccf5fb1b62cd9330acca3856b72ecc244fd14cb1952f18a02de1e518158a5865b03001de317196d675d2f4de1c3570df89d3725cf126ba3a91219d361317003bef3d505d603530ea4d9af20d8bce070573cd09e7645e3fa55fa89fdcb77eaa9cbd9dae40676f4efdcea8c9bbaa61cc06c513976ed107b2d598be5f72e5c6d8b9e0ea867183457781dbddbd4229e8c8951f91f507319ac0a142aa8617a6933205efaa77807540d11131e03f94c0cce92d7655704db9f66f2f9f270050fb96af14836495716a7e93e4d02f53ef959a4ce07a74c32cb36a41560bab48189c2faf80c06827fe8377f0d18ba812fc43839ed40df461c4f47c9d2a019418b892018efae2943884724ef57d6f751bc819780f3cdcbdec0aa8d79cb8dfb7740d6d33445deb10b19fa9763a6d6af88f8a1efee1b88817b2ad587fa3f45a5e04271401db31a3de3a76a91057f5bdb152ba4b6ee9700687c0b9ba9605ee9a4ff548d6467028d7095fc6d21081649c69c2841d3397e0e81478c4135ac0de728c18dd8e9b5cc7d7d6959cc2a1d53c9124c4ecb1a4cf0ca8b016541858258b2279a7034875d131297a69479f80af5f8ec275a5393423ac377bd3966c29bc85a017ca0855578fca484814e6983bef2a1a52ea0e65dc7fedf13e3c34b9550fe7f4492630dde4210ad75e539fc303988dbd9d9b8df3fd8aa31abbdd5ec8737a0447bb1a0301c89607a5d3788654d0d479c6853b534797a81c5d974d3509cadd124554b89d8e4d28b641c807d42b6d21fda65ce63a1461cf52b8e09e9d881b87b0c55ddf7b5213a163376feff90d6f514b7af8e3330952dd3b3140ca9e4d7177309f921b14ac76483bca3cf68d121f28e72e89154d3ab599df860cda413476654786d472ca9db317ff44b1f966497f2ce1f928374e2c47b015446aedba3c4401f34bb54d3bd45ced4d5b799293b68c33188025d4f5341b7e6dfc10e1a1ba95d75703cf7fafc960ae4ed527314bd39aa3635f926879dbf709c5ed09ab6f23bc21e3f6940668ca1eafa0869b58d58b8fb47808be3fe59f9fd4be0a61f4642400aa874c974f03975986dfb231dcc45395bf13d747d544212c90d1473d576efbc1d7535837e279012fe8bd31db9dc2508df30b3f5a6f06616d241e1b8760b893ce05c4ec742c36262532a8b88bd0fddcedf0501e3591835830b384206034d9da1ccb55820e48cf96372347302b0da008fbf98218205c0516a3dfa3235e297e17989476ec6c7b126b18ebf356ad1856a77848f16c3880d2756e56487674a56c0fd569f4cde9eda9f6c843ba89bd6a9bb3d11dae9977a03029960e7a8a73e2e2d3a7104acdc830a68c53fa35e37e61b6f25dccbf31300195f0cd4392bb744c6fc4035f7f8ae89963e29db93217e7e9f985709aa63079a787404332be89538015b318fc76f26b7816b8432532e17d598e3aef0d3160d573413655517f23684705a164ebfc8a1ddfc589493bec8da0f748cd53b62712ee83195106f6b1343d69e0ad523a210784332fc28ad40c857058e38ae61fa70a526e8e79fb06df74e8f4894088be133e48a61df2eecd77b7fefc3a719ba8b2c345c722c23c28c07c312d3828331d8db96dc091b94ff5c93b0a45892ef865b46728a3ee8024362eb10b3c1116c67c1abbb7639c9e04f7326a2b0cf23db6b29b739753e82f0bef9615feb27e7838804dec683a74d16e13e883498715baac30825db9fc4001070cb6acde65de78e2300d258c89493d4b8cbe3255f8c801760f9fa1f96db6ac189996f0d08d0c4075c061d9e14de65561ee364d1f7e89e619fc5187bd07bda78a19d39b5c0f528cce851ded690fb277f26c26a5359d61787a25e3b52542a07c3f29baedb8f08c4d092927ea1d85067e6e742bc90da2d0c57159c05c4365619b0a7eac010b7bbe49122fe926acd88b0585c3dd3704b79a459cbff645ffb4dc3d004bbf9eefaba779186b7b5f095c172540c8ce25ed781a22ab61b63924a0fb66f38c7fe3b1c554f674dbd03956fed72105c1de2b2ced5c304a9eb99e49c71e56bfa9162b4522755a547e93ab864d327b94e7b5b7052bce901b64b4c3b272df5108aab048bfa4f288c537201fb4b3a265085decf5ff996573710d0e68758c9facc62fc7f4507ec1a1b3c055a4afb6a2efecde1f674d387faf4fe23bc0d09eb8f7f37490e5764565dc0c82f25485c792a6ce3d1cc49c5e22bdfa125ae7320d8025d6cbf0c251e907febab4a14459962f1131601d54239435b51ecc627fd00b05ca795dae72f5281c77a1dac940eab3d0c51c4767347245be542082a17bdfd8b69bfa1b3cd707d48a875d9f66306608b3dc0d17cdc9cceda02f37e21cfc34cd6719a5f1ef3e23127c32fe01081c3fd59fe9ed42262583e74660b08e0c674c64a0d32131693af9c6c96808b90ce0cf6ee1e309b4ae26ebf4dbf78888f86d58ea7291aea78cd974c33f53ee5169fc6afe69d315ee325c6deae4494a8d8f090e0de415a34c746059ff56d3b64c1b8f02563ab8c14c458b1a3d18a852aa1df9d708a0b26e51d7f00a261b06152a05f6f87fe71a8f4bc3b4b2816c648e8e1eb8bc5c5b676aec98975df06b338c7c7b745e29ef70b14d89e1164800d55efd06bc9bc4abc24545ee76c1bec98b65d273d51ac84b5f832b5b5ec5ab9eaf61ce49d6c0c9cf324f54b70013caf54b148c7a4e8ce811d64e8486a05ce254951be25f43ab8487dffae6edf48127f9bb39ac776584b595a7bb9b2e1e522da30dba79f157c18af96f935fefdb95edf8490ab41fca3ff3df6686c81aa5dbf0a38f450cf9e819d52807b98ed7ddc86ae190b155fad2d0317fb4109f2347855bf10bf0fab7ed433f0ed12210589988a7089eb0644e2d46f51ae734c25aee3afe566070ab4e2bb9742a3291a0880ca4f1d5c51d68626904429b415a5a134a56d1f36dc98e7bcd56414d775666bcbfd378be4cc29973ca09175594f805c1f00d22e5a6f565d1bce24475cad508fd29dd32c18b5f54c55ab727ff424aec649192c4bc7a32c67fb774cd285cbe158646415028c40a8da652c863841dd7350733cebcf24d8cd5928fb23300126e23fe42f531e9058a0bf6bef9ed2483a0c942388738eb77dee32c547e6eaba45241f72cc3f0587f2d9a4341e3af5c50f2cd8f3f2c68358b8e5d35abdde0ff2a2ff78f844dbd015be4cce1cd9056a8e098c8a6681adef37d303f04f97de4b43228b5385e2806e3fb7004c643876323ae9ec7a42048b044e1b822f46b12ca4d2115fc9f93cfc06a1f8581c9264186339637cdcef9a0de53c094f74e4ced21c7848c13c8b9f5e133fbc80b771da03f50b6bd801452bec8496cb28ba29f6acbf6c67f266231c6c05d6db0d771f957e1c971379bcd0d937708ea42b935fec17132eaa147c9f1214f6f19a8b82bdf31179020ce07093a33cd4f0fc6c998c5e953bc6527c95028337a3e69dbd99c231ebf6c603bdab83ff640e25d562c283366cdb47f74689e1cfc7007163c4169ba0b2416c2f9af0a9170c94fb187a49424d534858c1f28fe22fbee75e70468cf431512296ea397676ae1b38d96b61b836481aa5bfdb175b490e22db7bb39f50f3438e9a47ba27f268961ba6bed00339a84a4eafd57575c253ded3b22da660e958ae3d9c78e0c615ea5fc25c235de2ebe0c43f5972ed8255e69d7dd4589b14155a09f1ef30b6d0eb0e373bf055eabde2a7963a31602a38bc48054fbd7422ec7b206f6a6480f1d76332d32b4995b2b24c8235281abbd30ba028ffdf83f5a273fad25186c8bc3c0e5af528cd25c78df60d2650a082e0566a12e05d35d718e80e5a0527c47ecac10ebb772382aaa6ba17050711cc2a3d8dc8ed9723ed0fc7717ae7b414e32600003556c75987da5dcea04b431087012d285baab60128059d7c4b96f163809c77dea3744f7ff7264643d74cc73967ed44a1314982d5ac3aa3fda65cfe0d25c7096bd0b23d780c658a98bc4ed5cdb1391bca532f492d73dcd4021a437dbeeaf922f5ab20dcb3ab85a1468a3f193fbd3ce63ff7bcddf924bca1f0235c168f4807775f146327e9c3b8ada08134d901798916b329fe314836b6d936ed656fd9a637d2cbba63f22b55c4ffc552a4e600949e9ace97b8899c22ad48bbecc940c92f342dc8828c3aba97419c3f78d5ea0c6a973c56884214069d93fc4e08dfac6203ec5158cfbf6f2d04afa10c4a655182bdee10664bfde2cd322f34f8873a9b25136454d07e19edfdcb0000f528877f697fa49dcba7c2f3a08fdae60e26f599fafb2778e115ec55dc0ca96d5daeba5dda4bc0826a03f4529cdc28c422ce75228371fa77aa0c95ddc4753ca7bcef92a173e0bad1e2c467c98389653b79f79388390661b407e497c35013d3707b1ccc2ffb66ec1534ceabf69ee36c0dcc57b3def25cf5405ad4ef097105ef37393e6314794088398a4aa5a1d16958ca017b954979fb514886b76a33b37e1d0ffbbe4bbbf6379a23eb7d293856050fc55e10994c8e4e03520a6e602827fb8c4c462a9b6d1b29e46a48b0b6ddfee0725f09dbfad76709fcdde13f8eb6eb4356d5e589fccadd2eeba5fe6d5f282c1537ddd5f64f36fbf971ef4499fa27c44f3bb15dfa78ed2c012d340ad2adeba560a03110e062e5ecee72b97aef28479776629c1a85de3475183d04c8a23128d1e8c6204a2955ca7dad54bc6d3adcd49418d8e14fdab126eef0f07dad24d6de8b5d221ec548bdbbfcff5328ad91f83341c80772c0543c592046519aa117486bc8f5229be7e0bfc6cce89085859d08e60fe00ad970228276c4dd09f17e7cb009c9fbdf1bdb641438e8d096ad87833e3c49499833f6f219edc15881a8cbf03193bb4ca3fcd3327e37cf3a8af62c8422f42dc0091c9b34f1cb3cc41268c8a17567af0f279c12359201ebf6943be90342ed718900ea0d6792852f141e85a0649f9201879ce5cce8a7dc5074917c469f93170b3d78bd5b97a62659265a8e120f5aaf361f6be3568790285ba718e4b72d23393cc40cab9041e0ff12bb6a132e0751cd86733d2b13c300d3912cb683c561652fd52ac0d117c6a60447ffd1413198ac5727a4345bb64b4114e8e96633f5bd0c2a9c48372c86b6f4282fe89b492763db0993b750039dbc07b7841809fe59ba95ba17b2c1b2a047c8d26007704deaa94aa3a0c47e5dc261a55705f4366ac89b919f756411e8338e1d50f83c5a8e89a63a4a7f8d0bdd38f420f622c9a8fd37eaf55a08d3de0d2bebc0dab72bc1ff84f23f9d2b921e1435c6f57f69454ab9f80ba8d9da93707dd2f862d63993b1cfbbed223295294ba99b6e8c49f0320b64dd4cd5ccd7522ffbdef71f6ddce5a52d55d58ec3b29dd85f5c8f52d436241bf95d31f0a84f712119b318cfcba8b2c38812b79ec57535a58d187c822b2d35ab5942395921dae8358bd8a48f04e988b7b92c8bbb0bf186895093064113b7fd95fc7dafa788fa87f196e7b96f06865008c63107daa39109c9bf3e43167eadcbaf562f03050fab94b421eac9405487a90e45b5e2c9e380c677421de6672c8d7c966647777cb198429a50cbf204977074979dddb9d1f870ac2ab0f50cc8e43d52775ab4000399f76f6fc8fb41bcecf5adf08f61b22ebc864ad35d883b923708758d6265dc47a74890436b5ee9be92567faee95e8405af9cc086bbe2f51d5c83be5a94707992a40f5c81c0490f3350778a19d29e378ea2d78a61588645bcc87be7041edda14b298abcedd9671ebddb39de2c7fb77da20612f8722a8d2f42d5d33d679c467c2d987d64b2d3cb2971756a34bb1788093ec2a25e74e073daf8ad838e5650d431b617af9d2a63042e275f077c4123235c7451db0b813890b8e57564330c04d4a2dfdbfbc95cd2d6ef26fb785217b8f20b41a55448f2ecf51844f43d3d8261c48dfcd4101912fc2424815e3cabc6de0d4e4b7ca44c3eb4aa75342d41d0e53db7cebe1668ab9ea7dff7fab8ce2af979a0493eddd5836a2b22d65d7a47b543d1a8ed8053b8721254a8db690eaf8bbfe1e6467bd30190c67353b9213631541da1e4ed9d59211f1716756882d12a5265297112706bc11bda6220b4ff2c6f2c674ed14ed85f99fbbd4e3e9a2c3d3c68e67d23dbe7236bfab3df1e57e0ea91c45fa063a34b83d33372ed9edb21e12f5247f54027f82110ac376f28bb8f07caab35a515488472b09eaab66eed553facd996cdb0671eed58585d43a922a22b09ef0423e8d10eeb30085270ce3e5123b2e3c08b1c6f25bd45ffb699743405310c9808f7cb118231a92ef1f8cb9fe9ce7394d99aef199de563e52445cfcb8e8827d246f02cde8c71e63a9e92ec18ff23533aac30a906f6df765587174df0c860f07b30301d3127d226369c8ce0f3b5fc461418c89e2e19aa836ea8ebfea711464ddd93e7f4604c863227f6624291b52a045e040c8349771a9bc747766f7d9b810e771d112c4688503b99abf4c4df04f4e09e611a1f768a15f418371855ad42dcfac0d2bc7852c5d83a396325d45add5d2c4f5acd05b22d96794c098845206ab6c13fddd771e5edb5f06fd1c109455b584ef1cd7e21f7febcbbc3dc5897e588cc1bb7504252c3a24a4d2236ccc1854b8bdea73bf61bb555ee395165029149c9426635b9229d3e4c6a4b7cb1d0b19f427c9bfb98b19ac85de17fb877f0f79578fd2c7c825553bd80381da3b323b695f18744243ccffea05370045efecaa4a5627cf7eff82ca4c185695c197235b7a6d6a357deabfc492f155572e8292013447769b03068b1831dda2769e8d5d0a35f4769dd7b5d6de903522006859d1e52b2f5499b8117ad8b47a9f81d173cf4f0fc8f722a43822799c4899204994a0cb6fdc187af362c519de59a2a160b25893ad0c63865a2b05eef191b95ad6198a8ff91f80a11d910b0903e19026c05511150cf4bb6eaa421dc38b44ed1084b28d675ed8781337b599d56b0575f6cfbb0e3fb64b70beef5befdc2b71aa12446465fb63899c2b0cac26172503ca7bac9edfe18f23121a60f15d67ef382e58af7955ed20c1456eeb9543389e6b8701b356985938d40967e5017d872c881a0d5056d1e7997fbfd9205b81674f931b42069a9d28028cc83bed8981a5577564b0b03c4edab33d4c9431ecfe3b0bafb3e7a27902d54be2ee7d5b3a62d137089a52cb770fadb1c55f7f4dfd95587a6d65070787b624c87bddf48093689b21bf317f1f1c6e14a21499257524e760d0e0b5da29d66c23b1a1cc0686fb14df81b1167007df43c4a9b012bf09b70643c2ccf619a2e55368f540c98d0ee93d6f97d7f1bfa38a4770284a75f6a54af97e7b2e10589ee6b8802e81adc1d1f493338b498ef2dbcc3561720b120f9d2f264146416f600ca6786fc78396e78cce605d191e64db87e3fbd19b98b8485a2f5a2ab4de20dc86293528a6c5ba719113dd7569800eeca05e0cb7182f14df79de84352b6ddbad96762d745e4e43ef0c1c29fa70fb67de11213f85d2d1338f1e502a74a50a20c3e4d4b2ea4a00c429413ea6047ceeebfadb6d9c5c7bab843069cd34f4ad7592c44d25aa8be8f405422aad40ef08a74132c8c4506098955e18c475d0724923d429e0b225a84628887f15c70d8fa4dd442c8507bf71bc1212943cd322e6c7787e924d57950bae3a3fde4bd0696aa0b92ed42a0c90bea6b313a7105e1b077873a6d6248caacb07721d0cae8b761d417ceae292c2a7e64bd9500e388b3f3ac02e8a34f0c1efe14cf58d14f7bdd587e6ac78fd5a54df98e92ecae26d682e2657427e3db848b531fd466889ee25d8345085a1ec98c419a4d791bc605df8d53b025adcca806d00d29fb8f82c5a9042a32fc0481e6bca1a8eb3fb47397cffc612062208543e13ac6d52c60507bf39b96309d9ed7a2473e8aa12c2bad3dbcffcb1d2a3ae2a2e2158122433619253a91690519fd988df027cb16f6e84b33203997d7b6990d8e738cb0c759e343b3e9d632a189990d137d7a4bbd34809cb7fb3472122e610ec6e6a49a8c134f42edec31362df82439f1e243a9a</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-03-09</title>
    <url>/2020/03/09/%E9%9A%8F%E7%AC%94-2020-03-09/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="45b94595aedb133be9df70351db2286987a71cc1255d75222ba488c1695ea29b">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e23a64b67f9a7173f52e7b9ca149393ef9ed370bcf0c12b31034856b457ce1a8f41edd22acc4c6846e27aaf44940bfc4c6450e637a1691621156c34375099534177bbba385513d9d74a7bea136d8a902afde47214321a4f9cbe40b3426b9084205a00d92b4ba75044f3477770c1042a6db3cd5d1491bc7df474fecd39511a6007717bea296421a6a9bd321159e2a83232dd0ec34e14d3852b0acb1c18a8379cc9b224fc19471f325994e0c3e2dbf3c8f9d26f7ad0a0f1697cee40aba4cc7fcfc765016ac3e8da5edc10c02b51248a9581d4240ef94abd445c90045eb11312be4fb7c410088035bd3ddaf0b6afc5eb00b6aa86c9971d8babc484603ed9315d5b0e55176f793fa32ada5b1552384752c23e13942c5e055a5ea384990acd4cfb8425d1d20c97cd3651e1817b2caa9b81fefb6951083ab4229806a25416d06e3f2854e2871276f89ea4275190dc034097308b02683b605da644c9cbc8277d110e27248396588e1e6fa1fcb611e76d17c50c0eee5ce0e94443c6ad1ed3f04c21d6ce476bbb4af929bff77ab97cc3c6a103d29901e904bbc9b5faa8ff4ee52ea362fe8d0d5e96548fc6cc87bbb305aba7a8103d18dc2fe1024e0e20e0ecc52ae7374baf2eae8bb449c7828ca69bbddebf6e79050eb19c897c1f926530481ed6a94c5f69b124248b3660ac27bdb41208aa4ba1cd3c03549d907dbc598bd0755deae486f6e41175c3d7a81b018f0320c9554edb93ee228974b063c483fbcff13aaee35742c3a6532a9e5fe5098bd954c8964dd11554ccb6288a69491ecd67af37067b059ce91acaa481deec0e81fb306e6f4f5891c7becf315b03d56e140548ce7a3eb3467377cf2ae280325b90fc605eafa5b06352a27c7a2af55da0dde2c75d0db08970f7ea0b38db693d3d56e586c8ecfc050d018212de48b396c6541c42e30f7f0ef806e5c2bd5d2311328c716042aad48bf8d71e59fafdbab4bfde1bd86bfbe977a2d743ce1ebe09588d5c2bd413bcf94e587f5b093e39aecfa3475dd17031bbd53cc9e4c8daeb6b61890ee81d75f809e393a665b3dbcc7b866361714352ffb3f36b6f932ca78f4b22acfb55408dd592800d79e370689c732109b4e2a00a95d697f272562e5e4050bb0231f83d4214a3a6308801c67bf793d63160665214f073a4530574e8b8bddfacd16ff17398cfaf4c57863808361a4d861b703fa71593c4a42263747ed3e948df64c191a55be8f072fc7cd31ab45286ebad9f8eaf41a701376f3debf35e6ac2a4b8e8cf7b602b84b457b033b29a8b9f94bfbb05e95929dfff90b990f4298225bb8d3b35ddc77ecfead260ac821d1cef6b78be6f5ec8916bc79d7812ad5729ce071abe2115ff004f94771a16adc2d8ff718b93dec26b1f2f76fd3c864155e055b1e7edf75e6179b3fb0d585559e88e6094d5a31f4886c1ef89871d0e03f37db71dde3fa0c0f7eb714e0bb05c57e8add12ed20d2127dc0fdddf37b8cb9181f81a57a39e6aa3f7ea9512aac065c05ab52c91e3226afea831dc0ff113957e159bea4cd0a5087159f133ddecd59dc81e4b127369125320c9606d68abf32cfa7d64032ada1f7010d0478e5dfe9c1327c8ed8aad9495b3021facc6d03d0e480413fbe0942747c4600b4ec6cc208de587ca41e412d45f6c012b4b45373526b12b4ed157198a87db4edbe909572f90457480ee92a06c2901274bf09b9ea03bf2a8710ab4bd0842d737199ef84e27eeb497e9c3c01d3fc910e729620d7aaf4f1913925a12d6985341241183ee7f5d024dd51ee3729d3ec6966213f9330d7093276b21e6a96657e071a0bb119365b813eeba6cd6e568cd1a9921036b7d03c98a80fe88a1c84aa2168469c16c63dc683d322d61c895b38076a9244dc141620889e2ba65573ecea35377f69db637cf74db1578ce86914d746f1a9a877345e222cb927404e44626d10b0e6b2e0b4f246d2149898b673187f363c7a2844d8f7b6f26a1de60a98994380c9ce87f27cb938dfd8c917cda03f007e7e894f1e9689d186d786adfb70e179377fa1a5b1d595e726510e3fdf245d5912b5cf84ef4d548e6d823a8e6716a8cc4665b154dfc46c2f1640304a8dc37790e9956aa398ababfb89f247d4bc84593a76bae74d85efaed69f63eb957ca14a1906550c5105fee4c730d8e052e976c0fb52c16027907d373181b85d0bc3497e75170c56e5b8c8706dbfe99f51fdee210153941670b5f7ca93121256124bf494a3ed89b22f529bb99d5cccc2c9640349de5934bb7c0115eb07fb85036ffb99c1accbcb3572464e646eadf8ced77667704198ff4fa25a93d4824b34e67ebf7c6f3a002d678a610d2e647d5c433052d964aad6480ec2c7a5e133d4fcc89b923fce26988a1652d447c74e82e909289e8772a3b7f3c4bb59960e5d66542e338f137ac2feed89b5477f94e4cac6fdd6a6dfe91cb4abb40cd6d7b84aa87c859c5abfe5c86b5442574c54fa74661a98c1d2ca14118b0aac2027e26f714c435652361ac76f6cf3eb7c945e923d0999d217253aa19c46351dc029aebec0b5633e51b122a43b82554818ffa20fba4ec934f913192ebaa18fb366c5359da14533e43ef2a61270e0c46eb0b8687fc4de1529b46555e28d2f555b40fdc3614999d1bd064b09b783084c1be01eba4253508fb1ad82bb3e99320932ce078cbb69edb6b4a1bececa92d836729a68e4e208df5ff52e45ed6587db54287538a5918892d0f78536998a4d4f1d03aca0efa31f1c8722197a559d2e6af14f29dfecfc4ac27a591d00cea1867349e046524cdd81ae54cc283332492489236bdab8b0b8c757617cf944d2f7b9aa999cc9d7ccd68eff647e25fee0bd9953e584ae08636e0c205011688381143df9863e329ed6a6c80e1524c5e4ba82ee3c998706d1010b84b94defde7a565aa587f9912622038048ab8f906cac1521ea1812fb72828252a8790d4453081b95497f8dc5dd405d555cee609445ee1f2db805ddc80e3d7ab5d67360dd46c3f9ed36965d4bdab2164d1df9dd57c5677612b8ce7623a3afe46d81a5ae42c90538d8012b25ec59164c00cf00b430718670b6e3de4bc0442b66ad4bfa624c1d3217c58da41b6a26e846d9ab0be4de2f002285b298a4296b2f84abe90ab1f0ec413d57e8e73907b361370fc8eeaaf7fe67bde5c386c95c4d4425d5e1cc97c134ed44394d59abe098077b8f150b5371920cbd31761ac735633906d50f8cdfb04554813184f36df157328fc338f9d7ec9d2701f47ecdf23daeefe1b0ea27f3300186892eab59d8497684ba501cb47bd81cd87925d857eb106ff6aade8a50c59a9a426eb4053306c1d961c0221ae370effa1950920f1c4d0a148148ba17f7de87c006d17f264278593cd692f971304adecd224617843ef297ad261afa38753e62b31c6555c9e503b5877e0f69cf93a67e1dc5c6ed515be9669c3f1b5bf1a9d7cfa36bc615739bfaa5930e04aea0a29f62800f43bed018d1fd57dc12ce8349361c72a46f77d144fd51f2b1577d070ca47d53f91aaba7d6f7a781ce5c3f9282239c8ebd72f3d068c118dad039d61f8ad4d05c41ff4bfd42c7dbaa19fa885891ee56e81212736a05329a4e58e96df78623bdac9101718c02eaa7841b2f2449fdf07c12568525ae3b52ef1b52bf3a99a76c5a3b1006d4a47d02b08ee7ac8a9edb051eda1f2898b654ab33dd6bb90daecd69bad2743a713db2353d8fdc7559ebd6d939b1d3ed94af22ea6daabf479c0f0470e5862733a5aa2e312d60b0c407228bb4de8046159ed60b8c048512a9cfdb74375d458edb708a0194fe96b4f8c14e17af2a9000f3cde29ca7457838bc6abcc056eaac0465b29c85c91981a86b09bb1e867f469906c9881cd3f6a7409d5fd12ef6c9e6d6ceb982db890fb8f0559f83df75f57c3ff2b016eb8daeaf26b0a2c13a54de8b0cd7e149782c3af97b14c0b8f1827412d3965037f8cf0b25cea5935afcf59c190758ebb90ae18b41e487b96b8131f7e451b296d94e41210628a81e04fae4091bb0d5e442a674a7b6371fb90c2a01e75a3dc8f5ccde0bee7bf3b0d5d72ab6a79935d4d5e89499faa6e12fa6f241be130b6160e33dd73d680153f27f50f322828b96d7184dbf52546c360311f93092ccb7031e3a55103b619e247496dd14054997c707c43f87709f2521d1256abddf3e773f5a1392f76b5946159725c17412d548aa8b4155d4ecfe1ebde997bef628e88104d2817f831832d0d6edea798bbc341ccaf9e315dcb8b833357236e30c1f4492a220acea96be685dc7c98fa82cf700724494eadb42f48c0b988fb11e83437efd472d232f274aae2824b6e4c75507fe8f2d7b9c93d634b41beef65c5815df09ada39638d2b688da4c5862ca79df0a6794bb87ba3345dee3f673428c03ac5f8b8b9a05924f4b1349ca125978966e3aa83710a46396cb2a600e639338219dc45e141530545f43ad05c4de665cb145d19f021c6bf7cad8786b4e461445c158487722ad55ed350db8d8f95077cab89ffb5f8f8b028c7ab57542b75f19853b6295f0a09808e628cdff3d1884fda121044235649a0eec4e313e0fbb1f5b8207e7c7dbaa60801f3cc3760c68994b3195d38f82820c1994d4fd90ef24b54477c222ea3f8c533328f5592fbab0be34273f481c4662c1a806e114a2534b11239f77e8c14d0013755c56de05f117431d7835954b0c86fe427392dee4ee251944c3abf89632d3d214914adb6f3892def79a0a7f430696a11cacd2cecd49dc157aaaf0cb610b65c2870a5b63fd63b2cedfe31cc96a6241cf7b5bd8153a2c236d02def712e1723062bd63e2f63decdd53bab4f66aeb9419654bcbac5f8c38cd445f487a82067b6788424ffd76c60a6bd867d8920a5d099c6bbd3ba586828e41dc2a68b6fbce745179ac4b9a9b6d245d604333290dd51fe3d0fb3f3d757938f9970aa06df54541eea296697b761fe3df7b87b526b7fb2d7fd3bb38faa9e0bdce0e79e68a10f3c742c405c727b03944d1bfe78870bf3d64bc971575377b67e298cddac7714d5272067ffbba02ec8cadad3914b750af752f21f3a619281feea4c2e7087fc60c1fd135c7506af629a091d74a7feaebc4b89d16c573c285f7dd6f081a5f4f749d71b8958e3e5b4f87bba8fe4057cd6e1ec0efbdadd8e762210094b2cc3ad3b9cec2dffd5d38fc27dcde7818170a56f14f7e7b2669274a6ec5079b26e23ed44c9236b3e0e133c340b04b087ad452e814837ff90bb34f26cf624891670b3472b50a7527dcae09f35d1a79fa26238c3b9cbe1a67c6f99fb3bb753e95c0f67b4968805715b86c042bc2ee511f23bdbf80c50971ff5bc31c6aa2c42612c45b7d541c62f2d6ee42b337093b4e1bb459446a57544c00f9631a377d5795dadb8cb78f06edf18489de8be8d8333ce1e2f991b402dbe642788ea933e6d085d9b5ced6cc257c71822185a6be58aa537348c4898a14e55a533e9c700612b15db63ac27cfb9ad0377b75f9358e911613b403384babb1797762950677cd7d3ba3457c1f366a571c52290e63880d09f8574c6fb066396eedb47f2cdc19ca5c5ac8e4091e3676734eb61251e058c21423ac463061f678ba796c877635b8fead5d2c874a56acc39312d1389ee9c1ac81d7934adbea9c714468cbfecf5a53cb3ae759daf14b09b159c6adca3b3d4805ccc7afbeffd247e92b0</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型-1</title>
    <url>/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-数据类型"><a href="#计算机科学-数据类型" class="headerlink" title="计算机科学-数据类型"></a>计算机科学-数据类型</h2><ul><li>数据类型-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li>数据类型</li><li>数据类型-变量</li><li>数据类型-函数</li><li>参数传递</li><li>形参与实参</li><li>内存</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><hr><ul><li>数据类型-变量</li><li>数据类型-存储类</li><li>数据类型-常量</li><li>数据类型-函数</li><li>数据类型-数组</li><li>数据类型-指针</li><li>数据类型-结构体</li><li>数据类型-共用体</li></ul><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>概念简述:</strong></p><ul><li>在计算机科学内，任何存在于客观概念与主观概念的现实或抽象世界内的一切概念，都可称为之为数据</li><li>在计算机内，一切皆为数据，数据即为数字与数理逻辑所构成的任何概念</li><li>这里所谈论的一切概念，都是基于 C 程序语言内的</li><li>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>数据类型的概念即为系统化的将任何存在于程序语言内数据进行准确的/系统化类型划分</li><li>还可以更直观的将其称为数据类型系统(相对于程序语言)</li></ul><p><strong>类别明细:</strong></p><ul><li>数据类型系统内包含于的数据类型可划分位四种类别，分别为:</li></ul><ol><li><p>基本类型</p><blockquote><p>被划分为算术类型，包含于两种类型: 整数类型与浮点类型<br>在整数类型内: 各种类型的存储大小与系统的位数和系统的类别有关，但目前通用的以64位为主<br>在浮点类型内: 可将浮点类型分为float-单精度浮点类型，double/long double-双精度浮点类型</p><blockquote><p>后续进行详细介绍</p></blockquote></blockquote></li><li><p>枚举类型</p><blockquote><p>被划分为算术类型，被用于定义在程序种只能赋予其一定的离散整数的变量<br>后续进行详细介绍</p></blockquote></li><li><p>void类型</p><blockquote><p>被划分为类型说明符，类型说明符void用于表明没有可用的值</p></blockquote></li></ol><p><strong>一般用于以下三种情况:</strong></p><ol><li>函数的返回值为空<blockquote><p>C 中有各种函数都不返回值，或者可以说它们返回空<br>不返回值的函数的返回类型为空<br>例如<code>void exit (int status);</code></p></blockquote></li><li>函数参数为空<blockquote><p>C 中有各种函数不接受任何参数<br>不带参数的函数可以接受一个 void<br>例如<code>int rand(void);</code></p></blockquote></li><li>指针指向void<blockquote><p>类型为<code>void *</code>的指针代表对象的地址，而不是类型<br>例如，内存分配函数<code>void *malloc( size_t size );</code><br>返回指向 void 的指针，可以转换为任何数据类型<br>后续进行详细介绍</p></blockquote></li></ol><hr><ol start="4"><li>派生类型<br>包含于: 指针类型，数组类型，结构类型，公用体类型和函数类型<blockquote><p>后续进行详细介绍</p></blockquote></li></ol><ul><li><p>关于聚合类型</p><blockquote><p>数组类型和结构类型被统称为聚合类型<br>函数的类型指的是函数返回值的类型</p></blockquote></li><li><p>在 C 程序语言内可以对数据类型进行转换或强制转换操作</p></li></ul><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>文章先进行正文归纳，再进行笔记归纳</li></ul><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h3><p><strong>对于涉及概念的系统化整理和解析</strong></p><ul><li><p>变量其实只不过是程序可操作的存储区的名称</p></li><li><p>C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局</p><blockquote><p>该范围内的值都可以存储在内存中，运算符可应用于变量上</p></blockquote></li><li><p>基于数据基本类型，有以下几种基本的变量类型:</p></li><li><p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等</p></li></ul><hr><ul><li><p>对于变量的概念，无非就是定义，声明，赋值，以及调用</p></li><li><p>其中声明和定义对于程序员来说是同时进行的，即在声明时就将其定义或不进行定义，只进行声明</p></li><li><p>定义即为为所定义变量分配内存空间</p></li><li><p>定义一个变量，就是告诉编译器在内存的何处创建属于当前被定义变量的存储区域</p><blockquote><p>变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表<br>并且定义变量时所指定的数据类型必须是有效的数据类型<br>在不带初始化的定义中，带有静态存储持续时间的变量会被隐式初始化NULL(所有字节的值皆为0)，其它所有变量的初始值是未定义的</p></blockquote></li><li><p>声明一个变量，变量声明的作用是向编译器保证变量以指定的类型和名称而存在，也可将其称之为专属于该变量的标识符，或变量标识符</p><blockquote><p>所以编译器在不需要知道变量完整细节的情况下也能进行进一步的编译<br>对于变量的声明，或称为将变量赋予专属的标识符，只在编译时有它的意义，在程序链接时编译器需要实际的变量声明</p></blockquote></li><li><p>对于变量声明有两种情况:</p></li></ul><ol><li>需要建立存储空间，例如 <code>int a</code>在声明的同时就建立了存储控件</li><li>不需要建立存储空间，通过使用extern关键字声明变量而不定义它，例如 <code>extern int a</code>其中变量a是可以在别的文件种定义的<blockquote><p>所以除非有extern关键字，否则都是对变量的定义</p></blockquote></li></ol><p><strong>关于 C 的左值(Lvalues)和右值(Rvalues)</strong></p><ul><li>C 中有两种类型的表达式:</li></ul><ol><li><p>左值(Lvalue):</p><blockquote><p>指向内存位置的表达式被称为左值(lvalue)表达式<br>左值可以出现在赋值号的左边或右边</p></blockquote></li><li><p>右值(Rvalue):</p><blockquote><p>术语右值(rvalue)指的是存储在内存中某些地址的数值<br>右值是不能对其进行赋值的表达式<br>也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边</p></blockquote></li></ol><p><strong>用途总结:</strong></p><ol><li>当需要保存数据的时候，需要lvalues</li><li>当需要读取数据的时候，需要rvalues</li></ol><ul><li>lvalues 和 rvalues 角色的相互转换<blockquote><p>根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为 rvalues<br>rvalues 永远不能转换为 lvalues</p></blockquote></li></ul><hr><p><strong>变量的全局变量与局部变量的概念简述:</strong></p><ul><li><p>全局变量就是在任何的函数外，整体的程序内所定义的变量，所以将会在整个程序内生效</p></li><li><p>而局部变量就是在函数内所声明的变量，所以只在函数内生效</p></li><li><p>在定义了全局变量后，在函数内调用该变量的方法:</p></li><li><p>为变量加上<code>extern</code>关键字即可跳过定义，直接使用:</p><blockquote><p><code>extern int a</code></p></blockquote></li></ul><hr><p><strong>全局变量和局部变量在内存中的区别</strong></p><ul><li><p>全局变量保存在内存的全局存储区中，占用静态的存储单元</p></li><li><p>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></li><li><p>C语言经过编译之后将内存分为以下几个区域：</p></li></ul><ol><li>栈(stack): 由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址<blockquote><p>操作方式类似数据结构中的栈</p></blockquote></li><li>堆(heap): 用于程序动态申请分配和释放空间<blockquote><p>C语言中的<code>malloc</code>和<code>free</code>，C++中的<code>new</code>和<code>delete</code>均是在堆中进行的<br>正常情况下，程序员申请的空间在使用结束后应该释放<br>若程序员没有释放空间，则程序结束时系统自动回收<br>注意: 这里的”堆”并不是数据结构中的”堆”</p></blockquote></li><li>全局(静态)存储区: 分为DATA段和BSS段<blockquote><p>DATA段(全局初始化区)存放初始化的全局变量和静态变量<br>BSS段(全局未初始化区)存放未初始化的全局变量和静态变量<br>程序运行结束时自动释放<br>其中BBS段在程序执行之前会被系统自动清0<br>所以未初始化的全局变量和静态变量在程序执行之前已经为0</p></blockquote></li><li>文字常量区: 存放常量字符串<blockquote><p>程序结束后由系统释放</p></blockquote></li><li>程序代码区: 存放程序的二进制代码。</li></ol><ul><li><p>所以C语言中的全局变量和局部变量在内存中是有区别的</p></li><li><p>C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中</p><blockquote><p>并且占用永久性的存储单元<br>局部变量，即自动变量，保存在栈中<br>只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元</p></blockquote></li><li><p>可以分析以下程序的运行结果，以便更直观的去了解其区别:</p><figure class="highlight perl"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> k1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k2;</span><br><span class="line">static <span class="keyword">int</span> k3 = <span class="number">2</span>;</span><br><span class="line">static <span class="keyword">int</span> k4;</span><br><span class="line"><span class="keyword">int</span> main( )</span><br><span class="line">&#123;  staticint m1=<span class="number">2</span>, m2;</span><br><span class="line">    inti=<span class="number">1</span>;</span><br><span class="line">    char*p;</span><br><span class="line">    charstr[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    char*<span class="keyword">q</span> = <span class="string">"hello"</span>;</span><br><span class="line">    p= (char *)malloc( <span class="number">100</span> );</span><br><span class="line">    free(p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"栈区-变量地址  i：%p\n"</span>, &amp;i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                p：%p\n"</span>, &amp;p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"              str：%p\n"</span>, str);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                q：%p\n"</span>, &amp;<span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"堆区地址-动态申请：%p\n"</span>, p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"全局外部有初值 k1：%p\n"</span>, &amp;k1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外部无初值 k2：%p\n"</span>, &amp;k2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"静态外部有初值 k3：%p\n"</span>, &amp;k3);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外静无初值 k4：%p\n"</span>, &amp;k4);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态有初值 m1：%p\n"</span>, &amp;m1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态无初值 m2：%p\n"</span>, &amp;m2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"文字常量地址    ：%p, %s\n"</span>,<span class="keyword">q</span>, <span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"程序区地址      ：%p\n"</span>,&amp;main);</span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h3><ul><li><p>这里对于存储类的说明只针对于变量</p></li><li><p>存储类定义 C 程序中变量或函数的范围(可见性)和生命周期</p><blockquote><p>所谓的声明周期与可见性(范围)就是指定变量在程序或函数内所生效的时间，或将其称之为在内存内所产生存在意义的阶段</p></blockquote></li><li><p>这些说明符放置在它们所修饰的类型之前</p><blockquote><p>例如 <code>auto int mouth</code></p></blockquote></li><li><p>C 程序中可用的存储类:</p><blockquote><p>auto<br>register<br>static<br>extern</p></blockquote></li></ul><p><strong>C内各存储类明细:</strong></p><p><strong>auto 存储类</strong></p><ul><li>auto 存储类是所有局部变量默认的存储类</li><li>auto 只能用在函数内，即 auto 只能修饰局部变量</li></ul><p><strong>register 存储类</strong></p><ul><li><p>register 存储类用于定义存储在寄存器中而不是RAM中的局部变量</p><blockquote><p>这意味着变量的最大尺寸等于寄存器的大小(通常是一个词)，且不能对它应用一元的<code>&#39;&amp;&#39;</code>运算符(因为它没有内存位置)</p></blockquote></li><li><p>存在意义</p><blockquote><p>在寄存器只用于需要快速访问的变量时进行使用，比如计数器<br>还应注意的是，定义<code>&#39;register&#39;</code>并不意味着变量将被存储在寄存器中<br>它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制</p></blockquote></li></ul><hr><p><strong>static 存储类</strong></p><ul><li>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁<blockquote><p>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></blockquote></li></ul><ul><li><p>static 修饰符也可以应用于全局变量</p><blockquote><p>当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内</p></blockquote></li><li><p>全局声明的一个 static 变量或方法可以被任何函数或方法调用</p><blockquote><p>只要这些方法出现在跟 static 变量或方法同一个文件中</p></blockquote></li><li><p>即在程序内的任何函数内对任何经由此声明的变量，不会在任何此调用时时进行重置</p></li></ul><p><strong>extern 存储类</strong></p><ul><li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的</li><li>即为当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置</li><li>当有多个文件且定义了一个可以在其它文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用</li><li>可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数</li><li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</li></ul><hr><p><strong>存储类整合说明:</strong></p><ul><li>auto 是局部变量的默认存储类, 限定变量只能在函数内部使用</li><li>register 代表了寄存器变量，不在内存中使用</li><li>static是全局变量的默认存储类,表示变量在程序生命周期内可见</li><li>extern 表示全局变量，即对程序内所有文件可见，类似于Java中的public关键字</li></ul><hr><p><strong>C 语言中全局变量，局部变量，静态全局变量，静态局部变量的区别</strong></p><p><strong>从作用域进行区分:</strong></p><ol><li><p>全局变量具有全局作用域</p><blockquote><p>全局变量只需在一个源文件中定义，就可以作用于所有的源文件<br>当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量</p></blockquote></li><li><p>静态局部变量具有局部作用域</p><blockquote><p>它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在<br>它和全局变量的区别在于全局变量对所有的函数都是可见的<br>而静态局部变量只对定义自己的函数体始终可见</p></blockquote></li><li><p>局部变量也只有局部作用域</p><blockquote><p>它是自动对象(auto)<br>它在程序运行期间不是一直存在，而是只在函数执行期间存在<br>函数的一次调用执行结束后，变量被撤销<br>其所占用的内存也被收回</p></blockquote></li><li><p>静态全局变量也具有全局作用域</p><blockquote><p>它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里<br>不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域<br>这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</p></blockquote></li></ol><p><strong>从分配内存空间来区分</strong></p><ol><li><p>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间</p><blockquote><p>而局部变量在栈里分配空间</p></blockquote></li><li><p>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式</p><blockquote><p>这两者在存储方式上并无不同<br>这两者的区别虽在于，非静态全局变量的作用域是整个源程序<br>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的<br>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效<br>在同一源程序的其它源文件中不能使用它<br>由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br>因此可以避免在其它源文件中引起错误</p></blockquote></li></ol><ul><li><p>静态变量会被放在程序的静态数据存储区(全局可见)中</p><blockquote><p>这样可以在下一次调用的时候还可以保持原来的赋值<br>这一点是它与堆栈变量和堆变量的区别</p></blockquote></li><li><p>变量用static告知编译器，自己仅仅在变量的作用范围内可见</p><blockquote><p>这一点是它与全局变量的区别</p></blockquote></li><li><p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期</p><blockquote><p>把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围<br>因此static 这个说明符在不同的地方所起的作用是不同的，应予以注意</p></blockquote></li></ul><p><strong>其它说明:</strong></p><ul><li>A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度</li><li>B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</li><li>C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见</li><li>D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为: 带”内部存储器”功能的的函数)</li><li>E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针</li></ul><hr><ul><li><p>其它的相关概念与具体的使用在以后实践时会进行相应的补充</p></li><li><p>C语言最大的优势是对于底层硬件结构的管理，其指针和其它缺省变量是最接近于内存的</p></li></ul><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>涉及概念</strong></p><ul><li>数据结构</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><p><strong>未涉及概念</strong></p><ul><li>常量</li><li>运算符</li><li>判断</li><li>循环</li></ul><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><hr><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><strong>C 作用域规则及其概念</strong></p><ul><li><p>所谓的变量作用域，就是变量所能够产生作用的代码块所属区域</p></li><li><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问</p></li><li><p>C 语言中有三个地方可以声明变量:</p></li></ul><ol><li>在函数或块内部的局部变量</li><li>在所有函数外部的全局变量</li><li>在形式参数的函数参数定义中</li></ol><ul><li>相关概念: 局部变量，全局变量和形式参数</li></ul><p><strong>局部变量</strong></p><ul><li>在某个函数或块的内部声明的变量称为局部变量<blockquote><p>它们只能被该函数或该代码块内部的语句使用<br>局部变量在函数外部是不可知的</p></blockquote></li></ul><p><strong>全局变量</strong></p><ul><li><p>全局变量是定义在函数外部，通常是在程序的顶部</p><blockquote><p>全局变量在整个程序生命周期内都是有效的<br>在任意的函数内部能访问全局变量</p></blockquote></li><li><p>全局变量可以被任何函数访问</p><blockquote><p>也就是说，全局变量在声明后整个程序中都是可用的</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li><p>函数的参数，形式参数，被当作该函数内的局部变量</p><blockquote><p>如果与全局变量同名它们会优先使用</p></blockquote></li><li><p>全局变量与局部变量在内存中的区别：</p><blockquote><p>全局变量保存在内存的全局存储区中，占用静态的存储单元<br>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></blockquote></li><li><p>通常使用static修饰符/关键字来定义全局/局部变量</p></li></ul><p><strong>初始化局部/全局变量</strong></p><ul><li>在定义全局或局部变量时需要先对其进行初始化<blockquote><p>初始化局部变量和全局变量<br>当局部变量被定义时，系统不会对其初始化，必须人为/自行的对其初始化<br>定义全局变量时，系统会自动对其初始化<br>初始化即为对其变量进行赋值</p></blockquote></li></ul><p><strong>全局变量自动初始化的值如下所示:</strong></p><table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">‘\0’</td></tr><tr><td align="left">float</td><td align="left">0</td></tr><tr><td align="left">double</td><td align="left">0</td></tr><tr><td align="left">pointer</td><td align="left">NULL</td></tr></tbody></table><ul><li>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果<blockquote><p>比如因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值</p></blockquote></li></ul><hr><h3 id="数据类型-派生类型-函数类型"><a href="#数据类型-派生类型-函数类型" class="headerlink" title="数据类型-派生类型/函数类型"></a>数据类型-派生类型/函数类型</h3><ul><li><p>函数的本质是存储结构化语句的数据类型</p></li><li><p>语句可以由变量或其它任何的数据类型构成</p></li><li><p>还可以说，任何的C程序都是由函数数据类型构成的</p></li><li><p>函数是一组一起执行一个任务的语句</p><blockquote><p>每个C程序都至少有一个函数，即主函数<code>main()</code><br>所有简单的程序都可以定义其他额外的函数<br>还可以把代码划分到不同的函数中<br>如何划分代码到不同的函数中是由人为所的<br>但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的</p></blockquote></li><li><p>函数声明告诉编译器函数的名称，返回类型和参数</p><blockquote><p>函数定义提供了函数的实际主体</p></blockquote></li><li><p>C 标准库提供了大量的程序可以调用的内置函数</p><blockquote><p>例如，函数<code>strcat()</code>用来连接两个字符串，函数<code>memcpy()</code>用来复制内存到另一个位置</p></blockquote></li><li><p>函数还有很多叫法，比如方法，子例程或程序，等等</p></li></ul><p><strong>定义函数的基本语法-C:</strong></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">return_type <span class="keyword">function</span><span class="constructor">_name( <span class="params">parameter</span> <span class="params">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body <span class="keyword">of</span> the <span class="keyword">function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li>在 C 语言中，函数由一个函数头和一个函数主体组成<blockquote><p>下面列出一个函数的所有组成部分:</p></blockquote></li></ul><ol><li>返回类型: 一个函数可以返回一个值<blockquote><p><code>return_type</code>是函数返回的值的数据类型<br>有些函数执行所需的操作而不返回值<br>在这种情况下，<code>return_type</code>是关键字<code>void</code></p></blockquote></li><li>函数名称: 这是函数的实际名称<blockquote><p>函数名和参数列表一起构成了函数签名</p></blockquote></li><li>参数: 参数就像是占位符<blockquote><p>当函数被调用时，您向参数传递一个值，这个值被称为实际参数<br>参数列表包括函数参数的类型，顺序，数量<br>参数是可选的，也就是说，函数可能不包含参数</p></blockquote></li><li>函数主体: 函数主体包含一组定义函数执行任务的语句</li></ol><hr><p><strong>函数声明</strong></p><ul><li><p>函数声明会告诉编译器函数名称及如何调用函数</p><blockquote><p>函数的实际主体可以单独定义</p></blockquote></li><li><p>函数声明包括以下几个部分：</p><blockquote><p><code>return_type function_name( parameter list );</code></p></blockquote></li><li><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的</p></li><li><p>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的</p><blockquote><p>在这种情况下，您应该在调用函数的文件顶部声明函数</p></blockquote></li></ul><hr><p><strong>调用函数</strong></p><ul><li><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务</p></li><li><p>当程序调用函数时，程序控制权会转移给被调用的函数</p><blockquote><p>被调用的函数执行已定义的任务，当函数的返回语句被执行时<br>或到达函数的结束括号时，会把程序控制权交还给主程序</p></blockquote></li><li><p>调用函数时，传递所需参数</p><blockquote><p>如果函数返回一个值，则可以存储返回值</p></blockquote></li></ul><hr><p><strong>函数参数</strong></p><ul><li><p>如果函数要使用参数，则必须声明接受参数值的变量</p><blockquote><p>这些变量称为函数的形式参数</p></blockquote></li><li><p>形式参数就像函数内的其他局部变量</p><blockquote><p>在进入函数时被创建，退出函数时被销毁</p></blockquote></li><li><p>当调用函数时，有两种向函数传递参数的方式：</p></li></ul><ol><li>传值调用: 该方法把参数的实际值复制给函数的形式参数<blockquote><p>在这种情况下，修改函数内的形式参数不会影响实际参数</p></blockquote></li><li>引用调用: 通过指针传递方式，形参为指向实参地址的指针<blockquote><p>当对形参的指向操作时，就相当于对实参本身进行的操作</p></blockquote></li></ol><ul><li>默认情况下，C 使用传值调用来传递参数<blockquote><p>一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数</p></blockquote></li></ul><hr><p><strong>内部函数与外部函数</strong></p><ul><li>根据函数能否被其他源文件调用，可以将函数区分为内部函数和外部函数</li></ul><p><strong>内部函数</strong></p><ul><li><p>如果一个函数只能被本文件中其他函数所调用，它称为内部函数</p><blockquote><p>在定义内部函数时，在函数名和函数类型的前面加 static，即<br><code>static 类型名 函数名 (形参表)</code><br>例如，函数的首行：<br><code>static int max(int a,int b)</code></p></blockquote></li><li><p>内部函数又称静态函数</p><blockquote><p>使用内部函数，可以使函数的作用域只局限于所在文件<br>即使在不同的文件中有同名的内部函数，也互不干扰<br>提高了程序的可靠性</p></blockquote></li></ul><p><strong>外部函数</strong></p><blockquote><p>如果在定义函数时，在函数的首部的最左端加关键字 extern<br>则此函数是外部函数，可供其它文件调用<br>如函数首部可以为<br><code>extern int max (int a,int b)</code><br>C 语言规定，如果在定义函数时省略 extern，则默认为外部函数</p></blockquote><ul><li>在需要调用此函数的其他文件中，需要对此函数作声明(即使在本文件中调用一个函数，也要用函数原型来声明)<blockquote><p>在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数</p></blockquote></li></ul><hr><p><strong>内联函数</strong></p><ul><li><p>内联函数是指用inline关键字修饰的函数</p><blockquote><p>在类内定义的函数被默认成内联函数<br>内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质</p></blockquote></li><li><p>内联扩展是用来消除函数调用时的时间开销</p><blockquote><p>它通常用于频繁执行的函数，对于小内存空间的函数非常受益</p></blockquote></li><li><p>使用内联函数的时候要注意:</p><blockquote><p>递归函数不能定义为内联函数<br>内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数<br>内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数<br>对内联函数不能进行异常的接口声明</p></blockquote></li></ul><hr><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><ul><li><p>形参与实参出现在函数中</p></li><li><p>形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用</p></li><li><p>实参出现在主调函数中，进入被调函数后，实参变量也不能使用</p></li></ul><p><strong>关于调用:</strong></p><ul><li><p>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元</p><blockquote><p>因此，形参只在函数内部有效<br>函数调用结束返回主调用函数后则不能再使用该形参变量</p></blockquote></li><li><p>实参可以是常量，变量，表达式，函数等</p><blockquote><p>无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参<br>因此应预先用赋值，输入等办法使参数获得确定值</p></blockquote></li></ul><p><strong>指针影响:</strong></p><ul><li>不是指针类型在内存中位置不同:</li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量<blockquote><p>它们在内存中位于不同的位置，形参将实参的内容复制一份<br>在该函数运行结束的时候形参被释放，而实参内容不会改变</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li>形式参数即为只是作为某种形式而存在于程序种的参数<blockquote><p>此类参数即为未进行赋值或者使用的参数</p></blockquote></li></ul><p><strong>实际参数</strong></p><ul><li><p>实际参数即为已经对其赋值或已经进行使用的参数</p></li><li><p>从字面上理解，所谓形式参数即只只是声明了一个作为参数的变量，并未直接进行赋值使用，而实际参数则相反</p></li><li><p>关于C语言形参与实参的区别:</p><blockquote><p>实参可以是变量，变量与表达式，实参与形参<br>实参与形参类型相同或赋值兼容<br>在调用函数过程中发生的实参与形参之间的数据传递，常称为”虚实结合”</p></blockquote></li></ul><ol><li>在定义函数中制定的形参，在没有出现函数调用时不占用内存中的存储单元<blockquote><p>在函数调用时才分配内存</p></blockquote></li><li>将实参的值传递给形参</li><li>在执行函数时，由于形参已经有值<blockquote><p>可以用形参进行运算</p></blockquote></li><li>通过return语句将函数值返回，若无返回值，则无return</li><li>调用结束后，形参被释放掉，实参保留原值(单向传值)</li></ol><hr><ul><li>可能还需要对其进行大量的补充，实践时会进行说明</li></ul><hr><ul><li>数据类型-派生类型/数组</li><li>数据类型-派生类型/指针</li><li>数据类型-派生类型/结构体类型</li><li>数据类型-派生类型/共用体类型</li><li>数据类型-派生类型/函数类型</li></ul><hr><h2 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h2><h3 id="数据类型-派生类型-数组"><a href="#数据类型-派生类型-数组" class="headerlink" title="数据类型-派生类型/数组"></a>数据类型-派生类型/数组</h3><ul><li><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合</p><blockquote><p>数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量</p></blockquote></li><li><p>数组用于存放相同类型的变量，还可以称其本质即为变量</p></li><li><p>声明一个数组，就相当于声明一个变量的集合，并且此集合内的变量通常为相同的类型</p><blockquote><p>比如声明一个number[100]，就相当于声明了100个名为number的变量<br>而这些变量用number[1],number[2],…,number[100]来进行标识，即数组中的特定元素可以通过索引来访问</p></blockquote></li><li><p>所有的数组都是由连续的内存位置组成的，其中最低的地址对应第一个元素，而最高的地址对应最后一个元素</p></li><li><p>数组于内存间的结构图片:</p></li></ul><hr><ul><li><p>声明数组的基本语法</p><blockquote><p>C 中要声明一个数组，需要指定数组内元素的类型和元素的数量<br><code>type arryName [ arraySize ];</code></p></blockquote></li><li><p>此语法所声明的数组被称之为一维数组，<code>arrySize</code>必须是一个大于零的整数常量</p><blockquote><p>而type可以是任何有效的C 数据类型<br>例如 <code>int serow[10];</code></p></blockquote></li><li><p>初始化数组(给数组进行赋值):</p><blockquote><p><code>type arryName [ arraySize ] = {进行线性赋值，用&#39;,&#39;分隔}</code><br><code>{}</code>之中值的数目不能超过<code>[]</code>间所定义的元素枢数目</p></blockquote></li><li><p>数组的赋值规则与物理内存地址的定义与赋值规则是完全线性的</p></li><li><p>访问数组内元素:</p></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> serow = unit[<span class="number">9</span>]; <span class="comment">//将数组unit中的第10个元素的值赋给serow变量</span></span><br></pre></td></tr></table></figure><hr><p><strong>至此</strong></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>无</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>变量-1</title>
    <url>/2020/03/09/%E5%8F%98%E9%87%8F-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>变量概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-变量"><a href="#计算机科学-变量" class="headerlink" title="计算机科学-变量"></a>计算机科学-变量</h2><ul><li>变量-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li><p>基本概念</p></li><li><p>概念整合</p></li><li><p>操作原理</p></li><li><p>标识原理</p></li><li><p>类型明细</p></li><li><p>内存分配</p></li><li><p>别名实现</p></li><li><p>参数明细</p></li><li><p>作用域与生命周期</p></li><li><p>线性表</p></li><li><p>数据结构-顺序存储结构</p></li><li><p>线性存储原理</p></li><li><p>堆栈</p></li></ul><hr><p><strong>任何数据类型与概念皆可称为变量，而变量也可以数据类型区分</strong></p><p><strong>函数结构化了变量，或称函数由变量构成</strong></p><hr><h2 id="变量概念明细"><a href="#变量概念明细" class="headerlink" title="变量概念明细:"></a>变量概念明细:</h2><ul><li>文字内关于变量的概念特指计算机科学内的变量概念</li><li>与数学间变量的概念会加以区分</li></ul><hr><p><strong>概述:</strong></p><ul><li>变量用于具体指向存储器内的存储空间的数据类型<blockquote><p>并且存储于变量内的数据是跟随程序的变化而变化的，这里类似于数学种变量的概念<br>每个不同的变量在计算机内所占有硬件的资源(存储空间或内存)都是有对应标识的(此标识概念被归纳于变量定义的概念内)</p></blockquote></li></ul><hr><p><strong>详细描述:</strong></p><ul><li>在计算机内，任何被人为定义的任何变量概念都是为了用于指向电脑内存储器的存储空间<blockquote><p>或称为，在计算机科学上，变量可以指在电脑存储器里存在值的被命名的存储空间</p></blockquote></li><li>变量所存储的内容被包含于变量的定义内，而变量名则是对于该变量所占用物理空间或称区域的命名与标识</li></ul><p><strong>语言区别:</strong></p><ul><li><p>各个程序语言之间对于变量的概念有不同的定义，但本质上都是相同的</p><blockquote><p>变量通常是可被修改的，即可以用来表示可变的状态<br>这是许多语言(如Java)的基本概念之一<br>有的语言可能定义其它术语，如C语言的左值来精确地表示这里的(可能匿名的)存储空间的概念<br>而”变量”则在变量名的意义上被强调<br>而还有些编程语言中的变量必须带有类型</p></blockquote></li><li><p>当某个已宣告变量开始使用，解释器或编译器通常会设置一个空间来存储所给出的值</p><blockquote><p>稍后该变量不再使用时，那些空间可以回收</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>也有观点认为，变量应该和数学的原意/义一致<blockquote><p>不需要允许它储存的值可变，不需要有能力表示可变状态<br>Haskell的类型变量仍然符合这个含义</p></blockquote></li></ul><hr><h2 id="概念理解整合"><a href="#概念理解整合" class="headerlink" title="概念理解整合"></a>概念理解整合</h2><ul><li>变量(Variable，scalar)</li></ul><p><strong>在程序设计中的变量所涉及的概念:</strong></p><ul><li>变量是指一个包含部分已知或未知数值或信息(即一个值)之/的存储地址<blockquote><p>以及相对应之符号名称(识别字)<br>通常使用变量名称引用存储值</p></blockquote></li></ul><p><strong>别名的意义(接上文识别字的概念):</strong></p><ul><li>用以将名称和内容分开，以能让被使用的名称独立于，所表示的精确消息之外</li><li>电脑源代码中的识别字能在运行期间绑扎一个值，且该变量的值可能在程序运行期间改变<blockquote><p>程序设计中的变量不一定能直接对应到数学中所谓的变量之概念<br>在程序设计中，变量的值不一定要为方程或数学公式之一部分</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>计算机变量与数学变量的区别:<blockquote><p>程序设计中的变量可使用在一段可重复的程序: 在一处赋值，然后使用于另一处，接着在一次赋值，且以相同方式再使用一次(涉及迭代概念)<br>程序设计中的变量通常会给定一个较长的名称，以描述其用途<br>而数学中的变量通常较为简洁，只给定一、两个字母，以方便抄写及操作</p></blockquote></li></ul><p><strong>别名简述:</strong></p><p><strong>变量别名/命名的概念:</strong></p><ul><li><p>一个变量的存储地址可以被不同的识别字所引用，这种情况称之为别名</p><blockquote><p>使用其中一个识别字为变量赋值，将会改变透过另一个识别字访问的值</p></blockquote></li><li><p>编译器必须将代表变量的名称替代成该数据所在的实际地址</p><blockquote><p>变量的名称，类型及地址通常会维持固定<br>但该地址所存储之数据于程序运行期间则可能会改变</p></blockquote></li></ul><hr><h2 id="变量各级操作的原理"><a href="#变量各级操作的原理" class="headerlink" title="变量各级操作的原理"></a>变量各级操作的原理</h2><h3 id="对于变量的使用"><a href="#对于变量的使用" class="headerlink" title="对于变量的使用:"></a>对于变量的使用:</h3><ul><li><p>又称引用变量</p><blockquote><p>涉及到标识符的概念</p></blockquote></li><li><p>标识符即为字符(人为输入的，用于识别所定义，或称所存在变量的字符串/数据类型)</p></li><li><p>用标识符引用变量能对变量进行访问，从而读出变量的值，改变变量的值</p><blockquote><p>或者改变变量的属性(如访问权限、状态锁定等)</p></blockquote></li><li><p>例如:</p><blockquote><p>一个变量用标识符<code>unit_serow</code>来引用<br>设定这个变量的值为1000<br>如果该变量同时也用<code>标识符g</code>来引用<br>然后通过<code>标识符g</code>将变量值改变为2000<br>那么读取<code>unit_serow</code>的值就是2000而不是1000</p></blockquote></li></ul><hr><ul><li><p>如果某种编程语言只允许同一个变量用一个标识符引用</p><blockquote><p>那么讨论”该变量的名字”就是有意义的，否则将其称之为”该变量的名字之一”</p></blockquote></li><li><p>例如:</p><blockquote><p>在前面的那个例子当中，<code>unit_serow</code>是这个变量的名字之一<br>而<code>标识符g</code>是这个变量的另外一个名字</p></blockquote></li></ul><hr><h3 id="对于变量的操作"><a href="#对于变量的操作" class="headerlink" title="对于变量的操作:"></a>对于变量的操作:</h3><ul><li><p>还可称为对于变量的管理</p></li><li><p>在指令式编程语言中</p><blockquote><p>变量的值通常能够随时访问或重新赋值</p></blockquote></li><li><p>但在逻辑式编程语言中</p><blockquote><p>根据参数透明的需求，变量被绑定到表达式并且在它的整个生命周期中保持同一个值</p></blockquote></li><li><p>在指令式编程语言中</p><blockquote><p>同样的行为用常量来表达，它和通常的变量存在反差</p></blockquote></li></ul><p><strong>不同语言的区别:</strong></p><ul><li>根据编程语言的类型系统的不同<blockquote><p>变量可能只存储一种特定的数据类型(如整型或字符串型)</p></blockquote></li><li>而另外一种情况，变量的数据类型能根据当前赋值而改变<blockquote><p>从而允许单个变量存储该编程语言支持的任何数据类型</p></blockquote></li></ul><hr><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li><p>变量所涉及的不同类型</p></li><li><p>在静态类型语言中</p><blockquote><p>如Java或ML等<br>每个都变量有一个类型，也就是说只有给定种类的值能存储到该变量中<br>一个基本类型的变量只能保存基本类型的值<br>一个类类型的变量能保存空值NULL，或者保存该类型或其子类型的对象<br>一个接口类型的变量能保存空值NULL，或者该接口的任何一个实现<br>一个数组类型能保存空值NULL或者一个数组</p></blockquote></li><li><p>在动态类型语言中</p><blockquote><p>如Python等<br>便是是作为值而出现的，而不是变量来携带类型信息<br>在Common Lisp中，这两种情况同时存在:<br>变量在编译时具有一个类型(如果没有声明，就假设这个类型为超类型T)<br>值也有具有一个类型，该类型可以在运行时进行检查和识别</p></blockquote></li><li><p>变量的类型也允许在编译时多态决定</p><blockquote><p>但是，这和面向对象的函数调用(在C++中称为虚函数)的多态不同</p></blockquote></li><li><p>变量常常保存简单的数据，如整数和字符串</p><blockquote><p>但有些程序设计语言允许变量同时表示多种数据类型<br>这些语言一般也允许函数参数多态<br>其函数对变量的操作可同时适用于多种数据类型</p></blockquote></li><li><p>例如:</p><blockquote><p><code>函数length</code>可以求一个列表的长度<br>如果length的类型签名中包含一个类型变量，就可以实现参数多态<br>这样，求列表中的元素个数就与列表元素的类型无关了</p></blockquote></li></ul><hr><h3 id="变量的参数概念"><a href="#变量的参数概念" class="headerlink" title="变量的参数概念"></a>变量的参数概念</h3><ul><li><p>函数的形式参数也被称为变量</p></li><li><p>如下的C++代码段：</p></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> AddTwo(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddTwo(<span class="number">5</span>);  <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure><ul><li>其中变量x是”形参”<blockquote><p>因为当函数被调用时会被给定一个值</p></blockquote></li><li>整数5是”实参”<blockquote><p>它给x一个值</p></blockquote></li><li>在多数语言中，函数参数具有局部的作用域<blockquote><p>这里的变量x只能在<code>AddTwo函数</code>中有效(尽管如此，其他函数也可以使用自己的变量x)</p></blockquote></li></ul><hr><h3 id="变量所对应的内存-底层概念"><a href="#变量所对应的内存-底层概念" class="headerlink" title="变量所对应的内存-底层概念"></a>变量所对应的内存-底层概念</h3><ul><li>线性存储结构(堆栈原理)示意图:<blockquote><p>线性表的顺序存储示意图</p></blockquote></li></ul><img src="/images/内存-1.png" width="40%" height="40%"><hr><ul><li><p>变量的内存分配</p></li><li><p>变量的内存空间分配和它们值的表示方法是多种多样的，这种区别体现在语言之间</p><blockquote><p>也体现在给定语言的内部使用上<br>很多语言都实现了局部变量的空间分配方式<br>局部变量保存在调用堆栈上，其生存周期维持在单个函数中，函数返回时这些内存会自动被回收(更一般的讲，变量的名字是和一些特定的连续内存块的地址绑定，对变量的操作其实是对相应的内存块进行操作)<br>对于巨大或者编译时不知道大小的数据，更常用的方法是使用”引用”<br>这时记录是值的地址而不是值本身，它们是从一种被称为栈的内存池中分配的</p></blockquote></li><li><p>绑定的变量具有值，一个抽象的值</p><blockquote><p>在程序执行时，变量的值用计算机内存中存储的一些数据对象来表示<br>程序，或者说运行时环境，必须为每个数据对象设置内存<br>由于内存是有限的<br>为了安置每一个数据对象，当数据对象不再表示某个变量的值时，相应的内存会被回收并重新使用</p></blockquote></li><li><p>在堆中分配的对象必须被释放掉，特别是当对象不再被需要时</p><blockquote><p>在具有垃圾回收机制的语言(如C#、Java和Lisp)中<br>当变量出了其作用域再也不能被引用时运行环境会自动地回收对象<br>在不具有垃圾回收机制的语言当中<br>如C语言，程序(程序员)必须显式地分配内存，而且用完之后还要释放内存<br>如果没有这样做会造成内存泄漏<br>在这种情况下，程序运行过程中堆会逐渐消耗，最终因为内存耗尽而崩溃</p></blockquote></li><li><p>当一个变量指向动态创建的数据结构时</p><blockquote><p>可能其中一些部分只能通过变量间接的访问<br>在这种环境下，垃圾回收器(或者类似的语言特性)必须处理当变量回收时只有一部分内存能够获得的情况</p></blockquote></li></ul><hr><h3 id="变量命名的原理"><a href="#变量命名的原理" class="headerlink" title="变量命名的原理"></a>变量命名的原理</h3><ul><li><p>即为变量的命名规范</p></li><li><p>与数学当中的量不同，程序设计所用的变量和常量通常都采用多字符的名字，如<code>count</code>或者<code>size</code></p><blockquote><p>而单个字符的名字一般仅用于辅助性的变量，如<code>i</code>，<code>j</code>，<code>k</code>常作为数组索引的变量</p></blockquote></li><li><p>一些命名规范是作为语法在语言层面强制执行的</p><blockquote><p>在大多数语言当中，变量名不能以数字开头，不能包含空格符<br>而标点符号是否允许存在在变量名当中就要视具体语言而定了<br>很多语言仅仅允许<code>下划线&#39;_&#39;</code>存在在变量名当中，而禁止其他所有的标点符号<br>而有些编程语言，特殊字符作为前缀或后缀添加在变量标识符当中来表明变量的类型<br>变量名的大小写敏感性也要视具体语言而定<br>大多数现代语言是大小写敏感的，一些较老的语言则不敏感<br>一些语言保留特定形式的变量名用来内部使用<br>在很多语言中，以两根下划线开头<code>__</code>的变量名常充当这种角色</p></blockquote></li><li><p>在语言语法基本的限制以外，进一步的命名风格规范也很有必要</p><blockquote><p>在机器码层面，是不会使用变量名的<br>所以计算机并不关心是否采用了准确的名字<br>正因为如此，变量名完全是作为程序员的工具而存在<br>借助这个工具程序员能更容易的编写和理解程序<br>程序员通常创建编码规范，并且坚持这些规范<br>帮助对变量命名甚至提供精确的命名规划。较短的名字便于输入<br>但是描述能力较差<br>较长的名字使程序更容易读懂，变量的意图更容易理解<br>尽管如此，冗长的变量名也可能会导致更难理解的代码</p></blockquote></li></ul><hr><p><strong>不同情况下命名规范的区别:</strong></p><ul><li><p>在源代码中</p><blockquote><p>在源代码中，变量名是将变量和内存地址绑定的一种方式<br>变量值以数据对象的形式存储在相应的地址内<br>这样该数据对象就能通过变量的名字进行访问和修改了</p></blockquote></li><li><p>在电子表格中</p><blockquote><p>在电子表格中，一个单元格可能包含参考其他单元格的公式<br>这种被参考的单元格就是一种形式的变量<br>它的值就是被参考的单元格的值</p></blockquote></li></ul><hr><h3 id="变量的作用域和生存周期"><a href="#变量的作用域和生存周期" class="headerlink" title="变量的作用域和生存周期"></a>变量的作用域和生存周期</h3><p><strong>变量作用于生存周期域的概念:</strong></p><ul><li><p>变量的作用域表示变量在原程序的文本中能被使用的范围</p><blockquote><p>变量的生存周期表示变量在程序运行过程中具有实际意义的值的时间范围<br>变量的作用域事实上是变量名字的性质<br>而变量的生存周期是变量本身是性质</p></blockquote></li><li><p>变量名字的作用域会影响它的生存周期</p></li><li><p>作用域是变量语法方面的性质</p><blockquote><p>多数语言对每一个变量(和其他名目实体)定义明确的作用域<br>这些作用域在同一个程序中可能不同<br>变量的作用域是指程序中的特定区域，在这些区域中，该变量的名字是有意义的并且变量是”可见的”<br>在进入作用域时，变量通常开始它的生命周期<br>而在离开作用域时，变量往往结束了它的生命周期</p></blockquote></li><li><p>例如:</p><blockquote><p>某个变量的语法作用域仅在特定的语句块或者子程序中<br>只有在某个函数中能访问的变量则被称为局部变量<br>在程序的任何一个地方都能引用的变量被称为全局变量</p></blockquote></li><li><p>生存周期，则是变量在运行时的性质</p><blockquote><p>在运行时，每次变量与值的绑定都具有自己的生存周期<br>绑定的生存周期是程序执行过程中的一段时间<br>在这段时间内，变量始终被关联到相同的值或者内存位置<br>在闭包的情况中，运行中的程序可能进入和离开某个生存周期很多次</p></blockquote></li><li><p>在一些代码段中，在一个变量的作用域中可能未被赋值，或者它的值已经被销毁掉了</p><blockquote><p>这类变量常被称为”生存周期外”或者”未绑定”<br>在很多语言中，试图使用未绑定的变量是一个错误<br>在其他语言中，这种行为会产生不可预期的结果，这样的变量可能被分配一个新的值<br>与之对照的是，一个变量绑定到一个超过他作用域的生存周期是被允许的<br>如Lisp的闭包和C语言的静态局部变量<br>当程序再次执行到变量的作用域时<br>变量能再次被使用，但还保持上一次的值</p></blockquote></li><li><p>为了提高空间效率，变量需要的存储空间可能要等到变量第一次使用时才申请</p><blockquote><p>不再使用后就删除<br>为了避免浪费空间，如果变量声明了但不实际使用<br>编译器通常会向程序员发出警告</p></blockquote></li><li><p>使变量的作用域尽可能的小，被认为是一个好的编程方式</p><blockquote><p>这样程序的不同部分就不会因为意外的改变对方的变量而互相影响了<br>实现上述目标的通常技术是让程序的不同部分使用不同名字空间<br>或者通过动态变量作用使用各自的私有变量</p></blockquote></li><li><p>很多程序设计语言使用保留的值(如NULL)表示没有初始化的变量</p></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下参考资料皆源于中文维基</strong></p><ul><li><p>CN-分类:变量(<a href="https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</a>)</p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</code></p></blockquote></li><li><p>CN-分类:计算机编程<a href="https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B</code></p></blockquote></li><li><p>CN-变量<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8</code></p></blockquote></li><li><p>CN-变量 (程序设计)<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)</code></p></blockquote></li></ul><hr><h2 id="补充内容-C-C"><a href="#补充内容-C-C" class="headerlink" title="补充内容-C/C++"></a>补充内容-C/C++</h2><ul><li>C/C++内变量的意义与应用<blockquote><p>见下一篇文章</p></blockquote></li></ul><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><ul><li><p>相对于编程语言(程序语言)</p></li><li><p>调用各种函数，利用正确的逻辑，来构成一个完整的程序</p></li></ul><p><strong>大体逻辑:</strong></p><ul><li><p>在函数外，也就是整个程序的内部可以定义各种常量</p><blockquote><p>然后定义各种函数，函数内定义各种变量，由变量构成各种语句<br>所谓的函数就是存储这些由变量构成的语句的区块(块结构)</p></blockquote></li><li><p>一个函数便可以称之为一个程序，或是一个功能</p><blockquote><p>之后再由若干个函数来构成一个完整的程序<br>每个函数中都应当有返回值</p></blockquote></li><li><p>所谓的常量，就是在程序当中，可以被任何函数所调用的数据类型</p></li><li><p>调用就是(即为)使用，函数就是方法，指针就是指针，用来指向某种数据类型(函数，变量等)并直接调用</p></li></ul><hr><ul><li>数据类型构建了变量与表达式</li><li>变量与表达式构建了函数</li><li>函数构建了各级功能</li><li>各级功能构建了完整的程序</li><li>其中在构建各个不同级次的程序时需要完整且正确的逻辑</li><li>在函数内的表达式与变量亦是如此</li><li>表达式，变量与函数都可以被合称为数据类型，包括指针或空值</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>无</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>NCRE-1</title>
    <url>/2020/03/08/NCRE-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>基础概念-数据结构与算法</strong></center><a id="more"></a><h2 id="NCRE-1"><a href="#NCRE-1" class="headerlink" title="NCRE-1"></a>NCRE-1</h2><hr><h3 id="公共基础知识-1"><a href="#公共基础知识-1" class="headerlink" title="公共基础知识-1"></a>公共基础知识-1</h3><ul><li><p>网课随堂笔记</p></li><li><p>二级公共基础知识-数据结构与算法</p></li></ul><hr><p><strong>数据结构与算法</strong></p><ul><li><p>包含内容于:</p><blockquote><p>算法复杂度<br>数据结构的概念<br>栈<br>二叉树的遍历<br>二分法查找</p></blockquote></li><li><p>涉及概念:</p><blockquote><p>算法的概念，算法时间复杂度及空间复杂度的概念<br>数据结构的定义，数据逻辑结构及物理结构的定义<br>栈的定义及其运算，线性链表的存储方式<br>树与二叉树的概念，二叉树的基本性质，完全二叉树的概念，二叉树的遍历<br>二分查找法<br>冒泡排序法</p></blockquote></li></ul><p>–</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h3><ul><li><p>计算机解题的过程实际上是在实施某种算法，这种算法称为计算机算法</p></li><li><p>算法即为为解决任何问题而产生出的必要方法，语言，思维或逻辑的本质也可称为算法</p></li><li><p>算法的基本特征：可行性，确定性，有穷性，拥有足够的情报</p></li></ul><p><strong>算法的基本要素:</strong></p><ol><li>算法中对数据的运算和操作</li></ol><ul><li><p>一个算法由两种基本要素组成：</p><blockquote><p>一是对数据对象的运算和操作<br>二是算法的控制结构</p></blockquote></li><li><p>在一般的计算机系统中，基本的运算和操作有以此四类：算术运算，逻辑运算，关系运算和数据传输</p></li></ul><ol start="2"><li>算法的控制结构：<blockquote><p>算法中各操作之间的执行顺序称为算法的控制结构</p></blockquote></li></ol><ul><li><p>描述算法的工具通常有：</p><blockquote><p>传统的流程图，N-S结构化流程图，算法描述语言等</p></blockquote></li><li><p>一个算法一般都可以用顺序，选择，循环3种基本控制结构组合而成</p></li></ul><hr><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>算法复杂度包括算法时间复杂度及空间复杂度的概念</li></ul><ol><li>算法的时间复杂度<blockquote><p>算法的时间复杂度是指执行算法所需要的计算工作量<br>同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行，效率均不同<br>这表明使用绝对的时间单位衡量算法的效率是不合适的<br>撇开这些与计算机硬件，软件有关的因素，可以认为一个特定算法”运行工作量”的大小，只依赖于问题的规模(通常用整数n表示)，它是问题规模的函数<br>即为<br><code>算法的工作量=f(n)</code></p></blockquote></li></ol><p>2.算法的空间复杂度</p><blockquote><p>算法的空间复杂度是指执行这个算法所需要的内存空间<br>一个算法所占用的存储空间包括算法程序所占的空间<br>输入的初始数据所占的存储空间以及算法执行过程中所需要的额外空间<br>其中额外空间包括算法程序执行过程中的工作单元以及某种数据结构所需要的附加存储空间<br>如果额外空间量相对于问题规模来说是常数，则称该算法是原地工作的<br>在许多实际问题中，为了减少算法所占的存储空间，通常采用压缩存储技术，以便尽量减少不必要的额外空间</p></blockquote><ul><li>算法的工作量用算法所执行的基本运算次数来计算，而算法所执行的基本运算次数是问题规模的函数，即算法的工作量=f(n)<blockquote><p>n为问题规模</p></blockquote></li></ul><hr><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><ul><li><p>数据的逻辑结构和存储结构的概念</p></li><li><p>数据结构作为计算机的一门学科，主要研究和讨论以下三个方面：</p></li></ul><ol><li>数据集合中个数据元素之间所固有的逻辑关系，即数据的逻辑结构</li><li>在对数据元素进行处理时，各数据元素在计算机中的存储关系，即数据的存储结构</li><li>对各种数据结构进行的运算</li></ol><ul><li><p>数据结构基本概念：</p><blockquote><p>数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称<br>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理<br>数据对象：是性质相同的数据元素的集合，是数据的一个子集</p></blockquote></li><li><p>数据的逻辑结构是对数据元素之间的逻辑关系的描述</p><blockquote><p>它可以用一个数据元素的集合和定义在此集合中的若干关系来表示<br>数据的逻辑结构有两个要素：<br>一是数据元素的集合，通常记为D<br>二是D上的关系，它反映了数据元素之间的前后件关系，通常记为R</p></blockquote></li><li><p>一个数据结构可以表示成：<code>B=(D,R)</code></p><blockquote><p>其中B表示数据结构<br>为了反映D中各数据元素之间的前后件关系，一般用二元组来表示</p></blockquote></li><li><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构(也称数据的物理结构)</p></li><li><p>由于数据元素在计算机存储空间中的位置关系可能与逻辑关系不同</p><blockquote><p>因此，为了表示存放在计算机存储空间中的各数据元素之间的逻辑关系(即前后件关系)<br>在数据的存储结构中，不仅要存放各数据元素的信息，还需要存放各数据元素之间的前后件关系的信息</p></blockquote></li><li><p>一种数据的逻辑结构根据需要可以表示成多种存储结构</p><blockquote><p>常用的存储结构有顺序，链接，索引等存储结构<br>而采用不同的存储结构，其数据处理的效率是不同的<br>因此，在进行数据处理时，选择合适的存储结构是很重要的</p></blockquote></li></ul><hr><h3 id="线性结构与非线性结构"><a href="#线性结构与非线性结构" class="headerlink" title="线性结构与非线性结构"></a>线性结构与非线性结构</h3><ul><li><p>根据数据结构中各数据元素之间前后件关系的复杂程度</p><blockquote><p>一般将数据结构分为两大类型：线性结构与非线性结构</p></blockquote></li><li><p>如果一个非空的数据结构满足下列两个条件：</p></li></ul><ol><li>有且只有一个根结点</li><li>每一个结点最多有一个前件，也最多有一个后件<blockquote><p>则称该数据结构为线性结构<br>线性结构又称线性表<br>在一个线性结构中插入或删除任何一个结点后还应是线性结构<br>如果一个数据结构不是线性结构，则称之为非线性结构</p></blockquote></li></ol><ul><li>空的数据结构被归于线性结构还是非线性结构的条件:<blockquote><p>一个空的数据结构究竟是属于线性结构还是属于非线性结构，这要根据具体情况来确定<br>如果对该数据结构的算法是按线性结构的规则来处理的，则属于线性结构<br>否则属于非线性结构</p></blockquote></li></ul><hr><h2 id="栈及线性链表"><a href="#栈及线性链表" class="headerlink" title="栈及线性链表"></a>栈及线性链表</h2><h3 id="栈及其基本运算"><a href="#栈及其基本运算" class="headerlink" title="栈及其基本运算"></a>栈及其基本运算</h3><ul><li>涉及栈的运算</li></ul><ol><li>栈的基本概念<blockquote><p>栈是限定只在一端进行插入与删除的线性表，通常称插入，删除的这一端为栈顶，另一端为栈底<br>当表中没有元素时称为空栈<br>栈顶元素总是后被插入的元素，从而也是最先被删除的元素<br>栈底元素总是最先被插入的元素，从而也是最后才能被删除的元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据的</li></ul><ol start="2"><li>栈的顺序存储及其运算</li></ol><ul><li>用一维数组<code>S(1 : m)</code>作为栈的顺序存储空间，其中m为最大容量<blockquote><p>在栈的顺序存储空间S<code>(1∶m)</code>中<br><code>S(bottom)</code>为栈底元素，<code>S(top)</code>为栈顶元素<br><code>top=0</code>表示栈空<br><code>top=m</code>表示栈满</p></blockquote></li></ul><p><strong>栈的基本运算</strong></p><ul><li>可将其归纳为三种: 入栈，退栈与读栈顶元素</li></ul><ol><li><p>入栈运算：入栈运算是指在栈顶位置插入一个新元素</p><blockquote><p>首先将栈顶指针加一(即top加1)，然后将新元素插入到栈顶指针指向的位置<br>当栈顶指针已经指向存储空间的最后一个位置时，说明栈空间已满，不可能再进行入栈操作<br>这种情况称为栈”上溢”错误</p></blockquote></li><li><p>退栈运算：退栈是指取出栈顶元素并赋给一个指定的变量</p><blockquote><p>首先将栈顶元素(栈顶指针指向的元素)赋给一个指定的变量，然后将栈顶指针减一(即top减1)<br>当栈顶指针为0时，说明栈空，不可进行退栈操作<br>这种情况称为栈的”下溢”错误</p></blockquote></li><li><p>读栈顶元素：读栈顶元素是指将栈顶元素赋给一个指定的变量</p><blockquote><p>这个运算不删除栈顶元素，只是将它赋给一个变量，因此栈顶指针不会改变<br>当栈顶指针为0时，说明栈空，读不到栈顶元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据，但是出栈方式有多种选择</li></ul><hr><h3 id="线性链表的基本概念"><a href="#线性链表的基本概念" class="headerlink" title="线性链表的基本概念"></a>线性链表的基本概念</h3><ul><li><p>涉及结点的组成</p></li><li><p>在链式存储方式中，要求每个结点由两部分组成：</p><blockquote><p>一部分用于存放数据元素值，称为数据域<br>另一部分用于存放指针，称为指针域<br>其中指针用于指向该结点的前一个或后一个结点(即前件或后件)</p></blockquote></li><li><p>链式存储方式既可用于表示线性结构，也可用于表示非线性结构</p></li></ul><p><strong>线性链表</strong></p><ul><li>线性表的链式存储结构称为线性链表<blockquote><p>在某些应用中，对线性链表中的每个结点设置两个指针<br>一个称为左指针，用以指向其前件结点<br>另一个称为右指针，用以指向其后件结点<br>这样的表称为双向链表</p></blockquote></li></ul><p><strong>带链的栈</strong></p><ul><li><p>栈也是线性表，也可以采用链式存储结构</p><blockquote><p>带链的栈可以用来收集计算机存储空间中所有空闲的存储结点<br>这种带链的栈称为可利用栈</p></blockquote></li><li><p>在链式结构中，存储空间位置关系与逻辑关系:</p><blockquote><p>在链式存储结构中，存储数据结构的存储空间可以不连续<br>各数据结点的存储顺序与数据元素之间的逻辑关系可以不一致<br>而数据元素之间的逻辑关系是由指针域来确定的</p></blockquote></li></ul><hr><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树与二叉树及其基本性质"><a href="#树与二叉树及其基本性质" class="headerlink" title="树与二叉树及其基本性质"></a>树与二叉树及其基本性质</h3><ul><li><p>涉及树及二叉树的性质</p></li><li><p>误区警示: 满二叉树也是完全二叉树，而完全二叉树一般不是满二叉树</p></li><li><p>结构示意图:</p></li></ul><img src="/images/二叉树-1.png" width="40%" height="40%"> <img src="/images/二叉树-2.png" width="40%" height="40%"><hr><p><strong>树的基本概念</strong></p><ul><li>树(tree)是一种简单的非线性结构<blockquote><p>在树结构中，每一个结点只有一个前件，称为父结点<br>没有前件的结点只有一个，称为树的根结点<br>每一个结点可以有多个后件，它们称为该结点的子结点<br>没有后件的结点称为叶子结点</p></blockquote></li></ul><ul><li>在树结构中，一个结点所拥有的后件个数称为该结点的度<blockquote><p>叶子结点的度为0<br>在树中，所有结点中的最大的度称为树的度</p></blockquote></li></ul><p><strong>二叉树的定义及其基本性质</strong></p><p><strong>二叉树的定义</strong></p><ul><li><p>二叉树是一种很有用的非线性结构</p></li><li><p>具有以下两个特点:</p><blockquote><p>1-非空二叉树只有一个根结点<br>2-每一个结点最多有两棵子树，且分别称为该结点的左子树和右子树</p></blockquote></li><li><p>由以上特点可以看出:</p><blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树（左子树或右子树）也均为二叉树<br>而树结构中的每一个结点的度可以是任意的<br>另外，二叉树中的每个结点的子树被明显地分为左子树和右子树</p></blockquote></li><li><p>在二叉树中，一个结点可以只有左子树而没有右子树</p><blockquote><p>也可以只有右子树而没有左子树<br>当一个结点既没有左子树也没有右子树时，该结点即为叶子结点</p></blockquote></li></ul><hr><p><strong>二叉树的基本性质</strong></p><ul><li><p>二叉树具有以下几个性质：</p><blockquote><p>性质1：在二叉树的第k层上，最多有<code>2k-1 (k≥1)</code>个结点<br>性质2：深度为m的二叉树最多有<code>2m-1</code>个结点<br>性质3：在任意一棵二叉树中，度为0的结点(即叶子结点)总是比度为2的结点多一个<br>性质4：具有n个结点的二叉树，其深度至少为<code>[log2n]+1</code><br>其中[log2n]表示取log2n的整数部分<br>因为文本无法输入下标，所以本文中所有log2n都用于表示已2为底n的对数</p></blockquote></li><li><p>在二叉树的遍历中，无论是前序遍历，中序遍历还是后序遍历，二叉树的叶子结点的先后顺序都是不变的</p></li></ul><hr><p><strong>满二叉树与完全二叉树</strong></p><p><strong>满二叉树</strong></p><ul><li><p>满二叉树是指这样的一种二叉树:</p><blockquote><p>除最后一层外，每一层上的所有结点都有两个子结点<br>在满二叉树中，每一层上的结点数都达到最大值<br>即在满二叉树的第k层上有<code>2k-1</code>个结点，且深度为m的满二叉树有<code>2m-1</code>个结点</p></blockquote></li><li><p>完全二叉树是指这样的二叉树:</p><blockquote><p>除最后一层外，每一层上的结点数均达到最大值<br>在最后一层上只缺少右边的若干结点</p></blockquote></li><li><p>对于完全二叉树来说，叶子结点只可能在层次最大的两层上出现：</p><blockquote><p>对于任何一个结点，若其右分支下的子孙结点的最大层次为p<br>则其左分支下的子孙结点的最大层次或为p，或为<code>p+1</code></p></blockquote></li></ul><p><strong>完全二叉树</strong></p><ul><li><p>完全二叉树具有以下两个性质(接上文二叉树的基本性质):</p><blockquote><p>性质5: 具有n个结点的完全二叉树的深度为`[log2n]+1</p></blockquote></li><li><p>性质6: 设完全二叉树共有n个结点</p><blockquote><p>如果从根结点开始，按层次(每一层从左到右)用自然数<code>1，2，……，n</code>给结点进行编号<br>则对于编号为k（k=1，2，……，n）的结点有以下结论:<br>1-若<code>k=1</code>，则该结点为根结点，它没有父结点<br>若<code>k&gt;1</code>，则该结点的父结点编号为<code>INT(k/2) 2-若</code>2k≤n<code>，则编号为k的结点的左子结点编号为2k 否则该结点无左子结点(显然也没有右子结点) 3-若</code>2k+1≤n<code>，则编号为k的结点的右子结点编号为</code>2k+1`<br>否则该结点无右子结点</p></blockquote></li></ul><hr><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>涉及遍历的具体算法，以及能由两种遍历的结果推导另一种遍历的结果</p></li><li><p>在遍历二叉树的过程中，一般先遍历左子树，再遍历右子树</p></li><li><p>在先左后右的原则下，根据访问根结点的次序，二叉树的遍历分为三类:</p><blockquote><p>前序遍历，中序遍历和后序遍历</p></blockquote></li></ul><ol><li><p>前序遍历：先访问根结点、然后遍历左子树，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先访问根结点<br>然后遍历左子树，最后遍历右子树</p></blockquote></li><li><p>中序遍历：先遍历左子树、然后访问根结点，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后访问根结点，最后遍历右子树</p></blockquote></li><li><p>后序遍历：先遍历左子树，然后遍历右子树，最后访问根结点</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后遍历右子树，最后访问根结点</p></blockquote></li></ol><ul><li>树与二叉树的不同之处<blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树(左子树或右子树)也均为二叉树<br>而树结构中的每一个结点的度可以是任意的</p></blockquote></li></ul><hr><h2 id="查找技术"><a href="#查找技术" class="headerlink" title="查找技术"></a>查找技术</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><ul><li><p>涉及顺序查找的算法</p></li><li><p>查找是指在一个给定的数据结构中查找某个指定的元素</p><blockquote><p>从线性表的第一个元素开始，依次将线性表中的元素与被查找的元素相比较<br>若相等则表示查找成功<br>若线性表中所有的元素都与被查找元素进行了比较但都不相等<br>则表示查找失败</p></blockquote></li><li><p>在下列两种情况下也只能采用顺序查找：</p></li></ul><ol><li>如果线性表为无序表，则不管是顺序存储结构还是链式存储结构，只能用顺序查找</li><li>即使是有序线性表，如果采用链式存储结构，也只能用顺序查找</li></ol><hr><h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><ul><li><p>涉及二分查找法的算法</p></li><li><p>二分法只适用于顺序存储的，按非递减排列的有序表，其方法如下：</p><blockquote><p>设有序线性表的长度为n，被查找的元素为i<br>1-将i与线性表的中间项进行比较<br>2-若i与中间项的值相等，则查找成功<br>3-若i小于中间项，则在线性表的前半部分以相同的方法查找<br>4-若i大于中间项，则在线性表的后半部分以相同的方法查找</p></blockquote></li><li><p>二分查找法适用情况</p><blockquote><p>二分查找法只适用于顺序存储的有序表<br>在此所说的有序表是指线性表中的元素按值非递减排列(即从小到大，但允许相邻元素值相等)<br>这个过程一直进行到查找成功或子表长度为0为止<br>对于长度为n的有序线性表，在最坏情况下，二分查找只需要比较<code>log2n</code>次</p></blockquote></li></ul><hr><h3 id="排序技术"><a href="#排序技术" class="headerlink" title="排序技术"></a>排序技术</h3><ul><li><p>交换类排序法</p></li><li><p>涉及排序算法的基本过程</p></li><li><p>冒泡排序法和快速排序法都属于交换类排序法</p></li></ul><p><strong>冒泡排序法</strong></p><ol><li><p>首先，从表头开始往后扫描线性表，逐次比较相邻两个元素的大小</p><blockquote><p>若前面的元素大于后面的元素，则将它们互换，不断地将两个相邻元素中的大者往后移动<br>最后最大者到了线性表的最后</p></blockquote></li><li><p>然后，从后到前扫描剩下的线性表，逐次比较相邻两个元素的大小，若后面的元素小于前面的元素，则将它们互换</p><blockquote><p>不断地将两个相邻元素中的小者往前移动<br>最后最小者到了线性表的最前面</p></blockquote></li><li><p>对剩下的线性表重复上述过程，直到剩下的线性表变空为止，此时已经排好序</p><blockquote><p>在最坏的情况下，冒泡排序需要比较次数为<code>n(n－1)/2</code>次</p></blockquote></li></ol><p><strong>快速排序法</strong></p><ul><li><p>它的基本思想是：</p><blockquote><p>任取待排序序列中的某个元素作为基准(一般取第一个元素)<br>通过一趟排序，将待排元素分为左右两个子序列<br>左子序列元素的排序码均小于或等于基准元素的排序码<br>右子序列的排序码则大于基准元素的排序码<br>然后分别对两个子序列继续进行排序<br>直至整个序列有序。</p></blockquote></li><li><p>冒泡排序和快速排序的平均执行时间:</p><blockquote><p>冒泡排序法的平均执行时间是O(n2)<br>而快速排序法的平均执行时间是O(nlog2n)</p></blockquote></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下内容参考自中文维基:</strong></p><ul><li><p>CN-具体数学<a href="https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8</code></p></blockquote></li><li><p>CN-线性代数<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0</code></p></blockquote></li><li><p>CN-离散数学<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6</code></p></blockquote></li><li><p>CN-概率论<a href="https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA</code></p></blockquote></li><li><p>CN-二分查找算法<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-算法分析<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90</code></p></blockquote></li><li><p>CN-排序算法<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-数据结构<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</code></p></blockquote></li><li><p>CN-二叉树<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li><li><p>CN-Category:Binary trees<a href="https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn</code></p></blockquote></li><li><p>CN-分类-二叉树<a href="https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li></ul><p><strong>以下为已使用电子书籍资源:</strong></p><ul><li><p>全国计算机二级考试公共基础知识完整版整合</p></li><li><p>计算机二级公共基础知识完整</p></li><li><p>二级公共基础知识电子书</p></li><li><p>公共基础知识总和本(无密)</p></li><li><p>资源获取-百度网盘(永久链接)<a href="https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w" target="_blank" rel="noopener">跳转</a></p><blockquote><p>链接: <code>https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w</code><br>提取码: aynj</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>无</category>
        <category>concept</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>MS-SQL-1</title>
    <url>/2020/03/07/MS-SQL-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>Access/MS SQL基本概念归纳</strong></center><a id="more"></a><h2 id="MS-SQL-1"><a href="#MS-SQL-1" class="headerlink" title="MS SQL-1"></a>MS SQL-1</h2><ul><li><p>网课随堂笔记</p></li><li><p>Access</p></li><li><p>MS SQL</p></li><li><p>数据库基础概念相关知识(数据抽象/数据模型/关系模型/各级关系运算)</p></li></ul><hr><h3 id="1-数据抽象"><a href="#1-数据抽象" class="headerlink" title="1. 数据抽象"></a>1. 数据抽象</h3><ul><li>设计数据库就是对数据的抽象过程:<blockquote><p><code>用户需求-抽象-&gt;概念模型-转换-&gt;[逻辑数据模型(外部模型)]-&gt;物理模型-&gt;数据库</code></p></blockquote></li><li>物理模型用于实现在数据库中对数据的存储</li><li>设计数据库的主要工作是构造数据模型</li><li>数据模型是对现实世界中数据特征的抽象</li><li>数据抽象中的数据模型主要有四种</li><li>概念模型 实体联系模型，可用于表达用户需求观点的数据全局逻辑结构的模型</li><li>ER图表示，ER图通常需要进行优化<blockquote><p><code>局部概念模型-&gt;全局概念模型</code></p></blockquote></li><li>ER图通常十分直观且形象</li></ul><hr><ul><li>逻辑模型<blockquote><p>用于表达计算机实现观点的数据库全局逻辑结构的模型<br>以树结构组织数据被称为层次模型<br>以网状结构组织数据称为网状模型<br>以二维表组织数据称之为关系模型(通常为主流数据模型)<br>ER图转化为逻辑模型<br>一对多，多对多，一对一，数据结构中存在几个实体对象，就将之称为几元联系<br>关系模式-(关系名-&gt;属性名)</p></blockquote></li><li>所有实体对象的集合被称之为关系</li></ul><hr><ul><li>内部模型<blockquote><p>即为物理模型<br>是用于表达数据库物理结构的数据库全局模型<br>以概念模型为基础，而转换处物理模型(内部模型)<br>有了物理模型，即可以在数据库中建立与之相对应的表结构</p></blockquote></li></ul><hr><ul><li>外部模型<blockquote><p>是用于表达用户使用观点的数据库局部逻辑结构的模型<br><code>[逻辑模型(若干外部模型)]</code><br>数据抽象过程</p></blockquote></li></ul><hr><ul><li><p>关系模型</p><blockquote><p>数据模型是一种严格定义的概念模型<br>关系模型精准的定义了数据结构，以及表与表之间可能发生的各种数据操作与管理，包括数据完整性操作<br>关系模型是以二维表的形式来组织数据<br>支持关系模型的数据库即为关系数据库<br>它使用若干个数据表来存储数据，此间可将一张二维表称之为关系<br>而关系的集合即为关系数据库</p></blockquote></li><li><p>关系模型的有关概念</p><blockquote><p>元组:表中的行，或称为记录<br>属性:表中的列，或称为字段与数据项<br>域:属性的取值范围<br>分量:一个属性的值<br>码:表中某个属性或属性组唯一标识一个元组<br>比如在一个表内，ID字符标识了所在行的整个元组，则称ID为码，即为关系模式约束<br><code>概念模型-&gt;逻辑模型-&gt;物理模型(内部模型)</code></p></blockquote></li><li><p>同种类型的实体集合被称之为实体型</p></li><li><p>在逻辑模型中所设计的一切概念，都被称之为关系模式</p><blockquote><p>关系模式由关系名及其属性的集合构成<br>在逻辑模型中将其称之为关系</p></blockquote></li><li><p>在内部模型中，也就是表结构，实体集为同一类型的表所属的数据集合</p><blockquote><p>在关系模型中将其称之为表</p></blockquote></li><li><p>为何把表称之为关系</p><blockquote><p>数学上把一系列域上的笛卡尔积的子集称为关系<br>而表正符合此定义</p></blockquote></li><li><p>域是一组具有相同类型的值的集合</p><blockquote><p>比如: 整型，实型或指定长度的字符串集合<br>而关系中属性的域可以被理解为属性的取值范围<br>比如学生中的性别属性，它的域就是男与女两个字符串</p></blockquote></li><li><p>笛卡尔积</p><blockquote><p>所有域的所有取值的任意集合<br>在数学中，以乘号来描述此概念<br>即<code>A*B={(x,y)|x∈A^y∈B}</code></p></blockquote></li><li><p>设集<code>A={a,b}</code>，集<code>B={0,1,2}</code></p><blockquote><p>即A的两个值乘以B的三个值<br>则两个集合的笛卡尔积为<code>{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}</code><br>如果A表示某学校学生的集合，B表示改学校所有课程的集合<br>则A与B的笛卡尔积可以用于表示所有的选课情况<br>A如果表示声母集合，B如果表示所有的声母集合，则A与B的笛卡尔积则可表示所有汉字的读音组合</p></blockquote></li><li><p>笛卡尔积并不都是有意义的</p><blockquote><p>设集<code>A={01,02}</code>,集<code>B={张三,李四}</code><br>则两个集合的笛卡尔积为<code>{(01,张三),(01,李四),(02,张三),(02,李四)}</code><br>如果A代表学号，B代表姓名，假设张三的学号是一号，而李四是二号<br>所以该笛卡尔积的结果集中，01的李四与02的张三是没有意义的</p></blockquote></li><li><p>数学上将一系列域上的笛卡尔积的子集称之为关系</p></li><li><p>而笛卡尔积中具有意义的那些元组则才被称之为关系</p></li><li><p>不是所有的二维表都是关系，关系是有以下特性的:</p><blockquote><p>关系必须规范化，比如: 每个表有多行，每个行有多列，每个行列单元都是不能再分的原子值<br>在同一关系中不允许出现相同的属性名<br>而关系中不允许有完全相同的元组<br>并且同一关系中元组及其属性的顺序可以随意</p></blockquote></li><li><p>严格的去定义表的具体规则与基本要求</p></li></ul><hr><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul><li><p>关系操作与数据查询操作可以用关系代数与关系逻辑的方法描述</p></li><li><p>或用具体的数据库语言，如SQL-结构化查询语言来描述与实现</p></li><li><p>最基本的方法是代数方法，即关系代数</p><blockquote><p><code>关系A&lt;-运算集合-&gt;关系B=关系C</code><br>代数是数学概念，同时关系代数也同为数学概念<br>运算符包括一系列运算集合<br>两个不同的关系通过一个运算符的运算来获得一个新的关系结果</p></blockquote></li><li><p>关系运算的运算符有两类，即为集合运算符和专门的关系运算符</p></li><li><p>选择运算</p><blockquote><p>选择运算是从关系中找出满足条件的元组的元组的操作<br>将其记为: <code>σ[(下标)&lt;条件表达式&gt;] (R)</code><br>用处于右下角的谓词来写条件表达式<br>其中，σ是选择运算符，R是关系名</p></blockquote></li><li><p>选择运算是根据给定的条件选择关系R中的若干元组而组成的新关系，是对关系的元组进行筛选</p><blockquote><p>结果关系与原关系有着相同的模式<br>可以将其表示为: <code>σ[(下标)sex]=R(tables_name)</code><br>在<code>tables_name</code>表中，找出sex字段等于R的所有记录<br>所以选择运算是对于行的操作</p></blockquote></li></ul><hr><p><strong>投影运算</strong></p><ul><li><p>投影运算是从关系中选取若干属性组成新的关系</p></li><li><p>投影运算是从列的角度进行计算，相当于对关系进行垂直分解</p></li><li><p>投影运算符用π来表示</p><blockquote><p><code>π[(下标)A] (R)</code><br>A用于表示投影属性或属性组，R是关系名</p></blockquote></li><li><p>例子: <code>π[(下标)A], π[(下标)A1](R)</code></p><blockquote><p>在R表中对A与A1两个字段进行投影，形成新的关系，同时去掉结果关系中重复的元组</p></blockquote></li><li><p>关系代数是把表看作元组集合的关系，既然是集合就不包括重复元组</p></li><li><p>也就是说，关系代数的每个运算都是去重复的</p></li></ul><hr><p><strong>并运算</strong></p><ul><li><p>并运算属于集合运算</p><blockquote><p>集合运算的两个关系必须拥有相同的关系模式，即相同的结构<br>两个关系包含属性的个数一致<br>两个关系对应属性的域应该相同或包容</p></blockquote></li><li><p>两个已知关系R和S的并将产生一个包含R，S中所有不同元组的新关系</p><blockquote><p>将其记为: <code>R∪S</code><br>则为R并S，因此并运算可以将其理解为现实中的或者</p></blockquote></li><li><p>两个已知关系R和S的交，是属于R而且也属于S的元组组成的新关系</p><blockquote><p>将其极为: <code>R∩S</code></p></blockquote></li><li><p>实例:</p><blockquote><p>设有两张不同的表<code>tables_A</code>与<code>tables_B</code>，并且设这两个表中分别有字段a，b，c，d，其值分别为拥有4行分别1，2，3，4的矩阵数列<br>首先找表<code>tables_A</code>中的a字段，即为:<br>先在<code>tables_A</code>表中进行选择运算，寻找的条件是a字段等于1，即为找出所有a等于1类型的数据记录，然后再进行投影运算，只取c字段(基于字段/列c来对a=1进行投影计算，也可称之为映射计算)<br>并且再<code>tables_B</code>表中进行选择运算，寻找的条件是b小于3的所有记录，然后进行投影运算<br>再将表<code>tables_A</code>与表<code>tables_B</code>进行差运算<br>此时的输出数据就是<br>将表<code>tables_A</code>中将所有已经排除了表<code>tables_B</code>中b小于三的数值类型的所有数值类型<br>因此得到想要查询的类型</p></blockquote></li><li><p>可将SQL语句具体描述为</p><blockquote><p><code>(π[(下标)c], π[(下标)a=1](tables_A))) - (π[(下标)c], π[(下标)b&gt;3](tables_B)))</code></p></blockquote></li><li><p>此时应输出的查询值即为</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">tables_B</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>笛卡尔积运算</strong></p><ul><li><p>设A和B是两个关系，如果A是m元关系，有i个元组</p></li><li><p>B是n元关系，有j个元组，则笛卡尔积为<code>A*B</code>是一个<code>m+n</code>元关系，则有<code>i*j</code>个元组</p></li><li><p>实例:</p></li><li><p>数据模型:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">tables_B</span><br><span class="line">c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>此时A关系有三个元组，同时B关系有三个元组</p></li><li><p>此时的笛卡尔积则为<code>3*3</code>，则为9个元组</p><blockquote><p>A关系的第一个元组与B关系的所有元组进行连接<br>A关系的第二个元组与B关系的所有元组进行连接<br>A关系的第三个元组与B关系的所有元组进行连接</p></blockquote></li><li><p>此结果即为此笛卡尔运算的乘积结果</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">a，b，c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积运算可以把两个运算连接到一起，从而形成一个新的关系</p><blockquote><p>由此引出连接运算与笛卡尔积的关系与区别</p></blockquote></li></ul><hr><p><strong>连接运算</strong></p><ul><li><p>连接运算是将两个关系的若干属性值拼接成一个新的关系的操作</p></li><li><p>对应的新关系中，包含满足连接条件的所有元组</p></li><li><p>即可将其记为: <code>R 连接(AθB) S</code> (连接符号于普通文本间无法输入)</p></li><li><p>其中，R与S是关系名</p><blockquote><p>A，B分别是R和S上度相等且可比的属性组<br>θ是比较运算符</p></blockquote></li><li><p>实例:</p></li><li><p>数据结构模型:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，a2，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，1</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li><li><p>对表<code>tables_A</code>与表<code>tables_B</code>进行以下比较连接</p></li><li><p><code>tables_A 连接(c&lt;E) tables_B</code>，即为<code>tables_A</code>中的c属性小于<code>tables_B</code>中的E属性</p></li><li><p>连接所输出的结果集为:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">C，E</span><br><span class="line"><span class="number">3</span>，<span class="number">8</span></span><br><span class="line"><span class="number">4</span>，<span class="number">9</span></span><br><span class="line"><span class="literal">null</span>，<span class="number">6</span></span><br></pre></td></tr></table></figure></li><li><p>此例为比较连接</p></li></ul><hr><ul><li>当比较运算符为等号时，可分为等值连接与自然连接</li></ul><p><strong>等值连接:</strong></p><ul><li>当连接条件为”=”时的连接运算 <code>R 连接(R.C=S.E) S</code>，此条件即可描述为R的C属性等于S的E属性</li></ul><p><strong>自然连接</strong></p><ul><li><p>自然连接是一种特殊的等值连接</p><blockquote><p>它要求两个关系中进行变焦的分量是相同的属性组，并且在结果中把重复的属性列去掉，可表示为: <code>R 连接 S</code></p></blockquote></li><li><p>此间的连接符号皆使用文字描述</p></li><li><p>如果将上述数据模型进行自然连接，即为将量表中的B列所拥有且相等的所有分量进行连接</p></li><li><p>连接运算与笛卡尔积运算的区别</p></li><li><p>连接运算是笛卡尔积运算和特定选择运算合并而成的一个运算</p></li><li><p>以此数据模型为例:</p></li></ul><ol><li>等值连接<blockquote><p>当<code>tables_A 连接(tables_A.C=tables_B.E) tables_b</code><br>即为将量表进行等值运算，运算条件与输出的值则为量表中分别<code>C=E</code>的值</p></blockquote></li></ol><ul><li>结果即为:<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A，tables_A.B，C，tables_B.B，E</span><br><span class="line">a1，b1，<span class="number">3</span>，a2，<span class="number">3</span></span><br><span class="line">a2，b3，<span class="number">6</span>，a1，<span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>自然连接</li></ol><ul><li><p><code>tables_A 连接 tables_B</code></p><blockquote><p>此间无任何条件</p></blockquote></li><li><p>结果即为:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">A，tables_A.B，C，E</span><br><span class="line">a1，b1，<span class="number">8</span>，<span class="number">8</span></span><br><span class="line">a1，b2，<span class="number">3</span>，<span class="number">9</span></span><br><span class="line">a2，b3，<span class="number">6</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，3</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>等值连接</strong></p><ul><li><code>tables_A</code>中的C属性与<code>tables_B</code>中的E属性进行比较，一直比较到有相同的元组相等时，将所在元组进行连接<blockquote><p>比如在此实例中3，6，相等，即连接结果为以上两条元组</p></blockquote></li></ul><p><strong>自然连接</strong></p><ul><li><code>tables_A</code>中的B属性和<code>tables_B</code>中的B属性进行等值比较<blockquote><p>此时b1=b1，b2=b2，b3=b3都互为相等，则互相连接，则输出结果为以上两个元组</p></blockquote></li></ul><hr><ul><li>从运算过程可以总结规律: 自然连接必定是等值连接，自然连接与等值连接的区别则在于自然连接所比较的属性必须为公共属性，或者是属性组<blockquote><p>还有一点就是自然连接所形成的新关系会自动将重复的属性去掉<br>在上例中就把<code>tables_B</code>中的B属性去掉了，因为同样的属性所产生的值也必然是相同的，所以会将重复复的值去掉</p></blockquote></li></ul><hr><p><strong>外连接</strong></p><ul><li><p>有些元组不能跟另外关系的任何一个元组匹配，一些实际应用中希望在结果中保留悬浮元组，因此就产生了外连接机制</p></li><li><p>外连接包括了左外连接，右外连接以及全外连接的概念</p></li><li><p>外连接运算的逻辑</p></li></ul><ol><li>计算内连接(比较连接，等值连接与自然连接)</li><li>然后根据左外连接，右外连接或全外连接再加上左侧关系或者右侧关系或者两侧关系中的没有匹配到的元组及悬浮元组</li><li>最后加上悬浮元组用控制NULL来填充相对与另一侧属性的属性值</li></ol><ul><li><p>实例:</p><blockquote><p>自然连接符号的右上角会标识有连接标识L左外连接，R右外连接，F全外连接</p></blockquote></li><li><p>数据模型结构:</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a3，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line">D，E</span><br><span class="line">b1，<span class="number">8</span></span><br><span class="line">b2，<span class="number">9</span></span><br><span class="line">a1，<span class="number">3</span></span><br><span class="line">a2，<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>计算机会先计算出自然连接的结果</li><li>之后再进行认为所指定的连接运算规则</li><li>然后再将所有乘积的属性置为空(NULL)</li><li>最后输出的数据集合变为结果</li></ol><ul><li>其它的运算都可以从这些基本关系的运算合并而成</li></ul><hr><ul><li><p>更多的实例这里不做过多阐述了，因为是Access与MS SQL，因此没有什么对其进行过多抽象描述的必要</p></li><li><p>知识图谱图片:</p></li></ul><img src="images/MS-SQL-2.png" width="30%" height="30%"><ul><li>相关概念图片:</li></ul><img src="images/MS-SQL-1.png" width="30%" height="30%"><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>参考URL</strong></p><ul><li><p>数据抽象级别<a href="https://blog.csdn.net/LetsStudy/article/details/79095315" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/LetsStudy/article/details/79095315</code></p></blockquote></li><li><p>数据科学的核心问题：现实问题的数据抽象与程序表达<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://new.qq.com/omn/20181003/20181003A0XITF00</code></p></blockquote></li><li><p>数据库关系模型范式总结<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36616602/article/details/85345295</code></p></blockquote></li><li><p>数据库之父对实现关系型数据库管理系统的12条建议<a href="https://blog.csdn.net/happmaoo/article/details/83075287" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/happmaoo/article/details/83075287</code></p></blockquote></li><li><p>数据库关系运算<a href="http://baijiahao.baidu.com/s?id=1602887097860809528&wfr=spider&for=pc" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://baijiahao.baidu.com/s?id=1602887097860809528&amp;wfr=spider&amp;for=pc</code></p></blockquote></li></ul><p><strong>参考书籍:</strong></p><ul><li><p>数据库原理及应用 (2017.06-郭春生，方昕)</p></li><li><p>数据库应用技术 (2018.1-栾志军，吕海洋，付海娟主编)</p></li><li><p>数据库技术与应用-2020年春季</p><blockquote><p>第一章-数据库基础知识<br>1.4节-1.6节(数据抽象/关系模型/关系运算)</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>规则</title>
    <url>/2020/03/07/%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>规则-主观</strong></center><a id="more"></a><hr><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><p>目的是引人思考，而绝非让人理解，即便能够理解，也必然不够全面</p></li><li><p>论题核心: 规则/规律/逻辑</p></li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>逻辑</li><li>规律</li><li>规则</li><li>秩序</li><li>智慧</li></ul><hr><p><strong>论题及其导论:</strong></p><ul><li>何为规则？</li><li>规则由何而来？</li><li>何为秩序？</li><li>秩序从何而来？</li><li>秩序与规则的关系与本质？</li><li>规则与秩序的对立概念？</li><li>为何要追求规则与秩序？</li><li>追求规则与秩序所带来的必然结果为何种概念？</li></ul><hr><h3 id="人类-2"><a href="#人类-2" class="headerlink" title="人类-2"></a>人类-2</h3><p><strong>规则与秩序</strong></p><ul><li><p>基于规则，实现秩序</p><blockquote><p>智慧于逻辑铸就规则<br>且相对于秩序<br>规则于现实铸就秩序<br>本能与自由相对秩序<br>本质与现实相对规则</p></blockquote></li><li><p>存在即现实</p><blockquote><p>人类的社会性的前提<br>无智规则<br>无智逻辑</p></blockquote></li><li><p>规则于现实中实现的方式可分为两类</p><blockquote><p>前者为完全/绝对且纯粹的基于智慧<br>其次为基于无智逻辑，即自然规则(自然法则)，此间的规则被称为规律<br>基于智慧的规则产生了可将其称之为法则的规则与规律，法律的概念这里不做阐述<br>自然规则来源于世界与现实，是一切存在于现实的物质与概念的基础<br>自然规则定义了生命，铸就了无智逻辑<br>规则/规律铸就逻辑<br>规则与逻辑皆来源于现实/世界与空</p></blockquote></li><li><p>纯粹性规则/纯粹性秩序的实现</p><blockquote><p>即为拥有纯粹智慧的社会性形态<br>并非纯粹的共产主义<br>而是绝对的纯粹意识形态<br>无即为一切，一切终究归于无，而又源于无<br>即为规则与秩序的根源<br>无规则即为纯粹规则，无逻辑即为纯粹逻辑<br>且<br>无意识即为纯粹意识<br>但智慧是存在于现实的<br>将一切归根结底的答案，都将归于无<br>在此所讨论的一切，都将不产生任何意义<br>理智与智慧是不应存于现实的，理智与智慧是最为荒谬的概念且为最不接近(或称其为抛离/脱离)于现实/世界的概念<br>人类/智慧生物在理智状态下做做出的一切行动都是最为荒谬的…</p></blockquote></li><li><p>顺天应人，随心而行，终究是最终且最合理的结果</p><blockquote><p>纯粹的纯粹唯物主义也莫过于如此<br>但大多或称所有，所谓的存在于现实中的顺天应人的智慧<br>都为主观结果，而非空或无所产生/带来的结果<br>纯粹且绝对性的概率如果存在，顺天应人则绝对不存在<br>光凭人类的智慧恐怕是完全无法做到所谓的顺天应人<br>追求规则与秩序所带来的必然结果即为无结果(绝对追求/追求绝对的规则与秩序)</p></blockquote></li><li><p>平衡</p><blockquote><p>针对平衡的概念与深层理解与思考<br>一切概念的最优解结尾平衡，平衡即为存于现实间最美好且最完全的概念<br>为何要去追求规则与秩序<br>一切都是为了将世界/现实达到或保持所谓的平衡，无论客观与主观<br>弱者与强者间的平衡，本能与理智间的平衡，本质与智慧之间的平衡，有与无(空)之间的平衡…</p></blockquote></li></ul><hr><h3 id="相关主观概念"><a href="#相关主观概念" class="headerlink" title="相关主观概念"></a>相关主观概念</h3><ul><li>现实/世界中所存在的一切皆可对立且皆成逻辑与规则</li><li>现实层面概念所产生与存在的现实概念:</li><li>现实/世界/自然因智慧/理智的存在而产生了最荒谬的结果</li><li>因此自然/世界将永远无法达到平衡(现实/世界存在智慧)</li></ul><p><strong>而人类社会更是与其相同</strong></p><ul><li><p>人与人之间于智慧层面的差距是人类永远也无法去主观进行理解的概念</p></li><li><p>而人与人之间所产生的智慧的差距皆来源于世界</p><blockquote><p>这里也可以将世界的概念称之为自然环境与绝对性概率所产生的环境差异</p></blockquote></li><li><p>正常状态下的人类皆拥有智慧？</p><blockquote><p>不<br>所谓的智慧，并非是所有人都在乞求得到的事物<br>沉迷于精神世界或沉迷于现实世界间的智慧将永远都不配将其称之为智慧(对于无限接近于纯粹的智慧而言)<br>有的人拥有的智慧接近于纯粹，而有的人则接近于无(此类人与无智慧生物相近，也就是猿猴)<br>但无论是任何形式的智慧，无论是拥有这两种绝对的概念其中的哪一个<br>所带来的结果都是绝对荒谬的<br>而接近于纯粹智慧的智慧永远都达不到且无法拥有纯粹的智慧，因为他们存在于现实间<br>而平衡，往往是于现实间所存在的最完美智慧<br>接近于纯粹智慧的智慧(按理/此处为主观愚解)应当理解这些基本的概念<br>接近于纯粹智慧的智慧会去无限的接近于平衡的智慧，而并非一味的去追求纯粹<br>一味的去追求纯粹的智慧并非为接近纯粹智慧的智慧<br>疯子与精神病患者可能会聪明绝顶，但其拥有的绝对不是接近于绝对纯粹的智慧<br>接近于绝对纯粹的智慧会尽力的去保持应有且为原有应当的平衡<br>即为将同时存在于现实与精神世界的人体意识时刻保持平衡<br>现实/世界间应只存在”最”的概念，而不应存在”绝对”的概念<br>无<br>纯粹</p></blockquote></li><li><p>此间只可意会，无法以言语相传</p></li><li><p>此间概念应有丢失，待今后进行相应补充</p></li></ul><p><strong>死循环<del>(嵌套循环)</del></strong></p><p><strong>即永远无法到达的平衡与纯粹</strong></p><p><strong>至此</strong></p><hr><h3 id="不精之精，而至纯粹"><a href="#不精之精，而至纯粹" class="headerlink" title="不精之精，而至纯粹"></a>不精之精，而至纯粹</h3><ul><li><p>改意之于-元精者，不精之精，其体纯粹，发而为智</p></li><li><p>此句来源于易经-周易阐真-序-先天五元，发为五得</p><blockquote><p>元性者（甲），无性之性，其体柔慈，发而为仁。<br>元神者（丙），不神之神，其体圆通，发而为礼。<br>元气者（戊），无气之气，其体纯一，发而为信。<br>元情者（庚），无情之情，其体刚烈，发而为义。<br>元精者（壬），不精之精，其体纯粹，发而为智。</p></blockquote></li></ul><hr><ul><li>而之即有其词-后天五浊，感生五贼<blockquote><p>游魂（乙）主生，其性善，感则生喜。<br>识神（丁）至灵，其性贪，感则生乐。<br>妄意（己）至动，其性乱，感则生欲。<br>鬼魂（辛）主死，其性恶，感则生怒。<br>浊精（癸）至浮，其性痴，感则生哀。</p></blockquote></li></ul><hr><p><strong>其它:</strong></p><ul><li>万物皆为相生相克，此存在于现实的概念恐怕8000年前的古中国就早已经有智慧提出了</li><li>而由进现代的相对论(狭义/广义)/质能守恒定律所产生的质能方程E=mc^2则完全且绝对的证明了此存在于现实的逻辑与观点</li><li>存在于现实的纯粹唯物主义的一切/绝对基本条件即为纯粹性概率/完全性概率，此概念将对应于现代所产生的量子理论</li><li>我虽自称沉醉于纯粹的纯粹唯物主义，但我对本质即为存在于现实世界的物理学一无所知</li><li>即便是纯粹的理论物理，而能令我沉迷的只有比其更接近于纯粹的纯粹数学</li></ul><hr><p><strong>下一论题:</strong></p><ul><li>智慧的起源/根源及其本质<blockquote><p>即为一切论题的基础，一切存在(唯心主义)于现实间的根源与基础<br>智慧绝非凭空产生或来于它类，进化论于唯物主义理论中是完全存在的<br>存在于现实的一切概念与生命都不可能拥有纯粹的智慧，因为纯粹的自由完全不属于现实(精神或意识形态)</p></blockquote></li></ul><hr><ul><li>文章内所涉及的一切现实与精神概念的相关内容皆基于主观理解与描述</li><li>相对于自身有限的智慧层次而对其客观进行的理解与描述</li><li>并且我将会尽量的做到绝对存在于现实的客观，但终究有限</li></ul><hr><ul><li>Because it is there-(因为山在那里)</li><li>我所拥有的一切皆来源于现实与世界，因此我终将一无所有</li></ul><hr><ul><li>补充一点: 0与1即为无与有，此时应当联想到何物？<blockquote><p>二进制……与机械智能……</p></blockquote></li></ul><hr><p><strong>相关资料:</strong></p><ul><li>中国哲学书电子化计划 -《周易阐真》<a href="https://ctext.org/wiki.pl?if=gb&res=904129&remap=gb" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://ctext.org/wiki.pl?if=gb&amp;res=904129&amp;remap=gb</code></p></blockquote></li></ul><blockquote><p>周易闡真（易道心法真傳）- 卷首-河圖<a href="https://www.eee-learning.com/book/eee-shinfa-ch3" target="_blank" rel="noopener">跳转</a><br><code>https://www.eee-learning.com/book/eee-shinfa-ch3</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>无</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LSP-2.2</title>
    <url>/2020/03/07/LSP-2-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用与库函数调用的执行检查与错误处理</strong></center><center><strong>UNIX/Linux-2.2</strong></center><a id="more"></a><h2 id="LSP-2-2"><a href="#LSP-2-2" class="headerlink" title="LSP-2.2"></a>LSP-2.2</h2><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-2</li></ul><hr><p><strong>涉及概念一览:</strong></p><ul><li>库函数基本检查</li><li>系统调用检查与错误处理</li><li>库函数调用检查与错误处理</li></ul><hr><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><ul><li><p>库函数即为存在于C 标准库内的任何函数，也可以称其为函数</p><blockquote><p>设计库函数的目的是为了提供比底层系统调用更方便的调用接口</p></blockquote></li><li><p>标准C语言函数库: GNU C 语言函数库(Glibc)</p><blockquote><p>标准C语言函数库的实现跟随UNIX的实现而异<br>GNU C语言函数库即为Linux上最常用的实现</p></blockquote></li><li><p>除了标准的函数之外通常还有其它的拓展函数uClibc与dietlibc</p><blockquote><p>uClibc: htttp://<a href="http://www.ulibc.org" target="_blank" rel="noopener">www.ulibc.org</a><br>dietlibc: <a href="http://www.fefe.de/detlibc" target="_blank" rel="noopener">http://www.fefe.de/detlibc</a></p></blockquote></li><li><p>因为Linux开发的大多数开发都只能用到Glibc，所以这里将不会对其它的拓展函数库进行过多讨论</p></li><li><p>查看当前系统的Glibc版本</p><blockquote><p>直接运行其glibc的共享库文件(可执行文件)，以获取版本<br><code>$ /lib/libc.so.6</code></p></blockquote></li><li><p>确定改库存放位置的方法之一:</p><blockquote><p>针对某个与glibc动态链接的可执行文件，运行ldd程序<br>然后再检查已输出的库依赖列表，便能发现glibc共享库所处于的位置<br><code>$ ldd myprog | grep libc</code></p></blockquote></li></ul><hr><ul><li>应用程序可以通过测试常量和调用函数库这两种方法来确定系统所安装的glibc版本及其详细信息<blockquote><p>从版本2.0开始，glibc定义了两个常量<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>，以供程序再编译时(在<code>#ifdef</code>语句中)测试使用<br>为了避免在同步机器上造成的版本不同而产生的参数差异所带来的种种问题，可以在程序内调用<code>gnu_get_libc_version()</code>来确定运行时的glibc版本</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/libc-version&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gnu_get_libc_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>而对于获取glibc版本信息，还有一种方法，即为使用<code>confstr()</code>函数来获取(glibc特有的)<code>_CS_GNU_LIBC_VERSION</code>配置变量的值<blockquote><p>其返回的字符串与上述实例相同</p></blockquote></li></ul><hr><h3 id="如何处理来自系统调用的错误与如何处理来自库函数的错误"><a href="#如何处理来自系统调用的错误与如何处理来自库函数的错误" class="headerlink" title="如何处理来自系统调用的错误与如何处理来自库函数的错误"></a>如何处理来自系统调用的错误与如何处理来自库函数的错误</h3><ul><li>几乎每个系统调用和库函数都会返回某类状态值，用以表明调用成功与否<blockquote><p>如果想要深入的了解调用是否成功，必须检查对状态值进行检查<br>若调用失败，则采取相应行动<br>所以让程序显示错误消息，以防止有意想不到的时间发生，是非常有必要的<br>但是还有少数几个系统调用函数在调用时从不会失败(例如<code>getppid()</code>总是能成功返回<code>进程的ID</code>，而<code>_exit()</code>总能终止进程，则无需对此类系统调用的返回值进行检查)</p></blockquote></li></ul><hr><p><strong>如何处理来自系统调用的错误:</strong></p><ul><li>每个系统调用的手册页记录有调用可能的返回值，并指出了哪些值表示错误<blockquote><p>通常，返回值为-1则表示出错，当处于此种情况下，可以使用下列代码对系统调用进行检查</p></blockquote></li></ul><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">fd = <span class="keyword">open</span>(pathname, flags, mode); <span class="comment">/* system call to open a file */</span></span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to handle the error */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">close</span>(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to heandle the error */</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>当系统调用失败时，会将全局整形变量<code>errno</code>设为一个正值，以标识具体的错误</p><blockquote><p>程序(<code>#include</code>)包含<code>&lt;errno.h&gt;</code>头文件，该文件提供了对<code>errno</code>的声明，以及一组针对各种错误编号而定义的常量<br>所有这些符号名都以子字母E打头，在每个手册页内标题为<code>ERRORS</code>的章节内，都刊载有一份相应系统调用可能返回的<code>errno值</code>列表</p></blockquote></li><li><p>这里是利用<code>errno</code>来诊断系统调用错误的一个简单实例:</p></li></ul><figure class="highlight nix"><table><tr><td class="code"><pre><span class="line"><span class="attr">cnt</span> = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">cnt</span> == -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">errno</span> == EINTR)</span><br><span class="line">fpintf(stderr, <span class="string">"read was interrupted by a signal\n"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Some other error occurred */</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>如果调用系统函数和函数库成功，<code>errno</code>绝不会被重置为0，故此改变了值不为0，还有可能是因为之前的调用失败造成的</p><blockquote><p>此外，<code>SUSv3</code>允许在函数调用成功时，将<code>errno</code>设置为非零值(但是基于没有函数会这么做)<br>因此，在进行错误检查时，必须检查首先检查函数的返回值是否表明调用出错，然后再检查<code>errno</code>确定错误原因<br>少数系统调用(比如<code>getpriority()</code>)在调用成功后，也会<code>返回-1</code><br>所以在要判断此类系统调用是否发生错误，应在调用前将<code>errno</code>设置为0，并在调用后进行检查(以上所描述的手法同样适用于某些库函数)</p></blockquote></li><li><p>系统调用失败后，常见的做法之一就是根据<code>errno</code>值来打印错误消息，提供的库函数<code>perror()</code>和<code>strerror()</code>，就是处于此目的</p><blockquote><p>此实例中函数<code>perror()</code>会打印出其<code>msg参数</code>所指向的字符串，紧跟一条与当前<code>errno值</code>相对应的消息</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>以下是对系统调用错误进行错误的一种简单方式:</li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">fd = open(pathname, flags, mode);</span><br><span class="line"><span class="keyword">if</span> (fd == -<span class="number">1</span>) &#123;</span><br><span class="line">perror(<span class="string">"open"</span>)</span><br><span class="line"><span class="keyword">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>strerror()</code>会针对其<code>errnum</code>参数中所给定的错误号，返回相应的错误字符串</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>由<code>strerror()</code>所返回的字符串可以是静态分配的，这意味着后续对<code>sterror()</code>的调用可能会覆盖该字符串</p><blockquote><p>若无法识别<code>errnum</code>所含的错误编号，则<code>strerror()</code>会返回<code>&quot;Unknown error nnn&quot;</code>形式的字符串<br>在某些其它的视线中，在这种情况下，<code>strerror()</code>会返回<code>NULL</code></p></blockquote></li><li><p>由于<code>perror()</code>和<code>sterror()</code>都属于对语言环境敏感(locale-sensitive)的函数，故而错误描述中使用的都是本地语言</p></li></ul><hr><p><strong>处理来自库函数的错误</strong></p><ul><li>不同的库函数在调用发生错误时，所返回的数据类型和值也各不相同(可以参见每个函数的手册页)</li><li>从错误的角度来讲，可以分为以下几类:</li></ul><ol><li>某些库函数返回错误信息的方式与系统调用完全相同，则<code>返回值为-1</code>，伴之以<code>errno号</code>来标识具体错误<blockquote><p><code>remove()</code>便是其中一例，可使用该库函数来删除文件(调用<code>unlink()</code>相同调用)或目录(调用<code>rmdir()</code>相同调用)<br>对此类函数所发生的错误进行诊断，其方式与系统调用完全相同</p></blockquote></li><li>某些库函数在出错时会<code>返回-1</code>之外的其他值，但仍会设置<code>errno</code>来表明具体的出错情况<blockquote><p>例如，<code>fopen()</code>在出错时会返回一个<code>NULL指针</code>，还会根据出错的具体底层相同调用来设置<code>errno</code><br>函数<code>perror()</code>和<code>sterror()</code>都可用来诊断此类错误</p></blockquote></li><li>还有一些函数根本不使用<code>errno</code>，对此类函数来说，确定错误存在与否及其起因的方法各不相同<blockquote><p>同样可见诸于相应函数的手册页中，不应使用<code>errno</code>，<code>perror()</code>或<code>strerror()</code>来诊断错误</p></blockquote></li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li>Linux/UNIX系统编程(上册)</li><li>参考自原书3.3-3.4章节</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>软件</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>LSP-2-1</title>
    <url>/2020/03/06/LSP-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用概念及其执行逻辑叙述</strong></center><center><strong>UNIX/Linux-2.1</strong></center><a id="more"></a><h2 id="LSP-2-1"><a href="#LSP-2-1" class="headerlink" title="LSP-2.1"></a>LSP-2.1</h2><ul><li>LSP/Linux System Prorgramming-2</li></ul><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-1</li><li>系统编程先决条件及其执行逻辑整合文案-1</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>系统调用及其执行逻辑刨析</li><li>对已执行的调用进行检查</li><li>逻辑简述</li></ul><hr><ul><li>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律</li></ul><hr><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li><p>系统调用是受控的内核入口，因此机制，进程可以请求内核以自己的名义去执行某些动作</p></li><li><p>以应用程序编程接口(API)的形式，内核提供有一系列服务提供程序访问(包括创建新进程，执行I/O，以及为进程间通信创建管道等)</p></li><li><p>在深入系统调用的运作方式之前，需要对其进行关注的几个问题点</p></li></ul><ol><li>系统调用是将处理器从用户态切换到和心态，以便CPU访问受到保护的内核内存</li><li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识(程序通过名称来标识系统调用，此编号机制通常与其无关)</li><li>每个系统调用可辅之以一套参数，对用户空间(亦即进程的虚拟地址空间)与内核空间之间(相互)传递的信息加以规范</li></ol><ul><li><p>从编程的角度去理解，系统调用与C语言函数的调用很相似</p><blockquote><p>然而在系统调用时，其幕后会经理诸多步骤，接下来将会对该步骤的具体逻辑进行叙述:</p></blockquote></li><li><p>这里将硬件平台-<code>x86-32</code>为例，按事件发生的顺序对这些步骤加以分析</p></li></ul><ol><li>应用程序通过调用C语言函数库中的外壳(wrapper)函数，以发起系统调用</li><li>对系统调用中断处理的例程来说，外壳函数必须保证所有的系统调用参数可用<blockquote><p>通过堆栈，这些参数传入外壳函数，但内核却希望这些参数置于特定的寄存器<br>因此，外壳函数会将上述参数复制到寄存器</p></blockquote></li><li>由于所有系统调用进入内核的方式相同，内核需要设法区分每个相同调用<blockquote><p>为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器(%eax)中</p></blockquote></li><li>外壳函数执行一条中断机器指令(<code>int 0x80</code>)，引发处理器从用户态切换到和心态，并执行系统终端<code>0x80</code>(十进制数为128)的终端矢量所指向的代码<blockquote><p>在较新的<code>x86-32</code>硬件平台实现了<code>sysenter指令</code>，较之传统的<code>int 0x80</code>中断指令，sysenter指令进入内核的速度更快，2.6内核与glibc2.3.2以后的版本都支持<code>sysenter指令</code></p></blockquote></li><li>为相应中断<code>0x80</code>，内核会调用<code>system_all()</code>例程(位于汇编文件<code>arch/i386/entry.S</code>中)来处理这次中断，具体的处理逻辑与步骤如下:<blockquote><p>1-在内核栈中保存寄存器值(这里先不做阐述)<br>2-审核系统调用编号的有效性<br>3-以系统调用编号对存放所有调用服务例程的列表(内核变量<code>sys_call_table</code>)并进行索引，发现并调用相应的系统系统调用服务例程<br>3.1-若系统调用服务例程带有参数，那么将会首先检查参数的有效性<br>3.2-例如，会检查地址指向用户空间的内存位置是否有效<br>3.3-随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改<br>3.4-以及在用户内存和内核内存间传递数据(比如在I/O操作中)<br>3.5-最后，该服务例程会将结果状态返回给<code>system_call()</code>例程<br>4.-从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中<br>5.-返回值外壳函数，同时将处理器切换回用户态</p></blockquote></li><li>若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno<blockquote><p>然后，外壳函数返回一个整型值，以表明系统调用是否成功<br>在Linux上，系统调用服务例程所遵循的惯例是调用成功则返回负值<br>发生错误时，例程会对相应erron常量取反，则返回一个负值<br>C语言函数库的外壳函数即对其再次取反(此时负负得正)，将此结果拷贝至 errno<br>同时以-1作为外壳函数的返回值返回，以此向调用程序表明有错误发生<br>上述惯例所依赖的先决条件是系统调用服务例程，若调用成功则不会返回负值<br>可是对于少数例程来说，这一前提并不成立<br>一般情况下，这也不会有问题，因为取反的errno值范围不会与调用成功返回负值的范围有交集<br>不过还有一种情况沿用这个惯例确实会出问题: 系统调用<code>fcntl()</code>的<code>F_GETOWN</code>操作，这里先不做阐述</p></blockquote></li></ol><hr><ul><li>以相同调用<code>execve()</code>为例，此图片展示了上文叙述及事件的发生序列</li><li>在<code>Linux/x86-32</code>上，<code>execve()</code>的系统调用号为<code>11(__NR_execve)</code><blockquote><p>因此，在<code>sys_call_table</code>向量中，<code>条目11</code>包含了该系统调用的服务例程<code>sys_execve()</code>的地址</p></blockquote></li><li>在Linux中，系统调用服务例程的命名通常会采取<code>sys_xyz()</code>的形式，其中<code>xyz()</code>则是所论及的系统调用</li></ul><p><strong>系统调用的执行步骤图例</strong></p><img src="/images/系统调用-1.png" width="40%" height="40%"><hr><ul><li><p>在系统调用的实际情况中，通常不需要将概念掌握并理解的如此深刻</p><blockquote><p>但即便对于一个简单的系统调用，仍要完成相当多的工作<br>因此系统调用的开销虽然很小，却也不容忽视</p></blockquote></li><li><p>这里可以将getppid()系统调用为例，研判一下发起系统调用的开销:</p><blockquote><p>该系统调用只是简单地返回调用进程的父进程ID<br>此时在一台运行着<code>Linux 2.6.25</code>的<code>x86-32</code>系统上，调用<code>getppid()</code>一千万次大约需要<code>2.2秒</code>钟，每次调用大致需要<code>0.3微秒</code><br>相形之下，在同一系统上，调用某个只返回整数的C语言函数一千万次，仅需0.11秒，约为<code>getppid()</code>耗费时间的<code>1/20</code><br>当然，大多数系统调用的开销都明显高于<code>getppid()</code></p></blockquote></li></ul><hr><ul><li>因此，从C 语言编程的角度去看，调用C语言函数库的外壳函数等同于调用相应的系统调用服务例程<blockquote><p>在今后的章节里，调用系统调用<code>xyz()</code>这类说法即意味着: 调用外壳函数，然后再由外壳函数去调用系统调用<code>xyz()</code></p></blockquote></li><li>为调试程序，或是研究程序的运作机制，可以使用<code>stace命令</code>，以便对程序发起的系统调用进行跟踪</li><li>有关与Linux系统调用机制有关的信息可参见其它书籍: [Love，2010]，[Bovet &amp; Cesati，2005]以及[Maxwell，1999]</li></ul><hr><p><strong>相关概念整合:</strong></p><ul><li><p>系统编程概念</p></li><li><p>系统编程先决条件及其执行逻辑整合文案</p></li><li><p>系统编程概念</p><blockquote><p>系统编程先决条件整合文案<br>系统调用<br>执行逻辑<br>库函数<br>GNU Libc (Glibc-GNU C 标准库)<br>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律<br>已执行调用检查<br>库函数错误<br>系统条用错误<br>可移植性<br>特性测试宏<br>SUSv3中定义的标准系统数据类型</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>可参考URL目录</p></li><li><p>CN-CSDN-Linux系统调用手册<a href="https://blog.csdn.net/xtx1990/article/details/8173950" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/xtx1990/article/details/8173950</code></p></blockquote></li><li><p>CN-CSDN-linux常用系统调用简介<a href="https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>CN-个人博客-[译] Linux 系统调用权威指南（2016）<a href="https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/</code></p></blockquote></li><li><p>CN-百度文库-系统调用手册<a href="https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html</code></p></blockquote></li><li><p>CN-IBM-Linux系统调用列表<a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</code></p></blockquote></li></ul><p>CN-个人博客-Linux系统调用(syscall)原理<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://gityuan.com/2016/05/21/syscall/</code></p></blockquote><hr><ul><li><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a><blockquote><p>第三章节内容<br>PDF资源可参考文章OS-1<br>手册页-Linux系统调用<br>书籍-附录A</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>LSP-1</title>
    <url>/2020/03/06/LSP-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux内核与操作系统基本概念归纳</strong></center><center><strong>UNIX/Linux-1</strong></center><a id="more"></a><h2 id="LSP-1"><a href="#LSP-1" class="headerlink" title="LSP-1"></a>LSP-1</h2><ul><li>LSP/Linux System Prorgramming</li></ul><hr><h3 id="UNIX-Linux-1"><a href="#UNIX-Linux-1" class="headerlink" title="UNIX/Linux-1"></a>UNIX/Linux-1</h3><ul><li>内核与操作系统的相关基本概念归纳</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><p><strong>内核</strong></p><ul><li><p>内核概念</p><blockquote><p>操作系统的核心<br>内核在狭义范围内被理解为用于管理与分配计算机硬件资源(即CPU，RAM，设备等)的核心层软件<br>在没有内核的情况下，计算机也能运行程序<br>内核的作用是对其它程序的编写和使用进行简化(通常会产生极大的简化效果)<br>者一切都要归功于内核为管理计算机的有限资源所提供的软件层</p></blockquote></li><li><p>内核文件命名机制</p><blockquote><p><code>vmunix/</code><br><code>boot/vmlinuz</code><br>内核为经由压缩的可执行文件</p></blockquote></li></ul><p><strong>内核的存在意义与职责</strong></p><ul><li><p>进程调度</p><blockquote><p>通常计算机内存在着若干个CPU(中央处理单元)以执行程序命令<br>UNIX kernel system与UNIX-like(Linux) kernel system属于抢占式多任务系统<br>多任务意指多个进程(即运行中的程序)可同时驻留于内存，且每个进程都能够获得对CPU的使用权<br>抢占用于泛指一组规则，这组规则控制着指定进程对CPU的使用权与使用时间<br>以上两者均有内核进程调度程序(而非程序本身)决定</p></blockquote></li><li><p>内存管理</p><blockquote><p>由于硬件资源的有限且软件对其硬件资源的占用，使得物理内存(RAM)被定义为有限资源<br>内核的作用就是以公平且高效的方式在进程间共享这一资源<br>多数的现代操作系统(包括Linux)采用了虚拟内存管理机制<br>使得进程与进程之间，进程与内核之间彼此隔离，以防止进程读取或修改内核或其它进程中的内存内容<br>只需将进程的一部分保存在内存中，以降低每个进程对内存的需求量与实现在RAM中同时加载更多的进程<br>此方法大幅提升了在任意时刻的CPU都有至少一个进程可以执行，以使得对CPU资源的利用更加充分的情况</p></blockquote></li><li><p>文件系统提供</p><blockquote><p>内核在磁盘之上有提供文件系统，并且允许对文件系统执行创建，获取，更新以及删除等管理操作</p></blockquote></li><li><p>创建和终止进程</p><blockquote><p>内核可以将新程序载入内存，以为其提供运行所需的资源(比如CPU，内存以及对文件的访问等)<br>这样一个处于运行状态下的程序被称之为进程<br>一旦进程执行完毕，内核还要确保释放其占用的资源，以备后续程序重新使用</p></blockquote></li><li><p>对设备与其硬件的访问</p><blockquote><p>计算机的外界设备(人体学输入设备，磁盘或磁带驱动器等)可实现计算机与外部世界的通信<br>此通信机制包括输入，输出或两者兼而有之<br>内核即为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问</p></blockquote></li><li><p>联网的机制与其实现</p><blockquote><p>内核以用户进程的名义收发网络消息(数据包)<br>该任务包括将网络数据表路由至目标系统</p></blockquote></li><li><p>提供系统调用应用编程接口(API)</p><blockquote><p>进程可利用内核入口点(也可称其为系统调用)请求内核去执行各种任务<br>衍生概念: Linux系统内核调用API的方法与步骤，此概念将会在以后章节内进行详细刨析与实践</p></blockquote></li><li><p>通常情况下，多用户操作系统(例如Linux等)会为用户提供一种名为: 虚拟私有计算机(virtual private computer)的抽象概念</p></li><li><p>即为每个用户都可以登陆操作系统，并且其独立的操作与其它的用户大致无干(包括独立访问设备，独立运行程序，CPU，磁盘及其硬件资源独立分配等等)</p></li><li><p>此时的内核用于负责解决(多进程)访问硬件资源时可能引发的冲突，并且不对用户和进程产生任何层面的影响</p></li></ul><hr><p><strong>内核态与用户态</strong></p><blockquote><p>现代处理器架构一般允许CPI至少在两者不同的状态下允许<br>即为用户态与核心态(有时也可称之为监管态supervisor mode)<br>执行硬件执行可使得CPU在两者状态间来回切换<br>与之相对应的虚拟内存区域也可划分(标记)为用户空间部分与内核空间部分<br>在用户状态下运行时: CPU只能访问被标记为用户空间的内存，视图访问属于内核空间的内存会引发硬件异常<br>在内核状态下运行时: CPU既能访问用户空间内存，也能访问内核空间内存<br>内核状态下运行的处理器通常可以完成某些特定操作: 此特定操作包括了执行宕机(halt)，访问内存管理硬件，以及设备I/O操作的初始化等等<br>实现者们通常会利用这一硬件设计将操作系统置于内核空间以确保用户进程不能访问内核指令和数据结构，保证了其无法对操作系统执行不利于操作系统运行的操作<br>而程序员在进行日常的编程任务时有必要去习惯于利用面向进程(process-oriented)的思维方式来考虑编程问题<br>即以进程及内核的视角来检视系统</p></blockquote><hr><h3 id="Shell相关"><a href="#Shell相关" class="headerlink" title="Shell相关"></a>Shell相关</h3><ul><li>shell是用于读取用户输入指令并将其相对应的程序进行执行并相应的软件程序<blockquote><p>也可将其称之为命令解释器<br>术语: 登陆shell(login shell)用于特质用户刚登陆系统时，由系统创建，用以运行shell的进程<br>在某些操作系统内会将命令解释器集成于内核中，对于UNIX系统而言，shell只是一个用户进程<br>在UNIX系统的历史中出现过的重要shell: Bourne shell (sh)，C shell (csh)，Korn shell (ksh，bash)等等<br>分别对应了UNIX，BSD，Linux等等</p></blockquote></li></ul><hr><h3 id="操作系统层面相关概念列表"><a href="#操作系统层面相关概念列表" class="headerlink" title="操作系统层面相关概念列表"></a>操作系统层面相关概念列表</h3><ul><li>用户和组-操作系统层面概念</li><li>单根目录层级-操作系统层面概念</li><li>目录-操作系统层面概念</li><li>链接/路径和链接/符号链接-操作系统层面概念</li><li>文件/链接文件/文件类型/文件命名/文件的所有权与权限(相对于用户与操作系统)-操作系统层面概念</li><li>路径/路径命名-操作系统层面概念</li><li>当前工作目录-操作系统层面概念</li><li>文件[I/O模型]/文件描述符-操作系统层面概念</li><li>stdio函数库(C语言在执行文件I/O操作时，通常会调用C标准库内的I/O函数，也可将I/O函数称为stdio函数库)，stdio函数位于I/O系统调用层之上-操作系统层面概念</li></ul><hr><p><strong>程序-操作系统层面概念</strong></p><ul><li><p>程序的存在形式与概念:</p><blockquote><p>程序在现实中的实现可分为两种形式: 源码文件与二进制文件<br>源码文件在执行程序时需要先将其转换(编译和链接处理)为二进制文件，即机器可以理解的二进制机器语言指令</p></blockquote></li><li><p>脚本</p><blockquote><p>脚本是包含命令的文本文件，它可以由shell或其它命令解释器之类的程序直接处理</p></blockquote></li><li><p>有关程序的相关概念列表:</p><blockquote><p>过滤器<br>命令行参数</p></blockquote></li></ul><hr><p><strong>进程</strong></p><ul><li><p>进程的概念与存在意义:</p><blockquote><p>进程即为正在执行的程序实例<br>在程序执行时，内核会将程序的源码载入虚拟内存，以为程序变量分配空间，建立内核记账(bookkeeping)数据结构<br>由此记录进程有关的各种信息(如: 进程ID，用户ID，组ID及其终止状态等)</p></blockquote></li><li><p>在内核的角度去观察进程</p><blockquote><p>进程是一个个实体，内核必须在它们之间共享各种计算机资源<br>以实现让所有的可再生资源在进程间进行平等的资源共享</p></blockquote></li><li><p>进程相关概念列表</p><blockquote><p>进程的内存布局</p></blockquote></li><li><p>逻辑上可以将某一个内存划分为这几部分(也可称为几段):</p><blockquote><p>文本: 程序的指令<br>数据: 程序使用的静态变量<br>堆: 程序可以从该区域动态分配额外内存<br>栈: 随机函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间</p></blockquote></li><li><p>进程相关的基础概念列表:</p></li><li><p>创建进程</p></li><li><p>创建可执行程序</p></li><li><p>进程ID</p></li><li><p>父进程ID</p></li><li><p>进程终止与终止状态</p></li><li><p>进程的用户和组标识符</p></li><li><p>特权进程</p></li><li><p>能力(概念-Capabilities/始于Linux kernel-v2.2)</p></li><li><p>init进程</p></li><li><p>守护进程</p></li><li><p>环境列表</p></li><li><p>资源限制</p></li></ul><hr><p><strong>内存映射</strong></p><ul><li>内存映射基本概念及其实现方法:<blockquote><p>调用系统函数<code>mmap()</code>的进程，会在其虚拟地址空间中创建一个新的内存映射</p></blockquote></li><li>内存映射可分为以下两类:</li></ul><ol><li>文件映射: 将文件的部分区域映射入调用进程的虚拟内存<blockquote><p>调用一旦完成，对文件映射内容的访问则转化为对应相应内存区域的字节操作，映射页面对按需自动从文件中加载</p></blockquote></li><li>相映成趣的是并无文件与之相应的匿名映射，其映射页面的内容会被初始化为0</li></ol><ul><li>由某一进程所映射的内存可以与其它进程的映射共享，而共享的方式通常有两个:</li></ul><ol><li>两个进程都针对某一文件的相同部分加以映射</li><li>由<code>fork()</code>创建的子进程自父进程处继承映射</li></ol><ul><li>内存映射有关概念:<blockquote><p>内存内容填充量分配<br>文件(I/O)，即映射内存I/O<br>进程间通信(通过内存共享映射)</p></blockquote></li></ul><hr><p><strong>静态库和共享库</strong></p><ul><li><p>所特指目标库的概念:</p><blockquote><p>所谓的目标库文件就是: 将(通常是逻辑相关的)一组函数代码加以编译，并置于一个文件中，以供其它程序调用的文件<br>此方法通常有利于程序的开发与维护</p></blockquote></li><li><p>现代UNIX系统提供两种类型的对象库: 静态库和共享库</p></li><li><p>静态库</p><blockquote><p>有时也可称之为档案文件[archives]，是早期UNIX系统中唯一的一种目标库<br>从本质上来讲，可以将静态库描述为: 是对已编译目标模块的一种结构化整合<br>使用静态库时需要在创建程序的链接命令中指定相应的库<br>主程序会在之后对静态库中隶属于各目标模块的不同函数加以引用<br>对于细节这里先不做过多描述，此后的章节内会对其进行具体且完整的刨析与使用和实践</p></blockquote></li><li><p>共享库</p><blockquote><p>共享库存在的意义亦在解决静态库所存在的问题<br>如果将程序链接到共享库，那么此时的链接器就不会把库中的目标模块复制到执行行文件中，而是在可执行文件中写入一条记录，用以表名可执行文件在运行时需要使用该共享库<br>在运行时将可执行文件载入内存的同时会由一个名为动态链接器的程序进行同步执行，以确保将可执行文件所需的动态库找到，并载入内存<br>随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中的函数定义相关联起来<br>在运行时的共享库代码在内存中秩序保存一份，且可供所有运行中的程序使用<br>且经过编译处理的函数仅在共享库内保存一份以解决磁盘空间<br>此设计还能确保各类程序在编译时会及时使用到函数的最新版本，即只需将带有函数新定义的共享库重新加以编译即可，程序将会在下次执行时自动使用新函数</p></blockquote></li></ul><hr><p><strong>进程间通信及其同步</strong></p><ul><li><p>Linux系统上运行有多个进程，其中许多都是独立运行</p><blockquote><p>然而有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制</p></blockquote></li><li><p>读写磁盘文件中的信息是进程通信的方法之一</p><blockquote><p>可是这种方法对于许多程序来说既慢又缺乏灵活性<br>因此，Linux像所有现代UNIX系统所实现的那样去提供了丰富进程间通信的IPC机制</p></blockquote></li><li><p>IPC机制相关概念列表/相关作用及其存在意义:</p><blockquote><p>信号(signal)，用于表示实践的发生<br>管道(即shell用户中的”|”)操作符和FIFO，用于在进程间传递数据<br>套接字，用于为同一台主机或是联网的不同主机上所允许的进程之间传递数据<br>文件锁定，用于防止其它进程读取或更新文件内容，同时运行某进程对文件的部分区域加以锁定<br>消息队列，用于在进程之间交换消息(数据包)<br>信号量(semaphore)，用于同步进程动作<br>共享内存，用于运行两个及两个以上的进程共享同一块内存</p></blockquote></li><li><p>就本质而言，FIFO和UNIX套接字的功能几近相同，即允许统一系统上并无关联的进程间彼此交换数据</p></li><li><p>两种可以并存于现在UNIX系统之中是由于FIFO来自System V，而套接字则源于BSD</p></li><li><p>IPC相关概念:</p><blockquote><p>对于信号及对其的深入刨析与讨论(依旧在后续章节对其实现与刨析)</p></blockquote></li></ul><hr><p><strong>线程</strong></p><ul><li><p>线程的基本概念描述:</p><blockquote><p>在现代UNIX实现中，每个进程都可执行多个线程<br>可将线程的概念比喻为共享同一虚拟内存及一干其它属性的进程<br>每个线程都会执行相同的程序代码，共享同一数据区域和堆<br>并且在同时，每个线程都拥有属于自己的栈，用以装载本地变量和函数调用等链接信息<br>线程之间可通过共享的全局变量进行通信<br>此外，利用上面所描述的IPC和同步机制，线程之间也能够彼此通信</p></blockquote></li><li><p>线程的优点:</p><blockquote><p>线程的优点就在于协同线程之间的数据共享(通过全局变量)更为容易<br>而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然<br>再者就是多线程应用能从多处理器硬件的并行处理中受益匪浅</p></blockquote></li><li><p>有关线程的相关概念列表:</p><blockquote><p>进程组<br>shell任务控制机制<br>会话机制<br>控制终端机制<br>控制进程机制</p></blockquote></li></ul><hr><p><strong>其它操作系统层面的相关概念:</strong></p><ul><li><p>伪终端，是一对相互连接的虚拟设备，也可称之为主从设备</p><blockquote><p>在这对设备之间，设有一条IPC信道以供数据之间进行双向传递<br>并且从设备(slave device)所提供的接口，其行为方式与终端相类似<br>最知名的伪终端要数telnet和ssh之类提供网络登陆服务的应用，以及 x window 系统所提供的终端窗口实现</p></blockquote></li><li><p>日期和时间</p><blockquote><p>进程涉及两种类型时间: 真实时间与进程时间(即为CPU时间，指自进程启动而来，所占有的CPU时间总量)<br>还可进一步的将CPU时间划分为系统CPU时间和用户CPU时间，前者用于指内核模式中执行代码所占用的时间，后者用于指在用户模式中执行代码所占用的时间<br>time命令会显示出真实时间，系统CPU时间，以及执行管道中的多个线程而花费的用户CPU时间</p></blockquote></li><li><p>客户端/服务器架构</p><blockquote><p>即C/S架构<br>这里不做过多赘述</p></blockquote></li><li><p>实时性</p><blockquote><p>纯粹性概念，字面理解<br>关于实时性概念的实现与对其的具体定义这里不做过多赘述</p></blockquote></li><li><p><code>/proc</code>文件系统</p><blockquote><p>在Linux中实现并且提供了类似于其它的现代UNIX系统中的<code>/proc</code>文件系统<br>由一组目录和文件所组成，装配(mount，或称其为挂载)于<code>/proc</code>目录下<br><code>/proc</code>文件系统是一种虚拟文件系统，以文件系统目录和文件形式来提供一个指向内核数据结构的接口<br>以用于用户查看，改变和管理各种系统属性<br>关于/proc文件系统的内容这里先不做过多赘述，今后的章节内会进行刨析与实践</p></blockquote></li></ul><hr><p><strong>本章节所涉及的相关概念归纳</strong></p><ul><li>涉及概念一览(完整版本)</li><li>UNIX/Linux kernel</li><li>操作系统</li><li>shell/shell任务控制</li><li>文件</li><li>I/O模型</li><li>程序</li><li>进程/进程间通信与进程间同步</li><li>信号</li><li>线程</li><li>进程组</li><li>会话</li><li>内存/内存映射</li><li>静态库</li><li>共享库</li><li>终端控制</li><li>进程控制</li><li>伪终端</li><li>日期及时间</li><li>C/S-客户端/服务器架构</li><li>实时性</li><li><code>/proc</code>文件系统</li></ul><p><strong>本章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>所有涉及的文献资料皆来源于电子书籍</p></li><li><p><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a></p><blockquote><p>第二章节内容<br>PDF资源可参考文章OS-1</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
        <tag>OS</tag>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>自由</title>
    <url>/2020/03/06/%E8%87%AA%E7%94%B1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>自由-主观</strong></center><a id="more"></a><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><ul><li>论题三大核心: 自由/纯粹/智慧</li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>自由/纯粹自由</li><li>理智/纯粹理智</li><li>本能/纯粹本能</li><li>智慧/纯粹智慧</li></ul><hr><p><strong>论题:</strong></p><ul><li>什么是自由</li><li>自由从从何而来</li><li>自由的本质是什么</li></ul><hr><p><strong>引论:</strong></p><ul><li>如何定义自由</li><li>对于自由的主观定义</li><li>所谓的自由</li><li>自由于精神层面的理解</li><li>自由于现实层面的实现</li><li>为何要去实现或追求自由</li></ul><hr><h3 id="人类-1"><a href="#人类-1" class="headerlink" title="人类-1"></a>人类-1</h3><p><strong>论题推论:</strong></p><ul><li>什么是自由</li><li>自由从何而来</li><li>自由的本质是什么</li></ul><p><strong>什么是自由?/自由从何而来?/自由的本质是什么?</strong></p><ul><li><p>自由源于人类的本质与天性，所谓天性，即为因存在于现实世界而产生的本能性质的无智逻辑(如果以具备智慧层面的生物来定义，也可称此为无逻辑)</p></li><li><p>但世事皆有因果，万物皆成逻辑(这里将不会过多的带入无的相关与衍生概念)</p></li><li><p>无智逻辑(亦可将其称之或理解为环境逻辑与自然逻辑)</p></li><li><p>存在即现实</p><blockquote><p>世界(即环境)源于空，空源于无<br>任何现实事物的本质来源于世界与环境，包括生命与智慧<br>生命是一切存在于现实的前提，但生命不会定义存在，而智慧可以定义存在<br>存在只是作为存在而存在于现实，概念将归于空-0<br>而当现实的存在被[定义]为存在于现实时，概念将归于世界，即为有-1<br>无即为无</p></blockquote></li><li><p>对于自由的主观定义</p><blockquote><p>在人类的存在还没有被定义之时，生物(即现实层面)的本质就早已被世界或环境所定义<br>此概念的逻辑为无智慧逻辑，也可将其定义于空，将不会产生任何讨论意义<br>此层面逻辑定义了人类于现实层面(世界)内最基本的性质，即存在(生命)<br>而伴随生命而存在的其它事物-现实，世界，无智逻辑(环境逻辑)<br>此间的现实中不存在于秩序，规则与存在等智慧层面的逻辑与概念</p></blockquote></li><li><p>存在即现实</p><blockquote><p>而自由与自由的概念所产生的本质皆来源于此刻<br>为什么会存在自由，有关自由的一切概念从何而来<br>自由来源于本质，而本质来源于环境与世界，世界源于空</p></blockquote></li><li><p>至此，引出我对自由的主观定义</p><blockquote><p>自由虽源于空，但绝不是凭空出现的<br>自由只是人类/生物于现实世界间所产生与拥有的本质<br>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面<br>或称为自由存在于现实层面，由此被智慧定义</p></blockquote></li><li><p>自由有可能可以被归于纯粹层面，即纯粹自由/本质(本能)自由</p><blockquote><p>自由是无智的逻辑，归于本质与本能，是人类永远不可能抛离的概念与本质<br>但人类拥有智慧，智慧可以定义与控制本质与本能<br>智慧存在于现实或精神层面之间的意义，即为定义本能或称[一切存在于世界之间的概念]<br>自由源于空，源于世界，源于本质，但绝对不会[源]于智慧<br>追求本质也是人类作为生物而存在于现实间的本质<br>一切概念与现实皆源于空，即存在-源于空</p></blockquote></li><li><p>存在即现实</p><blockquote><p>存在于现实间的本质与基本的条件/逻辑/概念—即为生命<br>即-生命归于现实，现实归于本质(人类)，本质归于空<br>至此自由是同存在/生命而存在与现实的<br>即人类/生物的本质即为存在，存在则为自由-[无规则(无秩序)/空-无]<br>人类源于空/无，人类/生物的本质即为空/无<br>自由是无概念概念，前者的概念为无，后者的概念为智慧所定义的概念<br>由源于空/源于无，自由是由无智时期就存在于现实间的概念</p></blockquote></li><li><p>生命与自由是人存在于现实的本质，本质即为无智逻辑</p><blockquote><p>于空或无间定义的概念，存在于现实间的人类或生物将永远无法抛离<br>不存在即为无意义，将不会产生任何讨论的意义<br>但不存在于现实可以进行讨论，这里先不进行讨论</p></blockquote></li><li><p>我目前还没有找到我想要找到的答案……</p><blockquote><p>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面 <?>
自由存在于现实层面，由此被智慧定义 <?> 迷惑概念<br>主观的现实逻辑混乱，有一些概念只可意会，无法言传<br>或称为我的主观智慧层次与逻辑层次未到足矣将其以言传之的境界</p></blockquote></li></ul><hr><p><strong>引论答案:</strong></p><ul><li><p>如何定义自由</p></li><li><p>对于自由的主观定义</p><blockquote><p>自由于主观智慧被定义为无逻辑概念</p></blockquote></li><li><p>所谓的自由</p></li><li><p>自由于精神层面的理解</p></li><li><p>自由于现实层面的实现</p></li><li><p>为何要去实现或追求自由</p><blockquote><p>自由源于本质，本质源于现实，讨论于智慧层面间的存在等概念将不会产生任何存在意义<br>现实源于空，空源于无</p></blockquote></li></ul><hr><ul><li><p>一切皆归于无，一切皆可定义为无</p><blockquote><p>逻辑漏洞/逻辑死角/逻辑缺口<br>或称为现实(世界/环境)漏洞/现实缺陷<br>世界也可将其主观的定义为宇宙(现实)</p></blockquote></li><li><p>无</p><blockquote><p>现实逻辑漏洞，有待思考……</p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li><p>如何实现自由，现实间的自由为何物？</p></li><li><p>为何要去实现与追求自由？</p></li><li><p>自由来源于本能，同时将终于智慧</p><blockquote><p>智慧与理智的产物-规则与秩序<br>限制了所谓的自由(即本能)<br>自由所带来的结果必然与智慧(最基本且必然的产物: 规则/秩序)相对<br>当然，由资本所带来的规则与秩序是极度不堪与肮脏的<br>纯粹的智慧终究会产生最精密的逻辑与最极端的规则与秩序<br>而拥有与持续规则与秩序的最基本的条件与概念为-[理智]<br>理智是完全相对于本能的，相对于生物的(与之完全对立且相反，这里称其为相对)<br>或称其是完全且绝对相对于低等/低智能或无智能生物的</p></blockquote></li><li><p>规则与秩序的最基本条件是理智，同时来源于智慧</p><blockquote><p>一味的追求本能与自由的后果即为-停止前进/进化<br>本能与智慧-自由与秩序-滞留与进化<br>自由在理智与智慧的层面是无意义的，是愚昧的，是与之完全/绝对相对的<br>但在本质与本能的层面是完全合理的，是必然的，是完全符合无智逻辑的，是完全正确的</p></blockquote></li><li><p>人类的本质是社会性的</p><blockquote><p>而现有/现实存在的人类/生物的最高进化概念即为-共产主义<br>智慧，理智与秩序最高的社会性形态即为共产主义社会<br>共产主义不会脱离社会性(或称共产主义就是完全建立在社会性的基础上的)，即绝对且完全不会去尝试抛离本能(抛离本能的概念将不存在于现实)<br>而共产主义的弊端即为-此概念是近乎抛离本能的(非本质)，所以成为纯粹共产主义者的前提-就是拥有绝对且成熟的理智与纯粹的智慧<br>抛离本能带来的最终结果即为-抛离自由-共产主义者的自由将必然会被社会性/所处共产主义社会形态所完全(或称绝对)剥夺</p></blockquote></li><li><p>纯粹共产主义社会没有自由可言</p><blockquote><p>因为每一个独立者都将拥有最绝对的理智与最纯粹的智慧<br>它们将不乞求于自由<br>它们将抛离生物的本能(非本质)<br>目前看来…<br>它们…注定不会是存在于现实间的人类…<br>生产力完全充足之时，将有可能实现？<br>不<br>只有当人类完全抛离生而为人/为生物的本质之时<br>才有可能实现<br>此概念将抛离于现实</p></blockquote></li><li><p>人类实现共产主义…</p><blockquote><p>机械智能能否实现共产主义？<br>只有纯粹的精神意识体，能够实现所谓的纯粹共产主义-即纯粹理想主义<br>纯粹理想主义的概念为非现实概念(即便有可能存在于现实)</p></blockquote></li><li><p>纯粹-纯粹自由/纯粹共产主义</p></li></ul><p><strong>至此</strong></p><hr><ul><li>下一论题<blockquote><p>规则与秩序</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>无</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>UNIX/PIPE-1</title>
    <url>/2020/03/05/PIPE-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>UNIX-PIPES概述</strong></center><a id="more"></a><h2 id="UNIX-PIPE-1"><a href="#UNIX-PIPE-1" class="headerlink" title="UNIX/PIPE-1"></a>UNIX/PIPE-1</h2><hr><h3 id="Unix-Pipeline-Pipes-1"><a href="#Unix-Pipeline-Pipes-1" class="headerlink" title="Unix-Pipeline/Pipes-1"></a>Unix-Pipeline/Pipes-1</h3><p><strong>概述:</strong></p><ul><li>管道(Pipeline)是一系列将标准输入输出链接起来的进程</li><li>其中每一个进程的输出被直接作为下一个进程的输入</li><li>每一个链接都由匿名管道实现</li><li>管道中的组成元素也被称作过滤程序</li><li>通常被用于类Unix操作系统(以及一些其他借用了这个设计的操作系统，如Windows)中</li><li>其他操作系统的这个特色源自于Unix，例如Taos和MS-DOS<blockquote><p>最终成为软件工程的管道与过滤器设计样本</p></blockquote></li><li>这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名</li><li>UNIX管道技术需要注意的一点就是需要将管道与管线区分开来(两种截然不同的概念)</li></ul><hr><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述:"></a>具体描述:</h3><p><strong>管道概念:</strong></p><ol><li>管道是用于将一系列的标准输入输出指令(代码)链接起来，从而形成进程的最基本条件</li><li>并且被链接的每一个进程的输出被直接作为下一个进程的输入</li></ol><p><strong>还可以将其描述为:</strong></p><ol><li><p>管道是将一系列标准输入输出链接起来的进程</p></li><li><p>其中每一个进程的输出被直接作为下一个进程的输入</p></li><li><p>其中每一个链接都由匿名管道实现</p></li><li><p>管道中的组成元素也被称作过滤程序</p></li></ol><ul><li><p>其概念模型非常类似于现实世界种的管道</p></li><li><p>该图片描述了某一文字终端上一个包含三个程序的管道:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>管线:</strong></p><ul><li><p>是指将计算机指令处理过程拆分为多个步骤</p></li><li><p>并通过多个硬件处理单元并行执行来加快指令执行速度</p></li><li><p>亦可称之为流水线</p><blockquote><p>因为其具体执行过程类似工厂中的流水线，并因此得名<br>可以将计算机指令比喻为流水线传送带上的产品<br>而各个硬件处理单元就是流水线旁的工人<br>每个不同的产品都需要细分为几个互不相同的部门来实现其各部件的所需<br>所以流水线中所属部门不同的工人会为了同一个产品而同时工作</p></blockquote></li></ul><hr><ul><li>微处理器</li><li>在使用流水线的处理器中一个指令不是在处理器的一个定时器信号中完成的<blockquote><p>而是被分到多个信号中去完成，但是与此同时多个指令的分任务被同时处理</p></blockquote></li><li>由于这些分任务比整个指令要简单，因此可以通过使用流水线提高定时器频率<blockquote><p>虽然每个指令需要多个信号后才能完成<br>但是通过多个指令的并行运算每个信号内一个指令可以完成<br>因此通过这个方法整个速度可以提高</p></blockquote></li></ul><hr><ul><li>流水线级</li><li>一条流水线的每个分步骤被称为流水线级<blockquote><p>它们被流水线寄存器分开除指令流水线外在现代系统中还有其它流水线<br>比如用来计算浮点数的算术流水线</p></blockquote></li></ul><hr><ul><li>管线危障(pipeline hazards)</li><li>假如，一个指令在执行的时候，需要等待流水线上前一个指令先执行完毕的话<blockquote><p>那么这两个指令相互之间彼此有依赖关系<br>这可能导致流水线冲突的现象发生<br>即为管线危障</p></blockquote></li><li>常见情况可分为四种: 资源冲突/数据冲突(指令层的数据冲突/传输层的数据冲突)/控制流冲突</li><li>通过分支预测器可以避免控制冲突<blockquote><p>在这里处理器预测性地继续运算，直到正式预测是正确为止</p></blockquote></li></ul><hr><p><strong>网络管线:</strong></p><ul><li>Unix哲学: “一切皆文件”<blockquote><p>netcat和socat这样的工具可以将管道连接到TCP/IP套接字</p></blockquote></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>管道(UNIX)</li><li>具名管道</li><li>命名管道</li><li>匿名管道</li><li>匿名命名管道</li><li>哈特曼管道</li><li>管线(流水线)</li><li>管线/流水线(计算机)</li><li>管线危障(pipeline hazards)</li><li>重定向(计算机)</li><li><code>tee指令</code><blockquote><p>该程序用于从管线内取出数据</p></blockquote></li><li>XML管道即为处理XML的管线</li><li>网络管线</li><li>UNIX</li><li>进程间通信</li><li>数字通信技术<blockquote><p>计算机通信技术</p></blockquote></li><li>管道协议</li><li>并发计算</li><li>协同控制</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>EN-System Interfaces<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html" target="_blank" rel="noopener">跳转</a></p></li><li><p>单一UNIX规范第7期，由国际开放标准组织发布</p><blockquote><p><code>https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html</code></p></blockquote></li><li><p>EN-Pipes: A Brief Introduction by The Linux Information Project (LINFO)<a href="http://www.linfo.org/pipe.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linfo.org/pipe.html</code></p></blockquote></li><li><p>获取管道的doc文案: <a href="http://www.cs.rit.edu/~swm/history/DTSS.doc" target="_blank" rel="noopener">http://www.cs.rit.edu/~swm/history/DTSS.doc</a></p></li></ul><hr><ul><li><p>以下内容参考自中文维基:</p></li><li><p>CN-分类:</p><blockquote><p>进程通信<a href="https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">跳转</a><br>进程间通信<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</code><br><code>https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A</code></p></blockquote></li><li><p>CN-分类: UNIX<a href="https://zh.wikipedia.org/wiki/Category:Unix" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Unix</code></p></blockquote></li><li><p>CN-分类: 并发计算<a href="https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97</code></p></blockquote></li><li><p>CN-分类: 协同控制<a href="https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6</code></p></blockquote></li><li><p>EN-分类: 指令处理<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><ul><li>CN-维基百科-点对点隧道协议: <a href="https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0</a></li><li>CN-维基百科-管道机制: <a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)</a></li><li>CN-维基百科-管道流: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-IDC: <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83</a></li><li>CN-维基百科-管线: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-命名管道: <a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93</a></li><li>EN-维基百科-管道(计算机): <a href="https://en.wikipedia.org/wiki/Pipeline_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pipeline_(computing)</a></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>UNIX</tag>
      </tags>
  </entry>
  <entry>
    <title>OS-1</title>
    <url>/2020/03/05/OS-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>OS-PDF/URL资源整合目录</strong></center><a id="more"></a><h2 id="Operating-System-1"><a href="#Operating-System-1" class="headerlink" title="Operating System-1"></a>Operating System-1</h2><ul><li>操作系统</li><li>Operating System/OS</li></ul><hr><h3 id="电子书资源整合目录"><a href="#电子书资源整合目录" class="headerlink" title="电子书资源整合目录"></a>电子书资源整合目录</h3><ul><li><p>可能还会利用持续利用此文本进行URL资源整合</p></li><li><p>操作系统概念</p></li><li><p>操作系统原理</p></li><li><p>操作系统设计</p></li><li><p>操作系统制作</p></li><li><p>操作系统实现</p></li></ul><hr><ul><li>操作系统分析与理解<blockquote><p>Unix操作系统<br>FreeBSD(Unix-Like)操作系统<br>Linux(Unix-Like)操作系统</p></blockquote></li></ul><hr><ul><li>中文维基-<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</code></p></blockquote></li></ul><hr><p><strong>使用资源目录:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)<a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/297382.html</code><br><code>https://pan.baidu.com/s/1ntzHejv</code></p></blockquote></li><li><p>CN-Linux系统编程手册上册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p></li><li><p>CN-Linux系统编程手册下册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2016-10/135953.htm</code></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)<a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/232150.html</code></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)<a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://pan.baidu.com/s/1gdKdxlT</code></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)<a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/90585.html</code></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)<a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/294083.html</code></p></blockquote></li></ul><hr><p><strong>资源相关URL补充:</strong></p><ul><li><p>Linux/UNIX编程手册(分卷压缩文件)</p><blockquote><p><code>https://download.csdn.net/download/js_gary/10216486</code><br><code>https://download.csdn.net/download/js_gary/10216495</code></p></blockquote></li><li><p>FreeBSD解析</p><blockquote><p><a href="https://download.csdn.net/download/starry225/6223229" target="_blank" rel="noopener">https://download.csdn.net/download/starry225/6223229</a></p></blockquote></li></ul><hr><p><strong>整合包获取:</strong></p><ul><li>以上PDF资源整合文件的压缩包(一共七本电子书，rar格式):</li><li>百度网盘地址<a href="https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w" target="_blank" rel="noopener">永久链接</a><blockquote><p><code>https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w</code></p></blockquote></li><li>提取码: j3qc</li></ul><hr><p><strong>资源汇总:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)</p><blockquote><p><a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">https://www.jb51.net/books/297382.html</a><br><a href="https://pan.baidu.com/s/1ntzHejv" target="_blank" rel="noopener">https://pan.baidu.com/s/1ntzHejv</a></p></blockquote></li><li><p>CN-Linux系统编程手册上册</p></li><li><p>CN-Linux系统编程手册下册</p><blockquote><p><a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-10/135953.htm</a></p></blockquote></li><li><p>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</p><blockquote><p><a href="http://www.downcc.com/soft/302635.html" target="_blank" rel="noopener">http://www.downcc.com/soft/302635.html</a></p></blockquote></li><li><p>CN-现代操作系统 (原书第四版)</p><blockquote><p><a href="https://www.jb51.net/books/655464.html" target="_blank" rel="noopener">https://www.jb51.net/books/655464.html</a></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)</p><blockquote><p><a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">https://www.jb51.net/books/232150.html</a></p></blockquote></li><li><p>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</p></li><li><p>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</p><blockquote><p><a href="https://www.jb51.net/books/483820.html" target="_blank" rel="noopener">https://www.jb51.net/books/483820.html</a></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</p><blockquote><p><a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">https://pan.baidu.com/s/1gdKdxlT</a></p></blockquote></li><li><p>CN-深入理解UNIX系统内核 (瓦哈利亚)</p><blockquote><p><a href="https://www.jb51.net/books/609170.html" target="_blank" rel="noopener">https://www.jb51.net/books/609170.html</a></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</p><blockquote><p><a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">https://www.jb51.net/books/294083.html</a></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)</p><blockquote><p><a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">https://www.jb51.net/books/90585.html</a></p></blockquote></li></ul><hr><p><strong>书籍参考目录:</strong></p><ul><li>CN-操作系统概念 (原书第九版)</li><li>CN-操作系统概念 (2007-第七版，西尔伯查茨)</li><li>CN-操作系统概念 (原书第7版，清大出版)</li><li>CN-操作系统概念精要 (原书第二版)</li></ul><hr><ul><li>CN-Linux系统编程手册上册</li><li>CN-Linux系统编程手册下册</li><li>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</li></ul><hr><ul><li>CN-现代操作系统 (原书第四版)</li><li>CN-现代操作系统 (原书第三版)</li></ul><hr><ul><li>CN-操作系统精髓与设计原理 (原书第六版)</li><li>CN-计算机系统: 核心概念及软硬件实现 (原书第四版)</li><li>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</li><li>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</li><li>CN-操作系统设计与实现 (2008版，ANDREW S.TANENBAUM/ALBERT S.WOODHULL)</li></ul><hr><ul><li>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</li><li>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</li><li>CN-30天自制操作系统 (2012版，川和秀实)</li><li>CN-深入理解UNIX系统内核 (瓦哈利亚)</li></ul><hr><p><strong>其它:</strong></p><ul><li>书不重要</li><li>问题在于看书的人所拥有的能力</li><li>同种类型的书的本质都是相同的</li><li>找出，理解并且完全记住其中的关键字</li><li>至于对于电子书的版号的选择也无所谓的</li><li>译版与原版随意，有译版最好读译版</li><li>通常EN版的寻找难度比CN版小很多</li></ul><hr><ul><li>系统化学习目录</li><li>Operating System kernel</li><li>数字理论基础</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>VPS/KVM-1</title>
    <url>/2020/03/05/VPS-KVM-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>VPS/KVM简要概述</strong></center><a id="more"></a><h2 id="VPS-KVM-1"><a href="#VPS-KVM-1" class="headerlink" title="VPS/KVM-1"></a>VPS/KVM-1</h2><hr><h3 id="虚拟专用服务器-Virtual-private-server"><a href="#虚拟专用服务器-Virtual-private-server" class="headerlink" title="虚拟专用服务器 (Virtual private server)"></a>虚拟专用服务器 (Virtual private server)</h3><p><strong>简述:</strong></p><ul><li>简称VPS</li><li>由容器技术或虚拟机技术实现</li><li>在容器或虚拟机中，每个VPS都拥有独立的公网IP，操作系统，磁盘空间，内存与处理器资源<blockquote><p>同时进程与系统配置之间也相互隔离<br>目的就是为了让用户和应用程序在同一个主机上模拟出完全不同，独立且相互隔离的资源占用与控制<br>以此让VPS可以完全拥有独立服务器的所有功能</p></blockquote></li><li>并且VPS为用户提供了管理配置的自由</li><li>VPS多用于企业虚拟化于IDC资源租用</li><li>VPS拥有完全的独立性，包括可以在容器内自行安装任何程序与其它对于虚拟硬件的操作<blockquote><p>远端服务器-&gt;容器/虚拟机-&gt;容器/虚拟机-&gt;用户</p></blockquote></li></ul><hr><h3 id="基于内核的虚拟机-Kernel-based-Virtual-Machine"><a href="#基于内核的虚拟机-Kernel-based-Virtual-Machine" class="headerlink" title="基于内核的虚拟机 (Kernel-based Virtual Machine)"></a>基于内核的虚拟机 (Kernel-based Virtual Machine)</h3><p><strong>简述:</strong></p><ul><li>可简称为KVM</li><li>是一种用于Linux内核中的虚拟化基础设施，可将Linux内核转化为一个虚拟机监视器</li><li>KVM于2007年2月5日被导入Linux 2.6.20核心中，基于C</li><li>KVM需要支持硬件虚拟化拓展特性的处理器</li><li>对于操作系统支持的范围较为广泛</li><li>基于多个GNY协议授权<blockquote><p>包括KVM内核模块: GPL v2<br>KVM用户模块: LGPL v2<br>QEMU虚拟CPU内核库(libqemu.a)和QEMU PC系统模拟器: LGPL<br>Linux用户模式QEMU模拟器: GPL<br>BIOS文件(bios.bin，vgabios.bin和vgabios-cirrus.bin): LGPL v2或更新</p></blockquote></li><li>KVM现由保罗·邦齐尼(Paolo Bonzini)维护</li><li>KVM 支持VirtIO半虚拟化技术-平行虚拟化技术(paravirtualization)</li></ul><hr><p><strong>内部结构:</strong></p><ul><li>KVM提供抽象的设备，但不模拟处理器</li><li>它开放了<code>/dev/kvm</code>接口，供使用者模式的主机使用:</li></ul><ol><li>设置客户虚拟机的地址空间<blockquote><p>宿主机同样也需用户可用于引导进主操作系统的固件镜像(通常为模拟PC时的自定义BIOS)</p></blockquote></li><li>为客户机模拟I/O</li><li>将客户机的视频显示映射回系统宿主机上</li></ol><ul><li><p>在Linux上，QEMU版本0.10.1及更新版就是一个用户层主机</p><blockquote><p>QEMU使用KVM以近乎原生的速度虚拟化客户机，若无KVM的话则将仅使用软件模拟</p></blockquote></li><li><p>KVM内部使用SeaBIOS作为对16位x86 BIOS的开源模拟</p></li><li><p>KVM/QEMU环境的高级概述:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>相关GUI(图形化管理)工具:</strong></p><ul><li>Kimchi – 网页版KVM虚拟化管理工具</li><li>Virtual Machine Manager – 支持创建、编辑、开始于关闭基于KVM的虚拟机，同时也支持对宿主之间的实时或冷拖拽虚拟机迁移</li><li>Proxmox虚拟环境 – 一项开源的虚拟化管理包，包括KVM与LXC<blockquote><p>同时它还有裸机安装器、网页版远程管理界面、HA集群堆栈、统一存储、柔性网络及可选的商业支持</p></blockquote></li><li>OpenQRM – 用于管理不同数据中心基础设施的平台</li><li>GNOME 机柜 – Linux上用于管理libvirt客户机的Gnome界面</li><li>oVirt – 用于管理基于libvirt的KVM开源工具</li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>VPS</li><li>KVM</li><li>Virtual</li><li>CN2</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-Redhat-KVM官方网站<a href="https://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux-kvm.org/page/Main_Page</code></p></blockquote></li><li><p>CN-CN2线路是什么，有哪些CN2线路的VPS<a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</code></p></blockquote></li></ul><p><strong>维基百科参考内容:</strong></p><ul><li><p>CN-虚拟主机<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA</code></p></blockquote></li><li><p>CN-虚拟专用服务器<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-服务器<a href="https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-虚拟化<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>CN-硬件虚拟化<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96</code></p></blockquote></li><li><p>CN-KVM-基于内核的虚拟机<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA</code></p></blockquote></li></ul><hr><h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><ul><li><p>境外KVM类型的VPS大约360RMB/年(美国)</p><blockquote><p>最便宜的</p></blockquote></li><li><p>官网地址: <a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">https://shadowsocks.org/en/index.html</a></p></li><li><p>仓库地址: <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></p></li></ul><hr><p><strong>可用参考:</strong></p><ul><li><p>CN-Github-SS教程</p><blockquote><p><a href="https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B</a><br><a href="https://ssr.tools/252" target="_blank" rel="noopener">https://ssr.tools/252</a></p></blockquote></li><li><p>搬瓦工 (Bandwagon Host)</p><blockquote><p>VPS供应商，支持支付宝支付<br><a href="https://bwh88.net/cart.php?gid=1" target="_blank" rel="noopener">https://bwh88.net/cart.php?gid=1</a><br><a href="https://bwg.net/" target="_blank" rel="noopener">https://bwg.net/</a></p></blockquote></li><li><p>CN2: <code>https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</code></p></li></ul><hr><ul><li><p>shadowsocks server</p><blockquote><p><a href="https://github.com/shadowsocksr-backup/shadowsocksr" target="_blank" rel="noopener">https://github.com/shadowsocksr-backup/shadowsocksr</a><br><code>$ apt-get install python-pip</code><br><code>$ pip install shadowsocks</code></p></blockquote></li><li><p>client</p><blockquote><p><a href="https://github.com/Jigsaw-Code/outline-client/" target="_blank" rel="noopener">https://github.com/Jigsaw-Code/outline-client/</a><br><a href="https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation</a><br><a href="https://shadowsocks.org/en/download/clients.html" target="_blank" rel="noopener">https://shadowsocks.org/en/download/clients.html</a></p></blockquote></li></ul><p><strong>Debian</strong></p><ul><li><p>软件源</p><blockquote><p><a href="https://github.com/debiancn/repo" target="_blank" rel="noopener">https://github.com/debiancn/repo</a></p></blockquote></li><li><p>直接拉取shadowsocks-qt5</p><blockquote><p><code>$ apt-get install shadowsocks-qt5 -y</code></p></blockquote></li><li><p>软件源配置:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>echo <span class="string">"deb https://repo.debiancn.org/ testing main"</span> | sudo tee /etc/apt/sources.list.d/debiancn.list;</span><br><span class="line"><span class="variable">$ </span>wget <span class="symbol">https:</span>/<span class="regexp">/repo.debiancn.org/pool</span><span class="regexp">/main/d</span><span class="regexp">/debiancn-keyring/debiancn</span>-keyring_0~<span class="number">20161212_</span>all.deb -O /tmp/debiancn-keyring.deb;</span><br><span class="line"><span class="variable">$ </span>sudo apt install /tmp/debiancn-keyring.deb;</span><br><span class="line"><span class="variable">$ </span>sudo apt update;</span><br><span class="line"><span class="variable">$ </span>rm /tmp/debiancn-keyring.deb;</span><br></pre></td></tr></table></figure></li><li><p>清理源指令:</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> sudo apt purge debiancn<span class="literal">-keyring</span>;</span><br><span class="line"><span class="variable">$</span> sudo rm <span class="operator">-f</span> /etc/apt/sources.list.d/debiancn.list;</span><br><span class="line"><span class="variable">$</span> sudo apt update;</span><br></pre></td></tr></table></figure></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Text</title>
    <url>/2020/03/04/text/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>常驻Text文档</strong></center><a id="more"></a><p><strong>常驻随笔文档</strong></p><ul><li>无<blockquote><p>无很容易理解<br>但很难做到<br>很难在现实中实现?<br>不<br>无不属于现实<br>无则为无<br>空源于无<br>世界源于空<br>思维源于世界<br>而思维终将归于无</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2020/03/02/test/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>常驻Test文档</strong></center><a id="more"></a><p><strong>样式实验文档</strong></p><p><span id="inline-blue">text.md</span></p><p><i class="fa fa-pencil"></i></p><ul><li><p>简介加粗并居中</p><blockquote><p><code>&lt;center&gt;&lt;strong&gt;常驻Test文档&lt;/strong&gt;&lt;/center&gt;</code><br><code>&lt;!-- more --&gt;</code></p></blockquote></li><li><p>插入图片</p><blockquote><p><code>&lt;img src=&quot;图片URL&quot; width=&quot;20%&quot; height=&quot;20%&quot;&gt;</code></p></blockquote></li></ul><hr><p><strong>URL收藏目录</strong></p><ul><li><p>他人学习笔记-BLFS/CLFS<a href="https://www.cnblogs.com/renren-study-notes/p/10385413.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/renren-study-notes/p/10385413.html</code></p></blockquote></li><li><p>免费高清壁纸-宇宙<a href="https://joer.ru/?id=23&start=294" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://joer.ru/?id=23&amp;start=294</code></p></blockquote></li></ul><hr><ul><li><p>更换图片教程<a href="https://www.jianshu.com/p/30bf702f533c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/30bf702f533c</code></p></blockquote></li><li><p>调色板<a href="https://www.colorhexa.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.colorhexa.com/</code></p></blockquote></li></ul><hr><p><strong>Emacs</strong></p><ul><li><p>这里标注一个大佬-子龙山人</p></li><li><p>知乎<a href="https://zilongshanren.com/tags/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zilongshanren.com/tags/</code></p></blockquote></li><li><p>博客<a href="https://www.zhihu.com/people/zilongshanren/answers" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.zhihu.com/people/zilongshanren/answers</code></p></blockquote></li><li><p>Github-spacemacs中文教程-子龙山人<a href="https://github.com/emacs-china/Spacemacs-rocks" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/emacs-china/Spacemacs-rocks</code></p></blockquote></li></ul><hr><ul><li>EN-GNU-An Introduction to Programming in Emacs Lisp<a href="https://www.gnu.org/software/emacs/manual/html_mono/eintr.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/eintr.html</code></p></blockquote></li></ul><hr><p><strong>在线测试网站收藏:</strong></p><ul><li><p>各类教程内的在线编译测试和各类参考手册都很好用</p></li><li><p>CN-<a href="https://www.tutorialspoint.com/compile_c_online.php" target="_blank" rel="noopener">C</a></p><blockquote><p><code>https://www.tutorialspoint.com/compile_c_online.php</code></p></blockquote></li><li><p>CN-<a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">tools</a></p><blockquote><p><code>https://tool.lu/coderunner/</code></p></blockquote></li><li><p>CN-<a href="http://www.dooccn.com/" target="_blank" rel="noopener">代码测试</a></p><blockquote><p><code>http://www.dooccn.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/" target="_blank" rel="noopener">RUNOOB</a></p><blockquote><p><code>https://www.runoob.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></p><blockquote><p><code>https://www.w3school.com.cn/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/w3cnote/runoob-chm.html" target="_blank" rel="noopener">离线版runoob获取</a></p><blockquote><p><code>https://www.runoob.com/w3cnote/runoob-chm.html</code></p></blockquote></li><li><p>CN-Git仓库地址<a href="https://github.com/it-ebooks/w3school" target="_blank" rel="noopener">W3cshool</a><a href="https://github.com/gagayuan/runoob-PDF-/tree/master/runoob" target="_blank" rel="noopener">Runoob-PDF</a></p><blockquote><p><code>https://github.com/it-ebooks/w3school</code><br><code>https://github.com/gagayuan/runoob-PDF-/tree/master/runoob</code></p></blockquote></li></ul><hr><p><strong>CN-LFS</strong></p><ul><li>CN-LFS-仓库: <a href="https://lctt.github.io/LFS-BOOK/" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/</a></li><li>CN-LFS-v9.0: <a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</a></li></ul><hr><h3 id="社交账户"><a href="#社交账户" class="headerlink" title="社交账户"></a>社交账户</h3><ul><li><p>Github</p><blockquote><p>ID: Unit-serow<br><a href="https://github.com/Unit-serow" target="_blank" rel="noopener">https://github.com/Unit-serow</a></p></blockquote></li><li><p>开源中国</p><blockquote><p>ID: serow<br><a href="https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0" target="_blank" rel="noopener">https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0</a></p></blockquote></li><li><p>博客园</p><blockquote><p>ID: UNITED<br><a href="https://home.cnblogs.com/u/1927298/" target="_blank" rel="noopener">https://home.cnblogs.com/u/1927298/</a></p></blockquote></li><li><p>CSDN</p><blockquote><p>ID: Unit-serow<br><a href="https://i.csdn.net/#/uc/profile" target="_blank" rel="noopener">https://i.csdn.net/#/uc/profile</a></p></blockquote></li><li><p>简书</p><blockquote><p>ID: G鬣羚<br><a href="https://www.jianshu.com/u/b852f1059757" target="_blank" rel="noopener">https://www.jianshu.com/u/b852f1059757</a></p></blockquote></li><li><p>码云</p><blockquote><p>ID: serow<br><a href="https://gitee.com/serow" target="_blank" rel="noopener">https://gitee.com/serow</a></p></blockquote></li></ul><hr><p><strong>国内的云服务平台</strong></p><ul><li>华为云: <a href="https://www.huaweicloud.com/" target="_blank" rel="noopener">https://www.huaweicloud.com/</a></li><li>阿里云: <a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a></li><li>腾讯云: <a href="https://cloud.tencent.com/" target="_blank" rel="noopener">https://cloud.tencent.com/</a></li><li>网易云: <a href="https://www.163yun.com/" target="_blank" rel="noopener">https://www.163yun.com/</a></li><li>百度云: <a href="https://cloud.baidu.com/" target="_blank" rel="noopener">https://cloud.baidu.com/</a></li><li>小鸟云: <a href="https://www.niaoyun.com/" target="_blank" rel="noopener">https://www.niaoyun.com/</a></li><li>七牛云: <a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></li></ul><hr><p><strong>LFS-金步国</strong></p><ul><li>金步国作品集<a href="http://www.jinbuguo.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.jinbuguo.com/</code></p></blockquote></li></ul><hr><ul><li>EN-Wiki-指令处理(Category:Instruction processing)<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><img src="/images/GNU-1.png" width="60%" height="60%"><ul><li>图片来源于: <a href="https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83</a></li></ul><hr><h3 id="GNU-Linux相关URL目录"><a href="#GNU-Linux相关URL目录" class="headerlink" title="GNU/Linux相关URL目录"></a>GNU/Linux相关URL目录</h3><ul><li><p>Linux Foundation<a href="https://www.linux.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux.com/</code></p></blockquote></li><li><p>Linux Listing of Wikis<a href="https://www.wiki.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.wiki.kernel.org/</code></p></blockquote></li><li><p>Linux 内核归档 (The Linux Kernel Archives)<a href="https://www.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/</code></p></blockquote></li><li><p>Linux 内核文档 (The Linux Kernel documentation)<a href="https://www.kernel.org/doc/html/latest/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/doc/html/latest/</code></p></blockquote></li><li><p>Linux 手册页项目 (The Linux man-pages project)<a href="https://www.kernel.org/doc/man-pages/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/doc/man-pages/</code></p></blockquote></li><li><p>Linux kernel 发行版镜像归档<a href="https://mirrors.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mirrors.kernel.org/</code></p></blockquote></li><li><p>Kernel.org-Git存储库<a href="https://git.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://git.kernel.org/</code></p></blockquote></li><li><p>GNU<a href="https://www.gnu.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/</code></p></blockquote></li><li><p>FSF<a href="https://www.linuxfoundation.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxfoundation.org/</code></p></blockquote></li></ul><hr><ul><li><p>GNU Hurd<a href="https://www.gnu.org/software/hurd/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/hurd/</code></p></blockquote></li><li><p>GNU Compiler Collection<a href="https://gcc.gnu.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://gcc.gnu.org/</code></p></blockquote></li><li><p>GNOME<a href="https://www.gnome.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnome.org/</code></p></blockquote></li></ul><hr><ul><li><p>廖雪峰</p><blockquote><p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></p></blockquote></li><li><p>Social-icons 图标</p><blockquote><p><a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">https://fontawesome.com/icons?d=gallery</a><br><a href="https://www.easyicon.net/iconsearch/iconset:social-icons/" target="_blank" rel="noopener">https://www.easyicon.net/iconsearch/iconset:social-icons/</a></p></blockquote></li><li><p>next主题优化</p><blockquote><p><a href="https://www.dazhuanlan.com/2019/12/11/5df04019e1c6a/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/12/11/5df04019e1c6a/</a><br><a href="https://bestzuo.cn/posts/blog-establish.html" target="_blank" rel="noopener">https://bestzuo.cn/posts/blog-establish.html</a><br><a href="https://io-oi.me/" target="_blank" rel="noopener">https://io-oi.me/</a><br><a href="https://enfangzhong.github.io/" target="_blank" rel="noopener">https://enfangzhong.github.io/</a></p></blockquote></li></ul><hr><ul><li>Huihoo-Free Software 相关手册<blockquote><p><a href="https://docs.huihoo.com/" target="_blank" rel="noopener">https://docs.huihoo.com/</a><br><a href="https://docs.huihoo.com/homepage/shredderyin/emacs.html" target="_blank" rel="noopener">https://docs.huihoo.com/homepage/shredderyin/emacs.html</a></p></blockquote></li></ul><hr><h3 id="2020-03-10-23-46-06"><a href="#2020-03-10-23-46-06" class="headerlink" title="2020-03-10-23-46-06"></a>2020-03-10-23-46-06</h3><img src="/images/serow-1.png" width="40%" height="40%"> <img src="/images/helloworld.png" width="40%" height="40%"><hr><!-- rebuild by neat -->]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-03-02</title>
    <url>/2020/03/02/%E9%9A%8F%E7%AC%94-2020-03-02/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="37e73649cb38ca7fd93e9b3ca0bd3a071970e072491b6c955f8d4bfb9c31d6f7">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546eebb84e514277c32fb4c68e0c68a19f7508a5647e46f762a6465ac294adc114f05e3a7ca450452c10ef84af16e8695a76e48e8b98fdf4b2fd379e51e770b2385bbccb0277a897645ff9f6f49413c102d685d54ded3609512bd8bd0f04d51e4e4d9f91b5643376b174b77faa88a0d19a54e09588398ff93ac3bd761e6118bea86afa5c7fd66ec7390b230653a2aca41444a6e8663dcccb9091ba2418f0c4dac76bc4918849c92410dc0c6462431a6a6c6259686f015d00faafb810660342d4225159adac67c452e0c59a075c729ba90f42fa30943c161a3fc9635989e957aab024b16ca6f3112b6aa7bf93964913e51322a9ed12ba4b9c7049e544abb669fab0e0d2dc651cee32668a96c347e556855cac5980ba6ba05e83e4fc450952d962f3bffbaae9df48be955e19628142881123302944a33a5629e83fd48d4923743fad94d2fffa936fa65214e7a53bf319f40bfa7c48f644780aae0c589ac38b4a147310263bf3390d6d37ac18a1a1c69a4cfb60567e744f2f560687050a0465308a004dc0a532e3930502419d2d14b203558c7d50d5e5097116fb0e5652dd0ff4e6deb95b6c84c64d4d60b9c56be26921ba60fd58a6ebfd0d126eea62c0692efa104148d202ef6347b9128e4964cff8baccd621f40920de87eefd65f566ae3ee912e48070a310496009613714b0c50d251b5fff624076deb7f96c48a7e5be34d629b9ec67d983071a14515caba8b4530c623de26890a380104f6cb9a4cf956ae34f58456164b2348b62a612217c249e41bd912c314201c35dd932df35068a6766b81ed2a5c670ee02da04845a65938ce37e35fe0041755ad788879ab26d2ef4fe9eb40ab91032c2e056281e7424cbf631d220e59b69f5a533c9bf34eeefb1de50a01cec292d7cfdf2244368d5b5c5351c38dcd98c2a8485f09710e8f8a198005f84f9b375ff65e75b2ab6d81bdb91e1f6c6a52cb66de37e501ec15300b9c1a796f233120dc682090cbdbda1fbd0f4e37d2d44474124c9bdabd0e237d6b4852b71c96966102598c16ec2e1ae181095766dee0ee193f6aa2f1be18f2631c0f5ec0b9f977c4df88f12a2ade905de248867c7eda08b5988ca0372a700179bf68ed3f27d9ee5db85fc75558e11bbd5cc1dbb9a0c95a7bfb071fbc359da7a1c7ff0e03ebc0182e6717983ccd64ce0b39b629e40eba7fff3a003a263931d20aa55a121ac31b2a917a7e5614e10a1727f45edb27c8fd1e0a0c072e70301967f64c5a048f725c5a022621432d661df701990bc1623bdbfc750961c48406c88f5939a88fa3d5c4ec69993b6941ae093e1514630db5680df81eafc9a8631b0a47fb7a5e60032c8955628a852f073748c0e441c95295b830b5caebf65bcf6c859a6b1276bf7743302ea7d12d7667cce15adaf53ed7370e1d2ce0a8e5590e747cf939144cb437516bef2a5ffdd1e80516dc47bcb4c474603617b9ad715e55899bba6c1400d23f7ebf3f11b9574b7311c2c341934090aadf8b3d4b45ed72961838440465adc4c1f0c1c1c87fc97bd9976674ef879ae451dd21c031b657bfbd708efa913e95c4f25e6104c76429a827683a65f66ba09bc0fc329792715b24fb9fc34345cd4d05511ebbb3e9085170d72ec2d7c2a3255e6530296351b14152b5bc7159ef4c0f9384733b98323bbecc6c048a1fd834c4d5e20a91e894d27b6df5777182ce270352705c5afa1e063c3c2e29911afc017cbe8deb276837068a5aed7deb9ea74736549968cb3b3c55776e3b9eb0d67ae9b6d974a8f747ad3234a9711ec52f8463e3022123179a7200e086ca23bcdbb92f9ed4ea0afc152c79b1e7b1b1ee39bd6c8745e305a0728f50035e17b98a1c5b6637df4eb1697cf83c176140e19bad3a951b23edbc5afa2afef3bac349085bfee0e6ead9f78af981999483a9507688c6048d6fccd1d19e4b9a75d7d97a62dc6cc60bee8f7ec17649c1fd360116ce7687807cc9d61a51835b196dac926dd5da59c77aaa45ffdffe82a45a47e9ac2c3bebd0e5457b9d6009e9ff531be189916408768505f8ffa9f6b1f7097c29665d9c6f8712a98adbbbfd7399335fb5a0245db87c0f881baf7f9d7295641e95fff973059b2a0aee3dcdaebb7c2e160622543b0ada58d864f07519b97f7c4b0a3070519156fdf18e415ba6c526b502e8159c3bb15191dfa21f0b29dd7dc5723ace3cce74aa0e46a85277e947dee5b80021dab6181cccd4f75a298f560190bd2ae1aae3b9d15341b3a39c16b2187155f871eb24f4ef04e9c8d8fbd277a946614ab6e0a9026ebfeb5c06bac967845226dfb6338d711ec223a9f5da142e0338abcd2449858a43f8aaaceda189e3dc46022da0ed85ec04a7cad4f2c771aac08412f2fde44db1e1578fda347ea70d1be7aaae29937b3fc53a23f0eabd857d30e40ca760380e27d3c8c446f218bea2044e62063033787dc124a53f26cb92c169c471bf681d1d53c4ea4be456a5aa7fe0b425a05b4527959c215fc87d5c2077d5f472f498d5113c1c9cba387b442f7d59c37b2bdf3cc17cd5a96ee21ea3540bf2fc97094ba513dfaa4e9c510dce36ebf3b64dfa8e25a22f72db8eccb00e4019309ec01fb8ca33482651b5577a00df6c293f3abb2f51ef7a60537d6ae3952edff50ebed2507873ffa5e91ee3cc91e10b1da0486de58825d95017ed6a14f2f770f860e0896feedd6ac2f28760efb360df78c729e4429c28a1bccc8016f50953e42b53cfea33f941ebd6d1bcaa308421503348d644e474a66efbbf52d139f75886258a37f8e105b8a3ec29af292bffea6e9923a75beff945202498bbc0994e0986fc462735652326e6b155ccded75f890e32e551eaf8a90a00b05a541883d02d46c8ece36e84ee9ebce741a140207eec7188c19db2758f18bde9923c462be697075d2f216b3eaec455c5bb0f46ed0c480919b7f65660dd21868e8ac721aa590fe74cde4e58c018945915a4708c6bf49a5e56840bf4e1330bf9332ef01977339ec90bb03d3e294562b9c5cf0f5156709a0298ee3d5750278def25fe19512d11a60a9db70f0cbbafbbdcb1b4f0ca004d05fba0a307aded68e8d07fd6d79f5bd131d6be06c3d45bf11676db6999a04883337e289033d2d5d306db7017842e23a7d37f9231091a421f2b8ff4bc8d0339299b4ef0488dd09d90c420bb497cd51e7c35c31f8f7b9a13a654814200d669d9b075011e29d5dfaa2b0b33b4a9b3596a6992dce0dfd2646744ef4d16e09b59066a3640adc86f4d757cb1e6855e7094ab43d559868d5e4bbceb993e2c98404fe8e9ed45778675bd4bbc1b0c391e05cab31d064290c0e3ab612ba5fb1d9d2ad1ce28cbd240d800a0efab659c1dabfb325c26d3f1569718cfbeb62e19b14aa9203c33985652612e55bb564f3999f0553f9a0bce17d3a6b2d380a51221c8948d198a3f80aafc1ff2dd14e7d9638a5b76e93fa55ad707d29d7d6d7309115fb4d25a5b6e1c8cc07417af102659cf751bfa2b0cfa0898fc49e0a2a7c672a46782e70ae55d0053bd95f7459845f202861c02b27f725805fb1fb57017eb3f6cca444af900eda9f7399a9a087e2e9fa49aa0e1d752a69fbb98532707aa3c8cf9567698433ef608bd4f7f4f9bf0dba645bf92dc0943bbd5d0203ed7995ca1157602071650953f2ffd0affbe00a5cc81fb5986906887a1f668e8f9ad83d12f3f3199ae79ec7278be6c755f855223388a5ef1ba7dda2dfd7d01f14dfde7db65bdd63e1fd9a1f4972de6ac0cada20ef6e789e6ad8e4d39eef4bf2130b33c87d7785893c1769faafcddd14acdcb6a8871cc229602ee953a7b2fc00f433d3c8b89a58b274012642bf73bb77e36877af65329bebb88b3d9d92b6e343bc812f8234952e0c46f823adf9e240ec2741cb9656888ba6044cf19dcfc458106754d7f0d1361aeced77eeede5789c93e33123f41031de6fa0dc4afe147a3146939070273529c54a97c72a60eb340d0c517cb23a6afb50b8b338d220684ce472c6dafa49434b3ae36fdd160c72a2bcea3e394a957043153537d2f875ececa28b7d1ef98c22a62c554512ae24c90671b24de140ebbd8691a624ccdaf74b982fa73304dd9b955bfadba3d2f7e16669f6d4ee761e77b85297973e6940d149a75084e5e170f365b3504381f4ddc84c4885eba39af32800e8d4aa76ba6e722cf04ecb12c2414777b62c7af906f58ab2eb0544e10aadab1ad3ef3c81c4930d4406dd126f49cddc6c1c4db3174b9ab39e7a026d8e08bc0478e55c4ea299f3c84270334a401539e113aa181f756153c96708996f6f2f850c3f7b765a482da47ca7e3ff0217ed0b07211043055eecae69a2434515917df70143618b20225fded8efa99fbbf58d385494be613dde12792a9b906f99f7100094513913fe83a9ed6ead653b24e988ceffe7a1ea2e08fa2466eb1338d62a384019f07cb690b660d6463986987655eaf249034bf3a63eb195b59ed484896949835a2e8b7796ec5565d3ef709e360da2bd8645109eae82b2e99968401808aba5a1b17e22777a39ccfd8dd140312b13d07cb7593c4780d62ddecfd4a95b8f881a014ed0504bcc552ff5fbe27c9d35908a6e8bbefc93a45d960f54a2a71ad8e014eaba5ed8c49a38771dc94e4aaea48b0d04aeca059d57780f16f5126ad3db63307ce8d368e4254694e2a199a31e9e051cbc4a073b876076f6f2e8aa12b501ec5a34ce0493eca8285f4c920c037314083975d1b05a35441868dec67d1f6300e780940308e4ee676c62dea02d961165c5ac4504a7051b371bdb30fc3be6340713e5a53545b794dee2925dee7d24571219faf20db86d876ea4751bcd122ae0c5bbe25b0e73c2539a85371104090b6dc3d8d2e7a67b091ae220bd897cc33763c0b7bae2cb2c1d0a7b054be9f89bb5e6f3fe9e6220a65ed3fd7a481b763f6a5219934cf28caf11d20818a8e0537d24ec006aece84e10a473be5af65a0f0f31a3f2c9cec246aafff051d3c88486560cc0bdc91666e0d5b3d04a17d275756dd610fc3884d9b712443cd8eeaab0e4a0b30df5296d4d4e7dcd59dfc12c2d1f5820c29baa4b444cff14aceb27cd121fdc3f9a71774905c8cd3bc06716759f3fbe678805afd3a272521b24b2946e1de160b1599e9cb56ff19fd1c9b6dd43959d2c28a5895a081c43f928a11aee70621c5f305974eef2c05de20298ad6baf03d4528202e0bd1a8c35ba3b235dcbf776abf1b35e43b355684cb43598985f7c3693ea69d7a1604b48c9c825da998393f600054ee1d3c5728f33c8fd85f01127e36ae5b04d2260c294f88501d4086ec952d5ef451fbcf6718974a7a8ece84fd144615741ec72d4958aae5506ca4f0769df8a3797259eed119ae49cf82c7fc4c6e9d7348acf009f70fd2bfe2b1b6dafbefeae760f5f463031e9ee85a8439e925a9128fc8c62dc11ed1cf16a68ed3845e36914f85045f8db924c7cf938a0324eb58996e337a27ba122341ae357d131c8c1ba479aabfeb10a6b0b1d182f3ac754845a417fe60451ae1e19df60b7ecd4d45dc2e375df847deb87099eb326fdb7ee58aa79ee3a1e03edd948cd99ccfa439025444f0eb5f29261b4d7f456d22fbbd77254c05f1a66a5ef65b741a20a0901532b126a15cfa45ff017aa7283bf314a7d92e87f91ee4aa9f74fc0894e1538a9f63241773219c907c7ddaabc981687f0e8e9727fd2ce33957bfa08fcef06610bec39cb625ce6c65540ca180d6cffc5ece9f44ac372a248bfb89683a6cc6325d7c16252ce135d16c8c516b51580d7b6a7424ae66cdcdf4931de95ce5868b25b715f1fe9a72fdd8417bc8ad6c21a00514154bccad882047b682fb3c9e3721dcb5245e05391a4b9a28456928876ec4edbd282b8ffa80d35b3d22494784e949096a912a99cd385c1959a2e6a54123a649c86733ed3f2485f06f685e5335485a4a0a86ce3f44abe816db653897f2ff5b512d8fc3364ee99f4edd41661ef9ab05d2f1a9c58a1b6605439dba6f0161402f1b75ded994fe13386ec539839fa0baa6d5719cc94b0c25614db592f0f55c43d92e1a979e313b4a8b69c48c89481379eaa4cf9dc522726390921deeb6ffa7585850a2a79681680ed69df4da909f0eef37ccd771fad520c3c9f83dc998c5e3ebf2f7e55a93e5ad59175da364f391ef9668b7090ae6935371ae72948b5252c9f01d8fe56535e7553abdc5492d146773d6c37f64ceea3e957d09b486106eeb6810637b811a759d7ffa67da4c42f3cfa5af4f4a587950e6806a3dfb0d8dd20533fcdfe7e7062dc72485906d0bf08ac8ec00d0353e59325e06d149d60f76347c741e03b2fb5c05f5c85da7609d69db9f72d005ee17e7f19c28fd3817f448e6b4505597296862693b2feaf5e3cecd2a3819a171dd8b4e47ffd1e30cd60567d329bd1daa41c749f2b318ded451d40406a7bfd2cf258c9026ea2a27196c3d958a5306fb28b9e8ccc6947d55dd5c4346734ca77e3883e47ab01e7c0968f66fc39de2c2a2e4d1c8b7af317c31cae3888ce68736b1284cd2ec213f09c22ee0824d5d61a6b75e49d8c08a53ae3a6334919de908b326930b9ca55696af5308d20a3d69648f992e73987b6ba4956027b727de42640f7cbf7c317ebfccd27581f8cf977762eafebb218cd6407464471756d1f8273c23b5d6da42e8c0c8ab20906c334329aa07f56c03d5a6e0011db7955ba579394deb617f254ea1f73302ff54bc1835cd24b2ad8c26895db9a957505aec31608f2d8db15d256583bb2075a33562d052fed443fd26a8e3b3f07fce14798612191a8723f79fd1e6bb4ab96ae4094571f41e41ef44079c999c029eef587e96ee0c9ed14bf29b3e8149e813c79f20a0d5e3e4b64d36fed8e4a65743779475f88c27561c92d54b0cc850f8bcf2374b5cc709eb089ee5a6f9c9ae393347f27f46978418c8359ef5a2e29dfcde052880c769f6dfa5dc705c261979ca12039fd464bce9740dd41b8ec6e49352aa5d206681124cbc26feeabbbf20147ba6d3ccb50470a4fde25c99016d6f0184bc62aedc553c21423c4fe05d9c706a4364eb57345f5f31aa253bfaa4b64dffcdc27e7076c8d9e71018ac236e6b422348a20d7c0221014b912cba28a717b0832c6d155fe1229e8763c383cfb4ff9810938ebd0f80f4a8a63316d71cd5f57e0d4643d96adadfbb375179666c28fb6f1c98b93c467c4a95a29f71e8d0b0a800566d5ece3d1a903ba929cff524bbbc15604c2b9247e020d4ad1a4e48189f96c0144b2f24a0c3940d470414b8d472f9d70a54bc00b28046c2665ab155f1a0fbd3e4043be84e8d66a86bbbec79b3853bfd9c787aac7ff6e49f9c84ec02c61fa8b09678b5600aadfed8acfddb7574ae4e5189eb2c283ebf7414b6b33ba2f393277ca0f543eab67df53e2eca8136cd417fdc4e06c7569523ca7d07f2a93f40b547a7134513ff66c890bbd7a40995f713ca70fa93561bad3f64cb154fb1dd7994a919b0026a85edaef0eb4512bda2142b7cad7e80062cd8190bda46d9be9ad0c959701ee449f0d150a7335ab748383f82fc48d7d0d348289cdedd67aa07c3e20d9db45d88ece45fbbcc8ce7eb68f2a72702ea61232206b56a4d1e8e8f7671e4229a998911afcb391c6453c6ab0b25ca39a10bb73a33951e5577f6559663aa5ed51a5463b6ef7eb08d1fd3f17103a01a0ecb9e4cdd42116706ce2da95baf6cde59aa7b9c0fcdfa17af8bc58d5cbbb5909d8a94cc827e5ebceeaedc182cc7f51ae46fc15ce79ce958c379bd39ac9c33f7b0a00b9798392d476be9d9ce58adeb4c0c1c71c03ca9ccfa0ff2da66d46236479a813df8fc829e1c9eb1857e771cbc96d25d28b001feed29cbee36c7ec98dcf7a952392d30b65cf1fd505f916b2656451ce189b7d49bd665743550122d200f94cacf72093530e9d0de8bd3d0638c1cd3e36d11c1cd3ee65067d122f253385993bf00524101988e01dd1c0c113347d0b1aeafb9b43eccaa15de32fbd0d5819a751779c9aded1e87425c7a1090a447cce87763fcdfe83cc64b587fd3f6229e97e218d9a7b05667611314696c19927c6e168f988a10d51f30ef3c5ff7396c55324eeaf9a9fb904f10f814e378e61e7a4754c6b1cebfb2a841a159fb2d5569e571e8c63ca2e582e548eb5b9c2e76a4ef4eaa6550c307463a713e4b67d2e4ff9946b6589046673e4d5c40f7e82e874be859760d5a96e5121a4dfc44a5275482f0058602e0becfdf502f2d07a93335e9579be3e9cd397ef223684485b8a96f2beb0cf381bab5d44df06b626f01b673ba34163b40b2964975afe9d4fc79af77b1f354bb0a085c83b43d14d9f632548464053e6d1a50a9b06f01cdedc38f3c0276e33e83c4bbf06813d4381f4bbde9e4f43f7a0f33c05ac45d7eafa5259ceeb5c52697788898c728ce7e77491b67c514675a071405a6e8523a9540f66243409a5559fbad5a4ac35d2321b6dcce36c0cfd3cc9c33c45a830eb19d1e1716109b1840087036599c50669b3eec8f8e990d4fe24a082b956091e13e4d816aa61f23315d7d0e3ca5a8ec1278ba0642cedc04b65e60ff2cf53f7c0e090aa91166604561568c414ef9df0515922cc8847ed66c07633fd1d46cc49cd761215643a3acec08e770785f15812f3bdacfb99d8ba3876ef5cf3aa3623c431b53057aa5bb08e928b8c3a0d31e76094eed5b1299a7f6ed684e3afcaf240eeaf5d0ef64eaa4615e2bc369f96cc6cf752fe1dc8711f48a056750adf28af3b83034c978dd7028a7795b3768e0e2cad04ae1dd9e49b190912866058a9feabe2b68543cb967c26b69199d49b5ea54c2d4680126aa4925f209243cab2fe15117aee2274c88db879c445d068b3f3df9176128d5c957472c74608289087814ed9112c7ec956912d89cad6ba6d29cfff31f36eb45c342bd4037f2926919f2c7be4d0384784c7fa41ab6e854864169efe98303d260b1472804c8894e0a3f34166284bf0c6fbf9bd9cc686489e61b2db375d15510f9532b3deca4410ae4820513af6e1d6a83b83d6d6da9c9fcea16a62bda2953e3d49c24ed2bf80d0089c57d1c73f7e7d544a257c89f39c96e4cbbb5ec12eaa32e8177d54fd43c60eb5bbfaab7d96f08f2ad43e672f2c0d393f7ba9da4407b4db65d891510fa519868362534a59a25eaa0d5d0f1a0b62579c9bba9e13a02d6affd289eb4886502395b1e9af0a4163692a82e58431ff24a2aab6368b464587a2d4865f43e3bf66c5be5194e0f48b4c64dd8e8a6ee0a6a7b552a8a748a5c5105d93ea052b5925448eab7ba02df1cdb27ceba944f923b5639f2eaf5c60dbaa4f40e240ac3f6213af46be41d69ce93727487e0666faabb561db86e7a6f47ee53cfd670639f9c08331fdde8f7768e9d8647ef611f620b8ca704587a1a0f9270e0e39e27b7851c0f64583ed7d67d6ad3b16ac617ea34863e85c48b7b4cbbe17060d3ac57db71b38f65cbb7b9552bbc4f6c5ff14c7dc036010acbf21efbaf1bac885567dc6162e4c3330b52e12096a2f38c677173bf82fc69bd17c94674d9993418a180630014c4e8ed94aa0eae476bdf5d87245c247268bfc7cde9b5dce4657f58369145f0d5db6dc5ecb0ca52d202b3e53787f4d58146af767f7a54495089f2c1acaa7b3bf418ee6a5f3694067dc7ee034e4381af4ed7ae64b24aed67652f1626747ec0e11e88e22288cc2e4fd69b7fe18fe8f9a1e4de4d08bbbd61d1f03b1370be8430650babab0b30641a6ed116b5d86f99cb4d0fa3fec8c258d8b4bcfa2a30128180a1603d8965c95504608a6253b81a0cf660ddb3ea0c7f2e21d2ffde0d85589ce0cceb470459dbec26c22c7a2800b1112e1b6fc8fd9dfac7bb49c1ce2f7a76638322716a44e71084790f8cd850e716ff96694e042b14314bcf1958dcca343459c47aeff96a9982dbe2b7936ae08979a202675e8eaf3c27400723d12ce51de689a119a62bdc013a56bcc681fd619fa0bbc3dd5cb79c21fde978ecc2fc0b68b30c012d7742704f45a17018150065417a2043d010fba740c472590c1773a95ab8ed095aabff86ea7556ce7d4c34577f7eb6a4e986da862c929952d089fa63f916bf56a74245c2c9d76fe0a047dbb7ac100d361076c5df0bebf91b2480a6c9eaadb6bd7623e215eebbb13e46a8c929b5cfd630d31f6bdd34e511b66e2a8a51da23683a1b4c413d5b10706d8383900788a79ead0f352006af743b401fa8d0bd0dbdfe55aba098be42c3f25499f379ea8cbf07fe98ba5359145834ad69608fd1acb30610fe4e2baf0c8d82084dc871a6a516e9539ebd872b3442fea581d480eb153cc6a826dff40a37e65742ba7da947a4c789684ffc5bb21212cc7c80cc85ee6aac77a22b1f604c1b834aafcfdf0294cbaa438993d8da16f72989cf36e1bdb677422630b952752da25b6d759ea54ef075090070f1c37ef75e8f47a8d79b2ec2cbe60954932a730baac2befb1b2cd6efa8d2b00fffa9903cce37ff0bb4db812c399cee1c6f46df9f850be9feabaf6420ab3d4da2a254f8d6d554b6fbbdd568e4ccd636236e907d027ba5c8e9e41cb415628016929fa88a7c97476f1e3fb4104496d5afcabaa023f9f031f5bf186e3c76c94fd57ec2cf19d5fa5b0727815c230d773b7b4840a0f8659107d55d222e501d54a79445ad3aa28023ef763c895d063bdb6c2e59a4bb7d37a504da379d14885c0ce10ae8d08ea5721d167dd810300bd5448ac87cdc9e018b50652906dc12f8bb02fa2f354e9b1fac9b5456b72ed6cb13ca4349f2f301d04c4188b9380703005471f7a29598d5b4946118ba7e93ac788f67adae26b88e68d149984077dbbe6267ba30e0b66e745bd87a0862813effd3211962bd657abc84ae925e6e07508ecef8b3c3a4e649ca51513b7bf6e8c387d258535cf2745e8e8bec2991856117f451153586f73c194710f747de84b834956e64968eda91337775a8d0e3eaf11481762d9ad5780dbd80a28f2c214700a7b8a421da252df1f8359e1c045f582cb80507b1ebb0956e07f8afd4a98ed53bae640ef9d59fbc31969eb4aace27cdeae20f911e436c525902fa0b8160e763143f59aaa7f23ff3a6c51fc5fc6ecae5209b5ec0de38eaa1176cfac54c91ab492a882a139c33e7fb4fab1ff638b6ba161be0b56ebc695ca524c7f795a076ea5f4dee2c4b0af623c14356991b09e10a786489b28910e38a7be3c1b1286ae73111fbde1af1244b2c14b118bf68dd493b5b7475b571f408f0ab3e32805ab063a0705940a68dd0f7a26e47a3592d5da4b42b1ad364fa09b71975c16eb5e030529e58681d7b0c8268c1b57c5b329765d3baedb5ff5d23db4e624e282f3e2ab3f12ce0438e9ebf8b99d1d596956e002e849ea500f29646bb185ad06c53490aa65623b73960879282b405fe084dc49e02e2d4125e5192173c649e1862c938b52fc936ec3b18be66a3c39d95f4c7886a8045a4541315d0cc45a1b7b51671416b2ad3c67e2303332c488185b08be5f05cb824a67f9a727147e1c63471887bb6ecb7498cf8cf24a6b2391cf56714da58605daa5d9158017b575cb65d56061ea32b14a5e3bcb0da5bb8d500ae1884bd712274ee0dcc543e949733056014d8c32b10505abd29781ae9c41826b38b2657c455e327c406fdd9f6f655e6ac3a0e0fdf12f14fdbf8bba2c1a4cb1096260673cb9134ca947a7d0b41d88ccf1f78495793a76c447fdb49a31a822301525349ab230f15b71c58984fb44709a5ce127538f14bb2e31f73289ba014791e3769bff133d77a20cb16ff183c46daddaefb57d3389df8a30fe99ecacbc73aa256dc6ac525fd26a2fa9b0ca0f7324ed52b4b413bbc4df91f0940479d556ee473c8a5bbba303e2bde65974c9bd7b3925ac20e04913b8acdfa575247110648ad8ad5e41498bfa4b246f97027092e21c81c5eee276485f2ccdffb467fe666541250c9ad971558cc6adfa3c659edd9595983973a84af6d816277e420800bde40dfe27b2d7ffd98cc1989a0b2a1de83d0f99109ab099a7fdbddda45736b60b96f22385e5df0011a5ad6c2b8d16fb230602453323b08a676dcce78055a44674657ca991223188d48dca64d43f80dce657d30437bc0925c5a63daef273fd24150877d59442e253d52d42c18a05315c198e793465ef8298712a4c6d426f101db426482e210fda8fe02186f7f4b2d260f1b09e81b6d51094dacb72162acd6150cec80f6c14d52b1c8dc0fef95c42d71ccdadff72642d3a6a40259730ce7be2f65d147b99856b11b1492d10c8ebc15783fd5489bb34702b91ad9c0455e491940381a7eb1a69fcc3cb70044830bd7f3f9351383d6309e3e96e1d291981f936cb63468f64fd584d7a1808a842c11419aea26f098b4ff7718405168d0738cdf5300c05b767453d867560ef798aaacd97781b1eeeb05f09c58b98799ff57c4574df01e8259e958c660a4df4b1205dd24e35df7e2cc543c0e881397f3e420fcd9bac461d528328b992be6c54d82876504a251a700235ff6c124217c03934e2ea4e7c3e664d87ecae7120f23fc5e68aa3045d36ce0725349df4f387d1ebfe6d35754672cb7e81b62a621f96a4e985cfbdd246de37920c96474658dfaf843251a127a2c9f0c47652f2696c954bdec0b0951abebcc24e9972c56a26a19cb30bb1d4b5ced2f16e61f6585f31eced6c45645bdd1be41dc1fcfd35a24aea6c8225f80bcab5cb0e2c45799ae907df0b6f3973050ae21f55844e8db8b9fa6f3569de38150b149a0b0669e969b61bd4eaccb80bf59d1525131cac152d2275aebdc334e405953e8bd0f1be470c10eec3158f5b6a78f9458820cfd7323393419254c9e3ab242500664ec1111502681352c2bbd84c65194863bc29c86ebb3d4144520c54fb3261a4465796e51641c1a6e9388ea6cefa665f5264e0aadd1c2419760f535755aa11f375736ee4f4b6b81c1100888e3785a6a7663013ce98b3456d9f3b06791ba70f5ef6ad2aec3297174cb5218c9d31cede3aa579a8781b0e389f2dae0458d09fc9db27e5f5e19c7edad6692f144fa3d92715ee8b123821812e0c129d0e33d99500d24a02fa59f56941799fc37abd2d6f65a696b052f240724296016cac89fef1582fe3e8a859eed086169a8e69a3aed44b229674184a902dcd8eb166d9a19ea068ce566efa84e9c587193a30e7e4887c97fafaa5f2c2ee292fa4c5bd772b1f7ad0bb57e140979165155f7268e6148093c9630f5b24a64284a8c6f87863b137628a23707fe942c4cb26a041b9cf913c0c4c12337df26f9b53055d02008d7fc14bc5209b7572aa7d6daa385e0fce617e5a3376b9d265b9ff8ac069843af639d0345af1e39267f0252ecd334fbfa04b5ac252d7e6aab1a30d7634ddbb336e4f2a710b48f3203eeac67405a1a3d8d76e60470b3a9df36e7db134b1acf090ec9a0c160b9e983c4f4e652cb94f810283e972f4e9cc94dde8f47588597a6b97d3685e54d31720db5b4eae17ba1ee2b96181378d603048e25d6b709d1c23f0f8b55a157c117b516a66d9fae375510e061067d4c4f54d2998f7e726618f012467406069a7225da518dd55740e0b82c8444e3b28f363653cfe3d4cdc25b8772ad1d57c446d2379d0882dad1b9820b4ee56f6701f8e47c68c5857963cd74fb10204fcf672eb7387496abd08e3519464e0e0babae352d2625fae387354611cc99d112e9bbff65c365e66c23bc71c607aa21d5045222da669</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU-LFS-3-3</title>
    <url>/2020/03/01/GNU-LFS-3-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-3-3"><a href="#GNU-LFS-3-3" class="headerlink" title="GNU-LFS-3-3"></a>GNU-LFS-3-3</h2><ul><li>系统转换过程与细节描述</li></ul><hr><p><strong>文案说明:</strong></p><ul><li>本篇文案用于描述目标系统环境的最基本配置与对从临时系统进入到目标系统的各种细节的描述</li><li>参考文献及版本为LFS-v6.2/v6.3</li><li>描述主体为LFS-v6.3，LFS-v6.2会有特别标注</li><li>LFS-v6.2和LFS-v6.3的内容与执行语句通常没有本质上的区别<blockquote><p>多数都只是执行顺序或者深层的处理逻辑不同<br>但大体非常相似</p></blockquote></li><li>多数指令在目标主机的chroot环境下进行</li></ul><p><strong>目录简述:</strong></p><ul><li>系统清理</li><li>虚拟文件系统</li><li>chroot环境</li><li>标准文件系统(FHS标准)</li><li>用户与用户组的基本配置</li><li>参考资料</li></ul><hr><h3 id="系统清理"><a href="#系统清理" class="headerlink" title="系统清理"></a>系统清理</h3><p><strong>临时主机的系统清理</strong></p><ul><li><p>删除已经安装的可执行程序和库文件当中的调试符号，以节约空间(大约70 MB)</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code><br><code>$ strip --strip-unneeded /tools/{,s}bin/*</code></p></blockquote></li><li><p>命令会跳过大约20个文件，报告不能识别这些文件格式</p><blockquote><p>其中大多数是脚本而不是二进制文件</p></blockquote></li><li><p>这里需要注意的一点是千万不要在库文件上使用<code>--strip-unneeded</code>，否则会破坏其静态版本</p><blockquote><p>如果已经是过去时了的话，就得从头开始编译全部的工具链软件包了</p></blockquote></li><li><p>删除相关文档文件(info，man)，会节约20 MB</p><blockquote><p><code>$ rm -rf /tools/{info,man}</code></p></blockquote></li></ul><hr><ul><li><p>到目前为止，临时工具链已制作完毕</p></li><li><p>这一阶段开始进入目标主机环境</p></li><li><p>从现在开始不需要lfs用户来制作系统了</p></li><li><p>退出lfs用户</p><blockquote><p><code>$ exit</code></p></blockquote></li><li><p>此时为root用户环境，改变必要文件的权限与所有者</p></li><li><p>一部分的原因是为了避免不必要的安全方面所产生的问题</p></li><li><p>将$LFS/tools目录以及其中文件的所有者改为root用户</p><blockquote><p><code>$ chown -R root:root $LFS/tools</code></p></blockquote></li><li><p>这里说明一下:</p><blockquote><p>建立LFS系统的时候，在创建<code>/etc/passwd</code>文件时<br>添加的user ID和group ID是与宿主系统的user ID和group ID相同的lfs用户</p></blockquote></li></ul><hr><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><strong>挂载虚拟文件系统</strong></p><ul><li><p>为虚拟内核文件系统建立挂载目录(dev,proc,sys)</p><blockquote><p><code>$ mkdir -pv $LFS/{dev,proc,sys}</code></p></blockquote></li><li><p>创建初始设备节点(创建两个目标系统所必须的设备文件)</p><blockquote><p><code>$ mknod -m 600 $LFS/dev/console c 5 1</code><br><code>$ mknod -m 666 $LFS/dev/null c 1 3</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>内核在引导时要求某些设备节点必须存在(特别是console和null)<br>这些设备节点必须创建在 硬盘上才能使得内核在udev尚未启动之前就可以使用它们<br>此外还有当Linux以<code>init=/bin/bash</code>启动</p></blockquote></li><li><p>挂载并填充/dev目录(LFS-v6.2)</p><blockquote><p><code>$ mount --bind /dev $LFS/dev</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>LFS-v6.2推荐的向<code>/dev</code>目录填充设备的方法是在<code>/dev</code>上挂载一个虚拟文件系统(比如 tmpfs)<br>然后在设备被检测到或被访问到的时候(通常是在系统引导的过程中)动态创建设备节点<br>既然现在新的系统尚未被引导，那么就有必要通过手工挂载和填充<code>/dev</code>目录<br>这可以通过绑定挂载宿主系统的<code>/dev</code>目录<br>绑定挂载是一种特殊的挂载方式，允许本地主机上的当前用户创建一个目录或者是挂载点的镜像到其他的地方</p></blockquote></li><li><p>挂载虚拟内核文件系统</p><blockquote><p><code>$ mount -v --bind /dev $LFS/dev</code><br><code>$ mount -vt devpts devpts $LFS/dev/pts</code><br><code>$ mount -vt tmpfs shm $LFS/dev/shm</code><br><code>$ mount -vt proc proc $LFS/proc</code><br><code>$ mount -vt sysfs sysfs $LFS/sys</code></p></blockquote></li></ul><hr><ul><li>在进入chroot环境之前，可以将<code>lfs-sources/</code>里面所有源码包复制到<code>$LFS/sources/</code>目录中</li><li>这么做会让后面在构建目标系统的时候使用源代码变得更方便<blockquote><p><code>$ cp -a /lfs-sources/* $LFS/sources/</code></p></blockquote></li></ul><hr><h3 id="chroot环境"><a href="#chroot环境" class="headerlink" title="chroot环境"></a>chroot环境</h3><p><strong>进入chroot环境</strong></p><ul><li>Chroot到目标系统的目录下，以便不受主系统的影响来制作目标系统</li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ chroot <span class="string">"$LFS"</span> <span class="regexp">/tools/</span>bin/env -i \ </span><br><span class="line">HOME=/root TERM=<span class="string">"$TERM"</span> PS1=<span class="string">'\u:\w\$ '</span> \ </span><br><span class="line">PATH=<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/tools/</span>bin \ </span><br><span class="line"><span class="regexp">/tools/</span>bin/bash --login +h</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><code>env</code>命令的<code>参数-i</code>的作用是清除所有chroot环境变量<blockquote><p>后面是重新设定HOME,TERM,PS1, PATH等变量的值</p></blockquote></li><li><code>TERM=$TERM</code>设定虚拟根环境中的TERM的值与chroot外面的一样<blockquote><p>这个值是让像vim和less之类的程序可以正确操作<br>如果还需要重新设置其它的值，如CFLAGS或CXXFLAGS，这里是个不错的位置</p></blockquote></li></ul><hr><ul><li><p>从这里开始，不再需要LFS环境变量了，因为所有的工作都被限制在LFS文件系统里面</p><blockquote><p>这是由于已经告诉了Bash shell $LFS 是现在的根目录(<code>/</code>)<br>注意，这里<code>/tools/bin</code>位于PATH的最后面<br>也就是说当软件包的最终版本安装之后就不再使用临时工具了<br>为了使shell无法记住可执行二进制代码的位置，需要通过使用<code>+h参数</code>关闭bash的散列功能</p></blockquote></li><li><p>此时bash提示符会显示: <code>I have no name!</code>这是正常的，因为<code>/etc/passwd</code>还没有创建</p></li></ul><hr><h3 id="标准文件系统"><a href="#标准文件系统" class="headerlink" title="标准文件系统"></a>标准文件系统</h3><p><strong>创建符合FHS标准的Unix文件系统</strong></p><p><strong>创建系统目录结构(FHS标准目录树):</strong></p><blockquote><p><code>$ mkdir -pv /{bin,boot,etc/opt,home,lib,mnt,opt}</code><br><code>$ mkdir -pv /{media/{floppy,cdrom},sbin,srv,var}</code><br><code>$ install -dv -m 0750 /root</code><br><code>$ install -dv -m 1777 /tmp /var/tmp</code><br><code>$ mkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}</code><br><code>$ mkdir -pv /usr/{,local/}share/{doc,info,locale,man}</code><br><code>$ mkdir -pv /usr/{,local/}share/{misc,terminfo,zoneinfo}</code><br><code>$ mkdir -pv /usr/{,local/}share/man/man{1..8}</code></p></blockquote><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">for</span> <span class="keyword">dir</span> <span class="keyword">in</span> /usr /usr/<span class="keyword">local</span>; <span class="keyword">do</span></span><br><span class="line">ln -sv share/&#123;<span class="keyword">man</span>,doc,info&#125; <span class="variable">$dir</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p><code>$ mkdir -pv /var/{lock,log,mail,run,spool}</code><br><code>$ mkdir -pv /var/{opt,cache,lib/{misc,locate},local}</code></p></blockquote><hr><p><strong>创建必需的文件与符号连接</strong></p><ul><li>一些程序使用固化的路径(<code>hard-wired paths</code>)指向一些目前还不存在的程序上</li><li>为了兼容这些程序，可以创建一些符号链接</li><li>然后在软件安装之后用实际文件进行替代</li></ul><p><strong>创建必要的符号链接:</strong></p><blockquote><p><code>$ ln -sv /tools/bin/{bash,cat,echo,grep,pwd,stty} /bin</code><br><code>$ ln -sv /tools/bin/perl /usr/bin</code><br><code>$ ln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib</code><br><code>$ ln -sv /tools/lib/libstdc++.so{,.6} /usr/lib</code><br><code>$ ln -sv bash /bin/sh</code><br><code>$ touch /etc/mtab</code></p></blockquote><hr><h3 id="用户与用户组的基本配置"><a href="#用户与用户组的基本配置" class="headerlink" title="用户与用户组的基本配置"></a>用户与用户组的基本配置</h3><p><strong>配置必要的用户组</strong></p><ul><li><p>以下区块为LFS-v6.2独有</p></li><li><p>一个常规的Linux系统在<code>/etc/mtab</code>中有一个已挂载文件系统的列表正常情况下</p></li><li><p>这个文件 在我们挂载一个新的文件系统的时候会被创建</p></li><li><p>因为从此开始在chroot环境下不会再挂载任何文件系统</p></li><li><p>所以需要人为的为那些用到<code>/etc/mtab</code>的程序创建一个空文件</p><blockquote><p><code>$ touch /etc/mtab</code></p></blockquote></li><li><p>为了让<code>root用户</code>可以登录而且<code>用户名root</code>可以被识别</p></li><li><p>在这里需要创建相应的<code>/etc/passwd</code>和<code>/etc/group</code>文件</p></li></ul><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>cat &gt; <span class="regexp">/etc/passwd</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span>0<span class="symbol">:</span>0<span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>此时root的真正密码将在后面设置(<code>&quot;x&quot;</code>在这里只是一个占位符)</li></ul><hr><ul><li>使用以下命令创建/etc/group文件(LFS-v6.2):</li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>在LFS-v6.2这里创建的用户组并不是某个标准所要求的部分<blockquote><p>只是因为在随后<code>Udev配置</code>将要用到而以</p></blockquote></li></ul><hr><p><strong>创建<code>root</code>及<code>nobody用户</code>和必要的组(LFS-v6.3):</strong></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>passwd &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>:<span class="number">0</span>:<span class="string">root:</span><span class="regexp">/root:/</span>bin/bash </span><br><span class="line"><span class="string">nobody:</span><span class="string">x:</span><span class="number">99</span>:<span class="number">99</span>:Unprivileged <span class="string">User:</span><span class="regexp">/dev/</span><span class="string">null:</span><span class="regexp">/bin/</span><span class="literal">false</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line"><span class="string">mail:</span><span class="string">x:</span><span class="number">34</span>: </span><br><span class="line"><span class="string">nogroup:</span><span class="string">x:</span><span class="number">99</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><hr><ul><li><p>因为完整的Glibc在目标系统中已经安装</p></li><li><p>而且<code>/etc/passwd</code>和<code>/etc/group</code>文件也已创建</p></li><li><p>所以用户名和组名现在可以开始使用了</p></li><li><p>重新加载bash，以使root用户起效</p><blockquote><p><code>$ exec /tools/bin/bash --login +h</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>参数+h</code>用于告诉bash不能使用其内部哈希表查找路径</p></blockquote></li></ul><hr><ul><li>程序 login, agetty, init(还有其它一些程序)使用一些日志文件来记录信息</li><li>比如谁在什么时候登录了系统等等</li><li>然而如果这些日志文件不存在，这些程序则无法写入</li><li>下面初始化这些日志文件，并设置适当的权限:</li></ul><blockquote><p><code>$ touch /var/run/utmp /var/log/{btmp,lastlog,wtmp}</code><br><code>$ chgrp -v utmp /var/run/utmp /var/log/lastlog</code><br><code>$ chmod -v 664 /var/run/utmp /var/log/lastlog</code></p></blockquote><ul><li>目录作用明细:<blockquote><p><code>/var/run/utmp</code>记录着现在登录的用户<br><code>/var/log/wtmp</code>记录所有的登录和退出<br><code>/var/log/lastlog</code>记录每个用户最后的登录信息<br><code>/var/log/btmp</code>记录错误的登录尝试</p></blockquote></li></ul><hr><ul><li>此时就已经完成了对目标主机的基础配置</li><li>同时已经进入目标主机的标准环境了</li><li>一下步即开始对目录主机进行程序编译与配置</li><li>进入源代码目录与设置LFS变量<blockquote><p><code>$ cd /sources</code><br><code>$ export LFS=/sources</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>官方-EN-LFS-v6.2</li><li>官方-EN-LFS-v6.3</li><li>金步国-CN-LFS-v6.2</li><li>孙海勇-CN-LFS-v6.3</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-9</title>
    <url>/2020/03/01/LFS-9/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="LFS-9"><a href="#LFS-9" class="headerlink" title="LFS-9"></a>LFS-9</h2><hr><h3 id="实现逻辑梳理-LFS-v6-3"><a href="#实现逻辑梳理-LFS-v6-3" class="headerlink" title="实现逻辑梳理(LFS-v6.3)"></a>实现逻辑梳理(LFS-v6.3)</h3><ul><li>主观理解，仅供参考</li></ul><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol><li>将原主机分区，假设分为两个分区:<blockquote><p>一个用作swap内存交换分区，另一个用作LFS系统制作分区</p></blockquote></li><li>创建LFS系统的制作及操作目录</li><li>挂载FLS系统所对应的分区目录</li><li>在被挂载的分区目录下建立源码存放目录/sources与工具编译目录/tools</li><li>利用原主机的root环境来为文件目录分配权限，同时配置目录的符号链接<blockquote><p>以方便操作与管理</p></blockquote></li><li>创建用户lfs与用户组lfs(可以同名)</li><li>登陆用户并建立lfs用户环境</li></ol><p><strong>建立临时系统</strong></p><ul><li><p>此时将所有的文件都编译进<code>$LFS/tools</code>目录内</p></li><li><p>源代码与压缩包存储于<code>$LFS/sources</code>目录内</p></li><li><p>构建GNU工具链内工具</p></li></ul><ol><li>Binutils Pass-1</li><li>GCC Pass-1</li><li>Kernel Headers API</li><li>Gilbc<blockquote><p>在Glibc在正确编译且安装完之后:<br>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils Pass-2</li><li>GCC Pass-2</li></ol><ul><li><p>构建其它辅助工具与系统程序</p></li><li><p>编译完成时，临时系统已完整</p></li><li><p>然后利用Strip程序对环境进行清理，info与man也可以进行清理</p></li><li><p>此时可以进入下一阶段</p></li></ul><hr><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li><p>此时的临时系统将作为目标系统的辅助系统以保证存在目的</p></li><li><p>退出lfs用户</p><blockquote><p>此时回到原主机的root环境<br>从此开始的编译都由root用户进行</p></blockquote></li><li><p>此时为了避免安全上的问题</p><blockquote><p>将$LFS/tools目录权限转交给root用户<br>可以将tools目录保留，以创建多个相同版本的LFS</p></blockquote></li></ul><hr><p><strong>首先挂载虚拟内核文件系统</strong></p><ol><li>创建虚拟内核文件系统(或其它设备文件)将要挂载的目录(dev,proc,sys)</li><li>创建设备初始节点</li><li>挂载并填充/dev目录</li><li>最后挂载虚拟文件系统至上面创建的节点之内<blockquote><p>挂载的同时创建了几个最重要的文件系统</p></blockquote></li><li>这里也可以将<code>/lfs-sources/*</code>内的源码包复制到<code>$LFS/sources/</code>内<blockquote><p>以方便使用</p></blockquote></li></ol><p><strong>其它内容:</strong></p><ul><li><p>系统环境逻辑:</p><blockquote><p><code>原主机-&gt;临时系统-&gt;目标系统</code><br><code>原主机-&gt;临时系统</code><br><code>原主机-&gt;目标系统</code><br><code>目标系统&lt;-临时系统</code></p></blockquote></li><li><p>这里要重点指出它们的关系并不是线性的</p></li><li><p>主系统包含于临时系统与目标系统</p></li><li><p>进入chroot的目的是让目标系统完全独立</p><blockquote><p>但此时的目标系统还带有临时系统所编译的工具环境<br>此时的原主机进入了chroot模式，因此现在不存在原主机的概念<br>原主机即为目标系统，而目标系统内当前还拥有临时系统的环境与功能</p></blockquote></li></ul><hr><p><strong>进入chroot来进行对LFS系统的操作</strong></p><ul><li>chroot</li><li>此时根据指令来进入chroot环境</li><li>现在所做的任何工作都是为了对已经进入的chroot进行补充<blockquote><p>以构建最终的LFS系统<br>并且chroot内只能使用到临时系统所构建的工具环境<br>此时所有的工作都被限制在LFS文件系统内<br>所以<code>Bash shell $LFS</code>就是现在的根目录<code>/</code></p></blockquote></li></ul><ol><li>清除所有chroot环境变量</li><li>重新设定HOME,TERM,PS1,PATH等变量的值</li><li>创建LFS系统的系统目录结构(必须是标准目录树/完全遵守FHS标准)</li><li>配置必要的符号链接<blockquote><p>因为有一些程序使用的固化的路径(hard-wired paths)指向一些还不存在的程序上<br>为了兼容这些程序，可以创建一些符号链接，然后在程序安装之后用实际文件进行替代</p></blockquote></li><li>然后再去创建root及nobody用户和必要的组<blockquote><p>以让root用户可以登陆与用户名root可以被识别</p></blockquote></li><li>此时因为已经拥有了临时系统内所构建的glibc和刚刚创建的<code>/etc/passwd</code>和<code>/etc/group</code>文件<blockquote><p>所以现在用户名和用户组已经处于可用状态了</p></blockquote></li><li>启动新的shell</li><li>设置某些特定程序的log文件，以保证这些程序能够正常写入</li><li>最后进入源代码目录下，此时还可以将之前复制到sources下的源代码文件目录设置符号链接</li></ol><hr><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><strong>建立目标系统</strong></p><ul><li><p>此时将所有的文件都编入当前LFS主机(分区)的/usr/bin目录下</p></li><li><p>GNU工具链内工具</p></li></ul><ol><li>Linux kernel headers</li><li>Man-pages</li><li>Glibc<blockquote><p>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils</li><li>GCC</li></ol><ul><li>构建其它辅助工具与系统程序<blockquote><p>当目标主机最后一个工具-vim已经编译安装成功之后，开始进行下一阶段</p></blockquote></li></ul><hr><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul><li>此时应该先对系统做一个备份<blockquote><p>因为此时操作此系统的人处于任何原因的手残或其它的失误<br>都会导致新操作系统的完全崩坏</p></blockquote></li></ul><ol><li>然后退出此时的虚拟根环境</li><li>接着再次进入虚拟根环境(为了清理系统)</li><li>利用Strip来清理系统</li><li>清理完成之后退出chroot并重新进入chroot<blockquote><p>从现在开始，每当重新进入LFS系统的chroot环境时，都不应该需要加入<code>/tools</code>参数了<br>因为此时的LFS主机内已经拥有完整的工具环境了</p></blockquote></li><li>进入chroot环境之后进行下一步配置<blockquote><p>包括配置启动脚本(boot loader)，设备处理模块，控制台，网络配置脚本，Bash Shell启动文件等等<br>然后为设备创建惯用的符号链接</p></blockquote></li><li>为了让LFS系统能够启动，还需要配置<code>/etc/fstab</code>文件</li><li>最后安装Linux内核</li><li>当配置完内核之后，安装GRUB并配置GRUB启动菜单</li><li>退出chroot</li><li>卸载虚拟文件系统</li><li>卸载LFS自己的文件系统</li><li>此时应该能够保证GRUB引导装载程序已经被设置，并且按照其启动菜单可以自动启动LFS系统</li></ol><p><strong>shutdown -r now</strong></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><hr><ul><li>需要理解的知识点:</li></ul><ol><li>工具链的制作与配置和对于配置细节的理解<blockquote><p>包括静态库与动态库的配置，应用与理解<br>打上该打的补丁(patch)，批处理文件(sed)，链接器与汇编器的使用与配置(as/ld)</p></blockquote></li><li>链接的过程与程序配置文件的编写<blockquote><p>在进入下一个阶段时对软链接的使用</p></blockquote></li><li>从一个系统到达另一个系统的配置环节<blockquote><p>清理工具(Strip)<br>固化代码</p></blockquote></li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-LFS-v6.6(非官方)<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><h3 id="LFS-补充内容"><a href="#LFS-补充内容" class="headerlink" title="LFS-补充内容"></a>LFS-补充内容</h3><ul><li><p>临时系统环境搭建(分区)</p></li><li><p>临时工具链安装与说明</p></li><li><p>临时工具链配置与说明</p></li><li><p>目标系统环境搭建(chroot)</p></li><li><p>目标工具链安装与说明</p></li><li><p>目标工具链配置与说明</p></li><li><p>然后以chroot进入纯粹的目标系统进行程序编译与安装</p></li><li><p>再然后进行对启动脚本与其它系统所需的最基本脚本进行配置</p></li><li><p>最后再创建fstab与编译并配置内核，重启系统结束</p></li><li><p>具体的脚本配置根据当前本地主机的内核版本而定</p></li><li><p>可参考LFS官方文案，这里不做过多赘述</p></li></ul><hr><ul><li>LFS-v6.2/v6.3所需的最基本脚本配置文件与程序</li></ul><ol><li>配置，编译并安装 LFS-Bootscripts-6.3</li><li>配置setclock脚本 (Configuring the setclock Script)</li><li>配置Linux控制台 (Configuring the Linux Console)</li><li>配置sysklogd脚本 (Configuring the sysklogd Script)</li><li>创建/etc/inputrc文件 (Creating the /etc/inputrc File)</li><li>配置Bash Shell启动文件 (The Bash Shell Startup Files)</li><li>配置localnet脚本 (Configuring the localnet Script)</li><li>自定义/etc/hosts文件 (Customizing the /etc/hosts File)</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li><li>配置网络脚本 (Creating the /etc/fstab File)</li><li>配置，编译并安装Linux-2.6.22.5</li><li>配置GRUB以使得系统可引导 (Making the LFS System Bootable)</li><li>重启操作系统 (Rebooting the System)</li></ol><hr><p><strong>参考资料:</strong></p><ul><li><p>LFS-v6.2/v6.3</p></li><li><p>EN-LFS-书籍仓库<a href="http://www.linuxfromscratch.org/lfs/downloads/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/</code></p></blockquote></li><li><p>EN-LFS-v6.2<a href="http://www.linuxfromscratch.org/lfs/downloads/6.2/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.2/</code></p></blockquote></li><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>具体的中文版可参考金钟国及其所属团队的译本</p></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-8</title>
    <url>/2020/03/01/LFS-8/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="LFS-8"><a href="#LFS-8" class="headerlink" title="LFS-8"></a>LFS-8</h2><hr><h3 id="LFS-v6-3基本程序一览"><a href="#LFS-v6-3基本程序一览" class="headerlink" title="LFS-v6.3基本程序一览"></a>LFS-v6.3基本程序一览</h3><ul><li>LFS-v6.3内软件目录(包含版本与章节)</li><li>不包含[GNU 工具链]内程序</li></ul><p><strong>参考资料:</strong></p><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-6.6非官方<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><p><strong>临时主机程序目录</strong></p><p>5.13. Ncurses-5.6<br>5.14. Bash-3.2<br>5.15. Bzip2-1.0.4<br>5.16. Coreutils-6.9<br>5.17. Diffutils-2.8.1<br>5.18. Findutils-4.2.31<br>5.19. Gawk-3.1.5<br>5.20. Gettext-0.16.1<br>5.21. Grep-2.5.1a<br>5.22. Gzip-1.3.12<br>5.23. Make-3.81<br>5.24. Patch-2.5.4<br>5.25. Perl-5.8.8<br>5.26. Sed-4.1.5<br>5.27. Tar-1.18<br>5.28. Texinfo-4.9<br>5.29. Util-linux-2.12r</p><hr><p><strong>目标主机程序目录</strong></p><p>6.13. Berkeley DB-4.5.20<br>6.14. Sed-4.1.5<br>6.15. E2fsprogs-1.40.2<br>6.16. Coreutils-6.9<br>6.17. Iana-Etc-2.20<br>6.18. M4-1.4.10<br>6.19. Bison-2.3<br>6.20. Ncurses-5.6<br>6.21. Procps-3.2.7<br>6.22. Libtool-1.5.24<br>6.23. Perl-5.8.8<br>6.24. Readline-5.2<br>6.25. Zlib-1.2.3<br>6.26. Autoconf-2.61<br>6.27. Automake-1.10<br>6.28. Bash-3.2<br>6.29. Bzip2-1.0.4<br>6.30. Diffutils-2.8.1<br>6.31. File-4.21<br>6.32. Findutils-4.2.31<br>6.33. Flex-2.5.33<br>6.34. GRUB-0.97<br>6.35. Gawk-3.1.5<br>6.36. Gettext-0.16.1<br>6.37. Grep-2.5.1a<br>6.38. Groff-1.18.1.4<br>6.39. Gzip-1.3.12<br>6.40. Inetutils-1.5<br>6.41. IPRoute2-2.6.20-070313<br>6.42. Kbd-1.12<br>6.43. Less-406<br>6.44. Make-3.81<br>6.45. Man-DB-2.4.4<br>6.46. Mktemp-1.5<br>6.47. Module-Init-Tools-3.2.2<br>6.48. Patch-2.5.4<br>6.49. Psmisc-22.5<br>6.50. Shadow-4.0.18.1<br>6.51. Sysklogd-1.4.1<br>6.52. Sysvinit-2.86<br>6.53. Tar-1.18<br>6.54. Texinfo-4.9<br>6.55. Udev-113<br>6.56. Util-linux-2.12r<br>6.57. Vim-7.1</p><hr><p><strong>最终阶段程序</strong></p><p>7.2. LFS-Bootscripts-6.3<br>Linux-2.6.22.5</p><hr><h2 id="相关指令参考"><a href="#相关指令参考" class="headerlink" title="相关指令参考"></a>相关指令参考</h2><ul><li>patch</li><li>sed</li><li>ld</li><li>strip</li></ul><hr><h3 id="patch命令"><a href="#patch命令" class="headerlink" title="patch命令"></a>patch命令</h3><ul><li><p>Linux patch命令用于修补文件(为文件打上补丁)</p><blockquote><p>patch指令让用户利用设置修补文件的方式，修改，更新原始文件<br>倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行<br>如果配合修补文件的方式则能一次修补大批文件<br>这也是Linux系统核心的升级方法之一</p></blockquote></li><li><p>语法:</p><blockquote><p><code>patch [参数] [选项] [原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-patch.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-patch.html</a></p></blockquote></li><li><p>实例:</p></li><li><p><code>$ patch -Np1 i ../expect-5.43.0-spawn-1.patch</code></p><blockquote><p>将<code>expect</code>工具打上补丁<code>expect-5.43.0-spawn-1.patch</code></p></blockquote></li></ul><hr><h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><ul><li><p>Linux sed 命令的作用是利用脚本来处理文本文件</p></li><li><p>sed可依照脚本的指令来处理，编辑文本文件</p></li><li><p>sed主要用来自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等</p></li><li><p>命令语法:</p><blockquote><p><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-sed.html</a></p></blockquote></li><li><p>实例:</p></li><li><p>利用sed命令来确保在非bootstrap编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ld命令"><a href="#ld命令" class="headerlink" title="ld命令"></a>ld命令</h3><ul><li><p>ld 命令是二进制工具集GNU Binutils的一员，是GNU的链接器，用于将目标文件与库链接为可执行文件或库文件</p></li><li><p>命令语法:</p><blockquote><p><code>$ ld [OPTIONS] OBJFILES</code></p></blockquote></li><li><p>实例:</p></li><li><p>链接目标文件生成可执行文件</p></li><li><p>给定C++目标文件<code>test.o</code>与<code>main.o</code>，生成可执行文件<code>test.out</code></p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ ld /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o &amp;&amp;</span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtbegin</span>.<span class="title">o</span> /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtend</span>.<span class="title">o</span> &amp;&amp;</span></span><br><span class="line">-L/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5 &amp;&amp;</span></span><br><span class="line">-L/usr/lib64 -L/usr/<span class="class"><span class="keyword">lib</span> -<span class="title">lstdc</span>++ -<span class="title">lm</span> -<span class="title">lgcc_s</span> -<span class="title">lc</span> -<span class="title">lgcc</span>  <span class="title">main</span>.<span class="title">o</span> <span class="title">test</span>.<span class="title">o</span> -<span class="title">o</span> <span class="title">test</span>.<span class="title">out</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>具体参考:<br><a href="https://www.gnu.org/software/binutils/" target="_blank" rel="noopener">https://www.gnu.org/software/binutils/</a><br><a href="https://www.linux.org/docs/man1/ld.html" target="_blank" rel="noopener">https://www.linux.org/docs/man1/ld.html</a><br><a href="https://blog.csdn.net/K346K346/article/details/89088652" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/89088652</a><br><a href="https://dablelv.blog.csdn.net/article/details/88094902" target="_blank" rel="noopener">https://dablelv.blog.csdn.net/article/details/88094902</a><br><a href="http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat" target="_blank" rel="noopener">http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat</a></p></blockquote><ul><li>ld和ld.so的区别<a href="https://www.cnblogs.com/foohack/p/4105717.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.cnblogs.com/foohack/p/4105717.html</code></p></blockquote></li></ul><hr><h3 id="Strip"><a href="#Strip" class="headerlink" title="Strip"></a>Strip</h3><ul><li><p>从特定文件中剥掉一些符号信息和调试信息，使文件变小</p></li><li><p>strip - Discard symbols from object files(from man strip)</p></li><li><p>具体语法:</p><blockquote><p><code>$ strip [-xxx bfdname |--xxx=bfdname]</code><br>strip 之后的任何选项都是自定义参数，这里将不会做过多阐述<br>参考自: <a href="https://blog.csdn.net/qq_37858386/article/details/78559490" target="_blank" rel="noopener">https://blog.csdn.net/qq_37858386/article/details/78559490</a></p></blockquote></li><li><p>实例:</p></li><li><p>清理<code>/tools/lib</code>内所有的debug文件</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU-LFS-3-2</title>
    <url>/2020/03/01/GNU-LFS-3-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-2"><a href="#GNU-LFS-3-2" class="headerlink" title="GNU LFS-3-2"></a>GNU LFS-3-2</h3><hr><p><strong>目标主机-2</strong></p><ul><li>GCC</li><li>Binutils</li><li>LFS-v6.2/v6.3</li></ul><hr><h3 id="Binutils"><a href="#Binutils" class="headerlink" title="Binutils"></a>Binutils</h3><p><strong>Binutils-2.17/Binutils-2.16.1</strong></p><blockquote><p><code>$ tar xvf $LFS/binutils-2.17/2.16.1.tar.bz2</code><br><code>$ mkdir -v ../binutils-build</code><br><code>$ cd ../binutils-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ ../binutils<span class="number">-2.17</span>/<span class="number">2.16</span><span class="number">.1</span>/configure --prefix=/usr \</span><br><span class="line">		            --enable-<span class="keyword">shared</span></span><br></pre></td></tr></table></figure></li><li><p>源码编译:</p><blockquote><p><code>$ make tooldir=/usr</code></p></blockquote></li></ul><p><strong>make参数含义:</strong></p><ul><li><p>参数<code>tooldir=/usr</code></p><blockquote><p>通常情况下，tooldir(可执行文件的安装目录)是<code>$(exec_prefix)/$(target_alias)</code><br>例如在i686机器上，将是<code>tt class=&quot;filename&quot;&gt;/usr/i686-pc-linux-gnu</code><br>因为此时只为自己的系统进 行编译，就并不需要在<code>/usr</code>目录后面再存在特殊的后缀<br><code>$(exec_prefix)/$(target_alias)</code>只是在交叉编译时(比如在Intel机器上编译将要在PowerPC上执行的程序)才用到</p></blockquote></li><li><p>编译测试套件:</p><blockquote><p><code>$ make check</code></p></blockquote></li><li><p>编译安装软件包</p><blockquote><p><code>$ make tooldir=/usr install</code></p></blockquote></li><li><p>安装某些软件包需要的<code>libiberty头文件</code></p><blockquote><p><code>$ cp -v ../binutils-2.17/2.16.1/include/libiberty.h /usr/include</code></p></blockquote></li><li><p>Binutils的内容这里不做过多阐述，可参考原文第6.11.2章节</p></li></ul><hr><h3 id="GCC-4-1-2-GCC-4-0-3"><a href="#GCC-4-1-2-GCC-4-0-3" class="headerlink" title="GCC-4.1.2/GCC-4.0.3"></a>GCC-4.1.2/GCC-4.0.3</h3><blockquote><p><code>$ tar xvf $LFS/gcc-4.1.2/4.0.3.tar.bz2</code><br><code>$ cd gcc-4.1.2/4.0.3</code></p></blockquote><ul><li><p>先使用一个sed命令来禁止GCC安装它自己的<code>libiberty.a</code></p></li><li><p>这里将使用Binutils附带的<code>libiberty.a</code>来代替</p><blockquote><p><code>$ sed -i &#39;s/install_to_$(INSTALL_DEST) //&#39; libiberty/Makefile.in</code></p></blockquote></li><li><p>在临时主机中应用的bootstrap编译中，编译器会有<code>-fomit-frame-pointer</code>的标志</p></li><li><p>非bootstrap编译默认是忽略这个标志的，可以应用下面的sed命令来确保编译的可靠性</p><blockquote><p><code>$ sed -i &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in</code></p></blockquote></li><li><p><code>fixincludes脚本</code>偶尔会因为修改系统的头文件而出错</p></li><li><p>因为GCC-4.1.2/4.0.3和Glibc-2.5.1/2.3.6是不需要修改的，运行下面的命令可以避免<code>fixincludes脚本</code>运行:</p><blockquote><p><code>$ sed -i &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in</code></p></blockquote></li><li><p>GCC中提供了一个<code>gccbug脚本</code>，会在编译时侦测<code>mktemp</code>是否存在，并且在测试中加强代码</p></li><li><p>这将会导致脚本使用一些不算很随机的名字来命名临时文件</p></li><li><p>因为我们后面会安装mktemp ，这里就将人为的去模仿它的存在:</p><blockquote><p><code>$ sed -i &#39;s/@have_mktemp_command@/yes/&#39; gcc/gccbug.in</code></p></blockquote></li></ul><blockquote><p><code>$ mkdir -v ../gcc-build</code><br><code>$ cd ../gcc-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/(gcc-4.1.2/4.0.3)/configure <span class="attribute">--prefix</span>=/usr 	\ </span><br><span class="line"><span class="attribute">--libexecdir</span>=/usr/lib 				\</span><br><span class="line">--enable-shared 				\ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix 				\</span><br><span class="line">--enable-__cxa_atexit 				\ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu 				\</span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++</span><br></pre></td></tr></table></figure></li><li><p>参数作用与目标主机内的作用相同，这里不做过多阐述</p></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li>预编译测试:<blockquote><p><code>$ make -k check</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>有的软件包希望C PreProcessor(预处理器)安装在<code>/lib</code>目录下，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv ../usr/bin/cpp /lib</code></p></blockquote></li><li><p>许多软件包使用cc作为C编译器的名字，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv gcc /usr/bin/cc</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU-LFS-3-1</title>
    <url>/2020/03/01/GNU-LFS-3-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-1"><a href="#GNU-LFS-3-1" class="headerlink" title="GNU-LFS-3-1"></a>GNU-LFS-3-1</h3><ul><li>此下任何关于LFS的讨论都是基于LFS-v6.2/6.3的LiveCD与手册之上的</li><li>程序内所拥有的文件与库这里不做阐述，可参考LFS-v6.2/6.3手册内容</li></ul><hr><p><strong>目标主机-1</strong></p><ul><li>内核头文件安装</li><li>Glibc安装</li><li>目标主机工具链解析</li><li>LFS-v6.2/v6.3</li><li>LFS-v6.3-LiveCD</li></ul><h3 id="内核头文件"><a href="#内核头文件" class="headerlink" title="内核头文件"></a>内核头文件</h3><p><strong>LFS-v6.3</strong></p><ul><li>[Linux-2.6.22.5]安装流程<blockquote><p><code>$ tar xvf $LFS/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code><br><code>$ sed -i &#39;/scsi/d&#39; include/Kbuild</code><br><code>$ make mrproper</code><br><code>$ make headers_check</code><br><code>$ make INSTALL_HDR_PATH=dest headers_install</code><br><code>$ cp -rv dest/include/* /usr/include</code><br><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Linux-Libc-Headers-2.6.12.0</strong></p><ul><li><p>添加一个用户空间头文件和新内核对于<code>inotify</code>特性的系统调用支持:</p><blockquote><p><code>$ patch -Np1 -i ../linux-libc-headers-2.6.12.0-inotify-3.patch</code></p></blockquote></li><li><p>安装内核头文件:</p><blockquote><p><code>$ install -dv /usr/include/asm</code><br><code>$ cp -Rv include/asm-i386/* /usr/include/asm</code><br><code>$ cp -Rv include/linux /usr/include</code></p></blockquote></li><li><p>确保这些头文件的所有者是root:</p><blockquote><p><code>$ chown -Rv root:root /usr/include/{asm,linux}</code></p></blockquote></li><li><p>确保用户可以读取这些头文件:</p><blockquote><p><code>$ find /usr/include/{asm,linux} -type d -exec chmod -v 755 {} \;</code><br><code>$ find /usr/include/{asm,linux} -type f -exec chmod -v 644 {} \;</code></p></blockquote></li><li><p>此时安装的头文件为<code>/usr/include/{asm,linux}/*.h</code></p></li><li><p>头文件内容可参考LFS-v6.2的6.7.2章节，这里不做过多阐述</p></li></ul><hr><p><strong>Man-pages-2.63/Man-pages-2.34</strong></p><ul><li>直接进行编译安装:<blockquote><p><code>$ tar xvf $LFS/man-pages-2.63.tar.bz2</code><br><code>$ cd man-pages-2.63</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf man-pages-2.63</code></p></blockquote></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><p><strong>Glibc-2.5.1/2.3.6</strong></p><ul><li><p>在进行之前请检查一下是否glibc-2.5.1和glibc-build这两个目录已经被删除，如果没有删除请删除后在继续</p></li><li><p>将glibc-libidn包解压到Glibc的源码目录:</p><blockquote><p><code>$ tar xvf $LFS/glibc-2.5.1.tar.bz2</code><br><code>$ cd glibc-2.5.1</code><br><code>$ tar -xvf $LFS/glibc-libidn-2.5.1.tar.gz</code><br><code>$ mv glibc-libidn-2.5.1 libidn</code></p></blockquote></li><li><p>应用下面这个patch来修正软件包在<code>sys/kd.h</code>之后包含<code>linux/types.h</code>导致编译错误:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-linux_types-1.patch</code></p></blockquote></li><li><p>添加一个头文件来定义为新内核对于inotify特性的系统调用函数:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-inotify-1.patch</code></p></blockquote></li><li><p>抑制locale的安装，以避免出现bash的bug</p><blockquote><p><code>$ sed -i &#39;/vi_VN.TCVN/d&#39; localedata/SUPPORTED</code></p></blockquote></li><li><p>当运行make install时，一个叫<code>test-installation.pl</code>的脚本会在我们新安装的Glibc上做一个小的完整性测试</p></li><li><p>然而，由于我们的<code>toolchain</code>仍然指向<code>/tools</code>目录，完整性测试会导致使用错误的Glibc</p></li><li><p>所以必须强制脚本测试刚安装的脚本</p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">$ sed -i \ </span><br><span class="line">'s|<span class="type">libs</span> -o|<span class="type">libs</span> -L/usr/lib -Wl,-dynamic-linker=/lib/ld-linux.so<span class="number">.2</span> -o|<span class="type">' \   </span></span><br><span class="line"><span class="type">scripts</span>/test-installation.pl</span><br></pre></td></tr></table></figure></li><li><p>继续运行指令:</p><blockquote><p><code>$ sed -i &#39;s|@BASH@|/bin/bash|&#39; elf/ldd.bash.in</code><br><code>$ mkdir -v</code><br><code>$ ../glibc-build</code><br><code>$ cd ../glibc-build</code></p></blockquote></li><li><p>配置安装脚本:</p><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure </span><br><span class="line">-<span class="ruby">-prefix=<span class="regexp">/usr \ </span></span></span><br><span class="line"><span class="ruby">--disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \ </span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--libexecdir=<span class="regexp">/usr/lib</span><span class="regexp">/glibc</span></span></span><br></pre></td></tr></table></figure></li><li><p>新参数说明:</p></li><li><p>参数<code>--libexecdir=/usr/lib/glibc</code></p><blockquote><p>把<code>pt_chown</code>程序的位置从默认的<code>/usr/libexec</code>改为<code>/usr/lib/glibc</code></p></blockquote></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li><p>对结果进行测试:</p><blockquote><p><code>$ make -k check 2&gt;&amp;1 | tee glibc-check-log</code><br><code>$ grep Error glibc-check-log</code></p></blockquote></li><li><p>在安装Glibc的过程中，它会警告缺少<code>/etc/ld.so.conf</code>文件</p></li><li><p>其实这没什么关系，不过下面的命令能修正它:</p><blockquote><p><code>$ touch /etc/ld.so.conf</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>(LFS-v6.2独有)此部还需要安装<code>inotify头文件</code>到系统头文件的地方:</p><blockquote><p><code>$ cp -v ../glibc-2.3.6/sysdeps/unix/sysv/linux/inotify.h \ /usr/include/sys</code></p></blockquote></li><li><p>一次安装所有列在<code>glibc-2.3.6/localedata/SUPPORTED</code>中的<code>locales</code></p><blockquote><p><code>$ make localedata/install-locales</code></p></blockquote></li></ul><hr><p><strong>配置Glibc</strong></p><ul><li><p>此时需要建立<code>/etc/nsswitch.conf</code>文件</p></li><li><p>因为在这个文件丢失或不正确的情况下，Glibc会使用默认配置，而Glibc的默认配置无法很好地在网络环境下工作</p></li><li><p>并且我们也需要设置自己的时区</p></li><li><p>建立一个新的<code>/etc/nsswitch.conf</code>文件:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/nsswitch.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"># Begin /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">passwd: <span class="keyword">files</span> </span><br><span class="line">group: <span class="keyword">files</span> </span><br><span class="line">shado<span class="variable">w:</span> <span class="keyword">files</span></span><br><span class="line">host<span class="variable">s:</span> <span class="keyword">files</span> dns </span><br><span class="line">network<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">protocol<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">service<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">ether<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">rpc: <span class="keyword">files</span> </span><br><span class="line"># End /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>设置时区:</p><blockquote><p><code>$ cp -v --remove-destination /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p></blockquote></li><li><p>配置动态链接库加载程序</p></li><li><p>写入配置</p></li><li><p>LFS-v6.3</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;ld.so.conf &lt;&lt; &quot;EOF&quot; </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib </span><br><span class="line">&#x2F;opt&#x2F;lib </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>LFS-v6.2</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"># Begin /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span></span><br><span class="line">/usr/<span class="keyword">local</span>/lib </span><br><span class="line">/opt/lib</span><br><span class="line"># End /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote><ul><li>glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误，还有一些能引起错误的LFS手册上有所提及</li><li>由此某些情况的错误可以无视</li></ul><hr><h3 id="调整目标主机工具链"><a href="#调整目标主机工具链" class="headerlink" title="调整目标主机工具链"></a>调整目标主机工具链</h3><ul><li><p>现在，最终的C库已经安装好了，此时需要再次调整工具链，让本章随后编译的那些工具都连接到这个库上</p></li><li><p>基本上，就是把临系统时增加中调整工具链那里做的调整给取消掉</p></li><li><p>在临时系统中，工具链使用的库是从宿主系统的<code>/{,usr/}lib</code>转向新安装的<code>/tools/lib</code>目录</p></li><li><p>同样的，现在工具链使用的库将从临时的<code>/tools/lib</code>转向LFS系统最终的<code>/{,usr/}lib</code>目录</p></li><li><p>首先，备份<code>/tools</code>下的链接</p><blockquote><p>用刚才在临时主机中编译的链接器来替换<br>再创建一个链接到在<code>/tools/$(gcc -dumpmachine)/bin</code>中的副本</p></blockquote></li><li><p>执行以下命令:</p><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote></li><li><p>接下来，修正GCC的specs文件，使它指向新的动态链接器</p></li><li><p>这样GCC才能知道在哪能发 现开始文件</p></li><li><p>这里应用一个sed命令:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ gcc -dumpspecs | sed <span class="string">\</span> </span><br><span class="line">-e <span class="string">'s@/tools/lib/ld-linux.so.2@/lib/ld-linux.so.2@g'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*startfile_prefix_spec:/&#123;n;s@.*@/usr/lib/ @&#125;'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*cpp:/&#123;n;s@$@ -isystem /usr/include@&#125;'</span> &gt; <span class="string">\</span> </span><br><span class="line">`dirname $(gcc --<span class="built_in">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>还可以利用perl命令</p><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">$ gcc -dumpspecs | \ </span><br><span class="line">perl -p -e	's<span class="comment">@/tools/lib/ld-linux.so.2@</span>/<span class="keyword">lib</span>/ld-linux.so<span class="number">.2</span><span class="comment">@g;' \</span></span><br><span class="line"><span class="comment">-e 's@</span>\*startfile_prefix_spec:\n<span class="comment">@$_/usr/lib/ @</span>g;' &gt; \</span><br><span class="line">`dirname	$(gcc --<span class="keyword">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>如果此时本地主机的系统平台上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须把上面命令里的<code>ldlinux.so.2</code>换成此时本地主机的系统平台上动态连接器的名字</p></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU-LFS-2-4</title>
    <url>/2020/02/29/GNU-LFS-2-4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-4"><a href="#GNU-LFS-2-4" class="headerlink" title="GNU LFS-2-4"></a>GNU LFS-2-4</h2><ul><li>[GNU 工具链]全面逻辑梳理</li><li>重点在于配置链接器与工具链的逻辑</li></ul><hr><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul><li>可以将临时主机的工具链搭建分为两部分</li><li>前半部分为第一遍编译并安装GCC，Binutils和内核头文件</li><li>后半部分为编译并安装Glibc，在配置完Glibc之后，正式调整临时工具链并再次安装GCC与Binutils</li><li>第一步与第二部和第五步与第六步的顺序没有严格规定</li><li>但对GCC与Binutils的第二次编译安装必须在先配置并且编译安装完Glibc之后再进行</li></ul><hr><ul><li><code>Binutils-&gt;GCC-&gt;Headres-&gt;GLibc-&gt;Tools调整-&gt;Binutils-&gt;GCC/C++补丁</code></li><li>参考至<code>LFSv6.2/6.3</code></li></ul><hr><ul><li>因为这里所使用的LiveCD是LFS官方提供的</li><li>由于官方于6.3版本之后就停止维护了</li><li>所以这里只介绍6.3及以下版本</li></ul><hr><ul><li>这里将以下七个工具所需要的</li><li>每个工具编译的重要步骤</li><li>与对工具链的链接和链接器的配置进行了逻辑的梳理</li></ul><hr><h3 id="1-Binutils-Pass-1"><a href="#1-Binutils-Pass-1" class="headerlink" title="1. Binutils Pass-1"></a>1. Binutils Pass-1</h3><ul><li>编译并安装过后</li><li>为调整工具链而准备链接器</li></ul><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/tools/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote><ul><li>参数<code>-C ld LIB_PATH=/tools/lib</code></li><li>指定<code>Makefile</code>的<code>LIB_PATH</code>变量值</li><li>使其明确指向临时工具目录，以覆盖默认值</li><li>这个变量同时还指定了链接器的默认库搜索路径</li><li>在编译完Glibc后就会用到</li></ul><hr><h3 id="2-GCC-Pass-1"><a href="#2-GCC-Pass-1" class="headerlink" title="2. GCC Pass-1"></a>2. GCC Pass-1</h3><ul><li>编译并安装过后</li><li>创建gcc的符号链接为cc，以保证兼容性<blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li></ul><hr><h3 id="3-kernel-headers-API"><a href="#3-kernel-headers-API" class="headerlink" title="3. kernel headers API"></a>3. kernel headers API</h3><ul><li>将头文件编译并复制到所需目录</li></ul><hr><h3 id="4-Glibc"><a href="#4-Glibc" class="headerlink" title="4. Glibc"></a>4. Glibc</h3><ul><li>编译并安装C标准库</li><li>执行<code>touch /tools/etc/ld.so.conf</code></li><li>以修补安装过程中缺少的<code>/tools/etc/ld.so.conf</code></li></ul><hr><h3 id="5-调整工具链-LFS-v6-2-v6-3"><a href="#5-调整工具链-LFS-v6-2-v6-3" class="headerlink" title="5. 调整工具链(LFS-v6.2/v6.3)"></a>5. 调整工具链(LFS-v6.2/v6.3)</h3><ul><li><p>在临时系统的C标准库安装好之后</p></li><li><p>需要将临时工具链中的所有工具都连接到C标准库之上</p></li><li><p>为了达到这个目标，必须调整链接器和编译器的space文件</p></li><li><p>因为Binutils Pass-1的时候以经调整过链接器了</p></li><li><p>所以现在需要做的只是将其重新命名并被正确的找到和使用</p></li><li><p>方法是备份原来的链接器，然后再用调整过的链接器来替代</p></li><li><p>最后再创建一个指向<code>/tools/$(gcc -dumpmachine)/bin</code>中链接器副本的链接</p></li></ul><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote><ul><li>从现在开始，所有程序都将连接到<code>/tools/lib</code>中的库文件</li></ul><hr><ul><li><p>接下来需要做的就是修正GCC中的spaces文件</p></li><li><p>目的是使他指向一个新的动态链接器</p></li><li><p>本质上就是把specs中所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>这里用的是sed命令，有两种语法(分别是LFS-v6.2与LFS-v6.3)</p></li><li><p>如果当前的本地主机上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须人为的把以下命令里的<code>ldlinux.so.2</code>换成本地主机的系统平台上动态连接器的名</p></li><li><p>LFS-v6.2</p></li></ul><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span>	<span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile	 <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFIL</span><br></pre></td></tr></table></figure><ul><li>LFS-v6.3</li></ul><blockquote><p><code>$ gcc -dumpspecs | sed &#39;s@^/lib/ld-linux.so.2@/tools&amp;@g&#39; &gt;</code>dirname $(gcc -print-libgcc-file-name)<code>/ specs</code></p></blockquote><hr><ul><li><p>最后删除GCC专属头文件目录中的头文件，以避免宿主机中的头文件污染编译环境</p></li><li><p>这里的命令v6.2与v6.3没有区别</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>工具链的调整方法有好几种</p></li><li><p>而且不同版本GCC的specs可能会有不同</p></li><li><p>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>还直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件</p></li></ul><hr><h3 id="6-Binutils-Pass-2"><a href="#6-Binutils-Pass-2" class="headerlink" title="6. Binutils Pass-2"></a>6. Binutils Pass-2</h3><ul><li><p>编译并安装</p></li><li><p>编译配置中配置参数<code>--with-lib-path=/tools/lib</code></p></li><li><p>以指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code></p></li><li><p>以防止连接器搜索宿主系统的库目录</p></li><li><p>最后为目标主机的调整工具链阶段配置链接器:</p><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/usr/lib:/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote></li></ul><hr><h3 id="7-GCC-C-补丁-Pass-2"><a href="#7-GCC-C-补丁-Pass-2" class="headerlink" title="7. GCC/C++补丁 Pass-2"></a>7. GCC/C++补丁 Pass-2</h3><ul><li><p>在GCC编译过程中会运行<code>fixincludes脚本</code>来扫描系统头文件目录</p></li><li><p>并找出需要修正的头文件，然后把修正后的头文件放到GCC专属头文件目录里</p></li><li><p>因为现在GCC和Glibc已经安装完毕，而且它们的头文件已知无需修正</p></li><li><p>所以这里并不需要<code>fixincludes脚本</code></p></li><li><p>必须先禁止fixincludes运行，以保证编译环境不受原主机所污染</p><blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig} &amp;&amp;</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li><p>因为在前几步中编译的GCC Pass-1中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项</p></li><li><p>而非<code>bootstrap</code>编译则默认忽略了该选项</p></li><li><p>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项</p></li><li><p>用以保持一致性:</p></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">	&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure><ul><li><p>然后使用补丁修改补丁修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置:</p><blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li><p>该命令同时还把/usr/include`从GCC的头文件搜索路径里删掉</p></li><li><p>现在预先打补丁而不是在安装GCC之后调整specs文件可以保证新的动态连接器在编译GCC的时候就用上</p></li><li><p>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></li><li><p>然后配置编译器，并进行编译与编译安装</p></li><li><p>关于GCC的C++是在LFS-v9.0中出现的，这里先不做过多阐述</p></li></ul><hr><ul><li>至此结束临时主机的[GNU 工具链]配置环节</li><li>下一步即为配置其它的辅助命令与工具链所处的大环境</li><li>从而为目标主机提供应有的功能与服务</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU-LFS-2-3</title>
    <url>/2020/02/29/GNU-LFS-2-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-3"><a href="#GNU-LFS-2-3" class="headerlink" title="GNU LFS-2.3"></a>GNU LFS-2.3</h3><ul><li>GCC Pass-2</li><li>Bintils Pass-2</li></ul><hr><h3 id="Bintils-Pass-2"><a href="#Bintils-Pass-2" class="headerlink" title="Bintils Pass-2"></a>Bintils Pass-2</h3><ul><li>Binutils-2.16.1/LFS-6.2 Pass-2 154 MB 1.1 SBU</li><li>Binutils-2.17/LFS-6.3 Pass 2</li><li>Binutils-2.32/LFS-9.0 Pass-2 879 MB 1.1 SUB</li></ul><hr><p><strong>Binutils-2.16.1/2.17</strong></p><ul><li>解压文件并进入编译目录<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li></ul><p>编译配置</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$ <span class="string">../binutils-2.17</span><span class="params">(-2.16.1)</span><span class="string">/configure</span> <span class="params">--prefix=/tools</span> 	\</span><br><span class="line">			<span class="params">--disable-nls</span> 		\ </span><br><span class="line">			<span class="params">--with-lib-path=/tools/lib</span></span><br></pre></td></tr></table></figure><ul><li><p>新参数含义:</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这个选项指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code><br>以防止连接器搜索宿主系统的库目录</p></blockquote></li><li><p>编译及安装</p><blockquote><p><code>$ make</code><br><code>$ make install</code></p></blockquote></li><li><p>为目标机器的工具链调整配置连接器</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new	/tools/bin</span><br></pre></td></tr></table></figure></li><li><p>最后清理一下</p><blockquote><p><code>$ cd .. rm -rf binutils-build</code><br><code>$ rm -rf binutils-2.17</code></p></blockquote></li></ul><hr><p><strong>Binutils-2.32</strong></p><ul><li>编译配置<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                \ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                	 \ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib        	 \ </span><br><span class="line"><span class="built_in">..</span>/configure                	 \    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools         	 \    </span><br><span class="line">--disable-nls            	 \    </span><br><span class="line">--disable-werror       		 \   </span><br><span class="line"><span class="attribute">--with-lib-path</span>=/tools/lib 	 \  </span><br><span class="line"> --with-sysroot</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数含义:</strong></p><ul><li><p>参数<code>CC=$LFS_TGT-gcc</code>,<code>AR=$LFS_TGT-ar</code>,<code>RANLIB=$LFS_TGT-ranlib</code></p><blockquote><p>因为这是真正的原生编译Binutils，设置这些变量能确保编译系统使用交叉编译器和相关的工具，而不是 宿主系统中已有的</p></blockquote></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这告诉配置脚本在编译Binutils的时候指定库搜索目录，此处将<code>/tools/lib</code>传递到链接器</p></blockquote></li><li><p>参数<code>--with-sysroot sysroot</code></p><blockquote><p>功能使链接器可以找到包括在其命令行中的其它共享对象明确需要的共享对象<br>否则的话，在某些主机上一些软件包可能会编译不成功</p></blockquote></li><li><p>之后进行编译安装</p></li><li><p>为目标机器中的工具链阶段准备链接器</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>make 参数说明</strong></p><ul><li>参数<code>-C ld clean</code><blockquote><p>用于告诉make程序移除所有ld子目录中编译过的文件</p></blockquote></li><li>参数<code>-C ld LIB_PATH=/usr/lib:/lib</code><blockquote><p>这个选项重新编译ld子目录中的所有文件<br>在命令行中指定<code>Makefile</code>的<code>LIB_PATH</code>变量可以使我们能 够重写临时工具的默认值并指向正确的最终路径<br>该变量的值指定链接器的默认库搜索路径<br>目标主机中会用到这个准备</p></blockquote></li></ul><hr><h3 id="GCC-Pass-2"><a href="#GCC-Pass-2" class="headerlink" title="GCC Pass-2"></a>GCC Pass-2</h3><ul><li>GCC 9.2.0 LFS-9.0 3.7 GB/15 SBU</li><li>GCC 4.1.2 LFS-6.3</li><li>GCC 4.0.3 LFS-6.2 443 MB/4.2 SBU</li></ul><hr><p><strong>GCC 4.1.2/4.0.3 Pass-2</strong></p><blockquote><p><code>$ tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</code><br><code>$ cd gcc-4.1.2</code></p></blockquote><ul><li>禁止fixincludes脚本运行，以保证编译环境不被污染<blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig}</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li>因为在之前的<code>GCC Pass-1</code>中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项，而非bootstrap`编译则默认忽略了该选项</li><li>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性<blockquote><p><code>$ cp -v gcc/Makefile.in{,.tmp}</code><br><code>$ sed &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in.tmp gcc \</code><br><code>&gt; Makefile.in</code></p></blockquote></li><li>使用下面的补丁来修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置，同时把<code>/usr/include</code>从GCC的头文件搜索路径里删掉:<blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li>预先打补丁而不是在安装GCC之后调整specs文件的作用是:<blockquote><p>可以保证新的动态连接器在编译GCC的时候就用上<br>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></blockquote></li><li>此补丁非常重要，必须进行使用才能成功编译</li></ul><ul><li>GCC Pass-2 编译配置:<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ mkdir -v <span class="built_in">..</span>/gcc-build</span><br><span class="line">$ cd <span class="built_in">..</span>/gcc-build </span><br><span class="line">$ <span class="built_in">..</span>/gcc-4.1.2/configure <span class="attribute">--prefix</span>=/tools 	\ </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools 			\ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu 				\</span><br><span class="line">--enable-shared 				\ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix 				\</span><br><span class="line">--enable-__cxa_atexit 				\ </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++ 			\</span><br><span class="line">--disable-libstdcxx-pch</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数解析:</strong><br><code>--prefix=/tools</code><br><code>--with-local-prefix=/tools</code></p><ul><li>参数<code>--enable-clocale=gnu</code><blockquote><p>用于确保确保C++库在任何情况下都使用正确的locale模块</p></blockquote></li><li>参数<code>--enable-threads=posix</code><blockquote><p>用于使C++异常能处理多线程代码</p></blockquote></li><li>参数<code>--enable-__cxa_atexit</code><blockquote><p>用<code>__cxa_atexit</code>代替<code>atexit</code>来登记C++对象的本地静态和全局析构函数<br>这是为了完全符合标准对析构函数的处理规定</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>用于编译C和C++语言的编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译头(PCH)，它占用了很大空间，并且在此版本中用不到它</p></blockquote></li></ul><hr><p><strong>编译安装并清理:</strong></p><blockquote><p><code>$ make</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote><hr><p><strong>GCC 9.2.0 Pass-2</strong></p><ul><li><p>因为在第一次编译GCC的时候安装了一些内部系统头文件</p></li><li><p>其中的一个<code>limits.h</code>会反过来包括对应的系统头文件<code>limits.h</code>，在本次的实例中，是<code>/tools/include/limits.h</code></p></li><li><p>但是，第一次编译gcc的时候<code>/tools/include/limits.h</code>并不存在</p></li><li><p>因此GCC安装的内部头文件只是部分的自包含文件，并不包括系 统头文件的扩展功能</p></li><li><p>这足以编译临时libc，但是这次编译GCC要求完整的内部头文件</p></li><li><p>使用和正常情况下GCC编译系统使用的相同的命令创建一个完整版本的内部头文件:</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ cat gcc/limitx.h gcc/glimits.h gcc/limity.h &gt; \  </span><br><span class="line">`dirname <span class="constructor">$($LFS_TGT-<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`/<span class="keyword">include</span>-fixed/limits.h</span><br></pre></td></tr></table></figure></li><li><p>再一次更改 GCC 的默认动态链接器的位置，使用安装在<code>/tools</code>的那个</p></li><li><p>执行以下配置:</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$ for file in gcc/config/&#123;linux,i386/linux&#123;,64&#125;&#125;<span class="string">.h</span> </span><br><span class="line">do  </span><br><span class="line">cp -uv $file&#123;,<span class="string">.orig</span>&#125;  </span><br><span class="line">sed -e 's@<span class="string">/lib</span>\<span class="params">(64\)</span>\?\<span class="params">(32\)</span>\?<span class="string">/ld</span>@<span class="string">/tools</span>&amp;@g' \</span><br><span class="line">       -e 's@<span class="string">/usr</span>@<span class="string">/tools</span>@g' $file.orig &gt; $file  </span><br><span class="line"><span class="keyword">echo</span> ' </span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_1 </span></span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_2 </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/" </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file  </span></span><br><span class="line">touch $file.orig </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>环境上构建，为64位库改变默认目录名至<code>lib</code>:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> $(uname -m) <span class="keyword">in</span>  </span><br><span class="line">x86_64)    </span><br><span class="line">sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \        </span><br><span class="line">-i.orig gcc/config/i386/t-linux64  </span><br><span class="line">;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p>和第一次编译GCC一样，它要求GMP,MPFR和MPC软件包</p></li><li><p>解压tar包并把它们重名为到所需的文件夹名</p></li><li><p>执行以下命令:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ tar -xf ../mpfr<span class="number">-4.0</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v mpfr<span class="number">-4.0</span><span class="number">.2</span> mpfr </span><br><span class="line">$ tar -xf ../gmp<span class="number">-6.1</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v gmp<span class="number">-6.1</span><span class="number">.2</span> gmp </span><br><span class="line">$ tar -xf ../mpc<span class="number">-1.1</span><span class="number">.0</span>.tar.gz </span><br><span class="line">$ mv -v mpc<span class="number">-1.1</span><span class="number">.0</span> mpc</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>在开始编译 GCC 之前，注意要取消所有会覆盖默认优化选项的环境变量</p></li><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                                   	\ </span><br><span class="line"><span class="attribute">CXX</span>=<span class="variable">$LFS_TGT</span>-g++                               		\ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                                 		\ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib                             	\ </span><br><span class="line"><span class="built_in">..</span>/configure                                      	\    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                                		\	    </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools                 		\    </span><br><span class="line"><span class="attribute">--with-native-system-header-dir</span>=/tools/include    	\    </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++                                \    </span><br><span class="line">--disable-libstdcxx-pch                       	        \    </span><br><span class="line">--disable-multilib                             	        \    </span><br><span class="line">--disable-bootstrap                            		\    </span><br><span class="line">--disable-libgomp</span><br></pre></td></tr></table></figure></li></ul><p><strong>新参数说明:</strong></p><ul><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保编译了C 和C++编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译的头文件(PCH)<br>这会花费很多时间，却对我们没有用处</p></blockquote></li><li>参数<code>--disable-bootstrap</code><blockquote><p>对于原生编译的 GCC，默认是做一个[引导]构建<br>这不仅会编译GCC一次，而是会编译很多次</p></blockquote></li></ul><hr><ul><li>然后执行编译安装等操作</li><li>在编译并安装过后，可以为其设置符号链接(<code>gcc-&gt;cc</code>)<blockquote><p><code>$ ln -sv gcc /tools/bin/cc</code></p></blockquote></li><li>很多程序和脚本执行cc而不是gcc来保证程序的通用性<blockquote><p>并且在所有的Unix类型的系统上都能用<br>而非仅局限于安装了GCC的Unix 类型的系统</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>LFS-v6.2</li><li>LFS-v6.3</li><li>LFS-v9.0</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU-LFS-2-2</title>
    <url>/2020/02/29/GNU-LFS-2-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-2"><a href="#GNU-LFS-2-2" class="headerlink" title="GNU LFS-2-2"></a>GNU LFS-2-2</h3><ul><li><p>内容简述</p><blockquote><p>Linux Kernel Headeres(CN-LFS-6.2/6.3/9.0)<br>Glibc/Libstdc++(CN-LFS-6.2/6.3/9.0)<br>第一遍的工具链调整(CN-LFS-6.2/6.3/9.0)</p></blockquote></li><li><p>说明内容:</p></li><li><p>本篇内容将新版和旧版的资料相融合(将新版补充旧版的内容)</p></li><li><p>同时将其它的学习资料补充进LFS官方的文档内</p></li><li><p>在区分版本说明时，会先去介绍6.3再解释其它版本</p></li></ul><hr><h3 id="Linux-API-Headers"><a href="#Linux-API-Headers" class="headerlink" title="Linux API Headers"></a>Linux API Headers</h3><ul><li><p>每个版本的Linux kernel headers的名字都不一样</p></li><li><p>这里整合性的指出了三个版本的安装方法，分别是:</p><blockquote><p>Linux-2.6.22.5 API Headers(LFS-6.3)<br>Linux-5.2.8 API (LFS-9.0)<br>Linux-Libc-Headers-2.6.12.0 (LFS-6.2)</p></blockquote></li><li><p>新建编译目录和清理工作这里就不做过多阐述了</p></li></ul><hr><p><strong>Version-2.6.22.5(LFS-v6.3)</strong></p><ul><li>解压并进入文件夹<blockquote><p><code>$ tar xvf /lfs-sources/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code></p></blockquote></li></ul><p>清除所有存在的多余依赖关系:</p><blockquote><p><code>$ make mrproper</code></p></blockquote><p>编译头文件</p><blockquote><p><code>$ make headers_check</code></p></blockquote><ul><li><p>从源代码中提取用户可见的内核头文件到指定位置</p><blockquote><p><code>$ make INSTALL_HDR_PATH=dest headers_install</code></p></blockquote></li><li><p>保存在一个临时本地文件夹中然后复制到所需的位置</p><blockquote><p><code>$ cp -rv dest/include/* /tools/include</code></p></blockquote></li><li><p>清理</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Version-5.2.8(LFS-v9.0)</strong></p><ul><li><p>大致构建用时: 0.1 SBU</p></li><li><p>所需磁盘空间: 960 MB</p></li><li><p>清除依赖项</p><blockquote><p><code>$ make mrproper</code></p></blockquote></li><li><p>从源代码中提取用户可见的内核头文件</p></li><li><p>把它们保存在一个临时本地文件夹中然后复制到所需的位置</p></li><li><p>因为解压过程会移除目标文件夹中任何已有的文件</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">make</span> INSTALL_HDR_PATH=dest headers_install</span><br><span class="line"><span class="keyword">cp</span> -<span class="keyword">rv</span> dest/include/* /tools/include</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Version-2.6.12.0(LFS-未知版本)</strong></p><ul><li><p>Linux-Libc-Headers-2.6.12.0</p></li><li><p>Linux-Libc-Headers内包含了纯净的内核头文件</p></li><li><p>预计编译时间：少于0.1</p></li><li><p>SBU所需磁盘空间：27MB</p></li><li><p>安装这些头文件所需指令:</p><blockquote><p><code>cp -Rv include/asm-i386 /tools/include/asm</code><br><code>cp -Rv include/linux /tools/include</code></p></blockquote></li><li><p>asm-i386为架构参数，需要自行进行调整</p></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><ul><li>Glibc-2.5.1</li><li>Glibc-2.30</li></ul><hr><p><strong>Glibc-2.5.1</strong></p><ul><li><p>LFS-v6.3</p></li><li><p>解压并进入编译目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/glibc-2.5.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v glibc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> glibc-build</span></span><br></pre></td></tr></table></figure></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure --prefix=/tools 	\</span><br><span class="line">-<span class="ruby">-disable-profile 				\</span></span><br><span class="line"><span class="ruby">--enable-add-ons 				\</span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> 				\</span></span><br><span class="line"><span class="ruby">--with-binutils=<span class="regexp">/tools/bin</span> 			\	 </span></span><br><span class="line"><span class="ruby">--without-gd 					\</span></span><br><span class="line"><span class="ruby">--with-headers=<span class="regexp">/tools/include</span> 			\ </span></span><br><span class="line"><span class="ruby">--without-selinux</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>--prefix=/tools</code></p><blockquote><p>用于指定安装目录</p></blockquote></li><li><p>参数<code>--disable-profile</code></p></li><li><p>参数<code>--enable-add-ons</code></p><blockquote><p>用于指示Glibc使用附加的NPTL包作为线程库</p></blockquote></li><li><p>参数<code>--enable-kernel=2.6.0</code></p><blockquote><p>用于告诉Glibc编译支持2.6.x内核的库</p></blockquote></li><li><p>参数<code>--with-binutils=/tools/bin</code></p><blockquote><p>用于保证在编译Glibc时不会用错Binutils程序</p></blockquote></li><li><p>参数<code>--without-gd</code></p><blockquote><p>可以保证不生成memusagestat程序</p></blockquote></li><li><p>参数<code>--with-headers=/tools/include</code></p><blockquote><p>数指示Glibc按照前面刚刚安装到tools目录中的内核头文件编译自己<br>从而精确的知道内核的特性以根据这些特性对自己进行最佳化编译</p></blockquote></li><li><p>参数<code>--without-selinux</code></p><blockquote><p>用于明确禁用含有SELinux特性的Glibc，以防止会出现许多操作失败的结果</p></blockquote></li><li><p>其中参数<code>--enable-kernel=2.6.0</code>，只是为了说明kernel的大版本</p><blockquote><p>所以不需要根据实际的kernel版本来改<br>即使是用linux-2.6.15也一样只写2.6.0就可以了</p></blockquote></li><li><p>编译至二进制格式</p><blockquote><p><code>$make</code></p></blockquote></li><li><p>配置链接器</p><blockquote><p><code>$ mkdir -v /tools/etc</code><br><code>$ touch /tools/etc/ld.so.conf</code></p></blockquote></li><li><p>编译安装</p><blockquote><p><code>$ make install</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote></li></ul><hr><p><strong>Glibc-2.30</strong></p><ul><li><p>Glibc 软件包包含了主要的 C 函数库</p></li><li><p>这个库提供了分配内存，搜索目录，打开关闭文件，读写文件，操作字 符串，模式匹配，基础算法等基本程序</p></li><li><p>大致构建用时: 4.8 SBU</p></li><li><p>所需磁盘空间: 896 MB</p></li><li><p>编译配置</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/glibc-2.5.1/configure              \      </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                    	\      </span><br><span class="line"><span class="attribute">--host</span>=<span class="variable">$LFS_TGT</span>                    	\      </span><br><span class="line"><span class="attribute">--build</span>=$(../scripts/config.guess) 	\      </span><br><span class="line"><span class="attribute">--enable-kernel</span>=3.2                	\      </span><br><span class="line"><span class="attribute">--with-headers</span>=/tools/include</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p><code>$ --host=$LFS_TGT, --build=$(../scripts/config.guess)</code></p><blockquote><p>这些选项的组合效果是Glibc的构建系统配置它自己用<code>/tools</code>里面的交叉链接器和交叉编译器交叉编译自己</p></blockquote></li><li><p><code>$ --enable-kernel=3.2</code></p><blockquote><p>这告诉Glibc编译能支持3.2以及之后的内核库<br>更早的内核版本不受支持</p></blockquote></li><li><p><code>$ --with-headers=/tools/include</code>告诉Glibc利用刚刚安装在tools文件夹中的头文件编译自身</p><blockquote><p>此能够根据内核的具体特性提供更好的优化</p></blockquote></li><li><p>在新版本的配置中，不仅需要安装C语言的标准库，还需要安装与配置对C++支持的标准库</p></li><li><p>Libstdc++是标准的C++库</p></li><li><p>需要用它来编译C++ 代码(GCC的一部分是用C++写的)</p></li><li><p>但是在构建GCC Pass-1时，我们需要推迟它的安装进程，因为依赖的glibc，还未部署在<code>/tools</code>目录中</p></li><li><p>大致构建用时: 0.5 SBU</p></li><li><p>所需磁盘空间: 879 MB</p></li><li><p>记得新建源码编译目录与编译完清理，这里不对此部分进行赘述了</p></li><li><p>因为Libstdc++是GCC源文件的一部分</p></li><li><p>所以首先应该解压GCC的压缩包，然后进入<code>gcc-9.2.0</code>文件夹</p></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">$ ../libstdc++-v3/configure             \    </span><br><span class="line">-<span class="ruby">-host=$LFS_TGT                 	\    </span></span><br><span class="line"><span class="ruby">--prefix=<span class="regexp">/tools                 	\    </span></span></span><br><span class="line"><span class="ruby">--disable-multilib              	\    </span></span><br><span class="line"><span class="ruby">--disable-nls                   	\    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-threads     	\    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-pch         	\    </span></span><br><span class="line"><span class="ruby">--with-gxx-<span class="keyword">include</span>-dir=<span class="regexp">/tools/</span>$LFS_TGT/<span class="keyword">include</span>/c++<span class="regexp">/9.2.0</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>配置说明:</strong></p><ul><li><p>参数<code>--host=...</code></p><blockquote><p>用于指示使用我们刚才编译的交叉编译器，而不是<code>/usr/bin</code>中的</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-threads</code></p><blockquote><p>由于我们还没有编译C线程库，C++的也还不能编译</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-pch</code></p><blockquote><p>此选项防止安装预编译文件，此步骤并不需要</p></blockquote></li><li><p>参数<code>--with-gxx-include-dir=/tools/$LFS_TGT/include/c++/9.2.0</code></p><blockquote><p>这是C++编译器搜索标准include文件的位置<br>在一般的编译中，这个信息自动从顶层文件夹中传入Libstdc++ configure选项<br>在我们的例子中，必须明确给出这信息</p></blockquote></li><li><p>进行编译安装</p><blockquote><p>$ make<br>$ make install</p></blockquote></li></ul><hr><p><strong>其它情况</strong></p><ul><li>在编译过程中可能会发生以下警告</li></ul><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">configure: WARNING: </span><br><span class="line"><span class="comment">*** These auxiliary programs are missing or </span></span><br><span class="line"><span class="comment">*** incompatible versions: msgfmt </span></span><br><span class="line"><span class="comment">*** some features will be disabled. </span></span><br><span class="line"><span class="comment">*** Check the INSTALL file for required versions.</span></span><br></pre></td></tr></table></figure><ul><li>msgfmt程序的缺失或者不兼容通常是无害的</li><li>这个msgfmt程序是Gettext软件包的一部分，主机发行版应该提供了</li></ul><hr><h3 id="调整工具链"><a href="#调整工具链" class="headerlink" title="调整工具链"></a>调整工具链</h3><ul><li>根据自身情况进行工具链调整</li><li>以下实例为LFS-v6.3的配置代码</li><li>同时也包括了部分LFS-v6.2的内容</li></ul><hr><p><strong>调整思路:</strong></p><ul><li>因为现在临时的C库已经装好，接下来本章中要编译的所有工具应该连接到这些库上</li><li>为了达到这个目标，需要调整连接器和编译器的specs文件</li><li>在第一遍编译Binutils快结束时已经调整过的连接器，现在需要被重新命名以便可以被正确的找到和使用</li><li>首先备份原来的连接器，然后用调整过的连接器来替代</li><li>最后还要创建一个指向<code>/tools/$(gcc-dumpmachine)/bin</code>中连接器副本的连接</li><li>如果当前本地主机的系统平台上，动态连接器的名字不是<code>ld-linux.so.2</code></li><li>必须人为的把spaces配置里的<code>ldlinux.so.2</code>换成你的系统平台上动态连接器的名字</li></ul><hr><ul><li>以下为工具链配置代码(LFS-6.3)<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;ld-<span class="keyword">new</span>,ld&#125; </span><br><span class="line">$ ln -sv /tools/bin/ld /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/ld </span><br><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>语句内容刨析:</strong></p><ul><li>符号链接部分</li></ul><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/$(gcc -dumpmachine)/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>-new,<span class="keyword">ld</span>&#125; </span><br><span class="line">$ ln -sv /tools/bin/<span class="keyword">ld</span> /tools/$(gcc -dumpmachine)/bin/<span class="keyword">ld</span></span><br></pre></td></tr></table></figure><ul><li><p>就是几个符号链接</p></li><li><p>当设置完成之后，所有程序都将连接到<code>/tools/lib</code>中的库文件</p></li><li><p>space部分</p></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure><p>此代码还可以拆成以下两部分</p><ul><li><p>部分一</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span>	<span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFILE</span><br></pre></td></tr></table></figure></li><li><p>用于修正GCC的specs文件，使它指向新的动态连接器</p></li><li><p>只需要像以上那样使用一个简单的sed命令就能做到</p></li><li><p>同时也可以手动编辑specs文件</p><blockquote><p>本质上就是把所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code>就行</p></blockquote></li><li><p>部分二</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>用于删除GCC专属头文件目录中的头文件</p><blockquote><p>以避免宿主系统中的头文件污染编译环境</p></blockquote></li></ul><hr><ul><li>相关说明<blockquote><p>工具链的调整方法有好几种，而且不同版本GCC的specs可能会有不同<br>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成了<code>/tools/lib/ld-linux.so.2</code><br>所以即使有些文章在调整工具链上的命令和LFS手册上的不一样也不用太奇怪<br>当然也可以 直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件<br>spaces必须加以检查以确保被修改的配置的的确确生效了</p></blockquote></li></ul><hr><h3 id="内容参考"><a href="#内容参考" class="headerlink" title="内容参考"></a>内容参考</h3><ul><li>CN-LFS-v9.0</li><li>CN-LFS-v6.3</li><li>CN-LFS-v6.2</li><li>在LFS-1的URL资源整合目录里都有说明</li></ul><hr><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>GNU-LFS-2-1</title>
    <url>/2020/02/29/GNU-LFS-2-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-1"><a href="#GNU-LFS-2-1" class="headerlink" title="GNU LFS-2-1"></a>GNU LFS-2-1</h2><hr><h3 id="构造临时系统-1-0"><a href="#构造临时系统-1-0" class="headerlink" title="构造临时系统-1.0"></a>构造临时系统-1.0</h3><ul><li>1.0-为第一遍编译并安装临时工具链内Binutils与GCC</li></ul><p><strong>概述:</strong></p><ul><li><p>对于临时系统的简述</p></li><li><p>目的是何构造一个最小的Linux系统</p></li><li><p>该系统将包含刚好足够构建目标主机中最终LFS系统所需的工具，以及一个比最小环境具有更好用户便利性的工作环境</p></li><li><p>使用的软件包皆为v6.3版本的LFS-liveCD中拥有的软件包</p></li><li><p>本文只介绍基本的[GNU 工具链]的搭建参考于v6.3与v9.0(对6.3进行补充，对9.0进行说明)</p><blockquote><p>v6.3和v9.0都有进行举例说明</p></blockquote></li><li><p>构建这个最小系统有两个步骤:</p><blockquote><p>第一步: 构建一个与宿主系统无关的新工具链(编译器、汇编器、链接器、 库和一些有用的工具)<br>第二步: 使用该工具链，去构建其它的基础工具</p></blockquote></li><li><p>临时系统中编译得到的文件将被安装在目录<code>$LFS/tools</code>中</p><blockquote><p>以确保在下一章中安装的文件和宿主系统生成的目录相互分离<br>由于此处编译的软件包都是临时性的，因此可以人为的去避免出现污染后面即将构成的LFS系统的情况发生</p></blockquote></li></ul><p><strong>需要特别注意的几点:</strong></p><ul><li>在构建的过程需要注意的问题</li></ul><ol><li>把所有源文件和补丁放到 chroot 环境可访问的目录，例如<code>/mnt/lfs/sources/</code><blockquote><p>但是千万不 能把源文件放在<code>/mnt/lfs/tools/</code>中</p></blockquote></li><li>进入到源文件目录</li><li>对于每个软件包:<blockquote><p>a. 用tar程序解压要编译的软件包<br>同时在临时系统目录中，确保解压软件包时本地主机使用的是lfs用户<br>b. 进入到解压后创建的目录中<br>c. 根据指南说明编译软件包<br>d. 回退到源文件目录<br>e. 除非特别说明，删除解压出来的目录</p></blockquote></li></ol><hr><ul><li><p>进入LFS包编译目录</p><blockquote><p><code>cd $LFS/sources</code></p></blockquote></li><li><p>第一遍编译[GNU 工具链]说明:</p><blockquote><p>在编译完成之后，通常需要运行测试套件<br>但此时测试套件框架(Tcl，Expect和DejaGNU)还没有就绪<br>同时因为此时是所有工作的初期阶段<br>所以此进行测试的收效甚微，因为第一遍编译的程序很快会被第二遍的代</p></blockquote></li></ul><hr><h3 id="1-0-0"><a href="#1-0-0" class="headerlink" title="1.0.0"></a>1.0.0</h3><p><strong>Binutils-2.17/2.32-Pass 1</strong><br><strong>安装交叉编译的Binutils</strong></p><ul><li><p>目标软件包简述:</p><blockquote><p>Binutils 软件包包含一个链接器，一个汇编器，以及其它处理目标文件的工具<br>大致构建用时: 1 SBU<br>所需磁盘空间: 580 MB</p></blockquote></li><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3配置编译</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> <span class="string">../binutils-2.17/configure</span> <span class="params">--prefix=/tools</span>  	\</span><br><span class="line">				            <span class="params">--disable-nls</span> 		\</span><br><span class="line">				            <span class="params">--disable-werror</span></span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span>  <span class="built_in">..</span>/binutils-2.32/configure 	<span class="attribute">--prefix</span>=/tools            \</span><br><span class="line">             					<span class="attribute">--with-sysroot</span>=<span class="variable">$LFS</span>        	\</span><br><span class="line">             					<span class="attribute">--with-lib-path</span>=/tools/lib 	\</span><br><span class="line">             					<span class="attribute">--target</span>=<span class="variable">$LFS_TGT</span>          	\</span><br><span class="line">             					--disable-nls              	\</span><br><span class="line">             					--disable-werror</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>CC=&quot;gcc -B/usr/bin/&quot;</code>该选项强制gcc使用宿主系统中/usr/bin目录下的连接器</p><blockquote><p>这样做的必要是因为新生成的ld可能与某些宿主系统的gcc不兼容</p></blockquote></li><li><p>参数<code>--prefix=/tools</code>用于告诉配置脚本将<code>Binutils程序</code>安装到<code>/tools</code>文件夹</p></li><li><p>参数<code>--with-sysroot=$LFS</code>用于交叉编译，告诉编译系统在<code>$LFS</code>中查找所需的目标系统库</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code>指定需要配置使用的链接器的库路径</p></li><li><p>参数<code>--target=$LFS_TGT</code>，因为<code>LFS_TGT</code>变量中的机器描述和<code>config.guess</code>脚本返回的值略有不同，这个选项会告诉<code>configure</code>脚本调整<code>Binutils</code>的构建系统来构建一个交叉链接器</p></li><li><p>参数<code>--disable-nls</code>会禁止国际化(i18n)，因为国际化对临时工具来说没有必要</p></li><li><p>参数<code>--disable-werror</code>会防止来自宿主编译器的警告事件导致停止编译</p></li><li><p>继续编译并进行编译安装</p><blockquote><p>$make<br>$make install</p></blockquote></li><li><p>为调整工具链步骤准备连接器</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ make -C <span class="keyword">ld</span> clean </span><br><span class="line">$ make -C <span class="keyword">ld</span> LIB_PATH=/tools/lib</span><br><span class="line">$ <span class="keyword">cp</span> -v <span class="keyword">ld</span>/<span class="keyword">ld</span>-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>-C ld clean</code></p><blockquote><p>用于告诉make程序删除所有ld子目录中编译生成的文件</p></blockquote></li><li><p>参数<code>-C ld LIB_PATH=/tools/lib</code></p><blockquote><p>用于这个选项重新编译ld子目录中的所有文件</p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-2.17</span></span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>上构建，创建符号链接，以确保工具链的完整性:</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">case</span> $(uname -m) in  </span><br><span class="line">	x86_64) mkdir -v /tools/<span class="class"><span class="keyword">lib</span> &amp;&amp; <span class="title">ln</span> -<span class="title">sv</span> <span class="title">lib</span> /<span class="title">tools</span>/<span class="title">lib64</span> ;</span>; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.16.2</code>的<code>Binutils内容</code></p></li></ul><hr><h3 id="2-0-0"><a href="#2-0-0" class="headerlink" title="2.0.0"></a>2.0.0</h3><p><strong>GCC-4.12/9.2.0 Pass-1</strong><br><strong>安装交叉编译的GCC</strong></p><ul><li>目标软件包简述:<blockquote><p>GCC软件包包括GNU编译器集，其中有C和C++的编译器<br>大致构建用时: 12 SBU<br>所需磁盘空间: 3.1 GB</p></blockquote></li></ul><p><strong>以下内容为LFS-v6.3的GCC编译过程</strong></p><ul><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v gcc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gcc-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3编译配置</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span> <span class="built_in">..</span>/gcc-4.1.2/configure 	<span class="attribute">--prefix</span>=/tools 		\ </span><br><span class="line">				      		 <span class="attribute">--with-local-prefix</span>=/tools 	\</span><br><span class="line">				       		--disable-nls 			\</span><br><span class="line">				       		--enable-shared 		\</span><br><span class="line">				       		<span class="attribute">--enable-languages</span>=c</span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> ../gcc-<span class="number">9.2</span>.<span class="number">0</span>/configure       	<span class="string">\</span></span><br><span class="line"> --target=$LFS_TGT                              	<span class="string">\</span></span><br><span class="line"> --prefix=/tools                                	<span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-glibc-version=<span class="number">2.11</span>                      	<span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-sysroot=$LFS                            	<span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-newlib                                  	<span class="string">\</span> </span><br><span class="line"> --without-headers                              	<span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-local-prefix=/tools                     	<span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-<span class="keyword">native</span>-system-header-dir=/tools/include 	<span class="string">\</span> </span><br><span class="line"> --disable-nls                                  	<span class="string">\</span></span><br><span class="line"> --disable-shared                               	<span class="string">\</span></span><br><span class="line"> --disable-multilib                             	<span class="string">\</span> </span><br><span class="line"> --disable-decimal-float                        	<span class="string">\</span> </span><br><span class="line"> --disable-threads                              	<span class="string">\</span> </span><br><span class="line"> --disable-libatomic                            	<span class="string">\</span> </span><br><span class="line"> --disable-libgomp                              	<span class="string">\</span> </span><br><span class="line"> --disable-libquadmath                          	<span class="string">\</span> </span><br><span class="line"> --disable-libssp                               	<span class="string">\</span> </span><br><span class="line"> --disable-libvtv                               	<span class="string">\</span></span><br><span class="line"> --disable-libstdcxx                            	<span class="string">\</span> </span><br><span class="line"> --enable-languages=c,c++</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>配置含义(参数说明):</strong></p><ul><li>参数<code>--with-newlib</code><blockquote><p>由于还没有可用的C库，这确保编译libgcc时定义了常数<code>inhibit_libc</code><br>这可以防止编译任何需要libc支持的代码</p></blockquote></li><li>参数<code>--without-headers</code><blockquote><p>在创建完整的交叉编译器时，GCC要求标准头文件和目标系统兼容<br>对于我们的目的来说，不需要这些头文件<br>这个选项可以防止GCC查找它们</p></blockquote></li><li>参数<code>--with-local-prefix=/tools GCC</code><blockquote><p>此参数会查找本地已安装的include文件的系统位置<br>默认是<code>/usr/local</code><br>把它设置为<code>/tools</code>能把主机位置中的<code>/usr/local</code>从GCC的搜索路径中排除</p></blockquote></li><li>参数<code>--with-native-system-header-dir=/tools/include</code><blockquote><p>GCC默认会在/usr/include中查找系统头文件<br>和<code>sysroot</code>选项一起使用，会转换为<code>$LFS/usr/include</code><br>在后面两个章节中头文件会被安装到<code>$LFS/tools/include</code><br>这个选项确保 gcc 能正确找 到它们<br>第二次编译 GCC 时，同样的选项可以保证不会去寻找主机系统的头文件</p></blockquote></li><li>参数<code>--disable-shared</code><blockquote><p>这个选项强制GCC静态链接到它的内部库<br>我们这样做是为了避免主机系统可能出现的问题</p></blockquote></li><li>参数:<blockquote><p><code>--disable-decimal-float</code>,<code>--disable-threads</code>,<code>--disable-libatomic</code>,<code>--disablelibgomp</code>,<br><code>--disable-libquadmath</code>,<code>--disable-libssp</code>,<code>--disable-libvtv</code>,<code>--disablelibstdcxx</code><br>这些选项取消了对十进制浮点数扩展，线程化，<code>libatomic</code>，<code>libgomp</code>，<code>libquadmath</code>，<code>libssp</code>，<code>libvtv</code>，<code>libcilkrts</code>和<code>C++</code>标准库的支持<br>这些功能在编译 交叉编译器的时候会导致编译失败，对于交叉编译临时 libc 来说也没有必要</p></blockquote></li><li>参数<code>--disable-multilib</code><blockquote><p>在<code>x86_64</code>机器上，LFS 还不支持<code>multilib</code>配置<br>这个选项对 x86 来说无害</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保只编译 C 和 C++ 编译器<br>这些是现在唯一需要的语言</p></blockquote></li><li>此时只编译了GCC里的C编译器</li></ul><hr><ul><li><p>编译并安装</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; $ make bootstrap</span></span><br><span class="line"><span class="quote">&gt; $ make install</span></span><br></pre></td></tr></table></figure></li><li><p>创建符号连接(工具链)</p><blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-build </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-4.1.2</span></span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.21.2</code>的GCC软件包内容里</p></li></ul><hr><ul><li>对于工具链内的工具或其它软件的编译安装大致可分为以下几步:</li></ul><ol><li>创建目录</li><li>配置编译器与其脚本文件</li><li>编译并安装</li><li>配置工具链</li></ol><ul><li>配置其它独有(针对于不同工具的特殊配置)性质</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>金钟国的v6.3-LFS</p></li><li><p>孙海勇的v6.3-LFS</p></li><li><p>LFS-v9.0</p></li><li><p><code>5.4. Binutils-2.18 - 第一遍</code><a href="https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html</code></p></blockquote></li><li><p><code>gcc -B/usr/bin -B</code>的含义<a href="https://www.169it.com/tech-qa-linux/article-10702497996978005026.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.169it.com/tech-qa-linux/article-10702497996978005026.html</code></p></blockquote></li><li><p>百度知道<a href="https://zhidao.baidu.com/question/501313846.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zhidao.baidu.com/question/501313846.html</code></p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>对于9.2.0版本的GCC的补充内容</strong></p><ul><li><p>需要GMP，MPFR和MPC 软件包</p></li><li><p>在本地的主机发行版中可能并不包括这些软件包，它们将和GCC一起编译</p></li><li><p>将每个解压软件包到 GCC 的目录下，并重命名解压后得到的目录，以便GCC编译过程中能自动使用这些软件</p></li><li><p>执行以下命令:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ tar -xf ../mpfr<span class="number">-4.0</span><span class="number">.2</span>.tar.xz</span><br><span class="line">$ mv -v mpfr<span class="number">-4.0</span><span class="number">.2</span> mpfr </span><br><span class="line">$ tar -xf ../gmp<span class="number">-6.1</span><span class="number">.2</span>.tar.xz</span><br><span class="line">$ mv -v gmp<span class="number">-6.1</span><span class="number">.2</span> gmp</span><br><span class="line">$ tar -xf ../mpc<span class="number">-1.1</span><span class="number">.0</span>.tar.gz</span><br><span class="line">$ mv -v mpc<span class="number">-1.1</span><span class="number">.0</span> mpc</span><br></pre></td></tr></table></figure></li><li><p>下面的指令将会修改GCC默认的动态链接器的位置，安装到<code>/tools</code>目录中的</p></li><li><p>并将<code>/usr/include</code>从GCC的include检索路径中移除</p></li><li><p>执行以下命令:</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">$ for file in gcc/config/&#123;linux,i386/linux&#123;,64&#125;&#125;<span class="string">.h</span> </span><br><span class="line">do  </span><br><span class="line">cp -uv $file&#123;,<span class="string">.orig</span>&#125;  </span><br><span class="line">sed -e 's@<span class="string">/lib</span>\<span class="params">(64\)</span>\?\<span class="params">(32\)</span>\?<span class="string">/ld</span>@<span class="string">/tools</span>&amp;@g' \</span><br><span class="line">-e 's@<span class="string">/usr</span>@<span class="string">/tools</span>@g' $file.orig &gt; $file  </span><br><span class="line"><span class="keyword">echo</span> ' </span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_1 </span></span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_2 </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/" </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file  </span></span><br><span class="line">touch $file.orig </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>参数解析:</strong></p><p><strong>执行逻辑说明:</strong></p><ol><li>首先复制文件<code>gcc/config/linux. h</code>,<code>gcc/config/i386/linux.h</code>，和<code>gcc/config/i368/linux64.h</code></li><li>然后给复制的文件加上<code>.orig</code>后缀</li><li>然后第一个sed表达式在每个<code>/lib/ld</code>,<code>/lib64/ld</code>或者<code>/lib32/ld</code>实例前面增加<code>/tools</code><blockquote><p>第二个sed表达式替换<code>/usr</code>的硬编码实例</p></blockquote></li><li>然后添加这改变默认<code>startfile前缀</code>到文件末尾的定义语句<blockquote><p>此时需要注意<code>/tools/lib/</code>后面的<code>/</code>是必须的</p></blockquote></li><li>最后用<code>touch</code>更新复制文件的时间戳<blockquote><p>当与<code>cp -u</code>一起使用时，可以防止命令被无意中运行两次造成对原始文件意外的更改</p></blockquote></li></ol><hr><ul><li>在<code>x86_64</code>的主机上，为64位的库设置默认目录名至[lib]:</li><li>执行以下命令:<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span><span class="keyword">case</span> <span class="variable">$(</span>uname -m) <span class="keyword">in</span>  </span><br><span class="line">x86_64)</span><br><span class="line">sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \        </span><br><span class="line">-i.orig gcc/config/i386/t-linux64 </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><ul><li><p>在LFS-v6.3版本中</p></li><li><p>这里要注意第一遍编译的时候编译器参数需要指定:<code>CC=&quot;gcc -B/usr/bin/</code></p><blockquote><p>用以强制gcc使用宿主系统中/usr/bin目录下的连接器</p></blockquote></li><li><p>ld-GNU链接器</p></li><li><p>在第一次工具链调整之后需要进行一次可用性测试</p></li><li><p>在第二次编译安装完成GCC后需要进行一次可用性测试</p></li><li><p>测试组件</p><blockquote><p>Tcl-8.4.15<br>Expect-5.43.0<br>DejaGNU-1.4.4</p></blockquote></li></ul><hr><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>参考自LFS-v9.0第5.5章节</p></li><li><p>LFS-v9.0<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>LFS-v6.2</p><blockquote><p>参考金步国的中文译本</p></blockquote></li><li><p>LFS-v6.3</p><blockquote><p>参考孙海勇的中文译本</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU-LFS-1</title>
    <url>/2020/02/28/GNU-LFS-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="LFS-1"><a href="#LFS-1" class="headerlink" title="LFS-1"></a>LFS-1</h3><ul><li>参考资料为CN-[LFS-BOOK(v9.0)]-PDF版</li></ul><hr><p><strong>文案说明:</strong></p><ul><li><p>GNU LFS-1-x 为LFS基本配置描述</p></li><li><p>GNU LFS-2-x 为临时系统描述</p></li><li><p>GNU LFS-3-x 为目标主机描述</p></li><li><p>进入chroot来操作目标主机</p></li><li><p>因为文章内关于LFS-v6.3或LFS-v6.2的内容使用了相近的解释，所以对于版本参数的描述可能有些凌乱</p></li><li><p>所以版本的问题需要就具体情况而定，文章里不会做对版本的细致区别</p></li><li><p>6.2和6.3版本的LFS有一个比较大的区别就是内核文件的不同，其它近乎相同</p></li><li><p>同时文章内的内容与资料仅供参考，具体实践还需查阅官方文档</p></li><li><p>使用6.3版本的原因是因为LFS官方的LiveCD的最新版本为6.3版本</p></li></ul><p><strong>本地主机环境一览:</strong></p><ul><li>原主机环境准备</li><li>主机内存(RAM)为4GB</li><li>主机磁盘为30GB</li><li>CPU为4核-2.2GHZ</li><li>本地主机硬盘接口类型为SCSI</li><li>磁盘分区表类型为MBR(GPT/GUID不做阐述)</li><li>磁盘启动引导类型为BIOS(UEFI不做阐述)</li><li>CD使用LFS-liveCD-v6.3(2007)</li></ul><hr><h3 id="1-0-0-1-2-7"><a href="#1-0-0-1-2-7" class="headerlink" title="1.0.0-1.2.7"></a>1.0.0-1.2.7</h3><p><strong>1.0.0</strong></p><ul><li>使用cfdisk工具对原主机进行分区(也可以使用fdisk工具进行分区操作)<blockquote><p><code>$cfdisk /dev/sda</code></p></blockquote></li></ul><p><strong>1.1.0 格式化磁盘分区</strong></p><ul><li><p>Swap分区(swap)</p><blockquote><p><code>$mkswap /dev/&lt;yyy&gt;</code><br><code>$mkswap /dev/sda1</code></p></blockquote></li><li><p>LFS分区(ext)</p><blockquote><p><code>$mkfs -v -t ext4/ext3 /dev/&lt;xxx&gt;</code><br><code>$mkfs.ext4/ext3 /dev/sda2</code><br><code>$mkfs -v -t ext3 /dev/sda2</code></p></blockquote></li><li><p>格式化为ext3文件系统</p><blockquote><p><code>mke2fs -jv /dev/&lt;xxx&gt;</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>前者为标准格式，后者为实例</li><li>在原主机磁盘上创建新分区</li><li>由于是LFS官方提供的liveCD，所以此时的原主机没有任何分区</li><li>这里创建两个本地的主分区: /dev/sda1用于交换分区(swap)，/dev/sda2用作目标主机制作环境，分区文件格式为ext3(或ext3/ext4等等)</li><li>存储容量分别是7000B与530000B(拟定，因本地主机的处理器指令集位数问题，实际情况会发生细微变动)</li></ul><hr><p><strong>1.2.0 设置LFS所处目录的系统变量</strong></p><ul><li>因为整个实现过程需要多次用到LFS系统的目录，所以先将LFS系统目录设置为LFS变量(变量名自拟，这里为LFS，即$LFS)</li><li>因为这里将要把LFS分区挂载到/mnt目录中，所以可以将LFS系统目录建立到/mnt目录内，以下指令直接创建环境变量:<blockquote><p><code>$export LFS=/mnt/lfs</code></p></blockquote></li></ul><p><strong>1.2.1 将新分区(LFS系统分区)进行挂载</strong></p><ul><li>挂载的目是访问所被挂载的分区，上一步中将分区所在目录设为了$LFS变量所指向的地址</li><li>创建挂载点<blockquote><p><code>mkdir -pv $LFS</code></p></blockquote></li><li>挂载LFS分区及其文件系统(文件可以自动识别，即便不加也是可以的)<blockquote><p><code>mount -v -t ext3/ext4 /dev/&lt;xxx&gt; $LFS</code><br><code>mount -v -t ext3 /dev/sda2 $LFS</code><br><code>mount /dev/sda2 $LFS</code></p></blockquote></li><li>(非必要)挂载并使用swap分区<blockquote><p><code>/sbin/swapon -v /dev/&lt;zzz&gt;</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>这里与以后的说明都将/dev/sda2分区称为LFS分区，即目标系统根目录</li><li>交换分区(swap)的作用是可以有效的解决编译过程中所需内存的不足，所以可以分出一个小型磁盘分区来当作swap空间</li><li>所以swap的容量可以按需分配，而sda2当然是越大越好</li><li>宿主机(原主机)和LFS分区的swap是公用的，如果原宿主机拥有swap，就没有必要再新建一个了</li><li>有关于磁盘分区的标志与其它分区表类型和启动引导类型的内容这里就不做过多赘述了</li></ul><hr><p><strong>1.2.2 创建必要目录以及目录权限分配</strong></p><ul><li><p>今后在第二阶段(临时系统)制作的时候会将所有的软件编译到<code>$LFS/tools</code>中，以便与第三阶段时所编译的软件完全分离</p></li><li><p>在目标系统成型后，便可将其遗弃</p></li><li><p>执行以下操作需要root权限</p></li><li><p>创建工具链目录<code>$LFS/tools</code></p><blockquote><p><code>mkdir -v $LFS/tools</code></p></blockquote></li><li><p>在原主机内创建符号链接，用以指向LFS分区中新建的目录(/tools)</p></li><li><p>此时所创建的符号链接将永远指向<code>/tools</code>文件夹</p><blockquote><p>即编译器，汇编器，链接器无论是在临时系统或是目标系统中都可以进行使用</p></blockquote></li><li><p>配置符号链接</p><blockquote><p><code>ln -sv $LFS/tools /</code></p></blockquote></li></ul><p><strong>1.2.3 创建源代码编译用目录</strong></p><blockquote><p><code>mkdir -v $LFS/sources</code></p></blockquote><ul><li>权限分配<blockquote><p><code>chmod -v a+wt $LFS/sources</code></p></blockquote></li></ul><hr><p><strong>1.2.4 添加LFS用户(自定义非特权用户命名)</strong></p><ul><li>因为以root用户登陆时，一个操作失误便可以摧毁整个操作系统，所以在此需要新建一个非特权用户来对软件包进行编译</li><li>同时也是为了建立一个干净的工作环境，这里创建一个名为lfs的新用于作为新组(同样命名为lfs)的成员</li><li>添加新用户:<blockquote><p><code>groupadd lfs</code></p></blockquote></li><li>将新用户lfs的shell设为默认bash，并将用户lfs添加到lfs组中，同时为lfs用户创建主目录</li><li>并对用户输入位置设置为空设备(null)，以防止可能从框架目录复制文件的情况<blockquote><p><code>useradd -s /bin/bash -g lfs -m -k /dev/null lfs</code></p></blockquote></li><li>设置lfs用户密码，可以为空<blockquote><p><code>passwd lfs</code></p></blockquote></li><li>将目录所有者改变为lfs<blockquote><p><code>chown -v lfs $LFS/tools</code></p></blockquote></li><li>同时为用户lfs赋予访问$LFS/tools目录的所有权限<blockquote><p><code>chown -v lfs $LFS/sources</code></p></blockquote></li><li>以lfs身份登陆主机</li><li>切换用户并启动shell环境<blockquote><p><code>su - lfs</code></p></blockquote></li></ul><hr><p><strong>1.2.5 设置环境</strong></p><ul><li>通过为bash shell创建两个开机启动文件，来设置合适的工作环境</li><li>以lfs用户的身份来创建一个新的<code>.bash_profile</code>文件<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cat &gt; ~/.bash_profile &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line">exec env -i <span class="attribute">HOME</span>=<span class="variable">$HOME</span> <span class="attribute">TERM</span>=<span class="variable">$TERM</span> <span class="attribute">PS1</span>=<span class="string">'\u:\w\$ '</span> /bin/bash </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li>当以lfs用户身份登录时，初始shell通常是一个login的shell</li></ul><ol><li>它先读取宿主机的<code>/etc/profile</code>文件(很可能包括一些设定和环境变量)</li><li>然后是<code>.bash_profile</code>文件</li><li><code>.bash_profile</code>中的命令<code>exec env -i.../bin/bash</code>用一个除了HOME，TERM和PS1变量外</li><li>其他环境完全为空的新shell代替运行中的shell</li><li>这能确保不会有潜在的和意想不到的危险环境变量，从宿主机泄露到构建环境中</li><li>这样做主要是为了确保环境的干净</li></ol><hr><p><strong>1.2.6 配置<code>.bashrc</code>文件</strong></p><ul><li>新的shell实例是一个<code>non-login</code>的shell</li><li>它不会读取<code>/etc/profile</code>或者<code>.bash_profile</code>文件，而是读取<code>.bashrc</code></li><li>创建<code>.bashrc</code>文件:<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">cat &gt; ~/.bashrc &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="builtin-name">set</span> +h </span><br><span class="line">umask 022 </span><br><span class="line"><span class="attribute">LFS</span>=/mnt/lfs </span><br><span class="line"><span class="attribute">LC_ALL</span>=POSIX </span><br><span class="line"><span class="attribute">LFS_TGT</span>=$(uname -m)-lfs-linux-gnu </span><br><span class="line"><span class="attribute">PATH</span>=/tools/bin:/bin:/usr/bin </span><br><span class="line"><span class="builtin-name">export</span> LFS LC_ALL LFS_TGT PATH </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li><code>set +h</code>命令关闭了bash的哈希功能</li><li>设置用户文件新建时的掩码(umask)为 022，以确保新建的文件和目录只有其所有者可写，但任何人都可读可执行</li><li>LFS 变量应设置成选定的挂载点</li><li><code>LC_ALL变量</code>控制某些程序的本地化，使它们的消息遵循特定国家的惯例</li><li>设置<code>LC_ALL</code>为<code>POSIX</code>或<code>C</code>(两者是等价的)，以确保在chroot环境中一切能如期望的那样进行</li><li><code>LFS_TGT变量</code>设置了一个虽非默认，但在构建交叉编译器、连接器和交叉编译临时工作链时，用得上到的兼容的机器说明</li><li>通过把<code>/tools/bin</code>放在标准<code>PATH变量</code>的前面，使得所有在临时主机中安装的程序，一经安装shell便能马上使用</li><li>与之配合的关闭哈希功能，能在临时主机环境中的程序在可用的情况下，限制使用宿主机中旧程序的风险</li></ul><hr><ul><li>1.2.7 启用配置</li><li>最后，启用刚才创建的用户配置</li><li>为构建临时工具完全准备好环境:<blockquote><p><code>source ~/.bash_profile</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Disk-1</title>
    <url>/2020/02/28/Disk/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Disk-1"><a href="#Disk-1" class="headerlink" title="Disk-1"></a>Disk-1</h2><hr><h3 id="Disk-引导逻辑全过程描述"><a href="#Disk-引导逻辑全过程描述" class="headerlink" title="Disk 引导逻辑全过程描述"></a>Disk 引导逻辑全过程描述</h3><ul><li>磁盘从底层固件引导至操作系统启动所对应的执行逻辑</li><li>本篇内容仅为主观描述，仅供参考</li></ul><p><strong>执行逻辑简述:</strong></p><p>Linux</p><blockquote><p><code>BIOS/UEFI(ROM)-&gt;MBR/GPT/GUID-(LBA/CHS)-&gt;VBR-&gt;grldr-&gt;boot loader-&gt;GRUB/LILO...-&gt;启动整个Linux系统</code></p></blockquote><p>windows</p><blockquote><p><code>BIOS-&gt;MBR-&gt;DPT-&gt;PBR-&gt;Bootmgr-&gt;BCD-&gt;系统选择界面--&gt;选择windows-NT-&gt;Winload.exe-&gt;内核加载等 -&gt;启动整个windows-NT系统</code></p></blockquote><p><strong>文字描述:</strong></p><ol><li><p>先给基于ROM的固件BIOS/UEFI通电(启动/运行)，以加载磁盘主引导程序</p></li><li><p>POST(Power-On Self-Test)，基于BIOS程序进行对本地主机的硬件自检</p></li><li><p>基于对应固件类别来加载引导扇区(Boot Sequence)</p><blockquote><p>BIOS根据Boot Sequence中的顺序，将最前面的存储设备的引导扇区的内容加载到内存中，并跳转到引导程序的第一条指令</p></blockquote></li><li><p>再通过基于主引导记录类型(MBR/GPT/GUID)来指定的寻址模式(LBA/CHS)来寻找已有的开机引导程序(进入磁盘启动环节)</p><blockquote><p>关于MBR与GPT的内容可参考历史文章</p></blockquote></li><li><p>基于某个类别的主引导记录类型利用分区表将控制权转交给硬盘的某个分区</p><blockquote><p>此时在四个主分区里面，只有一个是激活的计算机会读取激活分区的第一个扇区，叫做卷引导记录(Volume Boot Record，缩写为VBR，也可称为分区引导记录，Partition Boot Record，缩写为PBR)<br>卷引导记录的有以下主要作用:<br>寻找激活分区根目录下的grldr(Grub),NTLDR(XP),bootmgr(Win7 above),btldr.mbr(BootLink)等可用于引导的程序</p></blockquote></li><li><p>执行启动管理器(boot loader)，此时卷引导记录搜索到激活分区中的启动管理器，将控制权交给启动管理器运行</p><blockquote><p>boot loader是系统预先安装的程序，用以实现由用户选择启动哪一个操作系统<br>启动管理器寻找激活分区中的启动配置数据(如: Win7中的BCD文件、XP中的boot.ini文件)，根据启动配置数据，在显示器上显示多操作系统选择画面<br>然后选择相应的操作系统<br>最后控制权交给操作系统<br>Linux环境中，目前最流行的启动管理器是Grub<br>在windows下为启动管理器bootmgr(xp中的ntldr文件)</p></blockquote></li><li><p>下一步是将控制权转交给操作系统，以此让操作系统的内核首先被载入内存</p></li><li><p>最后实现磁盘内操作系统的启动</p></li></ol><p><strong>或</strong></p><ol><li>由BIOS/UEFI寻找第一个可启动设备(通常为Disk)</li><li>然后从MBR/GPT/GUID中基于的寻址模式来加载启动程序</li><li>最终把代码控制权交给GRUB(或其它引导程序)</li></ol><ul><li>所谓操作系统的引导过程是将存放在硬盘上的静态的操作系统装载到内存中，并开始执行操作系统的过程</li><li>每一个不同类别的工具都有完全不同的执行逻辑与所执行步骤对应的执行标志，这里先不做过多阐述</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>引导扇区: 主引导记录(主引导扇区)/全局唯一标识符(全局唯一标识分区表)<blockquote><p>MBR/GPT/GUID</p></blockquote></li><li>磁盘引导程序所基于的寻址模式(LBA/CHS)</li><li>LVM/RAID(逻辑卷管理/磁盘阵列)</li><li>BIOS/UEFI(固件系统)</li><li>磁盘/磁盘分区所属数据类型/文件系统</li><li>磁盘映像文件格式</li><li>磁盘驱动/硬件驱动/设备驱动</li><li>扩展分区(Extended partition)和逻辑分区(logical partition)<blockquote><p>扩展引导记录(Extended boot record)缩写为EBR</p></blockquote></li><li>MBR/GPT分区表</li><li>启动管理器(boot loader)</li></ul><hr><p><strong>磁盘缓存(Disk Buffer/Disk Cache)相关概述:</strong></p><ul><li><p>用于将下载到的数据先保存于系统为软件分配的内存空间中(这个内存空间被称之为”内存池”)</p><blockquote><p>当保存到内存池中的数据达到一个程度时，便会将数据保存到硬盘中<br>这样可以减少实际的磁盘操作，有效的保护磁盘免于重复的读写操作而导致的损坏</p></blockquote></li><li><p>磁盘缓存是为了减少CPU透过I/O读取磁盘驱动器的次数</p><blockquote><p>提升磁盘I/O的效率，用一块存储器来存储访问较频繁的磁盘内容<br>因为存储器的访问是电子动作，而磁盘的访问是机械动作，感觉上磁盘I/O变得较为快速</p></blockquote></li><li><p>普遍的磁盘通常有32MB或64MB缓存，现在市售上128MB与256MB也十分常见</p><blockquote><p>旧的硬盘则有8MB或16MB</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-磁盘缓存<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98</code></p></blockquote></li><li><p>CN-阮一峰-计算机是如何启动的?<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ruanyifeng.com/blog/2013/02/booting.html</code></p></blockquote></li><li><p>CSDN-操作系统引导过程<a href="https://blog.csdn.net/jonathan321/article/details/51987680" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/jonathan321/article/details/51987680</code></p></blockquote></li><li><p>CSDN-操作系统引导程序学习笔记<a href="https://blog.csdn.net/aice_dachong/article/details/50843240" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/aice_dachong/article/details/50843240</code></p></blockquote></li><li><p>CSDN-操作系统概念：系统引导过程、引导程序、固件<a href="https://blog.csdn.net/qq_36328643/article/details/79922425" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36328643/article/details/79922425</code></p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>硬盘的物理结构描述与图解:</strong></p><ul><li>磁盘的物理结构图例-1</li></ul><img src="/images/disk-images/磁盘-1.png" width="20%" height="20%"><ul><li>磁道(Track)</li><li>柱面(Cylinder)</li><li>扇区(Sector)</li><li>磁头(Heads)</li><li>盘片(Platters)</li><li>每个碟片都有两面，因此也会相对应每碟片有2个磁头</li></ul><hr><ul><li>磁盘的物理结构图例-2</li></ul><img src="/images/disk-images/磁盘-6.png" width="20%" height="20%"><ul><li>A: 磁道</li><li>B: 扇面</li><li>C: 扇区</li><li>D: 簇(扇区组)</li><li>在硬盘上定位某一数据记录位置—C扇区，使用了三维定位</li></ul><hr><ul><li>其它磁盘物理结构有关图片</li></ul><img src="/images/disk-images/磁盘-2.png" width="20%" height="20%"> <img src="/images/disk-images/磁盘-3.png" width="20%" height="20%"> <img src="/images/disk-images/磁盘-4.png" width="20%" height="20%"> <img src="/images/disk-images/磁盘-5.png" width="20%" height="20%"><hr><p><strong>图片来源:</strong></p><ul><li><p>CN-简书<a href="https://www.jianshu.com/p/42308db1fcde" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/42308db1fcde</code></p></blockquote></li><li><p>CN Wiki-GPT<a href="https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8</code></p></blockquote></li><li><p>CN Wiki-磁盘<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Disk</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU GRUB</title>
    <url>/2020/02/28/GNU-GRUB/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GRUB-简述"><a href="#GRUB-简述" class="headerlink" title="GRUB 简述"></a>GRUB 简述</h3><ul><li>概述</li><li>启动过程(逻辑)</li><li>特性(相对于LILO或其它的引导程序)</li><li>相关概念</li></ul><p><strong>概述:</strong></p><ul><li>GNU GRUB，简称GRUB</li><li>基于GNU通用公共许可证</li><li>是一个来自GNU项目的启动引导程序</li><li>GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统并在计算机启动时选择希望运行的操作系统</li><li>GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数</li><li>GNU GRUB的前身为Grand Unified Bootloader</li><li>它主要用于类Unix系统</li><li>同大多Linux发行版一样，GNU系统也采用GNU GRUB作为它的启动器</li><li>Solaris从10 1/06版开始在x86系统上也采用GNU GRUB作为启动器</li></ul><hr><p><strong>GRUB启动过程:</strong></p><ol><li>计算机启动后，BIOS将寻找第一个可启动的设备(通常为硬盘)</li><li>而后从MBR中加载启动程序，然后把控制交给这段代码</li><li>MBR位于硬盘的前512字节内</li></ol><ul><li>GRUB第一版的启动过程</li></ul><ol><li>GRUB的步骤1包含在MBR中<blockquote><p>由于受MBR的大小限制，步骤1所做的几乎只是装载GRUB的下一步骤(存放在硬盘的其它位置)</p></blockquote></li><li>步骤1既可以直接装载步骤2，也可以装载步骤1.5: GRUB的步骤1.5包含在MBR后面的30千字节中</li><li>步骤1.5加载步骤2</li><li>当步骤2启动后，它将呈现一个界面来让用户选择启动的操作系统<blockquote><p>这步通常采用的是图形菜单的形式，如果图形方式不可用或者用户需要更高级的控制<br>可以使用GRUB的命令行提示，通过它，用户可以手工指定启动参数<br>GRUB还可以设置超时后自动从某一个内核启动</p></blockquote></li></ol><ul><li>GRUB第二版的启动过程</li><li>与GRUB第一版相似的是，<code>boot.img</code>像步骤1一样在MBR或在启动分区中<blockquote><p>但是，它可以从任何LBA48地址的一个扇区中读取</p></blockquote></li></ul><ol><li>它(boot.img)将读取core.img(产生于diskboot.img)的第一个扇区以用来后面读取core.img的剩余部分</li><li>core.img正常情况下跟步骤1.5储存在同一地方并且有着同样的问题<blockquote><p>可是，当他被移动到一个文件系统或一个纯粹的分区时会比在步骤1.5移动或删除引起更少的麻烦<br>一旦完成读取，core.img会读取默认的配置文件和其他需要的模块</p></blockquote></li></ol><ul><li>当GRUB启动后的执行逻辑(NT内核的特点)</li><li>一旦选择了启动选项，GRUB把选择的内核加载内存并把控制交给内核<blockquote><p>在此步骤中，对于Windows之类不支持多启动标准的操作系统，GRUB也可以通过链式启动把控制传给其它启动器<br>在这种情况下，其它操作系统的启动程序被GRUB保存了下来</p></blockquote></li><li>与内核不同，其它操作系统如同直接自MBR启动<blockquote><p>类似Windows的启动菜单，也许是另一个启动管理器，它允许在多个不支持多启动的操作系统中做进一步的选择<br>在已有Windows的系统上面，或者包含多个Windows版本的系统上安装现代的Linux而不修改原操作系统，即属于这类情况</p></blockquote></li></ul><hr><p><strong>GRUB特点:</strong></p><ul><li><p>GRUB的一个重要的特性是安装它不需依附一个操作系统</p><blockquote><p>但是，这种安装需要一个Linux/Windows副本<br>由于单独工作，GRUB实质上是一个微型系统，通过链式启动的方式，它可以启动所有安装的主流操作系统</p></blockquote></li><li><p>与LILO不同，修改GRUB的配置文件后，不必把GRUB重新安装到MBR或者某个分区中</p></li><li><p>在Linux中，<code>$grub-install</code>命令是用来把GRUB的步骤1安装到MBR或者分区中的</p><blockquote><p>GRUB的配置文件、步骤2以及其它文件必须安装到某个可用的分区中<br>如果这些文件或者分区不可用，步骤1将把用户留在命令行界面</p></blockquote></li><li><p>GRUB Legacy的配置文件</p><blockquote><p>为<code>/boot/grub/menu.lst</code>或<code>/boot/grub/grub.conf</code></p></blockquote></li><li><p>GRUB 2的配置文件</p><blockquote><p>为<code>/boot/grub/grub.conf</code></p></blockquote></li><li><p>除了硬盘外，GRUB也可安装到光盘、软盘和闪存盘等移动介质中</p><blockquote><p>以此引导一台无法从硬盘启动的系统</p></blockquote></li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>LILO</li><li>SYSLINUX</li><li>GRUB</li><li>UEFI</li><li>BIOS</li><li>MBR</li><li>GPT</li><li>NTLDR</li><li>Windows Boot Manager</li></ul><hr><h3 id="GRUB-使用方法与相关指令简述"><a href="#GRUB-使用方法与相关指令简述" class="headerlink" title="GRUB 使用方法与相关指令简述"></a>GRUB 使用方法与相关指令简述</h3><ul><li>grub命令是多重引导程序grub的命令行shell工具</li><li>基本语法:<blockquote><p><code>$grub [options]</code></p></blockquote></li><li>直接键入grub则直接进入grub命令行</li><li>其它参数这里不过过多阐述</li></ul><hr><ul><li><p>正常启动情况下，屏幕上出现grub的启动项选择菜单时按<code>c键</code>也是可以进入<code>grub&gt;</code>状态的</p></li><li><p>grub指令最重要且最常用的功能就是用来启动损坏的或者是LFS的已独立系统</p></li><li><p>用grub的命令来手工启动系统只需要用到四个命令<code>boot</code>，<code>kernel</code>，<code>initrd</code>，<code>boot</code></p></li><li><p>参数<code>--help</code>用于显示帮助信息</p></li><li><p>列出当前电脑上可能的磁盘设备</p><blockquote><p><code>grub&gt; root (hd/sd</code><br>然后按两次TAB键<br>通常会输出硬盘为<code>hd0/hd1</code>或<code>sd0/sd1</code>等</p></blockquote></li><li><p>选择本地主机的安装Linux系统的硬盘</p></li><li><p>比如<code>hd0</code>，执行</p><blockquote><p><code>grub&gt; root (hd0,</code><br>再按两次TAB键<br>通常输出并列出本地主机第一块硬盘上的分区情况<br>此时可以知道哪个是swap交换分区(0x82)或哪个是Linux分区(0x83)</p></blockquote></li><li><p>然后选择可能的/boot目录所在的分区</p><blockquote><p>执行<code>root (hd0, 1)</code>并回车</p></blockquote></li><li><p>查看所选分区是否为<code>/boot</code>所在分区(根目录分区判断)</p><blockquote><p><code>grub&gt; cat /xxx/xxx</code><br>xxx为指定文件目录<br>按两次TAB键</p></blockquote></li><li><p>这里以输入<code>cat /sbin/init</code>来举例，连按两次TAB键之后参考以下两种情况:</p></li></ul><ol><li>如果出现一些init开头的文件，则说明该分区为<code>/</code>所在的分区</li><li>如果没有出现/sbin/init文件，说明(hd0,1)分区仅仅是<code>/boot</code>分区而不是<code>/</code>分区<blockquote><p>此时需要重新输入<code>$root (hd0,N)</code>命令，这里N是某个Linux分区<br>然后再试<code>cat /sbin/init</code>， 直到屏幕上出现<code>/sbin/init</code><br>则说明找到了<code>/</code>分区<br>严格来说，应该是<code>/sbin</code>目录所在的分区</p></blockquote></li></ol><ul><li><p>此指令还可用于判断所选分区内的文件目录与拥有文件，利用所存储文件的类别来判断分区的作用及分区名</p></li><li><p>这里的关键问题是如何确定系统的几个分区: <code>/boot</code>，<code>/</code>与<code>/sbin</code></p></li><li><p>比如输入<code>cat /boot/vm</code>并按两次TAB键</p><blockquote><p>如果出现一些<code>vm</code>开头的文件，比如<code>vmlinuz-2.6.15-26-386</code>说明这里是<code>/boot</code>所在的分区</p></blockquote></li><li><p>再输入<code>cat /boot/initrd</code>并按两次TAB键</p><blockquote><p>如果出现一些<code>initrd</code>开头的文件，比如<code>initrd.img-2.6.15-26-386</code>说明这个<code>/boot</code>所在的分区有<code>initrd</code>即<code>ramdisk</code>镜像</p></blockquote></li></ul><p><strong>通用指令集:</strong></p><ul><li>一般情况下，依次输入以下命令即可以进入(启动)系统<blockquote><p><code>root (hd0,1)</code> # 此时假设<code>/dev/hda2</code>是本地主机的<code>/boot</code>所在的分区<br><code>kernel /boot/vmlinuz-2.6.15-26-386 ro dev=/dev/hda3</code> # 此时假设<code>/dev/hda3</code>是本地主机的根目录<code>/</code>所在的分区<br><code>initrd /boot/initrd.img-2.6.15-26-386</code><br><code>boot</code><br>双引号</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-WIKI-GNU GRUB<a href="https://zh.wikipedia.org/wiki/GNU_GRUB" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU_GRUB</code></p></blockquote></li><li><p>EN-GNU 官网<a href="https://www.gnu.org/software/grub/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/grub/</code></p></blockquote></li><li><p>EN-GNU 手册<a href="https://www.gnu.org/software/grub/manual/grub/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/grub/manual/grub/</code></p></blockquote></li><li><p>CN-GRUB 2 中文指南<a href="http://wiki.ubuntu-tw.org/index.php?title=GRUB_2_%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://wiki.ubuntu-tw.org/index.php?title=GRUB_2_%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97</code></p></blockquote></li><li><p>CN-GRUB入门教程(Ubantu论坛)<a href="https://forum.ubuntu.org.cn/viewtopic.php?t=2475" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://forum.ubuntu.org.cn/viewtopic.php?t=2475</code></p></blockquote></li><li><p>EN-mmap.page<a href="https://mmap.page/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mmap.page/</code></p></blockquote></li><li><p>CN-GRUB指令集整合<a href="https://man.linuxde.net/grub" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://man.linuxde.net/grub</code></p></blockquote></li><li><p>CN-Linux命令大全<a href="https://man.linuxde.net/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://man.linuxde.net/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Disk</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Toolchain/GNU toolchain</title>
    <url>/2020/02/27/Toolchain-GNU-toolchain/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="工具链基本概念简述-1"><a href="#工具链基本概念简述-1" class="headerlink" title="工具链基本概念简述-1"></a>工具链基本概念简述-1</h2><ul><li>此模块只做简单的概述与对于概念的浅层理解</li><li>工具环境所需要的包这里不做过多赘述(与工具链无关)</li></ul><hr><h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p><strong>概述:</strong></p><ul><li>Toolchain</li><li>在开发软件过程中，一组工具链(toolchain)是一系列用于制作软件程序的工具</li><li>这些工具一般一个接一个地运用，上一个工具的输出即是下一个工具的输入，因此得名</li><li>但工具链这个词汇也可指涉这些工具并无此相依运行的限制</li><li>工具链与集成开发环境形成对照，分别代表了两种不同风格的软件开发环境</li></ul><p><strong>基本构成:</strong></p><ul><li>通常一个软件开发的工具链由以下组成:</li></ul><ol><li>编译器</li><li>链接器 (将源代码/目标代码转换成可执行程序档)</li><li>库 (提供与操作系统之间的界面)</li><li>调试器 (用来测试、调试所产出的程序)</li></ol><hr><h3 id="GNU-工具链"><a href="#GNU-工具链" class="headerlink" title="GNU 工具链"></a>GNU 工具链</h3><p><strong>概述:</strong></p><ul><li>GNU toolchain</li><li>是一个包含了由GNU计划所产生的各种编程工具的集合，由自由软件基金会负责维护工作</li><li>这些工具形成了一条工具链，用于开发应用程序和操作系统</li><li>同时与集成开发环境相对应</li></ul><p><strong>GNU工具链组成:</strong></p><ul><li>GNU make：用于编译和构建的自动工具</li><li>GNU编译器集合 (GCC) 一组多种编程语言的编译器</li><li>GNU Binutils: 包含链接器、汇编器和其它工具的工具集</li><li>GNU Bison: 编译器编译程序，经常和 Flex词法分析器 配合使用</li><li>GNU m4: m4 宏预处理器</li><li>GNU Debugger (GDB):代码调试工具</li><li>GNU构建系统 (autotools):<blockquote><p>Autoconf<br>Autoheader<br>Automake<br>Libtool</p></blockquote></li><li>GNU C Library: GNU C标准函数库</li><li>GNU Classpath</li></ul><hr><h3 id="交叉工具链"><a href="#交叉工具链" class="headerlink" title="交叉工具链:"></a>交叉工具链:</h3><p><strong>概述:</strong></p><ul><li><p>用于提供编译，链接，处理等功能</p></li><li><p>就是为了编译，链接，处理和调试跨平台体系结构的程序代码</p></li><li><p>每次执行工具链软件时，通过带有不同的参数，可以实现编译，链接，处理或者调试等不同的功能</p></li><li><p>从工具链的组成上来说，它一般由多个程序构成，分别对应着各个功能</p></li><li><p>所谓的交叉工具链是由以下两个概念组合而成的:</p></li></ul><ol><li>交叉编译: 是A机器上编译生成，运行在B机器上<blockquote><p>两个机子有不同的机器指令</p></blockquote></li><li>工具链: 一般由编译器，连接器，解释器和调试器组成</li></ol><hr><h3 id="交叉编译器"><a href="#交叉编译器" class="headerlink" title="交叉编译器:"></a>交叉编译器:</h3><ul><li>是指一个在某个系统平台下可以产生另一个系统平台的可执行文件的编译器</li><li>交叉编译器在目标系统平台(开发出来的应用程序序所运行的平台)难以或不容易编译时非常有用</li><li>交叉编译器的存在对于从一个开发主机为多个平台编译代码是非常有必要的</li><li>直接在平台上编译有时行不通，例如在一个嵌入式系统的单片机 ，因为它们没有操作系统，所以直接编译行不通</li><li>交叉编译器和源代码至源代码编译器不同，交叉编译器用于二进制代码的跨平台软件开发<blockquote><p>而源到源编译器是将某种编程语言的程序源代码作为输入<br>生成以另一种编程语言构成的等效源代码的编译器，但两者都是编程工具</p></blockquote></li><li>交叉编译器的基本用法就是将构建环境与目标环境分开</li><li>常在下面几种情况中使用(具体使用方法这里不做过多赘述):<blockquote><p>嵌入式电脑<br>编译多个目标库<br>引导一个新平台(Bootstrapping)<br>程序虚拟机(比如JVM)</p></blockquote></li></ul><hr><ul><li>工具链用途简述:</li><li>GNU工具链在针对嵌入式系统的Linux内核、BSD及其它软件的开发中起着至关重要的作用</li><li>GNU工具链中的部分工具也被Solaris, Mac OS X, Microsoft Windows (via Cygwin and MinGW/MSYS) and Sony PlayStation 3等其它平台直接使用或进行了移植</li></ul><hr><p><strong>工具链相关概念(关键字):</strong></p><ul><li>工具链</li><li>GNU 工具链</li><li>集成开发环境</li><li>编译器/标准库/链接器/调试器</li><li>交叉编译器</li><li>分布式/并发版本控制系统(CVS,Git等等)</li><li>工具链环境</li></ul><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p><strong>工具链环境:</strong></p><ul><li>所谓的工具链环境就是:<blockquote><p>不光包含于工具链的基本组件<br>还包含于各类辅助指令所对应的工具与程序的本地系统环境</p></blockquote></li></ul><hr><h3 id="GNU工具链组件完全性参考"><a href="#GNU工具链组件完全性参考" class="headerlink" title="GNU工具链组件完全性参考:"></a>GNU工具链组件完全性参考:</h3><p><strong>基本工具:</strong></p><ul><li>GNU make: 用于编译和构建的自动工具</li><li>GNU编译器集(GCC): 一组多种编程语言的编译器</li><li>GNU Binutils: 包含链接器，汇编器和其它工具的工具集</li><li>GNU调试工具(GDB): 代码调试工具</li><li>GNU自动化生成工具(autotools): 自动化检查软件编译过程的工具</li></ul><hr><p><strong>工具链体系:</strong></p><ul><li>此部分用于描述工具链的相关概念与结构，以实现对工具链实施完整的分析</li><li>本文选取LFS的工具链来说明工具链体系内的软件包组成及依赖关系</li><li>为了使以上不同类别的所属工具形成一个互相关联且互相依赖的工具链体系</li><li>必须安装与配置以下软件包工具与相关程序及源码来构成与实现其工具链体系的依赖关系</li></ul><p><strong>所需软件一览:</strong></p><p><strong>Binutils(汇编器):</strong></p><ul><li>包含的程序:<blockquote><p><code>addr2line，ar，as，c++filt，elfedit，gprof，ld，ld.bfd</code>，<br><code>nm，objcopy，objdump，ranlib，readelf，size，strings 和 strip</code></p></blockquote></li><li>包含的库:<blockquote><p><code>libiberty，libbfd</code> 和 <code>libopcodes</code></p></blockquote></li></ul><p><strong>GCC(编译器):</strong></p><ul><li>包含的程序:<blockquote><p><code>c++，cc(到 gcc 的链接)，cpp，g++，gcc</code>，<br><code>gcc-ar，gcc-nm，gcc-ranlib，gccbug</code> 和 <code>gcov</code></p></blockquote></li><li>包含的库:<blockquote><p><code>libgcc，libgcov，libgomp，liblto_plugin，libmudflap</code>，<br><code>libquadmath，libssp，libstdc++，libsupc++</code></p></blockquote></li><li>依赖的包: <code>gmp，mpfr，mpc</code></li></ul><p><strong>Linux API Headers:</strong></p><ul><li>这个是可选包，如果是为了做一个通用工具链，必须将其换成相应平台的头文件包</li><li>包含的头文件:<blockquote><p><code>/usr/include/asm/*.h</code>，<code>/usr/include/asm-generic/*.h</code>，<br><code>/usr/include/drm/*.h</code>，<code>/usr/include/linux/*.h</code>，<code>/usr/include/mtd/*.h</code>，<br><code>/usr/include/rdma/*.h</code>，<code>/usr/include/scsi/*.h</code>，<br><code>/usr/include/sound/*.h</code>，<code>/usr/include/video/*.h</code>，<code>/usr/include/xen/*.h</code></p></blockquote></li></ul><p><strong>Glibc:</strong></p><ul><li>可以根据标准LFS系统的制作方法来安装Glic(可以大幅度简化实现难度)</li><li>包含的程序:<blockquote><p><code>catchsegv，gencat，getconf，getent，iconv，iconvconfig</code>，<br><code>ldconfig，ldd，lddlibc4，locale, localedef，makedb，mtrace，nscd</code>，<br><code>pcprofiledump，pldd，pt_chown，rpcgen, sln, sotruss, sprof, tzselect, xtrace, zdump 和 zic</code></p></blockquote></li><li>包含的库:<blockquote><p><code>ld.so</code>，<code>libBrokenLocale</code>，<code>libSegFault</code>，<code>libanl</code>，<code>libbsd-compat</code>，<code>libc</code>，<code>libcidn</code>，<code>libcrypt</code>，<br><code>libdl</code>，<code>libg</code>，<code>libieee</code>，<code>libm</code>，<code>libmcheck</code>，<code>libmemusage</code>，<code>libnsl</code>，<code>libnss</code>，<code>libpcprofile</code>，<code>libpthread</code>，<br><code>libresolv</code>，<code>librpcsvc</code>，<code>librt</code>，<code>libthread_db</code>，<code>libutil</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-WIKI GNU核心工具组<a href="https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84</code></p></blockquote></li><li><p>CN-WIKI GNU工具链<a href="https://zh.wikipedia.org/wiki/GNU%E5%B7%A5%E5%85%B7%E9%93%BE" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU%E5%B7%A5%E5%85%B7%E9%93%BE</code></p></blockquote></li><li><p>CN-WIKI 交叉工具链<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</code></p></blockquote></li><li><p>百度百科 交叉工具链<a href="https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E5%B7%A5%E5%85%B7%E9%93%BE/2503696" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E5%B7%A5%E5%85%B7%E9%93%BE/2503696</code></p></blockquote></li><li><p>CN-WIKI 交叉编译器<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</code></p></blockquote></li><li><p>Linux From Scratch (简体中文版/版本: 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Chapter (5.x. 构建临时系统) 与 (5.2. 工具链技术说明)<br><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>工具链技术分析与实现(GNU 工具链)<a href="https://www.cnblogs.com/Leo_wl/p/3405580.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/Leo_wl/p/3405580.html</code></p></blockquote></li></ul><hr><h2 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="工具链技术实现"><a href="#工具链技术实现" class="headerlink" title="工具链技术实现"></a>工具链技术实现</h3><ul><li>GNU 工具链</li></ul><h3 id="工具链的使用方式"><a href="#工具链的使用方式" class="headerlink" title="工具链的使用方式"></a>工具链的使用方式</h3><ul><li><p>工具链的目的是提供一个临时可用的编译工作环境，通过chroot来完成在工具环境中进行开发、编译、制作工作</p></li><li><p>为了制作出干净、可移植的工具环境，建议创建一个专用于制作工具链的用户，这也是LFS推荐的</p></li><li><p>在使用工具链之前，此时的本地环境身份应该是root</p></li><li><p>首先挂载虚拟文件系统，然后进入到chroot环境中</p></li></ul><ol><li><strong>挂载虚拟文件系统</strong></li></ol><ul><li><p>可以将以下代码保存为相应的Shell脚本文件，添加执行权限即可使用</p></li><li><p>使用顺序是先挂载虚拟文件系统、后进入chroot环境</p></li><li><p>下方代码只适用于LFS的构建，可根据需求做适当的变量替换，原理和步骤是相同的</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mount -o <span class="built_in">bind</span> /dev <span class="variable">$LFS</span>/dev</span><br><span class="line">mount -t devpts devpts <span class="variable">$LFS</span>/dev/pts -o gid=5,mode=620</span><br><span class="line">mount -t proc proc <span class="variable">$LFS</span>/proc</span><br><span class="line">mount -t sysfs sysfs <span class="variable">$LFS</span>/sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -h <span class="variable">$LFS</span>/dev/shm ]; <span class="keyword">then</span></span><br><span class="line">  link=$(readlink <span class="variable">$LFS</span>/dev/shm)</span><br><span class="line">  mkdir -p <span class="variable">$LFS</span>/<span class="variable">$link</span></span><br><span class="line">  mount -t tmpfs shm <span class="variable">$LFS</span>/<span class="variable">$link</span></span><br><span class="line">  <span class="built_in">unset</span> link</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  mount -t tmpfs shm <span class="variable">$LFS</span>/dev/shm</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>进入到Chroot环境执行以下代码:</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">chroot <span class="string">"<span class="variable">$LFS</span>"</span> /tools/bin/env -i \</span><br><span class="line">    HOME=/root                  \</span><br><span class="line">    TERM=<span class="string">"<span class="variable">$TERM</span>"</span>                \</span><br><span class="line">    PS1=<span class="string">'\u:\w\$ '</span>              \</span><br><span class="line">    PATH=/tools/bin:/tools/sbin:/bin:/usr/bin:/sbin:/usr/sbin \</span><br><span class="line">    /tools/bin/bash --login +h</span><br></pre></td></tr></table></figure><hr><ul><li><p>Linux From Scratch (简体中文版/版本: 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Chapter (5.x. 构建临时系统) 与 (5.2. 工具链技术说明)<br><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>工具链技术分析与实现(GNU 工具链)<a href="https://www.cnblogs.com/Leo_wl/p/3405580.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/Leo_wl/p/3405580.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-7</title>
    <url>/2020/02/27/LFS-7/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="LFS-7"><a href="#LFS-7" class="headerlink" title="LFS-7"></a>LFS-7</h3><ul><li>内核编译等内容</li><li>有关GRUB的内容会再做补充</li></ul><hr><h3 id="相关指令-通用执行逻辑简述"><a href="#相关指令-通用执行逻辑简述" class="headerlink" title="相关指令(通用执行逻辑简述)"></a>相关指令(通用执行逻辑简述)</h3><ul><li>清理编译所处环境的内核依赖树<blockquote><p><code>$makemrpoper</code></p></blockquote></li></ul><hr><ul><li><p>通过菜单驱动的界面配置内核</p></li><li><p>BLFS包含一些有关LFS外部软件包的特定内核配置要求的信息<a href="http://www.linuxfromscratch.org/blfs/view/svn/longindex.html#kernel-config-index" target="_blank" rel="noopener">BLFS-kernel</a></p></li><li><p>基本语法</p><blockquote><p><code>make LANG=&lt;host_LANG_value&gt; LC_ALL= menuconfig</code></p></blockquote></li><li><p>参数含义:</p><blockquote><p>make将语言环境设置建立为主机上使用的语言环境设置(这个参数建立主机上使用的locale设置)<br>UTF-8 的linux文本控制台上的菜单配置ncurses 接口线图需要这个值<br>确保用主机上的<code>$LANG变量代替&lt;host_LANG_value&gt;(还可以说是用主机中变量&lt;host_LANG_value&gt;的值替换$LANG)</code><br>如果主机没有设置，还可以使用<code>$LC_ALL或$LC_CTYPE</code>的值代替</p></blockquote></li><li><p>另外在某一些场合使用<code>$make oldconfig</code>可能更合适</p><blockquote><p>更多信息可参考README文件</p></blockquote></li><li><p>还有一种方法，可以跳过配置内核的步骤</p><blockquote><p>直接把宿主系统里的内核配置文件<code>.config</code>(如果存在的话)复制到解压后的linux-2.6.32.8目录<br>FLS官方说明这里不推荐这么去做<br>考察全部的配置菜单并从头开始创建内核配置是更好的办法</p></blockquote></li></ul><hr><ul><li><p>编译内核映像和所选模块</p><blockquote><p>make</p></blockquote></li><li><p>参数说明</p><blockquote><p>如果使用内核模块，可能需要<code>/etc/modprobe.d</code>目录中的模块配置<br>关于模块和内核配置的信息请参考 Section 7.9内的LFS 系统的设备和模块处理内容和linux-2.6.32.8/Documentation目录的内核文档<br><code>modprobe.conf(5)</code>也可能有用</p></blockquote></li></ul><hr><ul><li><p>如果内核配置使用模块，执行模块安装指令:</p><blockquote><p><code>make modules_install</code></p></blockquote></li><li><p>当内核编译完成后，还需要一些步骤来完成安装</p></li><li><p>比如需要把一些文件拷贝到/boot目录</p></li></ul><hr><ul><li><p>内核镜像文件所在的路径因所处主机使用的平台不同而不同</p></li><li><p>下面的文件名可以更改为符合本地主机的配置</p></li><li><p>但为了与下一节描述的启动过程的自动安装兼容，文件名的词干应该是vmlinux</p></li><li><p>x86平台上运行以下命令:</p><blockquote><p><code>cp -v arch/x86/boot/bzImage /boot/vmlinux-2.6.32.8-lfs-6.6</code></p></blockquote></li><li><p>System.map是内核的符号文件</p></li><li><p>它映射了内核API中每个函数的入口， 以及正在运行内核的数据结构的地址</p></li><li><p>在调查内核问题时，使用它作为一种资源， 运行以下的命令安装此文件:</p><blockquote><p><code>cp -v System.map /boot/System.map-2.6.32.8</code></p></blockquote></li><li><p>上面<code>make menuconfig</code>这一步产生的内核配置文件<code>.config</code>包含了刚刚编译的内核的所有配置选项</p></li><li><p>最好保留这个文件以备将来参考:</p><blockquote><p><code>cp -v .config /boot/config-2.6.32.8</code></p></blockquote></li><li><p>安装Linux内核文档:</p><blockquote><p><code>install -d /usr/share/doc/linux-2.6.32.8</code><br><code>cp -r Documentation/* /usr/share/doc/linux-2.6.32.8</code></p></blockquote></li></ul><hr><p><strong>配置Linux模块装载顺序:</strong></p><ul><li><p>需要创建<code>/etc/modprobe.d/usb.conf</code>文件</p><blockquote><p>以便如果将USB驱动(<code>ehci_hcd， ohci_hcd 和uhci_hcd</code>)编译成模块时，它们会按正确的顺序装载<br>为了避免在启动时出现警告，<code>ehci_hcd</code>必须在<code>ohci_hcd和uhci_hcd</code>之前装载</p></blockquote></li><li><p>通过运行下面的命令来建立一个新文件/etc/modprobe.d/usb.conf:</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">install -v -m755 -d <span class="string">/etc/modprobe.d</span></span><br><span class="line">cat &gt; <span class="string">/etc/modprobe.d/usb.conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="comment"># Begin /etc/modprobe.d/usb.conf</span></span><br><span class="line"></span><br><span class="line">install ohci_hcd <span class="string">/sbin/modprobe</span> ehci_hcd ; <span class="string">/sbin/modprobe</span> -i ohci_hcd ; <span class="literal">true</span></span><br><span class="line">install uhci_hcd <span class="string">/sbin/modprobe</span> ehci_hcd ; <span class="string">/sbin/modprobe</span> -i uhci_hcd ; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># End /etc/modprobe.d/usb.conf</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>注意事项:</strong></p><ul><li><p>重要的一点是要注意到内核源码目录里的文件所有者不是root</p><blockquote><p>只要是用 root(像在chroot环境里做的那样)用户解压软件包，解压出来的文件的用户和组ID是这个软件包打包者计算机上的用户和组ID<br>对于其它软件包， 这通常不是问题， 因为安装完这些软件包之后源码目录就删除了<br>但是 Linux 内核源码树常常会保存很长的时间， 这样就有可能打包者的用户 ID 和您计算机上某个用户的 ID 相同<br>从而让您计算机上的这个用户获得了内核源码的写权限</p></blockquote></li><li><p>如果准备保留内核源代码，在<code>linux-2.6.32.8</code>目录上执行<code>chown -R 0:0</code>命令以确保全部文件的所有者是<code>root</code></p></li><li><p>一些内核文档建议建立一个从<code>/usr/src/linux</code>指向源码目录的符号链接</p><blockquote><p>这只是一个对 2.6 以前版本内核的特殊要求，并且在 LFS 系统上是不允许这样做的<br>因为基本的LFS系统完成以后，安装其他软件包时可能会因此而引起问题</p></blockquote></li><li><p>系统include目录中的头问题件应该总是保持Glibc编译时的那个版本</p><blockquote><p>这也是Linux内核tar包中的干净的头文件<br>因而，它们绝不要被替换成原始的内核头文件和其他干净的头文件</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li><p>LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/view/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/</code></p></blockquote></li><li><p>LFS-v9.3 重新启动系统<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter09/reboot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter09/reboot.html</code></p></blockquote></li><li><p>CSDN参考资料<a href="https://blog.csdn.net/Sugar_girl/article/details/78713316" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/Sugar_girl/article/details/78713316</code></p></blockquote></li><li><p>LFS内核配置全面信息<a href="http://www.linuxfromscratch.org/hints/downloads/files/kernel-configuration.txt" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/hints/downloads/files/kernel-configuration.txt</code></p></blockquote></li><li><p>LFS-v6.3-第八章第三节<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html</code></p></blockquote></li><li><p>Beyond Linux From Scratch (System V Edition) - Version 2020-02-27<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/blfs/view/svn/longindex.html#kernel-config-index</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-6</title>
    <url>/2020/02/26/LFS-6/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="LFS-6"><a href="#LFS-6" class="headerlink" title="LFS-6"></a>LFS-6</h2><hr><h3 id="LFS实现逻辑补充"><a href="#LFS实现逻辑补充" class="headerlink" title="LFS实现逻辑补充"></a>LFS实现逻辑补充</h3><p><strong>LFS的实现大致可分为以下四个阶段:</strong></p><ul><li>一阶段</li></ul><p>1.创建目标系统目录<br>2.创建临时系统目录</p><ul><li>二阶段</li></ul><p>3.建立预工具链</p><ul><li>三阶段</li></ul><p>4.建立临时系统<br>5.建立目标工具链</p><ul><li>四阶段</li></ul><p>6.建立目标系统<br>7.收尾工作</p><hr><h2 id="临时系统"><a href="#临时系统" class="headerlink" title="临时系统"></a>临时系统</h2><ol start="3"><li><strong>建立预工具链</strong></li></ol><ul><li><p>预工具链</p></li><li><p>汇编器Binutils，编译器GCC，标准库Glibc</p></li><li><p>以及主系统(内核头接口/API headers)</p><blockquote><p>API headers/GCC/BIN/GLI</p></blockquote></li><li><p>调整工具链</p><blockquote><p>每次安装完工具链想用工具集时都需要适当的调整工具链并对工具链进行测试</p></blockquote></li><li><p>Glibc编译过程中需要设置内核版本参数(可忽略小版本只写大版本)</p></li><li><p>二次安装工具目录(GCC/Bintils)</p></li><li><p>Tcl-v8.4</p></li><li><p>Expect-v5.4</p></li><li><p>DejaGNU-v1.4</p></li><li><p>GCC-Pass2</p></li><li><p>Binutils-Pass2</p></li><li><p>其它辅助程序(工具)</p></li><li><p>Tcl/Expect/DejaGNU为代码(二进制)编译文件测试工具</p><blockquote><p><code>$make check</code></p></blockquote></li></ul><hr><h3 id="预工具链安装逻辑"><a href="#预工具链安装逻辑" class="headerlink" title="预工具链安装逻辑:"></a>预工具链安装逻辑:</h3><ol><li>Binutils-2.17 - Pass 1</li><li>GCC-4.1.2 - Pass 1</li><li>Linux-2.6.22.5 API Headers</li><li>Glibc-2.5.1</li><li>Adjusting the Toolchain(调整工具链)</li><li>Tcl-8.4.15</li><li>Expect-5.43.0</li><li>DejaGNU-1.4.4</li><li>GCC-4.1.2 - Pass 2</li><li>Binutils-2.17 - Pass 2</li><li>其它辅助工具</li></ol><hr><p><strong>所对应LFS内章节内容:</strong></p><ol start="5"><li>Constructing a Temporary System(建立一个临时系统)</li></ol><ul><li>Introduction (介绍与说明)</li><li>Toolchain Technical Notes (工具链技术说明)</li><li>Binutils-2.17 - Pass 1 (汇编器)</li><li>GCC-4.1.2 - Pass 1 (编译器)</li><li>Linux-2.6.22.5 API Headers (内核接口)</li><li>Glibc-2.5.1 (标准库)</li><li>至</li><li>Util-linux-2.12r (UTIL)</li><li>Stripping (抛离)</li><li>Changing Ownership (改变所有权)</li><li>临时系统建立至此截止</li></ul><hr><h2 id="目标系统"><a href="#目标系统" class="headerlink" title="目标系统"></a>目标系统</h2><p><strong>第一步(进行必要配置):</strong></p><ol><li>建立目标系统的文件目录结构</li><li>创建与配置必要软链接</li><li>创建root及nobody用户和必要的组</li><li>此时可以选择是否重新加载bash</li><li>加载以使root用户起效</li><li>创建和设置几个临时文件和日志文件</li></ol><p><strong>第二步(建立目标工具链):</strong></p><ul><li>包括安装逻辑说明</li><li>Linux-2.6.22.5 API Headers - 1</li><li>Man-pages-2.63 - 2</li><li>Glibc-2.5.1 - 3</li><li>Re-adjusting the Toolchain(工具链调试) - 4</li><li>Binutils-2.17 - 5</li><li>GCC-4.1.2 - 6</li><li>其它辅助工具 (Shell/Bash，M4，Autotools等等) - 7</li><li>至此，一直到所有软件安装完毕后，进行工具链调试(v6.3的FSL中最后一个工具通常是vim)</li><li>之后退出chroot环境，设置启动脚本</li><li>下一步即为第七章-设置系统启动脚本然后进行最终的内核编译(Kernel Compile)</li></ul><hr><h3 id="建立目标工具链以及目标工具链环境"><a href="#建立目标工具链以及目标工具链环境" class="headerlink" title="建立目标工具链以及目标工具链环境:"></a>建立目标工具链以及目标工具链环境:</h3><p><strong>参考章节</strong></p><p><strong>三.建立LFS系统(III.Building the LFS System)</strong></p><ol start="6"><li>Installing Basic System Software (6.安装基本系统软件)</li></ol><ul><li>Introduction (介绍)</li><li>Preparing Virtual Kernel File Systems (准备虚拟内核文件系统)</li><li>Package Management (包装管理)</li><li>Entering the Chroot Environment (进入Chroot环境)</li><li>Creating Directories (创建目录)</li><li>Creating Essential Files and Symlinks (创建基本文件和符号链接)</li><li>Linux-2.6.22.5 API Headers (Linux-2.6.22.5 API标头)</li><li>Man-pages-2.63 (Man-帮助手册)</li><li>Glibc-2.5.1 (标准库)</li><li>Re-adjusting the Toolchain (重新调整工具链)</li><li>Binutils-2.17 (汇编器)</li><li>GCC-4.1.2 (编译器)</li><li>至</li><li>About Debugging Symbols (调试符相关内容)</li><li>Stripping Again (再次抛离)</li><li>Cleaning Up (清理环境)</li><li>目标系统环境已搭建完毕</li></ul><hr><h3 id="系统启动脚本设置与编译-包括编写"><a href="#系统启动脚本设置与编译-包括编写" class="headerlink" title="系统启动脚本设置与编译(包括编写)"></a>系统启动脚本设置与编译(包括编写)</h3><p><strong>参考自LFS英文版第七章内容:</strong><br><strong>7. Setting Up System Bootscripts</strong></p><ul><li>介绍 (Introduction)</li><li>LFS-Bootscripts-6.3 (LFS-boot 脚本)</li><li>至</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li></ul><p><strong>配置逻辑说明:</strong></p><ol><li>编译并安装 LFS-Bootscripts-6.3 (LFS-Bootscripts-6.3)</li><li>配置LFS系统上的设备和模块处理 (Device and Module Handling on an LFS System)</li><li>配置setclock脚本 (Configuring the setclock Script)</li><li>配置Linux控制台 (Configuring the Linux Console)</li><li>配置sysklogd脚本 (Configuring the sysklogd Script)</li><li>创建/etc/inputrc文件 (Creating the /etc/inputrc File)</li><li>Bash Shell启动文件 (The Bash Shell Startup Files)</li><li>配置本地网脚本 (Configuring the localnet Script)</li><li>定制/etc/hosts文件 (Customizing the /etc/hosts File)</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li></ol><ul><li>至此结束系统启动脚本配置，下一步即为内核编译</li></ul><hr><h3 id="配置LFS系统引导项-内核编译"><a href="#配置LFS系统引导项-内核编译" class="headerlink" title="配置LFS系统引导项(内核编译)"></a>配置LFS系统引导项(内核编译)</h3><p><strong>参考自FLS文档第八章</strong><br><strong>8. Making the LFS System Bootable</strong></p><p><strong>配置逻辑介绍(参考内容):</strong></p><ol><li>介绍 (Introduction)</li><li>创建/etc /fstab文件 (Creating the /etc/fstab File)</li><li>Linux-2.6.22.5 (Linux-2.6.22.5编译，配置并安装)</li><li>使LFS系统可启动 (Making the LFS System Bootable)</li></ol><ul><li>相关指令集可参考官方文档</li><li>有关第三项的详细说明与配置参考下一篇文章</li></ul><hr><p><strong>其它内容:</strong></p><ul><li>具体配置内容与描述可参考官方文档(EN/CN)</li><li>这里使用的是LFS官方的LiveCD，官方早已停止维护，所以版本已经很老了</li><li>最新的版本是<code>lfslivecd-x86_64-6.3-r2145.iso</code>(614.510KB)-2007</li><li>这里使用的版本是<code>lfslivecd-x86-6.3-r2145.iso</code>(32位版本/648.638KB)-2007</li><li>在<a href="http://unit-serow.com/2020/02/22/LFS-1/#more" target="_blank" rel="noopener">LFS-1</a>这篇文章内有有关LFS所有资料的链接<blockquote><p><code>http://unit-serow.com/2020/02/22/LFS-1/#more</code></p></blockquote></li></ul><hr><ul><li>对于目标系统中的任何工具的编译完成之后，最好进行编译文件(二进制文件)测试是否正确且可用</li><li>即便有错误，只要不是太多或可以通过下一步的应用测试，就可以先无视掉</li><li>等到目标系统内核建立并编译完成之后再对目标Debug进行修补与维护</li><li>测试指令(测试动态链接库): <code>$make check</code></li><li>测试时间长短由工具决定</li><li>有些二进制包在测试时可能会发生几处无关紧要的错误，但不会影响安装和正常使用<blockquote><p>比如类似于找不到man的动态链接库之类的错误</p></blockquote></li><li>有时测试不能顺利结束，可以根据报错来判断问题所在<blockquote><p>多半是文件依赖，动态库，文件映射或配置文件缺失等问题</p></blockquote></li></ul><hr><h3 id="需调整工具链"><a href="#需调整工具链" class="headerlink" title="需调整工具链:"></a>需调整工具链:</h3><ul><li><p>工具链一(预/临时工具链):</p><blockquote><p>预工具链与临时工具链(GCC/Glibc/Binutils/Linux Kernel API Headers)<br>调整specs文件<br>调试与测试所属工具链环境</p></blockquote></li><li><p>工具链二(目标工具链):</p><blockquote><p>目标工具链(GCC/Glibc/Linux Kernel API Headers/Binutils/Man-pages)<br>调整specs文件<br>调试与测试所属工具链环境</p></blockquote></li><li><p>最后执行Strip命令并进入新的chroot环境</p></li><li><p>即为拥有两次抛离过程</p><blockquote><p>第一次是主系统-临时系统<br>第二次是临时系统-目标系统<br>最后保证目标系统可以独立运行并将其独立(完全抛离原系统)</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>具体的配置代码与安装代码可参考LFS官方中/英文书籍</li><li>CN-参考资料FSL为6.3版本<a href="http://www.linuxfromscratch.org/lfs/view/6.3/index.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/index.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-5</title>
    <url>/2020/02/26/LFS-5/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="LFS-5"><a href="#LFS-5" class="headerlink" title="LFS-5"></a>LFS-5</h2><ul><li>应用笔记以及经验总结</li></ul><hr><h3 id="首要逻辑说明"><a href="#首要逻辑说明" class="headerlink" title="首要逻辑说明:"></a>首要逻辑说明:</h3><ul><li>编译工具就是汇编工具与语言编译器(Binutils/GCC)</li><li>汇编工具，语言编译器，对应语言标准库被合称为工具链(Binutils/GCC/Glibc)<blockquote><p>工具链的配置即为以上三个工具的配置<br>因为让编译工具生成可执行文件需要对应标准库，所以这里将标准库算到工具链内(严格来说标准库并不是工具)</p></blockquote></li><li>辅助命令</li><li>文件(目录)映射</li></ul><hr><ol><li>创建目标系统目录</li><li>创建临时系统目录</li><li>建立预工具链</li><li>建立临时系统</li><li>建立目标工具链</li><li>建立目标系统</li><li>收尾工作</li></ol><hr><p><strong>作用解释:</strong></p><ul><li><code>CC=&quot;gcc -B/usr/bin&quot;</code></li><li>在第一遍编译GCC中是调用/tools内的gcc<blockquote><p>调用GCC作为编译器，指定GCC运行环境为/usr/bin</p></blockquote></li><li>在第一遍编译Binutils时是调用/tools内的GCC，接下来指定链接器指向</li><li>在第二遍编译Binutils中是在调用host中的GCC</li></ul><hr><p><strong>注意事项(相关内容):</strong></p><ul><li>设置工具链的时候必须保证工具处于可用状态</li><li>有些程序和工具可能需要编译及安装两遍以上</li><li>在目标机器内Glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误<blockquote><p>还有一些能引起错误的LFS手册上有所提及<br>类似于超时这种 错误有时候很难避免<br>只能跳过去或进行多次编译以及安装</p></blockquote></li><li>跳过对于目标机器内Glibc及其工具链的测试</li><li>有一两个Error就忽略吧</li><li>测试代码并统计<blockquote><p><code>$make check</code><br>测试统计有可能会出现个别失败<br>有时会完全成功</p></blockquote></li><li>参考资料均来自十年前(最少)</li><li>参考资料本身没什么太大问题</li></ul><hr><h3 id="问题一览"><a href="#问题一览" class="headerlink" title="问题一览"></a>问题一览</h3><ul><li>待解决问题<blockquote><p>v6.2 无内核头部配置文件<br>v6.3 第二次编译C函数库(Glibc)时出错<br>v6.3 目标工具链-Binutils编译出现错误，没有通过测试，并且已无视<br>v6.3 目标工具链-GCC编译出现几处错误，但不影响使用并已成功通过安装测试与应用测试<br>v6.3 测试Automake-1.10工具源代码编译文件时出现三个错误，但无伤大雅<br>v6.3 Linux内核编译出现问题(kernel version:2.6.22.5)<br>v6.3 找不到GCC</p></blockquote></li></ul><hr><ul><li>目标机器内的Glibc标准函数库测试错误问题已解决</li><li>目标机器内的GCC编译器问题已解决</li><li>目标工具链内的GCC安装与应用测试成功</li><li>编译Coreutils-6.9出现两处Error<blockquote><p>动态链接库测试中编译帮助文件<code>man目录</code>失效<br><code>BEGIN failed--compilation aborted at ./help2man line 28</code><br>离开<code>*/man</code>目录<br>已经无视，并且进行代码测试后也是这个问题</p></blockquote></li><li>Procps-3.2.7(Top)<blockquote><p><code>collect2: ld returned 1 exit status</code><br>make停止<br>安装失败</p></blockquote></li><li>Perl-5.8.8<blockquote><p>动态链接库测试中编译出现两条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Readline-5.2<blockquote><p>动态链接库测试中编译出现一条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Automake-1.10<blockquote><p>动态链接库测试中编译出现三条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Psmisc-22.5<blockquote><p>cannot find tinfo，ncurses or termcap libraries<br>无法找到无法找到tinfo、ncurses或termcap库<br>编译失败</p></blockquote></li><li>Udev-113<blockquote><p>make test测试与安装无错误</p></blockquote></li><li>到达第七章与第八章之间的退出chroot出现问题<blockquote><p>根据LFS官方手册配置，进入新的系统环境下GCC丢失<br>未解决</p></blockquote></li></ul><hr><p><strong>错误补充</strong></p><ul><li>Coreutils-6.9动态库链接的测试编译有一处错误，原因关于man</li><li>perl-5.8.8的test测试出现未知错误两处(测试静态库)</li><li>automake-1.10<blockquote><p>动态库链接测试编译出现三处错误<br>[check-TESTS] ERROR 1<br>[check-am] Error 2<br>[check-recursive] Error 3<br>但能顺利结束并编译安装</p></blockquote></li><li>Findutils-4.2.31<blockquote><p>编译测试出现三次错误<br>check-DEJAGNU Error 1<br>check-am Error 2<br>[check-recursive] Error 3</p></blockquote></li><li>IPRoute2-2.6.20-070313<blockquote><p>编译错误<br>[arpd] Error1<br>[all] Error 2</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>开源中国<a href="https://www.oschina.net/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.oschina.net/</code></p></blockquote></li></ul><hr><ul><li>LFS注册<a href="http://www.linuxfromscratch.org/cgi-bin/lfscounter.php" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/cgi-bin/lfscounter.php</code></p></blockquote></li></ul><hr><ul><li>LFS-6.3版本<a href="http://www.linuxfromscratch.org/lfs/view/6.3/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/</code></p></blockquote></li></ul><hr><ul><li>LFS-6.3内核编译(kernel version:2.6.22.5)<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html</code></p></blockquote></li></ul><hr><ul><li>冲天飞豹Blog(已经挂了)<blockquote><p><code>http://youbest.cublog.cn/</code></p></blockquote></li></ul><hr><ul><li>LFS-PDF<a href="https://pan.baidu.com/s/1nZARmQlO63fh5BVGug4gPg" target="_blank" rel="noopener">跳转</a><blockquote><p>链接:<code>https://pan.baidu.com/s/1nZARmQlO63fh5BVGug4gPg</code><br>提取码:414z</p></blockquote></li></ul><hr><h3 id="重要工具与程序简述-小部分-最新版本"><a href="#重要工具与程序简述-小部分-最新版本" class="headerlink" title="重要工具与程序简述(小部分/最新版本):"></a>重要工具与程序简述(小部分/最新版本):</h3><ul><li><p><code>Glibc (2.30) - 16,189 KB:</code></p><blockquote><p>主页: <code>http://www.gnu.org/software/libc/</code><br>下载: <code>http://ftp.gnu.org/gnu/glibc/glibc-2.30.tar.xz</code><br>MD5 校验和: <code>2b1dbdf27b28620752956c061d62f60c</code></p></blockquote></li><li><p><code>GCC (9.2.0) - 68,953 KB:</code></p><blockquote><p>主页: <code>https://gcc.gnu.org/</code><br>下载: <code>http://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.xz</code><br>MD5 校验和: <code>3818ad8600447f05349098232c2ddc78</code></p></blockquote></li><li><p><code>Linux (5.2.8) - 104,555 KB:</code></p><blockquote><p>主页: <code>https://www.kernel.org/</code><br>下载: <code>https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.2.8.tar.xz</code><br>MD5 校验和: <code>602dd0ecb8646e539fefb2beb6eb6fe0</code></p></blockquote></li><li><p><code>Binutils (2.32) - 20,288 KB:</code></p><blockquote><p>主页: <code>http://www.gnu.org/software/binutils/</code><br>下载: <code>http://ftp.gnu.org/gnu/binutils/binutils-2.32.tar.xz</code><br>MD5 校验和: <code>0d174cdaf85721c5723bf52355be41e6</code></p></blockquote></li><li><p><code>GRUB (2.04) - 6,245 KB:</code></p><blockquote><p>主页: <code>http://www.gnu.org/software/grub/</code><br>下载: <code>https://ftp.gnu.org/gnu/grub/grub-2.04.tar.xz</code><br>MD5 校验和: <code>5aaca6713b47ca2456d8324a58755ac7</code></p></blockquote></li><li><p><code>LFS-Bootscripts (20190524) - 32 KB:</code></p><blockquote><p>下载: <code>http://www.linuxfromscratch.org/lfs/downloads/9.0/lfs-bootscripts-20190524.tar.xz</code><br>MD5 校验和: <code>c91b11e366649c9cec60c2552820fed5</code></p></blockquote></li></ul><hr><ul><li><p><code>Autoconf (2.69) - 1,186 KB:</code></p><blockquote><p>主页：<code>http://www.gnu.org/software/autoconf/</code><br>下载：<code>http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.xz</code><br>MD5 校验和：<code>50f97f4159805e374639a73e2636f22e</code></p></blockquote></li><li><p><code>Automake (1.16.1) - 1,499 KB:</code></p><blockquote><p>主页：<code>http://www.gnu.org/software/automake/</code><br>下载：<code>http://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.xz</code><br>MD5 校验和：<code>53f38e7591fa57c3d2cee682be668e5b</code></p></blockquote></li><li><p><code>Bash (5.0) - 9,898 KB:</code></p><blockquote><p>主页：<code>http://www.gnu.org/software/bash/</code><br>下载：<code>http://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz</code><br>MD5 校验和：<code>2b44b47b905be16f45709648f671820b</code></p></blockquote></li><li><p><code>File (5.37) - 867 KB:</code></p><blockquote><p>主页：<code>https://www.darwinsys.com/file/</code><br>下载: <code>ftp://ftp.astron.com/pub/file/file-5.37.tar.gz</code><br>MD5 校验和： <code>80c29aca745466c6c24d11f059329075</code></p></blockquote></li><li><p><code>Libtool (2.4.6) - 951 KB:</code></p><blockquote><p>主页：<code>http://www.gnu.org/software/libtool/</code><br>下载：<code>http://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.xz</code><br>MD5 校验和：<code>1bfb9b923f2c1339b4d2ce1807064aa5</code></p></blockquote></li><li><p><code>M4 (1.4.18) - 1,180 KB:</code></p><blockquote><p>主页：<code>http://www.gnu.org/software/m4/</code><br>下载：<code>http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.xz</code><br>MD5 校验和：<code>730bb15d96fffe47e148d1e09235af82</code></p></blockquote></li><li><p><code>Make (4.2.1) - 1,932 KB:</code></p><blockquote><p>主页：<code>http://www.gnu.org/software/make/</code><br>下载：<code>http://ftp.gnu.org/gnu/make/make-4.2.1.tar.gz</code><br>MD5 校验和：<code>7d0dcb6c474b258aab4d54098f2cf5a7</code></p></blockquote></li><li><p><code>OpenSSL (1.1.1c) - 8,657 KB:</code></p><blockquote><p>主页：<code>https://www.openssl.org/</code><br>下载：<code>https://www.openssl.org/source/openssl-1.1.1c.tar.gz</code><br>MD5 校验和：<code>15e21da6efe8aa0e0768ffd8cd37a5f6</code></p></blockquote></li></ul><hr><ul><li><p><code>Gawk (5.0.1) - 3,063 KB:</code></p><blockquote><p>主页：<code>http://www.gnu.org/software/gawk/</code><br>下载：<code>http://ftp.gnu.org/gnu/gawk/gawk-5.0.1.tar.xz</code><br>MD5 校验和：<code>f9db3f6715207c6f13719713abc9c707</code></p></blockquote></li><li><p><code>Util-linux (2.34) - 4,859 KB:</code></p><blockquote><p>主页：<code>http://freecode.com/projects/util-linux</code><br>下载：<code>https://www.kernel.org/pub/linux/utils/util-linux/v2.34/util-linux-2.34.tar.xz</code><br>MD5 校验和：<code>a78cbeaed9c39094b96a48ba8f891d50</code></p></blockquote></li><li><p><code>Zlib (1.2.11) - 457 KB:</code></p><blockquote><p>主页：<code>https://www.zlib.net/</code><br>下载：<code>https://zlib.net/zlib-1.2.11.tar.xz</code><br>MD5 校验和：<code>85adef240c5f370b308da8c938951a68</code></p></blockquote></li></ul><hr><p><strong>补丁:</strong></p><ul><li><p><code>Coreutils 国际化修复补丁 - 168 KB:</code></p><blockquote><p>下载：<code>http://www.linuxfromscratch.org/patches/lfs/9.0/coreutils-8.31-i18n-1.patch</code><br>MD5 校验和：<code>a9404fb575dfd5514f3c8f4120f9ca7d</code></p></blockquote></li><li><p><code>Glibc FHS 补丁 - 2.8 KB:</code></p><blockquote><p>下载：<code>http://www.linuxfromscratch.org/patches/lfs/9.0/glibc-2.30-fhs-1.patch</code><br>MD5 校验和：<code>9a5997c3452909b1769918c759eff8a2</code></p></blockquote></li></ul><hr><h3 id="已解决问题一览"><a href="#已解决问题一览" class="headerlink" title="已解决问题一览"></a>已解决问题一览</h3><ul><li>如果实在找不到GCC且有难以解决的问题，可以先利用已有的临时主机中的/tools目录来对目标主机进行错误与空白修补</li><li>各参数作用这里不做过多赘述，可参考LFS官方手册</li></ul><hr><ul><li>参考自LFS-v6.3版本第6.4-Entering the Chroot Environment至6.59-Stripping Again章节</li><li>第七章末尾找不到GCC的问题已解决<blockquote><p>需要先完全配置才能去抛离上一级系统目录环境(此时需要脱离的是临时系统)<br>在第六章开头理解出问题了<br>在查询了FSL官方的英文文档之后<br>发现退出chroot的代码只需要执行一遍<br>chroot及附带配置的作用是抛离前(是属于目标系统的)的配置<br>使用Strip对文件(二进制压缩包)进行清理</p></blockquote></li></ul><p><strong>可参考以下指令:</strong></p><ol><li><p>退出chroot环境:</p><blockquote><p><code>$logout</code></p></blockquote></li><li><p>为Strip而进入chroot环境:</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">chroot <span class="variable">$LFS</span> /tools/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM=$TERM PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span> \</span><br><span class="line">    /tools/bin/bash --login</span><br></pre></td></tr></table></figure></li><li><p>Strip:</p><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">/tools/bin/find /&#123;,usr/&#125;&#123;bin,<span class="class"><span class="keyword">lib</span>,<span class="title">sbin</span>&#125; -<span class="title">type</span> <span class="title">f</span> \</span></span><br><span class="line">  -exec /tools/bin/strip --strip-debug <span class="string">'&#123;&#125;'</span> <span class="string">';'</span></span><br></pre></td></tr></table></figure></li></ol><hr><ul><li>摘选自LFS-v6.3/EN-CN(翻译)<blockquote><p>A large number of files will be reported as having their file format not recognized.<br>These warnings can be safely ignored.<br>These warnings indicate that those files are scripts instead of binaries.</p></blockquote></li><li>翻译内容:<blockquote><p>大量文件将被报告为文件格式无法识别<br>可以安全地忽略这些警告<br>这些警告表明这些文件是脚本而不是二进制文件</p></blockquote></li></ul><hr><p><strong>补充内容:</strong></p><ul><li><p>摘选自FSL官方文档:</p><blockquote><p>From now on, when reentering the chroot environment after exiting, use the following modified chroot command:</p></blockquote><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">chroot <span class="string">"$LFS"</span> /usr/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM="$TERM" PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span> \</span><br><span class="line">    /bin/bash --login</span><br></pre></td></tr></table></figure><blockquote><p>The reason for this is that the programs in /tools are no longer needed. Since they are no longer needed you can delete the /tools directory if so desired.</p></blockquote></li><li><p>翻译内容:</p><blockquote><p>从现在开始，退出后重新进入chroot环境时，请使用以下修改后的chroot命令：<br>这样做的原因是/tools不再需要其中的程序<br>因为不再需要它们，所以可以根据需要来决定是否去删除/tools目录</p></blockquote></li></ul><hr><p><strong>补充内容:</strong></p><ul><li>6.4章节中描述的带有临时机器中的/tools文件夹的目标机器<blockquote><p>It is time to enter the chroot environment to begin building and installing the final LFS system. As user root, run the following command to enter the realm that is, at the moment, populated with only the temporary tools:</p></blockquote></li><li>翻译内容:<blockquote><p>现在是时候进入chroot环境开始构建和安装最终的LFS系统了<br>以user root身份，运行以下命令以输入当前仅由临时工具填充的领域:</p></blockquote><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line">chroot <span class="string">"$LFS"</span> /tools/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM="$TERM" PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/tools/bin</span> \</span><br><span class="line">    /tools/bin/bash --login +h</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>重点内容-1</strong></p><ul><li>6.2.章节 准备虚拟内核文件系统</li><li>6.22章节 挂载和激活/dev</li></ul><hr><p><strong>解决思路:</strong></p><ul><li>把/tools的内容转到<code>/usr</code>内<blockquote><p>为什么<code>cc/gcc</code>工具会不生效<br><code>GCC/Binutils/Glibc/Linux-2.6.22.5</code>已成功编译并安装入目标主机的<code>/usr</code>或<code>/usr/bin</code>文件目录内<br>每次的重新开始都是对经验的不断累积</p></blockquote></li><li>孙海勇在LinuxSir上的LFS教程-26-27页与29页</li><li><code>LFS 7.4 chapter 6.7: make: gcc: Command not found</code><a href="https://unix.stackexchange.com/questions/110184/lfs-7-4-chapter-6-7-make-gcc-command-not-found" target="_blank" rel="noopener">跳转</a><blockquote><p>LFS 7.4-第6.7章:make: gcc: 找不到命令<br><code>https://unix.stackexchange.com/questions/110184/lfs-7-4-chapter-6-7-make-gcc-command-not-found</code></p></blockquote></li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>6.4 Entering the Chroot Environment<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/chroot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/chroot.html</code></p></blockquote></li><li><p>6.59. Stripping Again<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/strippingagain.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/strippingagain.html</code></p></blockquote></li><li><p>6.60. Cleaning Up<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/revisedchroot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/revisedchroot.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Privacy Guard/GPG-1</title>
    <url>/2020/02/24/GPG-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="GNU-Privacy-Guard-GPG-1"><a href="#GNU-Privacy-Guard-GPG-1" class="headerlink" title="GNU Privacy Guard/GPG-1"></a>GNU Privacy Guard/GPG-1</h2><h3 id="简要概述与参考资料整理"><a href="#简要概述与参考资料整理" class="headerlink" title="简要概述与参考资料整理"></a>简要概述与参考资料整理</h3><ul><li><p>数据完整性(Data integrity)</p></li><li><p>使用工具:</p></li><li><p>GPG(GNU Privacy Guard)</p><blockquote><p>Linux GPG<br>GNU PG</p></blockquote></li></ul><hr><h3 id="命令简述"><a href="#命令简述" class="headerlink" title="命令简述:"></a>命令简述:</h3><ul><li><p>生成密钥</p><blockquote><p><code>$gpg --gen-key</code><br>安装提示对密钥进行配置</p></blockquote></li><li><p>列出密钥</p><blockquote><p><code>$gpg --list-keys</code></p></blockquote></li><li><p>删除密钥</p><blockquote><p><code>gpg --delete-key [用户ID]</code></p></blockquote></li><li><p>输入密钥</p><blockquote><p><code>gpg --import [密钥文件]</code></p></blockquote></li><li><p>加密文件</p><blockquote><p><code>gpg --recipient [用户ID] --output [file name] --encrypt [file name]</code></p></blockquote></li><li><p>解密并输出内容</p><blockquote><p><code>gpg [file name]</code></p></blockquote></li><li><p>文件签名(二进制存储)</p><blockquote><p><code>gpg --sign [file name]</code></p></blockquote></li><li><p>文件签名(ASCII码存储)</p><blockquote><p><code>gpg --clearsign [file name]</code></p></blockquote></li><li><p>生成单独的签名文件(二进制存储)</p><blockquote><p><code>gpg --detach-sign [file name]</code></p></blockquote></li><li><p>生成单独的签名文件(ASCII码存储)</p><blockquote><p><code>gpg --armor --detach-sign [file name]</code></p></blockquote></li><li><p>验证签名</p><blockquote><p><code>gpg --verify [file name].[asc] [file name]</code></p></blockquote></li><li><p>等等</p></li></ul><hr><p><strong>其它说明:</strong></p><ul><li>方括号为可选参数</li><li>这里的数据完整性以数据签名实现</li><li>压缩所选文件或目录并进行哈希加密实现数字签名</li><li>不进行压缩进行数字加密</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>GPG</li><li>PGP</li><li>GPG2</li><li>RSA加密算法(对称加密算法)</li><li>数据校检</li><li>数字签名</li><li>数据完整性</li><li>软件包签名</li><li>压缩文件签名</li><li>数据库数据完整性</li><li>文件目录数据完整性</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><strong>以下内容参考自中文维基与百度百科:</strong></p><p><strong>中文维基</strong></p><ul><li><p>数据完整性<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7</code></p></blockquote></li><li><p>数字签名<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0</code></p></blockquote></li></ul><p><strong>百度百科</strong></p><ul><li><p>数据完整性<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7</code></p></blockquote></li><li><p>数据校检<a href="https://baike.so.com/doc/741565-784957.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.so.com/doc/741565-784957.html</code></p></blockquote></li></ul><hr><p><strong>参考文献:</strong></p><ul><li><p>Linux下使用GPG加密解密的说明及示例<a href="https://www.linuxidc.com/Linux/2015-02/113015.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2015-02/113015.htm</code></p></blockquote></li><li><p>如何在Linux下使用GPG(GnuPG)加密及解密<a href="https://jingyan.baidu.com/album/3d69c5513244a7f0ce02d751.html?picindex=1" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://jingyan.baidu.com/album/3d69c5513244a7f0ce02d751.html?picindex=1</code></p></blockquote></li><li><p>GPG简要介绍<a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ruanyifeng.com/blog/2013/07/gpg.html</code></p></blockquote></li><li><p>Gnu隐私卫士(GnuPG)袖珍HOWTO(中文版)<a href="https://www.gnupg.org/howtos/zh/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnupg.org/howtos/zh/index.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Password</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Containers/LXC-1</title>
    <url>/2020/02/24/LXC-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Linux-Containers-LXC-1"><a href="#Linux-Containers-LXC-1" class="headerlink" title="Linux Containers/LXC-1"></a>Linux Containers/LXC-1</h2><p><strong>相关内容:</strong></p><ul><li>LXC(Linux Containers)</li><li>linux内核映射文件</li><li>文件映射</li></ul><hr><h3 id="LXC-Linux-Containers"><a href="#LXC-Linux-Containers" class="headerlink" title="LXC(Linux Containers)"></a>LXC(Linux Containers)</h3><p><strong>概述:</strong></p><ul><li>其名称来自Linux软件容器(Linux Containers)的缩写</li><li>是一种操作系统层虚拟化（Operating system–level virtualization)技术</li><li>作用是为Linux内核容器功能的一个用户空间接口</li></ul><hr><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><ol><li><strong>实现方法:</strong></li></ol><ul><li>在Linux内核中，提供了cgroups功能，来达成资源的区隔化<blockquote><p>它同时也提供了名称空间区隔化的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括行程树，网络，用户id，以及挂载的文件系统<br>但是cgroups并不一定需要引导任何虚拟机<br>LXC利用cgroups与名称空间的功能，提供应用软件一个独立的操作系统环境<br>LXC不需要Hypervisor这个软件层，软件容器(Container)本身极为轻量化，提升了创建虚拟机的速度<br>软件Docker被用来管理LXC的环境</p></blockquote></li></ul><hr><ul><li>执行流程简述:<blockquote><p>它将应用软件系统打包成一个软件容器(Container)，内含应用软件本身的代码，以及所需要的操作系统核心和库<br>透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境<br>从而使得Linux用户可以容易的创建和管理系统或应用容器</p></blockquote></li></ul><hr><ol start="2"><li><strong>具体实现:</strong></li></ol><ul><li><p>当前的LXC使用下列内核功能来控制进程:</p><blockquote><p>内核名字空间(进程间通信，uts，mount，pid，network和user)<br>AppArmor和SELinux配置<br>Seccomp策略<br>chroot(使用<code>pivot_root</code>)<br>Kernel Capibilities<br>控制组(cgroups)</p></blockquote></li><li><p>因此，LXC通常被认为介于“加强版”的chroot和完全成熟的虚拟机之间的技术。LXC的目标是创建一个尽可能与标准安装的Linux相同但又不需要分离内核的环境</p></li></ul><hr><ol start="3"><li><strong>具体使用:</strong></li></ol><ul><li>Proxmox VE:它直到4.0版才使用LXC技术，在此之前的版本都是使用OpenVZ技术</li><li>Docker:它在0.9版之前都是使用LXC技术，但在0.9版之后，已不再是唯一且默认的运行环境</li></ul><hr><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p><strong>概述:</strong></p><ul><li>内存映射文件(Memory-mapped file)，或称”文件映射”与”映射文件”</li><li>是一段虚内存逐字节对应于一个文件或类文件的资源，使得应用程序处理映射部分如同访问主内存</li></ul><hr><p><strong>内存映射文件分为以下两种:</strong></p><ul><li>Persisted<blockquote><p>Persisted文件与硬盘文件相关联，当关闭内存映射时，数据被写入对应的硬盘文件中<br>适合于很大的文件</p></blockquote></li><li>Non-persisted<blockquote><p>Non-persisted文件并不关联于硬盘文件。当关闭内存映射文件，所有数据被抛弃<br>适用于创建进程间通信的共享内存</p></blockquote></li></ul><p><strong>作用:</strong></p><ol><li>最常见用途是绝大多数操作系统(包括Microsoft Windows与Unix-like系统)用于加载进程</li><li>另一个用途是多个进程的共享内存</li><li>第三个用途是对大文件的读写</li></ol><p><strong>优势:</strong></p><ol><li>主要用处是增加I/O性能，特别是用于大文件</li><li>对于小文件，内存映射文件会导致碎片空间浪费，因为内存映射总是要对齐页边界，这起码是4 KiB<blockquote><p>因而一个5 KiB文件将会映射占用8 KiB内存，浪费了3 KiB内存</p></blockquote></li><li>访问内存映射文件比直接文件读写要快几个数量级</li></ol><p><strong>缺点(弊端):</strong></p><ol><li>内存映射文件需要在进程的占用一块很大的连续逻辑地址空间</li><li>对于Intel的IA-32的4 GiB逻辑地址空间，可用的连续地址空间远远小于<code>2---3GiB</code><blockquote><p>相关联的文件的I/O错误(如可拔出驱动器或光驱被弹出，磁盘满时写操作等)的内存映射文件会向应用程序报告SIGSEGV/SIGBUS信号(POSIX环境)<br>或<code>EXECUTE_IN_PAGE_ERROR</code>结构化异常(Windows环境)<br>但通常的内存操作是无需考虑这些异常的</p></blockquote></li><li>有内存管理单元(MMU)才支持内存映射文件</li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>官方网站<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linuxcontainers.org/</code></p></blockquote></li><li><p>LXC官方文档<a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linuxcontainers.org/lxc/introduction/</code></p></blockquote></li></ul><hr><p><strong>以下内容参考自中文维基:</strong></p><ul><li><p>虚拟内存<a href="https://zh.wikipedia.org/wiki/Category:%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98</code></p></blockquote></li><li><p>磁盘文件系统<a href="https://zh.wikipedia.org/wiki/Category:%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F</code></p></blockquote></li><li><p>Linux容器化<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%AE%B9%E5%99%A8%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%AE%B9%E5%99%A8%E5%8C%96</code></p></blockquote></li><li><p>Linux内核功能<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD</code></p></blockquote></li><li><p>操作系统层虚拟化<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>DevOps<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/DevOps</code></p></blockquote></li><li><p>虚拟化技术(Virtualization)<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian-3</title>
    <url>/2020/02/23/Debian-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Debian-GNU-Linux-3"><a href="#Debian-GNU-Linux-3" class="headerlink" title="Debian GNU/Linux-3"></a>Debian GNU/Linux-3</h2><h3 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h3><hr><ul><li>本篇文章会不断进行补充</li></ul><p><strong>常见的分区有以下三个:</strong></p><ul><li>fdisk</li><li>cfdisk</li><li>partman</li></ul><hr><p><strong>cfdisk用法</strong></p><ul><li>简易分区管理工具</li><li>这里的磁盘类型是<code>SCSI</code>，<code>IDE</code>则为<code>hda</code>，<code>SATA</code>与<code>NVMe</code>这里不进行过多赘述</li><li>具体可以查看<code>man手册</code>与<code>help帮助</code>指令</li><li>基本流程:<code>创建分区-&gt;配置文件系统根目录与其它选项(作用/用途)-&gt;格式化文件系统-&gt;文件系统挂载并使用</code></li></ul><p><strong>创建分区:</strong></p><ol><li>键入指令<code>$cfdisk /dev/sda</code></li><li>选择任意分区(最好是空白分区，已有分区需要先进行删除)</li><li><code>选择[new选项]-&gt;[primary选项]-&gt;[指定容量数值(以字节为单位)]</code></li><li><code>选择[write选择]-&gt;键入[yes保存修改]-&gt;选择[quit选项退出工具]</code></li></ol><ul><li>参数说明:</li><li>primary 主分区</li><li>extended 扩展分区</li></ul><hr><p><strong>交换分区操作:</strong></p><ul><li><p>格式化交换分区指令(这里将sda1格式化为交换分区)</p><blockquote><p><code>$mkswap /dev/sda1</code></p></blockquote></li><li><p>使用交换分区</p><blockquote><p><code>$swapon [交换分区设备名/交换文件]</code><br><code>$swapon /dev/sda</code></p></blockquote></li><li><p>查看内存信息来检查是否已启用交换分区</p><blockquote><p><code>$free</code></p></blockquote></li><li><p>取消交换分区</p><blockquote><p><code>$swapoff /dev/sda1</code></p></blockquote></li></ul><hr><p><strong>其它概念(交换分区):</strong></p><p><strong>swap</strong></p><ul><li>swap的部分内容就是开启了多少交换空间，其空间大小是开启使用的交换分区或者文件大小的总和</li><li>交换分区可以同时存在多个并可以同时使用</li><li>同时也可以使用文件格式的交换空间</li></ul><p><strong>交换空间</strong></p><ul><li>一般主机系统里会有两个磁盘分区</li><li>一个是交换空间，另一个则是其它的任何分区</li><li>第一个分区计划为用于交换空间</li><li>交换空间又可被称为交换内存空间</li><li>使用这种文件系统的分区被称为交换分区，用于进行系统过程中的内存交换</li></ul><hr><p><strong>格式化分区操作:</strong></p><ul><li>将磁盘分区格式化为指定的文件系统</li><li>有以下几种语法格式:<blockquote><p><code>mkfs.ext2/ext3/ext4/xfs等等 /dev/sdaxxx/(指定磁盘)</code><br><code>mkfs.文件系统 [分区或设备名]</code><br><code>mkfs [options] [指定磁盘文件格式] /dev/sdaxxx/(指定磁盘)</code><br>参数<code>-v</code>，<code>-t</code>等等<br>例如:<code>mkfs -t ext4 /dev/sda3</code></p></blockquote></li></ul><hr><p><strong>磁盘(光盘或设备)挂载:</strong></p><ul><li><p>基本语法格式:</p><blockquote><p><code>mount -o loop [/dev/sdaxxx(指定磁盘)] [/mnt(被挂载目录)]</code><br><code>mount -t ext4(指定磁盘文件系统) /dev/sda4 /mnt</code></p></blockquote></li><li><p>卸载光盘</p><blockquote><p><code>umount /mnt</code><br><code>umount /dev/sda2</code></p></blockquote></li><li><p>mount查看磁盘文件系统挂载情况</p><blockquote><p>参数<code>-h</code>返回容量单位</p></blockquote></li><li><p>mount输出参数说明:</p><blockquote><p>ro表示只读<br>rw为可读可写</p></blockquote></li></ul><hr><p><strong>查看磁盘文件系统挂载情况:</strong></p><blockquote><p><code>$df</code></p></blockquote><hr><p><strong>磁盘文件系统修复:</strong></p><ul><li><p>fsck</p><blockquote><p>fsck(file system consistency check)</p></blockquote></li><li><p>是Unix和类Unix系统上用于检查文件系统完整性的工具</p></li><li><p>基本命令格式:</p><blockquote><p><code>fsck -y /dev/sda1(指定磁盘)</code></p></blockquote></li><li><p>fuser</p><blockquote><p><code>fuser -m /boot</code> 输出选项模块对应线程的pid<br><code>fuser -mk /boot</code> kill掉所选进程的pid</p></blockquote></li></ul><hr><p><strong>其它概念:</strong></p><ul><li>hda一般是指IDE接口的硬盘，hda一般指第一块硬盘，类似的有hdb,hdc等</li><li>sda一般是指SATA接口的硬盘，sda一般指第一块硬盘，类似的有sdb,sdc等</li><li>现在的内核都会把硬盘，移动硬盘，U盘之类的识别为sdX的形式</li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>Debian 分区程序<a href="https://www.debian.org/releases/wheezy/mips/apcs05.html.zh-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.debian.org/releases/wheezy/mips/apcs05.html.zh-cn</code></p></blockquote></li><li><p>从零开始的Linux From Scratch<a href="http://www.linuxfromscratch.org/lfs/downloads/9.1-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/9.1-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html</code></p></blockquote></li></ul><hr><p><strong>问题解决方案:</strong></p><p><strong>1.找不到fdisk指令</strong></p><ul><li><p>查看路径:</p><blockquote><p><code>whereis cfdisk</code></p></blockquote></li><li><p>输出现有PATH变量路径</p><blockquote><p><code>echo $PATH</code></p></blockquote></li><li><p>配置软链接</p><blockquote><p><code>ln -sv [软件所在路径] [PATH所指定路径]</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian GNU/Linux-2</title>
    <url>/2020/02/23/Debian-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Debian-GNU-Linux-2"><a href="#Debian-GNU-Linux-2" class="headerlink" title="Debian GNU/Linux-2"></a>Debian GNU/Linux-2</h2><ul><li>网络配置问题统一解决方案</li></ul><h3 id="Debian网络配置基本命令"><a href="#Debian网络配置基本命令" class="headerlink" title="Debian网络配置基本命令"></a>Debian网络配置基本命令</h3><ul><li><p>输出网卡与网络配置情况</p><blockquote><p><code>ip -a/ifconfig</code></p></blockquote></li><li><p>查看所有已有网卡</p><blockquote><p><code>networkctl</code></p></blockquote></li><li><p>网卡配置目录</p><blockquote><p>/etc/network/interfaces</p></blockquote></li></ul><p><strong>网卡配置说明:</strong></p><ul><li><p>配置静态IP地址</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">auto eth0 		#开机自动激活</span><br><span class="line">iface eth0 inte static 	#静态IP</span><br><span class="line">address<span class="built_in"> IP </span>		#本机IP</span><br><span class="line">netmask 255.255.255.0 	#子网掩码</span><br><span class="line"><span class="comment"># network IP</span></span><br><span class="line"><span class="comment"># broadcast IP</span></span><br><span class="line">gateway<span class="built_in"> IP	</span>	#路由网关</span><br></pre></td></tr></table></figure></li><li><p>DHCP自动获取(动态IP地址)</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">auto</span> <span class="string">eth0</span></span><br><span class="line"><span class="attr">iface</span> <span class="string">eth0 inet dhcp</span></span><br></pre></td></tr></table></figure></li><li><p>配置好之后保存配置，重启网卡(多种方式)</p><blockquote><p><code>service networking restart</code> #service工具<br><code>systemctl restart network</code> #systemctl工具<br><code>/etc/init.d/network-manager restart</code><br><code>/etc/init.d/networking restart</code></p></blockquote></li><li><p>重启指定网卡</p><blockquote><p><code>ifdown eth0</code><br><code>ifup eth0</code></p></blockquote></li><li><p>配置DNS</p><blockquote><p><code>vi /etc/resolv.conf</code><br><code>nameserver 0.0.0.0</code></p></blockquote></li></ul><hr><h3 id="名称与各参数简述与解释"><a href="#名称与各参数简述与解释" class="headerlink" title="名称与各参数简述与解释:"></a>名称与各参数简述与解释:</h3><p><strong>eth(ethernet)</strong></p><blockquote><p>有线网卡<br>物理网卡<br>如:eth0，eth1，eth2…则代表网卡一，网卡二，网卡三…<br>还可称为en</p></blockquote><hr><ul><li>eth各接口说明<blockquote><p>eth0=lan接口<br>eth1=wan接口<br>br-lan=lan网桥<br>br-lan 虚拟设备，用于LAN口设备桥接，可以用<code>brctl show</code>查看使用情况</p></blockquote></li></ul><hr><ul><li>en(ethernet)标识说明:<blockquote><p>o:主板板载网卡，集成是的设备索引号<br>p:独立网卡，PCI网卡<br>s:热插拔网卡，USB之类的扩展槽索引号<br>nnn(数字):MAC地址+主板信息计算得出唯一序列</p></blockquote></li></ul><hr><p><strong>lo</strong></p><blockquote><p>代表localhost，即127.0.0.1<br>虚拟设备，自身的回环网设备</p></blockquote><hr><p><strong>ens</strong></p><blockquote><p>ens33为自动备援模式，名称定为ens33<br>eno1表示主板BIOS内置的网卡<br>ens1表示主板BIOS中内置的PCI-E网卡<br>enp2s0为PCI-E独立网卡<br>eth0:如果没有使用以上任何一个，则将返回默认的网卡名</p></blockquote><hr><ul><li>wlan<blockquote><p>无线网卡<br>wlan0=无限端口</p></blockquote></li></ul><hr><p><strong>网络接口的传统命名方式(可预测命名方案)</strong><br><strong>传统命名:</strong></p><ul><li>以太网:ethX,[0,oo)<blockquote><p>例如eth0，eth1…</p></blockquote></li><li>PPP网络:pppX, [0,…]<blockquote><p>例如，ppp0, ppp1, …</p></blockquote></li></ul><hr><h3 id="NONA"><a href="#NONA" class="headerlink" title="NONA"></a>NONA</h3><ol><li><p>设置网卡</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">nano</span> <span class="string">/etc/network/interfaces</span>  <span class="string">/etc/network/interfacesbak</span>   	<span class="comment">#备份原有配置文件</span></span><br><span class="line"><span class="string">nano</span> <span class="string">/etc/network/interfaces</span>   			<span class="comment">#编辑网网卡配置文件</span></span><br><span class="line"><span class="string">auto</span> <span class="string">lo</span></span><br><span class="line"><span class="string">auto</span> <span class="string">eth0</span>  					<span class="comment">#开机自动连接网络</span></span><br><span class="line"><span class="string">iface</span> <span class="string">lo</span> <span class="string">inet</span> <span class="string">loopback</span></span><br><span class="line"><span class="string">allow-hotplug</span> <span class="string">eth0</span></span><br><span class="line"><span class="string">iface</span> <span class="string">eth0</span> <span class="string">inet</span> <span class="string">static</span>   				<span class="comment">#static表示使用固定ip，dhcp表述使用动态ip</span></span><br><span class="line"><span class="string">address</span> <span class="number">192.168</span><span class="number">.21</span><span class="number">.166</span>   				<span class="comment">#设置ip地址</span></span><br><span class="line"><span class="string">netmask</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  				<span class="comment">#设置子网掩码</span></span><br><span class="line"><span class="string">gateway</span> <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span>    				<span class="comment">#设置网关</span></span><br><span class="line"><span class="string">ctrl+o</span>   						<span class="comment">#保存配置</span></span><br><span class="line"><span class="string">ctrl+x</span>   						<span class="comment">#退出</span></span><br></pre></td></tr></table></figure></li><li><p>设置DNS</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">cp</span>  <span class="string">/etc/resolv.conf</span>   <span class="string">/etc/resolv.confbak</span>    	<span class="comment">#备份原有dns配置文件</span></span><br><span class="line"><span class="string">nano</span> <span class="string">/etc/resolv.conf</span>   			<span class="comment">#编辑配置文件</span></span><br><span class="line"><span class="string">nameserver</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>   			<span class="comment">#设置首选dns</span></span><br><span class="line"><span class="string">nameserver</span> <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span>   			<span class="comment">#设置备用dns</span></span><br><span class="line"><span class="string">ctrl+o</span>   					<span class="comment">#保存配置</span></span><br><span class="line"><span class="string">ctrl+x</span>   					<span class="comment">#退出</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>网络上关于以下概念的资料数不胜数，这里就不再多做阐述了</li></ul><p><strong>OSI七层模型:</strong></p><blockquote><p>由上至下简述(程序至底层)<br>应用层/表示层/会话层/传输层/网络层/数据链路层/物理层<br>上层依赖于下层，下层为上层提供服务<br>OSI内的每一层模型都有属于自己的协议集与功能集<br>层与层之间相互独立且相互依赖</p></blockquote><ul><li><p>中文维基<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B</code></p></blockquote></li><li><p>TCP/IP</p><blockquote><p>IP:互联网协议<br>TCP:传输控制协议<br>三次握手与四次握手<br>任何基于互联网协议蔟与协议套组都基于TCP/IP</p></blockquote></li><li><p>HTTP</p><blockquote><p>超文本传输协议<br>无状态协议<br>大部分实现都是基于TCP的</p></blockquote></li><li><p>DNS</p><blockquote><p>域名系统</p></blockquote></li><li><p>其它常用协议</p><blockquote><p>应用层:BGP/DHCP/HTTPS/IMAP/NNTP/NTP/POP/SMTP/SNMP/SSH/Telnet等等<br>传输层:UDP/TLS/SSL/DCCP等等<br>网络层:IP/ICMP/IGMP/IPsec等等<br>链接层:APR/PPP/DSL/ISDN等等</p></blockquote></li></ul><hr><h3 id="操作流程-逻辑-整合-简述"><a href="#操作流程-逻辑-整合-简述" class="headerlink" title="操作流程(逻辑)整合/简述"></a>操作流程(逻辑)整合/简述</h3><ol><li>查看网络配置</li><li>查看已有网卡</li><li>启动或重启网卡</li><li>设置配置文件(静态IP或动态IP)</li><li>配置网关</li><li>配置DNS</li><li>保存配置并重启网卡</li></ol><ul><li>任何网络与本地的流量与数据的传输都需要经过本地或无限的网卡</li><li>流量与数据的抓取也只是读取经由网卡的信息并进行输出</li><li>配置无线或有限网的前提是所处的物理环境已有网络支持</li><li>网卡用于联网的虚拟信息处理方式，网络离不开物理层面的支持</li><li>网卡被归纳为设备内</li></ul><hr><p><strong>参考资料:</strong></p><ul><li>Linux系统运维<a href="https://www.osyunwei.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.osyunwei.com/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-4</title>
    <url>/2020/02/22/LFS-4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="LFS-4"><a href="#LFS-4" class="headerlink" title="LFS-4"></a>LFS-4</h2><h3 id="制作步骤"><a href="#制作步骤" class="headerlink" title="制作步骤"></a>制作步骤</h3><hr><p><strong>制作步骤设计:</strong></p><p><strong>分为三个阶段:</strong></p><ul><li>一阶段:1.创建目标系统目录，2.创建临时系统目录，3. 建立预工具链</li><li>二阶段: 4.建立临时系统，5. 建立目标工具链</li><li>三阶段: 6.建立目标系统，7.收尾工作</li></ul><hr><ol><li>创建目标系统目录</li></ol><ul><li>先建立一个空白的分区用于存放目标系统，并保证在制作完成后可以从这个分区启动已经制作完的系统</li><li>将这个分区格式化为主系统能够识别的文件系统，比如<code>EXT3</code>，并将该分区挂载到主系统中的某个目录，比如<code>/opt/mylinux</code>，这个目录将作为目标系统的制作目录</li><li>另外，还需要人为的将制作中所需要的软件包放在某个目录内，该目录需要在已经制作完成的系统的运行环境中能够访问到</li><li>可以存放在目标系统制作的目录中，如建立一个<code>/opt/mylinux/source</code>目录并存放于其中</li></ul><hr><ol start="2"><li>创建临时系统目录</li></ol><ul><li>本步骤是为了在主系统制作临时系统(详情可见阶段一与阶段二)和使用临时系统来制作目标系统(详情可见阶段三)能够用同样的目录来访问临时系统的目录和文件</li><li>阶段二和阶段三分别在不同根目录的运行环境中，但都使用到了临时系统，如果想让临时系统以最小的改动就可以使其中的命令既可以在主系统所在的运行环境中正常工作，也可以在目的相同所在的运行环境中工作正常</li><li>最好的解决方式就是让两个环境中调用临时系统的目录路径是完全一样的</li></ul><p><strong>执行步骤:</strong></p><ul><li><p>在目标系统所在目录中创建一个存放临时系统的目录，如<code>/opt/mylinux/tools</code></p></li><li><p>然后利用软链接文件的方式在主系统的根目录建立一个指向<code>/opt/mylinux/tools</code>的链接文件</p></li><li><p>该链接文件的文件名必须是<code>/tools</code></p></li><li><p>不去先建立<code>/tools</code>，然后再在<code>/opt/mylinux</code>目录下建立一个指向<code>/tools</code>的同名软链接的原因</p></li><li><p>原因就是目标系统目录是主系统的根目录下的某个目录，主系统根目录的运行环境都可以正常访问目标系统中目录</p></li><li><p>而目标系统在进入以所在目录为根目录的运行环境后就无法访问主系统的其它目录中的内容了</p></li><li><p>所以将真正的内容存放在目录系统的目录中将能够保证各个制作阶段均能访问临时系统中的内容，并且保证访问路径一致</p></li><li><p>采用链接方式在不同阶段的方式关系(链接我呢见在不同环境中的访问关系)</p></li></ul><p><strong>逻辑简述:</strong></p><p><strong>一阶段&amp;二阶段-&gt;三阶段</strong></p><blockquote><p><code>一阶段&amp;二阶段:[主系统(/tools)]&lt;-&gt;[目标系统所在目录(/opt/mylinux/tools)]</code><br><code>三阶段:{运行主系统环境[主系统(/tools)]}-可以访问-&gt;{运行目标系统环境[目标系统(/tools)]}</code><br>同时<br><code>三阶段:{运行目标系统环境[目标系统(/tools)]}-无法访问-&gt;{运行主系统环境[主系统(/tools)]}</code></p></blockquote><ul><li>箭头代表链接关系，箭头指向的是实际目录，另一方则为链接文件</li><li>在一阶段与二阶段中<code>/tools</code>和<code>/opt/mylinux/tools</code>无论谁是链接文件都不影响互相访问</li><li>而在第三阶段，只有<code>/tools</code>是链接文件时才能互相访问，<code>/opt/mylinux/tools</code>(在目标系统环境中变为<code>/tools</code>)是链接文件时无法访问<code>/tools</code>中的内容</li><li>同时还可以使用目录映射的方式使两个阶段都能够正常访问临时系统，即有两种方法:一种是软连接的方式，另一种是目录映射的方式</li><li>本篇文章仅介绍软链接的方式</li></ul><hr><ol start="3"><li>建立预工具链</li></ol><ul><li>预工具链的作用是生成临时工具链，临时工具链是独立于主系统中的工具链，根据工具链的制作原则需要有一个外部依赖的工具链作为过渡，该工具链就是预工具链</li></ul><p><strong>预工具链到临时工具链的制作过程与步骤</strong></p><ol><li>先完成预工具链的编译工具部分，此时预工具链是一个内部依赖的工具链，依赖主系统中的Glibc</li><li>然后使用编译工具完成临时系统中的Glibc，该Glibc存放在临时系统目录中，作为临时工具链和临时系统所依赖的Glibc</li><li>对预工具链进行调整，变为外部依赖的工具链，即可开始编译临时工具链中的编译工具，以此完成临时工具链</li><li>预工具链是临时工具链的过渡工具链，可以将其存放在临时系统的目录中，临时工具链的安装会覆盖掉预工具链，也可以存放在其它目录下，但需要在用完后手工删除掉</li></ol><p><strong>到此第一阶段的制作已经完成，即将开始第二阶段的制作过程</strong></p><hr><ol start="4"><li>建立临时系统</li></ol><ul><li><p>现在已经完成了临时工具链，但仅仅有一个工具链还不能顺利的编译各种软件包，需要有各种各样的辅助命令来共同完成</p></li><li><p>当前还处于主系统运行环境中，主系统所附带的各种辅助命令目前都可以用于编译</p></li><li><p>为了切换到目标系统运行环境后还能继续使用这些辅助命令，就必须将这些辅助命令存放在目标系统运行环境所能访问到的目录中</p></li><li><p>建立临时系统的原因就是为了承前启后，前即为主系统，后则为目标系统</p></li><li><p>临时系统是目标系统建立前用于支撑目标系统运行环境的基本框架，目标系统需要人为的进行从头建立</p></li><li><p>即为一开始什么都没有，此时临时系统承担了运行环境的运作，包括提供用户的交互功能，编译软件包以及常用命令</p></li><li><p>因此临时系统中必须加入工具链，辅助命令，常用命令和支撑运行环境的程序(如Bash)</p></li></ul><p><strong>逻辑简述(不同阶段切换过程中各个系统的内容)</strong></p><p><strong>一阶段开始-&gt;二阶段开始-&gt;三阶段开始-&gt;三阶段结束</strong></p><blockquote><p>一阶段:<code>{一阶段开始，主系统运行环境内(/&amp;/tools)[主系统(完整)/临时系统(无内容)]}-此时的目标系统内无内容</code><br>二阶段:<code>{二阶段开始，主系统运行环境内(/&amp;/tools)[主系统(完整)/临时系统(部分)]}-此时的目标系统内无内容</code><br>三阶段:<code>{三阶段开始，目标系统运行环境内(/&amp;/tools)[临时系统(完整)/目标系统(无内容)]}-{/[主系统(完整)]}</code><br>三阶段:<code>{三阶段结束，目标系统运行环境内(/&amp;/tools)[临时系统(完整)/目标系统(完整)]}-{/[主系统(完整)]}</code></p></blockquote><ul><li><p>第三阶段开始时，目标系统的根目录(<code>/</code>)没有任何内容，只能靠临时系统提供各种编译和运行的功能</p></li><li><p>第三阶段完成后，目标系统已经完整，就可以不需要临时系统而直接运行了</p></li><li><p>可以了解到临时洗头膏必须拥有相对完整的运行能力，并且要独立于主系统，无论临时工具链还是临时系统中其它辅助命令都必须依赖临时系统中的函数库</p></li><li><p>临时系统必须全部由临时工具链来链接生成</p></li><li><p>此时临时系统的制作内容就非常明确了，如Bash，常用命令(Coreuils等)和工具链环境(Awk，Sed等)</p></li></ul><hr><ol start="5"><li>建立目标工具链</li></ol><ul><li><p>制作完成了临时系统后就要进入第三阶段的制作过程，即为将运行环境正式切换到目标系统运行环境</p></li><li><p>需要明确的是:目标系统最终是需要通过人为方式去将内容进行保留，临时系统在完成目标系统后就会被删除掉</p></li><li><p>目标系统同样需要一个内部链接的工具链，这是为了实现今后目标系统脱离主系统后能成为一个独立的系统且能够继续编译安装软件包</p></li><li><p>目标的临时工具链也是内部依赖的工具链，根据制作原则可以知道从内部依赖的工具链生成另外一个内部依赖的工具链需要有一个外部依赖的工具链作为过渡</p></li><li><p>此时已经不再编译临时系统上的程序文件了，可以通过调整工具链的方法将临时工具链内部依赖变为内部依赖，过渡用的外部依赖工具链就用调整临时工具链的方法来实现，临时工具链由此开始作为过渡工具链</p></li><li><p>根据工具链的制作原则，调整之前需要先建立好目标系统中的Glibc，这个Glibc同样根据工具链制作原则存放在目标系统的目录中</p></li><li><p>然后调整临时工具链，再编译目标系统中的，形成内部依赖的工具链</p></li><li><p>目标工具链的形成意味着临时工具链的使命已经完成，虽然现在临时工具链经过了调整，但后续的制作过程中不会再使用到它了</p></li><li><p>此时不用在意它的存在，也不需要这时去删除它，在最后完成目标系统后再将它连同临时系统一并删除</p></li></ul><hr><ol start="6"><li>建立目标系统</li></ol><ul><li>临时工具链虽然已经不再需要了，但目前目标系统除了目标工具链还一无所有</li><li>还需要用到临时系统中的各种各种目录以及其它常用命令，交互环境程序也还在使用临时系统中的命令</li><li>如同制作临时系统的时候需要的命令安装到临时系统中一样，可以人为的将临时系统中出现的所有的软件包都重新用目标工具链再次编译并安装到目标系统目录中</li><li>最终将完全替代掉临时系统中的所有软件包和命令</li><li>目标系统和临时系统的要求是不一样的，临时系统只需要为制作目标系统编译环境和简单的运行环境的支撑能力即可</li><li>但目标系统除了要具备临时系统所具有的功能之外还需要有更高的要求</li><li>比如网络的支持，程序进程的管理，系统启动等，因此还需要安装许多Linux系统中常见的软件包</li><li>至于关于常见软件包，这里不过过多枚举</li></ul><hr><ol start="7"><li>收尾工作</li></ol><ul><li><p>完成了目标系统后，就可以展开收尾工作了</p></li><li><p>包括删除临时系统，临时系统所有文件都存放在了<code>/tools</code>目录中，只需要删除<code>/tools</code>就可以了</p></li><li><p>还有一些公共的配置文件需要进行设置，如主机名，网络地址等，这些内容将在后续章节内进行介绍，这里先不再赘述</p></li><li><p>对于编译出来的命令程序还有一个需要注意的地方，很多软件包编译生成的程序文件带有许多调试信息，会占据相当大的磁盘空间</p></li><li><p>有的程序文件所附带的调试信息可以使其增加数倍的大小，主体代码只有几百KB的程序可能会超过1MB，去掉这些调试信息显得非常重要</p></li><li><p>调试信息的删除可以使用strip命令来完成，具体参数不进行过多阐述，需要注意的一点就是某一些程序或软件的调试信息中会与其静态函数库发生关联，如果去掉则可能导致静态函数库无法使用</p></li></ul><hr><ol start="8"><li>启动目标系统</li></ol><ul><li>让这个目标系统正常的启动起来</li><li>如果以LiveCD的方式进行制作，同时所使用的本地计算机内没有任何影片盘的启动器时，可以使用GRUB的启动程序</li><li>关于GRUB的使用这里不做过多阐述</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-3</title>
    <url>/2020/02/22/LFS-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="LFS-3"><a href="#LFS-3" class="headerlink" title="LFS-3"></a>LFS-3</h2><ul><li>内容接LFS-2</li></ul><h3 id="制作过程中的相关技术"><a href="#制作过程中的相关技术" class="headerlink" title="制作过程中的相关技术"></a>制作过程中的相关技术</h3><ol><li>虚拟根目录</li></ol><ul><li>制作目标系统的最终且最基本点是让其称为一个可以独立运行的系统(不依赖主系统和临时系统的纯净系统)</li><li>根据Linux系统的特点它需要存放于根目录下，而第一阶段中的主系统也同样存放在根目录下</li><li>主系统在制作过程中是始终运行的，制作过程中要运行目标系统中的命令，从而形成了命令的执行矛盾</li><li>而在Linux系统中使用虚拟根目录可以解决这个矛盾</li><li>linux内核启动时建立的根目录被定义为真正的目录，虚拟根目录可以简单的理解为:一个运行的Linux系统中可以存在多个运行环境，而每个运行环境都有自己的根目录，这些运行环境的根目录就可以被定义为虚拟根目录，任何目录都可以被设置为某个运行环境中的根目录</li><li>在主系统中建立一个目录，其中存放系统的基本命令，即可将该目录作为虚拟根目录启动一个新的运行环境</li><li>如果将主系统环境称为环境A，把在A环境下建立的新的运行环境称为环境B，则可称环境B为环境A的子环境，而环境A被称为环境B的父环境</li></ul><p><strong>实现逻辑简述:</strong></p><ol><li>假设主系统中的根目录下存在若干文件目录</li><li>指定其中某一目录作为制作目标系统的基础目录(将此目录设置为新的运行环境的根目录)</li><li>此时将此目录称为X，而此目录下还可以存放若干文件目录，这里用X1，X2，X3表示</li><li>基于跟目录X创建一个运行环境，此时运行目录X下将只有X1，X2，X3目录</li></ol><ul><li>用于作为新运行环境中的根目录可以是父环境中的任何命令或者目录中的目录，同时也包括父环境中的根目录</li></ul><hr><ol start="2"><li>分区的挂载</li></ol><ul><li>目标系统的最终目的是独立于主系统而运行，此时需要将目标系统装在一个分区中，而不是主系统的某个目录下</li><li>Linux系统是通过挂载的方式使用分区，挂载就是将某个存储设备以某种文件系统链接到某个目录</li><li>用户查看到目录中的文件即为分区中的文件，对其中的文件进行操作与操作一般目录的文件相同</li><li>只要有一个空分区，将该分区格式化为主系统能识别的文件系统，并将其挂载到主系统的某个目录上就可以了</li><li>目标系统只需要存放到这个目录就等于存放在该分区，制作完成后就可以直接使用这个分区来启动系统，存放在目录下的第一级的文件和目录就是目标系统跟目录的内容</li></ul><p><strong>实现逻辑简述</strong></p><ol><li>挂载主系统的根目录下的某个目录，将此目录定义为磁盘分区A，此磁盘分区下拥有若干个目录</li><li>然后从磁盘分区A启动目标系统，启动之后的目标系统的根目录以及根目录下的文件即为主系统下被挂载的文件目录的中的文件，在这里还可将其称为磁盘分区A</li><li>从而使目标系统脱离主系统运行</li></ol><ul><li>可以看出子环境运行的方式和目标系统重新启动后的根目录相同</li><li>根据此原理，制作目标系统的过程中以挂载分区的目录作为虚拟根目录创建新的运行环境，在其中可以使用目标系统的命令</li><li>从而解决了主系统和目标系统都需要使用根目录的矛盾</li><li>目标系统制作完成后，目录系统就可以从分区单独启动以此来脱离主系统</li></ul><hr><ol start="3"><li>链接文件</li></ol><ul><li><p>在Linux系统中有一种用来引用其它文件的符号链接文件，这里将其简称为链接文件</p></li><li><p>其包含有一条绝对路径或者相对路径的形式用于指向其它文件或者目录的引用</p></li><li><p>其所链接的文件被称为目标文件，链接文件和目标文件的文件名可以相同也可以不同</p></li><li><p>相同文件名的情况下目标文件和链接文件不能存放于实质相同的目录下</p></li><li><p>链接文件可以分为软链接与硬链接两种</p><blockquote><p>软链接文件的读写就如同直接对目标文件进行操作，链接文件是一个独立文件，其存在并不依赖于目标文件<br>如果删除一个链接文件，它所指向的目标文件不受影响<br>如果删除了目标文件，其指向目标文件的链接文件依然存在</p></blockquote></li><li><p>硬链接与目标文件使用同一个文件索引节点，因此只能在同一个磁盘分区中使用硬链接，并且它不能离开关联文件而独立存在</p><blockquote><p>如果一个硬链接被移动，重命名或者删除时，其余关联到同一文件的硬链接不受影响<br>当最后一条指向该文件的硬链接被删除时，该文件内容会消失</p></blockquote></li><li><p>软链接可以跨磁盘分区来进行目标文件的指定，而硬链接只能使用同一个磁盘分区中的文件</p></li><li><p>建立软链接和硬链接的命令在Linux系统中是相同的，都是ln命令，使用不同的选项以建立不同的连接方式</p></li><li><p>ln命令的基本格式</p><blockquote><p><code>ln [options] 目标文件 链接文件</code></p></blockquote></li><li><p>参数<code>-s</code>表示建立软链接，没有设置的情况下默认建立硬链接</p></li><li><p>目标文件可以是相对路径或绝对路径</p></li><li><p>在制作过程中，均使用软链接文件，即符号链接文件</p></li></ul><hr><ol start="4"><li>文件系统</li></ol><ul><li>文件系统是一种存储和组织计算机文件和数据的方法，以更容易的去访问和查找数据</li><li>文件系统类型一览</li></ul><ol><li>磁盘文件系统:EXT2/3，XFS等等，可以直接应用在软硬盘存储设备上</li><li>网络文件系统:NFS，CIFS等等</li><li>事务文件系统:AUFS等等</li><li>内存文件系统:TmpFS等等，使用内存来模拟存储设备的文件系统，可以从内存中划出一块区域用于像磁盘文件系统那样来存放文件和目录</li><li>特殊文件系统:proc，sysfs等等，具有特殊功能的文件系统，如内核文件系统</li></ol><p><strong>文件系统的使用:</strong></p><ul><li>文件系统在Linux系统中以挂载的方式使用，挂载工具为mount<blockquote><p><code>mount [options] 设备名 目录名</code></p></blockquote></li><li>参数-t用于指定文件系统名称，一般mount会自动检测文件系统名称</li><li>如<code>mount /dev/sda3 /mnt</code><blockquote><p><code>/dev/sda3</code>是挂载分区，<code>/mnt</code>是被挂载的目录</p></blockquote></li></ul><hr><ol start="5"><li>目录映射</li></ol><ul><li>子环境的运行方式和从分区启动的方式中，虽然根目录是一致的，但就整个系统来说还是有很多差别的</li><li>比如有些目录，类似于/dev或/proc等等中的内容都是系统启动过程中创建的，并且会在运行过程中发生变化</li><li>这些目录中的内容有时会影响系统的制作，如果想让两种方式的效果最为接近，就需要让这些目录中存放的内容相似</li><li>这些目录的内容多与内核相关，但子环境的运行方式所使用的是主系统中的内核</li><li>因此目标系统和主系统的内核应当尽量保存兼容，以此利用主系统中相应目录的内容来补充目标系统中的这些目录中的内容</li><li>想让主系统和目标系统对应目录中的内容保存一致，最容易的办法无非是复制目录，但因为/proc的内容是反应内核当前的情况(动态目录)，复制过来的目录并不能随着系统的运行而发生变化，所以不能采用复制的方法</li><li>可以用建立软链接文件的方式来让两个目录的内容一致而又不采用复制目录的方法</li><li>访问链接文件就如同访问它所链接到的目录一样，但软链接文件的一个问题就是目标文件或目录必须存在且可以被当前的运行环境所访问</li></ul><p><strong>这里举一个例子:</strong></p><ul><li>在主系统中的根目录下存在/proc目录，现在系统在/opt/目录下创建一个proc_a链接文件并指向/proc</li><li>当前运行环境中访问/opt/proc_a中的内容就如同访问/proc中的内容</li><li>但如果将/opt作为虚拟根目录启动一个新的运行环境时，原先的/opt/proc_a将变成/proc_a(此时此分区的文件目录与原主机的文件目录相隔离)</li><li>所以它指向的/proc无法在这个运行环境中被访问到，则会导致链接文件失效，所以链接文件的方法也不能使用</li><li>所以这里就要引出目录映射的概念了</li></ul><p><strong>文件映射:</strong></p><ul><li><p>被映射的源目录和映射目录内容上保存一致，对它们中任何一方目录内的改动都将直接导致另一方同样的修改</p></li><li><p>与链接文件处理方式不同，源目录和映射目录都必须是实际目录，而非链接文件</p></li><li><p>目录映射并不依赖源目录的存在位置，即使在建立好目录映射后，改变源目录的名称或者位置都不会影响到映射目录中的内容</p></li><li><p>因此使用映射方式建立的目录一致性将在进入新的运行环境中继续产生作用</p></li><li><p>映射目录方法所建立起的文件关联会直接涉及于文件所在磁盘的物理地址，所以不会因为别名或修改文件状态的操作而发生失效或错误</p></li></ul><hr><ol start="6"><li>工具链调整</li></ol><p>*工具链从内部依赖转为外部依赖，不同外部依赖的转换，外部依赖转内部依赖，都属于调整依赖工具链<br>*调整工具链不存在内部依赖转内部依赖的情况</p><p><strong>这里举一个例子:</strong></p><ul><li>将工具链分为三个部分并用实际的软件包名称来表示:</li><li>工具链=Binutils+GCC+Glibc</li><li>调整工具链的实质就是用新的Glibc代替工具链原来的Glibc，两个Glibc存放在不同目录</li><li>调整工具链的原因是要让工具链中的编译工具改变链接的函数库位置，这个改变只需要改变两个地方:GCC的编译配置和Binutils中ld命令的函数库查询目录</li><li>GCC的编译默认配置被编译于GCC的相关文件中，GCC中的gcc命令有两种配置方式，一种是外部的配置文件，另一种是内部的默认配置</li><li>gcc命令优先使用外部配置的方式，则修改配置文件就可以实现目的</li><li>因为GCC的配置文件很复杂而不便于重新编写，所以可采用gcc命令将默认配置导出，然后修改相应的内容并保存到特定的文件中的方法来实现目的</li><li>gcc命令的默认导出配置方式的执行命令:<code>gcc -dumpspecs</code></li><li>该命令将默认配置显示在屏幕上，只需要人为的将其存放到gcc读取配置文件的目录中</li><li>gcc读取外部配置文件的目录可以使用此命令来获得:<code>dirname $(gcc -print-libgcc-file-name)</code></li><li>该命令返回读取配置文件的目录名，接下来只需要在这个目录中创建一个名为specs的文件，并将已经人为配置完的配置文件存放在该目录中就可以了</li><li>执行该命令:<code>gcc -dumpspecs &gt; $(dirname $(gcc -print-libgcc-file-name))/specs</code></li><li>此时配置文件已经准备好了，目前这个文件中的内容和GCC的默认配置完全一个，只需要人为的将文件中的内容进行修改就行</li><li>该文件以文本内容存放，所以可以使用一般的文本编辑器来进行修改，也可以使用文本编辑器的命令来进行修改，如sed命令</li><li>修改其寻址函数库的目录为新函数库的所在目录即可</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-2</title>
    <url>/2020/02/22/LFS-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Linux-from-Scratch-LFS-2"><a href="#Linux-from-Scratch-LFS-2" class="headerlink" title="Linux from Scratch/LFS-2"></a>Linux from Scratch/LFS-2</h2><ul><li>名词解释</li><li>制作逻辑</li><li>相关技术 LSF-3</li><li>制作步骤 LSF-4</li><li>目的为创造一个崭新的，基于Linux内核的操作系统</li></ul><hr><p><strong>linux from scratch</strong></p><h3 id="涉及名称一览-解释"><a href="#涉及名称一览-解释" class="headerlink" title="涉及名称一览(解释)"></a>涉及名称一览(解释)</h3><p><strong>主系统</strong></p><ul><li>源系统，用于提供制作处新系统的基本环境</li><li>可以比喻成一架航母上的某一架飞机的基础机型</li></ul><p><strong>目标系统</strong></p><ul><li>基于主系统要仿制/制作的目标系统(最终目的)</li><li>可以比喻成要仿制基础机型进行制造的另一架飞机</li></ul><p><strong>临时系统</strong></p><ul><li>在制作目标系统的过程中需要的过渡系统，用于辅助目标系统的制作过程</li><li>可以比喻成要制造却还在规划中的飞机模型与飞机的基本结构</li></ul><hr><p><strong>编译工具</strong></p><ul><li>这里将汇编工具Binutils与编译器GCC合称为编译工具</li></ul><p><strong>工具链</strong></p><ul><li><p>汇编工具，编译器，与C标准库(Binutils，GCC，Glibc)合成为工具链</p></li><li><p>因为让工具链生成可执行文件通常都需要函数库(标准库)，所以这里这里将函数库包含于工具链内</p></li><li><p>因为在整个制作过程中，各个阶段都会产生工具链，所以这里将各个阶段的工具链名称进行以下定义和命名</p></li></ul><ol><li>原工具链</li></ol><ul><li>主系统的工具链</li></ul><ol start="2"><li>预工具链</li></ol><ul><li>用于生成临时工具链的工具链</li></ul><ol start="3"><li>临时工具链</li></ol><ul><li>用于生成临时系统的工具链</li></ul><ol start="4"><li>目标工具链</li></ol><ul><li>用于生成目标系统的工具链</li></ul><hr><p><strong>辅助命令</strong></p><ul><li>在编译软件包的过程中，处理工具链以外通常还需要一些命令的参与</li><li>类似于make之类的，这类工具这里将其合成为辅助命令</li></ul><p><strong>工具链环境</strong></p><ul><li>将工具链同辅助命令合称为工具链环境，因为不同的阶段会出现不同的组合，所以这里将各个阶段工具链环境的名称进行以下定义和命名</li></ul><ol><li>预工具链环境</li></ol><ul><li>预工具链+主系统中的辅助命令及基本函数库</li></ul><ol start="2"><li>预临时工具链环境</li></ol><ul><li>临时工具链+临时系统中的辅助命令及基本函数库</li></ul><ol start="3"><li>目标工具链</li></ol><ul><li>目标工具链+目标系统中的辅助命令及基本函数库</li></ul><hr><p><strong>运行环境</strong></p><ul><li>因为在一个运行的系统中可以存在多个不同的环境，这些环境中有各自的根目录及环境设置</li><li>这一类的环境被称为运行环境，因为在制作过程中各个阶段会处于不同的运行环境，所以这里将各个阶段的运行环境进行以下定义和命名</li></ul><ol><li>主系统运行环境</li></ol><ul><li>以主系统所在的运行环境</li></ul><ol start="2"><li>目标系统运行环境</li></ol><ul><li>目标系统所在目录为根目录的运行环境</li></ul><hr><p><strong>头文件</strong></p><ul><li>用于编译的一类文件，以存放函数的接口描述与结构体信息等程序设计的相关内容</li></ul><p><strong>纯净度</strong></p><ul><li>目标系统对于主系统依赖程度的评估</li><li>目标系统必须完全不依赖于主系统，才可称其为独立系统</li></ul><hr><p><strong>结构体系描述</strong></p><blockquote><p><code>系统=内核+各类函数库+交互环境+各种应用程序(常用命令的指令集)+各类配置文件(辅助文件)</code></p></blockquote><blockquote><p><code>[程序]-配置文件-&gt;[命令]-配置文件-&gt;[交互环境]-配置文件-&gt;[函数库]-&gt;{内核}</code></p></blockquote><hr><p><strong>启动过程描述</strong></p><blockquote><p><code>BIOS/UEFI-&gt;GRUB/LILO-&gt;KERNEL(Kernel)</code></p></blockquote><hr><p><strong>基本编译过程描述</strong></p><blockquote><p><code>[Make]-GCC/各种编译工具-[源代码]-&gt;[目标代码]</code><br>同时Binutils利用以生成的目标代码<br><code>[Make]-[Binutils]-&gt;[共享函数库(运行时需要)/静态函数库(编译进程序)]-[目标代码]-&gt;{可执行程序}</code></p></blockquote><hr><h3 id="制作逻辑描述"><a href="#制作逻辑描述" class="headerlink" title="制作逻辑描述"></a>制作逻辑描述</h3><ul><li>常用命令尽量使用GNU所提供的</li></ul><ol><li>主系统准备</li></ol><ul><li>主系统与目标系统相同或相兼容</li><li>拥有工具链与辅助命令，即为原工具链</li></ul><hr><ol start="2"><li>预工具链的生成</li></ol><ul><li>主系统准备好之后就可以建立预工具链了</li><li>建立预工具链的目的是建立临时工具链</li><li>预工具链由原工具链生成，即为原工具链(初始工具链)到临时工具链(目的工具链)的过渡工具链</li><li>预工具链建立之初是一个内部依赖方式的工具链，用它编译出来的程序文件将链接到主系统的Glibc(C标准库)上</li></ul><hr><ol start="3"><li>临时工具链的生成</li></ol><ul><li>临时工具链的目的是建立临时系统，临时系统需要脱离主系统的运行环境</li><li>临时工具链本身也是临时系统的重要组成部分，所以临时工具链也能够脱离主系统的运行环境</li><li>预工具链负责完成临时系统种的Glibc，当Glibc完成后对预工具链进行依赖方式的调整，使与工具链变为外部依赖的工具链</li><li>调整完成后生成临时编译工具，临时编译工具依赖于临时系统种的Glibc</li><li>临时编译工具与临时系统的Glibc一起组成临时工具链，预工具链的使命到此完成</li><li>临时工具链将代替预工具链完成临时系统的制作</li><li>临时工具链不依赖主系统下的函数库，临时工具链为内部依赖的形式</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>[主系统(源工具链/辅助命令/其它命令...)]-1-&gt;[预工具链]-2-&gt;[临时工具链]</code><br>同时<br><code>[辅助命令]-2-&gt;[临时工具链]</code></p></blockquote><hr><ol start="4"><li>临时系统的生成</li></ol><ul><li>编译一个软件往往除了编译器之外还需要其它程序的参与，仅仅靠临时工具链是无法完成目标系统的制作的</li><li>因此需要一个相对完整的工具链环境，临时系统将完成临时工具链环境的创建</li><li>临时工具链环境的创建过程需要主系统的辅助命令参与完成，在完成临时工具链环境的辅助命令后便完成了临时工具链</li><li>此时的临时工具链不再依赖主系统种的辅助命令编译软件了，为临时系统脱离主系统环境做好准备</li><li>临时工具链将继续完成临时系统的制作，临时系统的制作目的是为了给制作目标提供一个不依赖于主系统的编译环境</li><li>用临时工具链生成临时系统可保证其中各种工具环境所依赖的函数库也是临时系统种的函数库</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>[主系统(源工具链/辅助命令/其它命令...)]-1-&gt;[预工具链]-2-&gt;[临时系统(临时工具链)-3-&gt;(辅助命令)]</code><br>同时<br><code>[辅助命令]-3-&gt;[临时系统(辅助命令)]</code></p></blockquote><hr><ol start="5"><li>目标工具链</li></ol><ul><li>此时临时系统已经完成制作，接下来将要做的是让临时系统脱离主系统，即用临时系统去制作目标系统</li><li>同时为了能让目标系统称为自我扩展的系统，必须人为的为这个目标系统提供一个工具链</li><li>即用已经生成的临时系统来生成目标系统的Glibc，然后调整临时工具链使其编译出来的程序文件或库文件链接到目标系统的Glibc上</li><li>即内部依赖的临时工具链变成外部依赖方式，再编译目标系统上的Binuils和GCC</li><li>此时完成目标工具链的建立，下一步将再用目标工具链和生成目标工具链环境</li><li>此时临时工具链已经完成了使命，但临时工具链环境种的辅助命令还需要继续使用直到目标工具链中相应的辅助命令建立，从而形成目标工具链环境</li></ul><hr><ol start="6"><li>目标工具链环境的生成</li></ol><ul><li>为了让目标系统能够自给自足的进行扩展更新，目标系统需要带有最基本的编译环境</li><li>以上的操作已经将目标工具链生成，但使用的辅助命令还是临时系统中的命令</li><li>这个时候就需要人为的编译这些需要用到的辅助命令，并安装到目标系统中，以此成为目标工具链环境</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>[主系统(源工具链/辅助命令/其它命令...)]-1-&gt;[预工具链]-2-&gt;[临时系统(临时工具链)-3-&gt;(辅助命令)]</code><br>同时<br><code>[辅助命令]-3-&gt;[临时系统(辅助命令)]</code><br><strong>在以上步骤进行完成后</strong><br><code>[临时系统(临时工具链/辅助命令)]-4-&gt;[目标工具链]</code></p></blockquote><ul><li>按照生成临时系统的内容编译完各种辅助命令之后，就可以安装更多的辅助命令或其它程序了</li></ul><p><strong>在以上步骤进行完成后</strong></p><blockquote><p><code>[临时系统(临时工具链/辅助命令)]-4-&gt;[目标工具链环境(目标工具链)-5-&gt;(辅助命令)]</code><br>同时<br><code>[目标工具链环境(辅助命令)]&lt;-5-&gt;[临时系统(辅助命令)]</code></p></blockquote><hr><ol start="7"><li>目标系统的生成</li></ol><ul><li>在目标工具链环境生成之后将这个环境进一步完善，包括编辑工具，网络工具等，使之成为真正有用的目标系统</li><li>这部分内容的选择并没由什么限制与约束</li><li>在目标系统主体程序安装完毕后需要让这个系统能够正常而独立的运行起来，还需要人为的对启动过程进行处理</li></ul><p><strong>逻辑表示即为</strong></p><blockquote><p><code>[主系统]-预工具链-&gt;[临时系统]-&gt;[目标系统]</code></p></blockquote><p><strong>精准逻辑表示</strong></p><p><strong>区块一:</strong></p><blockquote><p><code>区块一(主系统-&gt;临时系统)</code><br><code>[主系统(源工具链/辅助命令/其它命令)]-1-&gt;预工具链-2-&gt;[临时系统(临时工具链-3-&gt;辅助命令)]</code><br>同时<br><code>[主系统(辅助命令)]-2-&gt;[临时系统(临时工具链-3-&gt;辅助命令)]</code><br>同时<br><code>[主系统(辅助命令)-3-&gt;[临时系统(辅助命令)]</code></p></blockquote><p><strong>区块二:</strong></p><blockquote><p><code>区块二(临时系统-&gt;目标系统)</code><br><code>[临时系统(临时工具链-3-&gt;辅助命令)]-4-&gt;[目标系统(目标系统工具链环境-5-&gt;辅助命令)-6-&gt;(其它命令...)]</code><br>同时<br><code>[临时系统(辅助命令)]-4-&gt;[目标系统(命令工具链)]</code><br><code>[临时系统(辅助命令)]&lt;-5-&gt;[目标系统(辅助命令)]</code></p></blockquote><hr><h3 id="执行逻辑一览-汇总"><a href="#执行逻辑一览-汇总" class="headerlink" title="执行逻辑一览(汇总)"></a>执行逻辑一览(汇总)</h3><ul><li><p>可以分为三个阶段，六个时间点(步骤点)</p></li><li><p>阶段一</p></li></ul><ol><li>利用主系统的工具链与辅助命令生成预工具链</li><li>利用主系统中的辅助命令与已经生成的预工具链生成临时系统中所需的临时工具链</li></ol><ul><li>阶段二</li></ul><ol start="3"><li>利用主系统中的辅助命令和临时系统中的临时工具链生成临时系统中的辅助命令</li><li>利用临时系统中的临时工具链和辅助命令生成目标系统中的目标工具链</li></ol><ul><li>阶段三</li></ul><ol start="5"><li>利用目标系统中的目标工具链生与临时系统中的辅助命令生成目标系统中的辅助命令，以此生成目标工具链环境(目标工具链+辅助命令)</li><li>利用目标系统中的目标工具链环境中的目标工具链和辅助命令生成其它命令</li></ol><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>LFS-1</title>
    <url>/2020/02/22/LFS-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Linux-from-Scratch-LFS-1"><a href="#Linux-from-Scratch-LFS-1" class="headerlink" title="Linux from Scratch/LFS-1"></a>Linux from Scratch/LFS-1</h2><hr><h3 id="资源整合目录"><a href="#资源整合目录" class="headerlink" title="资源整合目录"></a>资源整合目录</h3><p><strong>Linux from scratch</strong></p><ul><li>官方网站<a href="http://linuxfromscratch.org/" target="_blank" rel="noopener">跳转</a><blockquote><p><a href="http://linuxfromscratch.org/" target="_blank" rel="noopener">http://linuxfromscratch.org/</a></p></blockquote></li></ul><p><strong>LFS LiveCD</strong></p><ul><li><p>HTTP获取</p><blockquote><p><code>http://linuxfromscratch.org/livecd/download.html</code></p></blockquote></li><li><p>FTP获取</p><blockquote><p><code>http://ftp.osuosl.org/pub/lfs-livecd/lfslivecd-x86-6.3-r2145. iso</code></p></blockquote></li><li><p>LFS LiveCD说明<a href="http://linuxfromscratch.org/livecd/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://linuxfromscratch.org/livecd/index.html</code></p></blockquote></li><li><p>LFS wiki<a href="https://trac.clfs.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://trac.clfs.org/</code></p></blockquote></li><li><p>操作手册<a href="http://linuxfromscratch.org/lfs/downloads/9.1-rc1/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://linuxfromscratch.org/lfs/downloads/9.1-rc1/</code></p></blockquote></li><li><p>中文维基<a href="https://zh.wikipedia.org/wiki/Linux_From_Scratch" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Linux_From_Scratch</code></p></blockquote></li><li><p>从LFS官网下载的速度属实不言而喻(无论是FTP还是HTTP)</p></li><li><p>以下链接为永久有效</p></li><li><p>Version:<code>lfslivecd-x86-6.2-3</code></p></li><li><p>LFS LiveCD 百度网盘地址<a href="https://pan.baidu.com/s/1IROLau9-OxbN2f-BL3PJVA" target="_blank" rel="noopener">跳转</a></p><blockquote><p>URL:<code>https://pan.baidu.com/s/1IROLau9-OxbN2f-BL3PJVA</code><br>提取码:y0ss</p></blockquote></li><li><p>Version:<code>lfslivecd-x86-6.3-r2145</code></p><blockquote><p>链接<a href="https://pan.baidu.com/s/1ix83uytHKlvqaOUEa4Rq0w" target="_blank" rel="noopener">跳转</a><br>URL:<code>https://pan.baidu.com/s/1ix83uytHKlvqaOUEa4Rq0w</code><br>提取码:dlp4</p></blockquote></li><li><p>Version:<code>lfslivecd-x86_64-6.3-r2145</code></p><blockquote><p>链接<a href="https://pan.baidu.com/s/1R4T6j07yoR9JAO1U2EoClA" target="_blank" rel="noopener">跳转</a><br>URL:<code>https://pan.baidu.com/s/1R4T6j07yoR9JAO1U2EoClA</code><br>提取码:1atk</p></blockquote></li><li><p>linux公社仓库<a href="https://linux.linuxidc.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linux.linuxidc.com/</code></p></blockquote></li></ul><hr><p><strong>GNU/Linux LFS Linux From Scratch</strong></p><ul><li><p>基础准备与Linux系统定制原理</p></li><li><p>LiveCD</p><blockquote><p>利用LFS的方法生成可以自行启动并安装了足够软件的CD<br>可以用来在空机器上安装LFS，或者直接在其上运行应用，已经停止维护</p></blockquote></li><li><p>Linux From Scratch简体中文版(version 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>Linux From Scratch简体中文版(全本版)<a href="https://lctt.github.io/LFS-BOOK/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/</code></p></blockquote></li></ul><hr><p><strong>LFS官方教材所整理的步骤</strong></p><ul><li><p>在宿主操作系统上安装LFS，需要的步骤如下:</p></li><li><p>宿主机即为原主机，原主机可以是GNU/Linux任何发行版</p></li><li><p>对硬盘分区，添加用于安装LFS的用户和组(LFS教科书第2章)</p></li><li><p>下载所有需要的软件包源代码(LFS教科书第3章)</p></li><li><p>准备开发环境(LFS教科书第4章)</p></li><li><p>构造一个基本开发环境(称为工具链/LFS教科书第5章)</p></li><li><p>构造完整的目标系统(LFS教科书第6章)</p></li><li><p>配置系统启动脚本(LFS教科书第7章)</p></li><li><p>启动系统(LFS教科书第8章)</p></li><li><p>相关项目</p></li></ul><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><hr><ul><li><p>Building and Installing Software Packages for Linux<a href="http://www.tldp.org/HOWTO/Software-Building-HOWTO.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p>软件构建知识Software-Building-HOWTO<br><code>http://www.tldp.org/HOWTO/Software-Building-HOWTO.html</code></p></blockquote></li><li><p>Linux用户手册1<a href="http://www.linuxfromscratch.org/hints/downloads/files/essential_prereading.txt" target="_blank" rel="noopener">跳转</a></p><blockquote><p>The Linux Users’ Guide<br>The Essential Pre-Reading<br><code>http://www.linuxfromscratch.org/hints/downloads/files/essential_prereading.txt</code></p></blockquote></li><li><p>Linux用户手册2<a href="http://www.linuxhq.com/guides/LUG/guide.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>The Linux Users&#39; Guide http://www.linuxhq.com/guides/LUG/guide.html</code></p></blockquote></li><li><p>Linuxsir<a href="http://www.linuxsir.org/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxsir.org/index.html</code></p></blockquote></li><li><p>LFS-内容参考资料</p></li><li><p>作者:孙海勇(冲天飞豹)</p></li><li><p>书籍名称:手把手教你如何建立自己的Linux系统第一版以及第二版</p><blockquote><p>2008/2010</p></blockquote></li><li><p>网络有很多的URL和仓库都已经失效或废除了</p></li><li><p>以我目前拥有的水平与能力，似乎已经找不到更多的参考和资料了</p></li><li><p>即便找到也毫无意义，因为都是搜索引擎已经爬取过的数据了……</p></li></ul><hr><h3 id="FLS-1-补充内容-2"><a href="#FLS-1-补充内容-2" class="headerlink" title="FLS-1 补充内容-2"></a>FLS-1 补充内容-2</h3><p><strong>LFS目录简述与参考:</strong></p><ul><li>一阶段<blockquote><p>第0至1章节-序章与介绍<br>第2至4章节-准备工作</p></blockquote></li><li>二阶段<blockquote><p>第5章节-临时系统</p></blockquote></li><li>三阶段<blockquote><p>第6章节-目标系统</p></blockquote></li><li>四阶段<blockquote><p>第7章节-系统配置<br>第8章节-系统可导<br>第9章节-系统启动(完全抛离)<br>第10章节-最后的清理与附录(尾声)</p></blockquote></li></ul><hr><h3 id="相关内容URL整合目录补充内容"><a href="#相关内容URL整合目录补充内容" class="headerlink" title="相关内容URL整合目录补充内容"></a>相关内容URL整合目录补充内容</h3><ul><li><p>CN-Chroot<a href="https://zh.wikipedia.org/wiki/Chroot" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Chroot</code></p></blockquote></li><li><p>CN-Linux内核功能<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD</code></p></blockquote></li><li><p>CN-金步国的<code>Linux-4.4-x86_64</code>内核配置选项简介<a href="http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.jinbuguo.com/kernel/longterm-linux-kernel-options.html</code></p></blockquote></li><li><p>CN-Unix实用程序列表<a href="https://zh.wikipedia.org/wiki/Unix%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Unix%E5%AE%9E%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%88%97%E8%A1%A8</code></p></blockquote></li><li><p>EN-Linux From Scratch(Version 9.1-systemd-rc1)<a href="http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Published February 14th, 2020<br><code>http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html</code></p></blockquote></li></ul><hr><ul><li><p>EN-Index of /lfs/downloads/9.1-systemd-rc1<a href="http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/9.1-systemd-rc1/</code></p></blockquote></li><li><p>EN-Download the Linux From Scratch Book<a href="http://www.linuxfromscratch.org/lfs/download.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/download.html</code></p></blockquote></li><li><p>CN-LFS(v9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-systemd/LFS-SYSD-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/lfs-systemd/LFS-SYSD-BOOK.pdf</code></p></blockquote></li><li><p>EN-The Linux From Scratch Counter<a href="http://www.linuxfromscratch.org/cgi-bin/lfscounter.php" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/cgi-bin/lfscounter.php</code></p></blockquote></li><li><p>EN-Linux Sea<a href="http://swift.siphos.be/linux_sea/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://swift.siphos.be/linux_sea/</code></p></blockquote></li><li><p>EN-其它发行版<a href="http://www.gentoo.org/" target="_blank" rel="noopener">Gentoo</a><a href="https://www.funtoo.org/Welcome" target="_blank" rel="noopener">Funtoo</a></p><blockquote><p>Gentoo: <code>http://www.gentoo.org/</code><br>Funtoo: <code>https://www.funtoo.org/Welcome</code></p></blockquote></li></ul><hr><h3 id="LFS补充内容"><a href="#LFS补充内容" class="headerlink" title="LFS补充内容"></a>LFS补充内容</h3><ul><li><p>相关书籍列表</p></li><li><p>《Linux From Scratch》（LFS）</p></li></ul><hr><ul><li>《Beyond Linux From Scratch》（BLFS）</li><li>提供了在LFS的基础上，进一步完善Linux基本系统的指引</li><li>在BLFS中，为系统增加网络、X桌面、声音、打印机和扫描仪支持<blockquote><p>标准LFS仅仅安装了足够让系统启动的基本软件，以及使新系统能够编译新软件包的开发工具<br>BLFS包括了更多的软件包，且都有相应指导<br>从5.0版开始，BLFS开始与LFS的版本号保持同步</p></blockquote></li></ul><hr><ul><li><p>《Cross Linux from Scratch》（CLFS）</p></li><li><p>用于描述交叉编译</p></li><li><p>为需要进行交叉编译(即在一个平台上编译另一个平台的代码)的用户提供指导，正式版本为1.0，另有两个变种</p><blockquote><p>《CLFS Sysroot》 采用Sysroot的方法来进行编译，好处是软件包的编译次数可以减少，坏处是不能支持在编译后对软件进行测试，必须要启动到目标平台上才能测试<br>《CLFS Embedded》 一般用于极小系统以及嵌入式系统<br>为此，它使用uclibc而不是一般LFS使用的glibc<br>该项目已停止维护，其官网已无法访问</p></blockquote></li><li><p>《Hardened Linux From Scratch》（HLFS）</p></li><li><p>此书专注于Linux系统的安全</p><blockquote><p>这个子项目致力于打造在安全性上无懈可击的Linux系统</p></blockquote></li></ul><hr><ul><li>《Automated Linux From Scratch》（ALFS）</li><li>标准的LFS只是一本书，用户需要根据书上的指引下载软件包并手动输入指令进行编译<blockquote><p>ALFS子项目提供了把这一切自动化的脚本</p></blockquote></li></ul><hr><ul><li>Hints<blockquote><p>收集一些解释性、增强性的文档，以协助用户</p></blockquote></li></ul><hr><ul><li>LiveCD<blockquote><p>利用LFS的方法生成可以自行启动并安装了足够软件的CD<br>可以用来在空机器上安装LFS，或者直接在其上运行应用<br>已经停止维护</p></blockquote></li></ul><hr><ul><li>Patches<blockquote><p>由于软件之间的依赖关系，在升级软件包之后可能会导致LFS的过程出现故障<br>Patch项目致力于研究最新版本的软件之间的互动，并提供一些补丁修复这些故障</p></blockquote></li></ul><hr><ul><li>《Community Driven BLFS》(CBLFS)<blockquote><p>该项目实际是一个Wiki网站<br>依靠网友的自发贡献来提交各种软件包的安装方式</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>CN-中文维基<a href="https://zh.wikipedia.org/wiki/Linux_From_Scratch" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Linux_From_Scratch</code></p></blockquote></li><li><p>LFS官方网站<a href="http://www.linuxfromscratch.org/lfs/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/</code><br><code>http://www.linuxfromscratch.org/lfs/</code></p></blockquote></li></ul><hr><h3 id="相关书籍URL补充"><a href="#相关书籍URL补充" class="headerlink" title="相关书籍URL补充"></a>相关书籍URL补充</h3><hr><p><strong>ALFS</strong></p><ul><li><p>仓库<a href="http://www.linuxfromscratch.org/alfs/downloads/jhalfs/stable/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/alfs/downloads/jhalfs/stable/</code></p></blockquote></li><li><p>官网<a href="http://www.linuxfromscratch.org/alfs/download.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/alfs/download.html</code></p></blockquote></li></ul><hr><p><strong>BLFS</strong></p><ul><li><p>BLFS-v9.1<a href="http://www.linuxfromscratch.org/blfs/downloads/stable/BLFS-BOOK-9.1-nochunks.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/blfs/downloads/stable/BLFS-BOOK-9.1-nochunks.html</code></p></blockquote></li><li><p>仓库<a href="http://www.linuxfromscratch.org/blfs/downloads/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/blfs/downloads/</code></p></blockquote></li><li><p>官网<a href="http://www.linuxfromscratch.org/blfs/download.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/blfs/download.html</code></p></blockquote></li></ul><hr><p><strong>CLFS</strong></p><ul><li><p>官网<a href="https://trac.clfs.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://trac.clfs.org/</code></p></blockquote></li><li><p>下载界面<a href="https://trac.clfs.org/wiki/download" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://trac.clfs.org/wiki/download</code></p></blockquote></li></ul><p><strong>CLFS书籍获取</strong></p><ul><li><p>稳定版</p></li><li><p>CLFS 3.0.0 - Systemd</p><blockquote><p><code>$ git clone git://git.clfs.org/cross-lfs.git</code><br><code>$ cd cross-lfs</code><br><code>$ git checkout clfs-3.0.0-systemd</code></p></blockquote></li><li><p>稳定版</p></li><li><p>CLFS 3.0.0 - Sysvinit</p><blockquote><p><code>$ git clone git://git.clfs.org/cross-lfs.git</code><br><code>$ cd cross-lfs</code><br><code>$ git checkout clfs-3.0.0-sysvinit</code></p></blockquote></li></ul><hr><p><strong>其它可用参考资源:</strong></p><ul><li><p>EN-手册地址<a href="https://github.com/syl20bnr/spacemacs#linux-distros" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs#linux-distros</code></p></blockquote></li><li><p>CSDN-使用<code>.emacs.d</code>目录管理Emacs配置文件<a href="https://blog.csdn.net/gxp/article/details/6970464" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/gxp/article/details/6970464</code></p></blockquote></li><li><p>某个人博客<a href="https://bitmingw.com/2017/03/02/spacemacs-install-configuration/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://bitmingw.com/2017/03/02/spacemacs-install-configuration/</code></p></blockquote></li></ul><hr><p><strong>资源补充:</strong></p><ul><li><p>HLinuxH的ChinaUnix博客<a href="http://blog.chinaunix.net/uid-25533439-id-3286334.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://blog.chinaunix.net/uid-25533439-id-3286334.html</code></p></blockquote></li><li><p>金步国作品集<a href="http://www.jinbuguo.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.jinbuguo.com/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Zsh-1</title>
    <url>/2020/02/21/Zsh-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Shell-Zsh"><a href="#Shell-Zsh" class="headerlink" title="Shell-Zsh"></a>Shell-Zsh</h2><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh my zsh"></a>oh my zsh</h3><ul><li>配置过程</li></ul><p><strong>相关指令:</strong></p><ul><li>查看系统当前使用的shell<blockquote><p><code>$ echo $SHELL</code></p></blockquote></li></ul><hr><ul><li>查看系统支持Shell列表<blockquote><p><code>$ cat /etc/shells</code></p></blockquote></li></ul><hr><ul><li>安装zsh<blockquote><p><code>apt-get -y install zsh</code></p></blockquote></li></ul><hr><ul><li>切换shell为zsh<blockquote><p><code>$ chsh -s /bin/zsh</code></p></blockquote></li></ul><hr><ul><li>修改主题<blockquote><p><code>$ vim ~/.zshrc</code></p></blockquote></li></ul><hr><ul><li>这里将<code>ZSH_THEME</code>改成ys<blockquote><p><code>ZSH_THEME=&quot;ys&quot;</code></p></blockquote></li></ul><p>–</p><ul><li>更新配置<blockquote><p><code>$ source ~/.zshrc</code></p></blockquote></li></ul><hr><p><strong>补全插件配置:</strong></p><ul><li><p>incr.zsh补全插件下载</p><blockquote><p><code>$ wget http://mimosa-pudica.net/src/incr-0.2.zsh</code></p></blockquote></li><li><p>将此插件放到oh-my-zsh目录的插件库下:</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">$cd ~/.oh-my-zsh/plugins/<span class="keyword">incr</span></span><br><span class="line">$mkdir <span class="keyword">incr</span></span><br><span class="line"><span class="comment"># root @ debian in ~/.oh-my-zsh/plugins/incr on git:master x [15:05:07] </span></span><br><span class="line">$ ls</span><br><span class="line"><span class="keyword">incr</span><span class="number">-0.2</span>.zsh</span><br></pre></td></tr></table></figure></li><li><p>在~/.zshrc文件末尾加上</p><blockquote><p><code>emacs ~/.zshrc</code><br><code>source ~/.oh-my-zsh/plugins/incr/incr*.zsh</code></p></blockquote></li><li><p>更新配置:</p><blockquote><p><code>$ source ~/.zshrc</code></p></blockquote></li></ul><hr><p><strong>与vim的提示冲突的解决方法:</strong></p><ul><li>使用自动补全插件可能会与vim的提示功能相冲突，如会报以下错误:</li></ul><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">vim</span> t</span><br><span class="line">_argument<span class="variable">s:451</span>: _vim_file<span class="variable">s:</span> <span class="function"><span class="keyword">function</span> <span class="title">definition</span> <span class="title">file</span> <span class="title">not</span> <span class="title">found</span></span></span><br></pre></td></tr></table></figure><hr><ul><li>解决方法：将<code>~/.zcompdump*</code>删除即可<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> rm -rf ~/.zcompdump*</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">exec</span> zsh</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>获取方式(Git/Curl/Wget):</strong></p><ul><li><p>Git拉取并安装</p><blockquote><p><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code></p></blockquote></li><li><p>Curl</p><blockquote><p><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p></blockquote></li><li><p>Wget</p><blockquote><p><code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></p></blockquote></li><li><p>Git源码地址<a href="https://github.com/ohmyzsh/ohmyzsh" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/ohmyzsh/ohmyzsh</code></p></blockquote></li><li><p>Zsh主题乐园<a href="http://blog.ysmood.org/my-ys-terminal-theme/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://blog.ysmood.org/my-ys-terminal-theme/</code></p></blockquote></li></ul><hr><p><strong>参考资料(技术博客):</strong></p><ul><li><p>修改Linux的shell从默认的bash切换为zsh<a href="http://www.findme.wang/blog/detail/id/282.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.findme.wang/blog/detail/id/282.html</code></p></blockquote></li><li><p>oh-my-zsh,让你的终端从未这么爽过<a href="https://www.jianshu.com/p/d194d29e488c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/d194d29e488c</code></p></blockquote></li><li><p>写给 Pythonist 的 Spacemacs 入门指北<a href="https://www.jianshu.com/p/c5cc672aae63" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/c5cc672aae63</code></p></blockquote></li><li><p>oh-my-zsh,最好用的shell,没有之一<a href="https://www.itshutong.com/articles/281/oh-my-zsh-the-best-shell-none" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.itshutong.com/articles/281/oh-my-zsh-the-best-shell-none</code></p></blockquote></li></ul><hr><p><strong>其它内容:</strong></p><ul><li><p>Shell<a href>跳转</a></p><blockquote><p>本篇<br><code>oh my zsh</code></p></blockquote></li><li><p>编辑器<a href="http://unit-serow.com/2020/02/21/Emacs-1/#more" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>spacemacs</code></p></blockquote></li><li><p>X window<a href="http://unit-serow.com/2020/02/20/Window-1/#more" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>X.org/GNOME</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-2-2-21</title>
    <url>/2020/02/21/%E9%9A%8F%E7%AC%94-2020-2-2-21/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="023e919899f53638211f00cb3f95d6bf44b2530c9e798f6b662f6117845e06d0">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98a53eee031ea70af8be62c8533ade5d5984993ab5b3c3e500b50562c3df5c9ad7bea4ce72e7d24a3a14965504b4602b9d5e91b510c3bc4954ae2485968304243b2976098ba2e44b0253da21f78de907f78bac263eee3902974af38915312bdd3f0e482aeb70630489848226d7bff3f519602afe34daeaed24721e985eb7ae6a409e2756c3bed588c68723823e762d4a1d111c1acf5c872fcfc2b8e96bba1a28ecd7e39e43b0dc44ffc1b97d77f2d9126aface1bad4d72b3a1c2768e993d3c43f9fa62f456a9b68f034af33c824634634fa4151bcf544dadeed0d70ab3a73b3dd34e79eea666b78c3295721736044828493396d0505a17c7c8603a4570f211f4bced1fecb37bfc422164542a9bb3b5fe1a5ace06406682a37a2c0b5f6c274048a73bf857c857ccba55f1cec5442c3f75758b6c2a137834232741609015dbb9a14dd63d84d7333a7d121948f6bb48c4ef95f7bd16452347a0b8c729dbbeb04d3abd5a829ca44f1ef52b6c323313c4ab9f38cd2da1b3e8bedff2d746e47e69684a1aa786759caa70844f665b1053b2ad78c1717a35005de3e0363b31a9797066bf4d77e876a65e49726a9b641a471428ee54760e180f2af316c47e8985bb9cb5acddf3a62b85f91235688c3029b8752eb2561c0117d0b902cbc8ae428b978a6e516f45b81baa7d8671c500763d4a17da915ef888b5f78902d3ff6703aa9af1319ba8f6297a1e7d85d3452dc68ca6cf46b7440240e9fb58f39099833ce1d630dcc2b22d45148fbd71dcdc05a25f77d93a7e5a03a0d9c5beb0a90bc09f77a160bbccf36db0477dcb6224579a4ff9b891e0a71e7417dd97a0e92e5a62ab2f7f6393abc8c6e0b5ec9be3654d62fe77e127002b6a71d18c4879442b7d081b9d979c640e7d8fab3578690f71c87f7577bc950c9d7dac6c7765c13692292e8f1decdfd2aa1557406f8e23840399dcd57b9b5b90770c639b82d3ba9e6cb3380ddcd652788708267df25d7f1d7eca6a632b7695a70f8caedea4ce4e3c2c9d7ab14482ad5c03226479f21d2f2fbc514f18967f51ceaae898ef8823f4d9280cf453a5a4341304ca87c169f7098e78d2e22edc274dc0e449adef0e1a9697d0efa62bd351178e660fca0ee5a5c261aa4255e298cc247aefc6e0315353242987b85fe7ca13ebf8589fcd6673ef596431b81b2d5fb4d7dcfbfad56bf8e8726c024c4eba53ef841f96cf8dcb347ddf6251ca91996d80e525bee151a08ef68ff9ddfff7358618f9dcfd1ecceb5fbac0e1bb075ad9d56e969785a5ea078899165b92354814a1222fb8fabbdab81775a7f348864518732615332bd4ee0aff11b5856627708ad4c0f5c7f428faf1f1d2ab6a3794fcd8a77fc6557e3899cffe6870992087e082ac283b61c261a01da8763f9abf563b1d1398171345554b174cc965942331e8795ee23e6706ac408d7214a0b5ab2f2a80b07bc3f6032d8284b082d7ab2319b3bbb934f3d89fd1f002ef5568580a3fb913ce9455ce321a97f72e12eff06e6bfccca39634b1120c1e2d05cbf1e57dae63869b3ff9fd91698d883fdd4b89d6ddcbc85a1ba88b403e37d8ce08a6f53fbad5819d5c6179b44484ee27a8688f70830b15fed62195eda617446bb3d50402e0d0efdd32d92d5966cbfa6a46ba0109ff8c943ef2b55fcb25863f398dba75f923f1f64e459c4369e748cf4273d2c15f1e8141fc76643baef9a728ef322b5e7634285e29bf4be2c2864015f80efd7887f7678b7debbc8bfeb757d028d96af1fe1ccfb4a4a10f0d2b6844912ea3b22c0d9b028d6585d1426139223c13f425800856a55c2fe65aa9f440821f5793c42fe6d61d96d90e1d571dd5fee0f1516e6d9322700036d961764e5dce94a22cf69d9016e1a0f3e36876523a34d470a33f090f71999ec74987b716c9efec4d6cce712ce7ff4c24fbae523d26f0a425677365bc6ee681d137ea0360911bf14a8ecba4f6916ee86ba8552329790a5dc29a3adb606833a0b6abaa570664e9b76bc6ed556e455ea3ad5e8d9f2a915aeeeaf139b130c15e25931188eae788e16cb1079e634cbe62a4d7ebbf500c416bc7b4c3259acd8d3a4558b37753771a9bfd8eeb98ccc1de1805363c05ccdca1111dc31f11bfa71a42dd90cc7a64118826e249c52939f39dedb0151125689006373898b390fb58653809718a9180a829cdaf15c72373411d884cb4430616017fa75a12f01b5a2c7fe7d73e7799f0fe62f837ff132bca2c8de66e93d37ad2706bd816f5952673017571cbbdfda9890899870f725530700b70175a92c5b038c4084c3549dc123098ab4243a2aa408f5e3ae8ada526d8d707dbc611fbfa03ba9add5e302d8ee82c401f7c1152ec5ee202124755ea614b72908a353fc5dd4219beeb3f08c52468e86f3e3cd25352db21db2f20a1032c3effd3b9ce6f268f14c4ecd48e68d523d6d9cd7380d1f1558407dfee99bfaf5f0eacedee320fd5531a187c43154ae977460b7457c42fb4ea63f75adb395ec499e3ddd5100352b38fd617a9640ff125f8ec4dfdddcceb7ab1c38a63997edd0b076137029269760d3f34f6e5a3978cf12f06ef5a6689ab6ec9d9c1ab62780ce16887f3aeafbeac2cbd61153af1a8931033a1bcdad62ee708fe18b852a4c9123046e023efb7ffe6917dcc7442ee47b36c0b188e225e327c993c4577c49628a7695c51863308d12da4008acb457a94d3e6a08c7c89bd903127e60480ec5ead032f826b46f52e9a523561ccc6b94ce1df4d154ec69ee866919267a1d33c416def8820315a8a296614f97c640f4a5164394aa789844f4ac6d503e177b3212cfcda43dec6bb112a6f22973da1173a65330a6400ffec5755b0462a64aa34fd446c20a53d88841304a0d44b631fb46f22499e2eb2323fc99138d5329dc790cdc0e7c8416088a0cc15e220ffe40c32e76b678adc5222639404623afcab9e32e2b4e9716de24b1d8b6051630dbda0dfb9b90a91d40d7ea1064ebd65d1770857d43d7dd894b761496cd7392366602d4dd428187ba9d2bf31199ee193882789584ac4817bd9bd433b05cfa58220827ab3b536d4876ef08d02529bd5c4c33c80df65a146a32b67b00ed50404ac63c92056be0eaa8179c8c788d081ad390f2683182c81d127fb37294e3e1e7d34addf03f1c16ec38c0a37c53930909f71f07d6e759ea9698048a8b498455f635c92802e7214faac9f2d8961c205793706a7fcd38c1b08aab62b84bfc6ec8315ca7db9ff53766c74c4105a038f0f718c94e03691de2cc4c2507ac9a295483d4785ede936ca7fd718e16817f7f12aaba7bf509224823ed5c8be97f9a8fef9744924e978e88747a0d5aad82fa4f3a3309f663c4066d6bba533c6e27d94bee1fdb444c95b9b68028431b038c52056985fe0643f8e2542ba31078c5b96df89653be6df278ff2adc40bf257dd3ea4b9254e2afb3f9b160a1fbad9ce9c0a85550937ac4ad10e836cedb1128e9ba1305f3576e2baf84555c5d76516f714ceb889cdf2e71119092cae3db6b498b66b41e95f8c7431456d1fdb6633ba62ca22aa57b2d60d74628e487eaef7481aa50b341cfa141c90b570dd976fd18b8d6ba82f0189c0f2a31b4244db28a26f85ea9f1562d8e9ceb59455d43ae0462150ee6c9bd2b350b3b31f0c60e39906364c19492ab1ab5628307973d0d87d78ebefc26b75e33ec3e73ce50b502688bca90e4d0a90ad7774c3cc65e2ed8f850c8359fc20d88152b2db714fbaf43d4dc571eba45e8690eefd80e176c2dace1b1c5db4a200092b6b82ad26e0c9600b5693e8d0dcbc0f83dde43b877bfdfa3d0e52aa633523b7c5e894522bf69ddfa8c59c7ddefb3efe21d3eba218c5463b87301bcba13d2cceb7b5d637fddd1f30e92efa28d5367435f6f957cb8b342892b7dadd55e684d419efdc00624d27a1cfa7f1f94cbaaacac5f4b981287710ba1fac3b67e927b005da1802a1c3c9645026d8f7d92f0ffee33225f44344c1babd46806865acf6e33f7f75d0af7205ddef549cd9aa24c6bdb9b89d58f05a826b8c00e7951e64779a8b9d91e6c08de17c6ee63ade8e9d3632ba6106f187af628633b454aaf1f6e4c8ab51161d1f78f7059620b54d225637a00b17092976759aff0a8d388543d84a826d9ad908c61769d5c4d4b7224b5fe779416768b782e8b195c3a6fbe7e579d992b5f24949462142d82203991c9637035e56e76ed8f4ab6368776d2615c36b45e36f733d38c0bf3ebb4ac8117995cb5b04e6fee9e28de16cf84d092b1a78de572512be934e26e4481095f14406a83a5867b9e4bc74b5eed5006b6c8818780fb5715b1083723269f40243c63ca227298fd9925c7bceed2a560b7994aa63f415da56863233ba9c50d0c28982b912877f677b211d220fca78ab78199d0bff08f1f7a7acc47b6d4372f28b908353541b22752f592bd7928b9ed7b75b5662c102778988cdc4545dcd944f53a30fc0f7c18287be9bda142653099218c7de6ae6ea3dae9fa1fbbf9928827ea1ecbcce477da15f92549ac576b52dba1642f0b3cf39f85de047aa9a2657207af13e706fe395bb7f37ef5b21542b245cc359c552aca739de490ef5daf4318af77c22b509924d809d2e3d88592704f3adc210033b7c37da80edb964f15d23b2ec69ec45291c79e979f1b9bbf0164a3d5220b9f07e12265fda4cf8d8ed4e27fb070a7ba8387c650fb6c313396e917d9d39a84bfe23d9b5c466394aadfb08a60b86c33584f6d4d828a436deb56aec0d6866e2c6832b247aef4cea7ecf4d34cda58e58826cb7347082bafab94c2dc4322494f5a364873eeb47786eab3eea7f123d9bc878d22b2e7637668fcaa1967863161660caa7feb7ad0464922d6ba8775153b96398d52186405161e5b89fa5537b050670da4fc88da71c474cdffea42fbe3fae4484b0d35701fcfbf5801b70c9e26aafd61920908d9d426e4be1518296c5e6a827b8e36a472403f262b311bdd6efb2a54b6a10be35a0c813c55624a46541b802674b28006d775b6902eb28b385e0e261a968ecbcdb6adc7f32eaa8825cdadab8b44a35af7ddc6f2b37f404cd5698e4b3dd7af09782936c2f9c5ae0da8ee1e4c5513be024213d89aa35d833f88a6665a0ad73533329548c4abedb55ed35b78f2a7a89751d4c2e2cfc2cb155cf80c4c3366a439f0c2314d7d7fd8bb0d45c4f77d9a2f03116c980f17048a85c4fc152205ee4c5d66d975ba9673fabd0b582d1d3ee398e9757b41d6d73f059a8c06b71bba841eca31b3177348f9f2bd03cb4707692834c3f129743a82c558dc912c3fc0979e5972afe750359fa51b8977e71bf83b9d39953b8e4af9133cd5f489ede9d74d8e915cda27d2bef1b5a6396471a6ec58bc4546f8037fb8f84941eb68c1661c6405ccb628df2a9ca05557429ee0b5b30db92fa431429c00974174e82db0cb66378e561b658dd4782115b7fd0d1732d4ab67c3ea9c995a892a483020fe37d105d31c5f4cae7c562c04eb5c77c7b6b1c7f232f15d7b9c78925efbb533886de1faa2f68424b1abe43d25a9ecd86f7a4a26b36bcd098f63dc7be0704d8848a2c21c0d6f525aa8e8f7700450c1d743d8e344b3c82b71f44d7cdaadbcd709791b36d882dc5b65f0f66f70515ff1a215455c3533f15f959f1d3f28f77d5633bf52fe856da1c6d1aa5dcb0aa77281b04e4ee1fd16d90c3b40085d653eb62e9a6047064baa87a07cc6d955ecc307ab799412f421b05262dcdd8ea9f6c60e65f310745170548b916dc9b545cc112d74c15a18b8458db9476bfe8e0584cd6071dd991fbbaeb4853138a9c55218055f208f0a8a47270d41b112b58ca113d08ff5665684e0ab791a841f81db7d98496017ad41865f44b07ee7612b9124dff0e2a127cd17bb1677fffd516e08fb914b5dc7cfe83a21b29ac1d81d5ca1b2d46dffda28719a0cefc04efc632790f8f54ad5bfbe5baef948776850b60b1fddc0dab2fa59808d11809954ade8b989d05a76087c7e33047c42b83ff0d42e4539ec29793d36c3ccc952a1c720638a68ba22e8a496d674dabfac246fb456ea7e1b2022c2de8875a51d9243c44398612885c88c087b60f5fb8425c7b6df4458d64e86f790a145fb23400600cd72b3854d644f503e52a3a19a38df9a58703f9f8f713836b2f261173fea8cf984c63eda2ed7a480feea2e7a9ab3c3a83f68d17f7858271162270689be5dce33d91fd2fb512b06d35813ce2e08966a8dc8b49b65cf4f5a37cbbf72a50fa4de2a50e2ea966e304aab0a4a9d7192eb238e33f6de51b156898363f138d26eb3810afb105d07708a6ed3ea6eb1ff993236e20a920a14f2fb537b3cb24a7c47dacb96e27db4453ae4744a552c91144eed52e9001c682e0f9cc38eb4e07a2bc6ef401142a14e776ba56baba679dc4e541faadf1387bcc2607c9c2ce08bcb06b84a927995e3675e04581294d4da09d3e4216b1d4ae091240bd5f7c45d62f6e27c36b30fc9e3baaffa92d1d11d003ed21a540bbfbac2c9c8a6cb06151b18a3634035f7c16df4c4cc3b7bcb616903331fc0036fd19d4e091640ba70f328db9dc6349466f05c94dce45a1b388ee741799b19640207e32ca4f4ffc3db2b7378ed8d5a0d5b54a172bd3fa594bdd158455171368e639a80d83001402030</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Emacs-1</title>
    <url>/2020/02/21/Emacs-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Emacs-1"><a href="#Emacs-1" class="headerlink" title="Emacs-1"></a>Emacs-1</h2><h3 id="Emacs快捷键快速参考-参考资料整理"><a href="#Emacs快捷键快速参考-参考资料整理" class="headerlink" title="Emacs快捷键快速参考(参考资料整理)"></a>Emacs快捷键快速参考(参考资料整理)</h3><p><strong>基本快捷键(常用且泛用):</strong></p><ul><li>C/M/De说明:<blockquote><p>C(Control/Ctrl)<br>M(Meta/Alt|Esc)<br>De(Backspace)</p></blockquote></li></ul><table><thead><tr><th align="left">指令</th><th align="left">作用</th><th align="left">摘要</th></tr></thead><tbody><tr><td align="left">C-x C-s</td><td align="left">保存文件</td><td align="left">保存</td></tr><tr><td align="left">C-x C-w</td><td align="left">使用其他文件名另存为文件</td><td align="left">另存为</td></tr><tr><td align="left">C-x C-f</td><td align="left">“find”文件, 即在缓冲区打开/新建一个文件</td><td align="left">新建</td></tr><tr><td align="left">C-z</td><td align="left">挂起emacs</td><td align="left">挂起</td></tr><tr><td align="left">C-x C-c</td><td align="left">关闭emacs</td><td align="left">关闭</td></tr><tr><td align="left">C-x i</td><td align="left">在当前光标处插入文件</td><td align="left">插入</td></tr><tr><td align="left">C-x C-v</td><td align="left">关闭当前缓冲区文件并打开新文件</td><td align="left">关闭缓冲区</td></tr><tr><td align="left">C-x b</td><td align="left">新建/切换缓冲区</td><td align="left">新建缓冲区</td></tr><tr><td align="left">C-x C-b</td><td align="left">显示缓冲区列表</td><td align="left">缓冲区信息</td></tr><tr><td align="left">C-x k</td><td align="left">关闭当前缓冲区</td><td align="left">关闭缓冲区</td></tr><tr><td align="left">M-n</td><td align="left">重复执行后一个命令n次</td><td align="left">宏</td></tr><tr><td align="left">C-d</td><td align="left">删除(delete)后一个字符</td><td align="left">删除字符</td></tr><tr><td align="left">M-d</td><td align="left">删除后一个单词</td><td align="left">删除字符串</td></tr><tr><td align="left">C-k</td><td align="left">移除(kill)一行</td><td align="left">删除行</td></tr><tr><td align="left">C-g</td><td align="left">停止当前运行/输入的命令</td><td align="left">停止</td></tr><tr><td align="left">C-x u</td><td align="left">撤销前一个命令</td><td align="left">撤销</td></tr><tr><td align="left">C-s</td><td align="left">向后搜索</td><td align="left">搜索</td></tr><tr><td align="left">C-r</td><td align="left">向前搜索</td><td align="left">搜索</td></tr><tr><td align="left">M-x shell</td><td align="left">打开shell模式</td><td align="left">shell</td></tr></tbody></table><hr><p><strong>帮助指令:</strong></p><table><thead><tr><th align="left">指令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">C-h c</td><td align="left">显示快捷键绑定的命令</td></tr><tr><td align="left">C-h k</td><td align="left">显示快捷键绑定的命令和它的作用</td></tr><tr><td align="left">C-h l</td><td align="left">显示最后100个键入的内容</td></tr><tr><td align="left">C-h w</td><td align="left">显示命令被绑定到哪些快捷键上</td></tr><tr><td align="left">C-h f</td><td align="left">显示函数的功能</td></tr><tr><td align="left">C-h v</td><td align="left">显示变量的含义和值</td></tr><tr><td align="left">C-h b</td><td align="left">显示当前缓冲区所有可用的快捷键</td></tr><tr><td align="left">C-h t</td><td align="left">打开emacs教程</td></tr><tr><td align="left">C-h i</td><td align="left">打开info阅读器</td></tr><tr><td align="left">C-h C-f</td><td align="left">显示emacs FAQ</td></tr><tr><td align="left">C-h p</td><td align="left">显示本机Elisp包的信息</td></tr></tbody></table><hr><h3 id="其它"><a href="#其它" class="headerlink" title="其它:"></a>其它:</h3><p><strong>指令集类型一共可以分为七种类型(具体可参考参考资料):</strong></p><ol><li>基本快捷键(Basic)</li><li>光标移动基本快捷键(Basic Movement)</li><li>编辑(Editint)</li><li>重要快捷键(Important)</li><li>在线帮助(Online-Help)</li><li>搜索/替换(Seach/Replace)</li><li>使用正则表达式(Regular expression)搜索/替换</li><li>窗口命令(Window Commands)</li><li>书签命令(Bookmark commands)</li><li>Text</li><li>Telnet</li><li>DIRectory EDitor (dired)</li><li>Shell</li><li>宏命令(Macro-commands)</li><li>编程(Programming)</li><li>GDB(调试器)</li><li>版本控制(Version Control)</li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>官方网站<a href="https://www.gnu.org/software/emacs/emacs.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/emacs.html</code></p></blockquote></li><li><p>官方手册<a href="https://www.gnu.org/software/emacs/manual/html_mono/emacs.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/emacs.html</code></p></blockquote></li><li><p>Emacs Lisp<a href="https://www.gnu.org/software/emacs/manual/html_mono/elisp.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/elisp.html</code></p></blockquote></li><li><p>获取地址:<a href="https://www.gnu.org/software/emacs/download.html#gnu-linux" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/emacs/download.html#gnu-linux</code></p></blockquote></li><li><p>国内社区<a href="https://emacs-china.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://emacs-china.org/</code></p></blockquote></li><li><p>apt-get获取</p><blockquote><p><code>apt-get -y install emacs</code><br>插件和拓展的配置与安装本章节不会多做赘述</p></blockquote></li><li><p>spacemacs仓库/获取地址<a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs</code></p></blockquote></li><li><p>spacemacs获取方式</p><blockquote><p><code>git clone https://github.com/syl20bnr/spacemacs ~/.emacs.d</code></p></blockquote></li></ul><hr><p><strong>其它指令参考网站:</strong></p><ul><li><p>CN-2015-Emacs常用基本快捷键<a href="https://gist.github.com/shijinkui/2048195" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://gist.github.com/shijinkui/2048195</code></p></blockquote></li><li><p>CN-2008-Emacs快捷键列表<a href="https://aifreedom.com/technology/112" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://aifreedom.com/technology/112</code><br>这个相当详细</p></blockquote></li><li><p>CN-2019-Emacs常用快捷键一览<a href="https://qiutedyuan.github.io/blog/2019/06/12/Emacs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%80%E8%A7%88/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://qiutedyuan.github.io/blog/2019/06/12/Emacs%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%B8%80%E8%A7%88/</code></p></blockquote></li></ul><hr><p><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></p><p><a href="https://www.google.com/" target="_blank" rel="noopener">https://www.google.com/</a></p><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><ul><li>2020-02-21<blockquote><p>20.46</p></blockquote></li></ul><hr><h3 id="Spacemacs"><a href="#Spacemacs" class="headerlink" title="Spacemacs"></a>Spacemacs</h3><p><strong>spacemacs参考资料</strong></p><ul><li><p>其它功能拓展与插件</p></li><li><p>代码补全</p><blockquote><p>自动补全 (company mode)</p></blockquote></li><li><p>语法高亮</p><blockquote><p>语法高亮 (Org-mode)</p></blockquote></li><li><p>其它工具</p><blockquote><p>major mode<br>minor mode</p></blockquote></li><li><p>编程/编译环境</p></li><li><p>在已经可以确定安装完成emacs之后，从Github仓库拉取spacemacs拓展</p><blockquote><p><code>git clone --recursive https://github.com/syl20bnr/spacemacs ~/.emacs.d</code></p></blockquote></li></ul><hr><p><strong>参考文献:</strong></p><ul><li><p>中文社区<a href="https://emacs-china.org/c/spacemacs" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://emacs-china.org/c/spacemacs</code></p></blockquote></li><li><p>EN-文档<a href="https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org</code></p></blockquote></li><li><p>代码仓库<a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="noopener">跳转</a></p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/syl20bnr/</span>spacemacs</span><br><span class="line">https:<span class="regexp">//gi</span>thub.com<span class="regexp">/syl20bnr/</span>spacemacs.git</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>EN-Wiki<a href="https://en.wikipedia.org/wiki/Spacemacs" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://en.wikipedia.org/wiki/Spacemacs</code></p></blockquote></li><li><p>技术博客子龙山人</p><blockquote><p><code>https://zilongshanren.com/</code></p></blockquote></li><li><p>CSND某博客<a href="https://blog.csdn.net/csfreebird/article/details/52744771" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/csfreebird/article/details/52744771</code></p></blockquote></li></ul><hr><p><strong>可参考资源补充:</strong></p><ul><li><p>EN-手册地址<a href="https://github.com/syl20bnr/spacemacs#linux-distros" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs#linux-distros</code></p></blockquote></li><li><p>CSDN-使用<code>.emacs.d</code>目录管理Emacs配置文件<a href="https://blog.csdn.net/gxp/article/details/6970464" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/gxp/article/details/6970464</code></p></blockquote></li><li><p>某个人博客<a href="https://bitmingw.com/2017/03/02/spacemacs-install-configuration/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://bitmingw.com/2017/03/02/spacemacs-install-configuration/</code></p></blockquote></li></ul><hr><h3 id="相关工具整理"><a href="#相关工具整理" class="headerlink" title="相关工具整理:"></a>相关工具整理:</h3><ul><li><p>zsh</p><blockquote><p>Z shell(Zsh)是一款可用作交互式登录的shell及脚本编写的命令解释器<br>Zsh对Bourne shell做出了大量改进，同时加入了Bash、ksh及tcsh的某些功能<br>实现工具: <code>oh-my-zsh</code></p></blockquote></li><li><p>参考网站:<a href="https://www.jianshu.com/p/d194d29e488c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/d194d29e488c</code></p></blockquote></li><li><p>Python管理工具</p><blockquote><p>pyenv<br>pyenv virtualenv</p></blockquote></li><li><p>其它工具</p><blockquote><p>nvm<br>npm</p></blockquote></li></ul><hr><h3 id="补充内容-spacemacs-1"><a href="#补充内容-spacemacs-1" class="headerlink" title="补充内容(spacemacs)-1:"></a>补充内容(spacemacs)-1:</h3><p><strong>spacemacs基本操作简述</strong></p><ul><li><p>spacemacs只是一份emacs的配置文件</p></li><li><p>通常只需要把克隆来的spacemacs放到<code>~/</code>目录下就可以直接启动与初始化了</p></li><li><p>以下为emacs匹配不到spacemacs的配置文件的解决方法:</p></li><li><p>先将原<code>~/.emacs.d</code>文件进行备份与移动，将由Git工具克隆来的文件下载到<code>~/</code>目录下(当前用户的根目录，默认非root)</p></li><li><p>再指定emacs启动文件的用户所有权(这里将emacs的启动文件的执行权交给了root)</p><blockquote><p><code>chown root:root emcas.d</code></p></blockquote></li><li><p>启动emacs编辑器时，加载指定用户的初始化文件(这里用root用户来初始化emcas启动文件)</p><blockquote><p><code>emacs -u root</code></p></blockquote></li><li><p>其它基本说明:</p><blockquote><p>更新emacs配置，并重新加载emacs(.emacs.d)配置文件<br>备份并移动<code>~/.emacs</code>文件，并且拥有<code>~/.emacs.d</code>的执行所有权<br><code>~/.emacs.d/init.el</code>为emacs的启动脚本，任何关于emacs的配置都在这里进行<br><code>~/.emacs</code>为启动文件<br><code>~/.emacs.d</code>为启动配置文件<br>现在通常只有下者了</p></blockquote></li><li><p>还有其它的解决办法</p><blockquote><p>初始化emacs程序(将其卸载并重新安装)<br>保证emacs第一次启动的启动脚本的配置是spacemacs应该也可以</p></blockquote></li></ul><hr><p><strong>相关资料归纳:</strong></p><ul><li><p>CN-Spacemacs 使用总结<a href="https://scarletsky.github.io/2016/01/22/spacemacs-usage/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://scarletsky.github.io/2016/01/22/spacemacs-usage/</code></p></blockquote></li><li><p>CN-Emacs学习(1)<a href="https://www.jianshu.com/p/a7b8d1659b9b" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/a7b8d1659b9b</code></p></blockquote></li><li><p>CN-15分钟学会Emacs Lisp (v0.2a)<a href="https://learnxinyminutes.com/docs/zh-cn/elisp-cn/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://learnxinyminutes.com/docs/zh-cn/elisp-cn/</code></p></blockquote></li><li><p>EN-Learn X in Y minutes(x分钟速成y技术)<a href="https://learnxinyminutes.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://learnxinyminutes.com/</code></p></blockquote></li><li><p>CN-Spacemacs入门与基本用法<a href="https://ifun.dev/post/spacemacs_usage/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://ifun.dev/post/spacemacs_usage/</code></p></blockquote></li><li><p>CN-emacs指令说明<a href="https://wangchujiang.com/linux-command/c/emacs.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://wangchujiang.com/linux-command/c/emacs.html</code></p></blockquote></li></ul><hr><p><strong>spacemacs基本配置</strong></p><ul><li><p>配置Magit，用于辅助并集成Git进行远端版本管理</p></li><li><p>EditorConfig</p><blockquote><p>维护工具<br>让不同的编译器和IDE都按照相同的格式来格式化代码</p></blockquote></li><li><p>org-mode</p><blockquote><p>代码自动补全</p></blockquote></li></ul><hr><p><strong>相关参考(URL归纳目录):</strong></p><ul><li><p>CN-emacs自动补全<a href="https://blog.csdn.net/hengrjgc/article/details/43231327" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/hengrjgc/article/details/43231327</code></p></blockquote></li><li><p>CN-Spacemacs 与 Org-mode 配置与使用技巧<a href="https://www.douban.com/note/706407786/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.douban.com/note/706407786/</code></p></blockquote></li><li><p>CN-spacemacs 与 org-mode 配置与使用技巧 <a href="http://mpwang.github.io/2019/02/06/productivity/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://mpwang.github.io/2019/02/06/productivity/</code></p></blockquote></li><li><p>CN-十个高效的spacemacs配置<a href="http://www.mamicode.com/info-detail-636363.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.mamicode.com/info-detail-636363.html</code></p></blockquote></li><li><p>CN-Spacemacs 使用总结<a href="https://scarletsky.github.io/2016/01/22/spacemacs-usage/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://scarletsky.github.io/2016/01/22/spacemacs-usage/</code></p></blockquote></li><li><p>spacemacs 中文教程<a href="http://www.voidcn.com/search/bopuqg" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.voidcn.com/search/bopuqg</code></p></blockquote></li><li><p>官方文档<a href="https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org</code></p></blockquote></li><li><p>Vim User<a href="https://github.com/syl20bnr/spacemacs/blob/master/doc/DOCUMENTATION.org" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/syl20bnr/spacemacs/blob/master/doc/VIMUSERS.org</code></p></blockquote></li></ul><hr><h3 id="补充内容-Spacemacs-2"><a href="#补充内容-Spacemacs-2" class="headerlink" title="补充内容(Spacemacs)-2"></a>补充内容(Spacemacs)-2</h3><p><strong>spacemacs配置相关:</strong></p><ul><li><p>在<code>~/.spacemacs</code>中的<code>dotspacemacs-additional-packages</code>内添加所需配置以使spacemacs支持所选服务</p></li><li><p>Layer</p><blockquote><p>spacemacs为依赖与拓展的管理提供了独有layer(分层)机制<br>使其已被配置且各个不同类别的插件在保证独立性的同时还大幅的简化了对插件或拓展的管理与操作难度<br>Layer基于Lisp编写与配置</p></blockquote></li><li><p>Package</p><blockquote><p>是spacemacs默认的独立包管理器<code>SPC-T-s</code>启用package</p></blockquote></li><li><p>Evil</p><blockquote><p>它能够为spacemacs提供vim的操作格式，为默认选项</p></blockquote></li></ul><hr><p><strong>可用URL参考:</strong></p><ul><li><p>CN-Spacemacs 的配置<a href="https://www.cnblogs.com/yangwen0228/p/10193245.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/yangwen0228/p/10193245.html</code></p></blockquote></li><li><p>CN-视频参考<a href="https://youtu.be/MBrU-Py3HaA?list=PL-61yFRAEMlUMOtAeoYErz2yLe9IeTKRS" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://youtu.be/MBrU-Py3HaA?list=PL-61yFRAEMlUMOtAeoYErz2yLe9IeTKRS</code></p></blockquote></li><li><p>CN-Spacemacs使用中的FAQ<a href="https://www.jianshu.com/p/354896569a90" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/354896569a90</code></p></blockquote></li><li><p>CN-某博客Spacemacs<a href="https://wayslog.com/2017/06/30/spacemacs/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://wayslog.com/2017/06/30/spacemacs/</code></p></blockquote></li><li><p>CN-spacemacs配置自己的layers<a href="https://www.jianshu.com/p/bdd64fecddce" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/bdd64fecddce</code></p></blockquote></li></ul><hr><p><strong>关键字:</strong></p><ul><li>layer</li><li>package</li><li>Evil</li></ul><hr><h3 id="补充内容-Spacemacs-3"><a href="#补充内容-Spacemacs-3" class="headerlink" title="补充内容(Spacemacs)-3"></a>补充内容(Spacemacs)-3</h3><p><strong>自动补全功能实现:</strong></p><ul><li><p>Org-mode</p><blockquote><p>Org-模式(Org-mode)是文本编辑软件Emacs的一种支持内容分级显示的编辑模式<br>这种模式支持写<code>to-do</code>列表，日志管理，做笔记，做工程计划或者写网页<br>意思就是大体作用类似于markdown<br>参考自: <a href="https://www.cnblogs.com/qlwy/archive/2012/06/15/2551034.html#sec-1" target="_blank" rel="noopener">https://www.cnblogs.com/qlwy/archive/2012/06/15/2551034.html#sec-1</a><br>参考自: <a href="https://baike.baidu.com/item/org-mode/3339684?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/org-mode/3339684?fr=aladdin</a></p></blockquote></li><li><p>spacemacs安装与配置<a href="https://baike.baidu.com/item/org-mode/3339684?fr=aladdin" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.fidding.me/article/12</code></p></blockquote></li></ul><hr><p><strong>Emacs/Spacemacs自动补全</strong></p><ul><li>最基本需要用到以下插件(layer)中的自动补全支持</li><li>在<code>dotspacemacs-configuration-layers</code>里面新增所需layer<blockquote><p>auto-complete 自动弹窗<br>yasnippet 自动补全<br>popup 自动弹窗<br>company 自动补全<br>lsp-mode 自动补全<br>Django 自动补全<br>anaconda-mode(python)自动补全</p></blockquote></li><li>这里的例子就举这么多，实际上数不胜数</li></ul><hr><ul><li>配置文件<blockquote><p>auto-complete.el<br>popup.el</p></blockquote></li></ul><hr><p><strong>可用URL参考目录:</strong></p><ul><li><p>emacs 自动补全<a href="https://blog.csdn.net/promanz/article/details/89384129?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/promanz/article/details/89384129?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>Emacs-107-开启全局自动补全模式<a href="https://blog.csdn.net/grey_csdn/article/details/79477169?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/grey_csdn/article/details/79477169?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>Emacs基本配置，自动补全<a href="https://blog.csdn.net/hengrjgc/article/details/43231327?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/hengrjgc/article/details/43231327?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>emacs代码补全插件介绍<a href="https://blog.csdn.net/topgun_chenlingyun/article/details/9447755?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/topgun_chenlingyun/article/details/9447755?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>EMACS下弹出窗口式的Auto-Complete自动补全工具简单介绍<a href="https://blog.csdn.net/hahazhouzhiqin/article/details/9735347" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/hahazhouzhiqin/article/details/9735347</code></p></blockquote></li><li><p>Emacs-015-自动补全插件company的安装与使用<a href="https://blog.csdn.net/grey_csdn/article/details/78966457" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/grey_csdn/article/details/78966457</code></p></blockquote></li><li><p>spacemacs安装与配置<a href="http://www.fidding.me/article/12" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.fidding.me/article/12</code></p></blockquote></li></ul><hr><h2 id="spacemacs配置简述"><a href="#spacemacs配置简述" class="headerlink" title="spacemacs配置简述"></a>spacemacs配置简述</h2><ul><li>从网络上下载的扩展包被放置于<code>~/.emacs.d/elpa</code>文件夹下</li><li><code>~/.spacemacs</code>为spacemacs配置文件</li></ul><p><strong>配置文件内常见(常用)参数简述:</strong></p><ul><li><code>dotspacemacs-configuration-layers</code>是启用的layer列表</li><li>初始列举的layer大多被双引号注释掉了，注释符号为<code>;;</code></li><li>其中的themes-megapack用于下载各类皮肤，dotspacemacs-themes用于设置皮肤</li><li><code>dotspacemacs-editing-style</code>是默认编辑模式</li><li><code>evil mode</code>默认的对应值为<code>&#39;vim</code></li><li><code>dotspacemacs-maximized-at-startup</code>在启动时自动最大化窗口，可以将值设为<code>t</code>以开启此功能</li><li><code>dotspacemacs-line-numbers</code>设置是否显示行号，<code>nil</code>隐藏，<code>t</code>显示</li><li><code>dotspacemacs-whitespace-cleanup</code>删除多余的空白，推荐设置为’trailing`</li><li><code>spacemacs</code>的灵魂:<code>auto-completion</code>(自动完成)和<code>heml</code></li><li><code>dotspacemacs-additional-packages&#39;(web-mode)添加</code>web-mode<code>，同时也是在</code>dotspacemacs-additional-packages`里面添加包的基本格式</li><li><code>dotspacemacs-elpa-https nil</code>用于https检测，可设为<code>nil</code></li></ul><hr><p><strong>可自定义选项参考:</strong></p><ul><li><p>user-init()选项内修改自定义配置</p></li><li><p>(add-hook ‘after-init-hook ‘global-company-mode) 激活自动补全</p></li><li><p>默认配置</p><figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">setq-default</span></span><br><span class="line"></span><br><span class="line">   dotspacemacs-themes '(monokai)<span class="comment">;;设置主题</span></span><br><span class="line"></span><br><span class="line">   dotspacemacs-fullscreen-use-non-native <span class="literal">t</span>   <span class="comment">;;设置最大化不占用系统导航栏</span></span><br><span class="line">   dotspacemacs-maximized-at-startup <span class="literal">t</span>   <span class="comment">;;设置窗口启动最大化</span></span><br><span class="line">   dotspacemacs-line-numbers <span class="literal">t</span>   <span class="comment">;;开启行号</span></span><br><span class="line">   dotspacemacs-auto-resume-layouts <span class="literal">t</span> <span class="comment">;;重启后自动打开关闭前alyout</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>参考自: <a href="https://bitmingw.github.io/2017/03/02/spacemacs-install-configuration/" target="_blank" rel="noopener">https://bitmingw.github.io/2017/03/02/spacemacs-install-configuration/</a></li><li>皮肤网站: <a href="https://themegallery.robdor.com/" target="_blank" rel="noopener">https://themegallery.robdor.com/</a></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-02-21</title>
    <url>/2020/02/21/%E9%9A%8F%E7%AC%94-2020-02-21/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="c536a915806535840955264731e01ce9e383c9a75d79930ccd557331e8f3f9ad">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546eebb84e514277c32fb4c68e0c68a19f75de57006ef73cd25b4cad6cca2b7fb98e60010a04b79eb1f3ebd257c85a3e46cde719fe9b9cc4e7291089863ee86cefc2c2bb8c7726517f4ab98031d50ac43cbc08d5f5b2807d48f8f2cd030ccb015cb13f89f49c2968ae079e3709cc8e9b280f1b249383b7f5428f6b359f89a8d8a3f7e3bebd8cb32d6a54d6ef9094ff7fc8bc621e96266bf703566dae77c185eb1c0cd5ec88bfb78f0ec51f7dd072f517384fb1cdf336fccbb20e7161a3430a9b62cdae512ece154c6f9a05f8b2a9536897fbd027c099e0680804f804e6a3289934a58e6b43e93741cd2348d605e5afe0facad9de9eca38779a5fc60d0dd71fdc292b3fa4ab27ce7ded9484d1baf5f72b13f52863872b45017b3f32f47f29f4760d5a7039a3f342ec61ee2ea1f2fdb957b26a5d00b756aa3745b885d33d27d0bbbe1d12b97ebaa9f81d33fe732b70575c772dd51fbacd62a6b62fe6c099dd226c2e325c220b82fea4ba30e5b080ea379a06bf88ebca36f0bf55c10d5b2b29b5b2b56a7ef5bca1caff6163ff38618f24f6ec2492029fb3c65a1da25ad5b48e5aee15279d5d00daa0e7dd5e58808fc65680ff0795de4c7bc3e973cf6cd4006d3e077b76f7c83a2bd273c78c7d84f6d0b78acd187ac0f59f8ab70a4bb1e527686861ffac45cea1b65412e879b0155b88bbe6904d4d02af77bb8d886a17ea7f9a96e3038d69a2cf1d2abfc841bc839e125c3376407638a532b655f44e833ec38d45cee1ee4e4edc024dadc262deda4597ec0cc123a8976e6ae7ad4ab4b0c241680fe297df7ab359af734d15fa60a66a399745ce590ce1b05a2bef2ff34045196cff1046bde28a6960c353b6a96bf53474d28e86eac7e0e91a9f4b55b3e237125da87b0b1cb6e025f49ed70dbd6b9aaab5a796c4393a56037f6544c09f218528ad7e406c68e2f5796961793b82ffecd798fd2a441d3f54214a2ca2b696cd00a3d8296f2faf803d218bede3d4061264a821fd21221a5b770891a678062c350f66bd1d225862e4bf228478501e6ca5b08ccadd372a5b62e9fe4d9b9f40f8a1af72f3e5e99964ea202dbe18c242f8151ac983a24af014ccdf13523f885f238888b5d4d99a9bad000e4f180f9a8823930ac3eb271dc042c26e97b8eaf2951246790596e33a183306d0356ffe5e1488757a74ebeb3a5d823c5bea382503a3d7b087f141fbcf1d9eea5f20bfb76ff8868793171d97af53ab40d35f8ab15c26f7b4931c90007920ce00b93befe6373a23e907716b4e7498a444a40b61ef4995280c8963b7ecbd075d9707077e8d86b6c8214337b9cb5ad8e1301e620a2cd83d131efc8f4a779cca8b247f8364aa21713607415b5ce2547062ba3cc861c7b36d3b4a4c38b9b43fda21cc214cbfe9299b826bac78ef643c4767a9132105e29ea66b04543125ffb89c8f6988f9b069f4e25a40c05ae85a922efa703197d80d87547bea51c1f12d6f548006acd86f66b40697bf3e1ce8d0e80b6d82ac4ffe5526bcee8e2c9bef2ee956149cc6a9fea4e399d5ee036c4d0f19536dcb4bd95c9f6966323980f67e9450cda03e1e901a4382ddae7286328254620856be3ce2c03946863c6d8205d94f00649b15bcd948563409b5597d3f5a8fad80d36f4c903cff9b1229cf1dfe9ec48c5653254f3e51d4c64404d91cc4585581f9fb9f830d6a291833bf33bff0113fd3e7d071da490faab69fdc5c3bf99f35e8631b33ce531c5789e67ced35b8687ddddf04728cf6187b9d4437d40d077b0af93c67b30e48244f8891b29671003669d29c09397494152209f37f0389bc0831444dcd8d5849136f8bb95973358d33a14011f1d5e59ee48e9cfde737b17c6c74aa2c9ccf0b78b715e32d7d3ffe09affe43a56cf604708d75c8c17bb981d9105bd11d1fdd34120a5b930cf1ba8165e9f66b2f293d3f503ad2f5cecb1563f998e4254b531cbde083d894dde995856167fe20f9b14c40d4b8f502f4be6a94d143c4ae0f971a4b1c76dc2e13ad7f0e5f3d4ee13b56951e689e88cfb2f1a6a88083f31a5f0422e52fa208526a07dc923d9fb401d721fecd7f7fb699737dcdd9f92284eee1b34517413dadd30ba79f1c4cd63b9da5e43061fe8ae8b21bf8f3cbcb2f0152ff04c0cdf7ef62a298d84ce918e2b7fff1ff8c164b065abcd1c780aa424bc43a12a723e4a59085fb24cfbcf08d326b5c67b8e08fcfa50c562a725d1cae17766796620cfcf07479c5a50421965e3b4a3e46914e98425265d7612e23291851b19b8dd9240a0e5720ee87171bdc2c84c2f4edea84853baf311656a379d3ecc5d4714cc0f0789ffc705aa3171dd737126310fdc0522031e0bb79aa0cbff3a623acf9582b8775ced553092995f8053081bbbf36cd7b4b9eb839c8f1ef2d3be0f8a6a0f60ee5aec537579c4e076f6c280efadeb443b758b1599dcc02c1865d474f015848f23a51e94b1c007ce21eb6dbfbc7e457ad556ac3de4b62b7ba1ced647a8b252fafcd8c9bbe77d7022747356d480f5d9dffae43060d91756f7247796b1547dbd939a1a537f992c80970d3369cdaf7cd4306f20d371f82ec95c6dc0adaef2cbe9f54421a149e7b344d71db499ebe13fa771bd9faea6fd9cebe7897f000803dc6f7fd00d385a0fc9bcd3bcc647dc3ccefeceab37821e747f78b6656d18d8477dbcac4e00e8585ae36015052395b2837b7a10dd2b240c235b48339eeea6c70a54d8a029c047949d574efc77655ddec71088dcd050f4022565e424337ff48b72224de16f5c73e2e28bc76a544ec3551b0050027c291bdb26de262bc7fe395dbb777706935d8efcadc73c32a281ebb85ae772715b7495f58756ea785cf2ea8958266b3343ac066aeaa0f753e68cbd85d76b13909ca06d264a18cf027d124321f3a012fcbd3d60bfe318d2d9dff2260cdf3cb3546768820129eefeadde3c18e9ead42f93da7bae6bfd0b5dcf6b6adefb71ec72d954e0a55c577767f7d1d2ea79dc8183a32998beb19444985d6b48cea706f745700cc01948adf7751dbcf3992c6c46febdd1079c93d8c7a1186442cd4cfdf2b02fa5adc2dfb73daaaab5b618ccb6a5e9ba2ff0e4e870227cce5acbc8eb66c8f0bbbc8a557a1ce0f5e914ffa52978abe5f654a3ad26703771c1ed7730c6af3353c17051d085b1d5816ef3ac4faa0e53c85b81094351b5a162c21b2299e9c6020a5aaf9dae69ac978a1cee39d8e090fff277aed6bab6967b978515e318ddf62a0ebe75dca2c1985c288793ffba45981e70b57793269e9736dd2e9b1568312f2ed1563ab34dfdc5790b28de04d3b704fbc7fb1e7fc03879eabce2ca0b30c6131bf5a6b4a28336568ffb040d50b6106a98f8a93989984ec99885ebd4c0efe7b28f68b6d5ccf8f92892bafa05700a74bbc1bdfd3706cd6af0ceeca3601998587dfde4c0ad4eba244a408f9a1088385df1852be3dbfade7257d1a902a97f89d3d7bd82a370fd4639bbd3b07849d1c0159228f7ae6c34440da4c7966944397511f546292f3dbe4cee0ec1de1bd1fc3b139811902867fe001043c64b00d25b980c7a5124786556f727d5f03365a864d3dba21a8f9388e318a4b320da95245076ada7caff6f8f6f7753f2dbeeac8a1b3c00a0bab206a50b543612d4502c56bd1afc2d95f1c71aa587bdea9515c1272a239612768c489f05e77907e1736210379f26eab4dcef19315ee57fdeda46db23a3412f57897ae398875ee2f3e88ec543a7d697cf40f3906ebfba377ca32a422cd2b8e1f4940d53a6b0410d54ec1fe2e56c582e3f464c062053f40ab57b0a32670e99cef69797c476ea5ce120fdad751d679cf9792974e40847b382a45f543a90aed6e39ef1dd4455169a27dee579361b8e29171da4bb3fca23d5f54cbfa8dc64004db49c830a420a3b29ab652162918b463f9633de2c69c559354370f0c8bc1d3d8394fbb4483fac6db87a983a6569abb8209ccd3afa8937c813d6c4894efcc21701413032ebb34c68332bf4730065e6ac5e91e3f797bff2dbffc77ca3d570dc12b1a0144b514</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>X Window-1</title>
    <url>/2020/02/20/Window-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="X-Window-System"><a href="#X-Window-System" class="headerlink" title="X Window System"></a>X Window System</h3><p><strong>概述:</strong></p><ul><li>X 窗口系统，别称/X11/X</li><li>X以位图方式显示的软件窗口系统</li><li>X能为GUI环境提供基本的框架</li><li>X只是工具包及架构规范，本身并无实际参与运作的实体，所以必须有人依据此标准进行开发撰写<blockquote><p>X只是一个协议(protocal)，这个协议定义一个系统成品所必需具备的功能<br>任何系统能满足此协议及符合Ｘ协会其他的规范，便可称为X</p></blockquote></li><li>标准实现体:X.Org(显示服务器)，XFree86(显示服务器)</li><li>GNOME(显示管理器)和KDE(显示管理器)是以X11窗口系统为基础建构成的</li><li>X的标准实现是X.Org的参考实现</li><li>基于MIT许可证授权</li></ul><hr><ul><li>最初是1984年麻省理工学院的研究，之后变成UNIX、类UNIX、以及OpenVMS等操作系统所一致适用的标准化软件工具包及显示架构的运作协议</li><li>最新的参考实现(参考性、示范性的实现体)版本则是X11 Release 7.7(简称：X11R7.7)，时间为2012年6月6日</li></ul><hr><p><strong>X的C/S模型</strong></p><ul><li>X采用C/S的架构模型(Client/Server)<blockquote><p>X的一大特点:网络透明性<br>应用程序(“客户端”应用程序)所运行的机器，不一定是用户本地的机器(显示的”服务器”)<br>X中所提及的”客户端”和”服务器”等字眼用词也经常与人们一般想定的相反<br>“服务器”反而是在用户本地端的自有机器上运行，而非是在远程的另一部机器上运行</p></blockquote></li></ul><hr><p><strong>网络透明性</strong></p><ul><li>服务器和客户端之间的通信协议的运作对计算机网络是透明的<blockquote><p>客户端和服务器可以在同一台计算机上，也可以不是，或许其架构和操作系统也不同，但都能运行<br>客户机和服务器还能够使用安全连接在互联网上安全地通讯</p></blockquote></li></ul><hr><p><strong>X Terminal</strong></p><ul><li>X Terminal(X 终端机)</li><li>作为仅运行X服务器的<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>瘦客户端(Thin Client)的作用硬件</li><li>该架构广泛用于为了使多人同时使用同一个大型服务器而构造终端</li><li>X终端搜索网络，使用XDMCP产生允许其运行客户机的主机列表</li><li>初始主机需要运行X显示管理器</li><li>专用的X终端机硬件已经于上个世纪被淘汰了</li><li>在1990年初期也被称为”穷人的UNIX工作站”</li></ul><hr><h3 id="安装显示服务器-显示管理器-X-org-XFree86-GNOME-Xface"><a href="#安装显示服务器-显示管理器-X-org-XFree86-GNOME-Xface" class="headerlink" title="安装显示服务器/显示管理器(X.org/XFree86-GNOME/Xface)"></a>安装显示服务器/显示管理器(X.org/XFree86-GNOME/Xface)</h3><ul><li>X11</li><li>apt源推荐(非必要)<blockquote><p><code>$emacs /etc/apt/sources.list</code><br><code>deb http://mirrors.geekbone.org/debian/ sid main contrib non-free</code><br><code>deb-src http://mirrors.geekbone.org/debian/ sid main contrib non-free</code></p></blockquote></li></ul><hr><blockquote><p><code>deb http://debian.cn99.com/debian/ sid main contrib non-free</code><br><code>deb-src http://debian.cn99.com/debian/ sid main contrib non-free</code><br><code>deb http://debian.okey.net/debian-uo/ sid java marillat rareware misc</code></p></blockquote><hr><ul><li><p>安装依赖项以及<code>X.org/GNOME</code></p><blockquote><p><code>apt-get -y install xbase-clients</code><br><code>apt-get -y install x-window-system-core</code><br><code>apt-get -y install xfonts-base</code>或<code>apt-get -y install xfonts*</code> (xfs为字体服务器)<br><code>apt-get -y install xserver-xorg*</code><br><code>apt-get -y install fvwm2</code><br><code>apt-get -y install menu</code><br><code>apt-get -y install gnome-core (gnome安装，以gnome为窗口管理器)</code><br><code>apt-get -y install gdm*</code><br><code>apt-get -y install xscreensaver-gnome</code>或<code>apt-get -y install xscreensaver*</code><br><code>&#39;*&#39;</code>为UNIX内标准通配符之一</p></blockquote></li><li><p>其它(XFCE4/XFREE86)</p><blockquote><p><code>apt-get -y install xfce4</code><br><code>apt-get -y install xserver-xfree86</code><br><code>dpkg-reconfigure xserver-xfree86 (重新配置)</code><br><code>apt-get -y install mozilla-firefox (浏览器安装)</code></p></blockquote></li><li><p>参数<code>-y</code>假定对所有的询问选是，不提示</p></li><li><p>可以选择是否添加(安装)中文补丁(一般安装系统的时候就会选择)</p></li><li><p>启动执行startx命令</p></li><li><p>便捷安装:</p><blockquote><p><code>apt-get -y install X Windows System*</code><br><code>apt-get -y install GNOME*</code></p></blockquote></li><li><p>音量错误解决方法</p><blockquote><p><code>apt-get install alsa-base</code><br><code>apt-get install alsa-utils</code></p></blockquote></li></ul><hr><h3 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念:"></a>其它概念:</h3><ul><li>X Window所关系的概念非常庞大，以至于包含整个UNIX体系的图形化界面的历史与技术</li></ul><p><strong>包含于:</strong></p><blockquote><p>X Window 架构<br>X Window 拓展<br>X Window 显示服务器<br>X Window 显示管理器<br>X Window 会话管理器<br>X Window 窗口管理器(合成/平铺/堆叠)<br>X Window 标准<br>X Window 应用程序<br>X Window 桌面环境</p></blockquote><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>X.org官方网站<a href="https://www.x.org/wiki/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.x.org/wiki/</code></p></blockquote></li><li><p>X.org官方文档<a href="https://www.x.org/wiki/Documentation/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.x.org/wiki/Documentation/</code></p></blockquote></li><li><p>X.org镜像源<a href="https://www.x.org/wiki/Releases/Download/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.x.org/wiki/Releases/Download/</code></p></blockquote></li><li><p>X.org获取地址<a href="https://www.x.org/releases/individual/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.x.org/releases/individual/</code></p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li><p>能下载的就下载，即便缺斤少两也不妨碍大体运行</p></li><li><p>补充安装方法</p><blockquote><p><code>$ apt-get install xserver-xorg</code><br><code>$ apt-get install x-window-system-core</code><br><code>$ dpkg-reconfigure xserver-xorg</code><br><code>$ apt-get install gnome-core</code><br><code>$ apt-get install gdm xscreensaver</code><br><code>$ apt-get install ttf-arphic*</code></p></blockquote></li><li><p>yum体系参考: <a href="https://www.jianshu.com/p/88ae1c2becd6" target="_blank" rel="noopener">https://www.jianshu.com/p/88ae1c2becd6</a></p></li><li><p>最好是添加个输入法fcitx</p></li></ul><p><strong>字体配置:</strong></p><ul><li><p>字体配置相关</p></li><li><p>terminator内字体显示出现错误(终端字符重叠问题)</p></li><li><p>locale相关</p></li><li><p>安装完字体之后重启终端</p></li><li><p>安装字体(<code>ttf-wqy-zenhei</code>在默认的<code>apt-get</code>仓库内可能没有):</p><blockquote><p><code>$ apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy</code><br><code>$ apt-get install ttf-wqy-microhei xfonts-wqy</code></p></blockquote></li><li><p>参考: <a href="https://blog.csdn.net/magaiou/article/details/80322396" target="_blank" rel="noopener">https://blog.csdn.net/magaiou/article/details/80322396</a></p></li><li><p>参考: <a href="http://www.legendsec.org/1534.html" target="_blank" rel="noopener">http://www.legendsec.org/1534.html</a></p></li></ul><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">指的是在客户端-服务器网络体系中的一个基本无需应用程序的计算哑终端</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>X Window</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-02-19</title>
    <url>/2020/02/19/%E9%9A%8F%E7%AC%94-2020-02-19/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="9a076385c1d6dd57edea9dff46e32bec0187740ab5a4b8c0d4f98ea0c7991966">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98abf761c1c475f025b5a39480d919b796c750b8a9d6700b79ea5e71977e25c69f16fbf8bbe7a6eaacb81f376d232bf0b92341a2587f077a3faea3fa71fd5afd55af2eeb23efa49a3b66096bddfc53bc47d060fb1a189ff03beeae57ee93121f008b87896595d327b373a431edf2d0c5ea789eccfd2e88bdefd453f88acf79046004eb68f5799e3fcb421895540f94aea22e9a163e81c5b63735b0c03ab5d5b6bf3e3100bd0f101054c248987ef33f9bb536d8f0c84741a766703fab9ea0e1205946ddd6094450f7a84afce597c145e3ace81d2946382772a2cf885ce717cc68ec369ae8d803a97752e958070a0614fbf8c01123a06dbd07092df3785a2b2da62ed4a03bdc03430ca7c6b982648a3df8b572abdb6e037d89ebed3ce56279abef296ecb65a3b0e4f6345e85a62d694d6ad1973437cf4657eec2b7da429285bc5a21e2be253600827faf5720a43c25ffa4cddd6fb97fd4db96495c4d2fcb679aa562d12ac1a46f36ec4535c726288e637f8afd900ebb8c2c6f44dadf2b6e324be76e35fcf32a8dce50abf846c4e7913ff72ec5071b8d508670c52941d78daec8b9907846a9e31a7c336c98c06cbf8973e64d05a9d696aeb369616d7e6de8ea241f8648ff014681f839a580b86cbeaeed340bfb2d2c44d890bd45992492f2925ab7f58e8c07ba7da9e532e6a168a2e99e7687965123adec7a4efd9e79e5e0ca9b9e487e55670c1e4ad97509985396b765cdee2b6df0e74239c32433ad2f6384ffb7b7ed255708bb17d750a63e20753f52917abc25c38c197ffc0ac216de01f88521b28b903faafb972c914ebcc7f3ee9cd7ba795f4a46e65da2caeebc9fb965aa3dd124b3d6e391a2e70231a0defefeb4e503c77983629fe3f46701674c8321ae670e5c5179bb6f00922f5f7582ba7eba04e823e082faaed9d9cdb7063c3b979e369d54144cab2bcd8912cf61042b77bc86a7662d8f39a66207894038185bfaa37817cb43706d032f34b2fabe21516c9556da5b2a191c746121f3ae48fec58bde0d07c14a1b948d1686cdae10b45d093138352a99f53240546b68e73bd83f84c7d66496785e770ff63ed7529df630c217368bb8334cf2e58185f696956597d55778fa0c90548cbf6b12c4ee6a5cb2bd8152c5d6a93301d6c68334672dc8c1f436ef908f093e6f2dea634d5bd55430a88c76bfaf6a7b390ab954a2ad52b6de9a99021440487ada622a7cf7c6b9db29c19a0769fd1e65225136155b788f170e2a9cf5ffe2c22b31ac7f9708a9c75293fc4313ec7bce724e8bb9f9554d1e56bc10c09e48a56b8f9d984c09cc1bf1b517235a82da5e5ecaabcfc4e08dc31f144da9080c6d23f365a59230e63ba5b74b9dfe234039f2eeca83d86ac6736d3d9464bedf8c1d0d79163227d8ea1bacdd2fd6abeefade28f4a60ca19461058f45743ccbd5c05ebb5b689c3454e0ff0fac15cd8ba34f367681ab348ab7176d88bd4fc0cbe38e3810e5abb6d15c7bb67b8891cfd13825069195ede3a58c612d2f284cd8577d380726cf257ac8082dfcd7a11720565f03a179d8a41801bf4c375488bda3d508efee546e04e044fee20bf518a798793256b93979a71965b4243488236c0e3dc556522adf5a07192638c0946d5ed14db5e19fa64d15dcf126346ef550c8ff870e595a3c5854b021ad89fc9916f0125352171b6fd38cd61f2a3b1f23f3d062f54b6823bfca21993584fa3afd8aa97bc65d244a5c1cbbf61a5439917ba0e44f0766fbfd24eca5fef2fd3f6e89bbe7b114664fb95e49f84d52107d960ba95744a5c82f0ec3e94eb6d117d33a5e991cb25e0b5896d4ba061847bd3b1a0f216f19d739a5b9b2054ea44f97e550dca4291296d4ee03e16a0a87fab121273764ddb54b89450a4b1ed3d0cd645e948315b121350bff75b21d7937a53cd45baffdbeb3d87f260897292c9d27570c3052642f5c2281f80cf1b7230355982de445af326242fb8fa9c58a11229d7c70f4e221c6c1f5acd7ae05b5c55b338b64c566da47ff4cf2581250f19282a2b90d885f8ff83316ede1b4f3054dbb516cc88442b13368bfcd06cf31a8dbe5c8dfc5a79abeecc4dd4b6aba7176158c820882df1e10cf0330c79a3e0fd0a6de91d81b6c61d15937db2bef43eaf225814f185e154c25a475e95563a3d31e9382aefe0789d3463d8cd51295a54c2c6f89c0a00d9c7d7faba861293660dcbb97fe49bee1022307bb580848b9d2d6c7667e6b4ea91154a35168cc19d14ab65cbc2f1099b8dc2332c2f24cfb438a6819160eb899574ca0c0a18ef0ea6a6b4fcb8d871f498499538e84ed85ba4e798d2e40394dfccd5f2700f1f54d846786b601565bafbe906df4f08a53be525d8e77ba3b344e271b0a52fee7ff57512e95320e791af65811e5ab2ef75bd1e2deb73c46b60118f9349fde51ee8b345d7c5b4e1260e80d38efcb0d16a27acf22865f538a3c40c9dbfba5fc31b4954a8506b7f54c64a44ac1f9ab75c3a67eff3bfa3c6a7abfd02a0398721a4589a68225366e0805e6ea8d2058f13ca0377145a3de904a2ab87a8df386d21cad6ceb1daf885159aa9aee1647ee153651753d48bcb23ae4511913667314404b26250d89d18c3237d21bd49cb82173c634b5f201261c2227231ccfca7e458261f9a3c5d21c41768204f14aef4c2a537a52ae92d3abf144a37270d7180e23f1c3c4c1a9d67cc378f164ae1a742e125a46a39f2694c3810bdce0b52723dc250221d7794baa1a19114362b2955af00e2b31ed9677215aa6fcb9fdc6ffd7b9c45a2ab3f2a16008e5a67d4aaf4cae34c32c13c16b0118bda1460c4caff8d09441eb29fca51a62ab6b976cb8a36288e7d8bb2f0389d9dce553fbbf728c4625b5ec9b847376674ffd6e9db114ba8d88ad3d0f525ac59558602933df53dac8ee4ef4c3428b90411ef5fa2ef38f9c6ba8241a2ae032cb4125078f6e30ed30e1039138ed98807facbb891ef90b464ae93a8f60fc6a915742255b3c4167470a26cc848d77c4d469b3e64a55d25f27c2690765ae68cd31eeccb606e0e13d7af66c9a3f66b498f92ab8dcf2194e2f85ff15680ffe6e13b3520760d305deed9c7ca48bda5dab7326674bd229b02a36e125d2eec88a8afc303e8bdc8ae7a7639cbbe87d3e4b4d7b6fea0a837968c8043fd35d1ebde29405feb94537f30ffc50bf3b34b96e7138b9042794be56cc7060a11d4b00287cc3da65cca61edf0d906ddc6c13d27b3a5d51e7bb12b045a13cb1db8df240ff95067d7312e527a0723a3430a2cadf2d7ea0490fa248c4a6847a3916e4bbdeacf1b58ae04feee1b813e97db9472f3903bb6f9a3a1c711ffa59b26f9200c08dfe2e5c7d1db99cd853bd445176a67c6285321a488d849450b23b5973f67f5bc2f4536127a31fe221e1f9ea4294fc19251a5131f4266a931e9df30c2f25c13338f2f9d2416aef3900c14541f5e0d786c7d81033d4f555d688da7fb1dd5c20653e912d2eb031a7c40ac83034ab9754b0abb6558e1538f0490711a4f4ce66bad259480f34d73d1350e4aef1802268dfa7a025e0abb88b86ee7573723d11408988d39ab51f7e41a32c16bd5b1dd82ef713f54b8b2863a761453ecbadcf34992e5aef91e85fe9d550a4baf70482b3ba6126975ab8fd1eb897e84b6d75f943ffe2778ba6a4c93ef3109d4c5dda2f256363f4f45aebbaa5c09f6b0b6445003ff3457f54c82936eaa7ac5bbbde9ebfe1cf300c0901284dc13bc106db01bc04bbcaaa5d8f490e4de6e4ea12cb6e32ce6ca83ebc9c09e682b050e06b5030b5d9356c574b9ccc75825fda50eeb733dc3f44603416bb7b46ac2f85ea30ed2daa7f363b81e9d61d676f645c8039d6032f42c6a011723decd787b8d114580251507a5753017888a6c5015a6f0708274baefbaabf599a3a44fc5f9bcc687571bcdb42dc33a7060e5cded7ed84effeaccdb186e907b63221a18c384ad3ea2f44d60a866763d0363ed13a017596302fafc71581d8c5f24f13ae7c5c414c77577925f5899b250d9f8bee51c716d23b4e72477bfd688e17f5ee64378e198912a4036cb0d936c2e468cacbceb6c6ecd35c223c96f1d336463b9811684e19482c8b6477599f7f28632abc78195e3fdf53e739c3bc33cc2db3412f603913799021e398fc9c50349b876305fab2093ca227102cdc5cb7699761489e7936947030c8f08e782b14995399c93e87c177c8c02f7e9b57429b34870ff40531e720cd43b439dec629e6250d9a80389f1a21ebdad65fde717756cc6219bc72ab3a6661a9c32d71ddbecd6498ce2c373aa7d63b881e563d415d1f7cec6ddbfc9baa135faea699ee59582416a4990823d7573c877aa2d2ca823de637d881d6fa954fedc8879b1cf9af191eee32c8d0e043d529b2da31c9584dd6dc4639da885607075c5b7a52abf54b02ceff2ad581376111cdb26c3d7b7057e77b54fe5e6f5cb2238aca0500be2e604992c74fe23c37aae3eab3c4f5ab1ef44fc8877a75e248725ed218858023875af5c4393118d6162d74f995268a69ce1284df4d43a6d6ae3a4217ba2bf86aac98926980fb02dfe4c9da34c9b365a5ffdbf06a30ed531dd8582584af3bcded6ae0e1f40dec3dfeb2c980c65835f8298cf71f8b76717c2b2717dad4e9e6d6b755930c48844fe555447a9bbfb4812b689dd0517fa5031767a9dd17ced7ad1ee18f3e457a8fde9f4216341f9c5829412aef49bf453a7f521e4e3b0e74da0b110843cdbcd6cfd86276f37edecab309e3cc45527465d86591cb2619bad0a03a71c3c47ec03c4eb7003991fb8cbd0c3cc734c94cae07d5c16846a19253e7785410442bdde98fc15bc930ef6355bf56ae04b1e44331740d6b095c98b61bbaf65ca3d566696e028b48051d4f46b1ace3bac6efe37e21bca9528a281b1dea75fb9ab47bf3a21e545a54bdf8e195420556f6a09cb9349414c570a38f7834c78a1b6c8adcf1dfc2c5e36f51ee52b19e1933f8e70dad6427755401db03b015a8cdca4a845531d3c71bdcd070ca7daa34bc7439bea9cdd7a84e061e475cf138658ec9f3f61819d60f22fd68a59d93297f41558298625b1c3d46e05149038ae24fad31428ac46557385037c65dd430fd01abacf5c53dd34ee798a5cfa839dc11a60baaeb6d3ce32c29f4290449ac175784a075f516faab89d21743f270f7005eabb1e3f1d8f9573b586bd7a3e7b698bdc419e62fcad4919f2d80026b6a8e71f82c044e5ce287d5bacb7d6a07f6fecfacb2315694281c78f63a03f0607109a83360691fdf62443776e955bc29a50f3d1c68ec44c230678135475af01e94c0628a35af26762c99992dc0ccd8ee2c36810bc0b10ee9dae10d04d3197db5563bb965982014dd2ed00c6ab0ec8b7d33581724e2f67ed4046da3dcade29c3dd65783eae4ca37bbacf24f0eaef626052aa4d29df8a83060a5b3987e3d8d9e201ed133d0be8bfe20047a4faef8ef8f6ce4ea00eeb3d47ef85fd89dd35a2f0daa70cdc80a1df8185e1f5825adf832e8bbea436806f3818c2eba1367425a1b6c3cb9c19fa59b71a8f02779545f8e6116d5210fc00410c799b8505299c0ec2dc440341ebbaaa45d52eb1114721cbd8a41785cfa78f48cc3f0c427fa15909c386159bca01807573dd1bb763cdda1aa94026269e3ecb9af321cebb4872492d3493dbde7ebf252c8d9d1ccfc78433a1f4b855d8e2d5078996b2ca592067008211c71d6d7b2f3ec56939e11f3edbb8dcf571aaf57d8f8f607fd3fe3ba11630c964a3e113d18c97b191d0b808363ebac48b100dfa6a952ac8ae2e409fe2aacdbcf913cb1978f479f1948ea369efd62ee64f00a91864f6bba38306b2b69b560eae4cc1e089a014a53ea860b09c95232d8d279ce25c21ac7ef620d894069443d4be48726f6ae89240f3004620d84b7652b9b1e626e3915d889890e1999b8afff7c1e704d496b4d9cd9059ff357f63e4057f48ce0bd189ca80ba912f91ac908d0f0961fd223e77d9142716d13b223d756d5efb960def022d33e138eca9662bfc1d7c55eae01a44475a78b21f7c99cfffebab5eb0b1f8b3a6ee3a081b40bd7007420a907a96eea6c95f88631aff0aec4843c97585e7dabf56a50ef347913592739f86ed25e51819d47c4b2a5a280d53ecb49dd545e6609051fb9475f9f2dd4feac37a36f8023ca9d351b1367f9e6f68da162abc1d30d31081b585d46f1c5919e3c616bfce21cc90fff68a2ac68f341207272d569d581148aa4082637d5b9059ddc78f8bc694d854c715d74e0ff6da801fbc43739c4f8019e0f7bc3b3ce9701879500d5109e61e175d6654ff8032d6d9cf527abb0cc574a63144ed2f2b9088be15e02386f1ee4bb5e757af2d1070977a8c8a235865c979ddb1fe3a6f6d1b643fc5bad6cfa72e056b809d0c150a34ee6b1ad5988a768526a859ad8ee3bd6388a6a6c0ec45cbfc2a5c4bc938f719d5f9a85c0d51eb6ad65ab9f9fc6921cdf9ec29f84fe72ff2554ff16ed6860c49d3c46d3dab31683128645b021054d7dc93808871692aee6eb7f25a70e08de6f08e9880db045d38fd14ad6ed65a02fbd5e388598d245493d68762b09cc465ba7bc2fb93259527f3940d54483cac4e862a7890d7263b31caccaeb66e61f1baf6134e7029d29e16ddc80f23bbfe3422b46736343abb11c7b42451f5e06ec6b8fccb21215d16fe3490d7fdb26f4fd66b0492757797a5674e071419b34c3c74e6b3138f551cbf7a7d8815e187bc49ad3ca4fe8d251ae0200a0945978448cb17f7300001f73048c420a3242e506032b35d74f706e65d0341fa6ac01352d2f3fdeddd01a8a3e76b96ac73d52f0ac6719bd2439f62746ac25f74361251c6ede6409d76fd7bf4a68260032d3efaeee58ab8da0cf93123af2f596a44d6e5e2b1b6337568da7998f9dc40dc574d0ff8800d045abb5e10f0cef76ce23326f5f6e2056f2df8073458943f5f0eb4ff2cc6a5927836244d282abb40ef3a44afce30964c56d0811406b1c66cf7f3fae411c190fe16318060cc1c29462f3bb8a61d3b2c9c337826949b7a054fea1b4a6886c70dd45a553dfca40b3cf811d2b924fd2b18b700941d19b2eafe22edf59fa43170e9fae4edf238851609ea519530962c0d6abc5d288cead148d1a86824bb55262a9f07afa9c0f50c12dc65d277f5e24140353d84508650e1f9d04c40edf54b39e6819771ad438101c58d568e81b9191fe6e24d00bee3871e8bf0a172d950f7ab5e49f795789e2a91bb64a10d98828c2a34d55e5d7d155fd3da9d8eed09f1b100f5bfb44513b4c49f71f386d90ef089b01f8e5c3c28df222eaf15cb0b36fc3589dfb9221af375c10d303aad763e4fb7861ac307e58925e4c943e90cccc2f313806e99ca2be5c77dc31d145e16a7cf4e73cf3ba722c580602d0983beca20e5a99bab2d89cd8fd643ac5409aff5e8c8dc89e0a9c2ba89feafcd87cce179455f5b944c233b7165369946876984ab20add1c1bb0f4e0d162fb6cb8a7158f546a1e2</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-3</title>
    <url>/2020/02/19/SQL-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="SQL-1-SQL2-补充内容"><a href="#SQL-1-SQL2-补充内容" class="headerlink" title="SQL-1/SQL2 补充内容"></a>SQL-1/SQL2 补充内容</h3><p><strong>增/删/改/查(SQL涉及概念补充):</strong></p><ul><li><p>增/改</p><blockquote><p>序列(AUTO INCREMENT)<br>插入(INSERT INTO)<br>更新(UPDATE)<br>创建(CREATE)<br>修改与创建(ALTER)</p></blockquote></li><li><p>查</p><blockquote><p>唯一值(DISTINCT)<br>条件(逻辑)语句(WHERE/LIKE/AND&amp;OR/IN/BETWEEN)<br>排序(ORDER BY)<br>限制返回数量(TOP,LIMIT,ROWNUM)</p></blockquote></li><li><p>删</p><blockquote><p>DELETE<br>DROP</p></blockquote></li></ul><hr><p><strong>通用概念总览:</strong></p><ul><li>通配符</li><li>通用数据类型</li><li>DB 数据类型</li><li>别名(AS)</li><li>视图(VIEW)</li><li>日期(DATES)</li><li>索引(INDEX)</li><li>合并(UNION)</li><li>NULL(NULL值，NULL函数，NULL约束)</li><li>复制(SELECT INTO/INSERT INTO SELECT)</li><li>连接(JOIN/(INNER,LEFT,RIGHT,OUTER,FULL))</li><li>约束(Constraints(NOT NULL/UNIQUE/PRIMARY KEY/FOREIGN KEY/CHECK/DEFAULT))</li><li>函数(聚合函数/其它函数)</li></ul><hr><p><strong>JDBC</strong></p><ul><li>JDBC API允许用户访问任何形式的表格数据，尤其是存储在关系数据库中的数据</li><li>执行流程:</li></ul><ol><li>连接数据源，如：数据库</li><li>为数据库传递查询和更新指令</li><li>处理数据库响应并返回的结果</li></ol><hr><p><strong>ODBC</strong></p><ul><li>开放数据库互连(Open DataBase Connectivity)</li><li>是微软公司开放服务结构(WOSA，Windows Open Services Architecture)中有关数据库的一个组成部分</li><li>它建立了一组规范，并提供了一组对数据库访问的标准API(应用程序编程接口)</li><li>这些API利用SQL来完成其大部分任务</li><li>ODBC本身也提供了对SQL语言的支持，用户可以直接将SQL语句送给ODBC</li></ul><hr><p><strong>PowerBuilder/PB</strong></p><ul><li>是美国Sybase公司研制的一种新型，快速开发工具，结构为C/S(客户机/服务器结构)</li><li>是基于Windows3.x、Windows95和WindowsNT的一个集成化开发工具</li><li>它包含一个直观的图形界面和可扩展的面向对象的编程语言PowerScript，提供与当前流行的大型数据库的接口，并通过ODBC与单机数据库相连</li></ul><hr><p><strong>PL/SQL</strong></p><ul><li>ORACLE客户端连接器</li></ul><p><strong>CYNOSDB</strong></p><ul><li>云数据库(Cynosdb)</li></ul><hr><h3 id="Oracle-PL-SQL"><a href="#Oracle-PL-SQL" class="headerlink" title="Oracle-PL/SQL"></a>Oracle-PL/SQL</h3><ul><li>客户端与连接工具</li></ul><p><strong>解释:</strong></p><ul><li>Oracle Database Software Express Edition 精简版</li><li>Oracle Database Software Enterprise Edition 企业版</li></ul><hr><p><strong>参考资料:</strong></p><p><strong>客户端(Client):</strong></p><ul><li><p>安装指南<a href="https://docs.oracle.com/en/database/oracle/oracle-database/18/xeinl/lot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.oracle.com/en/database/oracle/oracle-database/18/xeinl/lot.html</code></p></blockquote></li><li><p>文档/手册<a href="https://docs.oracle.com/en/database/oracle/oracle-database/18/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><a href="https://docs.oracle.com/en/database/oracle/oracle-database/" target="_blank" rel="noopener">https://docs.oracle.com/en/database/oracle/oracle-database/</a><br><code>https://docs.oracle.com/en/database/oracle/oracle-database/18/index.html</code></p></blockquote></li><li><p>EN-文献资料<a href="https://docs.oracle.com/en/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.oracle.com/en/</code></p></blockquote></li><li><p>获取地址<a href="https://www.oracle.com/database/technologies/oracle-database-software-downloads.html#19c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.oracle.com/database/technologies/oracle-database-software-downloads.html#19c</code></p></blockquote></li><li><p>官方网站<a href="https://www.oracle.com/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.oracle.com/index.html</code></p></blockquote></li><li><p>CN-文档<a href="https://www.oracle.com/technetwork/cn/indexes/documentation/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.oracle.com/technetwork/cn/indexes/documentation/index.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite-3</title>
    <url>/2020/02/19/SQLite-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="SQLite-3"><a href="#SQLite-3" class="headerlink" title="SQLite-3"></a>SQLite-3</h3><p><strong>概述:</strong></p><ul><li>是遵守ACID的RDBMS(关系数据库管理系统)<blockquote><p>因为SQLite遵守了ACID，所以实现了大多数SQL标准<br>ACID(原子性,一致性,隔离性和持久性)</p></blockquote></li><li>它使用动态的、弱类型的SQL语法</li><li>它作为嵌入式数据库，是应用程序，如网页浏览器，在本地/客户端存储数据的常见选择</li><li>与其它DBMS(数据库管理系统)不同的特点<blockquote><p>SQLite不是一个C/S(客户端/服务器结构)的数据库引擎，而是被集成在用户程序中<br>它有许多程序设计语言的语言绑定</p></blockquote></li><li>虽然遵守了ACID，但还有以下未解决的问题<blockquote><p>仅部分支持触发器<br>ALTER TABLE功能有所限制，不能修改或删除列，只能通过重新创建表的方式迂回进行<br>参考局限性内容</p></blockquote></li></ul><hr><ul><li>sqlite3的独立程序用来查询和管理SQLite数据库文件<blockquote><p>SQLite的用户可以把这个程序当作如何写SQLite应用程序的示例</p></blockquote></li><li>支持且拥有多种语言接口(C/C++,Tcl,PHP,Java等等)</li><li>SQLite通常小于600KB</li></ul><hr><h3 id="SQLite特点"><a href="#SQLite特点" class="headerlink" title="SQLite特点"></a>SQLite特点</h3><ul><li>完全不需要一个单独的服务器进程或操作的系统(无服务器的)</li><li>SQLite 不需要配置，即不需要安装或管理</li><li>一套完整的SQLite数据库是存储在一个单一的跨平台的磁盘文件</li><li>SQLite非常小的，是轻量级的，完全配置时小于400KiB，省略可选功能配置时小于250KiB</li><li>SQLite能够自给自足的，即不需要任何外部的依赖</li><li>SQLite事务完全兼容 ACID，允许从多个进程或线程安全访问</li><li>SQLite支持SQL92(SQL2)标准的大多数查询语言的功能</li><li>SQLite使用ANSI-C 编写，并提供了大量简单和易于使用的 API</li><li>SQLite兼容于UNIX，UNIX-Like(Linux, Mac OS-X, Android, iOS)和Windows(Win32, WinCE, WinRT)</li><li>SQLite拥有一套完整的与Shell交互的指令集</li></ul><hr><h3 id="SQLite安装"><a href="#SQLite安装" class="headerlink" title="SQLite安装"></a>SQLite安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget https://www.sqlite.org/download.html/sqlite-autoconf-3310100.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xvzf sqlite-autoconf-3310100.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> sqlite-autoconf-3310100</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./configure --prefix=/usr/<span class="built_in">local</span>(安装目录所在路径，/usr/<span class="built_in">local</span>为用户环境变量)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure><hr><h3 id="第三方GUI类插件"><a href="#第三方GUI类插件" class="headerlink" title="第三方GUI类插件"></a>第三方GUI类插件</h3><ul><li>SQLite拥有多种管理客户端，用以为SQLite提供GUI</li><li>Navicat for SQLite是一套专为SQLite设计的强大数据库管理及开发工具<blockquote><p>它可以用于任何版本2或3的SQLite数据库，并支持大部分SQLite的功能，包括触发器，索引，查看等</p></blockquote></li><li>SQLiteMan，使用Qt开发的一个SQLite客户端，支持多语言、跨平台</li><li>Firefox，可以通过添加部分扩展获得SQLite客户端，包括<code>SQLite Manager</code>,<code>SQLite Reader</code>.<code>SQLite Manager</code>(另一个同名的WebExtensions扩展)</li><li>SQLite Database Browser，一款连接SQLite数据库的图形客户端</li><li>SQLite Expert Personal，Windows上的一款连接SQLite数据库的免费客户端</li></ul><hr><h3 id="SQLite-局限性"><a href="#SQLite-局限性" class="headerlink" title="SQLite 局限性"></a>SQLite 局限性</h3><p><strong>在SQLite中，SQL92不支持的特性:</strong></p><table><thead><tr><th align="left">特性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">RIGHT OUTER JOIN</td><td align="left">只实现了 LEFT OUTER JOIN</td></tr><tr><td align="left">FULL OUTER JOIN</td><td align="left">只实现了 LEFT OUTER JOIN</td></tr><tr><td align="left">ALTER TABLE</td><td align="left">支持 RENAME TABLE 和 ALTER TABLE 的 ADD COLUMN variants 命令，不支持 DROP COLUMN，ALTER COLUMN，ADD CONSTRAINT</td></tr><tr><td align="left">Trigger支持</td><td align="left">支持 FOR EACH ROW 触发器，但不支持 FOR EACH STATEMENT 触发器</td></tr><tr><td align="left">VIEWS</td><td align="left">在SQLite中，视图是只读的，即不可以在视图上执行 DELETE，INSERT 或 UPDATE 语句</td></tr><tr><td align="left">GRANT 和 REVOKE</td><td align="left">可以应用的唯一的访问权限是底层操作系统的正常文件访问权限</td></tr></tbody></table><hr><h3 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念"></a>其它概念</h3><ul><li>DDL-数据定义语言</li></ul><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">CREATE</td><td align="left">创建表，视图，数据库与其它对象</td></tr><tr><td align="left">ALTER</td><td align="left">修改数据库中的某个已有的数据库对象</td></tr><tr><td align="left">DROP</td><td align="left">用于删除表，视图，数据库与其它对象</td></tr></tbody></table><hr><ul><li>DML-数据操作语言</li></ul><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">INSERT</td><td align="left">插入记录</td></tr><tr><td align="left">UPDATE</td><td align="left">修改记录</td></tr><tr><td align="left">DELETE</td><td align="left">删除记录</td></tr></tbody></table><hr><ul><li>DQL-数据查询语言</li></ul><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">SELECT</td><td align="left">检索/查询</td></tr></tbody></table><hr><h3 id="常用函数-聚合函数-参考"><a href="#常用函数-聚合函数-参考" class="headerlink" title="常用函数(聚合函数)参考:"></a>常用函数(聚合函数)参考:</h3><table><thead><tr><th align="left">函数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">MAX</td><td align="left">返回最大值</td></tr><tr><td align="left">MIN</td><td align="left">返回最小值</td></tr><tr><td align="left">COUNT</td><td align="left">计算并返回行数</td></tr><tr><td align="left">AVG</td><td align="left">返回平均值</td></tr><tr><td align="left">SUM</td><td align="left">返回数值总和</td></tr><tr><td align="left">RANDOM</td><td align="left">用于伪随机数生成</td></tr><tr><td align="left">ABS</td><td align="left">返回参数绝对值</td></tr><tr><td align="left">UPPER</td><td align="left">将字符串转换为大写字母</td></tr><tr><td align="left">LOWER</td><td align="left">将字符串转化为小写字母</td></tr><tr><td align="left">LENGTH</td><td align="left">返回字符串长度</td></tr><tr><td align="left"><code>sqlite_version</code></td><td align="left">返回SQLite库的版本</td></tr></tbody></table><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>官方网站:<a href="http://www.sqlite.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.sqlite.org/</code></p></blockquote></li><li><p>源码地址:<a href="https://www.sqlite.org/download.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.sqlite.org/download.html</code></p></blockquote></li><li><p>SQLite(PHP-API)文档:<a href="http://www.php.net/manual/en/book.sqlite3.php" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.php.net/manual/en/book.sqlite3.php</code></p></blockquote></li><li><p>获取方式:</p><blockquote><p><code>wget https://www.sqlite.org/download.html/sqlite-autoconf-3310100.tar.gz</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite-2</title>
    <url>/2020/02/19/SQLite-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="SQLite-2"><a href="#SQLite-2" class="headerlink" title="SQLite-2"></a>SQLite-2</h3><hr><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ID, A, B, C, D, TIME</span><br><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-19</span>/<span class="number">1999</span>/NOW()</span><br><span class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-19</span>/<span class="number">1999</span>/NOW()</span><br><span class="line"><span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-19</span>/<span class="number">1999</span>/NOW()</span><br><span class="line"><span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-19</span>/<span class="number">1999</span>/NOW()</span><br><span class="line"><span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-19</span>/<span class="number">1999</span>/NOW()</span><br><span class="line"><span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-19</span>/<span class="number">1999</span>/NOW()</span><br><span class="line"><span class="number">7</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-19</span>/<span class="number">1999</span>/NOW()</span><br><span class="line"><span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-18</span>/<span class="number">2000</span></span><br><span class="line"><span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-02</span><span class="number">-18</span>/<span class="number">2000</span></span><br></pre></td></tr></table></figure><hr><p><strong>表TABLES1</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES1(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">A <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">D <span class="built_in">REAL</span>, </span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>);</span><br></pre></td></tr></table></figure><p><code>CREATE TABLE TABLES1(ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,A TEXT NOT NULL,B INT NOT NULL,C CHAR(3),D REAL, TIME DATE);</code></p><hr><p><strong>列ID-TIME</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">INSERT INTO TABLES1 VALUES (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br><span class="line">INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">root@</span>debian:/home/sqlite/file# sqlite3 TEST1</span><br><span class="line">SQLite version <span class="number">3.31</span><span class="number">.1</span> <span class="number">2020</span><span class="number">-01</span><span class="number">-27</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">54</span></span><br><span class="line">Enter <span class="string">".help"</span> <span class="keyword">for</span> usage hints.</span><br><span class="line">sqlite&gt; .databases</span><br><span class="line">main: /home/sqlite/file/TEST1</span><br><span class="line">sqlite&gt; CREATE TABLE TABLES1(ID INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,A TEXT NOT NULL,B INT NOT NULL,C CHAR(<span class="number">3</span>),D REAL, TIME DATE);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br></pre></td></tr></table></figure><p><code>SELECT * FROM TABLES1;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES1;</span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">2</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">3</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">4</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">5</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">6</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">7</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">8</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br><span class="line"><span class="number">9</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br></pre></td></tr></table></figure><hr><h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><ul><li>基于ID进行降序查询并输出表TABLES1内A等于1且TIME等于2000/2020-02-18的数据(行)<blockquote><p><code>SELECT * FROM TABLES1 WHERE A = 1 AND TIME = 2000 ORDER BY ID DESC;</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES1 WHERE A = <span class="number">1</span> AND TIME = <span class="number">2000</span> ORDER BY ID DESC;</span><br><span class="line"><span class="number">9</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br><span class="line"><span class="number">8</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br></pre></td></tr></table></figure><hr><ul><li>查询并输出表TABLES1内TIME列以0结尾的数据<blockquote><p><code>SELECT * FROM TABLES1 WHERE TIME LIKE &#39;%0&#39;;</code></p></blockquote></li></ul><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES1 WHERE TIME LIKE '%<span class="number">0</span>'; </span><br><span class="line"><span class="number">8</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br><span class="line"><span class="number">9</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br></pre></td></tr></table></figure><hr><ul><li>查询并输出表TABLES1内TIME列中以2开头的数据<blockquote><p><code>SELECT * FROM TABLES1 WHERE TIME GLOB &#39;2*&#39;;</code></p></blockquote></li></ul><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES1 WHERE TIME GLOB '<span class="number">2</span>*';</span><br><span class="line"><span class="number">8</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br><span class="line"><span class="number">9</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br></pre></td></tr></table></figure><hr><ul><li>查询基于ID按降序输出表TABLES1内A等于6或TIME等于2000的数据并且只输出三条<br><code>SELECT * FROM TABLES1 WHERE A = 6 OR TIME = 2000 ORDER BY ID DESC LIMIT 3;</code></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES1 WHERE A = <span class="number">6</span> OR TIME = <span class="number">2000</span> ORDER BY ID DESC LIMIT <span class="number">3</span>;</span><br><span class="line"><span class="number">9</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br><span class="line"><span class="number">8</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br><span class="line"><span class="number">7</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9.0</span>|<span class="number">1999</span></span><br></pre></td></tr></table></figure><hr><ul><li>在TABLES1内基于A列对B列进行数值分组并按降序输出<blockquote><p><code>SELECT A , SUM(B) FROM TABLES1 GROUP BY A ORDER BY A DESC;</code></p></blockquote></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT A , SUM(B) <span class="keyword">FROM</span> TABLES1<span class="built_in"> GROUP </span>BY A ORDER BY A DESC;</span><br><span class="line">6|21</span><br><span class="line">1|12</span><br></pre></td></tr></table></figure><hr><ul><li>对表TABLES1内的A列中所有记录大于2的数据进行分组<blockquote><p><code>SELECT * FROM TABLES1 GROUP BY A HAVING count(A) &gt; 2;</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES1 GROUP BY A HAVING count(A) &gt; <span class="number">2</span>;</span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">4</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9.0</span>|<span class="number">1999</span></span><br></pre></td></tr></table></figure><hr><ul><li>查询并输出消除TABLES1内列A的重复记录<blockquote><p><code>SELECT DISTINCT A FROM TABLES1 WHERE TIME = 1999;</code></p></blockquote></li></ul><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> A <span class="keyword">FROM</span> TABLES1 <span class="keyword">WHERE</span> TIME = <span class="number">1999</span>;</span><br><span class="line">1</span><br><span class="line">6</span><br></pre></td></tr></table></figure><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h3><ul><li>NULL</li><li>WHERE</li><li>AND/OR</li><li>LIKE(<code>%</code>&amp;<code>_</code>)</li><li>GLOB(<code>*</code>&amp;<code>?</code>)<blockquote><p>SQLite特有性质<br>通配符遵循UNIX语法<br>搜索表达式<br>模式表达式<br>大小写敏感</p></blockquote></li><li>OR(or)</li><li>通配符</li><li>正则表达式</li><li>PRAGMA</li><li>Vacuum</li><li>触发器</li><li>别名</li><li>SQLite 注入</li><li>常用函数</li><li>视图(VIEW)</li><li>ALTER</li></ul><hr><ul><li>约束(NOT NULL/DEFAULT/UNIQUE/PRIMARY Key/CHECK)</li><li>交叉连接/内连接/外连接(CROSS/INNER/OUTER JOIN)</li><li>子查询(嵌套查询/<code>SELECT ... WHERE ... (SELECT ... WHERE ... (SELECT ... WHERE ...(...)))...</code>)</li></ul><hr><ul><li>索引查询(Indexed By)<blockquote><p>必须将索引命名才能从以前的表中查找值</p></blockquote></li></ul><hr><ul><li>Explain(解释)<blockquote><p>在 SQLite 语句之前<br>可以使用”EXPLAIN”关键字或”EXPLAIN QUERY PLAN”短语，用于描述表的细节<br>如果省略了EXPLAIN关键字或短语，任何的修改都会引起SQLite语句的查询行为<br>并返回有关SQLite语句如何操作的信息</p></blockquote></li></ul><hr><ul><li>合并(UNION)<blockquote><p>不会返回任何重复的行<br>为了使用 UNION，每个 SELECT 被选择的列数必须是相同的<br>相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序<br>但不必具有相同的长度</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLite-1</title>
    <url>/2020/02/19/SQLite-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="SQLite-1"><a href="#SQLite-1" class="headerlink" title="SQLite-1"></a>SQLite-1</h3><hr><ul><li>创建数据库同时返回命令提示符<blockquote><p><code>$sqlite3 TESTDB.db</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">root@</span>debian:/home/sqlite/file# sqlite3 TESTDB.db</span><br><span class="line">SQLite version <span class="number">3.31</span><span class="number">.1</span> <span class="number">2020</span><span class="number">-01</span><span class="number">-27</span> <span class="number">19</span>:<span class="number">55</span>:<span class="number">54</span></span><br><span class="line">Enter <span class="string">".help"</span> <span class="keyword">for</span> usage hints.</span><br><span class="line">sqlite&gt;</span><br></pre></td></tr></table></figure><p>查看所有数据库</p><blockquote><p><code>.databases</code></p></blockquote><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .databases</span><br><span class="line"><span class="symbol">main:</span> <span class="meta-keyword">/home/</span>sqlite<span class="meta-keyword">/file/</span>TESTDB.db</span><br></pre></td></tr></table></figure><ul><li>创建TABLES2<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES2(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">A <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">D <span class="built_in">REAL</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES2(</span><br><span class="line">ID <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">A <span class="type">TEXT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">B <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">C <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">D <span class="type">REAL</span>);</span><br></pre></td></tr></table></figure><ul><li>设置表查询输出的格式<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">.width <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">SELECT * FROM TABLES2;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .width <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span></span><br><span class="line">sqlite&gt; SELECT * FROM TABLES2;</span><br></pre></td></tr></table></figure><ul><li>查看表信息<blockquote><p><code>.table</code></p></blockquote></li></ul><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .<span class="keyword">table</span></span><br><span class="line">TABLES2</span><br></pre></td></tr></table></figure><ul><li>查看表配置<blockquote><p><code>.schema</code></p></blockquote></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES2(</span><br><span class="line">ID <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">A <span class="type">TEXT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">B <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">C <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">D <span class="type">REAL</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqlite_sequence(<span class="type">name</span>,seq);</span><br></pre></td></tr></table></figure><hr><ul><li>TABLES2修改为TABLES1<blockquote><p><code>ALTER TABLE TABLES2 RENAME TO TABLES1;</code></p></blockquote></li></ul><blockquote><p><code>sqlite&gt; ALTER TABLE TABLES2 RENAME TO TABLES1;</code></p></blockquote><ul><li>添加新列TIME<blockquote><p><code>ALTER TABLE TABLES1 ADD COLUMN TIME DATE;</code></p></blockquote></li></ul><blockquote><p><code>sqlite&gt; ALTER TABLE TABLES1 ADD COLUMN TIME DATE;</code></p></blockquote><ul><li>查看表信息<blockquote><p><code>.table</code></p></blockquote></li></ul><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .<span class="keyword">table</span></span><br><span class="line">TABLES1</span><br></pre></td></tr></table></figure><ul><li>查看表配置<blockquote><p><code>.schema</code></p></blockquote></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> "TABLES1"(</span><br><span class="line">ID <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">A <span class="type">TEXT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">B <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">C <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">D <span class="type">REAL</span>, <span class="type">TIME</span> <span class="type">DATE</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqlite_sequence(<span class="type">name</span>,seq);</span><br></pre></td></tr></table></figure><hr><ul><li><p><code>BEGIN;</code></p><blockquote><p><code>sqlite&gt; BEGIN;</code></p></blockquote></li><li><p>插入数据</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>条] INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, NOW())/(<span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">[<span class="number">1</span>条] INSERT INTO TABLES1 VALUES (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, NOW())/(<span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">[<span class="number">1</span>条] INSERT INTO TABLES1  VALUES (<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br><span class="line">[<span class="number">1</span>条] INSERT INTO TABLES1  VALUES (<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">`INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);`</span><br><span class="line">`INSERT INTO TABLES1  VALUES (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);`</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1 (A,B,C,D,TIME) VALUES (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1  VALUES (<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-19</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1  VALUES (<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br><span class="line">sqlite&gt; INSERT INTO TABLES1  VALUES (<span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2020</span><span class="number">-2</span><span class="number">-18</span>);</span><br></pre></td></tr></table></figure><ul><li><p>快照一</p><blockquote><p><code>COMMIT;</code><br><code>sqlite&gt; COMMIT;</code></p></blockquote></li><li><p><code>BEGIN;</code></p><blockquote><p><code>sqlite&gt; BEGIN;</code></p></blockquote></li><li><p>删除ID等于6的行</p><blockquote><p><code>DELETE FROM TABLES1 WHERE ID = 6;</code><br><code>sqlite&gt; DELETE FROM TABLES1 WHERE ID = 6;</code></p></blockquote></li><li><p>更新TABLES1内C,D列的数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> TABLES1</span><br><span class="line"><span class="keyword">SET</span> C = <span class="number">3</span>, D = <span class="number">4</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">ID</span> = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">sqlite&gt; UPDATE TABLES1</span><br><span class="line">   ...&gt; <span class="keyword">SET</span> C <span class="comment">= 3, D = 4</span></span><br><span class="line">   ...&gt; WHERE <span class="comment">ID = 4</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>SELECT * FROM TABLES1;</code></p></blockquote><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES1;</span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">2</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">3</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">4</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">5</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br></pre></td></tr></table></figure><ul><li>结束<blockquote><p><code>COMMIT</code><br><code>sqlite&gt; COMMIT;</code></p></blockquote></li></ul><hr><ul><li><p>创建表TABLES2并将TABLES1内数据复制到其中</p></li><li><p>查看表配置</p><blockquote><p><code>.schema</code></p></blockquote></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .<span class="keyword">schema</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> "TABLES1"(</span><br><span class="line">ID <span class="type">INTEGER</span> <span class="keyword">PRIMARY KEY</span> AUTOINCREMENT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">A <span class="type">TEXT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">B <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">C <span class="type">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">D <span class="type">REAL</span>, <span class="type">TIME</span> <span class="type">DATE</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sqlite_sequence(<span class="type">name</span>,seq);</span><br></pre></td></tr></table></figure><ul><li>复制配置信息，将TABLES1改为TABLES2<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES2(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span> AUTOINCREMENT <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">A <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">CHAR</span>(<span class="number">3</span>),</span><br><span class="line">D <span class="built_in">REAL</span>, <span class="built_in">TIME</span> <span class="built_in">DATE</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">sqlite&gt; CREATE TABLE TABLES2(</span><br><span class="line">   <span class="params">...</span>&gt; ID <span class="built_in">INTEGER</span> PRIMARY KEY AUTOINCREMENT <span class="literal">NOT</span> <span class="built_in">NULL</span>,</span><br><span class="line">   <span class="params">...</span>&gt; A TEXT <span class="literal">NOT</span> <span class="built_in">NULL</span>,</span><br><span class="line">   <span class="params">...</span>&gt; B INT <span class="literal">NOT</span> <span class="built_in">NULL</span>,</span><br><span class="line">   <span class="params">...</span>&gt; C CHAR(<span class="number">3</span>),</span><br><span class="line">   <span class="params">...</span>&gt; D REAL, TIME <span class="built_in">DATE</span>);</span><br></pre></td></tr></table></figure><ul><li>复制TABLES1信息到TABLES2<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2 (A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">SELECT</span> A,B,C,D,<span class="built_in">TIME</span></span><br><span class="line"><span class="keyword">FROM</span> TABLES1;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2 (A,B,C,D,TIME)</span><br><span class="line">   ...&gt; <span class="keyword">SELECT</span> A,B,C,D,TIME</span><br><span class="line">   ...&gt; <span class="keyword">FROM</span> TABLES1;</span><br></pre></td></tr></table></figure><p><code>SELECT * FROM TABLES2;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">sqlite&gt; SELECT * FROM TABLES2;</span><br><span class="line"><span class="number">1</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">2</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">3</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">4</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">1999</span></span><br><span class="line"><span class="number">5</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">4.0</span>|<span class="number">2000</span></span><br></pre></td></tr></table></figure><hr><ul><li>为TABLES1的A列与B列添加组合索引<blockquote><p><code>CREATE INDEX INDEX1 ON TABLES1 (A,B);</code></p></blockquote></li></ul><blockquote><p><code>sqlite&gt; CREATE INDEX INDEX1 ON TABLES1 (A,B);</code></p></blockquote><ul><li>列出表TABLES1内所有可用索引<blockquote><p><code>.indices/.indexes TABLES1</code></p></blockquote></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sqlite</span>&gt; <span class="selector-class">.indexes</span> <span class="selector-tag">TABLES1</span></span><br><span class="line"><span class="selector-tag">INDEX1</span></span><br></pre></td></tr></table></figure><hr><ul><li>删除索引(索引最好不要使用在较小或频繁且大批量更新的表与列上，且最好不要有太多的NULL值)<blockquote><p><code>DROP INDEX INDEX1;</code><br><code>sqlite&gt; DROP INDEX INDEX1;</code></p></blockquote></li></ul><blockquote><p><code>.exit</code></p></blockquote><ul><li>将TESTDB数据库导以<code>.sql</code>后缀导出到当前文件夹<blockquote><p>$sqlite3 TESTDB.db .dump &gt; testDB.sql;</p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="symbol">root@</span>debian:/home/sqlite/file# ls -l</span><br><span class="line">总用量 <span class="number">20</span></span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root <span class="number">20480</span> <span class="number">2</span>月  <span class="number">19</span> <span class="number">17</span>:<span class="number">15</span> TESTDB.db</span><br><span class="line">-rw-r--r-- <span class="number">1</span> root root     <span class="number">0</span> <span class="number">2</span>月  <span class="number">19</span> <span class="number">17</span>:<span class="number">02</span> testDB.sql</span><br></pre></td></tr></table></figure><blockquote><p><code>$sqlite3 TEST1</code></p></blockquote><ul><li>删除表TABLES1与TABLES2内所有内容<blockquote><p><code>DELETE FROM TABLES1;</code><br><code>DELETE FROM TABLES2;</code></p></blockquote></li></ul><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; <span class="keyword">DELETE</span> <span class="keyword">FROM</span> TABLES1;</span><br><span class="line">sqlite&gt; <span class="keyword">DELETE</span> <span class="keyword">FROM</span> TABLES2;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">sqlite&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLES1;</span><br><span class="line">sqlite&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLES2;</span><br></pre></td></tr></table></figure><ul><li>删除表TABLES1与TABLES2<blockquote><p><code>DROP TABLE TESTDB.TABLES1;</code>或<code>DROP TABLE TABLES1;</code><br><code>DROP TABLE TESTDB.TABLES2;</code>或<code>DROP TABLE TABLES2;</code></p></blockquote></li></ul><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">sqlite&gt; DROP <span class="keyword">TABLE</span> TABLES1;</span><br><span class="line">sqlite&gt; DROP <span class="keyword">TABLE</span> TABLES2;</span><br></pre></td></tr></table></figure><blockquote><p><code>.tables</code><br><code>sqlite&gt; .tables</code></p></blockquote><hr><p><strong>其它:</strong></p><ul><li>SQLite命令提示符内命令不需要分号，而语句需要分号(“;”)</li><li>大多数命令和语句不区分大小写(GLOB和glob对大小写敏感)</li><li>命令多以点符号<code>&#39;.&#39;</code>开头</li><li><code>.help</code>输出帮助指令</li><li>键入<code>sqlite指令</code>进入命令提示符界面</li></ul><hr><p><strong>附加&amp;分离</strong></p><ul><li><p>附加UNITDB数据库</p></li><li><p>基本语法:</p><blockquote><p><code>ATTACH DATABASE file_name AS database_name;</code></p></blockquote></li><li><p>将UNITDB附加到已有数据库TESTDB.db上</p><blockquote><p><code>ATTACH DATABASE &#39;TESTDB.db&#39; as &#39;UNITDB&#39;;</code></p></blockquote></li><li><p>分离UNITDB数据库</p></li><li><p>基本语法:</p><blockquote><p><code>DETACH DATABASE &#39;Alias-Name&#39;;</code><br>把’UNITDB’从testDB.db中分离出来<br><code>DETACH DATABASE &#39;UNITDB&#39;;</code></p></blockquote></li><li><p>输出结果:</p><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line">sqlite&gt; <span class="string">.database</span></span><br><span class="line">seq  name               file</span><br><span class="line"><span class="params">---</span>  <span class="params">---------------</span>  <span class="params">----------------------</span></span><br><span class="line">0    main                 <span class="string">/home/sqlite/testDB.db</span></span><br><span class="line">2    test                   <span class="string">/home/sqlite/testDB.db</span></span><br></pre></td></tr></table></figure></li><li><p>说明:</p><blockquote><p>数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库<br>这两个数据库名称可用于每个数据库连接</p></blockquote></li></ul><hr><h3 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念:"></a>其它概念:</h3><ul><li>基本语法</li><li>数据类型</li><li>运算符</li><li>导入与导出</li><li>数据库:分离(游离)</li><li>数据库:附加</li><li>表达式</li><li>NULL</li><li>序列</li><li>触发器</li><li>索引</li><li>ALTER(限制)</li><li>别名</li><li>Truncate(无)</li><li>SQLite注入</li><li>VACUUM(Vacuum)</li><li>Explain(解释)</li><li>日期&amp;时间</li><li>函数</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>RDBMS-KEY-1</title>
    <url>/2020/02/19/RDBMS-KEY-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="RDBMS-KEY-1-关系键"><a href="#RDBMS-KEY-1-关系键" class="headerlink" title="RDBMS-KEY-1(关系键)"></a>RDBMS-KEY-1(关系键)</h3><ul><li>关系键是关系数据库(关系模型)的重要组成部分</li><li>关系键是一个表中的一个或几个属性，用来标识该表的每一行或与另一个表产生联系</li></ul><hr><p><strong>可大致分为六类</strong></p><ul><li>主键</li><li>超键</li><li>候选键</li><li>外键</li><li>代理键</li><li>自然键</li><li>公共键</li></ul><hr><ol><li>主键</li></ol><ul><li>主键，又称主码/主关键字(primary key或unique key)</li><li>数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合</li><li>一个数据表只能有一个主键，且主键的取值不能缺失，即不能为空值(Null)</li><li>作表的行的唯一标识的候选关键字</li><li>一个表只能有一个主键</li><li>主键可以由一个字段，也可以由多个字段组成，分别称为单字段主键或多字段主键<blockquote><p>并且它可以唯一确定表中的一行数据，或者可以唯一确定一个实体</p></blockquote></li></ul><p><strong>primary key和unique key的区别</strong></p><ol><li>作为primary key的域<code>／</code>域组不能为Null，而unique key可以</li><li>一个表只能有一个primary key，但可有多个unique key</li><li>更大的区别在逻辑设计<blockquote><p>primary key一般在逻辑设计中用作记录标识，这也是设置primary key的本意<br>而unique key只是为了保证域／域组的唯一性</p></blockquote></li></ol><p><strong>作用:</strong></p><ol><li>保证实体的完整性</li><li>加快数据库的操作速度</li><li>在表中添加新记录时，ACCESS会自动检查新记录的主键值，不允许该值与其他记录的主键值重复</li><li>ACCESS自动按主键值的顺序显示表中的记录，如果没有定义主键，则按输入记录的顺序显示表中的记录</li></ol><hr><ol start="2"><li>超键</li></ol><ul><li>超键，又称超码(superkey)</li><li>是在数据库关系模式设计中能够唯一标示多元组(即”行”)的属性集</li><li>包含所有属性的集叫做明显(平凡)超键</li></ul><hr><ol start="3"><li>候选键</li></ol><ul><li><p>候选键，又称候选码(candidate key)</p></li><li><p>是某个关系变量的一组属性所组成的集合</p></li><li><p>它需要同时满足下列两个条件：</p><blockquote><ol><li>这个属性集合始终能够确保在关系中能唯一标识元组</li><li>在这个属性集合中找不出真子集能够满足条件(1)</li></ol></blockquote></li><li><p>满足第一个条件的属性集合称为超键</p><blockquote><p>因此也可以把候选键定义为”最小超键”，也就是不含有多余属性的超键</p></blockquote></li><li><p>候选键的重要性是它们能够在关系中唯一标识出不同的元组，因此超键也是在设计数据库模式时需要指定的最重要的约束之一</p></li><li><p>由于在关系模型中，每个关系都是一个集合(没有重复的元素)，所以每个关系都至少有一个候选键(因为所有属性组合必然是个超键)</p></li><li><p>但是在某些关系型数据库中表也能代表多重集，所以在每个关系中都显式地定义至少一个候选键是一条很重要的设计原则</p><blockquote><p>数据库管理系统通常都需要将每个关系中的某个候选键定义为主键<br>亦即这个候选键是区分不同元组时首选的识别方式<br>例如外键通常就是引用主键而非其他候选键</p></blockquote></li></ul><hr><ol start="4"><li>外键</li></ol><ul><li><p>外键，又称外部键/外来键(foreign key)</p></li><li><p>在关系数据库中，每个数据表都是由关系来连系彼此的关系</p><blockquote><p>父数据表(Parent Entity)的主键(primary key)会放在另一个数据表，当做属性以创建彼此的关系<br>而这个属性就是外键</p></blockquote></li><li><p>比如，学生跟老师之间是教学的关系，学生数据表会有个属性叫指导老师(FK)，而这个值就是对应到老师数据表的老师代号(PK)，学生的指导老师就是外键</p></li><li><p>如果公共键在一个关系中是主关键字，那么这个公共键被称为另一个关系的外键</p><blockquote><p>由此可见，外键表示了两个关系之间的相关联系<br>以另一个关系的外键作主键的表被称为主表，具有此外键的表被称为主表的从表<br>外键又称作外关键字</p></blockquote></li></ul><p><strong>作用:</strong></p><ul><li>保持数据一致性，完整性，主要目的是控制存储在外键表中的数据</li><li>使两张表形成关联，外键只能引用外表中的列的值或使用空值</li></ul><hr><ol start="5"><li>代理键</li></ol><ul><li><p>代理键(surrogate key)</p></li><li><p>是在当数据表中的候选键都不适合当主键时，例如数据太长，或是意义层面太多，就会请一个无意义的但唯一的字段来代为作主键</p></li><li><p>代理键是(引用描述):</p></li><li><p>1.<code>Surrogate (1) – Hall, Owlett and Codd (1976)</code></p><blockquote><p>一个代理键值确定了外部世界的一个实体，代理键值是数据库生成的，从来不显示给用户或应用程序看</p></blockquote></li><li><ol start="2"><li><code>Surrogate (2) – Wieringa and De Jonge (1991)</code><blockquote><p>一个代理键值确定了数据库中的一个对象，代理键值是数据库生成的，用户或应用程序看不到它</p></blockquote></li></ol></li><li><p>在实践中，代理键值通常是个自动递增的数字</p></li><li><p>例如:</p></li><li><p>PostgreSQL用serial</p></li><li><p>Oracle用SEQUENCE</p></li><li><p>在MySQL用标记有<code>AUTO_INCREMENT</code>的字段</p></li></ul><hr><ol start="6"><li>自然键</li></ol><ul><li>自然键(natural key)</li><li>与代理键相反，是在自然(真实)生活中唯一确定一个事物的标识</li><li>身份证号(理论上，假设没有因技术原因造成的重复)就是一个自然键，用于准确且绝对的确定一个人</li></ul><hr><ol start="7"><li>公共键</li></ol><ul><li>公共键，又可称为公共关键字(Common Key)</li><li>在关系数据库中，关系之间的联系是通过相容或相同的属性或属性组来表示的<blockquote><p>如果两个关系中具有相容或相同的属性或属性组，那么这个属性或属性组被称为这两个关系的公共键</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>LBA/CHS/RAID-1</title>
    <url>/2020/02/19/LBA-CHS-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="LBA-CHS-RAID-1"><a href="#LBA-CHS-RAID-1" class="headerlink" title="LBA/CHS/RAID-1"></a>LBA/CHS/RAID-1</h2><ul><li>LBA(寻址模式)-1</li><li>CHS(寻址模式)-1</li><li>RAID(磁盘阵列)-1</li></ul><h3 id="LBA-寻址模式"><a href="#LBA-寻址模式" class="headerlink" title="LBA-寻址模式"></a>LBA-寻址模式</h3><p><strong>简述:</strong></p><ul><li>LBA寻址模式</li><li>逻辑区块地址(Logical Block Address, LBA)</li><li>是描述电脑存储设备上数据所在区块的通用机制，一般用在像硬盘这样的辅助记忆设备</li><li>LBA可以意指某个数据区块的地址或是某个地址所指向的数据区块<blockquote><p>现今电脑上所谓一个逻辑区块通常是512或1024位组<br>ISO-9660格式的标准CD则以2048位组为一个逻辑区块大小</p></blockquote></li></ul><hr><p><strong>LBA定址机制:</strong></p><ul><li>LBA是非常单纯的一种定址模式:从0开始编号来定位区块，第一区块LBA=0，第二区块LBA=1，依此类推</li><li>这种定址模式取代了原先操作系统必须面对存储设备硬件构造的方式<blockquote><p>最具代表性的首推CHS(cylinders-heads-sectors，磁柱-磁头-扇区)定址模式<br>区块必须以硬盘上某个磁柱、磁头、扇区的硬件位置所合成的地址来指定<br>CHS模式对硬盘以外的设备来说没什么作用(例如磁带或是网络存储设备)，所以通常也不会用在这些地方<br>过去MFM(Modified Frequency Modulation, 改良调频式)和RLL(Run Length Limited)存储设备都曾使用CHS模式<br>ATA-1设备更将延伸CHS(Extended Cylinders-Heads-Sectors, ECHS)也派上了用场</p></blockquote></li><li>SCSI采用LBA抽象定址</li></ul><hr><p><strong>LBA所对应的/与逻辑器件虚拟化</strong></p><blockquote><p>当逻辑器件是经由虚拟化或是集合所构成的<br>像是RAID(磁盘阵列)和SANs(Storage Area Network)这种复杂的情况<br>就得把应用程序根据其观点中的磁盘来指定的LBA转换成每个实体存储设备上的LBA</p></blockquote><ul><li><p>在复杂的分布式存储结构下，从发出要求的应用程序到实体甚至是远程设备之间，会有太多这样的LBA转换</p></li><li><p>CHS与LBA之间可以相互转换</p></li></ul><hr><p><strong>转换公式:</strong></p><ul><li><p>CHS地址转LBA公式</p><blockquote><p><code>#lba=(#c*H+#h)*S+#s-1</code></p></blockquote></li><li><p>说明:</p><blockquote><p><code>#c</code>,<code>#h</code>,<code>#s</code>分别是磁柱、磁头、扇区的编号<br><code>#lba</code>是逻辑区块编号<br>H=heads per cylinder，每个磁柱的磁头数<br>S=sectors per track，每磁道的扇区数</p></blockquote></li></ul><hr><ul><li><p>LBA地址转CHS公式:</p><blockquote><p>#c=#lba/(S*H)<br>#h=(#lba/S)%H<br>#s=(#lba%S)+1</p></blockquote></li><li><p>说明:</p><blockquote><p><code>/</code>是整数除法<br><code>%</code>是取整数除法中的余数<br>需要注意的一点是当今的磁盘使用ZBR(Zone Bit Recording, 等密度记录)方式，实际的每轨扇区数得根据它是哪一轨<br>不过磁盘还是会提供这个参数来符合公式，内部再自动调整</p></blockquote></li></ul><hr><ul><li><p>其它公式:</p><blockquote><p><code>#lba/S=q 余 r</code><br><code>#s=1+r</code><br><code>q/H=#c 余 #h</code></p></blockquote></li><li><p>例如:</p><blockquote><p><code>CHS总数=[600, 10, 84]</code>，求<code>#lba=1234</code>所对应的CHS编号:<br><code>1234/84=14 余 58</code><br><code>#s=1+58=59</code><br><code>14/10=1 余 4</code><br><code>#c=1</code><br><code>#h=4</code><br><code>#chs=(1, 4, 59)</code><br>验算:<code>(1*10+4)*84+59-1=14*84+58=1234</code></p></blockquote></li></ul><hr><h3 id="CHS寻址模式"><a href="#CHS寻址模式" class="headerlink" title="CHS寻址模式"></a>CHS寻址模式</h3><p><strong>概述:</strong></p><ul><li>CHS寻址模式</li><li>柱面-磁头-扇区(Cylinder-head-sector，简称为CHS)</li><li>CHS寻址模式将硬盘划分为磁头(Heads)，柱面(Cylinder)，扇区(Sector)</li><li>是早期对硬盘驱动器的每一个物理数据块进行编址的一种方法<blockquote><p>就软盘驱动器而言，可对同一磁盘介质进行低级格式化而得到不同的容量</p></blockquote></li></ul><hr><ul><li>磁头(Heads):每张磁片的正反两面各有一个磁头，一个磁头对应一张磁片的一个面<blockquote><p>因此，用第几磁头就可以表示数据在哪个磁面</p></blockquote></li><li>柱面(Cylinder):所有磁片中半径相同的同心磁道构成”柱面”，意思是这一系列的磁道垂直叠在一起，就形成一个柱面的形状<blockquote><p>简单地理解:柱面数=磁道数<br>扇区(Sector)：将磁道划分为若干个小的区段，就是扇区<br>虽然很小，但实际是一个扇子的形状，故称为扇区，每个扇区的容量为512字节</p></blockquote></li></ul><hr><ul><li>知道了磁头数、柱面数、扇区数，就可以很容易地确定数据保存在硬盘的哪个位置</li><li>确定硬盘的容量计算公式:<blockquote><p>硬盘容量=磁头数×柱面数×扇区数×512字节</p></blockquote></li></ul><hr><ul><li>LARGE寻址模式把柱面数除以整数倍、磁头数乘以整数倍而得到的逻辑磁头/柱面/扇区参数进行寻址</li><li>所以表示的已不是硬盘中的物理位置，而是逻辑位置</li></ul><hr><ul><li>LBA寻址模式是直接以扇区为单位进行寻址的，不再用磁头/柱面/扇区三种单位来进行寻址<blockquote><p>但为了保持与CHS模式的兼容，通过逻辑变换算法，可以转换为磁头/柱面/扇区三种参数来表示<br>但表示的也和LARGE寻址模式一样，并不是硬盘中的物理位置，而是逻辑位置</p></blockquote></li></ul><hr><h3 id="RAID-磁盘阵列"><a href="#RAID-磁盘阵列" class="headerlink" title="RAID-磁盘阵列"></a>RAID-磁盘阵列</h3><ul><li>独立硬盘冗余阵列(RAID, Redundant Array of Independent Disks)</li><li>旧称廉价磁盘冗余阵列(Redundant Array of Inexpensive Disks)</li><li>利用虚拟化存储技术把多个硬盘组合起来，成为一个或多个硬盘阵列组，目的为提升性能或数据冗余，或是两者同时提升</li></ul><hr><ul><li><p>根据实现模式，分为软件和硬件两种：</p><blockquote><p>软件磁盘阵列(Software RAID)<br>硬件磁盘阵列(Hardware RAID)</p></blockquote></li><li><p>目前水平有限，文章只对RAID进行简单概述</p></li></ul><hr><h3 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念:"></a>其它概念:</h3><ul><li>FDISK(分区)</li><li>BOOT</li><li>ACPI</li><li>UEFI</li><li>BIOS</li><li>CHS</li><li>LBA</li><li>SMBIOS</li><li>Aptio</li><li>硬盘固件/固件</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Disk</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>EFI/UEFI-1</title>
    <url>/2020/02/19/UEFI-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="EFI-UEFI-1"><a href="#EFI-UEFI-1" class="headerlink" title="EFI/UEFI-1"></a>EFI/UEFI-1</h3><p><strong>概述:</strong></p><ul><li>统一可扩展固件接口(Unified Extensible Firmware Interface)</li><li>作为BIOS的替代方案被用来定义操作系统与系统固件之间的软件界面</li><li>可扩展固件接口负责加电自检(POST)，联系操作系统以及提供连接操作系统与硬件的接口</li><li>UEFI的前身是Intel在1998年开始开发的Intel Boot Initiative，后来被重命名为可扩展固件接口(Extensible Firmware Interface，缩写EFI)</li><li>Intel在2005年将其交由统一可扩展固件接口论坛(Unified EFI Forum)来推广与发展，为了凸显这一点，EFI也更名为UEFI(Unified EFI)</li><li>位置说明:操作系统&lt;-&gt;可拓展接口(UEFI/BIOS)&lt;-&gt;系统固件&lt;-系统硬件</li><li>在EFI规范中，一种突破传统MBR磁盘分区结构限制的GUID磁盘分区系统(GPT)被引入</li></ul><hr><h3 id="UEFI与BIOS"><a href="#UEFI与BIOS" class="headerlink" title="UEFI与BIOS"></a>UEFI与BIOS</h3><p><strong>UEFI</strong></p><ul><li>UEFI用模块化，C语言风格的参数堆栈传递方式，动态链接的形式构建的系统</li><li>较BIOS而言更易于实现，容错和纠错特性更强，缩短了系统研发的时间</li><li>它可以运行于x86-64、IA32、IA64等架构上（在个人电脑上通常是x86-64平台），突破传统16位代码的寻址能力，达到处理器的最大寻址</li><li>它利用加载EFI驱动程序的形式，识别及操作硬件，不同于BIOS利用挂载实模式中断的方式增加硬件功能</li><li>另外UEFI在概念上非常类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力<blockquote><p>但EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以威胁操作系统的统治地位</p></blockquote></li></ul><hr><ul><li>UEFI系统下的驱动程序可以由EFI Byte Code(EBC)编写而成<blockquote><p>EFI Byte Code是一组专用于EFI驱动程序的虚拟机器语言，必须在EFI驱动程序运行环境(Driver Execution Environment，或DXE)下被解释运行<br>采用EBC编写的EFI驱动程序拥有向下兼容性，以便在安装不同处理内不需要重新编写EFI驱动，所以UEFI无需对系统升级带来的兼容性因素作考虑</p></blockquote></li><li>基于EFI的驱动模型可以使UEFI系统接触到所有的硬件功能<blockquote><p>比如在操作系统运行以前浏览万维网站，实现图形化、多语言的BIOS设置界面，或者无需运行操作系统即可在线更新BIOS</p></blockquote></li></ul><hr><ul><li>UEFI固件区分架构，在UEFI引导模式下，通常只能运行特定架构的UEFI操作系统和特定架构的EFI应用程序(EBC程序除外)<blockquote><p>比如，采用64位UEFI固件的PC，在UEFI引导模式下只能运行64位操作系统引导程序<br>而在Legacy引导模式(即BIOS兼容引导模式)下，通常不区分操作系统的比特数，既可以运行16位的操作系统(如DOS)<br>也可以运行32位或64位的操作系统，和BIOS一样</p></blockquote></li></ul><hr><ul><li>在众多的分区类型中，EFI系统分区可以被UEFI固件访问，可用于存放操作系统的引导程序、EFI应用程序和EFI驱动程序</li><li>EFI系统分区采用FAT文件系统，容量较小，在Windows操作系统下，默认是隐藏的</li><li>UEFI固件通过运行EFI系统分区中的引导程序引导操作系统</li></ul><p><strong>BIOS</strong></p><ul><li>BIOS必须将一段类似于驱动程序的16位代码(如RAID卡的Option ROM)放置在固定的<code>0x000C0000</code>至<code>0x000DFFFF</code>之间存储区中<blockquote><p>运行这段代码的初始化部分，它将挂载实模式下约定的中断向量向其他程序提供服务<br>由于这段存储空间有限(128KB)，BIOS对于所需放置的驱动程序代码大小超过空间大小的情况无能为力</p></blockquote></li><li>BIOS的硬件服务程序都以16位代码的形式存在，这就给运行于增强模式的操作系统访问其服务造成了困难<blockquote><p>因此BIOS提供的服务在现实中只能提供给操作系统引导程序或MS-DOS类操作系统使用</p></blockquote></li><li>部分采用EFI技术的BIOS并不支持EFI引导</li></ul><hr><h3 id="统一可扩展固件接口-UEFI-的构成"><a href="#统一可扩展固件接口-UEFI-的构成" class="headerlink" title="统一可扩展固件接口(UEFI)的构成"></a>统一可扩展固件接口(UEFI)的构成</h3><ul><li>一般认为UEFI由以下几个部分构成:</li><li>Pre-EFI初始化模块</li><li>EFI驱动程序执行环境</li><li>EFI驱动程序</li><li>兼容性支持模块(CSM)</li><li>EFI高层应用</li><li>GUID磁盘分区表</li></ul><hr><p><strong>实现逻辑:</strong></p><ul><li>在实现中，统一可扩展固件接口(UEFI)初始化模块和驱动执行环境通常被集成在一个只读存储器中</li><li>Pre-EFI初始化程序在系统开机的时候最先得到执行，它负责最初的CPU，芯片组及存储器的初始化工作，紧接着加载EFI的驱动程序执行环境(DXE)</li><li>当DXE被加载运行时，系统便具有了枚举并加载其他EFI驱动程序的能力</li><li>在基于PCI架构的系统中，各PCI桥及PCI适配器的EFI驱动程序会被相继加载及初始化</li><li>同时，系统进而枚举并加载各桥接器及适配器后面的各种总线及设备的EFI驱动程序，以此周而复始，直到最后一个设备的EFI驱动程序被成功加载<blockquote><p>正因如此，EFI驱动程序可以放置于系统的任何位置，只要能保证它可以按顺序被正确枚举</p></blockquote></li></ul><p><strong>例如:</strong></p><ol><li>有一个具PCI-E总线接口的RAID存储适配器，其EFI驱动程序一般会放置在这个设备的符合PCI规范的扩展只读存储器(PCI Expansion ROM)中</li><li>当PCI总线驱动程序被加载完毕，并开始枚举其子设备时，这个存储适配器旋即被正确识别并加载它的EFI驱动程序</li><li>部分EFI驱动程序还可以放置在某个磁盘的EFI系统分区(ESP)中，只要这些驱动程序不是用于加载这个磁盘的驱动的必要部件</li></ol><hr><p><strong>CSM</strong></p><ul><li>CSM是在x86平台UEFI系统中的一个特殊的模块</li><li>它将为不具备UEFI引导能力的操作系统(如Windows XP)以及16位的传统Option ROM(即非EFI的Option ROM)提供类似于传统BIOS的系统服务</li><li>Secure Boot和CSM不兼容，因此在UEFI固件设置中打开CSM前，需要在UEFI固件设置中关闭Secure Boot</li></ul><hr><p><strong>采用UEFI固件的x86/x64系统类别</strong></p><ul><li>类别0，这类系统使用x86 BIOS固件，只支持传统操作系统</li><li>类别1，这类系统采用支持UEFI和Pi规范的固件，激活CSM层功能，只支持传统操作系统</li><li>类别2，这类系统采用支持UEFI和Pi规范的固件，激活CSM层功能，同时支持传统和UEFI引导的操作系统</li><li>类别3，这类系统采用支持UEFI和Pi规范的固件，不再提供或完全关闭CSM层功能，只支持由UEFI引导的操作系统</li><li>类别3+，在类别3的系统基础上提供并激活Secure Boot功能</li></ul><hr><h3 id="版本历史"><a href="#版本历史" class="headerlink" title="版本历史:"></a>版本历史:</h3><ul><li><p>1.1版本于2002年12月发布(EFI)</p></li><li><p>2.1版本于2007年1月7日发布(UEFI)</p><blockquote><p>增加与改进了加密编码(cryptography)<br>网络认证(network authentication)<br>用户接口架构(User Interface Architecture)</p></blockquote></li><li><p>2.3版本于2009年5月9日发布</p></li><li><p>最新为2.7版本</p></li><li><p>Linux内核自2000年开始，已经支持EFI引导</p><blockquote><p>早期使用ELILO作为EFI下的引导程序<br>现在，GRUB的EFI版本已代替ELILO，大多数Linux发行版已使用GRUB作为UEFI下的引导程序</p></blockquote></li><li><p>VMware Workstation支持对UEFI的模拟</p><blockquote><p>但是在VMware Workstation 11以前，VMware Workstation并未正式支持UEFI，需要手动编辑虚拟机的.vmx文件以打开虚拟机的UEFI</p></blockquote></li></ul><hr><h3 id="Secure-Boot相关"><a href="#Secure-Boot相关" class="headerlink" title="Secure Boot相关"></a>Secure Boot相关</h3><ul><li><p>在UEFI 2.3.1 Errata C规范中定义了一项名为”Secure Boot”的协议</p></li><li><p>Secure Boot只允许加载有适当数字签名的EFI驱动程序和EFI引导程序，以此Secure Boot可让引导过程更安全</p></li><li><p>自由软件基金会(FSF)的Josh Gay对UEFI的”Secure Boot”实现提出忧虑，并发表公开声明及连署说：</p><blockquote><p>我们—连署者—敦促所有实现了UEFI中称为”Secure Boot”的电脑制造商立即允许自由的操作系统可以被安装<br>基于尊重用户的自由权以及确切保护用户安全，制造商必须允许电脑拥有者停用引导限制，或是提供一个确切可能的方法让他们安装并运行自由的操作系统<br>我们承诺我们将不会购买、也不会推荐剥夺用户重要自由的电脑<br>并且，我们将积极地敦促社会大众避免如此禁锢用户的系统</p></blockquote></li><li><p>2012年1月，微软发布一份关于OEM硬件认证的文件</p><blockquote><p>指出所有的x86和x86-64设备应该将UEFI Secure Boot引导<br>不过可以改用一个可让用户增加数字签名的自定义secure boot模式</p></blockquote></li><li><p>RHEL(从RHEL 7开始)，CentOS(从CentOS 7开始)，Debian(从Debian 10开始)等Linux发行版已经支持SecureBoot</p></li></ul><hr><p><strong>其他概念:</strong></p><ul><li>EFI</li><li>UEFI</li><li>BIOS</li><li>RAID</li><li>Option ROM</li><li>CSM</li><li>SecureBoot</li><li>x86-64(AMD64和Intel 64)</li><li>SMBIOS</li><li>ACPI</li></ul><hr><p><strong>外部链接:</strong></p><ul><li><p>EN-统一可扩展固件接口论坛<a href="https://uefi.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://uefi.org/</code></p></blockquote></li><li><p>EN-FSF对于SecureBoot的评价<a href="https://www.fsf.org/campaigns/secure-boot-vs-restricted-boot" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.fsf.org/campaigns/secure-boot-vs-restricted-boot</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Firmware</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>BIOS-1</title>
    <url>/2020/02/18/BIOS-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="BIOS-Basic-Input-Output-System"><a href="#BIOS-Basic-Input-Output-System" class="headerlink" title="BIOS(Basic Input/Output System)"></a>BIOS(Basic Input/Output System)</h3><p><strong>概述:</strong></p><ul><li>基本输入输出系统</li><li>亦称为ROM BIOS、System BIOS、PC BIOS</li><li>是在通电引导阶段运行硬件初始化，以及为操作系统和程序提供运行时服务的固件</li><li>BIOS最早随着CP/M操作系统的推出在1975年出现</li><li>BIOS预安装在个人电脑的主板上，是个人电脑启动时加载的第一个软件</li><li>BIOS用于初始化和测试系统的硬件组件，以及从大容量存储设备(如硬盘)加载引导程序，并由引导程序加载操作系统</li><li>可以理解为是一组固化到计算机内主板上一个ROM芯片上的程序，用于保存计算的基本输入输出的程序以及开机后自检程序和系统自启动程序</li><li>从CMOS中读写系统设置的具体信息</li><li>其主要功能是为计算机提供最底层的、最直接的硬件设置和控制</li></ul><p><strong>相关:</strong></p><ul><li>许多BIOS程序都只能在特定电脑型号或特定主板型号上运行</li><li>早年的BIOS存储于ROM芯片上</li><li>而现在的BIOS多存储于闪存芯片上，以方便BIOS更新</li><li>许多较新的操作系统在引导后不再通过BIOS访问硬件</li><li>系统硬件的变化是由BIOS隐藏，程序使用BIOS功能而不是直接控制硬件</li><li>现代操作系统会忽略BIOS提供的抽象层并直接控制硬件组件</li></ul><hr><ul><li>大约从80386 PC开始，个人电脑的BIOS ROM集成了设置程序(Setup)</li><li>主板的CMOS芯片用于存储BIOS设置值及硬件侦测值</li><li>主板上的钮扣电池用于让CMOS存储BIOS设置值，以及电脑在断电时依然可以让系统时钟运作</li></ul><hr><ul><li>BIOS还为DOS操作系统提供键盘、显示及其他I/O设备的硬件抽象层<blockquote><p>BIOS可通过BIOS中断调用为MS-DOS操作系统及MS-DOS程序提供磁盘、键盘、显示等标准服务<br>通过BIOS中断调用访问视频硬件非常缓慢，因此，有些DOS程序(尤其是游戏)通过直接访问视频硬件提高效率</p></blockquote></li><li>现代操作系统仅在操作系统引导时通过BIOS中断调用访问硬件</li><li>现代的BIOS可以让用户选择由哪个引导设备引导电脑，如光盘驱动器、硬盘、软盘、U盘等等</li><li>旧式的BIOS多半已被UEFI所取代</li></ul><hr><ul><li>自P6微架构开始，Intel处理器支持可重新编程的微码</li><li>BIOS可能包含处理器微代码更新</li><li>一些BIOS支持超频</li></ul><hr><ul><li>BIOS以16位实模式运行<blockquote><p>现代操作系统以保护模式或长模式运行，访问BIOS的16位实模式服务(如BIOS中断调用)是低效的<br>现代操作系统仅在引导时使用BIOS中断调用服务<br>后来的BIOS加入了APM、即插即用规范(PnP)，ACPI等功能</p></blockquote></li></ul><hr><h3 id="运行流程-系统引导"><a href="#运行流程-系统引导" class="headerlink" title="运行流程(系统引导)"></a>运行流程(系统引导)</h3><ol><li>当计算机通电之后，BIOS就会从主板上的ROM芯片运行</li><li>运行加电自检(POST)</li><li>测试和初始化CPU，RAM，直接存储器访问控制器，芯片组，键盘，软盘，硬盘等设备</li><li>当所有的Option ROM被加载后，BIOS就试图从引导设备(如硬盘、软盘、光盘)加载引导程序，由引导程序加载操作系统</li></ol><ul><li>BIOS也可从网卡等设备引导</li></ul><hr><h3 id="BIOS固件"><a href="#BIOS固件" class="headerlink" title="BIOS固件"></a>BIOS固件</h3><ul><li><p>由于BIOS与硬件系统集成在一起(将BIOS程序指令刻录在IC中)，所以有时候也被称为固件</p></li><li><p>在大约1990年BIOS是保存在ROM(只读存储器)中而无法被修改</p></li><li><p>因为BIOS的大小和复杂程度随时间不断增加，而且硬件的更新速度加快，令BIOS也必须不断更新以支持新硬件</p><blockquote><p>于是BIOS就改为存储在EEPROM或者闪存中，让用户可以轻易更新BIOS</p></blockquote></li><li><p>不适当的运行或是终止BIOS更新可能导致电脑无法使用</p><blockquote><p>为了避免BIOS损坏，有些主板有备份的BIOS(“双BIOS”主板)<br>现在的BIOS有”引导区块”(Boot Block)，属于BIOS ROM的一部分，一引导就会被运行<br>这个程序会在运行BIOS前，验证BIOS其他部分是否正确无误(经由检查码，凑杂码等等)<br>如果引导区块侦测到主要的BIOS已损坏，则可自动读取U盘/光盘中的特定BIOS文件并更新BIOS<br>主板厂商/OEM经常发出BIOS升级来更新他们的产品和修正已知的问题</p></blockquote></li></ul><hr><h3 id="CMOS与BIOS"><a href="#CMOS与BIOS" class="headerlink" title="CMOS与BIOS"></a>CMOS与BIOS</h3><ul><li>CMOS是计算机上另一个重要的存储器</li><li>BIOS程序的设置值，硬件参数侦测值被保存在CMOS之中<blockquote><p>而且在BIOS程序引导计算机时，需要加载CMOS中的设置值</p></blockquote></li><li>CMOS通常被集成在南桥芯片组中</li><li>UEFI系统则多用NVRAM存储设置</li></ul><p><strong>BIOS与CMOS的区别</strong></p><ul><li>BIOS是存储在唯读记忆体(EEPROM)</li><li>CMOS为随机存储器(RAM)</li><li>BIOS中存储的是程序，而CMOS中存储的是普通信息</li><li>CMOS的内容在断电会消失<blockquote><p>所以把主板的电池拆出便可重置其内容，同时拆出电池也会重置时间</p></blockquote></li></ul><hr><h3 id="扩展程序（Option-ROM）"><a href="#扩展程序（Option-ROM）" class="headerlink" title="扩展程序（Option ROM）"></a>扩展程序（Option ROM）</h3><ul><li>扩展卡如硬盘控制器、显卡、网卡可能包含BIOS扩展程序(即Option ROM)以为BIOS提供附加的功能</li><li>在BIOS引导操作系统前，Option ROM被BIOS运行</li><li>部分内置于主板的设备(如板载RAID)，其Option ROM可能包含在主板BIOS中</li><li>Option ROM通过BIOS引导规范扩展BIOS的引导功能</li></ul><p><strong>系统初始化</strong></p><ul><li>系统在加电自检(POST)阶段，查找并运行Option ROM</li><li>Option ROM通过BIOS中断调用对硬件进行测试，初始化，并显示诊断信息或显示设置画面</li></ul><hr><h3 id="UEFI简述"><a href="#UEFI简述" class="headerlink" title="UEFI简述:"></a>UEFI简述:</h3><ul><li>因特尔于2000年开发出可扩展固件接口(Extensible Firmware Interface)</li><li>随后，由业界多家著名公司共同成立统一可扩展固件接口论坛(UEFI Forum)</li><li>EFI被更名为UEFI，且由UEFI论坛制定新的UEFI规范</li><li>现时UEFI已经取代传统BIOS，且Intel将于2020年弃用传统BIOS接口</li><li>届时Intel产品不再支持基于16位实模式的UEFI CSM(UEFI兼容性支持模块)</li></ul><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h3><ul><li>BIOS</li><li>SMBIOS</li><li>UEFI</li><li>CMOS</li><li>Option ROM</li><li>固件</li><li>ACPI<blockquote><p>高级配置与电源接口(Advanced Configuration and Power Interface)</p></blockquote></li><li>VEB<blockquote><p>VESA BIOS Extensions是VESA制定的标准</p></blockquote></li><li>Aptio<blockquote><p>AMI基于UEFI规范的下一代BIOS固件<br>将被应用于未来固件可移植性和可扩展性的发展</p></blockquote></li><li>El Torito<blockquote><p>可引导光盘规格</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Firmware</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GPT/GUID-1</title>
    <url>/2020/02/18/GPT-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="硬盘结构-主引导扇区-2-GPT-1"><a href="#硬盘结构-主引导扇区-2-GPT-1" class="headerlink" title="硬盘结构-主引导扇区-2/GPT-1"></a>硬盘结构-主引导扇区-2/GPT-1</h2><ul><li>GPT/GUID对应于MBR</li><li>基于UEFI标准</li></ul><h3 id="MBR-GPT-GPT-GUID"><a href="#MBR-GPT-GPT-GUID" class="headerlink" title="MBR/GPT-GPT/GUID"></a>MBR/GPT-GPT/GUID</h3><ul><li>GPT-全局唯一标识分区表(GUID Partition Table）</li><li>实体硬盘的分区表的结构布局的标准</li><li>是<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>可扩展固件接口(UEFI)标准的一部分</li><li>被用于替代BIOS系统中的一32bits来存储逻辑块地址和大小信息的主引导记录(MBR)分区表</li></ul><hr><ul><li>全局唯一标识符(Globally Unique Identifier,GUID)是一种由算法生成的唯一标识</li><li>通常表示成32个16进制数字(0－9，A－F)组成的字符串<blockquote><p>如:<code>{21EC2020-3AEA-1069-A2DD-08002B30309D}</code>它实质上是一个128位长的二进制整数</p></blockquote></li><li>GUID一词有时也专指微软对UUID标准的实现</li><li>GUID的主要目的是产生完全唯一的数字<blockquote><p>在理想情况下，任何计算机和计算机集群都不会生成两个相同的GUID</p></blockquote></li><li>GUID的总数也足够大，达到了<code>2^128(3.4*10^38)</code>个，所以随机生成两个相同GUID的可能性是非常小的，但并不为0<blockquote><p>所以，用于生成GUID的算法通常都加入了非随机的参数(如时间)，以保证这种重复的情况不会发生</p></blockquote></li></ul><hr><h3 id="GPT-特点"><a href="#GPT-特点" class="headerlink" title="GPT-特点:"></a>GPT-特点:</h3><ul><li>在MBR硬盘中，分区信息直接存储于主引导记录(MBR)中(主引导记录中还存储着系统的引导程序)</li><li>在GPT硬盘中，分区表的位置信息储存在GPT头中</li><li>但由于出于兼容性问题，硬盘的第一个扇区仍然用作MBR，之后才是GPT头</li><li>与现代的MBR一样，GPT也使用逻辑区块地址(LBA)取代了早期的CHS寻址方式</li><li>传统MBR信息存储于LBA 0，GPT头存储于LBA 1，接下来才是分区表本身</li><li>为了减少分区表损坏的风险，GPT在硬盘最后保存了一份分区表的副本</li></ul><hr><h3 id="扇区简述"><a href="#扇区简述" class="headerlink" title="扇区简述"></a>扇区简述</h3><p><strong>第一扇区(LBA 0):</strong></p><ul><li>传统MBR(LBA 0)<blockquote><p>在GPT分区表的最开头，出于兼容性考虑仍然存储了一份传统的MBR<br>它用于防止不支持GPT的硬盘管理工具错误识别并破坏硬盘中的数据<br>这个MBR也可称之为保护MBR<br>不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作<br>可以完全避免用户特别要求删除其分区的危险<br>另外，能够识别GPT分区表的操作系统会检查保护MBR中的分区表<br>如果分区类型不是0xEE或者MBR分区表中有多个项，也会拒绝对硬盘进行操作</p></blockquote></li><li>在支持从GPT启动的操作系统中，这里也用于存储第一阶段的启动代码</li><li>在保护MBR中，只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表</li><li>在使用MBR/GPT混合分区表的硬盘中，这部分存储了GPT分区表的一部分分区(通常是前四个分区)<blockquote><p>可以使不支持从GPT启动的操作系统从这个MBR启动，启动后只能操作MBR分区表中的分区</p></blockquote></li></ul><hr><p><strong>第二分区(LBA 1):</strong></p><ul><li>分区表头(LBA 1)<blockquote><p>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量<br>EFI标准要求分区表最小要有16,384字节，即128个分区项的大小</p></blockquote></li><li>分区表头还记录了这块硬盘的GUID<blockquote><p>记录了分区表头本身的位置和大小(位置总是在LBA 1)以及备份分区表头和分区表的位置和大小(在硬盘的最后)<br>它还储存着它本身和分区表的CRC32校验</p></blockquote></li><li>固件，引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否出错<blockquote><p>如果出错了，可以使用软件从硬盘最后的备份GPT中恢复整个分区表<br>如果备份GPT也校验错误，硬盘将不可使用</p></blockquote></li><li>所以GPT硬盘的分区表不可以直接使用16进制编辑器修改</li><li>主分区表和备份分区表的头分别位于硬盘的第二个扇区(LBA 1)以及硬盘的最后一个扇区</li><li>备份分区表头中的信息是关于备份分区表的</li></ul><hr><p><strong>其他扇区(分区表本身):</strong></p><ul><li><p>GPT的分区表使用简单而直接的方式表示分区</p></li><li><p>一个分区表项的前16字节是分区类型GUID</p></li><li><p>例如</p><blockquote><p>EFI系统分区的GUID类型是<code>{C12A7328-F81F-11D2-BA4B-00A0C93EC93B}</code><br>接下来的16字节是该分区唯一的GUID(这个GUID指的是该分区本身，而之前的GUID指的是该分区的类型)<br>再接下来是分区起始和末尾的64位LBA编号，以及分区的名字和属性</p></blockquote></li></ul><p><strong>GPT分区表项的格式:</strong></p><table><thead><tr><th align="right">起始字节</th><th align="center">长度</th><th align="left">内容</th></tr></thead><tbody><tr><td align="right">0</td><td align="center">16字节</td><td align="left">分区类型GUID</td></tr><tr><td align="right">16</td><td align="center">16字节</td><td align="left">分区GUID</td></tr><tr><td align="right">32</td><td align="center">8字节</td><td align="left">起始LBA(小端序)</td></tr><tr><td align="right">40</td><td align="center">8字节</td><td align="left">末尾LBA</td></tr><tr><td align="right">48</td><td align="center">8字节</td><td align="left">属性标签(如:60表示”只读”)</td></tr><tr><td align="right">56</td><td align="center">72字节</td><td align="left">分区名(可以包括36个UTF-16(小端序)字符)</td></tr></tbody></table><hr><ul><li>MBR与GPT之间提供了互相转换的机制</li><li>对于不同内核的操作系统有不同的GUID分区类型支持</li></ul><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>GPT/GUID</li><li>MBR</li><li>LBA(逻辑区块地址)</li><li>CHS(早期寻址方式)</li><li>UEFI</li><li>BIOS</li><li>磁道(Track)</li><li>柱面(Cylinder)</li><li>扇区(Sector)</li><li>磁头(Heads)</li><li>盘片(Platters)</li><li>磁盘的物理结构</li><li>磁盘的逻辑结构</li></ul><hr><p><strong>补充内容:</strong></p><p><strong>分区表头的格式:</strong></p><table><thead><tr><th align="right">起始字节</th><th align="center">长度</th><th align="left">内容</th></tr></thead><tbody><tr><td align="right">0</td><td align="center">8字节</td><td align="left">签名(“EFI PART”, 45 46 49 20 50 41 52 54)</td></tr><tr><td align="right">8</td><td align="center">4字节</td><td align="left">修订(在1.0版中，值是00 00 01 00)</td></tr><tr><td align="right">12</td><td align="center">4字节</td><td align="left">分区表头的大小(单位是字节，通常是92字节，即5C 00 00 00)</td></tr><tr><td align="right">16</td><td align="center">4字节</td><td align="left">分区表头(第0－91字节)的CRC32校验，在计算时，把这个字段作为0处理，需要计算出分区序列的CRC32校验后再计算本字段</td></tr><tr><td align="right">20</td><td align="center">4字节</td><td align="left">保留，必须是0</td></tr><tr><td align="right">24</td><td align="center">8字节</td><td align="left">当前LBA(这个分区表头的位置)</td></tr><tr><td align="right">32</td><td align="center">8字节</td><td align="left">备份LBA(另一个分区表头的位置)</td></tr><tr><td align="right">40</td><td align="center">8字节</td><td align="left">第一个可用于分区的LBA(主分区表的最后一个LBA＋1)</td></tr><tr><td align="right">48</td><td align="center">8字节</td><td align="left">最后一个可用于分区的LBA(备份分区表的第一个LBA-1)</td></tr><tr><td align="right">56</td><td align="center">16字节</td><td align="left">硬盘GUID(在类UNIX系统中也叫UUID)</td></tr><tr><td align="right">72</td><td align="center">8字节</td><td align="left">分区表项的起始LBA(在主分区表中是2)</td></tr><tr><td align="right">80</td><td align="center">4字节</td><td align="left">分区表项的数量</td></tr><tr><td align="right">84</td><td align="center">4字节</td><td align="left">一个分区表项的大小(通常是128)</td></tr><tr><td align="right">88</td><td align="center">4字节</td><td align="left">分区序列的CRC32校验</td></tr><tr><td align="right">92</td><td align="center"><code>*</code></td><td align="left">保留，剩余的字节必须是0(对于512字节LBA的硬盘即是420个字节)</td></tr></tbody></table><hr><h3 id="图解补充"><a href="#图解补充" class="headerlink" title="图解补充"></a>图解补充</h3><ul><li>GPT/GUID结构图例说明:</li></ul><img src="/images/disk-images/GPT分区表结构图示.png" width="40%" height="40%"><ul><li>此例中，每个逻辑块(LBA)为512字节，每个分区的记录为128字节</li><li>负数的LBA地址表示从最后的块开始倒数，-1表示最后一个块</li><li>图片来源于: <a href="https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8</a></li></ul><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">被Intel用于替代个人计算机的BIOS</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Disk</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>MBR-1</title>
    <url>/2020/02/18/MBR-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="硬盘结构-主引导扇区-1-MBR-1"><a href="#硬盘结构-主引导扇区-1-MBR-1" class="headerlink" title="硬盘结构-主引导扇区-1/MBR-1"></a>硬盘结构-主引导扇区-1/MBR-1</h2><ul><li>以下内容中的MBR特指主引导记录，而不泛指主引导扇区</li><li>主引导扇区泛指以下的所有内容</li><li>磁盘-机械硬盘概念</li></ul><h3 id="MBR主引导记录-master-boot-record"><a href="#MBR主引导记录-master-boot-record" class="headerlink" title="MBR主引导记录(master boot record)"></a>MBR主引导记录(master boot record)</h3><ul><li><p>计算机访问硬盘时所必须读取的首个分区</p></li><li><p>用于记录本身的相关信息与硬盘各个分区的大小及位置信息</p></li><li><p>还包含了基本数据结构的信息</p></li><li><p>硬盘上的三维地址(柱面，磁头，扇区)=(0,0,1)</p></li><li><p>开头的446字节内容</p><blockquote><p>后4个16个字节为磁盘分区表(DPT)<br>结束标志字:2字节结束标准(55AA)</p></blockquote></li><li><p>对于硬盘而言，一个扇区可能的字节数为128×2n(n=0,1,2,3)</p><blockquote><p>大多情况下，取n=2，即一个扇区(sector)的大小为512字节</p></blockquote></li></ul><p><strong>MBR主引导记录构成:</strong></p><ul><li>启动代码<blockquote><p>主引导记录最开头的第一阶段是引导代码<br>其中的硬盘引导程序的主要作用是检查分区表是否正确<br>同时在系统硬件完成自检后将控制权交给硬盘上的引导程序(如GNU GRUB)<br>此阶段不依赖任何操作系统<br>启动代码可以改变，以用于实现多系统引导</p></blockquote></li></ul><hr><h3 id="磁盘分区表-DPT"><a href="#磁盘分区表-DPT" class="headerlink" title="磁盘分区表(DPT)"></a>磁盘分区表(DPT)</h3><ul><li><p>磁盘分区表占据主引导扇区的64个字节(偏移01BEH–偏移01FDE)</p></li><li><p>可对四个分区的信息进行描述，其中每个分区的信息占据16个字节</p></li><li><p>字节定义:参考硬盘分区结构信息</p></li><li><p>示例:</p></li><li><p>假设某一分区在硬盘分区表的信息:</p><blockquote><p><code>80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00</code></p></blockquote></li><li><p>说明:</p><blockquote><p>最前面的”80”是一个分区的激活标志，表示系统可引导<br>“01 01 00”表示分区开始的磁头号为1，开始的扇区号为1，开始的柱面号为0<br>“0B”表示分区的系统类型是FAT32，其他比较常用的有04(FAT16)，07(NTFS)<br>“FE BF FC”表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764<br>“3F 00 00 00”表示首扇区的相对扇区号为63(小端序)<br>“7E 86 BB 00”表示总扇区数为12289662(小端序)</p></blockquote></li><li><p>对于大于8.4G的现代硬盘，CHS已经无法表示, BIOS使用LBA模式</p><blockquote><p>对于超出的部分，CHS值通常设为0xFEFFFF，并加以忽略<br>直接使用Offset 0x08-0x0c的4字节相对值，再进行内部转换</p></blockquote></li><li><p>结束标志字55，AA(偏移1FEH－偏移1FFH)</p><blockquote><p>最后两个字节是检验主引导记录是否有效的标志</p></blockquote></li></ul><hr><h3 id="主引导扇区读取逻辑-流程"><a href="#主引导扇区读取逻辑-流程" class="headerlink" title="主引导扇区读取逻辑(流程):"></a>主引导扇区读取逻辑(流程):</h3><ol><li>BIOS加电/引导自检(Power On Self Test – POST)<blockquote><p>BIOS执行内存地址为FFFF:0000H处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件(包括内存)进行检查</p></blockquote></li><li>读取主引导记录(MBR)<blockquote><p>当BIOS检查到硬件正常并与CMOS中的设置相符后，按照CMOS中对启动设备的设置顺序检测可用的启动设备<br>BIOS将相应启动设备的第一个扇区(也就是MBR扇区)读入内存地址为0000:7C00H处</p></blockquote></li><li>检查0000:7DFEH-0000:7DFFH(MBR的结束标志位)是否等于55AAH，若不等于则转去尝试其他启动设备<blockquote><p>如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机</p></blockquote></li><li>检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备<blockquote><p>启动设备的MBR将自己复制到0000:0600H处，然后继续执行</p></blockquote></li><li>根据MBR中的引导代码启动引导程序(如GNU GRUB)</li></ol><ul><li>BIOS不仅检查0000:7DFEH-0000:7DFFH（MBR的结束标志位）是否等于55AAH，往往还对磁盘是否有写保护、主引导扇区中是否存在活动分区等进行检查</li><li>如果发现磁盘有写保护，则显示磁盘写保护出错信息</li><li>如果发现磁盘中不存在活动分区，则显示类似如下的信息“Remove disk or other media Press any key to restart”</li></ul><hr><h3 id="硬盘分区简述"><a href="#硬盘分区简述" class="headerlink" title="硬盘分区简述:"></a>硬盘分区简述:</h3><ul><li><p>MBR(主引导记录)只包含了64个字节的DPT(磁盘分区表)</p><blockquote><p>因为每个分区需要占有16个字节，所以对于MBR型分区结构的硬盘，最多只能识别4个主要分区(Primary partition)<br>如果此时想要得到4个以上的主要分区，就需要引出拓展分区了<br>拓展分区被归类为主分区(是主分区的一种)<br>但与主分区在理论上不同的是拓展分区可以被划分为无数个逻辑分区</p></blockquote></li><li><p>拓展分区</p><blockquote><p>拓展分区中的逻辑驱动器的引导记录是链式的<br>每个逻辑分区都有一个扩展引导记录(EBR/结构类似于MBR)<br>其中表的第一项指向逻辑分区本身的引导扇区<br>第二项指向下一个逻辑驱动器的EBR，分区表的第三，第四项没有用到</p></blockquote></li><li><p>windows操作系统在一般情况下，只会划分一个主分区用于存储操作系统，其余全部划入拓展分区</p></li><li><p><code>[1-主分区]-[3-逻辑分区-&gt;N-逻辑分区]</code></p></li></ul><hr><p><strong>MBR分区表与GPT分区表</strong></p><ul><li><p>MBR分区表</p><blockquote><p>MBR磁盘分区样式支持的最大卷为2TB(Terabytes)，并且最多四个主分区(或3个主分区，1个扩展分区和无限制的逻辑驱动器)</p></blockquote></li><li><p>GPT分区表</p><blockquote><p>GPT磁盘分区样式在理论上最大支持128个分隔，一个分割最大18 EB(Exabytes)<br>GPT分区磁盘有备份分区表，用以提高分区数据结构的完整性<br>如果硬盘太大则必须改用GPT</p></blockquote></li><li><p>操作系统限制问题</p><blockquote><p>分区表本身需要占有一定空间，规划硬盘时留给分区表的空间决定了最多可以有多少个分区<br>IA-64版Windows限制最多有128个分区，同时这也是EFI规定的分区表最小尺寸<br>GPT与MBR在分区的磁盘不同点是GPT将至关重要的平台操作系统位于分区，而非位于非分区或隐藏分区<br>在UEFI系统上，通常是通过ESP分区中的EFI应用程序文件来引导GPT硬盘上的操作系统，而不是活动主分区上的引导程序</p></blockquote></li><li><p>系统分区可以设为活动主分区，但不是必须的，需要根据引导程序而定</p></li><li><p>一个硬盘的分区个数还要受到分区大小的限制，因为硬盘是按照柱面分区的：一个分区至少要占一个柱面</p></li><li><p>现在的硬盘结构已经和老式硬盘有了很大区别，其寻址结构也不再是CHS寻址，所以这里的柱面大小不同于相关软件显示的柱面大小</p></li><li><p>对于物理结构上有n个面的硬盘，其分区空间的最小值为:<code>n*扇区/磁道*512字节</code></p></li><li><p>根据16字节分区表的结构:当前分区的扇区数用4个字节表示，前面各分区扇区数的总和也是4个字节，而<code>232*512 ＝ 2 199 023 255 552 Byte</code></p></li></ul><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念:"></a>相关概念:</h3><ul><li>BIOS</li><li>UEFI</li><li>MBR</li><li>GPT-GUID/GPT<blockquote><p>GUID磁碟分割表<br>全局唯一标识分区表<br>是一个实体硬盘的分区表的结构布局的标准</p></blockquote></li><li>主分区/拓展分区/逻辑分区</li><li>磁盘/操作系统文件系统<blockquote><p>FAT/exFAT/NTFS</p></blockquote></li><li>RAM</li><li>ROM</li><li>BOOT</li><li>GURB</li><li>CHS<blockquote><p>柱面-磁头-扇区(Cylinder-head-sector)<br>是早期对硬盘驱动器的每一个物理数据块进行编址的一种方法<br>就软盘驱动器而言，可对同一磁盘介质进行低级格式化而得到不同的容量</p></blockquote></li><li>LBA</li><li>EFI<blockquote><p>可扩展固件接口标准</p></blockquote></li><li>Buffer<blockquote><p>硬盘缓存</p></blockquote></li><li>硬盘数据接口<blockquote><p>ATA/SATA/SCSI/SAS/FC/电源接口</p></blockquote></li><li>逻辑结构(机械硬盘)</li><li>物理结构(机械硬盘)</li><li>机械/固态/混合/硬盘/软盘</li></ul><hr><h3 id="相关内容补充"><a href="#相关内容补充" class="headerlink" title="相关内容补充:"></a>相关内容补充:</h3><p><strong>硬盘分区结构信息</strong></p><table><thead><tr><th align="left">偏移</th><th align="left">长度(字节)</th><th align="left">意义</th></tr></thead><tbody><tr><td align="left">00H</td><td align="left">1</td><td align="left">分区状态:00–&gt;非活动分区；80–&gt;活动分区(其它数值没有意义)</td></tr><tr><td align="left">01H</td><td align="left">1</td><td align="left">分区起始磁头号(HEAD)，用到全部8位</td></tr><tr><td align="left">02H</td><td align="left">2</td><td align="left">分区起始扇区号(SECTOR)，占据02H的位0－5；该分区的起始磁柱号(CYLINDER)，占据02H的位6－7和03H的全部8位</td></tr><tr><td align="left">04H</td><td align="left">1</td><td align="left">文件系统标志位</td></tr><tr><td align="left">05H</td><td align="left">1</td><td align="left">分区结束磁头号(HEAD)，用到全部8位</td></tr><tr><td align="left">06H</td><td align="left">2</td><td align="left">分区结束扇区号(SECTOR)，占据06H的位0－5；该分区的结束磁柱号(CYLINDER)，占据06H的位6－7和07H的全部8位</td></tr><tr><td align="left">08H</td><td align="left">4</td><td align="left">分区起始相对扇区号</td></tr><tr><td align="left">0CH</td><td align="left">4</td><td align="left">分区总的扇区数</td></tr></tbody></table><hr><p><strong>标准MBR结构</strong></p><p><strong>准确地址长度与描述:</strong></p><table><thead><tr><th align="center">Hex</th><th align="center">Oct</th><th align="center">Dec</th><th align="center">描述</th><th align="center">长度(字节)</th></tr></thead><tbody><tr><td align="center">0000</td><td align="center">0000</td><td align="center">0</td><td align="center">代码区</td><td align="center">440(最大446)</td></tr><tr><td align="center">01B8</td><td align="center">0670</td><td align="center">440</td><td align="center">选用磁盘标志</td><td align="center">4</td></tr><tr><td align="center">01BC</td><td align="center">0674</td><td align="center">444</td><td align="center">一般为空值; 0x0000</td><td align="center">2</td></tr><tr><td align="center">01BE</td><td align="center">0676</td><td align="center">446</td><td align="center">标准MBR分区表规划(四个16 byte的主分区表入口)</td><td align="center">64</td></tr><tr><td align="center">01FE</td><td align="center">0776</td><td align="center">510</td><td align="center">55h-(MBR有效标志:0x55AA)</td><td align="center">1</td></tr><tr><td align="center">01FF</td><td align="center">0777</td><td align="center">511</td><td align="center">AAh-(MBR有效标志:0x55AA)</td><td align="center">1</td></tr></tbody></table><ul><li>MBR总大小:446字节+64字节+2字节=512字节(长度)</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>CN-Linux引导程序<a href="https://www.ibm.com/developerworks/cn/linux/l-linuxboot/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.ibm.com/developerworks/cn/linux/l-linuxboot/</code></p></blockquote></li><li><p>CN-FAT详解-1<a href="https://web.archive.org/web/20090725091233/http://www.raid-recovery.org/Article/sjhfdoc/200404/1.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://web.archive.org/web/20090725091233/http://www.raid-recovery.org/Article/sjhfdoc/200404/1.html</code></p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>引导扇区:</strong></p><ul><li><p>引导扇区是硬盘、软盘或类似的数据存储设备的一个扇区</p><blockquote><p>内含负责引导(booting)”存放在碟片(disk)的其他部分的程序(通常，但不必然是操作系统)”的机器代码</p></blockquote></li><li><p>引导扇区有两种:</p></li><li><p>Volume Boot Record</p><blockquote><p>是磁盘未被分割的第一个扇区，或已分割的分区的第一个扇区，包含了加载与唤起操作系统(放在这个分区之内或放在这个磁盘上)的码</p></blockquote></li><li><p>Master Boot Record</p><blockquote><p>是磁盘已被分割的第一个扇区，它包含定位活动分区与唤起它的VBR的码</p></blockquote></li><li><p>IBM PC兼容机上，BIOS不在意VBR与MBR的不同，甚至分区</p></li><li><p>固件只是加载并运行磁盘的第一个扇区(sector)，在MBR里的码，才知道磁盘分割消息，且是负责加载引导活动分区的VBR<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的地方</p></li></ul><hr><h3 id="LVM-逻辑卷管理器"><a href="#LVM-逻辑卷管理器" class="headerlink" title="LVM(逻辑卷管理器)"></a>LVM(逻辑卷管理器)</h3><p><strong>概述:</strong></p><ul><li>LVM(Logical Volume Manager)</li><li>又译为逻辑卷宗管理器、逻辑扇区管理器、逻辑磁盘管理器</li><li>是Linux核心所提供的逻辑卷管理(Logical volume management)功能</li><li>它在硬盘的硬盘分区之上，又创建一个逻辑层，以方便系统管理硬盘分割系统</li><li>最先由IBM开发，在AIX系统上实现</li></ul><p><strong>LVM基本术语:</strong></p><ul><li><p>PV</p><blockquote><p>物理卷，PV处于LVM系统最低层，它可以是整个硬盘，或者与磁盘分区具有相同功能的设备(如RAID)<br>但和基本的物理存储介质相比较，多了与LVM相关管理参数</p></blockquote></li><li><p>VG</p><blockquote><p>卷组，创建在PV之上，由一个或多个PV组成，可以在VG上创建一个或多个”LVM分区”(逻辑卷)<br>功能类似非LVM系统的物理硬盘</p></blockquote></li><li><p>LV</p><blockquote><p>逻辑卷，从VG中分割出的一块空间，创建之后其大小可以伸缩，在LV上可以创建文件系统(如/var,/home)</p></blockquote></li><li><p>PE</p><blockquote><p>物理区域，每一个PV被划分为基本单元(也被称为PE)，具有唯一编号的PE是可以被LVM寻址的最小存储单元<br>默认为4MB</p></blockquote></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>Linux file system(Linux文件系统)</li><li>Linux内核支持文件系统</li><li>Unix文件系统</li><li>扩展文件属性</li><li>逻辑卷轴管理</li><li>引导扇区</li><li>磁盘分区</li><li>分区表</li></ul><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">可变码率VBR(Variable bitrate)VBR和该词相对应的词是固定码率CBR(constant bit rate)/(内容有关数据压缩算法)</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Disk</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Debian GNU/Linux-1</title>
    <url>/2020/02/18/Debian-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Debian-GNU-Linux-1"><a href="#Debian-GNU-Linux-1" class="headerlink" title="Debian GNU/Linux-1"></a>Debian GNU/Linux-1</h3><ul><li>通用软件包管理与操作的解决方案</li><li>一:<code>apt-get</code>一条龙的全自动化解决</li><li>二:<code>wget/curl</code>获取-&gt;<code>dpkg/autoconf</code>安装-&gt;设置环境变量-&gt;设置别名</li><li><code>apt-get/dpkg/wget/curl</code>都可用户依赖解决</li></ul><hr><ul><li>目录:</li></ul><ol><li>apt-get</li><li>curl</li><li>wget</li><li>dpkg</li><li>autoconf-configure/make</li><li>env/export</li><li>set/declare</li><li>alias</li></ol><hr><h3 id="Debian内软件获取与卸载方法简述"><a href="#Debian内软件获取与卸载方法简述" class="headerlink" title="Debian内软件获取与卸载方法简述"></a>Debian内软件获取与卸载方法简述</h3><p><strong>APT-GET包管理器参数简述</strong></p><ul><li><p>从镜像源仓库拉取软件包并于本地自动配置</p><blockquote><p><code>$apt-get install package_name</code></p></blockquote></li><li><p>联网解决或清理依赖关系</p><blockquote><p><code>$apt-get install -f</code></p></blockquote></li><li><p>刷新本地镜像源仓库索引</p><blockquote><p><code>$apt-get updata</code></p></blockquote></li><li><p>更新本地镜像源仓库与所有可更新软件包</p><blockquote><p><code>$apt-get upgrade</code></p></blockquote></li><li><p>查看软件包依赖</p><blockquote><p><code>$apt-get show</code><br><code>$apt-cache show depends package_name</code></p></blockquote></li><li><p>查看仓库内软件包列表</p><blockquote><p><code>$apt-get search</code><br><code>$apt-cache search package_name</code></p></blockquote></li><li><p>卸载软件包及其配置文件</p><blockquote><p><code>$apt purge/apt remove</code><br><code>$apt-get -purge remove package_name</code></p></blockquote></li><li><p>删除软件包备份</p><blockquote><p><code>$apt-get clean</code></p></blockquote></li><li><p>镜像源目录:</p><blockquote><p><code>/etc/apt/sources.list</code></p></blockquote></li><li><p>还有很多用于包管理与镜像管理的软件与程序</p><blockquote><p>conda,npm等等…</p></blockquote></li><li><p>CentOS体系</p><blockquote><p>yum/rpm</p></blockquote></li></ul><hr><h3 id="URL拉取工具"><a href="#URL拉取工具" class="headerlink" title="URL拉取工具"></a>URL拉取工具</h3><ul><li>拉取所选网页内所有资源，多用于直接从远端仓库拉源码至本地</li></ul><p><strong>CURL</strong></p><blockquote><p><code>$curl [URL(选项)] [参数(options)]</code></p></blockquote><p><strong>WGET</strong></p><blockquote><p><code>$wget [URL(选项)] [参数(options)]</code></p></blockquote><ul><li>参数简述:<blockquote><p><code>-r</code>下载整个网站<br><code>-c</code>断点续传<br><code>-i</code>批量下载<br><code>--help/man</code></p></blockquote></li></ul><hr><h3 id="Dpkg"><a href="#Dpkg" class="headerlink" title="Dpkg"></a>Dpkg</h3><ul><li><p>用于管理Debian包的工具</p></li><li><p>安装已有包</p><blockquote><p><code>$dpkg -i package_name.deb</code></p></blockquote></li><li><p>安装目录下的所有包</p><blockquote><p><code>$dpkg -R /文件目录</code></p></blockquote></li><li><p>查看软件包安装位置</p><blockquote><p><code>$dpkg -L 软件包</code></p></blockquote></li><li><p>卸载一个包及其配置信息</p><blockquote><p><code>$dpkg -P package_name</code></p></blockquote></li></ul><blockquote><p><code>--help/man</code></p></blockquote><hr><h3 id="源码包安装与管理"><a href="#源码包安装与管理" class="headerlink" title="源码包安装与管理"></a>源码包安装与管理</h3><p><strong>autotools</strong></p><ul><li><p>保证下载来的源码包已经有makefile和由autoconf生存的configure脚本</p></li><li><p>根据makefile运行configure脚本并选择安装路径</p><blockquote><p><code>$./configure --prefix=/安装目录</code></p></blockquote></li><li><p>用make进行源码编译</p><blockquote><p><code>$make</code></p></blockquote></li><li><p>使用make安装</p><blockquote><p><code>$make install</code></p></blockquote></li><li><p>还有很多参数<code>--help</code>或<code>man</code></p></li><li><p>在source内执行make uninstall卸载软件包</p></li><li><p>正常情况下source内的makefile都能写uninstall</p></li><li><p>没有makefile的话看makefile的安装项，挨个删除</p></li><li><p>如果连source被删了的话，那没法了</p></li></ul><hr><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><ul><li><p>tar -zxvf xxx.tar</p></li><li><p>zip xxx.zip</p></li><li><p>gzip xxx.gzip</p></li><li><p>解压没什么好说的</p></li></ul><hr><h3 id="环境变量与自定义变量"><a href="#环境变量与自定义变量" class="headerlink" title="环境变量与自定义变量"></a>环境变量与自定义变量</h3><p><strong>配置环境变量与自定义变量(PATH变量/Shell变量)</strong></p><ul><li>系统变量/用户变量</li></ul><p><strong>PATH变量</strong></p><ul><li><p>查看PATH变量列表(内容)</p><blockquote><p><code>$echo $PATH</code></p></blockquote></li><li><p>PATH变量的默认优先于用户的可执行程序</p></li><li><p>用export工具向PATH内添加内容</p><blockquote><p><code>export PATH=$PATH:/可执行文件所在目录/</code></p></blockquote></li><li><p>此时添加的是永久变量</p></li><li><p>export命令基本格式</p><blockquote><p><code>export [-fnp][变量名称]=[变量设置值]</code></p></blockquote></li><li><p>可执行文件目录说明:</p><blockquote><p>可执行文件多存于<code>/usr/local/bin</code>与<code>/usr/bin</code>内<br><code>/usr/local/bin</code>优先于<code>/usr/bin</code><br><code>/usr/bin</code>目录用于存放系统预装的可执行程序文件<br><code>/usr/local/bin</code>目录用于存放用户的可执行的文件，系统升级会覆盖此目录</p></blockquote></li></ul><hr><ul><li><p>用set工具添加环境变量与自定义变量</p></li><li><p>set用于添加session(会话)级别环境变量</p></li><li><p>语句形式</p><blockquote><p><code>set PATH=/usr/local/xxx/bin</code></p></blockquote></li><li><p>或用declare定义新变量:</p><blockquote><p><code>declare 变量名=&#39;变量值&#39;</code></p></blockquote></li></ul><hr><p><strong>env/export/set/declare简述</strong></p><ul><li><p>env 和 export 显示环境变量</p><blockquote><p>env 显示系统级别的环境变量，不显示自定义<br>export 功能与env相同，只不过会根据变量名进行排序</p></blockquote></li><li><p>set 和 declare 显示环境变量和自定义变量</p><blockquote><p>set 显示用户级别的环境变量，显示自定义<br>declare 显示所有级别的变量</p></blockquote></li><li><p>export用于管理env，set用于管理declare</p></li><li><p>set 用来显示本地变量</p></li><li><p>env 用来显示环境变量</p></li><li><p>export 用来显示和设置环境变量</p></li><li><p>set 显示当前shell的变量，包括当前用户的变量</p></li><li><p>env 显示当前用户的变量</p></li><li><p>export 显示当前导出成用户变量的shell变量</p></li></ul><hr><ul><li>清除用户级别环境变量<blockquote><p><code>unset 变量名</code></p></blockquote></li></ul><p><strong>变量所在目录</strong></p><ul><li><p>普通用户</p><blockquote><p><code>~/home/.bashrc</code></p></blockquote></li><li><p>root用户</p><blockquote><p><code>~/.bashrc</code><br><code>~/etc/profile</code></p></blockquote></li><li><p>权限足够时可以直接对其进行修改与管理</p></li><li><p>其他概念</p></li><li><p><code>~/.bashrc</code></p></li><li><p><code>~/.bash_profile</code></p></li><li><p><code>~/etc/profile</code></p></li><li><p><code>~/etc/environment</code></p></li></ul><p><strong>usr全称:Unix System Resource</strong></p><hr><h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><ul><li><p>使用alias工具对指令设置别名</p></li><li><p>基本格式:</p><blockquote><p><code>$alias[别名]=[指令名称]</code></p></blockquote></li></ul><hr><p><strong>Debian各版本开发代号</strong></p><table><thead><tr><th align="left">代号</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">下一代Debian正式发行版的代号为bullseye</td><td align="left">发布时间尚未确定</td></tr><tr><td align="left">Debian 10(buster)</td><td align="left">当前的稳定版(stable)</td></tr><tr><td align="left">Debian 9(stretch)</td><td align="left">旧的稳定版(oldstable)</td></tr><tr><td align="left">Debian 8(jessie)</td><td align="left">更旧的稳定版(oldoldstable)</td></tr><tr><td align="left">Debian 7(wheezy)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian 6.0(squeeze)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian GNU/Linux 5.0(lenny)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian GNU/Linux 4.0(etch)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian GNU/Linux 3.1(sarge)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian GNU/Linux 3.0(woody)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian GNU/Linux 2.2(potato)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian GNU/Linux 2.1(slink)</td><td align="left">被淘汰的稳定版</td></tr><tr><td align="left">Debian GNU/Linux 2.0(hamm)</td><td align="left">被淘汰的稳定版</td></tr></tbody></table><hr><p><strong>debian中文乱码解决方法:</strong></p><p><strong>安装locales</strong></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> -y update</span><br><span class="line">apt-<span class="builtin-name">get</span> install -y locales</span><br><span class="line">dpkg-reconfigure locales</span><br></pre></td></tr></table></figure><ul><li><p>选择并设置字符编码</p><blockquote><p><code>en_US.UTF-8</code><br><code>zh_CN.UTF-8</code></p></blockquote></li><li><p>最后选择默认默认<code>ZH_CN.UTF-8</code></p></li><li><p>在界面中可以勾选<code>en_US.UTF-8</code>和<code>zh_CN.UTF-8</code></p></li><li><p>然后选择<code>zh_CN.UTF-8</code>为默认的LOCALE，则系统为中文界面(这里也可以选<code>en_US.UTF-8</code>，使系统为英文界面)</p></li><li><p>检查当前locale环境</p><blockquote><p><code>locale</code></p></blockquote></li><li><p>如果是正确的则会输出<code>LANG =zh_CN.UTF-8</code></p></li></ul><p><strong>如果还有问题:</strong></p><ul><li><p>安装字体</p><blockquote><p><code>apt-get install ttf-wqy-zenhei -y</code></p></blockquote></li><li><p>安装输入法</p><blockquote><p><code>apt-get install ibus ibus-gtk ibus-pinyin -y</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>GNU/Linux</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB-4</title>
    <url>/2020/02/17/MongoDB-4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MongoDB-4"><a href="#MongoDB-4" class="headerlink" title="MongoDB-4"></a>MongoDB-4</h3><ul><li>剩余概念补充-1</li></ul><p><strong>概念简述:</strong></p><ol><li>管道</li><li>复制原理(创建副本集)</li><li>分片技术(集群)</li></ol><hr><ol><li><strong>管道(聚合)</strong></li></ol><ul><li>管道在Unix和Linux中一般用于将当前命令的输出结果作为下一个命令的参数</li><li>MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理</li><li>管道操作是可以重复的</li><li>表达式：处理输入文档并输出</li><li>表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档</li></ul><p><strong>常用聚合框架(模式)一览:</strong></p><table><thead><tr><th align="left">框架</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">$project</td><td align="left">修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档</td></tr><tr><td align="left">$match</td><td align="left">用于过滤数据，只输出符合条件的文档，$match使用MongoDB的标准查询操作</td></tr><tr><td align="left">$limit</td><td align="left">用来限制MongoDB聚合管道返回的文档数</td></tr><tr><td align="left">$skip</td><td align="left">在聚合管道中跳过指定数量的文档，并返回余下的文档</td></tr><tr><td align="left">$unwind</td><td align="left">将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值</td></tr><tr><td align="left">$group</td><td align="left">将集合中的文档分组，可用于统计结果</td></tr><tr><td align="left">$sort</td><td align="left">将输入文档排序后输出</td></tr><tr><td align="left">$geoNear</td><td align="left">输出接近某一地理位置的有序文档</td></tr></tbody></table><hr><ol start="2"><li>MongoDB复制原理(创建副本集)</li></ol><ul><li><p>MongoDB复制是将数据同步在多个服务器的过程</p></li><li><p>复制提供了数据的冗余备份，并在多个服务器上存储数据副本，提高了数据的可用性， 并可以保证数据的安全性</p></li><li><p>复制还允许从硬件故障和服务中断中恢复数据</p></li><li><p>复制作用:</p><blockquote><p>保障数据的安全性<br>数据高可用性<code>(24*7)</code><br>灾难恢复<br>无需停机维护(如备份，重建索引，压缩)<br>分布式读取数据</p></blockquote></li></ul><p><strong>MongoDB复制原理</strong></p><ul><li><p>mongodb的复制至少需要两个节点</p><blockquote><p>其中一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据</p></blockquote></li><li><p>mongodb各个节点常见的搭配方式为：一主一从、一主多从</p></li><li><p>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作</p><blockquote><p>然后对本地的数据副本执行这些操作，从而保证从节点的数据与主节点一致</p></blockquote></li><li><p>复制的逻辑结构简述:</p></li><li><p>客户端从主节点读取数据，在客户端写入数据到主节点时， 主节点与从节点进行数据交互保障数据的一致性</p><blockquote><p><code>Client Application-Write/Reads-&gt;Primary-Replication/Replication-&gt;Secondary/Secondary</code></p></blockquote></li></ul><hr><p><strong>MongoDB副本集设置</strong></p><ol><li>利用同一个MongoDB来做MongoDB主从模型</li><li>通过指定<code>--replSet</code>选项来启动mongoDB，<code>--replSet</code>基本语法格式如下:<blockquote><p><code>mongod --port &quot;PORT&quot; --dbpath &quot;YOUR_DB_DATA_PATH&quot; --replSet &quot;REPLICA_SET_INSTANCE_NAME&quot;</code></p></blockquote></li></ol><p><strong>参数说明:</strong></p><ol><li><code>REPLICA_SET_INSTANCE_NAME</code>为所选实例命名</li><li>指定MongoDB实例所处端口(端口号)</li><li>此时会启动并连接MongoDB服务</li><li>在Mongo客户端可以使用命令<code>rs.initiate()</code>来启动一个新的副本集</li><li>可以使用<code>rs.conf()</code>来查看副本集的配置</li><li>查看副本集状态执行<code>rs.status()</code>命令</li></ol><p><strong>副本集特征:</strong></p><ul><li><p>N 个节点的集群</p></li><li><p>任何节点可作为主节点</p></li><li><p>所有写入操作都在主节点上</p></li><li><p>自动故障转移</p></li><li><p>自动恢复</p></li><li><p>rs.add()方法用于添加副本集的成员</p></li><li><p>rs.add() 命令基本语法格式:</p><blockquote><p><code>rs.add(HOST_NAME:PORT)</code></p></blockquote></li></ul><ul><li><p>MongoDB中只能通过主节点将Mongo服务添加到副本集中</p><blockquote><p>判断当前运行的Mongo服务是否为主节点可以使用命令<code>db.isMaster()</code></p></blockquote></li><li><p>MongoDB的副本集与常见的主从有所不同</p><blockquote><p>主从在主机宕机后所有服务将停止<br>而副本集在主机宕机后<br>副本会接管主节点成为主节点<br>不会出现宕机现象</p></blockquote></li></ul><hr><ol start="3"><li><strong>分片技术(集群)</strong></li></ol><ul><li>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求</li><li>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量<blockquote><p>此时就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据</p></blockquote></li></ul><p><strong>分片技术的作用:</strong></p><ul><li>复制所有的写入操作到主节点</li><li>延迟的敏感数据会在主节点查询</li><li>有效解决单个副本集限制在12个节点的问题</li><li>能解决当请求量巨大时会出现内存不足</li><li>能够解决本地磁盘不足</li><li>可以避免价格昂贵的垂直扩展</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>(APP Server[Router(mongos)])|(APP Server[Router(mongos)])&lt;-2 or more Routes-&gt;&lt;-&gt;(3*Config Server)&lt;-&gt;&lt;-2 or more Shards-&gt;(Shard(replica set))|(Shard(replica set))</code></p></blockquote><ul><li><p>组件描述:</p><blockquote><p>Shard:用于存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障<br>Config Server:mongod实例，存储了整个 ClusterMetadata，其中包括 chunk信息<br>Query Routers:前端路由，客户端由此接入，且让整个集群看上去像单一数据库，前端应用可以透明使用</p></blockquote></li><li><p>实例不进行阐述</p></li></ul><hr><p><strong>其它概念:</strong></p><ol><li>数据备份与恢复</li><li>监控部署</li><li>其他语言接口</li><li>关系</li><li>数据库引用</li><li>MongoDB覆盖索引查询</li><li>Map Reduce</li><li>固定集合(Capped Collections)</li></ol><hr><ol><li>查询分析</li><li>高级索引</li><li>索引限制</li><li>原子操作</li><li>全文检索</li><li>ObjectId</li><li>自动增长</li></ol><hr><ul><li>正则表达式</li><li>操作符</li><li>运算符</li><li>管理工具:<blockquote><p>Rockmongo<br>GridFS</p></blockquote></li></ul><hr><ul><li>有待补充…</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB-3</title>
    <url>/2020/02/17/MongoDB-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MongoDB-3"><a href="#MongoDB-3" class="headerlink" title="MongoDB-3"></a>MongoDB-3</h3><p><strong>使用数据模型:</strong></p><ul><li>集合SET1<blockquote><p><code>db.createCollection(&quot;SET1&quot;, { capped : true, autoIndexId : true, size : 6142800, max : 10000} )</code></p></blockquote></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"A1"</span>, B: <span class="string">"A2"</span>, likes: <span class="number">100</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"A1"</span>, B: <span class="string">"A2"</span>, likes: <span class="number">110</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"B1"</span>, B: <span class="string">"B2"</span>, likes: <span class="number">120</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"B1"</span>, B: <span class="string">"B2"</span>, likes: <span class="number">130</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"D1"</span>, B: <span class="string">"D2"</span>, likes: <span class="number">140</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"D1"</span>, B: <span class="string">"D2"</span>, likes: <span class="number">150</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"E1"</span>, B: <span class="string">"E2"</span>, likes: <span class="number">160</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"E1"</span>, B: <span class="string">"E2"</span>, likes: <span class="number">170</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"F1"</span>, B: <span class="string">"F2"</span>, likes: <span class="number">180</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"F1"</span>, B: <span class="string">"F2"</span>, likes: <span class="number">190</span>&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.create<span class="constructor">Collection(<span class="string">"SET1"</span>, &#123; <span class="params">capped</span> : <span class="params">true</span>, <span class="params">autoIndexId</span> : <span class="params">true</span>, <span class="params">size</span> : 6142800, <span class="params">max</span> : 10000&#125; )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"note"</span> : <span class="string">"the autoIndexId option is deprecated and will be removed in a future release"</span>,</span><br><span class="line">	<span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"A1"</span>, <span class="string">B:</span> <span class="string">"A2"</span>, <span class="string">likes:</span> <span class="number">100</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"A1"</span>, <span class="string">B:</span> <span class="string">"A2"</span>, <span class="string">likes:</span> <span class="number">110</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"B1"</span>, <span class="string">B:</span> <span class="string">"B2"</span>, <span class="string">likes:</span> <span class="number">120</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"B1"</span>, <span class="string">B:</span> <span class="string">"B2"</span>, <span class="string">likes:</span> <span class="number">130</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"D1"</span>, <span class="string">B:</span> <span class="string">"D2"</span>, <span class="string">likes:</span> <span class="number">140</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"D1"</span>, <span class="string">B:</span> <span class="string">"D2"</span>, <span class="string">likes:</span> <span class="number">150</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"E1"</span>, <span class="string">B:</span> <span class="string">"E2"</span>, <span class="string">likes:</span> <span class="number">160</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"E1"</span>, <span class="string">B:</span> <span class="string">"E2"</span>, <span class="string">likes:</span> <span class="number">170</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"F1"</span>, <span class="string">B:</span> <span class="string">"F2"</span>, <span class="string">likes:</span> <span class="number">180</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.insert(&#123; <span class="string">A:</span> <span class="string">"F1"</span>, <span class="string">B:</span> <span class="string">"F2"</span>, <span class="string">likes:</span> <span class="number">190</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="module-access"><span class="module"><span class="identifier">SET1</span>.</span></span>find<span class="literal">()</span></span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02973"</span>)</span>, <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02974"</span>)</span>, <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : <span class="number">110</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02975"</span>)</span>, <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : <span class="number">120</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02976"</span>)</span>, <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : <span class="number">130</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02977"</span>)</span>, <span class="string">"A"</span> : <span class="string">"D1"</span>, <span class="string">"B"</span> : <span class="string">"D2"</span>, <span class="string">"likes"</span> : <span class="number">140</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02978"</span>)</span>, <span class="string">"A"</span> : <span class="string">"D1"</span>, <span class="string">"B"</span> : <span class="string">"D2"</span>, <span class="string">"likes"</span> : <span class="number">150</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02979"</span>)</span>, <span class="string">"A"</span> : <span class="string">"E1"</span>, <span class="string">"B"</span> : <span class="string">"E2"</span>, <span class="string">"likes"</span> : <span class="number">160</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f0297a"</span>)</span>, <span class="string">"A"</span> : <span class="string">"E1"</span>, <span class="string">"B"</span> : <span class="string">"E2"</span>, <span class="string">"likes"</span> : <span class="number">170</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f0297b"</span>)</span>, <span class="string">"A"</span> : <span class="string">"F1"</span>, <span class="string">"B"</span> : <span class="string">"F2"</span>, <span class="string">"likes"</span> : <span class="number">180</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854e97967282a0f0297c"</span>)</span>, <span class="string">"A"</span> : <span class="string">"F1"</span>, <span class="string">"B"</span> : <span class="string">"F2"</span>, <span class="string">"likes"</span> : <span class="number">190</span> &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>开始查询:</strong></p><ul><li>查询并输出A=A1和B=A2的键值<blockquote><p><code>db.SET1.find({&quot;A&quot; : &quot;A1&quot;, &quot;B&quot; : &quot;A2&quot;})</code></p></blockquote></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="module-access"><span class="module"><span class="identifier">SET1</span>.</span></span>find(&#123;<span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02973"</span>)</span>, <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02974"</span>)</span>, <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : <span class="number">110</span> &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>查询并输出集合SET1内likes大于100且小于200的键值，跳过前两条并且只输出四条<blockquote><p><code>db.SET1.find({likes : {$lt :200, $gt : 100}}).limit(4).skip(2)</code></p></blockquote></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="module-access"><span class="module"><span class="identifier">SET1</span>.</span></span>find(&#123;likes : &#123;$lt :<span class="number">200</span>, $gt : <span class="number">100</span>&#125;&#125;).limit(<span class="number">4</span>).skip(<span class="number">2</span>)</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02976"</span>)</span>, <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : <span class="number">130</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02977"</span>)</span>, <span class="string">"A"</span> : <span class="string">"D1"</span>, <span class="string">"B"</span> : <span class="string">"D2"</span>, <span class="string">"likes"</span> : <span class="number">140</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02978"</span>)</span>, <span class="string">"A"</span> : <span class="string">"D1"</span>, <span class="string">"B"</span> : <span class="string">"D2"</span>, <span class="string">"likes"</span> : <span class="number">150</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02979"</span>)</span>, <span class="string">"A"</span> : <span class="string">"E1"</span>, <span class="string">"B"</span> : <span class="string">"E2"</span>, <span class="string">"likes"</span> : <span class="number">160</span> &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>查询并降序输出集合SET1内A等于A1或等于B1或等于D1的数据<blockquote><p><code>db.SET1.find({$or:[{&quot;A&quot;: &quot;A1&quot;},{&quot;A&quot;: &quot;B1&quot;},{&quot;A&quot;: &quot;D1&quot;}]}).sort({&quot;likes&quot;:-1})</code></p></blockquote></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.<span class="builtin-name">find</span>(&#123;<span class="variable">$or</span>:[&#123;<span class="string">"A"</span>: <span class="string">"A1"</span>&#125;,&#123;<span class="string">"A"</span>: <span class="string">"B1"</span>&#125;,&#123;<span class="string">"A"</span>: <span class="string">"D1"</span>&#125;]&#125;).sort(&#123;<span class="string">"likes"</span>:-1&#125;)</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5e4a854d97967282a0f02978"</span>), <span class="string">"A"</span> : <span class="string">"D1"</span>, <span class="string">"B"</span> : <span class="string">"D2"</span>, <span class="string">"likes"</span> : 150 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5e4a854d97967282a0f02977"</span>), <span class="string">"A"</span> : <span class="string">"D1"</span>, <span class="string">"B"</span> : <span class="string">"D2"</span>, <span class="string">"likes"</span> : 140 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5e4a854d97967282a0f02976"</span>), <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : 130 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5e4a854d97967282a0f02975"</span>), <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : 120 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5e4a854d97967282a0f02974"</span>), <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : 110 &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : ObjectId(<span class="string">"5e4a854d97967282a0f02973"</span>), <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : 100 &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>查询并输出集合SET1内A等于A1或等于B1，且likes值小于并等于50的值<blockquote><p><code>db.SET1.find({&quot;likes&quot;: {$gt:50}, $or: [{&quot;A&quot; : &quot;A1&quot;},{&quot;A&quot; : &quot;B1&quot;}]})</code></p></blockquote></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.<span class="builtin-name">find</span>(&#123;<span class="string">"likes"</span>: &#123;<span class="variable">$gt</span>:50&#125;, <span class="variable">$or</span>: [&#123;<span class="string">"A"</span> : <span class="string">"A1"</span>&#125;,&#123;<span class="string">"A"</span> : <span class="string">"B1"</span>&#125;]&#125;)</span><br><span class="line">&#123; `<span class="string">"_id"</span>` : ObjectId(<span class="string">"5e4a854d97967282a0f02973"</span>), <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : 100 &#125;</span><br><span class="line">&#123; `<span class="string">"_id"</span>` : ObjectId(<span class="string">"5e4a854d97967282a0f02974"</span>), <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : 110 &#125;</span><br><span class="line">&#123; `<span class="string">"_id"</span>` : ObjectId(<span class="string">"5e4a854d97967282a0f02975"</span>), <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : 120 &#125;</span><br><span class="line">&#123; `<span class="string">"_id"</span>` : ObjectId(<span class="string">"5e4a854d97967282a0f02976"</span>), <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : 130 &#125;</span><br></pre></td></tr></table></figure><ul><li>执行逻辑(顺序)<blockquote><p>先执行sort(), 然后执行skip()，最后执行limit()<br>相当于<code>like &gt;=50 AND (where A=&#39;A1&#39; OR A=&#39;B1&#39;)</code><br><code>where likes [条件运算符] [条件] AND (key=&gt;value OR key=&gt;value)</code></p></blockquote></li></ul><hr><ul><li>以降序查询并输出集合SET1内文本A的内容<blockquote><p><code>db.SET1.find({},{&quot;A&quot;:1, _id:0}).sort({&quot;likes&quot;:-1})</code></p></blockquote></li></ul><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">&gt; `db.SET1.<span class="built_in">find</span>(&#123;&#125;,&#123;<span class="string">"A"</span>:<span class="number">1</span>, <span class="variable">_id</span>:<span class="number">0</span>&#125;).<span class="built_in">sort</span>(&#123;<span class="string">"likes"</span>:-<span class="number">1</span>&#125;)`</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"F1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"F1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"E1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"E1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"D1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"D1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"B1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"B1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"A1"</span> &#125;</span><br><span class="line">&#123; <span class="string">"A"</span> : <span class="string">"A1"</span> &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>输出SET1内G列内的所有文本数据，输出量为三，偏移量为一<blockquote><p><code>db.SET1.find({&quot;A&quot; : {$type : &#39;string&#39;}}).limit(3).skip(1)</code></p></blockquote></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="module-access"><span class="module"><span class="identifier">SET1</span>.</span></span>find(&#123;<span class="string">"A"</span> : &#123;$<span class="keyword">type</span> : '<span class="built_in">string</span>'&#125;&#125;).limit(<span class="number">3</span>).skip(<span class="number">1</span>)</span><br><span class="line">&#123; `<span class="string">"_id"</span>` : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02974"</span>)</span>, <span class="string">"A"</span> : <span class="string">"A1"</span>, <span class="string">"B"</span> : <span class="string">"A2"</span>, <span class="string">"likes"</span> : <span class="number">110</span> &#125;</span><br><span class="line">&#123; `<span class="string">"_id"</span>` : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02975"</span>)</span>, <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : <span class="number">120</span> &#125;</span><br><span class="line">&#123; `<span class="string">"_id"</span>` : <span class="constructor">ObjectId(<span class="string">"5e4a854d97967282a0f02976"</span>)</span>, <span class="string">"A"</span> : <span class="string">"B1"</span>, <span class="string">"B"</span> : <span class="string">"B2"</span>, <span class="string">"likes"</span> : <span class="number">130</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>string可以用2表示，Array用4</p></blockquote><hr><ul><li>在SET2内基于ID求出的文档A1的数据总和，并进行分组<blockquote><p><code>db.SET1.aggregate([{$group : {</code>_id<code>: &quot;A1&quot;, amount : {$sum : 1}}}])</code></p></blockquote></li></ul><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.aggregate([&#123;<span class="symbol">$group</span> : &#123;<span class="string">`_id`</span> : <span class="string">"A1"</span>, <span class="attr">amount</span> : &#123;<span class="symbol">$sum</span> : <span class="number">1</span>&#125;&#125;&#125;])</span><br><span class="line">&#123; <span class="string">`"_id"`</span> : <span class="string">"A1"</span>, <span class="string">"amount"</span> : <span class="number">10</span> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>类似于RDBMS中的SQL语句:<code>Sselect A1, count(*) from SET2 group by _id</code></p></blockquote><hr><ul><li>类似概念<blockquote><p>逗号’”,”<code>即为</code>AND<code></code>$or<code>即为</code>OR`</p></blockquote></li></ul><hr><ul><li>操作符<blockquote><p>用于比较两个表达式并从mongoDB集合中获取数据</p></blockquote></li></ul><p><strong>操作符总览</strong></p><table><thead><tr><th align="left">全称</th><th align="left">符号说明</th><th align="left">操作符</th></tr></thead><tbody><tr><td align="left">greater than</td><td align="left">“&gt;”(大于)</td><td align="left">$gt</td></tr><tr><td align="left">less than</td><td align="left">“&lt;”(小于)</td><td align="left">$lt</td></tr><tr><td align="left">gt equal</td><td align="left">“&gt;=”(大于等于)</td><td align="left">$gte</td></tr><tr><td align="left">lt equal</td><td align="left">“&lt;=”(小于等于)</td><td align="left">$lte</td></tr><tr><td align="left">not equal</td><td align="left">“!=”(不等于)</td><td align="left">$ne</td></tr><tr><td align="left">equal</td><td align="left">“=”(等于)</td><td align="left">$eq</td></tr></tbody></table><hr><p><strong>相关概念</strong></p><ul><li><p>条件操作符</p></li><li><p><code>projection</code></p></li><li><p><code>$type</code></p></li><li><p><code>limit</code></p></li><li><p><code>skip</code></p></li><li><p>排序(<code>sort({KEY:1/-1})</code>)</p></li><li><p>聚合(aggregate)</p></li><li><p>复制(副本集)</p></li><li><p>分片(集群)</p></li><li><p>序列(自增)</p></li><li><p>查询语法基本结构</p><blockquote><p><code>db.collection.find((query, projection)</code><br><code>db.collection.find({key1:value1, key2:value2}).pretty()</code></p></blockquote></li></ul><hr><p><strong>MongoDB与RDBMS Where语句比较</strong></p><p><strong>查询语句:</strong></p><table><thead><tr><th align="left">操作</th><th align="left">格式</th><th align="left">范例</th><th align="left">RDBMS中的类似语句</th></tr></thead><tbody><tr><td align="left">等于</td><td align="left">{<key>:<value>}</value></key></td><td align="left">db.col.find({“A”:”xxx”}).pretty()</td><td align="left">where A = ‘xxx’</td></tr><tr><td align="left">小于</td><td align="left">{<key>:{$lt:<value>}}</value></key></td><td align="left">db.col.find({“likes”:{$lt:50}}).pretty()</td><td align="left">where likes &lt; 50</td></tr><tr><td align="left">小于或等于</td><td align="left">{<key>:{$lte:<value>}}</value></key></td><td align="left">db.col.find({“likes”:{$lte:50}}).pretty()</td><td align="left">where likes &lt;= 50</td></tr><tr><td align="left">大于</td><td align="left">{<key>:{$gt:<value>}}</value></key></td><td align="left">db.col.find({“likes”:{$gt:50}}).pretty()</td><td align="left">where likes &gt; 50</td></tr><tr><td align="left">大于或等于</td><td align="left">{<key>:{$gte:<value>}}</value></key></td><td align="left">db.col.find({“likes”:{$gte:50}}).pretty()</td><td align="left">where likes &gt;= 50</td></tr><tr><td align="left">不等于</td><td align="left">{<key>:{$ne:<value>}}</value></key></td><td align="left">db.col.find({“likes”:{$ne:50}}).pretty()</td><td align="left">where likes != 50</td></tr></tbody></table><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB-2</title>
    <url>/2020/02/17/MongoDB-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MongoSQL-2"><a href="#MongoSQL-2" class="headerlink" title="MongoSQL-2"></a>MongoSQL-2</h3><p><strong>创建并连接</strong></p><ul><li>创建并选择数据库<blockquote><p><code>use TEST1</code></p></blockquote></li></ul><figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">use</span> TEST1</span><br><span class="line">switched <span class="keyword">to</span> db TEST1</span><br></pre></td></tr></table></figure><ul><li>创建集合<blockquote><p><code>db.createCollection(&quot;SET1&quot;, { capped : true, autoIndexId : true, size : 6142800, max : 10000} )</code></p></blockquote></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.create<span class="constructor">Collection(<span class="string">"SET1"</span>, &#123; <span class="params">capped</span> : <span class="params">true</span>, <span class="params">autoIndexId</span> : <span class="params">true</span>, <span class="params">size</span> : 6142800, <span class="params">max</span> : 10000&#125; )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"note"</span> : <span class="string">"the autoIndexId option is deprecated and will be removed in a future release"</span>,</span><br><span class="line">	<span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>向集合内插入两个文档</strong></p><ul><li>定义变量:<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">A1=(&#123;</span><br><span class="line"><span class="symbol">A:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line"><span class="symbol">B:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line"><span class="symbol">C:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line"><span class="symbol">D:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line"><span class="symbol">E:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>],</span><br><span class="line"><span class="symbol">likes:</span> <span class="number">100</span>&#125;)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><p><code>A1=({ A: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], B: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], C: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], D: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], E: [&#39;1&#39;, &#39;2&#39;, &#39;4&#39;], likes: 100});</code></p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt; <span class="symbol">A1</span>=(&#123;</span><br><span class="line">... <span class="symbol">A</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line">... <span class="symbol">B</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line">... <span class="symbol">C</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line">... <span class="symbol">D</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line">... <span class="symbol">E</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'4'</span>],</span><br><span class="line">... likes: <span class="number">100</span>&#125;);</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"A"</span> : [</span><br><span class="line">		<span class="string">"1"</span>,</span><br><span class="line">		<span class="string">"2"</span>,</span><br><span class="line">		<span class="string">"3"</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">"B"</span> : [</span><br><span class="line">		<span class="string">"1"</span>,</span><br><span class="line">		<span class="string">"2"</span>,</span><br><span class="line">		<span class="string">"3"</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">"C"</span> : [</span><br><span class="line">		<span class="string">"1"</span>,</span><br><span class="line">		<span class="string">"2"</span>,</span><br><span class="line">		<span class="string">"3"</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">"D"</span> : [</span><br><span class="line">		<span class="string">"1"</span>,</span><br><span class="line">		<span class="string">"2"</span>,</span><br><span class="line">		<span class="string">"3"</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">"E"</span> : [</span><br><span class="line">		<span class="string">"1"</span>,</span><br><span class="line">		<span class="string">"2"</span>,</span><br><span class="line">		<span class="string">"4"</span></span><br><span class="line">	],</span><br><span class="line">	<span class="string">"likes"</span> : <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入文档<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(<span class="selector-tag">A1</span>)</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET1</span><span class="selector-class">.insert</span>(<span class="selector-tag">A1</span>)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">&gt; db<span class="selector-class">.SET1</span>.insert(A1)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br><span class="line">&gt; db<span class="selector-class">.SET1</span>.insert(A1)</span><br><span class="line"><span class="function"><span class="title">WriteResult</span><span class="params">(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span></span></span><br></pre></td></tr></table></figure><p><code>db.SET1.find()</code></p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="symbol">SET1</span>.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="symbol">ObjectId</span>(<span class="string">"5e4a614f39d6dc440c77623b"</span>), <span class="string">"A"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"B"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"C"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"D"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"E"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"4"</span> ], <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="symbol">ObjectId</span>(<span class="string">"5e4a615439d6dc440c77623c"</span>), <span class="string">"A"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"B"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"C"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"D"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"E"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"4"</span> ], <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure><hr><ul><li>更新数据<blockquote><p><code>db.SET1.updateMany({&#39;E&#39;: [&#39;1&#39; , &#39;2&#39;, &#39;4&#39;]}, {$set:{&#39;E&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]}},{multi:true})</code></p></blockquote></li></ul><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET1.updateMany(&#123;<span class="string">'E'</span>: [<span class="string">'1'</span> , <span class="string">'2'</span>, <span class="string">'4'</span>]&#125;, &#123;<span class="string">$set:</span>&#123;<span class="string">'E'</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]&#125;&#125;,&#123;<span class="string">multi:</span><span class="literal">true</span>&#125;)</span><br><span class="line">&#123; <span class="string">"acknowledged"</span> : <span class="literal">true</span>, <span class="string">"matchedCount"</span> : <span class="number">2</span>, <span class="string">"modifiedCount"</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>查看集合内容<blockquote><p><code>db.SET1.find().pretty()</code></p></blockquote></li></ul><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="symbol">SET1</span>.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="symbol">ObjectId</span>(<span class="string">"5e4a614f39d6dc440c77623b"</span>), <span class="string">"A"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"B"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"C"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"D"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"E"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="symbol">ObjectId</span>(<span class="string">"5e4a615439d6dc440c77623c"</span>), <span class="string">"A"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"B"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"C"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"D"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"E"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>查看数据库<blockquote><p><code>db</code></p></blockquote></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; db</span></span><br><span class="line">TEST1</span><br></pre></td></tr></table></figure><ul><li>查看所有数据库<blockquote><p><code>show dbs</code></p></blockquote></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">TEST1   0.000GB</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br></pre></td></tr></table></figure><hr><p><strong>创建索引</strong></p><ul><li>因为索引不能用于并行数组</li><li>所以这里新建了一个文档并进行字符串插入</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">db</span><span class="selector-class">.createCollection</span>("<span class="selector-tag">SET2</span>", &#123; <span class="attribute">capped </span>: true, autoIndexId : true, size : <span class="number">6142800</span>, max : <span class="number">10000</span>&#125; )</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET2</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"A1"</span>, B: <span class="string">"A2"</span>, likes: <span class="number">100</span>&#125;);</span><br><span class="line"><span class="selector-tag">db</span><span class="selector-class">.SET2</span><span class="selector-class">.insert</span>(&#123; <span class="attribute">A</span>: <span class="string">"A1"</span>, B: <span class="string">"A2"</span>, likes: <span class="number">100</span>&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.create<span class="constructor">Collection(<span class="string">"SET2"</span>, &#123; <span class="params">capped</span> : <span class="params">true</span>, <span class="params">autoIndexId</span> : <span class="params">true</span>, <span class="params">size</span> : 6142800, <span class="params">max</span> : 10000&#125; )</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"note"</span> : <span class="string">"the autoIndexId option is deprecated and will be removed in a future release"</span>,</span><br><span class="line">	<span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET2.insert(&#123; <span class="string">A:</span> <span class="string">"A1"</span>, <span class="string">B:</span> <span class="string">"A2"</span>, <span class="string">likes:</span> <span class="number">100</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.SET2.insert(&#123; <span class="string">A:</span> <span class="string">"A1"</span>, <span class="string">B:</span> <span class="string">"A2"</span>, <span class="string">likes:</span> <span class="number">100</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><ul><li>将文档SET2内的键A和键分别设置为升序索引与降序索引(DRBMS内称之为复合索引)<blockquote><p><code>db.SET2.createIndex({&quot;A&quot;:1,&quot;B&quot;:-1})</code></p></blockquote></li></ul><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&gt; db.SET2.createIndex(&#123;<span class="string">"A"</span>:<span class="number">1</span>,<span class="string">"B"</span>:-<span class="number">1</span>&#125;)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"createdCollectionAutomatically"</span> : <span class="type">false</span>,</span><br><span class="line">	<span class="string">"numIndexesBefore"</span> : 1,</span><br><span class="line">	<span class="string">"numIndexesAfter"</span> : 2,</span><br><span class="line">	<span class="string">"ok"</span> : 1</span><br></pre></td></tr></table></figure><hr><ul><li>查看所有索引<blockquote><p><code>db.SET2.getIndexes()</code></p></blockquote></li></ul><figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">&gt; db.SET2.getIndexes()</span><br><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"v"</span> : 2,</span><br><span class="line">		<span class="string">"key"</span> : &#123;</span><br><span class="line">			<span class="string">"_id"</span> : 1</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="string">"name"</span> : "_<span class="type">id</span>_<span class="string">",</span></span><br><span class="line"><span class="string">		"</span>ns<span class="string">" : "</span>A.SET2<span class="string">"</span></span><br><span class="line"><span class="string">	&#125;,</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">		"</span>v<span class="string">" : 2,</span></span><br><span class="line"><span class="string">		"</span>key<span class="string">" : &#123;</span></span><br><span class="line"><span class="string">			"</span>A<span class="string">" : 1,</span></span><br><span class="line"><span class="string">			"</span>B<span class="string">" : -1</span></span><br><span class="line"><span class="string">		&#125;,</span></span><br><span class="line"><span class="string">		"</span>name<span class="string">" : "</span>A_1_B_-<span class="number">1</span><span class="string">",</span></span><br><span class="line"><span class="string">		"</span>ns<span class="string">" : "</span>A.SET2<span class="string">"</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">]</span></span><br></pre></td></tr></table></figure><hr><ul><li>删除所有索引<blockquote><p><code>db.SET2.dropIndexes()</code></p></blockquote></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="module-access"><span class="module"><span class="identifier">SET2</span>.</span></span>drop<span class="constructor">Indexes()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"nIndexesWas"</span> : <span class="number">2</span>,</span><br><span class="line">	<span class="string">"msg"</span> : <span class="string">"non-_id indexes dropped for collection"</span>,</span><br><span class="line">	<span class="string">"ok"</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><ul><li><p>删除集合SET1内所有符合条件的文档</p><blockquote><p><code>db.SET1.deleteMany({A: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]})</code><br><code>db.SET1.remove({&#39;A&#39;:[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]})</code></p></blockquote></li><li><p>查看集合内容</p><blockquote><p><code>db.SET1.find().pretty()</code></p></blockquote></li><li><p>删除集合</p><blockquote><p><code>db.SET1.drop()</code></p></blockquote></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="module-access"><span class="module"><span class="identifier">SET1</span>.</span></span>drop<span class="literal">()</span></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>删除所在数据库<blockquote><p><code>db.dropDatabase()</code></p></blockquote></li></ul><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">&gt; db.dropDatabase<span class="comment">()</span></span><br><span class="line">&#123; <span class="string">"dropped"</span> : <span class="string">"TEST1"</span>, <span class="string">"ok"</span> : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><ul><li>查看已有数据库列表<blockquote><p><code>show dbs</code></p></blockquote></li></ul><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br></pre></td></tr></table></figure><hr><p><strong>补充内容:</strong></p><ul><li>文档的数据结构和JOSN基本相同</li><li>所有存储在集合中的数据都是BSON格式</li><li>BSON 是一种类似 JSON 的二进制形式的存储格式，是 Binary JSON 的简称</li><li>增删改查中只有查和改有实际用途，而精髓就在于查</li></ul><hr><p><strong>其它概念:</strong></p><ul><li>数组</li><li>变量</li><li>数据库</li><li>集合</li><li>文档</li><li>键</li><li>值</li><li>索引(1/-1)<blockquote><p><code>createIndex()</code> version&gt;3.0.0<br><code>ensureIndex()</code> version&lt;3.0.0</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB-1</title>
    <url>/2020/02/17/MongoDB-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MongoDB-1"><a href="#MongoDB-1" class="headerlink" title="MongoDB-1"></a>MongoDB-1</h3><p><strong>概述:</strong></p><ul><li>NoSQL</li><li>是一个基于分布式文件存储的数据库</li><li>由C++撰写</li><li>目的是为WEB应用提供可扩展的高性能数据存储解决方案</li><li>虽然是非关系型，但它的功能超越了所有其他的NoSQL，是最接近关系型数据库的NoSQL</li><li>MongoDB 将数据存储为一个文档，数据结构由键值<code>(key=&gt;value)</code>对组成</li><li>MongoDB 文档类似于JSON对象</li><li>字段值可以包含其他文档，数组及文档数组</li><li>2007年10月，MongoDB由10gen团队所开发，发布于2009年2月</li></ul><hr><p><strong>(Key=&gt;Value)简述:</strong></p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="type">name</span>: "serow"	&lt;-field: <span class="keyword">value</span></span><br><span class="line">   <span class="type">time</span>: "2020-01-17"	&lt;-field: <span class="keyword">value</span></span><br><span class="line">   xxx: "xxx"		&lt;-field: <span class="keyword">value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>存储结构示例</strong></p><p><strong>向数据库内UNIT1集合插入两条文档数据</strong></p><p><code>db.UNIT1.insert({[A: &#39;1&#39;, &#39;2&#39;, &#39;3&#39;], [B: &#39;1&#39;, &#39;2&#39;, &#39;3&#39;] likes: 100)});</code></p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.UNIT1.insert(&#123;</span><br><span class="line">... <span class="string">A:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line">... <span class="string">B:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>],</span><br><span class="line">... <span class="string">likes:</span> <span class="number">100</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">&gt; db.UNIT1.insert(&#123; <span class="string">A:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>], <span class="string">B:</span> [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>], <span class="string">likes:</span> <span class="number">100</span>&#125;);</span><br><span class="line">WriteResult(&#123; <span class="string">"nInserted"</span> : <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure><hr><p><strong>输出示例(结构示例):</strong></p><p><code>db.UNIT1.find()</code></p><figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line">&gt; db.<span class="symbol">UNIT1</span>.find()</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="symbol">ObjectId</span>(<span class="string">"5e4a564937144332c7b7814a"</span>), <span class="string">"A"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"B"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br><span class="line">&#123; <span class="string">"_id"</span> : <span class="symbol">ObjectId</span>(<span class="string">"5e4a569837144332c7b7814b"</span>), <span class="string">"A"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"B"</span> : [ <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span> ], <span class="string">"likes"</span> : <span class="number">100</span> &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>特点:</strong></p><ol><li>MongoDB是一个面向文档存储的数据库，因此降低了管理与操作的难度</li><li>Mongo支持丰富的查询表达式，而查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组</li><li>允许在MongoDB记录中设置任何属性的索引来实现更快的排序</li><li>允许通过本地或者网络创建数据镜像，以此大幅增加了MongoDB的扩展性</li></ol><hr><ol start="5"><li>MongoDB使用update()命令可以实现替换完成的文档(数据)或者一些指定的数据字段</li><li>MongoDB中的Map/reduce主要是用来对数据进行批量处理和聚合操作</li><li>Map和Reduce:Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理</li><li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作</li><li>MongoDB允许在服务端执行脚本用Javascript编写某个函数，然后直接在服务端执行，函数的定义可以存储在服务端，以方便下次调用</li></ol><hr><ol start="10"><li>MongoDB拥有各种API用以支持各类编程语言:PHP,Lisp,Puby,C++,Scala,Python等</li><li>在负载增加时(需要更多的存储空间和更强的处理能力)，它可以分布在计算机网络中的其他节点上，即为分片</li></ol><hr><p><strong>内置工具</strong></p><ul><li>MongoDB中的内置功能(插件)<blockquote><p>MongoDB提供了网络和系统监控工具Munin，作为插件应用于MongoDB中<br>Gangila是MongoDB高性能的系统监视的工具，还可以可以用于存放大量小文件，作为插件应用于MongoDB中<br>基于图形界面的开源工具之一:Cacti，用于查看CPU负载，网络带宽利用率，同时提供了一个应用于监控MongoDB的插件</p></blockquote></li></ul><hr><p><strong>GUI工具一览</strong></p><table><thead><tr><th align="left">名称</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Fang of Mongo</td><td align="left">网页式，由Django和jQuery撰写</td></tr><tr><td align="left">Futon4Mongo</td><td align="left">一个CouchDB Futon web的MongoDB山寨版</td></tr><tr><td align="left">Mongo3</td><td align="left">由Ruby撰写</td></tr><tr><td align="left">Opricot</td><td align="left">一个基于浏览器的MongoDB控制台, 由PHP撰写</td></tr><tr><td align="left">RockMongo</td><td align="left">MongoDB管理工具，轻量级且支持多国语言，由PHP撰写</td></tr><tr><td align="left">MongoHub</td><td align="left">适用于OSX的应用程序</td></tr><tr><td align="left">Database Master</td><td align="left">Windows的mongodb管理工具</td></tr></tbody></table><hr><p><strong>基本概念简述:</strong></p><ul><li>在mongodb中基本的概念:</li><li>数据库</li><li>文档</li><li>集合</li><li>键</li><li>值(域)</li></ul><table><thead><tr><th align="left">MongoDB术语与概念</th><th align="left">SQL术语与通用概念</th><th align="left">解释与说明</th></tr></thead><tbody><tr><td align="left">database</td><td align="left">database</td><td align="left">数据库</td></tr><tr><td align="left">collection</td><td align="left">table</td><td align="left">集合/数据库表</td></tr><tr><td align="left">document</td><td align="left">row</td><td align="left">文档/数据行</td></tr><tr><td align="left">field</td><td align="left">column</td><td align="left">域/数据字段</td></tr><tr><td align="left">index</td><td align="left">index</td><td align="left">索引</td></tr><tr><td align="left">primary key</td><td align="left">primary key</td><td align="left">主键,MongoDB自动将<code>_id</code>字段设置为主键</td></tr><tr><td align="left">table joins</td><td align="left">—</td><td align="left">MongoDB不支持表连接</td></tr></tbody></table><hr><p><strong>概念解析</strong></p><ol><li>数据库(Database)</li></ol><ul><li>MongoDB的默认数据库为’db’，该数据库被存储于data目录内</li><li>MongoDB的单个实例可以容纳多个独立的数据库，每个实例都有独立的集合与权限</li><li>不同的数据库被放置于data目录内不同的文件中</li></ul><p><strong>基本命令:</strong></p><ul><li>以列表方式输出已存在数据库信息<blockquote><p><code>show dbs</code></p></blockquote></li><li>显示当前数据库对象或集合<blockquote><p><code>db</code></p></blockquote></li><li>连接所选数据库，命名的具体规则不进行过多说明<blockquote><p><code>use database_name</code></p></blockquote></li></ul><p><strong>MongoDB内拥有特定作用的保留数据库，可直接访问</strong></p><p><strong>具体说明:</strong></p><blockquote><p><code>admin</code>:操作权限管理数据库，添加于此数据库的用户会自动继承数据库的所有操作权限，即为root权限<br>一些特定的服务器端命令也只能从这个数据库运行，例如列出所有的数据库或者关闭服务器<br><code>local</code>:此数据库内的数据不可复制，可以用来存储限于本地单台服务器的任意集合<br><code>config</code>:当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息</p></blockquote><ul><li>关于数据库的具体命令本章不做阐述</li></ul><hr><ol start="2"><li><p>文档(Document)</p></li><li><p>文档是一组键值(key-value)对(即BSON)</p></li><li><p>MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这是MongoDB完全不同于关系型数据库的一个特点</p></li><li><p>文档中的键/值对是有序的</p></li><li><p>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型(并且允许嵌入整个文档)</p></li><li><p>MongoDB区分类型和大小写</p></li><li><p>MongoDB的文档不能有重复的键</p></li><li><p>文档的键是字符串，除了少数例外情况，键可以使用任意UTF-8字符</p></li></ol><p><strong>文档键命名规范:</strong></p><ol><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾</li><li><code>.</code>和<code>$</code>有特别的意义，只有在特定环境下才能使用</li><li>以下划线<code>&quot;_&quot;</code>开头的键是保留的(不是严格要求的)</li></ol><ul><li>文档示例:<blockquote><p><code>{&quot;set&quot;:&quot;unit&quot;,&quot;serow&quot;:&quot;takin&quot;}</code></p></blockquote></li></ul><p><strong>RDBMS与MongoDB对应的术语:</strong></p><table><thead><tr><th align="left">RDBMS</th><th align="left">MongoDB</th></tr></thead><tbody><tr><td align="left">数据库</td><td align="left">数据库</td></tr><tr><td align="left">表格</td><td align="left">集合</td></tr><tr><td align="left">行</td><td align="left">文档</td></tr><tr><td align="left">列</td><td align="left">字段</td></tr><tr><td align="left">表联合</td><td align="left">嵌入文档</td></tr><tr><td align="left">主键</td><td align="left">主键(MongoDB提供了key为<code>_id</code>)</td></tr></tbody></table><p><strong>数据库和客户端:</strong></p><table><thead><tr><th align="left">数据库</th><th align="left">客户端</th></tr></thead><tbody><tr><td align="left">mongo</td><td align="left">mongod</td></tr><tr><td align="left">Mysqld</td><td align="left">mysql</td></tr><tr><td align="left">Oracle</td><td align="left">sqlplus</td></tr></tbody></table><hr><ol start="3"><li>集合(collections)</li></ol><ul><li><p>集合是MongoDB文档组，类似于RDBMS<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>中的表格</p></li><li><p>集合存在于数据库中，集合没有固定的结构</p></li><li><p>所以集合中可以插入不同格式和类型的数据，但通常情况下插入集合中的数据都会有一定的关联性</p></li><li><p>当第一个文档插入时，集合就会被创建</p></li><li><p>集合示例:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"set"</span>:<span class="string">"group"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"unit"</span>:<span class="string">"communism"</span>,<span class="attr">"free"</span>:<span class="string">"rule"</span>&#125;</span><br><span class="line">&#123;<span class="attr">"takin"</span>:<span class="string">"serow"</span>,<span class="attr">"elk"</span>:<span class="string">"crocodile"</span>,<span class="attr">"elephant"</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>集合的命名规则:</strong></p><ul><li><p>集合名不能是空字符串<code>&quot;&quot;</code></p></li><li><p>集合名不能含有\0字符(空字符)，此字符表示集合名的结尾</p></li><li><p>集合名不能以”system.”开头，这是为系统集合保留的前缀</p></li><li><p>集合名字不能含有保留字符</p><blockquote><p>但某些驱动程序可以支持在集合名内包含保留字符，因为某些系统生成的集合中包含该字符<br>除非要访问这种系统创建的集合，否则不可以在名字里出现<code>$</code></p></blockquote></li><li><p>命名实例:</p><blockquote><p><code>db.col.fineOne()</code></p></blockquote></li></ul><hr><ol start="4"><li>封装集合(Capped collections)</li></ol><ul><li>Capped collections就是固定大小的collection</li><li>有很高的性能以及队列过期的特性(过期按照插入的顺序)，有点类似于<code>RRD</code>的概念</li><li>Capped collections是高性能自动的维护对象的插入顺序<blockquote><p>适合类似记录日志的功能<br>与标准的collection不同，其需要显式的创建一个capped collection，指定一个collection的大小(单位是字节)<br>collection 的数据存储空间值提前分配的</p></blockquote></li><li>Capped collections 可以按照文档的插入顺序保存到集合中，而且这些文档在磁盘上存放位置也是按照插入顺序来保存的<blockquote><p>所以更新Capped collections中文档的时候，更新后的文档不可以超过之前文档的大小，以确保所有文档在磁盘上的位置一直保持不变</p></blockquote></li><li>Capped collection是按照文档的插入顺序而不是使用索引确定插入位置，此种方法可以提高增添数据的效率<blockquote><p>MongoDB的操作日志文件<code>oplog.rs</code>就是利用Capped Collection来实现的</p></blockquote></li><li>指定的存储大小包含了数据库的头信息，这一点需要特别注意</li></ul><hr><ul><li>在Capped Collection中可以能添加新的对象</li><li>可以进行更新，并且对象不会增加存储空间，如果增加，更新就会失败</li><li>使用Capped Collection不能删除一个文档，可以使用drop()方法删除collection所有的行</li><li>删除之后必须显式的重新创建此collection</li><li>在32bit机器中，capped collection最大存储为<code>1e9( 1X10^9)</code>个字节</li></ul><hr><ul><li>Capped Collections示例:<blockquote><p><code>db.createCollection(&quot;mycoll&quot;, {capped:true, size:100000})</code></p></blockquote></li></ul><hr><ol start="5"><li>元数据</li></ol><ul><li>数据库的信息存储在集合中，它们使用了系统的命名空间:<blockquote><p><code>dbname.system.*</code></p></blockquote></li><li>在MongoDB数据库中名字空间<code>&lt;dbname&gt;.system.*</code>是包含多种系统信息的特殊集合(Collection)</li></ul><p><strong>集合命名空间说明:</strong></p><table><thead><tr><th align="left">集合命名空间</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">dbname.system.namespaces</td><td align="left">列出所有名字空间</td></tr><tr><td align="left">dbname.system.indexes</td><td align="left">列出所有索引</td></tr><tr><td align="left">dbname.system.profile</td><td align="left">包含数据库概要(profile)信息</td></tr><tr><td align="left">dbname.system.users</td><td align="left">列出所有可访问数据库的用户</td></tr><tr><td align="left">dbname.local.sources</td><td align="left">包含复制对端(slave)的服务器信息和状态</td></tr></tbody></table><p><strong>对于修改系统集合中的对象有的规则:</strong></p><ol><li>在<code>&quot;[{system.indexes]}&quot;</code>插入数据，可以创建索引<blockquote><p>但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)</p></blockquote></li><li><code>&quot;[{system.users}]&quot;</code>是可修改的</li><li><code>&quot;[{system.profile}]&quot;</code>是可删除的</li></ol><hr><p><strong>其它概念:</strong><br>MongoDB 数据类型<br>ObjectId<br>字符串(BSON字符串都是UTF-8编码)<br>时间戳<br>日期(<code>DATE/DATE()</code>)</p><hr><p><strong>参考资料:</strong></p><p>官方网站<a href="https://www.mongodb.com/" target="_blank" rel="noopener">跳转</a><br><code>https://www.mongodb.com/</code></p><p>官方文档EN<a href="https://docs.mongodb.com/manual/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.mongodb.com/manual/</code></p><p>下载地址<a href="https://www.mongodb.com/download-center/community" target="_blank" rel="noopener">跳转</a><br><code>https://www.mongodb.com/download-center/community</code></p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">(关系数据库管理系统：Relational Database Management System，RDBMS)</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-3</title>
    <url>/2020/02/16/Redis-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Redis-简易参考"><a href="#Redis-简易参考" class="headerlink" title="Redis-简易参考"></a>Redis-简易参考</h3><p><strong>便捷参考</strong></p><ul><li>基本语法:<blockquote><p><code>redis 127.0.0.1:6379&gt; COMMAND KEY_NAME VALUE</code></p></blockquote></li><li>参数说明:<blockquote><p><code>COMMAND为命令(映射于数据类型)</code><br><code>KEY_NAME为键</code><br><code>VALUE 为值</code></p></blockquote></li></ul><hr><p><strong>相关命令简述(不进行详细说明)</strong></p><ul><li>String/Hash/List/Set/Sorted set不进行说明</li><li>Redis 在 2.8.9 版本添加了 HyperLogLog 结构</li><li>Redis HyperLogLog 是用来做基数统计的算法</li></ul><table><thead><tr><th align="left">相关说明</th><th align="left">相关参数</th></tr></thead><tbody><tr><td align="left">HyperLogLog用于实现基数统计算法</td><td align="left">PFADD\PFCOUNT\PFMERGE</td></tr><tr><td align="left">订阅</td><td align="left">SUBSCRIBE\PUBLISH</td></tr><tr><td align="left">事务</td><td align="left">MULTI\EXEC\DISCARD</td></tr><tr><td align="left">脚本</td><td align="left">EVAL</td></tr><tr><td align="left">连接</td><td align="left">PING\QUIT\SELECT index</td></tr><tr><td align="left">服务</td><td align="left">INFO</td></tr><tr><td align="left">备份</td><td align="left">Bgsave\SAVE</td></tr><tr><td align="left">恢复</td><td align="left">SAVE</td></tr><tr><td align="left">安全</td><td align="left">CONFIG\AUTH</td></tr><tr><td align="left">性能测试</td><td align="left">redis-benchmark [option] [option value]</td></tr><tr><td align="left">连接客户端</td><td align="left">redis-server –maxclients [最大连接数]</td></tr></tbody></table><hr><p><strong>相关概念</strong></p><ul><li>订阅</li><li>事务</li><li>脚本</li><li>连接</li><li>服务器</li><li>数据备份</li><li>数据恢复</li><li>安全</li><li>管道技术</li><li>分区</li><li>测试(性能)</li><li>Log</li></ul><hr><ul><li><p>参考资料:<a href="https://redis.io/commands" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://redis.io/commands</code></p></blockquote></li><li><p>在线测试<a href="http://try.redis.io/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://try.redis.io/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-02-16</title>
    <url>/2020/02/16/%E9%9A%8F%E7%AC%94-2020-02-16/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="0657e4f1b28c59a3723aecde14925e7c120e39da0c118d6509b851e24c54c9e2">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546eebb84e514277c32fb4c68e0c68a19f75d35aef7ae6360093a8f2e268652470c0fb64228deaa9daf5d40cbc36bb3a32f5b8e4d36db6adfc1179482702eb8c982b334029612825765c8c0fa885e9b5dd57a8b91a9e6c62962ef97644e896d276c15d19e1e2eb68c6ba64d311812e1de75b66ba558bb8621772ba6790eaccd470d245d37a7e7f6d5686dfad3904a2939da43d75e9c14a4d1ee3d0784a34562d451601ab2b3624c58f62924931c713dcc614a32ca693302b1a2c47e331b62928d49018938d630ad37b1f18a4172bc34b57ab77f5a24d7f8da78a2b1602523a3ebc80ebf50ede12f7393135700f7e9c0acc1b2e29695166506a123992b743a744d173b668dfc421ee424d5d6bdc66647e1273467f86931c99e8ec888a123b98b1d90b0e2001a3d8fcfc7feca600d131c3ef56bf801768ca123452ce91f80a885e027186e07ea595398f72ad5a91111fd2d5acc43b9a2212d46901ba5831af37518e4c5216688ee291edd9b655d12be9519d50e6b0c949cd3411a9196e544f8c6558d3ad52fd945c654b30a39a301024bc796d9d72e2e1ce2d89705722f3dad1d49422a3cd654c8bdfb192ca32f2f2d88c3a303c8dffa80358b65293da1f05960071cfd464e14238eda10a016326fe11071e3983354abe12b434272741d231f0543f64ed5d0f7461d46f0e149e0491863f3fc6fc975fda7b240c7058923ef2cd576e6b096f487e195595d12fd1f5baabf0486f059535d064b7d372bd3c57c69dd3fc759f448db36095a680ed774e2f139571a36c56c1f4dbe755c03a5822745d21ca54334efa0e7b539f226ed25bdf159893f237edd427adbd7a84622a435cfdd4b21776c0415dd2b7bf0e95c03a4fb9bb7d010db994d0aefbb36d70aeb972bea6bfa5</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔 2020-02-16</title>
    <url>/2020/02/16/%E9%9A%8F%E7%AC%94-2020-2-2-16/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="6deb804cad02a07bda61c9921cf7713bf76d3f4d3f51fb69f732ca24e8d9c035">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98a650f9f1593f438cde583552f659434e346cff18a0d0903b0c6f47d4c9a9e0141d0a779fd2fee5163ebd811e0e3978dea95526ca1c2cf22d07b3b25cc4cd671ddfe69ee6d75b67d0dcd4500400b737dd390bf42dc58fb7f40f0c5192d2df44b9306b84021b3fd60fe1639f16f50508f91613faef727ea4ab989260a56620bba44c4f0c3f99c61fa19cc289c2a4c521b17cafecda5c447cc76b4e56318ed54bcc4b7c132f2840e503e957af8e4285e1710cbbfa4d3c87e73930507fb34ceeee52eb945dd6f0b3f52435f677d02e48d1487b7a597b7566ce1861a24b74ac120a765e614d9e90bf5f2d4b8f4a9b265305bf9cfecd91469e48bd3c1903ee83875ed215ef1b0979b9da42b5e767a6ad1ac50393e5d296f4a784a4588ba0228a7b21dea4857751a8b213e0bffa320a92d12f51ff6bf2369c774f41a99c7e1439c5ec55dc4c121eaef6332100ee4989198d38c43c0e4caccd1cd28431b42f228434904f5067fa1ab56aac73cb28669351e65f5b006892d508e5a2f3ead49c5d83e4eac47439817d6f18144ad76c81c7e74bf9685242d04c21f8df945de598523eaf8d9aae3b8466317f9f5acedc8507798c7f159b2c4c72bf30095961a8a69917570fe92b008d3735c9ad1bdc09eb1668adc206b0f0f0b90677e6760c72ce4d77528b6bd02289c15aa789b76d6d4fd76b8d57172771115746264b6fe76fb155d7de86259c5e02c75e9d1db0d6be0470bdf96d284d7ab74c6cedc0c1edee6b1209024f8226fa957943fcb589a13085980189d6e7842d36ae759d6eadc194c0714aaf65fc75c5a12e310520ae2a5b9aed81f8971e2326fa76ac4a006f9f635239539316b0d85a8575856ecfc79ead56742dd7def7028af0dbc00852f4241f161fee4d5f96fdb7112a95c4a825d777a1646865bb4810c018ef4a4cf9ce65faaba301de2d5fe8ea59a88412a23c6fa4b221d1100e37c3fc8d019507ea86c55fdc13275a4d29afe4ec2785e0d09d82f5fd430f780e5d88e7195f78bc123c55a6ccbb8fac11138af9a68eb787a843826446ff231347681ac8e5514ebd9e045470237d088d2f89ba37cf03140892e7afbc11911898120cd7ad3138543b872331c95c90b82eeebacce8e35872a10e4bd669a967ea0754def14fbfc239e2d0cd6cf3abbde5768d893a5137c876eaeff0de82ce7c6b0910321a5f7cbe8622bd7e246c685a404ba51a0e45ac35375baab4145408c05856daa53f3def39ad6f5803eda5e5b0ae9bc57d5ce4a92c23653ba05225be8ac749379c6b5aee7a267bda8c0ca05416afc69937c4e59e09127b721c58cd0af1cc79e1e9958599b55c008a881446bcfbe9c784333f3260dacdb996400e3be812023a66ece87252b16fcbe284ea9d43349e8223e442da588d78a09ff710e6274354bc19575298d5e3270dab9dadea57eb260d8427d9980bee5d98fcd3f44e608bdfb5f5352c7936f561ed5b3b7e93406416faee78faf7ce89515e9102ad32e355b74cc6a5ab25890fe81585b5d38a3018829899cffd259e3b1096b2e16adac1ddb8c9e7e7e8bd95275debd852c83ee96fea16d8f21f3b202011ccc3acc5d6be31bf8fac635f9a5527a731b6772230b63cf4fac084fa586391264b565936a9b648c1ff4959b4fcffac28a9e996e8a4ec1dd398cb869df2cf9314bbef92d8d6d56691e824335e6acffb3227ba1361c8971c321ae60d91f0bfc637d85a1b4f59b3102c5939d2ef8b01f1776d3e24efb38368d436ed20866f4a23846e86d3c085c63be90a302e81ec17c10bc2c8bce5816cdbe8eb3a0a45b72a88f642126d373a6adbebcab3d74279c544b78730dfd4204d1fb5870ad50a2e7b42f9e7d07df650446622f2ce0fecaeeedd10bad9bfe37ed9b7c8479bb41c4b861a187cc4acff482a03b4d0dc851d6db4ddd24d54bae0b878b65cd6157b93d565a52bcab4b969e530cff0111acccd1aa91813bde88ccd73bd36693d7f24313dcb6e6b1fc4367193ef5265413f8d424721dbba2cdf372b831b2b7d558e60a5b8d7c05303782868661bcdcdccfcbfc01a890d6a4f082fc63914f9188c79dc6ff0bb851e547333c033fc21a7b70272b264e25e8e974e321afc61ab6a6b39381027714564e1fd01bc72ae6b49117fbaba3597851327a8c013156617ec4018d76fcdcd89d3da3ddb2ed84cc8f68dbc31d7cb17ccf3f19f375e4edeb958463fe114392ee477c0d8482cf393c1185c5c6edce4479d3f15cc5d8c123f3c10bf3127c53f9a90c997d8b09cf42b27a3fb4b61b3b96055d70827dbc5203e29da68cd4cb8fb1243ee80470ec0c5f4eef12a4a5d8ddb36e4e41e75f9f8ef8b6344756d1b75abafa544204eecfa763368353264cee21f4d35acbaea71839605319e1854e0a1172ca8a7e5cb867e42b50c2ce26dbb47c0af2509a96edd28cb6f2fd111d5db9fa67f6e9b71efe7fb4176d04c71438d201cf0dd91ddedabf49d2777e71f204a917f4536791540381a715ea4c562a22cb73237966d277ea44bd381f4303a2984e283153112aabbdc21d22fff1b0372c1ef0c86fd6eaf7cafc76727ad0e569d1d41e7db2a4bb5e4f6fddd9ab5afa147b91e3f342e39e41bec3dcb6142581266445b468764700039eaef48e1df5da869d922b273a3ae829923b1aca5b45258633ba355c129c0cef2d5096db57b01d6b63e31429e33bf53417b764ce9a708246bf89237da08f56f765a0e9b335f6d7c28cb1dc93bbc0fe12993958cb289f68620ddae57917d803ac68831eb43ae9d7e7c2e9d536a5328d4c6949cd85006c75e892fcefe9cb730e1a00ea6b0a70ec9beda10c10da176ed2420748ea17596203f90c441c1a913af10e12ace4236584ed2e94826b3de7f2768b88dce37eb2557a5436a951f3232df95326ff2766a394a1bfe4b07252a8cb4707292857088f0b09d39ef6981d8e05854a1ee416888d02dba94e119cda55d5784e7a18581842681c367752c853f74b739f8f7c87d30320d620f1ac8d23f1a524ff0c4be8a6fb4f7b9be3891eec729cb7bed8208b6ccb1d35ddd9b64eb9f2f6c95162d6c036ca7e2f18616bfdf84235794eacffedbf0ff4f6cd285daaeae9c5a0f74840519a86f5e66b6d8373648d5c6859c468817e90eb0651b8c89fc0358299fa9d98ccfe1a1f12e7b3ce6924a851062ede9f299a91663bb4ef53fa816bf0fc00b0e7fef0d33321460cac4f4763c3849e1dea95a5e477384178dc28d3535eba70fe9c4e5188a16d4a292144627955d34b350e468ae1be8f0bd93526b4cef7692e9f463c1630a5223bfc1d0ab8f4f2b5280fc1050108a02d3be9c817de4f515a836dae044b42620464507d673163227171dbda077603b2845b4b1a0369e835526a679adf767634c4161bcf6afd283c7dcb24b47df771d49f3f86ca25bfa6057df1708a27b3d11aaeb596f4e6229fadcaaa98fc673cca5658785e583e40a16a8f55712d5f3222b94e79e61a6bf4ac3dc98e6eff2d431d08d4c37afe6b740d2f2e2e238cccfdcf1741f03a28355c844600d89b556b2dca7fb416e2dafca1d38614335f09f6b3eea6c50f9ebae8704ff5e0d1b74759a84ba8df1cdc8a1cbf0b62b67bc164aaffbd0bf05dfd74402d5b455b9fab45a72fdd314b766f807b9949536e18b8c0d2ef64948e70fa1b20428683122ba96d7ed06c94596bca4c064969a47bf8ff9153320349cf9dea4f0fc7cf3e77fcc1de31eb34b5a6a6fbc957148ec210af082ee8a4b5a4aeda9790c8735bbe4d491672138adbe66988379328e95e0eaa25128c7f947602af1196a53e6e9802dbb8783e4d1613a17d38055c87c1725ca299a91327502425c88c3c5258c958d59c2051b3a997c4b1204086e3946bde0a9cc5985945145f80dca505c525c856183fd80d5c053612354a8f5be089afc8027b99fe877c6af2b6d0a5d437d46797f56d18b355ee7ec1f3092d6f668cd917b735c8287f0f88e67b99db42ed0581664764ca5ab21d1d16ea06a269b0aa317c754f953cdb4c9706b5af963d8669438739295b936cbc143c85e0bc99739ed4b35f8d82d7c321ac8badc27728e9c04b638fb392121b0cf1a3ac3f7d5f5359bce18773ba8862a473bc34bebfac7b3791ef42c7255de6ddfa03bb4a0db6abcc5918bd2ab41dde62695e08099e9eb61fb041034174d66329a5e98ac48ebc8d214bfa23d6c03f6b52411545297359c4cd1dc6c03c074dd56f6cde806b5728c39aba0733263cfc63c29f11a9983bfc84e45794af789d47e85721c43941b8175b1ca43a39553f6e88fbb66d500f24dbee7273045beb5988f83c1676102b81173e19dd0252df2b35dfb2a821f8f6ff76279f0dd914f4fc2646d413739a1495ef3a33674068d6b577263ffc439ff582d34185acea396a6e1e5115c288ecd3de9a9d8a401edf6eafcf9227dbcced955a5bb4b91beab5f98bf4ac5b9fb7e43508b941168b0dcf5658692b7810db7f65cb284dae93addb801cb79f230c1fc4560d6fdef543cdc78af44ac27bf1fca4fe14f0e96bb9a290ec07593eac4f13e12d8b239e965b5fd83ea3cfcd8fc48cbbdf4df5c45ce085b177ccf1cd8f2d3afdc213dcde81ba32ba5e3b8bcafbd1eb6644d86b9d1651d05f408b0f144ff842bf59a5b650ccd2a6a184b66243e1baceef0cd4459a824609ad61677f9e927de752709dca95711d945c8b1efefa261cea05835ae3fe8c20c7158ce636b13823aecba1d3c1d81e6463e8d59551de18088139e6dfc2caece781977011cfb1ab36a4c05bbd08f04fbb572e972dde32bf6cb563fe1804168aed5ef8b9a8507fcf59569a322beac104818da624c5dcc8174971f79fecf104a6c3b28384ff29d7631a04ffc98f67bda5808ea76dc0f72ff1078e51ff11ad867f733c95363d4093914cd99e02fa16661d4f9353ff45992b9345d5fd8bec6d2000384b70cf32e6b777f83a8275ba440e8cf025b30eb248d3c85973965feb6b06808bbc7bce889ed945ed00ff37d527d58bb25c72adbf06a0530dbc52817b7c17d445d1b4b53824fe361a02abd19ee6792c2ef2348f0a0ba9d3b784014c694b9323bc1d32f4eef8ba763c098c7843f37ebb5f92bf7500fb99f3de8589fc2eebb55972f166c9b4e13fa1770d20a05a8f2bef6fbba29599b2de167bda6331eebfb8a94e8be593ec301ce88293a800546f3204dcdbdd6733d4321aaa16fc481f76cd8ca68d57e2f8da512853a09903fec320b700c3758c7c7d8cee06598e95af42e44cd9eae406f2dce2517497f4603d831325305f816d5dce1d81f3c0a0137ffe53edf440f941ba58256eee87370b2b3ff9ad6f6b6c5e7f2295ba45795e6de5b84dd4db014b6f3aa91378a397d356455fa9261035019389962c39feedb165e0dfe871fe85c35981e3772d650bc641e999b124c623403226bf939bc0934e69cb03bf09827042606bf2ace676c92d732852c2fe5f6e592350c591d55995ea0f3319c52ab32d93268ee1c969790cc85fd080de1354d7b6dc826349f50b74d4cfded146c4f17266d0a41a248a2e9e9d047dec8d1045eaf56f809c8b31701ab575d98aefb64c75d60dacf376fd0a170e1c84cd7881a0097ab6de29ce98beae6fa3091e4781d4b8e02ada837af390194af1b92815a6532ebdce167d4f21f54f8c2a4d0091f1526ceb2f6570f44d2d54426f401cf78fa6519eaa386cc60ef7b707e9c0f37c9e72058f171f56c46cf25093ea9a5c25</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-2</title>
    <url>/2020/02/16/Redis-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Redis-2"><a href="#Redis-2" class="headerlink" title="Redis-2"></a>Redis-2</h2><ul><li>配置与数据类型简述</li></ul><hr><h3 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h3><ul><li>启动Redis<blockquote><p><code>$ redis-server</code></p></blockquote></li><li>打开终端(查看redis是否启动)<blockquote><p><code>$ redis-cli</code><br><code>redis 127.0.0.1:6379&gt;</code><br>本机IP:<code>127.0.0.1</code>，redis服务端口:<code>6379</code></p></blockquote></li></ul><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">root@debian:~# redis-cli</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt;</span><br></pre></td></tr></table></figure><hr><ul><li><p>配置文件</p><blockquote><p><code>/安装目录/redis.conf</code></p></blockquote></li><li><p>CONFIG命令用于查看或设置配置项</p></li><li><p>命令格式</p><blockquote><p><code>redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</code><br><code>*</code> 用于匹配所有配置项<br><code>redis 127.0.0.1:6379&gt; CONFIG GET *</code></p></blockquote></li><li><p>可以通过修改redis.conf文件或使用 CONFIG set 命令来修改配置</p></li><li><p>CONFIG SET 命令</p></li><li><p>基本语法：</p><blockquote><p><code>redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</code></p></blockquote></li><li><p>对于GONFIG的参数与redis.conf的配置项在本篇内不进行过多阐述</p></li></ul><hr><h3 id="数据类型简述"><a href="#数据类型简述" class="headerlink" title="数据类型简述"></a>数据类型简述</h3><ul><li>Redis支持五种数据类型:</li><li>String(字符串)</li><li>Hash(哈希)</li><li>List(列表)</li><li>Set(集合)</li><li>Zset(sorted set:有序集合)</li></ul><hr><ul><li>本篇中的应用实例简述只列举出最基本的用法，其他命令不会多做阐述</li><li>在命令提示符内输入命令时Redis会给出对应的相关提示</li><li>删除:<code>DEL KEY_name</code></li></ul><hr><ol><li>String(字符串)</li></ol><ul><li><p>String是redis最基本的类型，方式是一个<code>Key</code>对应一个<code>Value</code></p></li><li><p>String类型是二进制安全的，即Redis的String可以包含任何数据，包括序列化的对象与任何形式的图片</p></li><li><p>String类型的值最大能存储512MB</p></li><li><p>相关命令:<code>SET</code>与<code>GET</code></p></li><li><p>应用实例:</p></li><li><p>使用Redis中的<code>SET</code>与<code>GET</code>命令，<code>Key</code>为<code>UNIT</code>，<code>Value</code>为<code>serow</code></p><blockquote><p><code>SET UNIT &quot;serow&quot;</code><br><code>GET UNIT</code></p></blockquote></li><li><p>输出:</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; SET UNIT <span class="string">"serow"</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; GET UNIT</span><br><span class="line"><span class="string">"serow"</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><blockquote><p><code>DEL UNIT</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><ol start="2"><li>Hash(哈希)</li></ol><ul><li><p>Redis hash是一个键值(key=&gt;value)对集合</p></li><li><p>Redis hash是一个String类型的<code>field</code>和<code>value</code>的映射表</p></li><li><p>Hash适合用于存储对象</p></li><li><p>每个hash可以存储<code>2^32-1</code>键值对(40多亿)</p></li><li><p>相关命令:<code>HMSET</code>与<code>HGET</code></p></li><li><p>应用实例:</p></li><li><p>使用Redis中的<code>HMSET</code>与<code>HGET</code>命令，<code>HMSET</code>设置了两个<code>field=&gt;value</code>对，<code>HGET</code>获取对应<code>field</code>对应的<code>value</code></p><blockquote><p><code>HMSET UNIT field1 &quot;serow&quot; field2 &quot;takin&quot;</code><br><code>HGET UNIT field1</code><br><code>HGET UNIT field2</code></p></blockquote></li><li><p>输出:</p><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; HMSET UNIT field1 <span class="string">"serow"</span> field2 <span class="string">"takin"</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; HGET UNIT field1</span><br><span class="line"><span class="string">"serow"</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; HGET UNIT field2</span><br><span class="line"><span class="string">"takin"</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><blockquote><p><code>DEL UNIT</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><ol start="3"><li>List(列表)</li></ol><ul><li><p>Redis 列表是简单的字符串列表，按照插入顺序排序</p></li><li><p>可以添加一个元素到列表的头部(左侧)或者尾部(右侧)</p></li><li><p>列表最多可存储<code>2^32-1</code>元素 (4294967295, 每个列表可存储40多亿)</p></li><li><p>相关命令:<code>LPUSH</code>与<code>LRANGE</code></p></li><li><p>应用实例:</p></li><li><p>使用Redis中的<code>LPUSH</code>与<code>LRANGE</code>命令</p><blockquote><p><code>LPUSH UNIT redis</code><br><code>LPUSH UNIT serow</code><br><code>LPUSH UNIT takin</code><br><code>LRANGE UNIT 0 10</code></p></blockquote></li><li><p>输出:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH UNIT redis</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH UNIT serow</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH UNIT takin</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE UNIT <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"takin"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"serow"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"redis"</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><blockquote><p><code>DEL UNIT</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br></pre></td></tr></table></figure><ul><li><p>还可以写为</p><blockquote><p><code>LPUSH A A B C D E F G</code><br><code>LRANGE A 0 10</code></p></blockquote></li><li><p>输出:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LPUSH A A B C D E F G</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; LRANGE A <span class="number">0</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"G"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"F"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"E"</span></span><br><span class="line"><span class="number">4</span>) <span class="string">"D"</span></span><br><span class="line"><span class="number">5</span>) <span class="string">"C"</span></span><br><span class="line"><span class="number">6</span>) <span class="string">"B"</span></span><br><span class="line"><span class="number">7</span>) <span class="string">"A"</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><blockquote><p><code>DEL A</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL A</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL A</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><ol start="4"><li>SET(集合)</li></ol><ul><li><p>Redis的Set是String类型的无序集合</p></li><li><p>集合是通过哈希表实现的，即添加，删除，查找的复杂度都是O(1)</p></li><li><p>集合中最大的成员数为<code>2^32-1</code>(4294967295, 每个集合可存储40多亿个成员)</p></li><li><p>相关命令:<code>SADD</code>与<code>SMEMBERS</code></p></li><li><p>应用实例:</p></li><li><p>使用Redis中的<code>SADD</code>与<code>SMEMBERS</code>命令</p><blockquote><p><code>SADD UNIT redis</code><br><code>SADD UNIT serow</code><br><code>SADD UNIT takin</code><br><code>SADD UNIT takin</code><br><code>SMEMBERS UNIT</code></p></blockquote></li><li><p>输出:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD UNIT redis</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD UNIT serow</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD UNIT takin</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SADD UNIT takin</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; SMEMBERS UNIT</span><br><span class="line"><span class="number">1</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"takin"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"serow"</span></span><br></pre></td></tr></table></figure></li><li><p>实例中takin添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略</p></li><li><p>删除</p><blockquote><p><code>DEL UNIT</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><ol start="5"><li>ZSET(sorted set：有序集合)</li></ol><ul><li><p>Redis zset和Set一样也是String类型元素的集合,且不允许重复的成员</p></li><li><p>不同的是每个元素都会关联一个<code>double类型</code>的分数</p></li><li><p>Redis正是通过分数来为集合中的成员进行从小到大的排序</p></li><li><p>Zset的成员是唯一的,但分数(score)却可以重复</p></li><li><p>相关命令:<code>ZADD</code>与<code>ZRANGEBYSCORE</code></p></li><li><p>基本语法:</p></li><li><p>添加元素到集合，元素在集合中存在则更新对应<code>score</code></p><blockquote><p><code>zadd key score member</code></p></blockquote></li><li><p>应用实例:</p></li><li><p>使用Redis中的ZADD与ZRANGEBYSCORE命令</p><blockquote><p><code>ZADD UNIT 0 redis</code><br><code>ZADD UNIT 0 serow</code><br><code>ZADD UNIT 0 takin</code><br><code>ZADD UNIT 0 takin</code><br><code>ZRANGEBYSCORE UNIT 0 1000</code></p></blockquote></li><li><p>输出:</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ZADD UNIT <span class="number">0</span> redis</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ZADD UNIT <span class="number">0</span> serow</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ZADD UNIT <span class="number">0</span> takin</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ZADD UNIT <span class="number">0</span> takin</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; ZRANGEBYSCORE UNIT <span class="number">0</span> <span class="number">1000</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"redis"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"serow"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"takin"</span></span><br></pre></td></tr></table></figure></li><li><p>删除</p><blockquote><p><code>DEL UNIT</code></p></blockquote></li></ul><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DEL UNIT</span><br><span class="line">(<span class="built_in">int</span>eger) <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p><strong>各个数据类型应用场景:</strong></p><table><thead><tr><th align="left">类型</th><th align="left">简介</th><th align="left">特性</th><th align="left">场景</th></tr></thead><tbody><tr><td align="left">String(字符串)</td><td align="left">二进制安全</td><td align="left">可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td align="left">—</td></tr><tr><td align="left">Hash(字典)</td><td align="left">键值对集合,即编程语言中的Map类型</td><td align="left">适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td align="left">存储,读取,修改用户属性</td></tr><tr><td align="left">List(列表)</td><td align="left">链表(双向链表)</td><td align="left">增删快,提供了操作某一段元素的API</td><td align="left">1. 最新消息排行等功能(比如朋友圈的时间线) 2.消息队列</td></tr><tr><td align="left">Set(集合)</td><td align="left">哈希表实现,元素不重复</td><td align="left">1. 添加、删除,查找的复杂度都是O(1) 2. 为集合提供了求交集、并集、差集等操作</td><td align="left">1.共同好友 2. 利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td align="left">Sorted Set(有序集合)</td><td align="left">将Set中的元素增加一个权重参数score,元素按score有序排列</td><td align="left">数据插入集合时,已经进行天然排序</td><td align="left">1. 排行榜 2. 带权重的消息队列</td></tr></tbody></table><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-1</title>
    <url>/2020/02/16/Redis-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="REmote-DIctionary-Server-Redis"><a href="#REmote-DIctionary-Server-Redis" class="headerlink" title="REmote DIctionary Server(Redis)"></a>REmote DIctionary Server(Redis)</h3><p><strong>概述:</strong></p><ul><li>是一种Key-Value数据库</li><li>还可称为key-value存储系统，即数据结构服务器</li><li>由ANSI C语言编写</li><li>是基于BSD协议的<code>Free software</code></li><li>支持多种语言的API</li><li>支持网络</li><li>可基于内存亦可持久化的日志型</li></ul><hr><ul><li>Redis具有极为先进的数据管理方式与处理算法</li><li>Redis与其它<code>key-value</code>缓存产品相比的特有性质:<blockquote><p>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用<br>Redis不仅仅支持简单的<code>key-value</code>类型的数据，同时还提供<code>list</code>,<code>set</code>,<code>zset</code>,<code>hash</code>等数据结构的存储<br>Redis支持数据的备份，即<code>master-slave</code>模式的数据备份<br>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径<br>Redis的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象<br>Redis运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存<br>在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情<br>同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问</p></blockquote></li></ul><hr><ul><li>Redis特点<blockquote><p>性能特点: Redis能读的速度是<code>110000次/s</code>，写的速度是<code>81000次/s</code><br>数据类型特点: Redis支持二进制案例的<code>Strings</code>,<code>Lists</code>,<code>Hashes</code>,<code>Sets</code>及<code>Ordered Sets</code>数据类型操作</p></blockquote></li><li>原子性质:<blockquote><p>Redis的所有操作都是原子性的(只有成功且完全执行与失败且完全不执行)，单个操作是原子性的<br>多个操作也支持事务，即原子性，通过<code>MULTI</code>和<code>EXEC</code>指令对其进行封装</p></blockquote></li></ul><hr><ul><li><p>原子性操作:</p><blockquote><p>将任何一套完整数据处理操作定义为一个事务<br>该事务要么完全执行，要么完全不执行，不会出现执行到一半因为错误而中止<br>以此绝对的保证了数据的完整性<br>如果把事务比作一个程序，它要么完整的被执行,要么完全不执行</p></blockquote></li><li><p>key value 存储</p><blockquote><p>键值存储，即为key=&gt;value<br>键=&gt;值(key=&gt;value)对，键唯一，对应一个值，值的形式随意<br>以此绝对的保证了数据结构的完备性</p></blockquote></li></ul><hr><p><strong>相关基本概念(基本数据结构概念)</strong></p><ul><li>String: 字符串</li><li>Hash: 散列</li><li>List: 列表</li><li>Set: 集合</li><li>Sorted Set: 有序集合</li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>文档<a href="https://redis.io/documentation" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://redis.io/documentation</code></p></blockquote></li><li><p>官网<a href="https://redis.io/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://redis.io/</code></p></blockquote></li><li><p>获取<a href="https://redis.io/download" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://redis.io/download</code></p></blockquote></li><li><p>配置说明<a href="https://redis.io/topics/config" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://redis.io/topics/config</code></p></blockquote></li><li><p>apt-get自动化获取</p><blockquote><p><code>apt-get install redis-server</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL-4</title>
    <url>/2020/02/16/PostgreSQL-4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="PostSQL-4"><a href="#PostSQL-4" class="headerlink" title="PostSQL-4"></a>PostSQL-4</h3><p><strong>PostgreSQL命令语句便捷参考(总览)</strong></p><ul><li><p>中文手册详细资料<a href="http://www.postgres.cn/docs/9.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.postgres.cn/docs/9.6/</code></p></blockquote></li><li><p>输出帮助内容</p><blockquote><p><code>postgres-# \help &lt;command_name&gt;</code></p></blockquote></li></ul><hr><p><strong>CREATE</strong></p><ul><li><p>定义一个新的聚集函数</p><blockquote><p><code>CREATE AGGREGATE</code></p></blockquote></li><li><p>定义一个用户定义的转换</p><blockquote><p><code>CREATE CAST</code></p></blockquote></li><li><p>定义一个新的约束触发器</p><blockquote><p><code>CREATE CONSTRAINT TRIGGER</code></p></blockquote></li><li><p>定义一个新的的编码转换</p><blockquote><p><code>CREATE CONVERSION</code></p></blockquote></li><li><p>创建新数据库</p><blockquote><p><code>CREATE DATABASE</code></p></blockquote></li><li><p>定义一个新域</p><blockquote><p><code>CREATE DOMAIN</code></p></blockquote></li><li><p>定义一个新函数</p><blockquote><p><code>CREATE FUNCTION</code></p></blockquote></li><li><p>定义一个新的用户组</p><blockquote><p><code>CREATE GROUP</code></p></blockquote></li><li><p>定义一个新索引</p><blockquote><p><code>CREATE INDEX</code></p></blockquote></li><li><p>定义一种新的过程语言</p><blockquote><p><code>CREATE LANGUAGE</code></p></blockquote></li><li><p>定义一个新的操作符</p><blockquote><p><code>CREATE OPERATOR</code></p></blockquote></li><li><p>定义一个新的操作符表</p><blockquote><p><code>CREATE OPERATOR CLASS</code></p></blockquote></li><li><p>定义一个新的数据库角色</p><blockquote><p><code>CREATE ROLE</code></p></blockquote></li><li><p>定义一个新重写规则</p><blockquote><p><code>CREATE RULE</code></p></blockquote></li><li><p>定义一个新模式</p><blockquote><p><code>CREATE SCHEMA</code></p></blockquote></li><li><p>定义一个新的外部服务器</p><blockquote><p><code>CREATE SERVER</code></p></blockquote></li><li><p>定义一个新序列发生器</p><blockquote><p><code>CREATE SEQUENCE</code></p></blockquote></li><li><p>定义一个新表</p><blockquote><p><code>CREATE TABLE</code></p></blockquote></li><li><p>从一条查询的结果中定义一个新表</p><blockquote><p><code>CREATE TABLE AS</code></p></blockquote></li><li><p>定义一个新的表空间</p><blockquote><p><code>CREATE TABLESPACE</code></p></blockquote></li><li><p>定义一个新的触发器</p><blockquote><p><code>CREATE TRIGGER</code></p></blockquote></li><li><p>定义一个新的数据类型</p><blockquote><p><code>CREATE TYPE</code></p></blockquote></li><li><p>创建一个新的数据库用户帐户</p><blockquote><p><code>CREATE USER</code></p></blockquote></li><li><p>定义一个视图</p><blockquote><p><code>CREATE VIEW</code></p></blockquote></li></ul><hr><p><strong>ALTER</strong></p><ul><li><p>修改一个聚集函数的定义</p><blockquote><p><code>ALTER AGGREGATE</code></p></blockquote></li><li><p>修改一个排序规则定义</p><blockquote><p><code>ALTER COLLATION</code></p></blockquote></li><li><p>修改一个编码转换的定义</p><blockquote><p><code>ALTER CONVERSION</code></p></blockquote></li><li><p>修改一个数据库</p><blockquote><p><code>ALTER DATABASE</code></p></blockquote></li><li><p>定义默认的访问权限</p><blockquote><p><code>ALTER DEFAULT PRIVILEGES</code></p></blockquote></li><li><p>修改一个域的定义</p><blockquote><p><code>ALTER DOMAIN</code></p></blockquote></li><li><p>修改一个函数的定义</p><blockquote><p><code>ALTER FUNCTION</code></p></blockquote></li><li><p>修改一个用户组</p><blockquote><p><code>ALTER GROUP</code></p></blockquote></li><li><p>修改一个索引的定义</p><blockquote><p><code>ALTER INDEX</code></p></blockquote></li><li><p>改变一个操作符的定义</p><blockquote><p><code>ALTER OPERATOR</code></p></blockquote></li><li><p>修改一个模式的定义</p><blockquote><p><code>ALTER SCHEMA</code></p></blockquote></li><li><p>修改一个序列生成器的定义</p><blockquote><p><code>ALTER SEQUENCE</code></p></blockquote></li><li><p>修改表的定义</p><blockquote><p><code>ALTER TABLE</code></p></blockquote></li><li><p>修改一个表空间的定义</p><blockquote><p><code>ALTER TABLESPACE</code></p></blockquote></li><li><p>修改改变一个触发器的定义</p><blockquote><p><code>ALTER TRIGGER</code></p></blockquote></li><li><p>修改一个类型的定义</p><blockquote><p><code>ALTER TYPE</code></p></blockquote></li><li><p>修改数据库用户帐号</p><blockquote><p><code>ALTER USER</code></p></blockquote></li><li><p>更新一个表中的行</p><blockquote><p><code>UPDATE</code></p></blockquote></li></ul><hr><p><strong>删除</strong></p><ul><li><p>删除一个准备好的查询</p><blockquote><p><code>DEALLOCATE</code></p></blockquote></li><li><p>删除一个表中的行</p><blockquote><p><code>DELETE</code></p></blockquote></li><li><p>删除一个用户定义的聚集函数</p><blockquote><p><code>DROP AGGREGATE</code></p></blockquote></li><li><p>删除一个用户定义的类型转换</p><blockquote><p><code>DROP CAST</code></p></blockquote></li><li><p>删除一个用户定义的编码转换</p><blockquote><p><code>DROP CONVERSION</code></p></blockquote></li><li><p>删除一个数据库</p><blockquote><p><code>DROP DATABASE</code></p></blockquote></li><li><p>删除一个用户定义的域</p><blockquote><p><code>DROP DOMAIN</code></p></blockquote></li><li><p>删除一个函数</p><blockquote><p><code>DROP FUNCTION</code></p></blockquote></li><li><p>删除一个用户组</p><blockquote><p><code>DROP GROUP</code></p></blockquote></li><li><p>删除一个索引</p><blockquote><p><code>DROP INDEX</code></p></blockquote></li><li><p>删除一个过程语言</p><blockquote><p><code>DROP LANGUAGE</code></p></blockquote></li><li><p>删除一个操作符</p><blockquote><p><code>DROP OPERATOR</code></p></blockquote></li><li><p>删除一个操作符表</p><blockquote><p><code>DROP OPERATOR CLASS</code></p></blockquote></li><li><p>删除一个数据库角色</p><blockquote><p><code>DROP ROLE</code></p></blockquote></li><li><p>删除一个重写规则</p><blockquote><p><code>DROP RULE</code></p></blockquote></li><li><p>删除一个模式</p><blockquote><p><code>DROP SCHEMA</code></p></blockquote></li><li><p>删除一个序列</p><blockquote><p><code>DROP SEQUENCE</code></p></blockquote></li><li><p>删除一个表</p><blockquote><p><code>DROP TABLE</code></p></blockquote></li><li><p>删除一个表空间</p><blockquote><p><code>DROP TABLESPACE</code></p></blockquote></li><li><p>删除一个触发器定义</p><blockquote><p><code>DROP TRIGGER</code></p></blockquote></li><li><p>删除一个用户定义数据类型</p><blockquote><p><code>DROP TYPE</code></p></blockquote></li><li><p>删除一个数据库用户帐号</p><blockquote><p><code>DROP USER</code></p></blockquote></li><li><p>删除一个视图</p><blockquote><p><code>DROP VIEW</code></p></blockquote></li><li><p>清空一个或一组表</p><blockquote><p><code>TRUNCATE</code></p></blockquote></li></ul><hr><p><code>SELECT</code></p><blockquote><p>从表或视图中取出若干行</p></blockquote><p><code>SELECT INTO</code></p><blockquote><p>从一个查询的结果中定义一个新表</p></blockquote><hr><p><code>SET</code></p><blockquote><p>修改运行时参数</p></blockquote><p><code>SET CONSTRAINTS</code></p><blockquote><p>设置当前事务的约束检查模式</p></blockquote><p><code>SET SESSION AUTHORIZATION</code></p><blockquote><p>为当前会话设置会话用户标识符和当前用户标识符</p></blockquote><p><code>SET TRANSACTION</code></p><blockquote><p>开始一个事务块</p></blockquote><hr><p><strong>其它</strong></p><ul><li><p>收集与数据库有关的统计</p><blockquote><p><code>ANALYZE</code></p></blockquote></li><li><p>用于退出当前事务</p><blockquote><p><code>ABORT</code></p></blockquote></li><li><p>开始一个事务块</p><blockquote><p><code>BEGIN</code></p></blockquote></li><li><p>开始一个事务块</p><blockquote><p><code>START TRANSACTION</code></p></blockquote></li><li><p>提交当前事务</p><blockquote><p><code>COMMIT</code></p></blockquote></li><li><p>提交当前的事务</p><blockquote><p><code>END</code></p></blockquote></li><li><p>在当前事务里定义一个新的保存点</p><blockquote><p><code>SAVEPOINT</code></p></blockquote></li><li><p>回滚到一个保存点</p><blockquote><p><code>ROLLBACK TO SAVEPOINT</code></p></blockquote></li><li><p>退出当前事务</p><blockquote><p><code>ROLLBACK</code></p></blockquote></li><li><p>强制一个事务日志检查点</p><blockquote><p><code>CHECKPOINT</code></p></blockquote></li><li><p>定义一个游标</p><blockquote><p><code>DECLARE</code></p></blockquote></li><li><p>定位一个游标</p><blockquote><p><code>MOVE</code></p></blockquote></li><li><p>用游标从查询中抓取行</p><blockquote><p><code>FETCH</code></p></blockquote></li><li><p>关闭游标</p><blockquote><p><code>CLOSE</code></p></blockquote></li><li><p>重建索引</p><blockquote><p><code>REINDEX</code></p></blockquote></li><li><p>根据一个索引对某个表盘簇化排序</p><blockquote><p><code>CLUSTER</code></p></blockquote></li><li><p>定义或者改变一个对象的注释</p><blockquote><p><code>COMMENT</code></p></blockquote></li><li><p>删除一个前面定义的保存点</p><blockquote><p><code>RELEASE SAVEPOINT</code></p></blockquote></li><li><p>在表和文件之间拷贝数据</p><blockquote><p><code>COPY</code></p></blockquote></li><li><p>创建一个准备好的查询</p><blockquote><p><code>PREPARE</code></p></blockquote></li><li><p>执行一个准备好的查询</p><blockquote><p><code>EXECUTE</code></p></blockquote></li><li><p>显示一个语句的执行规划</p><blockquote><p><code>EXPLAIN</code></p></blockquote></li><li><p>生成一个通知</p><blockquote><p><code>NOTIFY</code></p></blockquote></li><li><p>定义访问权限</p><blockquote><p><code>GRANT</code></p></blockquote></li><li><p>删除访问权限</p><blockquote><p><code>REVOKE</code></p></blockquote></li><li><p>在表中创建新行，即插入数据</p><blockquote><p><code>INSERT</code></p></blockquote></li><li><p>监听一个通知</p><blockquote><p><code>LISTEN</code></p></blockquote></li><li><p>停止监听通知信息</p><blockquote><p><code>UNLISTEN</code></p></blockquote></li><li><p>加载或重载一个共享库文件</p><blockquote><p><code>LOAD</code></p></blockquote></li><li><p>锁定一个表</p><blockquote><p><code>LOCK</code></p></blockquote></li><li><p>把一个运行时参数值恢复为默认值</p><blockquote><p><code>RESET</code></p></blockquote></li><li><p>显示运行时参数的值</p><blockquote><p><code>SHOW</code></p></blockquote></li><li><p>垃圾收集以及可选地分析一个数据库</p><blockquote><p><code>VACUUM</code></p></blockquote></li><li><p>计算一个或一组行</p><blockquote><p><code>VALUES</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>ORDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL-3</title>
    <url>/2020/02/16/PostgreSQL-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="PostgreSQL-3"><a href="#PostgreSQL-3" class="headerlink" title="PostgreSQL-3"></a>PostgreSQL-3</h3><p><strong>TABLES1数据结构</strong></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">ID  A  B  C  D  TIME</span><br><span class="line"> <span class="number">1</span>  <span class="number">1</span>  <span class="number">1</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">2</span>  <span class="number">2</span>  <span class="number">2</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">3</span>  <span class="number">3</span>  <span class="number">3</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span> -</span><br><span class="line"> <span class="number">4</span>  <span class="number">1</span>  <span class="number">4</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">5</span>  <span class="number">2</span>  <span class="number">1</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">6</span>  <span class="number">2</span>  <span class="number">7</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">7</span>  <span class="number">3</span>  <span class="number">7</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">1</span>  <span class="number">8</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">9</span>  <span class="number">4</span>  <span class="number">1</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"><span class="number">10</span> <span class="number">4</span>  <span class="number">6</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"><span class="number">11</span> <span class="number">1</span>  <span class="number">3</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"><span class="number">12</span> <span class="number">2</span>  <span class="number">2</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-17</span> -</span><br><span class="line"><span class="number">13</span> <span class="number">4</span>  <span class="number">9</span> <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span> -</span><br></pre></td></tr></table></figure><hr><blockquote><p>创建并连接</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">TEST</span>;</span><br><span class="line">\c test;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">postgres=# <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> TEST;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">postgres=<span class="comment"># \c test;</span></span><br><span class="line">您现在已经连接到数据库 <span class="string">"test"</span>,用户 <span class="string">"postgres"</span>.</span><br></pre></td></tr></table></figure><blockquote><p>创建A类表TABLES1</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> A</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> A.TABLES1 (</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">A <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>, </span><br><span class="line">B <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">D <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>);</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">test-# <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> A.TABLES1 (</span><br><span class="line">test(# ID <span class="type">SERIAL</span> <span class="keyword">PRIMARY KEY</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">test(# A <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">test(# B <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">test(# C <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">test(# D <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">test(# <span class="type">TIME</span> <span class="type">DATE</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>向A类表TABLES1内插入数据</p></blockquote><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">INSERT INTO A.TABLES1</span><br><span class="line">(A,B,C,D,TIME)</span><br><span class="line">VALUES</span><br><span class="line">(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-17</span>'),</span><br><span class="line">(<span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>');</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">test=# INSERT INTO A.TABLES1</span><br><span class="line">test-# (A,B,C,D,TIME)</span><br><span class="line">test-# VALUES</span><br><span class="line">test-# (<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">3</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">2</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">7</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">9</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>'),</span><br><span class="line">test-# (<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-17</span>'),</span><br><span class="line">test-# (<span class="number">4</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">7</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-16</span>');</span><br><span class="line">INSERT <span class="number">0</span> <span class="number">13</span></span><br></pre></td></tr></table></figure><p><code>SELECT * FROM A.TABLES1;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test=# SELECT * FROM A.TABLES1;</span><br><span class="line"> id | a | b | c | d |    time    </span><br><span class="line">----+---+---+---+---+------------</span><br><span class="line">  <span class="number">1</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">2</span> | <span class="number">2</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">6</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">3</span> | <span class="number">3</span> | <span class="number">3</span> | <span class="number">9</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">4</span> | <span class="number">1</span> | <span class="number">4</span> | <span class="number">8</span> | <span class="number">3</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">5</span> | <span class="number">2</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">6</span> | <span class="number">2</span> | <span class="number">7</span> | <span class="number">5</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">7</span> | <span class="number">3</span> | <span class="number">7</span> | <span class="number">3</span> | <span class="number">6</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">8</span> | <span class="number">1</span> | <span class="number">8</span> | <span class="number">7</span> | <span class="number">7</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">9</span> | <span class="number">4</span> | <span class="number">1</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">10</span> | <span class="number">4</span> | <span class="number">6</span> | <span class="number">1</span> | <span class="number">9</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">11</span> | <span class="number">1</span> | <span class="number">3</span> | <span class="number">8</span> | <span class="number">1</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">12</span> | <span class="number">2</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-17</span></span><br><span class="line"> <span class="number">13</span> | <span class="number">4</span> | <span class="number">9</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">(<span class="number">13</span> 行记录)</span><br></pre></td></tr></table></figure><hr><blockquote><p>复制A类表TABLES1结构与表内数据于TABLES2</p></blockquote><p><code>SELECT * FROM TABLES2;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test=# SELECT * FROM A.TABLES2;</span><br><span class="line"> id | a | b | c | d |    time    </span><br><span class="line">----+---+---+---+---+------------</span><br><span class="line">  <span class="number">1</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">2</span> | <span class="number">2</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">6</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">3</span> | <span class="number">3</span> | <span class="number">3</span> | <span class="number">9</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">4</span> | <span class="number">1</span> | <span class="number">4</span> | <span class="number">8</span> | <span class="number">3</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">5</span> | <span class="number">2</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">6</span> | <span class="number">2</span> | <span class="number">7</span> | <span class="number">5</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">7</span> | <span class="number">3</span> | <span class="number">7</span> | <span class="number">3</span> | <span class="number">6</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">8</span> | <span class="number">1</span> | <span class="number">8</span> | <span class="number">7</span> | <span class="number">7</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">9</span> | <span class="number">4</span> | <span class="number">1</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">10</span> | <span class="number">4</span> | <span class="number">6</span> | <span class="number">1</span> | <span class="number">9</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">11</span> | <span class="number">1</span> | <span class="number">3</span> | <span class="number">8</span> | <span class="number">1</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line"> <span class="number">12</span> | <span class="number">2</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-17</span></span><br><span class="line"> <span class="number">13</span> | <span class="number">4</span> | <span class="number">9</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">(<span class="number">13</span> 行记录)</span><br></pre></td></tr></table></figure><hr><blockquote><p>输出A类表TABLES1与A类表TABLES2内ID等于6或3与7或4的行</p></blockquote><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A.TABLES1 <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="number">6</span> <span class="keyword">OR</span> <span class="keyword">ID</span>=<span class="number">3</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A.TABLES2 <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="number">7</span> <span class="keyword">OR</span> <span class="keyword">ID</span>=<span class="number">4</span>;</span><br></pre></td></tr></table></figure><p><code>SELECT * FROM A.TABLES1 WHERE ID=6 OR ID=3 UNION SELECT * FROM A.TABLES2 WHERE ID=7 OR ID=4;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test=# SELECT * FROM A.TABLES1 WHERE ID=<span class="number">6</span> OR ID=<span class="number">3</span>              </span><br><span class="line">UNION</span><br><span class="line">SELECT * FROM A.TABLES2 WHERE ID=<span class="number">7</span> OR ID=<span class="number">4</span>;</span><br><span class="line"> id | a | b | c | d |    time    </span><br><span class="line">----+---+---+---+---+------------</span><br><span class="line">  <span class="number">6</span> | <span class="number">2</span> | <span class="number">7</span> | <span class="number">5</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">3</span> | <span class="number">3</span> | <span class="number">3</span> | <span class="number">9</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">4</span> | <span class="number">1</span> | <span class="number">4</span> | <span class="number">8</span> | <span class="number">3</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">7</span> | <span class="number">3</span> | <span class="number">7</span> | <span class="number">3</span> | <span class="number">6</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">(<span class="number">4</span> 行记录)</span><br></pre></td></tr></table></figure><hr><blockquote><p>输出并查询A类表TABLES1内ID等于3或等于4的行</p></blockquote><p><code>SELECT * FROM A.TABLES1 WHERE ID=3 OR ID=4;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test=# SELECT * FROM A.TABLES1 WHERE ID=<span class="number">3</span> OR ID=<span class="number">4</span>;</span><br><span class="line"> id | a | b | c | d |    time    </span><br><span class="line">----+---+---+---+---+------------</span><br><span class="line">  <span class="number">3</span> | <span class="number">3</span> | <span class="number">3</span> | <span class="number">9</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">4</span> | <span class="number">1</span> | <span class="number">4</span> | <span class="number">8</span> | <span class="number">3</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">(<span class="number">2</span> 行记录)</span><br></pre></td></tr></table></figure><hr><blockquote><p>以偏移量为三为前提，输出并查询A类表TABLES1内的三条数据</p></blockquote><p><code>SELECT * FROM A.TABLES1 LIMIT 3 OFFSET 3;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test=# SELECT * FROM A.TABLES1 LIMIT <span class="number">3</span> OFFSET <span class="number">3</span>;</span><br><span class="line"> id | a | b | c | d |    time    </span><br><span class="line">----+---+---+---+---+------------</span><br><span class="line">  <span class="number">4</span> | <span class="number">1</span> | <span class="number">4</span> | <span class="number">8</span> | <span class="number">3</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">5</span> | <span class="number">2</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">1</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">  <span class="number">6</span> | <span class="number">2</span> | <span class="number">7</span> | <span class="number">5</span> | <span class="number">2</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-16</span></span><br><span class="line">(<span class="number">3</span> 行记录)</span><br></pre></td></tr></table></figure><hr><blockquote><p>以偏移量为一为前提与排除所有重复数据为前提，输出并查询A类表TABLES1内的四条数据</p></blockquote><p><code>SELECT DISTINCT A,B,C FROM A.TABLES1 LIMIT 4 OFFSET 1;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test=# SELECT DISTINCT A,B,C FROM A.TABLES1 LIMIT <span class="number">4</span> OFFSET <span class="number">1</span>;</span><br><span class="line"> a | b | c </span><br><span class="line">---+---+---</span><br><span class="line"> <span class="number">1</span> | <span class="number">3</span> | <span class="number">8</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">1</span> | <span class="number">1</span></span><br><span class="line"> <span class="number">2</span> | <span class="number">7</span> | <span class="number">5</span></span><br><span class="line"> <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span></span><br><span class="line">(<span class="number">4</span> 行记录)</span><br></pre></td></tr></table></figure><hr><blockquote><p>将A类表TABLES1内B列的结果基于A列进行分组并求和，分组数量小于10且为降序输出</p></blockquote><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A, <span class="built_in">SUM</span>(B) <span class="keyword">FROM</span> A.TABLES1 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> A </span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">count</span>(A) &lt; <span class="number">10</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> A <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><code>SELECT A, SUM(B) FROM A.TABLES1 GROUP BY A HAVING count(A) &lt; 10 ORDER BY A DESC;</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">test</span>=# SELECT A, SUM(B) <span class="keyword">FROM</span> A.TABLES1<span class="built_in"> GROUP </span>BY A HAVING count(A) &lt; 10 ORDER BY A DESC;</span><br><span class="line"> a | sum </span><br><span class="line">---+-----</span><br><span class="line"> 4 |  16</span><br><span class="line"> 3 |  10</span><br><span class="line"> 2 |  12</span><br><span class="line"> 1 |  16</span><br><span class="line">(4 行记录)</span><br></pre></td></tr></table></figure><ul><li>执行逻辑</li></ul><ol><li>将B映射于A，并对A的数值类型进行分组</li><li>SUM()函数将B中映射于A的数值进行求和</li><li>降序输出且组的数量不能大于10</li></ol><hr><blockquote><p>删除两表内所有数据<br><code>TRUNCATE TABLE A.TABLES1;</code></p></blockquote><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">test=# TRUNCATE <span class="keyword">TABLE</span> A.TABLES1;</span><br><span class="line">TRUNCATE <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><p><code>TRUNCATE A.TABLES2;</code></p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">test=# TRUNCATE <span class="keyword">TABLE</span> A.TABLES2;</span><br><span class="line">TRUNCATE <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><p><code>DROP TABLE A.TABLES1;</code></p><p><code>DROP TABLE A.TABLES2;</code></p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test</span>=# <span class="keyword">DROP</span> <span class="keyword">TABLE</span> A.TABLES1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">test</span>=# <span class="keyword">DROP</span> <span class="keyword">TABLE</span> A.TABLES2;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><p><code>DROP DATABASE TEST;</code></p><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">postgres=# <span class="keyword">DROP</span> <span class="keyword">DATABASE</span> TEST;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span></span><br></pre></td></tr></table></figure><hr><ul><li>没必要去设计特别复杂的逻辑语句,有时适当分句往往能提高工作效率</li></ul><hr><p><strong>相关概念:</strong></p><table><thead><tr><th align="left">概念</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">SELECT</td><td align="left">查询</td></tr><tr><td align="left">FROM</td><td align="left">来源于…</td></tr><tr><td align="left">DISTINCT</td><td align="left">唯一</td></tr><tr><td align="left">WHERE</td><td align="left">条件</td></tr><tr><td align="left">AND&amp;OR</td><td align="left">逻辑与和逻辑或</td></tr><tr><td align="left">LIKE</td><td align="left">类似于…</td></tr><tr><td align="left">LIMIT</td><td align="left">限制查询结果的输出数量</td></tr><tr><td align="left">OFFSET</td><td align="left">查询结果偏移</td></tr><tr><td align="left">ORDER BY (ASC/DESC)</td><td align="left">排序</td></tr><tr><td align="left">GROUP BY</td><td align="left">分组</td></tr><tr><td align="left">HAVING</td><td align="left">分组之上再设置分组条件</td></tr><tr><td align="left">WITH</td><td align="left">子句封装，将使用指令进行封装以便一键执行</td></tr><tr><td align="left">UNION</td><td align="left">连接</td></tr><tr><td align="left">VIEW</td><td align="left">创建视图</td></tr><tr><td align="left">WHERE可以嵌套查询语句</td><td align="left">所执行嵌套的语句被称为内部查询/子查询</td></tr><tr><td align="left">内聚函数</td><td align="left">可以称为内置函数</td></tr><tr><td align="left">TRUNCATE TABLE</td><td align="left">删除表数据</td></tr></tbody></table><hr><p><strong>常用内聚函数参考</strong></p><ul><li>COUNT 函数:用于计算数据库表中的行数</li><li>MAX 函数:用于查询某一特定列中最大值</li><li>MIN 函数:用于查询某一特定列中最小值</li><li>AVG 函数:用于计算某一特定列中平均值</li><li>SUM 函数:用于计算数字列所有值的总和</li><li>ARRAY 函数:用于输入值(包括null)添加到数组中</li><li>Numeric 函数:完整列出一个SQL中所需的操作数的函数</li><li>String 函数:完整列出一个SQL中所需的操作字符的函数</li></ul><p><strong>其他函数类型</strong></p><ul><li>数学函数</li><li>三角函数</li><li>字符函数</li><li>操作符函数</li><li>类型转换函数</li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>ORDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL-2</title>
    <url>/2020/02/15/PostgreSQL-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="PortgreSQL-2"><a href="#PortgreSQL-2" class="headerlink" title="PortgreSQL-2"></a>PortgreSQL-2</h3><ul><li>使用前几章MySQL中所规定的数据模型</li><li>默认超级管理员权限</li></ul><hr><ul><li>创建数据库test1<blockquote><p><code>CREATE DATABASE TEST1;</code></p></blockquote></li></ul><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">postgres=# <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> TEST1;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span></span><br></pre></td></tr></table></figure><ul><li>查看所有数据库<blockquote><p><code>\l</code></p></blockquote></li></ul><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">postgres=<span class="comment"># \l</span></span><br><span class="line">                                     数据库列表</span><br><span class="line">   名称    |<span class="string">  拥有者  </span>|<span class="string"> 字元编码 </span>|<span class="string">  校对规则   </span>|<span class="string">    Ctype    </span>|<span class="string">       存取权限        </span></span><br><span class="line"><span class="string">-----------+----------+----------+-------------+-------------+-----------------------</span></span><br><span class="line"><span class="string"> postgres  </span>|<span class="string"> postgres </span>|<span class="string"> UTF8     </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> template0 </span>|<span class="string"> postgres </span>|<span class="string"> UTF8     </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> =c/postgres          +</span></span><br><span class="line"><span class="string">           </span>|<span class="string">          </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">             </span>|<span class="string"> postgres=CTc/postgres</span></span><br><span class="line"><span class="string"> template1 </span>|<span class="string"> postgres </span>|<span class="string"> UTF8     </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> =c/postgres          +</span></span><br><span class="line"><span class="string">           </span>|<span class="string">          </span>|<span class="string">          </span>|<span class="string">             </span>|<span class="string">             </span>|<span class="string"> postgres=CTc/postgres</span></span><br><span class="line"><span class="string"> test1     </span>|<span class="string"> postgres </span>|<span class="string"> UTF8     </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> zh_CN.UTF-8 </span>|<span class="string"> </span></span><br><span class="line"><span class="string">(4 行记录)</span></span><br></pre></td></tr></table></figure><ul><li>连接数据库，默认用户<code>postgres</code><blockquote><p><code>\c test1;</code></p></blockquote></li></ul><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">postgres=<span class="comment"># \c test1;</span></span><br><span class="line">您现在已经连接到数据库 <span class="string">"test1"</span>,用户 <span class="string">"postgres"</span>.</span><br></pre></td></tr></table></figure><hr><ul><li>模式A<blockquote><p><code>CREATE SCHEMA A;</code></p></blockquote></li></ul><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> A;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span></span><br></pre></td></tr></table></figure><ul><li>表<code>A.tables1</code><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> A.tables1(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">SERIAL</span> PRIMARY <span class="keyword">KEY</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">A <span class="built_in">TEXT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">D <span class="built_in">REAL</span>,</span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> A;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span></span><br><span class="line">test1=# <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> A.tables1(</span><br><span class="line">test1(# ID <span class="type">SERIAL</span> <span class="keyword">PRIMARY KEY</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">test1(# A <span class="type">TEXT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">test1(# B <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">test1(# C <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">UNIQUE</span>,</span><br><span class="line">test1(# D <span class="type">REAL</span>,</span><br><span class="line">test1(# <span class="type">TIME</span> <span class="type">DATE</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><ul><li>索引<blockquote><p><code>CREATE UNIQUE INDEX A_INDEX ON A.TABLES1 (A);</code></p></blockquote></li></ul><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> A_INDEX <span class="keyword">ON</span> A.TABLES1 (A);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span></span><br></pre></td></tr></table></figure><ul><li>别名<blockquote><p><code>SELECT G.ID, G.A, G.B, G.C, G.D FROM TABLES1 AS G;</code></p></blockquote></li></ul><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">test1=# SELECT G.ID, G.A, G.B, G.C, G.D FROM A.TABLES1 AS G;</span><br><span class="line"><span class="code"> id | a | b | c | d </span></span><br><span class="line">----<span class="code">+---+</span>---<span class="code">+---+</span>---</span><br><span class="line">(0 行记录)</span><br></pre></td></tr></table></figure><hr><ul><li>开启事务<blockquote><p><code>BEGIN;或者BEGIN TRANSACTION;</code></p></blockquote></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">INSERT INTO A.tables1 </span><br><span class="line">(A,B,C,D,TIME) </span><br><span class="line">VALUES </span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-13</span>' );</span><br></pre></td></tr></table></figure><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">test1=# INSERT INTO A.tables1 </span><br><span class="line">(A,B,C,D,TIME) </span><br><span class="line">VALUES </span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-14</span>' ),</span><br><span class="line">(<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>, '<span class="number">2020</span><span class="number">-02</span><span class="number">-13</span>' );</span><br><span class="line">INSERT <span class="number">0</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>更新<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> A.TABLES1 <span class="keyword">SET</span> A = <span class="number">2</span> <span class="keyword">WHERE</span> <span class="keyword">ID</span> =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> A.TABLES1 <span class="keyword">SET</span> A = <span class="number">1</span> <span class="keyword">WHERE</span> <span class="keyword">ID</span> =<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li></ul><p><code>SELECT * FROM A.TABLES1;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">test1=# SELECT * FROM A.TABLES1;</span><br><span class="line"> id | a | b | c | d |    time    </span><br><span class="line">----+---+---+---+---+------------</span><br><span class="line">  <span class="number">3</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">1</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span></span><br><span class="line">  <span class="number">4</span> | <span class="number">2</span> | <span class="number">2</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span></span><br><span class="line">  <span class="number">5</span> | <span class="number">3</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span></span><br><span class="line">  <span class="number">6</span> | <span class="number">4</span> | <span class="number">2</span> | <span class="number">4</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span></span><br><span class="line">  <span class="number">7</span> | <span class="number">0</span> | <span class="number">2</span> | <span class="number">0</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-13</span></span><br><span class="line">(<span class="number">5</span> 行记录)</span><br></pre></td></tr></table></figure><ul><li>修改<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> A.TABLES1 <span class="keyword">ADD</span> E <span class="built_in">CHAR</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> A.TABLES1 <span class="keyword">ADD</span> F <span class="built_in">CHAR</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> A.TABLES1 <span class="keyword">ADD</span> E <span class="type">CHAR</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">test1=# <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> A.TABLES1 <span class="keyword">ADD</span> F <span class="type">CHAR</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><p><code>SELECT * FROM A.TABLES1;</code></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">test1=<span class="comment"># SELECT * FROM A.TABLES1;</span></span><br><span class="line"> id |<span class="string"> a </span>|<span class="string"> b </span>|<span class="string"> c </span>|<span class="string"> d </span>|<span class="string">    time    </span>|<span class="string"> e </span>|<span class="string"> f </span></span><br><span class="line"><span class="string">----+---+---+---+---+------------+---+---</span></span><br><span class="line"><span class="string">  3 </span>|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 1 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  4 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  5 </span>|<span class="string"> 3 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  6 </span>|<span class="string"> 4 </span>|<span class="string"> 2 </span>|<span class="string"> 4 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  7 </span>|<span class="string"> 0 </span>|<span class="string"> 2 </span>|<span class="string"> 0 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-13 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">(5 行记录)</span></span><br></pre></td></tr></table></figure><ul><li>锁<blockquote><p><code>LOCK TABLE A.TABLES1 IN ACCESS EXCLUSIVE MODE;</code></p></blockquote></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">LOCK</span> <span class="keyword">TABLE</span> A.TABLES1 <span class="keyword">IN</span> <span class="keyword">ACCESS</span> <span class="keyword">EXCLUSIVE MODE</span>;</span><br><span class="line"><span class="keyword">LOCK</span> <span class="keyword">TABLE</span></span><br></pre></td></tr></table></figure><ul><li>关闭事务<blockquote><p><code>COMMIT;或者END TRANSACTION;</code></p></blockquote></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">END</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">COMMIT</span></span><br></pre></td></tr></table></figure><hr><ul><li>查询表格是否存在<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">\d</span><br><span class="line">\d <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>table1</span><br><span class="line">SELECT<span class="operator"> * </span>FROM <span class="module-access"><span class="module"><span class="identifier">A</span>.</span></span>tables1;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">test1=<span class="comment"># \d A.TABLES1;</span></span><br><span class="line">                                数据表 <span class="string">"a.tables1"</span></span><br><span class="line"> 栏位 |<span class="string">     类型     </span>|<span class="string"> 校对规则 </span>|<span class="string">  可空的  </span>|<span class="string">                 预设                  </span></span><br><span class="line"><span class="string">------+--------------+----------+----------+---------------------------------------</span></span><br><span class="line"><span class="string"> id   </span>|<span class="string"> integer      </span>|<span class="string">          </span>|<span class="string"> not null </span>|<span class="string"> nextval('a.tables1_id_seq'::regclass)</span></span><br><span class="line"><span class="string"> a    </span>|<span class="string"> text         </span>|<span class="string">          </span>|<span class="string"> not null </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> b    </span>|<span class="string"> integer      </span>|<span class="string">          </span>|<span class="string"> not null </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> c    </span>|<span class="string"> character(1) </span>|<span class="string">          </span>|<span class="string">          </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> d    </span>|<span class="string"> real         </span>|<span class="string">          </span>|<span class="string">          </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> time </span>|<span class="string"> date         </span>|<span class="string">          </span>|<span class="string">          </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> e    </span>|<span class="string"> character(1) </span>|<span class="string">          </span>|<span class="string">          </span>|<span class="string"> </span></span><br><span class="line"><span class="string"> f    </span>|<span class="string"> character(1) </span>|<span class="string">          </span>|<span class="string">          </span>|<span class="string"> </span></span><br><span class="line"><span class="string">索引：</span></span><br><span class="line"><span class="string">    "tables1_pkey" PRIMARY KEY, btree (id)</span></span><br><span class="line"><span class="string">    "a_index" UNIQUE, btree (a)</span></span><br><span class="line"><span class="string">    "tables1_c_key" UNIQUE CONSTRAINT, btree (c)</span></span><br></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">test1=<span class="comment"># SELECT * FROM A.tables1;</span></span><br><span class="line"> id |<span class="string"> a </span>|<span class="string"> b </span>|<span class="string"> c </span>|<span class="string"> d </span>|<span class="string">    time    </span>|<span class="string"> e </span>|<span class="string"> f </span></span><br><span class="line"><span class="string">----+---+---+---+---+------------+---+---</span></span><br><span class="line"><span class="string">  3 </span>|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 1 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  4 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 2 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  5 </span>|<span class="string"> 3 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  6 </span>|<span class="string"> 4 </span>|<span class="string"> 2 </span>|<span class="string"> 4 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">  7 </span>|<span class="string"> 0 </span>|<span class="string"> 2 </span>|<span class="string"> 0 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-13 </span>|<span class="string">   </span>|<span class="string"> </span></span><br><span class="line"><span class="string">(5 行记录)</span></span><br></pre></td></tr></table></figure><hr><ul><li>删除<blockquote><p><code>DROP SCHEMA A CASCADE;</code><br><code>DROP TABLE TABLES1;</code><br><code>DROP DATABASE TEST1;</code></p></blockquote></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">test1=# <span class="keyword">DROP</span> <span class="keyword">SCHEMA</span> A <span class="keyword">CASCADE</span>;</span><br><span class="line">注意:  递归删除 表 a.<span class="keyword">tables</span></span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line">postgres=# <span class="keyword">DROP</span> <span class="keyword">DATABASE</span> TEST1;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span></span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>ORDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL-1</title>
    <url>/2020/02/15/PostgreSQL-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="PostgreSQL-1"><a href="#PostgreSQL-1" class="headerlink" title="PostgreSQL-1"></a>PostgreSQL-1</h3><p><strong>概述:</strong></p><ul><li>ORDBMS(关系数据库服务器)</li><li>基于BSD许可证发行</li></ul><hr><p><strong>基本特征:</strong></p><ul><li>函数:通过函数，可以在数据库服务器端执行指令程序</li><li>索引:用户可以自定义索引方法，或使用内置的<code>B树</code>，<code>哈希表</code>与<code>GiST索引</code></li><li>触发器:触发器是由SQL语句查询所触发的事件，如：一个INSERT语句可能触发一个检查数据完整性的触发器。触发器通常由<code>INSERT</code>或<code>UPDATE</code>语句触发</li><li>多版本并发控制:PostgreSQL使用多版本并发控制(MVCC，Multiversion concurrency control)系统进行并发控制，该系统向每个用户提供了一个数据库的”快照”，用户在事务内所作的每个修改，对于其他的用户都不可见，直到该事务成功提交</li><li>规则:规则(RULE)允许一个查询能被重写，通常用来实现对视图(VIEW)的操作，如插入(INSERT)、更新(UPDATE)、删除(DELETE)</li><li>数据类型:包括文本、任意精度的数值数组、<code>JSON数据</code>、<code>枚举类型</code>、<code>XML数据等</code></li><li>全文检索:通过<code>Tsearch2</code>或<code>OpenFTS</code>，<code>8.3版本</code>中内嵌<code>Tsearch2</code></li><li>NoSQL:<code>JSON</code>，<code>JSONB</code>，<code>XML</code>，<code>HStore</code>原生支持，至<code>NoSQL</code>数据库的外部数据包装器</li><li>数据仓库:能平滑迁移至同属<code>PostgreSQL</code>生态的<code>GreenPlum</code>，<code>DeepGreen</code>，<code>HAWK</code>等，使用<code>FDW</code>进行<code>ETL</code></li><li>PostpreSQL与MySQL的语法与模式完全不同</li></ul><hr><p><strong>安装:</strong></p><ul><li><code>apt-get</code>全自动安装<blockquote><p><code>$ sudo apt-get install postgresql postgresql-client</code></p></blockquote></li><li>安装完毕后，系统会创建一个数据库超级用户postgres，密码为空<blockquote><p><code># sudo -i -u postgres</code></p></blockquote></li><li>进入postgres命令行提示符<blockquote><p><code>$ psql</code></p></blockquote></li><li>退出PostgreSQL命令行提示符<blockquote><p><code>\q</code></p></blockquote></li></ul><hr><ul><li>基本配置与帮助</li><li>可执行文件目录<blockquote><p><code>/etc/init.d/postgresql</code><br><code>/etc/postgresql</code></p></blockquote></li><li>配置文件目录<blockquote><p><code>/usr/lib/postgresql</code></p></blockquote></li><li>帮助文档目录<blockquote><p><code>/usr/share/postgresql</code></p></blockquote></li><li>帮助指令<blockquote><p><code>postgres-# \help &lt;command_name&gt;</code></p></blockquote></li><li>例如<blockquote><p><code>postgres=# \help SELECT</code></p></blockquote></li><li>查看所有帮助(指令用法)<blockquote><p><code>postgres=# \?</code></p></blockquote></li></ul><hr><p><strong>其他:</strong></p><ul><li><code>pgAdmin</code>工具(图形化管理与操作工具)</li><li><code>pgAdmin</code>工具提供了完整操作数据库的功能</li><li>类似于MySQL的<code>MySQLadmin</code></li><li>封装命令</li><li>进入<code>PostpreSQL</code>的可执行目录内执行(/安装目录/bin)</li><li>PostgreSQL特有性质，例如<code>CREATE DATABASE</code>语句等同于<code>createdb</code>命令</li><li>文案中将会避免使用封装命令，而尽可能多的使用SQL标准中所规定的标准语句</li><li>封装命令的执行不需要添加分号(<code>;</code>)</li><li>关于权限的使用与说明本篇不做阐述</li></ul><hr><ul><li><p><code>createdb</code>命令语法格式如下:</p></li><li><p>进入<code>PostpreSQL</code>的可执行目录内执行</p><blockquote><p><code>createdb [option...] [dbname [description]]</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>dbname</code>:要创建的数据库名<br><code>description</code>:关于新创建的数据库相关的说明<br><code>options</code>:参数可选项，具体参考官方中文手册</p></blockquote></li><li><p><code>psql</code>连接工具语法</p></li><li><p><code>psql</code>的命令都是以斜杠<code>\</code>开头的</p></li><li><p>关于<code>\</code>的具体使用，本篇将不会多做阐述</p><blockquote><p><code>psql -h &lt;hostname or ip&gt; -p &lt;端口&gt; [数据库名称] [用户名称]</code></p></blockquote></li><li><p>执行存储在外部文件中的SQL命令</p><blockquote><p><code>\i &lt;文件名&gt;</code>执行存储在外部文件中的sql语句<br>当然也可以在<code>psql命令行</code>加<code>-s &lt;filename&gt;</code>来执行SQL脚本文件中的命令<br>如<code>psql -s test.sql</code></p></blockquote></li></ul><hr><p><strong>快速参考</strong></p><ul><li>相关概念简述:</li><li>数据类型</li><li>运算符</li><li>表达式</li><li>触发器</li><li>NULL</li><li>子查询/嵌套查询/内部查询</li><li>事务</li><li>函数</li></ul><hr><ul><li>模式 <code>SCHEMA</code></li><li>别名 <code>AS</code></li><li>序列 <code>smallserial/serial/bigserial(AUTO_INCREMENT)</code></li><li>排序/分组 <code>order by(asc/desc)/group by</code></li><li>连接 <code>UNION/JOIN LEFT/RIGHT/PULL/INNER/CROSS</code></li><li>索引 <code>INDEX</code></li><li>约束 <code>PRIMARY KEY/FOREIGN KEY/CHECK/EXCLUSION/UNIQUE/NOT NULL</code></li><li>视图 <code>VIEW</code></li><li>锁 <code>LOCK</code></li><li>权限 <code>GRANT</code></li><li>时间/日期 <code>DATE</code></li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>手册CN<a href="http://www.postgres.cn/docs/9.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.postgres.cn/docs/9.6/</code></p></blockquote></li><li><p>10.1手册源码CN<a href="https://github.com/postgres-cn/pgdoc-cn/wiki/pg10" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/postgres-cn/pgdoc-cn/wiki/pg10</code></p></blockquote></li><li><p>最新版手册源码CN<a href="https://github.com/postgres-cn/pgdoc-cn/releases" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/postgres-cn/pgdoc-cn/releases</code></p></blockquote></li><li><p>手册翻译社区CN<a href="https://github.com/postgres-cn/pgdoc-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/postgres-cn/pgdoc-cn</code></p></blockquote></li><li><p>官方网站<a href="https://www.postgresql.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.postgresql.org/</code></p></blockquote></li><li><p>下载地址<a href="https://www.postgresql.org/download/linux/debian/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.postgresql.org/download/linux/debian/</code></p></blockquote></li><li><p>软件源码<a href="https://www.postgresql.org/ftp/source/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.postgresql.org/ftp/source/</code></p></blockquote></li><li><p><code>apt-get</code>获取</p><blockquote><p><code>apt-get install postgresql postgresql-client</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>ORDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-5</title>
    <url>/2020/02/15/MySQL-5/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MySQL-5"><a href="#MySQL-5" class="headerlink" title="MySQL-5"></a>MySQL-5</h3><ul><li>MySQL补充内容</li><li>MySQL可执行目录/usr/bin/mysql</li><li>MySQL配置文件目录/etc/my.cnf</li></ul><hr><p><strong>添加用户</strong></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO<span class="built_in"> user </span></span><br><span class="line">          (host, user, password, </span><br><span class="line">           select_priv, insert_priv, update_priv) </span><br><span class="line">           VALUES (<span class="string">'localhost'</span>, <span class="string">'guest'</span>, </span><br><span class="line">           PASSWORD(<span class="string">'guest123'</span>), <span class="string">'Y'</span>, <span class="string">'Y'</span>, <span class="string">'Y'</span>);</span><br><span class="line">Query OK, 1 row affected (0.20 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>泛用指令</strong></p><ul><li><p>设置权限</p><blockquote><p><code>chown mysql:mysql -R /var/lib/mysql</code></p></blockquote></li><li><p>初始化</p><blockquote><p><code>mysqld --initialize</code></p></blockquote></li><li><p>查看所有数据库</p><blockquote><p><code>SHOW DATABASES;</code></p></blockquote></li><li><p>查看当前数据库内所有表</p><blockquote><p><code>SHOW TABLES;</code></p></blockquote></li><li><p>显示数据表的属性，属性类型，主键信息 ，是否为NULL，默认值等其他信息</p><blockquote><p><code>SHOW COLUMNS FROM 数据表;</code></p></blockquote></li><li><p>显示数据表的详细索引信息，包括<code>PRIMARY KEY</code>(主键)</p><blockquote><p><code>SHOW INDEX FROM 数据表;</code></p></blockquote></li><li><p>输出Mysql数据库管理系统的性能及统计信息</p><blockquote><p><code>SHOW TABLE STATUS LIKE [FROM db_name] [LIKE &#39;pattern&#39;] \G;</code></p></blockquote></li></ul><hr><p><strong>RDBMS-MySQL参考资料</strong></p><ul><li><p>mysql官网<a href="https://www.mysql.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.mysql.com/</code></p></blockquote></li><li><p>mysql下载地址<a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://dev.mysql.com/downloads/</code></p></blockquote></li><li><p>文档(EN)<a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://dev.mysql.com/doc/</code></p></blockquote></li></ul><hr><ul><li><p>MariaDB官网<a href="https://mariadb.org" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mariadb.org</code></p></blockquote></li><li><p>MariaDB下载地址<a href="https://mariadb.org/download/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mariadb.org/download/</code></p></blockquote></li><li><p>文档(CN)<a href="https://mariadb.com/kb/zh-cn/mariadb/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mariadb.com/kb/zh-cn/mariadb/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-4</title>
    <url>/2020/02/15/MySQL-4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MySQL数据导出与导入"><a href="#MySQL数据导出与导入" class="headerlink" title="MySQL数据导出与导入"></a>MySQL数据导出与导入</h3><p><strong>导出</strong></p><ul><li><p>所导出目标文件必须为有可读写权限</p></li><li><p>使用<code>SELECT ... INTO OUTFILE</code>语句</p></li><li><p>基本语法:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="built_in">table_name</span></span><br><span class="line">    -&gt; <span class="keyword">INTO</span> OUTFILE <span class="string">'目标路径'</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用mysqldump导出原始数据</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p --no-create-<span class="builtin-name">info</span> \</span><br><span class="line">            <span class="attribute">--tab</span>=/目标文件路径 database_name table_name</span><br><span class="line">password:</span><br></pre></td></tr></table></figure></li><li><p>导出SQL格式的文件</p></li><li><p>不添加<code>table_name</code>导出整个数据库</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">$ mysqldump -u root -p database_name table_name &gt; 目标文件路径</span><br><span class="line"><span class="symbol">password:</span></span><br></pre></td></tr></table></figure></li><li><p>导出所有数据库</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> mysqldump -u root -p --<span class="keyword">all</span>-databases &gt; 目标文件路径</span><br><span class="line">password:</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>导入</strong></p><ul><li><p>mysql 命令导入</p><blockquote><p><code>mysql -u username -p passwrod &lt; 要导入的数据库数据文件路径(xxx.sql)</code></p></blockquote></li><li><p>source 命令导入</p></li><li><p>登录到数库终端执行以下命令</p><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line">mysql&gt; USE DATABASE_NAME;</span><br><span class="line">mysql&gt; <span class="keyword">SET</span> NAMES <span class="comment">utf8</span>;</span><br><span class="line">mysql&gt; SOURCE /目标文件路径(.sql)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight elm"><table><tr><td class="code"><pre><span class="line"><span class="title">mysqlimport</span>导入</span><br><span class="line">$ mysql<span class="keyword">import</span> -u root -p <span class="comment">--local tables_name /被导入文件路径</span></span><br><span class="line"><span class="title">password</span> *****</span><br></pre></td></tr></table></figure><hr><p><strong>PHP语法简介</strong></p><ul><li>PHP Mysqli</li><li>mysqli()函数</li></ul><p><strong>格式</strong></p><blockquote><p><code>mysqli_function(value,value,...);</code></p></blockquote><ul><li>以上格式中function部分描述了mysqli()函数的功能，例如:<blockquote><p><code>mysqli_connect($connect);</code><br><code>mysqli_query($connect,&quot;SQL 语句&quot;);</code><br><code>mysqli_fetch_array()</code><br><code>mysqli_close()</code></p></blockquote></li></ul><hr><p><strong>mysqladmin用法简述</strong></p><ul><li><p>管理性操作语法</p><blockquote><p><code>mysqladmin [OPTIONS] command [command-option] command ...</code></p></blockquote></li><li><p>帮助指令</p><blockquote><p><code>mysqladmin --help</code></p></blockquote></li><li><p>连接</p><blockquote><p><code>mysqladmin -u[username] -p[password] status</code></p></blockquote></li></ul><hr><p><strong>简要参数:</strong></p><table><thead><tr><th align="left">参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">create databasename</td><td align="left">创建一个新数据库</td></tr><tr><td align="left">drop databasename</td><td align="left">删除一个数据库及其所有表</td></tr><tr><td align="left">shutdown</td><td align="left">关掉服务器</td></tr><tr><td align="left">kill id,id,…</td><td align="left">杀死mysql线程</td></tr><tr><td align="left">flush-logs</td><td align="left">清理掉所有日志</td></tr><tr><td align="left">flush-tables</td><td align="left">清理掉所有表</td></tr><tr><td align="left">ping</td><td align="left">检查mysqld是否存在</td></tr></tbody></table><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-参考</title>
    <url>/2020/02/14/SQL-%E5%8F%82%E8%80%83/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="SQL-参考"><a href="#SQL-参考" class="headerlink" title="SQL 参考"></a>SQL 参考</h3><p><strong>按出现次数排行</strong></p><p><strong>重要指令一览</strong></p><table><thead><tr><th align="left">指令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">SELECT</td><td align="left">从数据库中提取数据</td></tr><tr><td align="left">UPDATE</td><td align="left">更新数据库中的数据</td></tr><tr><td align="left">DELETE</td><td align="left">从数据库中删除数据</td></tr><tr><td align="left">INSERT INTO</td><td align="left">向数据库中插入新数据</td></tr><tr><td align="left">CREATE DATABASE</td><td align="left">创建新数据库</td></tr><tr><td align="left">ALTER DATABASE</td><td align="left">修改数据库</td></tr><tr><td align="left">CREATE TABLE</td><td align="left">创建新表</td></tr><tr><td align="left">ALTER TABLE</td><td align="left">变更(改变)数据库表</td></tr><tr><td align="left">DROP TABLE</td><td align="left">删除表</td></tr><tr><td align="left">CREATE INDEX</td><td align="left">创建索引(搜索键)</td></tr><tr><td align="left">DROP INDEX</td><td align="left">删除索引</td></tr></tbody></table><hr><p><strong>基本语句</strong></p><table><thead><tr><th align="left">语句</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">CREATE</td><td align="left">创建</td></tr><tr><td align="left">TABLE</td><td align="left">数据表</td></tr><tr><td align="left">DATABASE</td><td align="left">数据库</td></tr><tr><td align="left">SELECT</td><td align="left">选择</td></tr><tr><td align="left">ALTER</td><td align="left">变更/修改</td></tr><tr><td align="left">INSERT</td><td align="left">插入</td></tr><tr><td align="left">UPDATE</td><td align="left">更新</td></tr><tr><td align="left">DELETE</td><td align="left">删除</td></tr><tr><td align="left">VIEWS</td><td align="left">视图</td></tr></tbody></table><hr><p><strong>逻辑语句</strong></p><table><thead><tr><th align="left">单词</th><th align="left">翻译</th></tr></thead><tbody><tr><td align="left">WHERE</td><td align="left">在…</td></tr><tr><td align="left">FROM</td><td align="left">来自…</td></tr><tr><td align="left">AND&amp;OR</td><td align="left">逻辑与/逻辑或</td></tr><tr><td align="left">LIKE</td><td align="left">类似于…/像…</td></tr><tr><td align="left">IN</td><td align="left">在…内</td></tr><tr><td align="left">JOIN</td><td align="left">连接</td></tr><tr><td align="left">INNER/LEFT/RIGHT/FULL</td><td align="left">内部/左部/右部/全部</td></tr><tr><td align="left">UNION</td><td align="left">并集/组合</td></tr></tbody></table><hr><p><strong>关键字/操作符</strong></p><table><thead><tr><th align="left">单词</th><th align="left">翻译</th></tr></thead><tbody><tr><td align="left">DISTINCT</td><td align="left">不同的</td></tr><tr><td align="left">ORDER</td><td align="left">顺序</td></tr><tr><td align="left">ORDER BY</td><td align="left">以…排序</td></tr><tr><td align="left">ASC</td><td align="left">DESC</td></tr><tr><td align="left">TOP/LIMIT/ROWNUM</td><td align="left">极限/最大化</td></tr><tr><td align="left">BETWEEN</td><td align="left">在…之间</td></tr><tr><td align="left">UNIQUE</td><td align="left">独特</td></tr><tr><td align="left">FOREIGN</td><td align="left">外来的</td></tr><tr><td align="left">CHECK</td><td align="left">阻止/检查</td></tr><tr><td align="left">DEFAULT</td><td align="left">默认</td></tr><tr><td align="left">INDEX</td><td align="left">索引/指标</td></tr><tr><td align="left">DROP</td><td align="left">中止</td></tr><tr><td align="left">ADD</td><td align="left">添加</td></tr><tr><td align="left">COLUMN</td><td align="left">纵列</td></tr><tr><td align="left">INTO</td><td align="left">到…内</td></tr><tr><td align="left">PRIMARY</td><td align="left">主键/首要/基本</td></tr><tr><td align="left">AUTO</td><td align="left">自动/自动模式</td></tr><tr><td align="left">INCREMENT</td><td align="left">递增/增加</td></tr><tr><td align="left">NOT</td><td align="left">否</td></tr></tbody></table><hr><p><strong>其他一</strong></p><table><thead><tr><th align="left">单词</th><th align="left">翻译</th></tr></thead><tbody><tr><td align="left">USE</td><td align="left">使用/选择</td></tr><tr><td align="left">VALUES</td><td align="left">值</td></tr><tr><td align="left">SET</td><td align="left">位于…</td></tr><tr><td align="left">AS</td><td align="left">例如/向…</td></tr><tr><td align="left">NULL</td><td align="left">空/无</td></tr><tr><td align="left">BY</td><td align="left">由/被/到…之前</td></tr><tr><td align="left">HAVING</td><td align="left">具有</td></tr><tr><td align="left">ON</td><td align="left">在…上/触发/打开</td></tr><tr><td align="left">IN</td><td align="left">在…内</td></tr><tr><td align="left">ALL</td><td align="left">全部</td></tr><tr><td align="left">TRUNCATE</td><td align="left">截取</td></tr><tr><td align="left">CONSTRAINT</td><td align="left">约束</td></tr><tr><td align="left"><code>*</code></td><td align="left">泛用通配符</td></tr></tbody></table><hr><p><strong>其他二</strong></p><table><thead><tr><th align="left">单词</th><th align="left">翻译</th></tr></thead><tbody><tr><td align="left">column</td><td align="left">列</td></tr><tr><td align="left">table</td><td align="left">表</td></tr><tr><td align="left">operator</td><td align="left">操作符</td></tr><tr><td align="left">valueN</td><td align="left">值</td></tr><tr><td align="left">some</td><td align="left">某个</td></tr><tr><td align="left">Persons</td><td align="left">个体</td></tr><tr><td align="left">percent</td><td align="left">占比</td></tr><tr><td align="left">external</td><td align="left">外部</td></tr><tr><td align="left">DB</td><td align="left">数据库</td></tr><tr><td align="left">type</td><td align="left">类型</td></tr><tr><td align="left">size</td><td align="left">尺寸/大小</td></tr><tr><td align="left">Last</td><td align="left">末尾</td></tr><tr><td align="left">First</td><td align="left">起始</td></tr></tbody></table><hr><p><strong>语句参考</strong></p><ul><li>ALTER TABLE</li><li>CREATE DATABASE</li><li>CREATE INDEX</li><li>CREATE TABLE</li><li>CREATE VIEW</li><li>DROP DATABASE</li><li>DROP INDEX</li><li>DROP TABLE</li><li>INSERT INTO</li><li>INNER JOIN</li><li>LEFT JOIN</li><li>RIGHT JOIN</li><li>FULL JOIN</li><li>SELECT DISTINCT</li><li>SELECT INTO</li><li>SELECT TOP</li><li>TRUNCATE TABLE</li><li>UNION ALL</li><li>GROUP BY</li><li>ORDER BY</li><li>SELECT *</li></ul><hr><p><strong>子句参考</strong></p><ul><li>WHERE</li><li>UPDATE</li><li>UNION</li><li>SELECT</li><li>LIKE</li><li>IN</li><li>HAVING</li><li>DELETE</li><li>BETWEEN</li><li>AS (alias)</li><li>AND/OR</li></ul><hr><p><strong>概念</strong></p><ul><li>通配符</li><li>别名</li><li>约束</li><li>索引</li><li>函数</li><li>通用数据类型</li><li>DB 数据类型</li></ul><hr><p><strong>最泛用常用函数</strong></p><blockquote><p>DATE()<br>NULL()</p></blockquote><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>RDBMS-MySQL</title>
    <url>/2020/02/14/RDBMS-MySQL/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="RDBMS-MySQL"><a href="#RDBMS-MySQL" class="headerlink" title="RDBMS-MySQL"></a>RDBMS-MySQL</h3><p><strong>RDBMS-MySQL相关概念简述</strong></p><ul><li>数据库: 数据库是一些关联表的集合</li><li>数据表: 表是数据的矩阵，在一个数据库中的表看起来像一个简单的电子表格</li><li>列: 一列(数据元素) 包含了相同类型的数据, 例如邮政编码的数据</li><li>行: 一行（=元组，或记录）是一组相关的数据，例如一条用户订阅的数据</li><li>冗余: 存储两倍数据，冗余降低了性能，但提高了数据的安全性</li><li>主键: 主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据</li><li>外键: 外键用于关联两个表</li><li>复合键: 复合键（组合键）将多个列作为一个索引键，一般用于复合索引</li><li>索引: 使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。类似于书籍的目录</li><li>参照完整性: 参照的完整性要求关系中不允许引用不存在的实体。与实体完整性是关系模型必须满足的完整性约束条件，目的是保证数据的一致性</li><li>表头(header): 每一列的名称</li><li>列(col): 具有相同数据类型的数据的集合</li><li>行(row): 每一行用来描述某条记录的具体信息</li><li>值(value): 行的具体信息, 每个值必须与该列的数据类型相同</li><li>键(key): 键的值在当前列中具有唯一性</li><li>所谓的”关系型”可以理解为”表格”的概念, 一个关系型数据库由一个或数个表格组成</li></ul><hr><p><strong>MySQL</strong></p><ul><li>MySQL 为关系型数据库(Relational Database Management System)</li><li>MySQL -server- MySQL 服务器程序</li><li>MySQL-client - MySQL 客户端程序，用于连接并操作Mysql服务器</li><li>MySQL-devel - 库和包含文件，如果你想要编译其它MySQL客户端</li><li>MySQL-shared - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so)，使用MySQL</li><li>MySQL-bench - MySQL数据库服务器的基准和性能测试工具</li></ul><hr><p><strong>RDBMS-MySQL的三种连接方式</strong></p><ul><li>二进制连接 mysql -u username -p password</li><li>Shell连接 使用MySQLadmin工具</li><li>PHP连接不做阐述</li></ul><hr><p><strong>其他概念</strong></p><ul><li>数据类型</li><li>运算符</li><li>正则表达式</li><li>索引</li><li>元数据</li><li>序列</li><li>函数</li><li>MySQLadmin指令</li><li>PHP连接</li><li>SQL注入</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-3</title>
    <url>/2020/02/14/MySQL-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MySQL-3"><a href="#MySQL-3" class="headerlink" title="MySQL-3"></a>MySQL-3</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">CREATE</span> DATABLE TEST1;</span><br><span class="line"><span class="keyword">USE</span> TEST1;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> TEST1;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; USE TEST1;</span><br><span class="line"><span class="keyword">Database</span> changed</span><br></pre></td></tr></table></figure><p>分别建立TABLES1,TABLES2(唯一键值)</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES1(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">A <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">D <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> ( <span class="keyword">ID</span>, A, B )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><hr><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES2(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">A <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">D <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> ( <span class="keyword">ID</span>, A, B )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; CREATE TABLE TABLES1(</span><br><span class="line">    -&gt; ID INT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    -&gt; A VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; B VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; C VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; D VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; TIME DATE,</span><br><span class="line">    -&gt; PRIMARY KEY ( ID, A, B )</span><br><span class="line">    -&gt; )<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.061 sec)</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; CREATE TABLE TABLES2(</span><br><span class="line">    -&gt; ID INT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    -&gt; A VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; B VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; C VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; D VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; TIME DATE,</span><br><span class="line">    -&gt; UNIQUE ( ID, A, B )</span><br><span class="line">    -&gt; )<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.006 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>向TABLES1插入数据</strong></p><ul><li>4<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure></li><li>1<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">'2020-02-13'</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.003</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("2","3","4","5",<span class="string">'2020-02-13'</span>);</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.002</span> sec)</span><br></pre></td></tr></table></figure><hr><p><strong>复制TABLES1内数据到TABLES2</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2 (<span class="keyword">ID</span>,A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>,A,B,C,D,<span class="built_in">TIME</span></span><br><span class="line"><span class="keyword">FROM</span> TABLES1;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2 (ID,A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">SELECT</span> ID,A,B,C,D,<span class="type">TIME</span></span><br><span class="line">    -&gt; <span class="keyword">FROM</span> TABLES1;</span><br><span class="line">Query OK, <span class="number">5</span> <span class="keyword">rows</span> affected (<span class="number">0.001</span> sec)</span><br><span class="line">Records: <span class="number">5</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p><strong>复制TABLES1内数据到TABLES3</strong></p><ul><li>查看标结构<blockquote><p><code>SHOW CREATE TABLE TABLES1 \G;</code></p></blockquote></li></ul><p><strong>将表内结构规划语句拷贝并执行,并命名为TABLES3</strong><br><strong>复制数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3 (<span class="keyword">ID</span>,A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>,A,B,C,D,<span class="built_in">TIME</span></span><br><span class="line"><span class="keyword">FROM</span> TABLES1;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SHOW CREATE TABLE TABLES1 \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: TABLES1</span><br><span class="line">Create Table: CREATE TABLE `TABLES1` (</span><br><span class="line">  `ID` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `A` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `B` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `C` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `D` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `TIME` date<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (`ID`,`A`,`B`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB <span class="attribute">AUTO_INCREMENT</span>=6<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.000 sec)</span><br><span class="line"></span><br><span class="line">ERROR: <span class="literal">No</span> query specified</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `TABLES3` (</span><br><span class="line">  `ID` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `A` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `B` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `C` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `D` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  `TIME` date<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY KEY (`ID`,`A`,`B`)</span><br><span class="line">) <span class="attribute">ENGINE</span>=InnoDB <span class="attribute">AUTO_INCREMENT</span>=6<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8</span><br><span class="line">;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; CREATE TABLE `TABLES3` (</span><br><span class="line">    -&gt;   `ID` int(11) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    -&gt;   `A` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   `B` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   `C` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   `D` varchar(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   `TIME` date<span class="built_in"> DEFAULT </span><span class="literal">NULL</span>,</span><br><span class="line">    -&gt;   PRIMARY KEY (`ID`,`A`,`B`)</span><br><span class="line">    -&gt; ) <span class="attribute">ENGINE</span>=InnoDB <span class="attribute">AUTO_INCREMENT</span>=6<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.042 sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3 (<span class="keyword">ID</span>,A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">ID</span>,A,B,C,D,<span class="built_in">TIME</span></span><br><span class="line"><span class="keyword">FROM</span> TABLES1;</span><br></pre></td></tr></table></figure><hr><p><code>SHOW TABLES;</code></p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SHOW TABLES;</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">| Tables<span class="emphasis">_in_</span>TEST1 |</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">| TABLES1         |</span><br><span class="line">| TABLES2         |</span><br><span class="line">| TABLES3         |</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">3 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLES1;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLES2;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLES3;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES1;</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">| ID | A | B | C | D | TIME       |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">2</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">3</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">4</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">5</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-13</span> |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES2;</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">| ID | A | B | C | D | TIME       |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">2</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">3</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">4</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">5</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-13</span> |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES3;</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">| ID | A | B | C | D | TIME       |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">2</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">3</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">4</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">5</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-13</span> |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><hr><p><strong>统计表TABLES1内A列与B列中重复的数据</strong></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">SELECT COUNT(*) as repetitions, A, B</span><br><span class="line"><span class="keyword">FROM</span> TABLES1</span><br><span class="line">GROUP BY A, B</span><br><span class="line">HAVING repetitions &gt; 1;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT COUNT(*) as repetitions, A, B</span><br><span class="line">    -&gt; <span class="keyword">FROM</span> TABLES1</span><br><span class="line">    -&gt;<span class="built_in"> GROUP </span>BY A, B</span><br><span class="line">    -&gt; HAVING repetitions &gt; 1;</span><br><span class="line">+-------------+---+---+</span><br><span class="line">| repetitions | A | B |</span><br><span class="line">+-------------+---+---+</span><br><span class="line">|           4 | 1 | 2 |</span><br><span class="line">+-------------+---+---+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="builtin-name">set</span> (0.000 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>过滤重复数据并输出TABLES1内数据</strong></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT A, B</span><br><span class="line"><span class="keyword">FROM</span> TABLES1;</span><br><span class="line">或</span><br><span class="line">SELECT A, B</span><br><span class="line"><span class="keyword">FROM</span> TABLES2</span><br><span class="line">GROUP BY (C);</span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT DISTINCT A, B</span><br><span class="line"><span class="code">    -&gt; FROM TABLES1;</span></span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">| A | B |</span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">| 1 | 2 |</span><br><span class="line">| 2 | 3 |</span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">2 rows in set (0.000 sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; SELECT A, B</span><br><span class="line"><span class="code">    -&gt; FROM TABLES2</span></span><br><span class="line"><span class="code">    -&gt; GROUP BY (C);</span></span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">| A | B |</span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">| 1 | 2 |</span><br><span class="line">| 2 | 3 |</span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">2 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>删除TABLES1内重复数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp <span class="keyword">SELECT</span> A, B, C, D <span class="keyword">FROM</span> TABLES1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> (C);</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> TABLES1;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tmp <span class="keyword">RENAME</span> <span class="keyword">TO</span> TABLES1;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp <span class="keyword">SELECT</span> A, B, C, D <span class="keyword">FROM</span> TABLES1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> (C);</span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.027</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> TABLES1;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.002</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tmp <span class="keyword">RENAME</span> <span class="keyword">TO</span> TABLES1;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.002</span> sec)</span><br></pre></td></tr></table></figure><p><code>SELECT * FROM TABLES1;</code></p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES1;</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---+</span><br><span class="line">| A | B | C | D |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---+</span><br><span class="line">| 1 | 2 | 3 | 4 |</span><br><span class="line">| 2 | 3 | 4 | 5 |</span><br><span class="line"><span class="code">+---+</span>---<span class="code">+---+</span>---+</span><br><span class="line">2 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>或设置主键以清理TABLEST2内重复数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">IGNORE</span> <span class="keyword">TABLE</span> TABLES2</span><br><span class="line"><span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (A, B);</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; ALTER IGNORE TABLE TABLES2</span><br><span class="line">    -&gt; ADD PRIMARY KEY (A, B);</span><br><span class="line">Query OK, <span class="number">5</span> rows affected (<span class="number">0.059</span> sec)              </span><br><span class="line">Records: <span class="number">5</span>  Duplicates: <span class="number">3</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>SELECT * FROM TABLES2;</code></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT <span class="symbol">*</span> FROM TABLES2;</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|<span class="string"> ID </span>|<span class="string"> A </span>|<span class="string"> B </span>|<span class="string"> C </span>|<span class="string"> D </span>|<span class="string"> TIME       </span>|</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|<span class="string">  1 </span>|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|<span class="string"> 2020-02-14 </span>|</span><br><span class="line">|<span class="string">  5 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|<span class="string"> 5 </span>|<span class="string"> 2020-02-13 </span>|</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">2 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-2</title>
    <url>/2020/02/14/MySQL-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MySQL-2"><a href="#MySQL-2" class="headerlink" title="MySQL-2"></a>MySQL-2</h3><p><strong>创建并选取数据库</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> TEST1;</span><br><span class="line"><span class="keyword">USE</span> TEST1;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> TEST1;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">MariaDB</span> [(<span class="literal">none</span>)]&gt; USE TEST1;</span><br><span class="line"><span class="attribute">Database</span> changed</span><br></pre></td></tr></table></figure><p><strong>创建临时表TABLEST6</strong><br><code>CREATE TEMPORARY TABLE TABLES6 (B INT, C CHAR(1) );</code></p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">CREATE</span> <span class="keyword">TEMPORARY</span> <span class="keyword">TABLE</span> TABLES6 (B <span class="type">INT</span>, C <span class="type">CHAR</span>(<span class="number">1</span>) );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><hr><p><strong>向表内插入字段</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> A <span class="built_in">INT</span> <span class="keyword">FIRST</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> D <span class="built_in">INT</span> <span class="keyword">AFTER</span> C;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> E <span class="built_in">CHAR</span> <span class="keyword">AFTER</span> D;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> G <span class="built_in">CHAR</span> <span class="keyword">AFTER</span> E;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> A <span class="type">INT</span> FIRST;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> D <span class="type">INT</span> <span class="keyword">AFTER</span> C;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> E <span class="type">CHAR</span> <span class="keyword">AFTER</span> D;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">ADD</span> G <span class="type">CHAR</span> <span class="keyword">AFTER</span> E;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>查看表结构</strong><br><code>SHOW COLUMNS FROM TABLES6;</code></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SHOW COLUMNS FROM TABLES6;</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">|<span class="string"> Field </span>|<span class="string"> Type    </span>|<span class="string"> Null </span>|<span class="string"> Key </span>|<span class="string"> Default </span>|<span class="string"> Extra </span>|</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">|<span class="string"> A     </span>|<span class="string"> int(11) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> B     </span>|<span class="string"> int(11) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> C     </span>|<span class="string"> char(1) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> D     </span>|<span class="string"> int(11) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> E     </span>|<span class="string"> char(1) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> G     </span>|<span class="string"> char(1) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">+-------+---------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>修改字符类型</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">MODIFY</span> A <span class="built_in">INT</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">MODIFY</span> B <span class="built_in">INT</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">MODIFY</span> C <span class="built_in">INT</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">MODIFY</span> D <span class="built_in">CHAR</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">MODIFY</span> E <span class="built_in">CHAR</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">MODIFY</span> G <span class="built_in">CHAR</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 MODIFY A INT(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 MODIFY B INT(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.000</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 MODIFY C INT(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 MODIFY D CHAR(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 MODIFY E CHAR(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 MODIFY G CHAR(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>查看表结构</strong><br><code>SHOW COLUMNS FROM TABLES6;</code></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SHOW COLUMNS FROM TABLES6;</span><br><span class="line">+-------+----------+------+-----+---------+-------+</span><br><span class="line">|<span class="string"> Field </span>|<span class="string"> Type     </span>|<span class="string"> Null </span>|<span class="string"> Key </span>|<span class="string"> Default </span>|<span class="string"> Extra </span>|</span><br><span class="line">+-------+----------+------+-----+---------+-------+</span><br><span class="line">|<span class="string"> A     </span>|<span class="string"> int(10)  </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> B     </span>|<span class="string"> int(10)  </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> C     </span>|<span class="string"> int(10)  </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> D     </span>|<span class="string"> char(10) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> E     </span>|<span class="string"> char(10) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> G     </span>|<span class="string"> char(10) </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">+-------+----------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>修改字段名称</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">CHANGE</span> G F <span class="built_in">BIGINT</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">CHANGE</span> F F <span class="built_in">CHAR</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 CHANGE G F BIGINT;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 CHANGE F F CHAR(<span class="number">10</span>);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p><strong>修改默认值</strong></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TABLES6</span><br><span class="line">MODIFY D BIGINT <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> DEFAULT </span>1000;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TABLES6</span><br><span class="line">MODIFY E BIGINT <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> DEFAULT </span>1000;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">ALTER TABLE TABLES6</span><br><span class="line">MODIFY F BIGINT <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> DEFAULT </span>100;</span><br></pre></td></tr></table></figure><p><code>ALTER TABLE TABLES6 ALTER F SET DEFAULT 1000;</code></p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6</span><br><span class="line">    -&gt; MODIFY D BIGINT <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> DEFAULT </span>1000;</span><br><span class="line">Query OK, 0 rows affected (0.001 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6</span><br><span class="line">    -&gt; MODIFY E BIGINT <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> DEFAULT </span>1000;</span><br><span class="line">Query OK, 0 rows affected (0.001 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6</span><br><span class="line">    -&gt; MODIFY F BIGINT <span class="keyword">NOT</span> <span class="literal">NULL</span><span class="built_in"> DEFAULT </span>100;</span><br><span class="line">Query OK, 0 rows affected (0.001 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 ALTER F <span class="builtin-name">SET</span><span class="built_in"> DEFAULT </span>1000;</span><br><span class="line">Query OK, 0 rows affected (0.001 sec)              </span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure><p><strong>查看表结构</strong><br><code>SHOW COLUMNS FROM TABLES6;</code></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SHOW COLUMNS FROM TABLES6;</span><br><span class="line">+-------+------------+------+-----+---------+-------+</span><br><span class="line">|<span class="string"> Field </span>|<span class="string"> Type       </span>|<span class="string"> Null </span>|<span class="string"> Key </span>|<span class="string"> Default </span>|<span class="string"> Extra </span>|</span><br><span class="line">+-------+------------+------+-----+---------+-------+</span><br><span class="line">|<span class="string"> A     </span>|<span class="string"> int(10)    </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> B     </span>|<span class="string"> int(10)    </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> C     </span>|<span class="string"> int(10)    </span>|<span class="string"> YES  </span>|<span class="string">     </span>|<span class="string"> NULL    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> D     </span>|<span class="string"> bigint(20) </span>|<span class="string"> NO   </span>|<span class="string">     </span>|<span class="string"> 1000    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> E     </span>|<span class="string"> bigint(20) </span>|<span class="string"> NO   </span>|<span class="string">     </span>|<span class="string"> 1000    </span>|<span class="string">       </span>|</span><br><span class="line">|<span class="string"> F     </span>|<span class="string"> bigint(20) </span>|<span class="string"> NO   </span>|<span class="string">     </span>|<span class="string"> 1000    </span>|<span class="string">       </span>|</span><br><span class="line">+-------+------------+------+-----+---------+-------+</span><br><span class="line">6 rows in set (0.002 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>修改表TABLES6的存储引擎</strong><br><code>ALTER TABLE TABLES6 ENGINE = MYISAM;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES6 ENGINE = MYISAM;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p><strong>查看存储结构</strong><br><code>SHOW TABLE STATUS LIKE &#39;TABLES6&#39;;</code></p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">'TABLES6'</span>;</span><br><span class="line">Empty <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><hr><p><strong>修改TABLES6为TABLES4</strong><br><code>ALTER TABLE TABLES6 RENAME TO TABLES4;</code></p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES6 <span class="keyword">RENAME</span> <span class="keyword">TO</span> TABLES4;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><hr><p><strong>创建索引并删除多余索引</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES4 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> (B);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES4 <span class="keyword">ADD</span> <span class="keyword">INDEX</span> (A);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES4 <span class="keyword">DROP</span> <span class="keyword">INDEX</span> B;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES4 ADD INDEX (B);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES4 ADD INDEX (A);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.002</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES4 DROP INDEX B;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.002</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p><strong>设A为主键(作为主键索引,A值不能为空)</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES4 <span class="keyword">MODIFY</span> A <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES4 <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (B);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES4 <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLES4 <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (A);</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES4 ADD PRIMARY KEY (B);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES4 DROP PRIMARY KEY;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; ALTER TABLE TABLES4 ADD PRIMARY KEY (A);</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.001</span> sec)              </span><br><span class="line">Records: <span class="number">0</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br></pre></td></tr></table></figure><hr><p><strong>列出索引</strong><br><code>SHOW INDEX FROM TABLES4;</code></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SHOW INDEX FROM TABLES4;</span><br><span class="line">+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">|<span class="string"> Table   </span>|<span class="string"> Non_unique </span>|<span class="string"> Key_name </span>|<span class="string"> Seq_in_index </span>|<span class="string"> Column_name </span>|<span class="string"> Collation </span>|<span class="string"> Cardinality </span>|<span class="string"> Sub_part </span>|<span class="string"> Packed </span>|<span class="string"> Null </span>|<span class="string"> Index_type </span>|<span class="string"> Comment </span>|<span class="string"> Index_comment </span>|</span><br><span class="line">+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">|<span class="string"> TABLES4 </span>|<span class="string">          0 </span>|<span class="string"> PRIMARY  </span>|<span class="string">            1 </span>|<span class="string"> A           </span>|<span class="string"> A         </span>|<span class="string">           0 </span>|<span class="string">     NULL </span>|<span class="string"> NULL   </span>|<span class="string">      </span>|<span class="string"> BTREE      </span>|<span class="string">         </span>|<span class="string">               </span>|</span><br><span class="line">|<span class="string"> TABLES4 </span>|<span class="string">          1 </span>|<span class="string"> A        </span>|<span class="string">            1 </span>|<span class="string"> A           </span>|<span class="string"> A         </span>|<span class="string">        NULL </span>|<span class="string">     NULL </span>|<span class="string"> NULL   </span>|<span class="string">      </span>|<span class="string"> BTREE      </span>|<span class="string">         </span>|<span class="string">               </span>|</span><br><span class="line">+---------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+</span><br><span class="line">2 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>删除TABLES4</strong><br><code>DROP TABLE TABLES4;</code></p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">DROP</span> <span class="keyword">TABLE</span> TABLES4;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-1</title>
    <url>/2020/02/14/MySQL-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="MySQL-1"><a href="#MySQL-1" class="headerlink" title="MySQL-1"></a>MySQL-1</h3><p><strong>应用-1</strong></p><p><strong>所使用数据模型:</strong></p><blockquote><p>六行六列<br>TABLES1:</p></blockquote><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[ID-A-B-C-D-time]</span><br><span class="line">[<span class="number">1</span><span class="number">-1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span>-now]</span><br><span class="line">[<span class="number">2</span><span class="number">-1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span>-now]</span><br><span class="line">[<span class="number">3</span><span class="number">-1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span>-now]</span><br><span class="line">[<span class="number">4</span><span class="number">-1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span>-now]</span><br><span class="line">[<span class="number">5</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span><span class="number">-2020</span><span class="number">-02</span><span class="number">-13</span>]</span><br></pre></td></tr></table></figure><blockquote><p>TABLES2:</p></blockquote><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[ID-A-B-C-D-time]</span><br><span class="line">[<span class="number">1</span><span class="number">-1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span>-now]</span><br><span class="line">[<span class="number">2</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span>-now]</span><br><span class="line">[<span class="number">3</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span>-now]</span><br><span class="line">[<span class="number">4</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span>-now]</span><br><span class="line">[<span class="number">5</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span><span class="number">-2020</span><span class="number">-02</span><span class="number">-13</span>]</span><br></pre></td></tr></table></figure><blockquote><p>TABLES3:</p></blockquote><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">[ID-A-B-C-D-time]</span><br><span class="line">[<span class="number">1</span><span class="number">-1</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span>-now]</span><br><span class="line">[<span class="number">2</span><span class="number">-2</span><span class="number">-3</span><span class="number">-4</span><span class="number">-5</span>-now]</span><br><span class="line">[<span class="number">3</span><span class="number">-6</span><span class="number">-7</span><span class="number">-8</span><span class="number">-9</span>-now]</span><br><span class="line">[<span class="number">4</span><span class="number">-6</span><span class="number">-7</span><span class="number">-8</span><span class="number">-9</span>-now]</span><br><span class="line">[<span class="number">5</span><span class="number">-6</span><span class="number">-7</span><span class="number">-8</span><span class="number">-9</span><span class="number">-2020</span><span class="number">-02</span><span class="number">-13</span>]</span><br></pre></td></tr></table></figure><hr><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASELS;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> TEST1;</span><br><span class="line"><span class="keyword">USE</span> TEST1;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> TEST1;</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [(<span class="keyword">none</span>)]&gt; USE TEST1;</span><br><span class="line"><span class="keyword">Database</span> changed</span><br></pre></td></tr></table></figure><p><strong>分别创建TABLES1,TABLES2,TABLES3</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES1(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">A <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">D <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> ( <span class="keyword">ID</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES2(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">A <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">D <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> ( <span class="keyword">ID</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLES3(</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">A <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">B <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">C <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">D <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">TIME</span> <span class="built_in">DATE</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> ( <span class="keyword">ID</span> )</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; CREATE TABLE TABLES1(</span><br><span class="line">    -&gt; ID INT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    -&gt; A VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; B VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; C VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; D VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; TIME DATE,</span><br><span class="line">    -&gt; PRIMARY KEY ( ID )</span><br><span class="line">    -&gt; )<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.046 sec)</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; CREATE TABLE TABLES2(</span><br><span class="line">    -&gt; ID INT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    -&gt; A VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; B VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; C VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; D VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; TIME DATE,</span><br><span class="line">    -&gt; PRIMARY KEY ( ID )</span><br><span class="line">    -&gt; )<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.043 sec)</span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; CREATE TABLE TABLES3(</span><br><span class="line">    -&gt; ID INT <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    -&gt; A VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; B VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; C VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; D VARCHAR(100) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; TIME DATE,</span><br><span class="line">    -&gt; PRIMARY KEY ( ID )</span><br><span class="line">    -&gt; )<span class="attribute">ENGINE</span>=InnoDB<span class="built_in"> DEFAULT </span><span class="attribute">CHARSET</span>=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.005 sec)</span><br></pre></td></tr></table></figure><p><code>SHOW TABLES;</code></p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SHOW TABLES;</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">| Tables<span class="emphasis">_in_</span>TEST1 |</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">| TABLES1         |</span><br><span class="line">| TABLES2         |</span><br><span class="line">| TABLES3         |</span><br><span class="line"><span class="code">+-----------------+</span></span><br><span class="line">3 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>分别向TABLES1,TABLES2,TABLES3内填充数据</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> A;</span><br></pre></td></tr></table></figure><ul><li>4<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure></li><li>1<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">'2020-02-13'</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES1 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; INSERT INTO TABLES1</span><br><span class="line"><span class="function">    -&gt;</span> (A,B,C,D,TIME)</span><br><span class="line"><span class="function">    -&gt;</span> VALUES</span><br><span class="line"><span class="function">    -&gt;</span> (<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">'2020-02-13'</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> A;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> TABLES1;</span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; RELEASE SAVEPOINT A;</span><br><span class="line">Query OK, <span class="number">0</span> rows affected (<span class="number">0.000</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES1;</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">| ID | A | B | C | D | TIME       |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">2</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">3</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">4</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">5</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-13</span> |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> A;</span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">WORK</span>;</span><br></pre></td></tr></table></figure><hr><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STRAT TRANSACTION/<span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> A;</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">* <span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2</span><br><span class="line">(A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">("1","2","3","4",NOW());</span><br></pre></td></tr></table></figure><ul><li>3<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure></li><li>1<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">'2020-02-13'</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.002</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("2","3","4","5",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("2","3","4","5",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br><span class="line"></span><br><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES2 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("2","3","4","5",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; INSERT INTO TABLES2</span><br><span class="line"><span class="function">    -&gt;</span> (A,B,C,D,TIME)</span><br><span class="line"><span class="function">    -&gt;</span> VALUES</span><br><span class="line"><span class="function">    -&gt;</span> (<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="string">'2020-02-13'</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><p><code>SELECT * FROM TABLES2;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES2;</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">| ID | A | B | C | D | TIME       |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">2</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">3</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">4</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">5</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-13</span> |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> A;</span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">WORK</span>;</span><br></pre></td></tr></table></figure><hr><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">STRAT TRANSACTION/<span class="keyword">BEGIN</span>; </span><br><span class="line"><span class="keyword">SET</span> AUTOCOMMIT=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">SAVEPOINT</span> A;</span><br></pre></td></tr></table></figure><ul><li>1<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure></li><li>1<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure></li><li>2<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure></li><li>1<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3</span><br><span class="line">(A,B,C,D,<span class="built_in">TIME</span>)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">'2020-02-13'</span>);</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("1","2","3","4",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("2","3","4","5",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3</span><br><span class="line">    -&gt; (A,B,C,D,<span class="type">TIME</span>)</span><br><span class="line">    -&gt; <span class="keyword">VALUES</span></span><br><span class="line">    -&gt; ("6","7","8","9",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">INSERT</span> <span class="keyword">INTO</span> TABLES3 (A,B,C,D,<span class="type">TIME</span>) <span class="keyword">VALUES</span> ("6","7","8","9",NOW());</span><br><span class="line">Query OK, <span class="number">1</span> <span class="keyword">row</span> affected, <span class="number">1</span> <span class="built_in">warning</span> (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; INSERT INTO TABLES3</span><br><span class="line"><span class="function">    -&gt;</span> (A,B,C,D,TIME)</span><br><span class="line"><span class="function">    -&gt;</span> VALUES</span><br><span class="line"><span class="function">    -&gt;</span> (<span class="string">"6"</span>,<span class="string">"7"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">'2020-02-13'</span>);</span><br><span class="line">Query OK, <span class="number">1</span> row affected (<span class="number">0.001</span> sec)</span><br></pre></td></tr></table></figure><p><code>SELECT * FROM TABLES3;</code></p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES3;</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">| ID | A | B | C | D | TIME       |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line">|  <span class="number">1</span> | <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">2</span> | <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">3</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">4</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-14</span> |</span><br><span class="line">|  <span class="number">5</span> | <span class="number">6</span> | <span class="number">7</span> | <span class="number">8</span> | <span class="number">9</span> | <span class="number">2020</span><span class="number">-02</span><span class="number">-13</span> |</span><br><span class="line">+----+---+---+---+---+------------+</span><br><span class="line"><span class="number">5</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> A;</span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">WORK</span>;</span><br></pre></td></tr></table></figure><hr><p><strong>从三个表中选择所有列A匹配1的数据，返回所有列A中映射于列1的数据，并让列A靠左</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A,B <span class="keyword">FROM</span> TABLES1</span><br><span class="line"><span class="keyword">WHERE</span> A=<span class="string">'1'</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> A,B <span class="keyword">FROM</span> TABLES2</span><br><span class="line"><span class="keyword">WHERE</span> A=<span class="string">'1'</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> A,B <span class="keyword">FROM</span> TABLES3</span><br><span class="line"><span class="keyword">WHERE</span> A=<span class="string">'1'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> A;</span><br></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT A,B FROM TABLES1</span><br><span class="line"><span class="code">    -&gt; WHERE A='1'</span></span><br><span class="line"><span class="code">    -&gt; UNION ALL</span></span><br><span class="line"><span class="code">    -&gt; SELECT A,B FROM TABLES2</span></span><br><span class="line"><span class="code">    -&gt; WHERE A='1'</span></span><br><span class="line"><span class="code">    -&gt; UNION ALL</span></span><br><span class="line"><span class="code">    -&gt; SELECT A,B FROM TABLES3</span></span><br><span class="line"><span class="code">    -&gt; WHERE A='1'</span></span><br><span class="line"><span class="code">    -&gt; ORDER BY A;</span></span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">| A | B |</span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">| 1 | 2 |</span><br><span class="line">| 1 | 2 |</span><br><span class="line"><span class="code">+---+</span>---+</span><br><span class="line">2 rows in set (0.001 sec)</span><br></pre></td></tr></table></figure><p><strong>查询并输出表TABLES1内列A中匹配数值2和列B中匹配数值3与列TIME中匹配以3结尾的数据</strong></p><blockquote><p><code>SELECT * FROM TABLES1 WHERE A=2 AND B=3 AND TIME LIKE &#39;%3&#39;;</code></p></blockquote><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT * FROM TABLES2 WHERE A=2 AND B=3 AND TIME LIKE <span class="emphasis">'%3'</span>;</span><br><span class="line"><span class="code">+----+</span>---<span class="code">+---+</span>---<span class="code">+---+</span>------------+</span><br><span class="line">| ID | A | B | C | D | TIME       |</span><br><span class="line"><span class="code">+----+</span>---<span class="code">+---+</span>---<span class="code">+---+</span>------------+</span><br><span class="line">|  5 | 2 | 3 | 4 | 5 | 2020-02-13 |</span><br><span class="line"><span class="code">+----+</span>---<span class="code">+---+</span>---<span class="code">+---+</span>------------+</span><br><span class="line">1 row in set (0.000 sec)</span><br></pre></td></tr></table></figure><hr><p><strong>将表A内数据利用COUNT()函数按数值类型进行数据分组并求其平均值,并按降序排列(默认升序)</strong></p><blockquote><p><code>SELECT A, COUNT(*) FROM TABLES2 GROUP BY A DESC;</code></p></blockquote><figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; <span class="keyword">SELECT</span> A, COUNT<span class="comment">(*) FROM TABLES2 GROUP BY A DESC;</span></span><br><span class="line"><span class="comment">+---+----------+</span></span><br><span class="line"><span class="comment">| A | COUNT(*)</span> |</span><br><span class="line">+---+----------+</span><br><span class="line">| <span class="number">2</span> |        <span class="number">4</span> |</span><br><span class="line">| <span class="number">1</span> |        <span class="number">1</span> |</span><br><span class="line">+---+----------+</span><br><span class="line"><span class="number">2</span> rows <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.000</span> sec)</span><br></pre></td></tr></table></figure><hr><p><strong>TABLES1&amp;TABLES2-left&amp;right</strong><br><strong>将TABLES1的A,B列与TABLES2的B,C列进行以下三种连接:</strong><br><strong>将标识为a的A,B列于标识为b的C列进行等值连接</strong></p><figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT </span>a.A, a.<span class="keyword">B, </span><span class="keyword">b.C </span>FROM TABLES1 a INNER JOIN TABLES2 <span class="keyword">b </span>ON a.<span class="keyword">B </span>= <span class="keyword">b.B; </span></span><br><span class="line"><span class="keyword">SELECT </span>a.A, a.<span class="keyword">B, </span><span class="keyword">b.C </span>FROM TABLES1 a, TABLES2 <span class="keyword">b </span>WHERE a.<span class="keyword">B </span>= <span class="keyword">b.B;</span></span><br></pre></td></tr></table></figure><ul><li>左连接:<blockquote><p><code>SELECT a.A, a.B, b.C FROM TABLES1 a LEFT JOIN TABLES2 b ON a.B = b.B;</code></p></blockquote></li><li>右连接:<blockquote><p><code>SELECT a.A, a.B, b.C FROM TABLES1 a RIGHT JOIN TABLES2 b ON a.B = b.B;</code></p></blockquote></li></ul><p><strong>如下所示:</strong></p><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT a.A, a.B, b.C FROM TABLES1 a INNER JOIN TABLES2 b ON a.B = b.B; </span><br><span class="line">+---+---+---+</span><br><span class="line">|<span class="string"> A </span>|<span class="string"> B </span>|<span class="string"> C </span>|</span><br><span class="line">+---+---+---+</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4 </span>|</span><br><span class="line">+---+---+---+</span><br><span class="line">8 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT a.A, a.B, b.C FROM TABLES1 a LEFT JOIN TABLES2 b ON a.B = b.B; </span><br><span class="line">+---+---+------+</span><br><span class="line">|<span class="string"> A </span>|<span class="string"> B </span>|<span class="string"> C    </span>|</span><br><span class="line">+---+---+------+</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3    </span>|</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3    </span>|</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3    </span>|</span><br><span class="line">|<span class="string"> 1 </span>|<span class="string"> 2 </span>|<span class="string"> 3    </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4    </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4    </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4    </span>|</span><br><span class="line">|<span class="string"> 2 </span>|<span class="string"> 3 </span>|<span class="string"> 4    </span>|</span><br><span class="line">+---+---+------+</span><br><span class="line">8 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="code"><pre><span class="line">MariaDB [TEST1]&gt; SELECT a.A, a.B, b.C FROM TABLES1 a RIGHT JOIN TABLES2 b ON a.B = b.B;</span><br><span class="line">+------+------+---+</span><br><span class="line">|<span class="string"> A    </span>|<span class="string"> B    </span>|<span class="string"> C </span>|</span><br><span class="line">+------+------+---+</span><br><span class="line">|<span class="string"> 1    </span>|<span class="string"> 2    </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 1    </span>|<span class="string"> 2    </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 1    </span>|<span class="string"> 2    </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 1    </span>|<span class="string"> 2    </span>|<span class="string"> 3 </span>|</span><br><span class="line">|<span class="string"> 2    </span>|<span class="string"> 3    </span>|<span class="string"> 4 </span>|</span><br><span class="line">|<span class="string"> 2    </span>|<span class="string"> 3    </span>|<span class="string"> 4 </span>|</span><br><span class="line">|<span class="string"> 2    </span>|<span class="string"> 3    </span>|<span class="string"> 4 </span>|</span><br><span class="line">|<span class="string"> 2    </span>|<span class="string"> 3    </span>|<span class="string"> 4 </span>|</span><br><span class="line">+------+------+---+</span><br><span class="line">8 rows in set (0.000 sec)</span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>RDBMS</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔-2020-2-2-13</title>
    <url>/2020/02/13/%E9%9A%8F%E7%AC%94-2020-2-2-13/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="26d8ae0138db8891b9f52b71f27e15239abab1facaba803415d3f1cea0403135">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98abe6b72a9074af2212930d4a0af2d5d6fc8eea2858f0bd19993abcfc73fc812615781abdc89d6cd9b1749cd6fc88fadeb05f8005f4bd3384e07276fa01c4b4aa2e12073e946973495b99a3a4ab2ad8c322d067a9c66ff0c646cab223e102595eccc0f09759847052ffba3b5ca1a472086745dea3981f7b969eacdf735246d88824648604923022d4c57e06cc31be006c3d287d892a85a84c4bc6997171d8c760aaca734d6d8514ab908f35e9cdb03ddbd6882882a26503112362e5c30fdf62e45fda3a533205765e42eb43ed0c1c05b085a917f8d2ec1670d726e18e176eb38057671f6bc08f478417ad106aeb57f79c5c3c2e1ba7115ceba73d696fc66d21bd49ce2ae47b6f497df03c102f3c7a1c43c156486593eeadff7000f3ac6bb1a1a77ae5f37e98d6df36b251bae42df12af8ad650c6f16a50f963e3594c6a1bb6dd443c540cbce4958e2480d98b1145c67e45df5f51107cfece243b19f69fc10aec56e4236e0c9303ff87a2371d1993f33a30f52be2b439de8d55f1a0e401f872a9f6292d21af8bd8caae2e9ecdf41475bd5ad11b2465a0d43d87ac91218b37f1cb206511998a8daaacacd8225d00315e2509c27a11008d864bdb85a61e5a646e530c67cb086ab9c77d30f34ddea0cc787cb1e50376fd3b407f1c0ee42a0f169294674f439244a668a56dba001dbc8e0ba5f684b5f45bb6db55f1c0b8bbf728719dbe894be0bdfcedde508a5c2c495ec531daa49fdc9a83db3f354e3525a8b774022b22150e5dde4cde73bd8793fccf9680b45517ca3562abd07131b7923769b609c7d58d3699c223a61f579d044d61c4783b5ff4ad2883d0398a6b4821efeb90314c4cb23e3edc92ea3dbc58334ddd1c8c0b0fa72f299df9f9bd30f6ccb6f8741c7cd5004bfda41170ee0d602a35fbff2bc765f7b65302867ab02e23f6de687a9ee6430847bd1a4a36642e36f970e8b7a04323d5b2e9de70ee502ce100ad565cd163c3f5a4c2dea339dfe3c4cd5ea07f0828e54f2c664bf2daf9760716cdc16d4614c0c6e02e57e3a1e9831a7b9617b26afed894b4334602b58fb7e100d8823b482bdc2dfe45097bbf1f10b96e6149671f942a9aa8d87b28f8f83d0d10d013405839e1c19ce216080171fd0b038f8f466f63c357c84ef55938100f4fc5c6f1f1578d72997a03fe74de4ed2d5c38ae7ff4d23f4c268a157cc17f88ed0d6df6ccd12a897542881baac9e698e028f798396b13cd261dec1e1d314b16fa5c727dbeafd7c43bb1ba9de0f88c31d29e9a69cb8f9a4b5a99d38d8d10ab1cb0157f8506aacdb0cc18e1d2d85f9169d37fb2c87fadba9d2639404e1e05a50859699a52be28636af9571dc4ee06977aa2e30ef5c38cd95d4276e5ba9dd26046db9324c9a0b8f3e51a7e6f7beaa77aaea8e14b7178bcc63db6dac26c81707ec4ce9f688c73209f23e68d2b496e85188ad1827c4c0917c49bb82f50bc4b2b7e6136c81dd424c4dd19ce6e1d02a95bb40fa1cf1999bfb8e2426ac915795353153e5454e82e3c0a6285005251071a4b9c43a8aac915c0fac134605f2d18daa2858cb8a3cd466f6b1e677795b4f7a50b4676451109d7bd1e7b8c927b10a64a48a21affc65df51e6e19e068f4b67b148cedcd06d9e6894c819c4d74bb5f258037dabf3702f23d6f353ab4d0359da271c999b7f3fd31ee7539faec5c6eaca120a6c66a2f6b472e4b1d985e2ec117fd811411218c1756dd267aaedccbed141bf53dd1fbf9b371d8e7cad1dd3ca8100e5bd62c78e8d23d68cf378537bfeecbba9194665e1ec6b30f1dc35e7ce4022b01be8639b5b79155ba130f57104d823597440714368d2dd9d3fdadf92f0755f2597338322efe5d8b37969d1e4ce7ae36a846e806a8c7526e171aef00bdf6861e02d11130b8dafc92049491528552287b80ccbecfaee6128446696d675f2bc1a102e5584fe53df80be61ec43ccc45ab2f0776bb06b21cd4a2ca656b05efdbcf8b60465e3e65d9a7a934ec2f30a5439e20d5650e5a2517f33ef82bc0da8a9c81f068ebc346b1b9b171a4cf62525186884e3eef04f3ba3ed8bd66cc8c9326b7a214626e71f68547b15fc67c9bbc7f34cb5dbf864cc9753f24f37d1b591050e96e3f3f8f6cd3e15a80ee12858529d56fc7dc0d4e780f666e42d5f81846571602dd530d2ddf8d19f39870c439ade59dc08e089907d7d2358f4a96dc1c514ac00bb29f19000fbed95e74bb4b8956a4afa2798bf5917ffe8543b12e211620dbbc5426dc325fc94a97fafaa572dfc0fc60c490e635c51af67e83c1454d4f4f1ae7782195b6f00561664b4f39c353924de637fdaea877516b8c10033144d80e4e3b3beb130178c092baa502e727679a1944283ad0fa0132559bf19eba4454dc5c6fb01bad6eaa9cd8307bfba4dce492c318a381e29fa650d17f7f0805767488440631a27a366ac013be294787a15cdb3f3abb903fbe81e3e443d2bdad00f5b48356b458407d599bdbcf7584dc8d221d1dfc7596c089ad1f16e09fc9943277f826511e69b27acebe633939aa7a6938e8d7b1c885d67a069775088b647c097ae6ad848e4098069670681ff68e8d845b380028fb53d1f9230333454dc9d5393e8a980bb6a0bb1fc797e4d13c6b583704f0492284a5f20c9de549282ead42490bc740b55d477ea1bcdafa4c415bc0656b024a3b35383202556d19b2d398b821484439d4bbbbdfa21474383f1589b8a02fce9ee3da347a12ecbfe04a42e8e3659f906c57ca3b30d2fd3f29841c93ba6dedebcbf8cf9c1dead0dd6429646901266ce79e33140bc9925d2bec234133a3921ddda0ae19cb9cad7c7da1770b48221567876a8399511eb7c6ca675bb16a45f560f26c62678ef4c009ccc32d677801283273ecfa807f170c08b5106944b0368534756c8b9d4081a0e65f1176cfdc61afed2423c6fc918d440010f5b96f4cd19ff2fd13b3c38463c34d1a798cb878a1c1eb2d22ee0fccafcbcbb9dd73f1a117c82c023ff0d0ef761e4b0566f6c8001f744535dfe03c839200dd8836c2e0d7a8e810d78293a475b8ccb48a60647eb6ad4c4b690b7c2a1d62193033a285107352968300f10fbd609c2be0b84c8824daa69e8e252aa2dd32ba25cd18e17132b556836fa3eff0686effd81dc7ebb392e8b7da783a46d0cd36610aaf9b52c0538bc540913dca8b9c2ab4be9b63f7ed7909bf11403d65a3b766cbd0b62282519a4f0e44fd6d8291c93e2efea8590a23d81de89a4f1c7741d4cbe00ffea06d404b5fb8eb311a4bd0403245f789a52526f006ffbd0f8bb18851ca1ae0ef706fb9bdd3d9267d62fa26f622e070e2515405a27553b742430eaad0dda98519c69ab59b1d389cefd218a0d73b6d97560849dbab9890043118b6c487075bef1265e853dbacedf72b74dec245ed14bfa57c866a70b98561ef84aabd2d6f31bc2d1fad870c5b01bd5c12d2d7a8253ffd0a55acb4185b30569ecf37c681d3dda6f04f827d4e93d5152002a18ab389beef3e519bf3f602d41be95fbfd6f1ccdeedb308eb2605fef1cd12c6a90a9acedc915ec301704866ff10cf85da08742208ddc7f5dd36acf7193fd6c534928e221199e20eede89859c67e5821e6bd133114520de299903f55e6445d09b858619c37de70f0f7536e7c4447609cd220db63c612523ff266635525a2192cbde729f6013fe2681c125d4e87f517fdb1159e4ea38f2e891ff99c73e29b02cb49d43035d1cde852f63c14dfcbd3e8890d4cfa36583cd9905f0249139650832bc5ff9b48701ff38f948cedf07a8aca5e0374829a179541643502717b3ed19f80ce47b59504f33ac8f2420cbd06824d26f3ef78487d96beb0770118083ad7ad68eff7d4a1d81f4408df1b6d00a8d62fed5d5477defc167acabab5d2be75fd0b36a8472b8f3cd013f6649941a37eed7dbd5b464041acb97448eea70be72990c1e337283cf5f9dcda1f243319c26f250769d2f5ccd74428fbd044b5a730513c3f598df3d3ffbb2b619aa06362bf9aeb79218e9fc89db25fbf38fa5ca25aa27f69920f234eace3ac289cff7d9a6c80840202a629b4172ff00e0806c4968b96ac9fcc2eda66ab9c4e35ebffe0632f795cd8de79d7b2b67767dbe71e55dcdc9babd4fa151fe6b6d935d515bb677662de328e90c2616a7e573f28a2d47c23827794ec9b981a420bf194ef6daede920b18a6c302ef20a24b9187fa990427ebb0549acda14c24d6da7ab7e23509e7e28bf2ac5f1d9ac3583ee72c02a114b4bc0a5a85f0a7ea19fbb1959613d87e9eeacf417c5139915217e7e24044732a52e0e9f18c104101ca557cb0e37a1a39b7954ac9b86a1f720b092a5645f0f82aa41080b9ff4d5caee61e7b4f66f5f010a76b8de4f61471513280ea7cd05423799a635cafbeab31ddf6aa7c231f439a09c2fbc6b8aecae0badd98599cb08caf303b43a7638f4bac2335ead7cd2b2011ac86a1c9250f162d6d887c43eb6100585a2fc2f6a7eb4054e9f7eff70c39a60dd7a63da889dbfe44b20c3a357d48a3d859b36f68f1003110c5f7e5cf148d3539fbf909a981629382ea9837c5d65d964ca2c1ed5d6165fed110636823a2b86a6df9186937ed45ce4f212276781953c060e6a00c8efb889fb46b135b6008cb607ae5f06b59337293191a13f6d64cb44ada9380cb2817c1fea67b693918a0811f877d24525dfe3a468608cc77261e965e6679149106237e0bca8dd6b07f84f7352c8b062fc79fc97b5c970f52f55934d2286f01361dfb64223a24d6b268173b5cae94ea58ddae06e6827b37eecbdda8f81fdecde834f231c953ffcefb33172539a042d16c1c60af1bcef61780d36313c867543a3801096d8c50a7a96beb30866348a7315ddb4e0f7feaeb081234399a0f665c0f57da6111f5238d677c28a1e8981cd95df7fb5f3a7617d591b2173fa01b0e08f0e2ff0de131baca5abc9c9357f8560fdde888a8268e074a90e42eb37297b2b6399b3a94afc38ebfceb3f016f8ae6d19eb0cea9a27f90a9bebb62efff0c50cf729aa64ed5a3853b6497e279e3df5c56aa68bb05bf88f5e1d3f7724ac12a707cff0ae2b91492efa5d869e61d3ad5c543257dbf43f26cf618164459649533a4e35ce9053d7489951000dcd479d96d7ed84abe350076fd2a15bd7888077043efd3ee2ccd228403eb917141093b35f4bfd68bc626f521eca54d1d5e561a2bc8ee6f6cfef0f6f7d8d5374bce55b5fda43c24e1451c776f58320e292385a94231c0ef8fd308f90aa51a04f3df3e69439ab38364f8eab52d44b5a6e19cf71e1c788f37f9aa132c3362b2305bb4c99cc54ad5b7b4a9322fcfa549d39c605abd29dd3a8d597fe6d29694a9bae59fd282c0f73b484e6a532e7d0f04a47f4ad217f115d7bb5b5bd0eaf5025dc28c74f4346a0880cde730bb5289cfd2b679619f9604956dc96cf20c1eb3cce1c07cee309f560a371f98240768350af84d8ccec417d219e635962bcdb347b3b709d24d63f7ea577dc14c38de0e6f94aef63d12af2655d6e56de669a959c2d060e3ef0101f2fb0f5cb9f04f210dc4236e1e131965c5af9b99983d8d4e4a9b443f6d2df6e67d0e0f0bc517797715bb88be8d04296df2439b082037c4adb8287b4b89acc8a668de1f45490b2f3cb4faf4d2fb8bc11cd4b849437a8476cf50ec20b52734bde5c1332b985510ee0701dfdddbcda75d6e118de5c1380efe8a913b0f88e3a865aa25c3a69061f3f6b9310b2046acc8943add602d11f9eed3d23bf419d756dc2f01752e33045682b9cc6ca582d5ef0a98ecbcd6e90d9f44992d1f293e889f15674352f6f5188058f385b9295fadad5d5bf3d59aa75e8faf8990efe37115c091dcda8d69125974561a73d5916336cf6446fd60db4d0e7ff50324e16b37e338acdfe6488a6facce4d72bcfc006d183db69a4955f04c9028f1069aad6a03e3e25414831094aa0aa3945dc4b9fa724b821170a731407d6906568348bb860b917827729bf6d92d9d9e7103bfd6dacb46b8e5860af3f9d1ab2cd8c46b0c21d67af87ed93f6806189af714a39173c7e110b67ea5ada76c22a368c700e89d4520e0245c988c5b9ae0f73dbd19266b4d976c78aa1d077e5087e7024dada96687f6800205d454b36b771119bc73111b399926a54aaf785784bd0c605d7afa1a9b4f706ce43ecd2330da6089b7279d9e9566cf350fd321c99e894db757b116d6bf327a9d3ed29f3b102bccce8a74d0ab10f740aab7e4462dfae1de8221da375e37c6ffa5de6f4c80ace7d181efbb691b3b47ff31e5fad93c7136e326bd71544e37bbc992a4d80d6a30c8812ea8028fd6a214c4e60203afe9a5c3e2df13956e4df11ea1019eac24f143e7d06f3638c5f0aaa9d5b9832335b8916590191fcb6dfee3eb06b545f7b88dfa7c6486b0f6b316b53e34708e4bd6df70473539a7d8eb92d65a7b3f78c8fd5332104b1d13a9056224a823afe6cf555bbe4870fa3c6984b1c96e8c6b242875645f90ea28bd7df130df55a1ad0f01f4bed7997b968b46e59760539f2ad2e90f8348bf5a6c4d15ccacd97315ddd2539dfb5aeeb1b43f3489da3454e1344a461741a7b14affd78ba598e6442e5ce4bf42983b6f38d4cbcff6d271509ba035639b7e7744cc1fe562907662317cf0a93cd07dfec74fef942eeee2678695e8cd9dd6d11a304c740bf6d15255e66333e5607874a3f1ee6c1f7eda54d3ff8b6e51a09237ca24ff881d0f1c7202ef790e964a98f77c342d82d2e6d07a1616b788b30dba6a323a71510072936d6ed99c36c5c7ec3064035f9744134ffb806346899057ea2e168af3b14d7ffd1635f752c295623a29b525c5217bd5549ad175688cedaaee7be8521df97a56d6b066bdb8176edff5b5aa9b2838b8d2836152f4dc4b6434ee694e1b97c4821268e9c8943451e54269ff0e5e419ec04ec2e7614d7f26f04573aa6ee3854f98e53cedbabddf12f5067b1c6781e706f103231cbb838c3c9a3b9d8c38923ce5418d23419e0bff864bc32773ecefe0e277f0b5b8152fc58eecdef1ecf55676017d6e37b342845960b2cf1572da1dd2a7249c5f5b2e51d4f864930cd0228f4a3dd456345957d474169c941d2a77daab69248f53b1d4dd4b9f574f17ca48e1842732d5861dcd9c0613a5175a042d2621d61911a09335d73fec7baadcb83ba7a3f98fb2e5d227df263bcd58464a5d839b29af432d57756b8a6c31d50f2d2589bc1129abecbec0fed8d17a722bf84d8e0a6ec5572d4b6224813b2ab56a72bbeeaf0dd431aa791c4dd33e4794093846091482daf6067e0e6eb7109d26014eca1f04caa44de574b485e2226b9aa70e46d04581494650693700bac6508bf9d06f18e77fd5668c8c21592da9c64d05ae89338bf34d43ad827a99c8216b44df4dd14001d6a9f3afd47c59142652255dfe695258fb947d1a9f1456d331b8fdda279ac90998c72d6907832391e378b98a702b131f099e9595c38f011c7ddcc42546a2d5b13565e8220a158e444bee063c6abfe1dc585372b25161c2ccf9c52c40a81685ecdea1b263839af01f3ba31ac14212a55663d87ca4a9a261e8dacfd08893a37225a4cc1171e1371419b5c4a79950b578a50b6fce1a6776f7a72b72b26074b12faf91ccd9e9ac4bfb0bdc65be248394dfad7603dbfe26295847dbf6074b88401b5a3134f4bcae7801fd1c0276e78fd6a15fa5ece6c6b20ffafbdee306796c27613335e2ae293c0db880a348b1645f91bfc365b7625a0ee9d57d1412477a4a7c4ca5bf4c849e7189098caba3a0b583da230af9d764f863852b7c84ce3a784ae3ad45d5542ae5b1f8239d554b</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>web crawler-1</title>
    <url>/2020/02/13/web-crawler-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="网络爬虫的基本原理"><a href="#网络爬虫的基本原理" class="headerlink" title="网络爬虫的基本原理"></a>网络爬虫的基本原理</h3><p><strong>简述:</strong></p><ul><li>英文:web crawler/spider</li><li>用来自动浏览万维网的网络机器人</li><li>其目的一般为编纂网络索引</li><li>搜索引擎抓取的重要组成部分</li><li>爬虫的主要目的是将互联网上的网页下载到本地形成一个或联网内容的镜像内分</li><li>网络搜索引擎等站点通过爬虫软件更新自身的网站内容或其对其他网站的索引</li><li>网络爬虫可以将自己所访问的页面保存下来，以便搜索引擎事后生成索引供用户搜索</li><li>同一时间点的执行逻辑用同一语句描述</li></ul><p><strong>网络爬虫的基本结构及工作流程:</strong></p><ul><li>基本工作流程简述:</li></ul><ol><li>首选选取一部分经过挑选的种子URL</li><li>将这些种子URL放入待抓取URL队列</li><li>从待抓取URL队列中取出待抓取URL，解析其URL，并得到其主机的IP，并将URL对应的网页下载下来，存储到已下载的网页库中</li><li>同时，将这些URL放进已抓取URL队列</li><li>分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环</li></ol><ul><li>逻辑简述:<blockquote><p>种子URL-&gt;待抓取URL-&gt;[已下载网页库内[读取URL，DNS解析，网页下载]]/[[已抓取URL内[将已下载URL放进已抓取URL队列]]-抽取新的URL放入待抓取URL队列-&gt;待抓取URL]<br>/符号代表同级关系，执行步骤相同</p></blockquote></li></ul><hr><ul><li>从爬虫的角度对互联网进行划分</li><li>爬虫可以将互联网页面大致划分为五个部分:</li></ul><ol><li>已下载未过期网页</li><li>已下载已过期网页: 抓取到的网页实际上是互联网内容的一个镜像与备份，互联网是动态变化的，一部分互联网上的内容已经发生了变化，这时，这部分抓取到的网页就已经过期了</li><li>待下载-&gt;若干个可知网页: 也就是待抓取URL队列中的那些页面</li><li>可知网页: 还没有抓取下来，也没有在待抓取URL队列中，但是可以通过对已抓取页面或者待抓取URL对应页面进行分析获取到的URL，认为是可知网页</li><li>不可知网页: 还有一部分网页，爬虫是无法直接抓取下载的，称为不可知网页</li></ol><hr><h3 id="抓取策略"><a href="#抓取策略" class="headerlink" title="抓取策略:"></a>抓取策略:</h3><ul><li>待抓取URL队列是构成爬虫系统中必不可失的一部分</li><li>待抓取URL队列中的URL以什么样的顺序排序，将会涉及到所选抓取页面的优先级问题</li><li>而决定这些URL排列顺序的方法，就被称为抓取策略</li></ul><hr><p><strong>几种常见的抓取策略:</strong></p><p><strong>深度优先遍历策略</strong></p><ol><li>深度优先遍历策略是指网络爬虫会从起始页开始，一个链接接一个链接的跟踪下去</li><li>处理完这条线路之后再转入下一个起始页，继续跟踪链接</li></ol><p><strong>逻辑简述:</strong></p><blockquote><p>起始页A，不同路线的链接页面B到I，链接关联:(<code>F-&gt;G，E-&gt;H-&gt;I，B，C，D</code>)</p></blockquote><ol><li><code>A-&gt;F-&gt;G</code></li><li><code>A-&gt;E-&gt;H-&gt;I</code></li><li><code>A-&gt;B</code></li><li><code>A-&gt;C</code></li><li><code>A-&gt;D</code></li></ol><hr><p><strong>宽度优先遍历策略</strong></p><p><strong>基本思路:</strong></p><ol><li>将新下载网页中发现的链接直接插入待抓取URL队列的末尾</li><li>也就是指网络爬虫会抓取起始网页中链接的所有网页</li><li>然后再选择其中的一个链接网页，继续抓取再次网页中链接的所有网页</li></ol><p><strong>逻辑简述:</strong></p><blockquote><p>起始页A，不同路线的链接页面B到I，(<code>F-&gt;G，E-&gt;H-&gt;I，B，C，D</code>)<br><code>A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F，G，H，I</code></p></blockquote><hr><p><strong>反向链接数策略</strong></p><ol><li>反向链接数是指一个网页被其他网页链接指向的数量</li><li>反向链接数表示的是一个网页的内容受到其他人的推荐的程度</li><li>因此，很多时候搜索引擎的抓取系统会使用这个指标来评价网页的重要程度，从而决定不同网页的抓取先后顺序</li><li>在真实的网络环境中，由于广告链接、作弊链接的存在，反向链接数不能完全等同于所选链接重要程度</li><li>所以搜索引擎往往考虑一些可靠的反向链接数</li></ol><hr><p><strong>Partial PageRank策略</strong></p><ol><li>Partial PageRank算法借鉴了PageRank算法的思想：</li><li>对于已经下载的网页，连同待抓取URL队列中的URL，形成网页集合，计算每个页面的PageRank值</li><li>在计算完之后，将待抓取URL队列中的URL按照PageRank值的大小排列</li><li>最后按照该顺序抓取页面</li></ol><ul><li>每次抓取一个页面，就会重新计算PageRank值</li><li>一种折中方案是：每抓取K个页面后，重新计算一次PageRank值</li><li>但是这种情况还会衍生出另一个问题:对于已经下载下来的页面中分析出的链接，也就是之前提到的未知网页那一部分，暂时是没有PageRank值的</li><li>为了解决这个问题，会给这些页面一个临时的PageRank值:将这个网页所有入链传递进来的PageRank值进行汇总，这样就形成了该未知页面的PageRank值，从而参与排序</li></ul><hr><p><strong>OPIC策略策略</strong></p><ul><li>该算法实际上也是对页面进行一个重要性打分</li></ul><p><strong>基本思路:</strong></p><ol><li>在算法开始前，给所有页面一个相同的初始现金(cash)</li><li>当下载了某个页面P之后，将P的现金分摊给所有从P中分析出的链接，并且将P的现金清空</li><li>对于待抓取URL队列中的所有页面按照现金数进行排序</li></ol><hr><p><strong>大站优先策略</strong></p><p><strong>基本思路:</strong></p><ol><li>对于待抓取URL队列中的所有网页，根据所属的网站进行分类</li><li>对于待下载页面数多的网站，优先下载</li><li>这个策略也因此叫做大站优先策略</li></ol><hr><h3 id="更新策略"><a href="#更新策略" class="headerlink" title="更新策略"></a>更新策略</h3><p><strong>简述:</strong></p><ul><li>互联网是实时变化的，具有很强的动态性</li><li>网页更新策略主要是决定何时更新之前已经下载过的页面</li></ul><p><strong>常见的更新策略有以下三种:</strong></p><p><strong>历史参考策略</strong></p><p><strong>基本思路:</strong></p><ol><li>根据页面以往的历史更新数据，预测该页面未来何时会发生变化</li><li>一般来说，是通过泊松过程进行建模进行预测</li></ol><hr><p><strong>用户体验策略</strong></p><ul><li>索引擎针对于某个查询条件能够返回数量巨大的结果</li><li>但用户往往只关注前几页结果</li><li>所以抓取系统可以优先更新那些现实在查询结果前几页中的网页，而后再更新那些后面的网页</li><li>这种更新策略也是需要用到历史信息的</li></ul><p><strong>基本思路:</strong></p><ol><li>用户体验策略保留网页的多个历史版本</li><li>并且根据过去每次内容变化对搜索质量的影响</li><li>然后得出一个平均值，用这个值作为决定何时重新抓取的依据</li></ol><hr><p><strong>聚类抽样策略</strong></p><ul><li>前面提到的两种更新策略都有一个前提:需要网页的历史信息</li><li>这样就存在两个问题:</li></ul><ol><li>系统要是为每个系统保存多个版本的历史信息，无疑增加了很多的系统负担</li><li>要是新的网页完全没有历史信息，就无法确定更新策略</li></ol><p><strong>基本思路:</strong></p><ul><li>这种策略认为，网页具有很多属性，类似属性的网页，可以认为其更新频率也是类似的</li><li>要计算某一个类别网页的更新频率，只需要对这一类网页抽样，以他们的更新周期作为整个类别的更新周期</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p>原始网页-网页聚类-&gt;[聚类一/聚类二/聚类三]-&gt;对不同类聚类分别抽样-&gt;分别确定更新周期</p></blockquote><hr><h3 id="分布式抓取结构"><a href="#分布式抓取结构" class="headerlink" title="分布式抓取结构"></a>分布式抓取结构</h3><p><strong>概述:</strong></p><ul><li>通常的抓取系统需要面对的是整个互联网上数以亿计的网页</li><li>因此单个抓取程序不可能完成这样的任务，所以往往需要多个抓取程序一起来处理</li><li>一般来说抓取系统往往是一个分布式的三层结构:1.网页，2.数据中心，3.网络爬虫</li></ul><p><strong>逻辑简述:</strong></p><blockquote><p><code>[原始网页&lt;-网络爬虫-&gt;[数据中心(远端服务器)]]&lt;-[所有的数据中心(Global)]</code></p></blockquote><ol><li>不同的数据中心分布在不同的地理位置</li><li>在每个数据中心内有若干台抓取服务器</li><li>而每台抓取服务器上可能部署了若干套爬虫程序</li><li>这就构成了一个基本的分布式抓取系统</li></ol><hr><ul><li>对于一个数据中心内的不同抓取服务器，有不同的协同工作方式</li><li>协同工作的方式有以下几种:</li></ul><ol><li>主从式(Master-Slave)</li></ol><p><strong>逻辑(同一时间点)简述:</strong></p><blockquote><p><code>[待抓取URL队列(若干数量)]-&gt;[(远端服务器)Master-&gt;Slave1/Slave2/Slave3]&lt;-下载-原始网页</code></p></blockquote><ol><li>对于主从式而言，有一台专门的Master服务器来维护待抓取URL队列</li><li>它负责每次将URL分发到不同的Slave服务器，而Slave服务器则负责实际的网页下载工作</li><li>Master服务器除了维护待抓取URL队列以及分发URL之外，还要负责调解各个Slave服务器的负载情况</li><li>以免某些Slave服务器过于清闲或者劳累</li><li>这种模式下，Master往往容易成为系统瓶颈</li></ol><hr><ol start="2"><li>对等式(Peer to Peer)<blockquote><p><code>[待抓取URL队列(若干数量)]-&gt;Hash-&gt;[(抓取服务器)server0/server1/server2]&lt;-原始网页</code></p></blockquote></li></ol><ul><li>在这种模式下，所有的抓取服务器在分工上没有不同</li></ul><ol><li>每一台抓取服务器都可以从待抓取在URL队列中获取URL</li><li>然后对该URL的主域名的hash值H</li><li>再计算H mod m(其中m是服务器的数量，此时设m为3)</li><li>最后计算得到的数就是处理该URL的主机编号</li></ol><p><strong>举例:</strong></p><ul><li><p>有server0，server1，server2分别为0，1，2号服务器</p></li><li><p>假设对于URL-<code>www.baidu.com</code>，计算器<code>hash</code>值<code>H=8</code>，<code>m=3</code>，则<code>H mod m=2</code>，因此由编号为2的服务器进行该链接的抓取</p></li><li><p>假设这时候是0号服务器拿到这个URL，那么它将该URL转给服务器2，由服务器2进行抓取</p></li><li><p>这种模式有一个问题，当有一台服务器死机或者添加新的服务器，那么所有URL的哈希求余的结果就都要变化</p></li><li><p>也就是说，这种方式的扩展性不佳</p></li><li><p>针对这种情况，又有一种改进方案被提出来</p></li><li><p>这种改进的方案是一致性哈希法来确定服务器分工</p></li><li><p>其基本结构流程:</p></li></ul><ol><li>一致性哈希将URL的主域名进行哈希运算，映射为一个范围在<code>0-2^32</code>之间的某个数</li><li>而将这个范围平均的分配给m台服务器，根据URL主域名哈希运算的值所处的范围判断是哪台服务器来进行抓取</li><li>如果某一台服务器出现问题，那么本该由该服务器负责的网页则按照顺时针顺延，由下一台服务器进行抓取</li><li>如此一来，即便某台服务器出现问题，也不会影响其他服务器的工作</li></ol><p><strong>逻辑简述:</strong></p><blockquote><p><code>URL-&gt;hash-&gt;1,2,3,4&lt;-hash&lt;-URL</code></p></blockquote><hr><p><strong>相关概念:</strong></p><ul><li>搜索引擎</li><li>网络爬虫</li><li>爬虫策略/抓取策略</li><li>爬虫，索引，检索，排序</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>WEB</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-2</title>
    <url>/2020/02/13/SQL-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="SQL-GURD"><a href="#SQL-GURD" class="headerlink" title="SQL-GURD"></a>SQL-GURD</h3><ul><li>增/删/改/查</li></ul><p><strong>增:</strong></p><ul><li>INSERT INTO 语句</li><li>基本插入语句</li><li>语法一(不指定列名):<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></li><li>语法二(指定列名):<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">INSERT</span></span> INTO table_name (column1,column2,column3,...)</span><br><span class="line"><span class="function"><span class="title">VALUES</span></span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>删:</strong></p><ul><li>DELETE 语句</li><li>基本删除语句</li><li>语法:<figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> some_column=some_value;</span><br></pre></td></tr></table></figure></li><li>如果未对WHERE语句进行规定，所有的记录都会被删除</li></ul><hr><p><strong>改:</strong></p><ul><li>UPDATE 语句</li><li>基本修改(更新)语句</li><li>语法:<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line"><span class="builtin-name">SET</span> <span class="attribute">column1</span>=value1,column2=value2,...</span><br><span class="line">WHERE <span class="attribute">some_column</span>=some_value;</span><br></pre></td></tr></table></figure><blockquote><p>uptate 表名<br>set 列名=指定值…<br>where 过滤规则</p></blockquote></li><li>如果未对WHERE语句进行规定，所有的记录都会被更新</li></ul><hr><p><strong>查:</strong></p><ul><li><p>SELECT 语句</p></li><li><p>基本查询语句</p></li><li><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">column_name</span>,<span class="built_in">column_name</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">table_name</span>;</span><br></pre></td></tr></table></figure><figure class="highlight n1ql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name;</span><br><span class="line"><span class="keyword">SELECT</span> 表名 <span class="keyword">FROM</span> 表内指定列</span><br></pre></td></tr></table></figure></li><li><p>DISTINCT 关键字</p></li><li><p>常用于<code>SELECT DISTINCT</code></p></li><li><p>返回所选被查询列中唯一不同(distinct)的值(筛选列内重复值并进行排除)</p></li><li><p>语法:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">column_name</span>,<span class="built_in">column_name</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">table_name</span>;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句:"></a>条件语句:</h3><p><strong>WHERE 子句</strong></p><ul><li>用于配置所选执行语句的过滤条件</li><li>语法:<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">column_name</span>,<span class="built_in">column_name</span> </span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">table_name</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">column_name</span> <span class="keyword">operator</span> <span class="keyword">value</span>;</span><br></pre></td></tr></table></figure></li><li>WHERE子句中的运算符:</li></ul><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">=</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt;,!=</td><td align="left">不等于</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;=</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;=</td><td align="left">小于等于</td></tr><tr><td align="left">BETWEEN</td><td align="left">在某个范围内</td></tr><tr><td align="left">LIKE</td><td align="left">搜索某种模式</td></tr><tr><td align="left">IN</td><td align="left">指定针对某个列的多个可能值</td></tr></tbody></table><hr><p><strong>LIKE 操作符</strong></p><ul><li>用于在WHERE子句中搜索列中搜索列的指定模式</li><li>语法:<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">column_name</span>(s)</span><br><span class="line"><span class="keyword">FROM</span> <span class="built_in">table_name</span></span><br><span class="line"><span class="keyword">WHERE</span> <span class="built_in">column_name</span> <span class="keyword">LIKE</span> pattern;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>SQL函数参考:</strong></p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">AVG</td><td align="left">平均值</td></tr><tr><td align="left">COUNT</td><td align="left">计数(不含Null)</td></tr><tr><td align="left">FIRST</td><td align="left">第一个记录的值</td></tr><tr><td align="left">MAX</td><td align="left">最大值</td></tr><tr><td align="left">MIN</td><td align="left">最小值</td></tr><tr><td align="left">STDEV</td><td align="left">样本标准差</td></tr><tr><td align="left">STDEVP</td><td align="left">总体标准差</td></tr><tr><td align="left">SUM</td><td align="left">求和</td></tr><tr><td align="left">VAR</td><td align="left">样本方差</td></tr><tr><td align="left">VARP</td><td align="left">总体方差</td></tr><tr><td align="left">UCASE</td><td align="left">转化为全大写字母</td></tr><tr><td align="left">LCASE</td><td align="left">转化为全小写字母</td></tr><tr><td align="left">MID</td><td align="left">取中值</td></tr><tr><td align="left">LEN</td><td align="left">计算字符串长度</td></tr><tr><td align="left">INSTR</td><td align="left">获得子字符串在母字符串的起始位置</td></tr><tr><td align="left">LEFT</td><td align="left">取字符串左边子串</td></tr><tr><td align="left">RIGHT</td><td align="left">取字符串右边子串</td></tr><tr><td align="left">ROUND</td><td align="left">数值四舍五入取整</td></tr><tr><td align="left">MOD</td><td align="left">取余</td></tr><tr><td align="left">NOW</td><td align="left">获得当前时间的值</td></tr><tr><td align="left">FORMAT</td><td align="left">字符串格式化</td></tr><tr><td align="left">DATEDIFF</td><td align="left">获得两个时间的差值</td></tr></tbody></table><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL-1</title>
    <url>/2020/02/12/SQL-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="结构化查询语言-SQL-1"><a href="#结构化查询语言-SQL-1" class="headerlink" title="结构化查询语言-SQL-1"></a>结构化查询语言-SQL-1</h3><p><strong>概述:</strong></p><ul><li>全称<code>Structured Query Language</code></li><li>是一种特定目的编程语言，用于管理关系型数据库管理系统(RDBMSR)，或在其中进行流处理</li><li>RDBMS全称<code>Relational Database Management System</code></li><li>SQL是高级的非过程化编程语言</li><li>允许用户在高层数据结构上工作</li><li>SQL同时也是数据库文件格式的扩展名</li><li>SQL基于关系代数和元组关系演算，包括一个数据定义语言和数据操纵语言</li><li>SQL在很大程度上是一种声明式编程(4GL)，但是其也含有过程式编程的元素</li><li>1986年的<code>SQL-86</code>/<code>SQL-87</code>是ANSI对于SQL的首次标准化</li><li>2016年的<code>SQL:2016</code>是现阶段最后一次标准化的更新</li><li>SQL的核心大致可分为DQL,DDL,DML,DCL四大部分</li><li>本篇只进行基本的体系整理与概念认识与理解</li></ul><hr><p><strong>SQL语言内存在要素简述:</strong></p><blockquote><p><code>子句</code>:基本构成条件，语句和查询的组成部分<br><code>语句</code>:由子句等任何其他元素构成的执行逻辑<br><code>查询</code>:基于特定条件检索数据<br><code>谓词</code>:限制语句和查询结果与控制流程<br><code>表达式</code>:用于产生任何标量值，标量值也可由列和行的数据库表构成<br><code>;</code>-<code>分号</code>:语句结束标志(终结符)，为SQL标准所定义<br>空格在SQL语句和查询中会被忽略</p></blockquote><hr><p><strong>SQL总体的构成包含五个部分:</strong></p><ul><li>数据查询语言(Data Query Language，DQL)</li><li>数据定义语言(Data Definition Language，DDL)</li><li>数据操控语言(Data Manipulation Language, DML)</li><li>数据控制语言(Data Control Language, DCL)</li><li>事务控制语言</li></ul><hr><p><strong>SQL语言构成模块简述:</strong></p><ol><li>DDL-数据定义语言</li></ol><ul><li>SQL语言集中负责数据结构定义与数据库对象定义的语言</li><li>主要由<code>CREATE</code>,<code>ALTER</code>,<code>DROP</code>(<code>create</code>,<code>alter</code>,<code>drop</code>)三个语法构成</li><li>SQL指令子的集之一</li></ul><ol start="2"><li>DML-数据操纵语言</li></ol><ul><li>SQL中用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句</li><li>以<code>INSERT</code>,<code>UPDATE</code>,<code>DELETE</code>(<code>insert</code>,<code>update</code>,<code>delete</code>)作为核心</li><li>分别代表创建，修改，删除</li><li>再加上SQL的<code>SELECT</code>(<code>select</code>查询)语句(属于DQL)</li><li>从而称其为<code>CRUD</code>即为<code>增删改查</code></li><li>SQL指令集的子集之一</li></ul><ol start="3"><li>DCL-数据控制语言</li></ol><ul><li>SQL中可对数据访问权进行控制的指令</li><li>由GRANT和REVOKE两个指令组成</li><li>SQL指令集的子集之一</li></ul><ol start="4"><li>DQL-数据查询语言</li></ol><ul><li>DQL的主要功能是查询数据</li><li>SQL中用于从数据库或信息系统中查询数据的计算机语言</li><li>由<code>SELECT</code>,<code>FROM</code>,<code>WHERE</code>,<code>GROUP BY</code>和<code>ORDER BY</code>这些语法构成</li><li>其核心指令为<code>SELECT</code>(<code>select</code>)</li></ul><hr><p><strong>其他概念:</strong></p><ul><li>语句，子句，关键字，运算符，操作符</li><li>通配符，连接，别名，约束，NULL，数据类型(通用/DB)</li></ul><hr><p><strong>参考:</strong></p><ul><li>SQL标准<a href="https://web.archive.org/web/20100304063252/http://structedtext.appspot.com/db/sql.html" target="_blank" rel="noopener">参考资料/CN</a><blockquote><p><code>https://web.archive.org/web/20100304063252/http://structedtext.appspot.com/db/sql.html</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>DBMS-1</title>
    <url>/2020/02/12/DBMS-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="DBMS-1"><a href="#DBMS-1" class="headerlink" title="DBMS-1"></a>DBMS-1</h3><p><strong>概述:</strong></p><ul><li>本篇注重对知识体系的规划与系别的整理</li><li>别称:数据库管理系统(Database Management System)</li><li>简称:DBMS</li><li>一个数据库由多个表空间(Tablespace)构成</li><li>用于将数据以一定方式存储到同一个数据库内，能同时予以多个用户共享</li><li>让应用程序的数据集合彼此独立，并且具有尽可能小的冗余度</li><li>数据库管理系统指的是为管理数据库而设计的电脑软件(程序)系统</li><li>大多数具有存储，截取，安全保证，备份等基础功能</li><li>几乎所有的数据库管理系统都配备了一个开放式数据库连接（ODBC）驱动程序，令各个数据库之间得以互相集成</li><li>不涉及结构化查询语言/数据查询语言(SQL)相关内容</li></ul><hr><ul><li>数据库的类别一览</li></ul><table><thead><tr><th align="left">类别</th><th align="left">相关(与其相结合)</th></tr></thead><tbody><tr><td align="left">分布式数据库</td><td align="left">分布处理技术</td></tr><tr><td align="left">并行数据库</td><td align="left">并行处理技术</td></tr><tr><td align="left">演绎数据库</td><td align="left">人工智能</td></tr><tr><td align="left">多媒体数据库</td><td align="left">多媒体技术</td></tr><tr><td align="left">特定领域数据库</td><td align="left">统计/空间/工程/地理数据库等等</td></tr><tr><td align="left">关系型数据库</td><td align="left">MySQL,Oracle,postgreSQL等</td></tr><tr><td align="left">非关系型数据库</td><td align="left">NoSQL/Redis,MongoDB等</td></tr></tbody></table><hr><ul><li>关系型数据库简介<blockquote><p>MySQL<br>MariaDB (MySQL的代替品)<br>Percona Server (MySQL的代替品)<br>PostgreSQL<br>Microsoft Access<br>Microsoft SQL Server<br>Google Fusion Tables<br>FileMaker<br>Oracle数据库<br>Sybase<br>dBASE<br>Clipper<br>FoxPro<br>foshub</p></blockquote></li></ul><hr><ul><li>非关系型数据库(NoSQL)简介</li><li>NoSQL是对不同于传统的关系数据库的数据库管理系统的统称<blockquote><p>BigTable (Google)<br>Cassandra<br>MongoDB<br>CouchDB<br>Redis</p></blockquote></li></ul><hr><ul><li>键值数据库简介<blockquote><p>Apache Cassandra(为Facebook所使用)高度可扩展<br>Dynamo<br>LevelDB(Google)</p></blockquote></li></ul><hr><p><strong>数据库关系模型简述(数据结构):</strong></p><ol><li>对象模型</li></ol><ul><li>层次-层次模型<blockquote><p><code>Hierarchical database model</code><br>轻量级数据访问协议<br>用树形结构描述实体及其之间关系的数据模型</p></blockquote></li></ul><ol start="2"><li><p>网状-网状模型</p><blockquote><p><code>Network model</code><br>用于大型数据储存<br>由美国的<code>查尔斯·巴赫曼(Charles William Bachman)</code>发明</p></blockquote></li><li><p>平面-平面模型</p></li></ol><ul><li><code>Flat-file database</code></li><li>表格模型，一般在形式上是一个二维数组</li><li>如表格模型数据Excel</li><li>不同于平面文件系统<code>Flat file system</code></li></ul><ol start="4"><li><p>关系-关系模型</p><blockquote><p><code>Relational model</code><br>基于谓词逻辑和集合论的一种数据模型</p></blockquote></li><li><p>ER模型-增强实体关系模型</p><blockquote><p><code>Entity-relationship model</code><br>概念数据模型的高层描述所使用的数据模型或模式图</p></blockquote></li><li><p>图-图数据库</p><blockquote><p><code>graph database,GDB</code><br>使用图结构进行语义查询的数据库，它使用节点、边和属性来表示和存储数据<br>该系统的关键概念是图，它直接将存储中的数据项，与数据节点和节点间表示关系的边的集合相关联</p></blockquote></li><li><p>面向对象-面向对象模型</p><blockquote><p>面向对象数据库<br>对象数据库的数据库管理系统被称为<code>ODBMS</code>或<code>OODBMS</code><br>以对象形式表示信息的数据库</p></blockquote></li><li><p>实体-属性-值</p><blockquote><p><code>Entity–attribute–value model,EAV</code><br>EAV也称为对象属性值模型，垂直数据库模型和开放式架构<br>是一种数据模型，以节省空间的方式对实体进行编码，其中可以用来描述实体的属性(属性，参数)的数量可能很大，但是实际适用于给定的实体是相对适度的<br>这样的实体对应于稀疏矩阵的数学概念</p></blockquote></li><li><p>空间/纬度建模</p><blockquote><p><code>Dimensional modeling,DM</code></p></blockquote></li><li><p>半结构化模型</p></li></ol><hr><p><strong>其他模型:</strong></p><ol start="11"><li><p>关联-数据关联模型</p><blockquote><p><code>Associative model of data</code><br>数据的关联模型是一个数据模型的数据库系统</p></blockquote></li><li><p>多维-联机分析处理</p><blockquote><p><code>Online analytical processing,OLAP</code><br>是计算机技术中快速解决多维分析问题(MDA)的一种方法</p></blockquote></li><li><p>数组-矩阵数据库管理系统</p><blockquote><p><code>Array DBMS</code><br><code>Array database management systems</code>(array DBMSs)<br>矩阵数据库管理系统(Array DBMS)专门为矩阵(也称为栅格数据)提供数据库服务</p></blockquote></li><li><p>语义数据模型</p><blockquote><p><code>Semantic data model,SDM</code><br>基于高级语义的数据库描述和数据库的结构形式化(数据库模型)</p></blockquote></li><li><p>星模式</p><blockquote><p><code>Star schema</code><br>在计算中，星形模式是数据集市模式的最简单样式，并且是最广泛用于开发数据仓库和维度数据集市的方法</p></blockquote></li><li><p>XML数据库</p><blockquote><p><code>XML database</code><br>数据持久性软件系统，该系统允许数据被指定，有时存储在XML格式</p></blockquote></li></ol><p><strong>关于实现方法这里不做阐述</strong></p><hr><p><strong>架构:</strong></p><ul><li>数据库的架构可以大致区分为三个概括层次:内层,概念层和外层<blockquote><p>内层:最接近实际存储体，亦即有关数据的实际存储方式<br>外层:最接近用户，即有关个别用户观看数据的方式<br>概念层:介于两者之间的间接层</p></blockquote></li></ul><hr><p><strong>数据库事务</strong></p><ul><li>事务(transaction)包含一组数据库操作的逻辑工作单元，在事务中包含的数据库操作是不可分割的整体</li><li>这些操作要么一起做，要么一起回滚(Roll Back)到执行前的状态</li><li>事务的ACID特性：<blockquote><p>基元性 (atomicity)<br>一致性 (consistency)<br>隔离性 (isolation)<br>持续性 (durability)</p></blockquote></li><li>事务的并发性是指多个事务的并行操作轮流交叉运行，事务的并发可能会访问和存储不正确的数据，破坏交易的隔离性和数据库的一致性</li></ul><hr><ul><li>网状模型-网状数据模型的数据结构</li><li>满足下面两个条件的基本层次联系的集合为网状模型</li></ul><ol><li>允许一个以上的结点无双亲</li><li>一个结点可以有多于一个的双亲</li></ol><hr><p><strong>其他:</strong></p><ul><li><p>数据库管理系统是指管理数据库的程序</p></li><li><p>相关概念简述:</p><blockquote><p>数据库存储结构(Database storage structures)<br>数据模型(data model)<br>数据库模型(database model)<br>关系模型(Relational model)<br>数据结构(data structure)<br>数据类型</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>协议概述-1</title>
    <url>/2020/02/12/%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h1 id="协议概述-1"><a href="#协议概述-1" class="headerlink" title="协议概述-1"></a>协议概述-1</h1><h3 id="TLS-Transport-Layer-Security"><a href="#TLS-Transport-Layer-Security" class="headerlink" title="TLS(Transport Layer Security)"></a>TLS(Transport Layer Security)</h3><p><strong>传输层安全协议</strong></p><p><strong>概要:</strong></p><ul><li>传输层协议</li><li>互联网上保密通信的工业标准协议</li><li>目的是为互联网通信提供安全及数据完整性保障</li><li>前身为安全套接层(Secure Sockets Layer)-SSL</li><li>IETF(互联网工程用户组)将SSL进行标准化</li><li>传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥(Session key)</li></ul><p><strong>简述:</strong></p><ul><li>TLS协议采用C/S架构，以便在两个应用程序间透过网络创建安全的传输通道，从而防止数据传输时受到窃听或篡改</li><li>TLS与高层的应用层协议(HTTP,FTP,Telnet等)无耦合</li><li>所以应用层协议能透明的运行在TLS协议之上，由TLS协议进行创建加密信道需要的协商和认证</li><li>应用层协议传送的数据在通过TLS协议时都会被加密，从而达到保证通信的私密性</li></ul><p><strong>逻辑:</strong></p><ul><li>TLS协议是可选的，必须配置客户端和服务器才能使用</li><li>主要有两种方式实现这一目标:<blockquote><p>一个是使用统一的TLS协议端口(例如:用于HTTPS的端口443)<br>另一个是客户端请求服务器连接到TLS时使用特定的协议机制</p></blockquote></li><li>一旦客户端和服务器都同意使用TLS协议，他们通过使用一个握手过程协商出一个有状态的连接以传输数据</li><li>通过握手，客户端和服务器协商各种参数用于创建安全连接，握手过程:</li></ul><ol><li>当客户端连接到支持TLS协议的服务器要求创建安全连接并列出了受支持的密码组合（加密密码算法和加密哈希函数），握手开始</li><li>服务器从该列表中决定加密和散列函数，并通知客户端</li><li>服务器发回其数字证书，此证书通常包含服务器的名称、受信任的证书颁发机构（CA）和服务器的公钥</li><li>客户端确认其颁发的证书的有效性</li><li>为了生成会话密钥用于安全连接，客户端使用服务器的公钥加密随机生成的密钥，并将其发送到服务器，只有服务器才能使用自己的私钥解密</li><li>利用随机数，双方生成用于加密和解密的对称密钥</li><li>这就是TLS协议的握手，握手完毕后的连接是安全的，直到连接（被）关闭</li><li>如果上述任何一个步骤失败，TLS握手过程就会失败，并且断开所有的连接</li></ol><h3 id="SSL-Secure-Sockets-Layer"><a href="#SSL-Secure-Sockets-Layer" class="headerlink" title="SSL(Secure Sockets Layer)"></a>SSL(Secure Sockets Layer)</h3><p><strong>安全套接层</strong></p><p><strong>概述:</strong></p><ul><li>SSL是最初是网景公司Netscape用于对HTTPS协议进行加密而退出的</li><li>SSL包含记录层(Record Layer)和传输层，记录层协议确定传输层数据的封装格式</li></ul><hr><h3 id="SSH-Secure-Shell"><a href="#SSH-Secure-Shell" class="headerlink" title="SSH(Secure Shell)"></a>SSH(Secure Shell)</h3><p><strong>安全外壳协议</strong></p><p><strong>概述:</strong></p><ul><li>网络层协议</li><li>是一种加密的网络传输协议</li><li>可在不安全的网络中为网络服务提供安全的传输环境</li><li>任何网络服务都可以通过SSH实现安全传输</li><li>在设计上，SSH是Telnet和非安全shell的替代品，而Telnet和Berkeley rlogin、rsh、rexec等协议采用明文传输，使用不可靠的密码，容易遭到监听、嗅探和中间人攻击</li></ul><p><strong>简述:</strong></p><ul><li>SSH通过在网络中创建安全隧道来实现SSH客户端与服务器之间的连接</li><li>SSH最常见的用途是远程登录系统，通常利用SSH来传输命令行界面和远程执行命令</li><li>SSH旨在保证非安全网络环境（例如互联网）中信息加密完整可靠</li><li>SSH以非对称加密实现身份验证</li><li>SSH协议有两个主要版本，分别是SSH-1和SSH-2</li><li>SSH的经典用途是登录到远程电脑中执行命令</li><li>SSH也支持隧道协议、端口映射和X11连接。借助SFTP或SCP协议，SSH还可以传输文件</li><li>SSH使用客户端-服务器模型，标准端口为22</li></ul><p><strong>SSH协议框架中最主要的部分是三个协议:</strong></p><ul><li><p>传输层协议(The Transport Layer Protocol):传输层协议提供服务器认证，数据机密性，信息完整性等的支持</p></li><li><p>用户认证协议(The User Authentication Protocol):用户认证协议为服务器提供客户端的身份鉴别</p></li><li><p>连接协议(The Connection Protocol):连接协议将加密的信息隧道复用成若干个逻辑通道，提供给更高层的应用协议使用</p></li><li><p>同时还有为许多高层的网络安全应用协议提供扩展的支持</p></li><li><p>各种高层应用协议可以相对地独立于SSH基本体系之外，并依靠这个基本框架，通过连接协议使用SSH的安全机制</p></li></ul><hr><h3 id="PGP-Pretty-Good-Privacy"><a href="#PGP-Pretty-Good-Privacy" class="headerlink" title="PGP(Pretty Good Privacy)"></a>PGP(Pretty Good Privacy)</h3><p><strong>优良保密协议</strong></p><p><strong>概述:</strong></p><ul><li>是一套用于讯息加密、验证的应用程序，采用IDEA的散列算法作为加密和验证之用</li><li>1997年7月，PGP Inc.与齐默尔曼同意IETF制定一项公开的互联网标准，称作OpenPGP，任何支持这一标准的程序也被允许称作OpenPGP</li><li>PGP及其同类产品均遵守OpenPGP数据加解密标准<a href="https://tools.ietf.org/html/rfc4880" target="_blank" rel="noopener">RFC 4880</a><blockquote><p><code>https://tools.ietf.org/html/rfc4880</code></p></blockquote></li><li>官网<a href="https://web.archive.org/web/20041230152556/http://www.pgp.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://web.archive.org/web/20041230152556/http://www.pgp.com/</code></p></blockquote></li></ul><hr><h3 id="IPsec-Internet-Protocol-Security"><a href="#IPsec-Internet-Protocol-Security" class="headerlink" title="IPsec(Internet Protocol Security)"></a>IPsec(Internet Protocol Security)</h3><p><strong>互联网安全协议</strong></p><p><strong>概述:</strong></p><ul><li>一个协议包，透过对IP协议的分组进行加密和认证来保护IP协议的网络传输协议族(一些相互关联的协议的集合)</li></ul><p><strong>IPsec主要由以下协议组成</strong></p><ol><li>认证头(AH)，为IP数据报提供无连接数据完整性、消息认证以及防重放攻击保护</li><li>封装安全载荷(ESP)，提供机密性、数据源认证、无连接完整性、防重放和有限的传输流(traffic-flow)机密性</li><li>安全关联(SA)，提供算法和数据包，提供AH、ESP操作所需的参数</li></ol><hr><p><strong>其他</strong></p><ul><li><p>密码学无政府主义(Crypto-anarchism)</p></li><li><p>加密无政府<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%97%A0%E6%94%BF%E5%BA%9C%E4%B8%BB%E4%B9%89" target="_blank" rel="noopener">跳转至中文维基</a><br><code>https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6%E6%97%A0%E6%94%BF%E5%BA%9C%E4%B8%BB%E4%B9%89</code></p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Encryption&amp;Decryption</title>
    <url>/2020/02/12/%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h1 id="加密-解密-类型与算法概述"><a href="#加密-解密-类型与算法概述" class="headerlink" title="加密/解密-类型与算法概述"></a>加密/解密-类型与算法概述</h1><ul><li>整理范围为现代密码学中的密码学算法</li><li>主要注重于对各种加密算法的浅层了解，与基本使用</li><li>对于算法本质的刨析这里先不做阐述</li><li>对于加密也先不做阐述</li></ul><h2 id="对称密钥密码学"><a href="#对称密钥密码学" class="headerlink" title="对称密钥密码学"></a>对称密钥密码学</h2><p><strong>概述:</strong></p><ul><li>[Symmetric-key algorithm]</li><li>别称:对称加密，对称密钥加密，对称密钥算法</li><li>别称:私钥加密，共享密钥加密</li></ul><p><strong>定义:</strong></p><ul><li>加密和解密时使用相同的密钥</li><li>或者使用两个可以简单地进行互相推算的密钥</li><li>多用于维持多个成员之中的秘密通信</li></ul><p><strong>常用的对称加密算法:</strong></p><ul><li>DES(数据加密标准)</li><li>3DES</li><li>AES(高端加密标准)</li><li>Blowfish</li><li>IDEA</li><li>RC5(分组加密算法)</li><li>RC6</li></ul><hr><h3 id="分组加密"><a href="#分组加密" class="headerlink" title="分组加密"></a>分组加密</h3><p><strong>概述:</strong></p><ul><li>[Block cipher]</li><li>别称:分组密码，分块加密，块密码</li><li>属于一种对称加密算法</li><li>DES是现代分组加密设计的基础思想</li><li>IBM在20世纪70年代基于<code>Horst Feistel</code>工作完成的<code>Lucifer</code>被客观认为是第一个现代分组密码</li><li>分组密码取用明文的一个区块和密钥，输出相同大小的密文区块</li><li>DES和AES是美国联邦政府核定的分组密码标准(AES将取代DES)</li></ul><p><strong>定义:</strong></p><ul><li>先将明文分成多个等长的模块(blocak)，然后使用确定的算法和对称密钥对每组分别进行加密与解密</li></ul><hr><h3 id="流加密"><a href="#流加密" class="headerlink" title="流加密"></a>流加密</h3><p><strong>概述:</strong></p><ul><li>[Stream cipher]</li><li>别称:数据流加密，流密码</li><li>属于一种对称加密算法</li><li>该算法解决了对称加密完善保密性(perfect secrecy)的实际操作困难</li><li>RC4是流加密的实现</li><li>相对于区块加密，制造一段任意长的密钥原料，与明文依比特或字符结合，类似一次一密密码本(one-time pad)，输出的流根据加密时的内部状态而定</li><li>输出的流根据加密时的内部状态而定</li></ul><p><strong>定义:</strong></p><ul><li>先加密和解密双方使用相同伪随机加密数据流(pseudo-random stream)作为密钥</li><li>然后让明文数据每次与密钥数据流顺次对应加密，从而得到密文数据流</li><li>实践中数据通常是一个位(bit)并用异或(xor)操作加密</li></ul><hr><h2 id="非对称密钥密码学"><a href="#非对称密钥密码学" class="headerlink" title="非对称密钥密码学"></a>非对称密钥密码学</h2><p><strong>概述:</strong></p><ul><li>别称:公开密钥密码学 [Public-key cryptography]</li><li>别称:非对密钥码密码学 [Asymmetric cryptography]</li><li>别称:公开密钥加密算法，公钥密码学，非对称式密码学</li></ul><p><strong>定义:</strong></p><ul><li>拥有两个密钥，一个公开密钥，一个私有密钥，前者加密，后者解密</li><li>使用其中任一密钥用于加密，另一个则用于解密</li><li>经过密钥加密的密文只能通过对应的另一个密钥进行解密才能得到原文</li><li>曾用于加密的密钥也不能对其加密过的数据进行解密</li><li>因此加密和解密需要两个不同且互相对应的密钥，所以被称为非对称加密</li><li>不同于加密和解密都使用同一个密钥的对称加密</li><li>虽然这两个密钥于数学上相关，但依旧不同通过其中一个密钥来计算出另外一个密钥</li><li>因此其中一个可以公开，称为公钥，可以任意发布</li><li>不公开的密钥为私钥</li></ul><p><strong>简述:</strong></p><ol><li>加密过程d(c(x))=x</li><li>主机A撰写未加密明文x</li><li>主机B通过[密码学安全伪随机数生成器]生成一对密钥，其中一个公钥为c，另一个作为私钥d</li><li>而主机B要做的就是向主机A发送公钥c，即便任何主机于中间窃听到c也没关系</li><li>主机A用公钥c对明文x进行加密，得到密文c(x)</li><li>此时主机A向主机B发送密文c(x)</li><li>主机B在收到密文c(x)后，使用私钥d对密文c(x)进行解密d(c(x))，得到明文x</li><li>此时如果主机A没有私钥d时，它将无法透过主机A的公钥c和密文c(x)重新获得原文x</li></ol><hr><h2 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a>密码散列函数</h2><p><strong>概述:</strong></p><ul><li>[Cryptographic hash function]</li><li>别称:加密散列函数，散列算法，哈希函数(hash)，消息摘要函数，杂凑函数</li><li>是散列函数(hash function)的一种</li><li>是一种单向函数(单向散列算法)</li><li>不一定使用到密钥，但和许多重要的密码算法相关</li><li>常用于数字签名/公钥数字签名(digital signature)</li><li>应用于<code>MD5</code>,<code>SHA-1</code>,<code>SHA-2</code>,<code>SHA-3/Keccak</code></li><li>数字签名标准内的数字签名算法</li><li>它将输入数据(通常是一整份文件)输出成较短的固定长度散列值，这个过程是单向的，逆向操作难以完成，而且碰撞(两个不同的输入产生相同的散列值)发生的几率非常小</li><li>消息认证码或押码(Message authentication codes, MACs)很类似密码散列函数，除了接收方额外使用秘密密钥来认证散列值</li></ul><h3 id="SHA类密码散列函数"><a href="#SHA类密码散列函数" class="headerlink" title="SHA类密码散列函数"></a>SHA类密码散列函数</h3><p><strong>概述:</strong></p><ul><li>[Secure Hash Algorithm]，缩写为SHA，常用于特指一整个密码散列函数系列</li><li>别称:安全散列算法，安全哈希算法</li><li>由FIPS<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>认证的安全散列算法</li><li>由美国国家安全局(NSA)所设计</li><li>由美国国家标准与技术研究院(NIST)发布</li><li>是一种密码散列函数</li><li>用于计算出一个数字消息所对应到的，长度固定的字符串(又称信息摘要)的算法</li></ul><p><strong>系列成员:</strong></p><ul><li>SHA系列的五个算法:<blockquote><p><code>SHA-1,SHA-224,SHA-256,SHA-384,SHA-521</code></p></blockquote></li><li><code>SHA-256</code>到<code>SHA-512</code>有时被并称为<code>SHA-2</code></li><li><code>SHA-1</code>在许多安全协议中广为使用</li><li>包括<code>TLS</code>,<code>SSL</code>,<code>PGP</code>,<code>SSH</code>,<code>S/MIME</code>,<code>IPsec</code></li><li>最初的算法于1993年发布<code>SHA-0</code></li><li>也可称为[安全杂凑标准(secure hash standard)，<code>FIPS PUB 180</code></li><li>NSA于1995年发布<code>SHA-0</code>修订版本<code>FIPS PUB 180-1</code>(SHA-1)</li><li>最新的标准是FIPS PUB 180-3于2008年更新</li><li>规定了SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法</li><li><code>SHA-1</code>，<code>SHA-224</code>和<code>SHA-256</code>适用于长度不超过<code>2^64</code>二进制位的消息</li><li><code>SHA-384</code>和<code>SHA-512</code>适用于长度不超过<code>2^128</code>二进制位的消息</li></ul><p><strong>简述:</strong></p><ul><li>思想是接收一段明文，然后以一种不可逆的方式将它转换成一段(通常更小)的密文</li><li>或称为</li><li>取一串预映射或信息(输入码)，并将它们转化为长度较短，位数固定的输出序列</li><li>即散列值 也可以称为信息摘要或信息认证码 的过程</li></ul><p><strong>散列算法概述:</strong></p><ul><li>散列是信息的提炼，通常其长度要比原信息小的多，且为一个固定长度</li><li>加密性强的散列一定是不可逆的，所以说通过散列的结构将无法退出任何部分的原始信息</li><li>任何输出信息的变化，哪怕仅一位，都将导致散列结果的明显变化，即为雪崩效应</li><li>散列还应该是防冲突的，即找不出具有相同散列结果的两条信息，具有这些特性的散列结果就可以用于验证信息是否被修改</li><li>单向散列函数一般用于产生信息摘要，密匙加密等，常见的有MD系列(由RSA数据安全公司开发的一种单向散列算法)，SHA系列</li><li>散列算法可实现数字签名的实现</li></ul><p><strong>数字签名概述:</strong></p><ul><li>数字签名的原理是将要传送的明文通过一种函数运算(hash)转换成报文摘要(不同的明文对应不同的摘要)</li><li>报文摘要加密后与明文一种传送给接受方</li><li>接受方将接受的明文产生新的报文摘要与发送方发来的报文摘要解密比较</li><li>比较结果一致表示明文未被改动，反之则明文已被篡改</li></ul><hr><h3 id="消息认证码"><a href="#消息认证码" class="headerlink" title="消息认证码"></a>消息认证码</h3><p><strong>概述:</strong></p><ul><li>[Message authentication code，MAC]</li><li>别称:消息鉴别码、文件消息认证码、讯息鉴别码、信息认证码</li></ul><p><strong>简述:</strong></p><ul><li>是经过特定算法后产生的一小段信息，用于检查某段消息的完整性，以及作身份验证</li><li>用来检查在消息传递过程中，其内容是否被更改过，不管更改的原因是来自意外或是蓄意攻击</li><li>同时可以作为消息来源的身份验证，确认消息的来源</li><li>消息认证码的算法中，通常会使用带密钥的散列函数(HMAC)，或者块密码的带认证工作模式(如CBC-MAC)</li><li>信息鉴别码不能提供对信息的保密，若要同时实现保密认证，同时需要对信息进行加密</li></ul><p><strong>密钥散列消息认证码</strong></p><ul><li>Keyed-hash message authentication code</li><li>又称散列消息认证码(Hash-based message authentication code，HMAC)</li><li>是一种通过特别计算方式之后产生的消息认证码(MAC)，使用密码散列函数，同时结合一个加密密钥</li><li>它可以用来保证数据的完整性，同时可以用来作某个消息的身份验证</li></ul><hr><h3 id="密码学安全伪随机数生成器"><a href="#密码学安全伪随机数生成器" class="headerlink" title="密码学安全伪随机数生成器"></a>密码学安全伪随机数生成器</h3><p><strong>概述:</strong></p><ul><li>Cryptographically secure pseudo-random number generator</li><li>通称CSPRNG</li><li>亦作密码学伪随机数生成器</li><li>是一种能够通过运算得出密码学安全伪随机数的伪随机数生成器</li><li>相较于统计学伪随机数生成器和更弱的伪随机数生成器，CSPRNG所生成的密码学安全伪随机数具有额外的伪随机属性</li><li>CSPRNG常被作为密码学原件，用以搭建更复杂的密码学应用</li><li>如，可变长CSPRNG和XOR函数搭配即构成流密码的编解码方法</li></ul><hr><h3 id="对等加密-Reciprocal-cipher"><a href="#对等加密-Reciprocal-cipher" class="headerlink" title="对等加密(Reciprocal cipher)"></a>对等加密(Reciprocal cipher)</h3><p><strong>概述:</strong></p><ul><li>是对称密钥加密(Symmetric-key algorithm)的一个特例</li><li>该类密码的加密算法是它自己本身的逆反函数，所以其解密算法等同于加密算法</li><li>如果要还原对等加密的密文，套用加密同样的算法即可得到明文</li><li>换句话说，使用相同的密钥，两次连续的对等加密运算后会回复原始文字</li><li>在数学上，这有时称之为对合<blockquote><p>常见的对等加密算法有<code>ROT13</code>，<code>异或密码</code>，<code>RC4</code></p></blockquote></li></ul><hr><ul><li>几个重要的概念，公钥，私钥，加密，解密，对称，非对称，散列算法(hash)</li><li>所有的复杂的现代密码学算法都是基于对称加密或非对称加密算法与散列算法加密所建立的</li></ul><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">联邦信息处理标准(Federal Information Processing Standards)</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Password</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔 2020-2-2.11</title>
    <url>/2020/02/11/%E9%9A%8F%E7%AC%94-2020-2-2-11/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="830cefc0245e921249e5c00f9277558a9e31d701d05d1bbda31ac43ab7e4ebae">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98aa1a98520952bc00918cdbd1c769f4d2bdf0070aef349bdc8f07ddad67446e6ce2b97482e6d1fa40808209c076452f032e0f2e13e70163cf8ed4e0058acacbf63457ec66651ece6ca06d5de1f47883342eadae6aabb71e98daefe884a5463348bf8600e81d30ac99c24b5be6c692e00bd5f1559d525c89c3dca8113bd4aa92cfa3644965bd584d4d8c69be18899e50fc1607afc665c89d08557454d5bfa133fffe3031f112586bf450a8f83b4266e903b23792e6db6a582fa387e461b2b0cb0c14d72b8cb796dfeb2dba9813f756d95ba6703f56188094a89a20dcd1dac0764f42f9b8e5aa05b67a995e81be755bd81d26339baca17f0636e639c3a0306e159865c43680a254b16c1bd4c9b3097078221984488caff4f9077c7eeb8b8d5b120b18cf3238510ecad5db617af0eee0b6310a4417ee4c403e50388d05a7c2e1e408bf1301884a2345b865a326ac6d0571edc8b75c7aa4ce2a944af1ae484711c3527f36d2f9d428f2cd9e57ff1ccf50bdc769baa3e827cb8712d936cad85719ffa001d97ebe08af4946c41056b7750f79b5187ef42f053316b641d062f5474dce6ea649e1b9e691ebd08a7a2da4d6b2aa90a5c446477890f0baeaef05a01a16cd9f8c9dee21e286b75e986a44c684fb9d19139859a981eb166e3f40fd11e3ee5761da4659b61bd44c5f6c1aabe3572fdb8f74d411743173e3b7dfa61494698b409bb3662f51696e40f989d4a423cf1b8eb1cbdf96ed40e1e1b510d437f8762d4633c3a8a5081d0f1b4c8385c1345ffd932554fd34e37d74b04d83e4926fd5e97bf74f788c2007e7c9ba7696102471e96436352c2ee88386204abb3347b43a8b548574ac7ac13cc0c1fb26eb1916aebd3fd6795c23c715dff648c452d04147f1917f93e5764fbbf39487ed8453f945da0517e45105a3782b37e13216e8b1677cc18209e259c71c4b00a687d9fa37354b10285e2f2f1745f1a681e577aa0cd9ca4fc4feeb7a8c82dc38c0fd5cbeb3dfb54bf3818ab061cbe0f28b0af1f8a8ebb667f75e16cc1f9e2a5cbd532ffab2a25120abf0eef4185c4465125028b6820c8766847b4a8bf92876ef82a0d3b4748883269b9361d4d98a4143c63f2a1613f5ebe09533042f6d0873f69f8da7581b410668c91a079df8e69c47e0b2421edbc7f2b4cc66dd0fb6f752c6ba353d68aa46580f24bfa4211563ab1c9b86a393685bc7d5027a6933d0f5aec7f793761d94e341e2a3634c53f501d98852112a27bc1f2d1d506828ac292a8c6975dea619c70d444fb89a7fb538ff218850be70349c99c5de67cc352e10fe7c3873f3e4e8adc3e14275f1d011c827f263216170030677efa5781e44f9e3cfc61f116ef5dbb3c62857255b5e19412396ca0d9d3a22afd5634f85c712c7001b140a94574e55ac2c6055ffa299606931fcda95990654dfac9aec937e9b06ce6251cd1ddef17b5f22426d7157fb68c68aef895751370c9ca5d1a1e0a77cb889fdf5ee39369a98f0562fe08460e49ea99bc2544ecaa509a232273e875384a0a38fcd4c1713e10455d625977bcd766410b8b982fbe35c187bbbad5690a6c99cc8eb720742b05dc8f0086deaad43a5608482d1333746c97df42b708f53f58a9d7b6a0ed1cf592d19dabb5e4768a0f8e288b855ac3a578f8cc2906a3469bbd49441a5bfa21d003a68c6d96265b2a8c2dc82257f380c0e4b4d160fe516d2d00427efec24cb56822234890371f23714a3e2137c093694f254cbf7667a330d7b99784afdeab0fe41209a6fb40b2dc9ec1dac2878d6f74baaed9e5a9377826c15cb61f80b2c9028ad94062d419dae99a609da193ab3c7d06b126a2fd89e39cf57e8299d25348f3bc5d0a2c4903c05d980c2a382c51dd368a2efe1e128ddd1a28c7450df4f6fdb057cfee83e976554e025d74d187e78fe33414f4b7ffae91ab482264a8d0f41776feaf5e54e9dcc50c8bffbb8004513be298fc2be02240110255ea7409ef02d402b588e8b407ab3966b2a905558f968e0d65624521b005b6ada9634251047581f3b07da9481625637a6c0fb56b3b3569362db2e27e6d457a345dfc103517850ad0aec70383943952a26e418473a24b9c026bd5f75a500ee1eac1ecec239e21d18ae26be3f204946811727e5497833a29ff3601da4ee012495824f104a6a3386463d4fde4ea011283e7680d6aa7358ff24b4e3c5f6cfd625f31db2e33218306f97002e25f22de78c7948174008f46c8d061d1ef8fb81aadf4d7637a19e2229d9d5a11f18cfd40ce31b411f5f6c6a78e2c64279293595728f2e40e77b886f7c4c05f12dc3d8f60db14f871dac942c3b1649bb86dec73e94f2891e7700d6d9792bcef40da77afbe7bc0654ec50b4af1733cbd55d30a44ab0d8e03d8e150d04e58afa18ce97da8da18d8420f073aef4c4978f24e68c24da0f86c9f7fc634e6376bbbd001787a5449d6c8d766c867a89d2feae5aeb9fd06a5b01cf53aebd3e594a3b7213039f3b206ee0c01508acd8831f648318395a62e253269e113c64710822da1c827008739a24018a56c594fe5876a3f3fc41b88ebd1808167169e13d1420ea59dad98a855d6eff84b0d0f046b7968e532691908e8af4b0e3380089142ed718cb8ac36bb9ffaae0da2cd507c6eddc7a0b23e3fb053fa73d646f45132d5eb301d21ca2d3c847e399127236ed1e50728dbd9a06b96a1ded5b09bef238f82034b4360f010cb994606d729e48b1cf3357b238bdc0a56f626c5585e0a9ad73ec84b71a36354d464d792c254d3101f0c401cd0d23c8d4cfa41132ade38398618301401b4f0bdc36affbeeba0a27cdeccf2cd7984b7506dc9242ca6f91d27b3794c4f3c8e98971cfe3003dae23bdbb60bb22063391ee06be73ec963baa0488de5c0a4cb75179c677cab80b47032a2ae37063f1a5e6a689c1c3e5afa4545b119e4351e5af1f44c739afe3b448525d315b1ca77573e60f74bff61bc68492ca2c4856fadfc6911c758e23a01ca05100b793637bf096c4f268a8f78e7349e2044dee591aa82f21b7ce5964192875bee8b5dc3debdda96f01b851941f12e4d0052744a0ea3a3d4abece427d514a33687cc62039a92a8052c1c2313a702d217a2010b69931eacc0e110e2f90545a9281ae2c5d7acd01c290e774d395d2a7d6b3596acf122d3b23bdc3e0eb8b36e78dc591ed6559e8ca6b9e2ec788ce1d017f4ea3682c8ee131fced0c47f8809cde96e0062f7563ca8a41c480a1d402f9905eb95073f40733bc0a9c7fad060bf79eb11d5f4aa673b6818f07b5abd37d77e41761cde0ab78ccb64f34756096a2b2aea66605ed883a49743e866ab9a0259fd5dbeed39ceea5fa9b767f26bbb9965cb1d7e2ecfd5a447efdc2aae49de82594e932f32057f89a50c728f0949f4ed33d6e0d4441d923b94bfe8ecd6b724bad3a252bdabbd90828f2efed0ccc8e1c53698bbf95d2dfecfbf0cc9bd82d4f4b84639a78d1aa294bff5c1cc44d0b1f51e5cffeda20a05b39a0442037f73509a9c467c03c5b8897498e4e8fce5fcdf39e2b2892dfdd30e57ad9ea548e86298d5e0909893bbe42f757eb170c450c77c2739bfdf39f113ca66ce28920a7885815e9c29c948f61f78ede201e85637c5e6de90eae4e03cd762abcd9f2863f41ec2ce9972d2cf09773e8364356b929d4decf10af0ac91bb31e205c71a988cd652fc3487a144839a6d8840e0ceea911d2ea07c3423d830fd4a626ad276f8b341dbf6f34a3e4c9ffead91a744acfa49866e50b650df28e9602135380c64f19ea3fd5d1f6b6a7cc246914ec930ecce33c8e1bcf669e853c6e9cb17f1e33a18dea12abb2ec7cd1673ad7f3fda6e05458df54db1c2298af42e9d275a6d5bbc5438180609b7efc0a2854e41462dc904b5cdf62ebc7719805c7c013858b8dc60fc665dcfa082f141364cca383cb8f092391a1df6b424177a00422880b93590ec20966a3ebb1211aec14bdf7985e7a8c5b67f64226beead432ef9526bc6d1616c3ba2a3c27d69a6a626634e0820943b56fcacee6fab6f0cea992a91c51e8711c106f2444ca789ded0c8041a615c6d2f8469b82bd36d7e381f10338b1fa90adab3e71dbcd06a9d1a4ade5ab8b04a77d737fe5d59c2e8a235bf647ec5af42812e01c6f8bcc7e30fd86ec6972100439385f4ead6b3c41f333e4a41d31a243e0ff3712f432725f0a9610ae801a228533378032f1ce460b8e79eb560fa546b61fdf364a361542bb0797e96d033caae3ccc0c27c53ee1c79c14bcbd8337a60a0ae5bd5050a667a48a423c965b3e2f3ea0dee71d5e24b3979290a96977666644c204ec9cdfd389fcdef41ebbd01d2042225fd7d19c1dae3e24be6a5ed0fa56ecd031c5ea146d73a392504c17eb14377bed874aa5a3e91d4977a97caec048cce9e9713fe1cf2918cf7805d5147e17963e323e7707bf66cc0bb996b84c6b0aea329d6db96b4e508102615eaca626ac67c8bd17b743f23395553b17e613e0a628101c0f88ce68125f0b3cd8bb2479a8af1800a919c081b64f048d9dea1d7bd6ab772b1959c91aeea7f02c248221558bdaf9d5bc6984f6aa7356a49b9457d09e191173c7a43e0f45c6f47a14929583aef1e6ee524729602e5ca9595b8d507c7e94099aa2f076718e29e6b2b3764e0c84cf3bd0f0b0e5a8dade9ac7d548d3524d8640d0813fc046440615c85f9513eca442aac2b02aaad8b1305249f6ff1590738bf7c51803b03588de706788cb7560a0326797633bfd452948b513b1b22f5c6fda4e3baf9226b66937dbb0298aa3a1312482c3fe3293964f2c8d5e68789aca7d0bbe3d24b778967bc40ee63cec39a0d6d8b16554b67836846569f388d8dbdd7f70bc60d8f6fa61f9525f67b7aec20717f82666aae053df99e002ef16c57f7cbffe2b1b31f11ab5fcbb4f3c81d04291951c2e746ea9ce26b161bf7243f331974703660b0e618829da522f279286d26bea8312a87017335e8b9485c1dbba81891e2b99c421e8b44398dc7d1d5c3fdd025f4e16e533073ff9207f8565d61691dc1442833602b232c98ecedef84fbc8adfa229f7fee3ccaf616db45d8b9474b6a62f48afffaf9d8764da1550d6d3c1e074fb0329050be2c8c4423f78ec77a2b91eaa7a92ed0ca0654445d70116d18d2b57e432711c96556ffe0abddd774c89a73c3383d8eaf7e4b123b34bc39f2c1af54d5284732cb994b93fe7e31e6cb0d70a23af5e855e10bcbfc30f13e3a15671b781a0b813dc5d3477e2f7cbdf2d07bc3c339ff29db517ea231c1a9c3d99bba3f81d85b9d5b12cbf2ca53d1dbb183f6fb68806364e654d794057e448afc37e03e7a3ddbeb03a2f312bd3228fd57b33911288883b9eaebf1dc666972d73d7c8237b87506ca7c4a5dcbd6ce8d1f3a0eb5aa0613ff86fc605318b213b8bd224a69494a1b450e3596bc2e4027a0ac20f6847aad87240e58409c455d3027cd6789acdf1c2bfcd93ee456cde2c91954ecf3244558d667fdaf44e2d9490d5bdea04d8e73ad2db0fa2cab18063b21634f4ec4968e044bdce0291c13d989ecad76aeec13c8d72335bc808135b709d2b2f004a33c7a89ead16cf286dce7109f9b7fd68e96b98c40364e96ddcc34c023f696f343e9804eac372ae824001abeaa23c5facea4cff510ddac77d6efe40646e86d5ce9e94ba730028affeab52bc6fd57bade3b67083cd420be26b0a7874127675713232e71507ca35ae8077a09246f8626d4cd247f26371679e60edff54a2f913bb05c87fb0984c5598308fe49b898b63cd07971fc56fe9c03e6d6fee0019ced16689e1ebe5e3bc0f8c49f7d2fe69ea4ae3c4a32bb1a4a56e53832c6bc715334d49721459c0990b86705b7f6fb1e7adfa0263eb25089bddb2f6e9fe6a845227f5e39178ae2895aab045220f51fae43e2344e4b464a664a9bc87f7ad445095edde616273ac396dfaed362935b1a254b8c9b3fc991413e034719f7e93cc8f28a2fec7214178c7601765d38f6cf8ed418f40c2c20ba69bbddb7fd404ae0b94bd3bcdb02a77ecce646e8439ea6474345ea1892a16459569691f90c5ee63850ebbd181d514065717b848ad7182e4e61c3dfcf8ca3bfdfc47f483a2e50e3e91ec5ddad18cd9707d7cd260bdbe829fce1173fb4ddb8dcaba7a0e3ab894426661f42b85ea3795838339ec3d87eb3bdfb33f3005cd486a11f5905194538663a3a54718ed1ba410b4128660383d3c87b97d2de3d9b514bf1b5741a54cb05a33bd68f3b05939783aaa607d826082b62a47365d11b48062e8228ef2d8db8da0cf15c273fe1934606e6ef51ecc782ebe7cb326606b46eae385ee7db76a5447685361948d4d01dc2a26150c1ee30883e367e1a08b46ce7e5115aa035974a77e68a15ea9668a29a1415a3bed08c9be3aea0e7429dfc324dbc0e8dfed0cf3784667c412dcb727db5795ca97b9a6a5fa54ec9a74650f3e0a277bf62b331505201213cdd1f1028328b263a60bb3d16d4e94cd563de65f69b5de3849e34774ea8205038f019a4013a49a3f87ba0d8e0d7225b1268a9a92516cc96127f859a4bd0cca4c98decea32a185dac42718ebffda3ffea98709b1b9283a3d17b9a964f0800a6fd514faaa67807a22ae89058d84bfa39787de04b702d450b256e7bd1b80e99883d71e703b0d64d085a882dc13b2b0edc4de194ad1a280b72b261fa026cadc878c2be5592ba338928664b7cc33a3b1ec475359f7f9c00c0ee50ea39fa6dfe9e75a07dd20548c20b2cd509a7f0e6c03f917c5da3fa4f63ebc18fe69197f75fd2fed687e476bac7897aebca56890e4bb1f75dcfc1a2bb6125a374601a9aa0d25d1c9a90fd2c3077279d7541c22e389bf21032b1abca318c4447e3aad50f5df5a46931485f17efc0443aed8a76dd73d2c588799d5129832896bd83cc9b716872d6fe8f13e35178871119dcd5205d796670cfa220f2ed1c5bb31a786f98243810c792056344334d0869a6393af43650d6bb6b8a8474dcdb4b6dd096a4d83e88020010b805f1786103e6c4fb8703a92b01e6dccdf94eb100e23faf81bd1c691723860c844df566c9411e5622cdfc06ea951927e784cf6bd5a07462e601cd13a6ee8424d6</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-随笔</title>
    <url>/2020/02/09/Docker-%E9%9A%8F%E7%AC%94/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Docker-随笔"><a href="#Docker-随笔" class="headerlink" title="Docker 随笔"></a>Docker 随笔</h3><ul><li><p>Docker 由Go语言编写</p></li><li><p>Docker 主要分支(三大项目)</p></li></ul><ol><li><p>Docker Engine-Community</p><blockquote><p>docker社区</p></blockquote></li><li><p>Docker Compose</p><blockquote><p>docker自动化操作-YAML/Go</p></blockquote></li><li><p>Docker Machine</p><blockquote><p>docker集群化管理</p></blockquote></li></ol><hr><ul><li>基本概念</li><li>dockerfile</li><li>容器集群网络</li><li>docker虚拟机</li><li>swarm集群</li></ul><hr><ul><li>绝对基本流程<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">images</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">search</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">run</span></span><br><span class="line"><span class="attr">search</span> <span class="string">ps -a</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rmi</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rm -f </span></span><br><span class="line"><span class="attr">docker</span> <span class="string">start/restart/stop</span></span><br></pre></td></tr></table></figure></li><li>能直接拉就直接拉，不到极端情况下最好别总想着整一些类似于dockerfile的花活</li></ul><hr><ul><li><p>docker hub<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com</code></p></blockquote></li><li><p>文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/</code></p></blockquote></li></ul><hr><h3 id="容器服务安装并启动实例"><a href="#容器服务安装并启动实例" class="headerlink" title="容器服务安装并启动实例"></a>容器服务安装并启动实例</h3><p><strong>容器-操作系统</strong></p><ul><li>Ubantu/Debian/CentOS</li><li>先<code>docker search</code>看一下镜像</li><li>直接<code>pull</code>过来然后<code>exec</code>就行</li><li>默认是最新版本<code>Ubantu/Debian/CentOS:latest</code></li><li>Docker Hub内点击<code>Sort by</code>选项卡查看其他版本</li><li>这里暂时不阐述通过Dockerfile构建的方法</li></ul><ol><li><p>Ubuntu 镜像库地址<a href="https://hub.docker.com/_/ubuntu?tab=tags&page=1" target="_blank" rel="noopener">跳转</a><br><code>https://hub.docker.com/_/ubuntu?tab=tags&amp;page=1</code></p></li><li><p>CentOS 镜像库地址<a href="https://hub.docker.com/_/centos?tab=tags&page=1" target="_blank" rel="noopener">跳转</a><br><code>https://hub.docker.com/_/centos?tab=tags&amp;page=1</code></p></li><li><p>Debian 镜像库地址<a href="https://hub.docker.com/_/debian?tab=tags&page=1" target="_blank" rel="noopener">跳转</a><br><code>https://hub.docker.com/_/debian?tab=tags&amp;page=1</code></p></li></ol><hr><p><strong>容器-web服务</strong></p><ul><li>Nginx/Apache/Node.js/Tomcat</li></ul><ol><li>Nginx</li></ol><ul><li><p>说明:Nginx是一个高性能的HTTP和反向代理web服务器，同时也提供了<code>IMAP/POP3/SMTP</code>服务</p></li><li><p>镜像库地址<a href="https://hub.docker.com/_/nginx?tab=tags" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com/_/nginx?tab=tags</code></p></blockquote></li><li><p>运行容器:</p><blockquote><p>$ docker run –name nginx-test -p 8080:80 -d nginx</p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>--name nginx-test</code>:容器名称<br><code>-p 8080:80</code>:端口进行映射，将本地8080端口映射到容器内部的80端口<br><code>-d nginx</code>:设置容器在在后台一直运行</p></blockquote></li></ul><hr><ol start="2"><li>Apache-httpd</li></ol><ul><li><p>镜像库地址<a href="https://hub.docker.com/_/httpd?tab=tags" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com/_/httpd?tab=tags</code></p></blockquote></li><li><p>运行容器:</p><blockquote><p><code>$ docker run -p 80:80 -v $PWD/www/:/usr/local/apache2/htdocs/ -v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf -v $PWD/logs/:/usr/local/apache2/logs/ -d httpd</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>-p 80:80</code>:将容器的 80 端口映射到主机的 80 端口<br><code>-v $PWD/www/:/usr/local/apache2/htdocs/</code>:将主机中当前目录下的<code>www</code>目录挂载到容器的<code>/usr/local/apache2/htdocs/</code><br><code>-v $PWD/conf/httpd.conf:/usr/local/apache2/conf/httpd.conf</code>:将主机中当前目录下的<code>conf/httpd.conf</code>文件挂载到容器的<code>/usr/local/apache2/conf/httpd.conf</code><br><code>-v $PWD/logs/:/usr/local/apache2/logs/</code>:将主机中当前目录下的<code>logs</code>目录挂载到容器的<code>/usr/local/apache2/logs/</code></p></blockquote></li></ul><hr><ol start="3"><li>Node.js</li></ol><ul><li>镜像库地址<a href="https://hub.docker.com/_/node?tab=tags" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://hub.docker.com/_/node?tab=tags</code></p></blockquote></li><li>运行容器:<blockquote><p><code>docker run -itd --name node-test node</code></p></blockquote></li><li>进入容器内部查看其服务版本</li></ul><hr><ol start="4"><li>Tomcat</li></ol><ul><li>镜像库地址<a href="https://hub.docker.com/_/tomcat?tab=tags" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://hub.docker.com/_/tomcat?tab=tags</code></p></blockquote></li><li>运行容器:<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ docker <span class="keyword">run</span><span class="bash"> --name tomcat -p 8080:8080 -v <span class="variable">$PWD</span>/<span class="built_in">test</span>:/usr/<span class="built_in">local</span>/tomcat/webapps/<span class="built_in">test</span> -d tomcat</span></span><br><span class="line">acb33fcb4beb8d7f1ebace6f50f5fc204b1dbe9d524881267aa715c61cf75320</span><br></pre></td></tr></table></figure></li><li>参数说明:<blockquote><p><code>-p 8080:8080</code>:将容器的8080端口映射到主机的8080端口<br><code>-v $PWD/test:/usr/local/tomcat/webapps/test</code>:将主机中当前目录下的<code>test</code>挂载到容器的<code>/test</code></p></blockquote></li></ul><hr><p><strong>容器-数据库</strong></p><ul><li><p>MySQL/MongoDB/Redis</p></li><li><p>MySQL</p></li><li><p>镜像库地址<a href="https://hub.docker.com/_/mysql?tab=tags" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com/_/mysql?tab=tags</code></p></blockquote></li><li><p>运行容器:</p><blockquote><p><code>$ docker run -itd --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>-p 3306:3306</code>:映射容器服务的3306端口到宿主机的3306端口，外部主机可以直接通过宿主机<code>ip:3306</code>访问到MySQL的服务<br><code>MYSQL_ROOT_PASSWORD=123456</code>:设置MySQL服务root用户的密码</p></blockquote></li></ul><hr><ul><li>MongoDB</li><li>简介:<code>MongoDB</code>是一个免费的开源跨平台面向文档的<code>NoSQL</code>数据库程序</li><li>镜像库地址:<a href="https://hub.docker.com/_/mongo?tab=tags&page=1" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://hub.docker.com/_/mongo?tab=tags&amp;page=1</code></p></blockquote></li><li>运行容器:<blockquote><p><code>$ docker run -itd --name mongo -p 27017:27017 mongo --auth</code></p></blockquote></li><li>参数说明:<blockquote><p><code>-p 27017:27017</code>:映射容器服务的27017端口到宿主机的27017端口，使外部可以直接通过宿主机<code>ip:27017</code>访问到<code>mongo</code>的服务<br><code>--auth</code>:需要密码才能访问容器服务</p></blockquote></li><li>接着使用以下命令添加用户和设置密码，并且尝试连接<blockquote><p><code>$ docker exec -it mongo mongo admin</code></p></blockquote></li><li>创建一个名为<code>admin</code>，密码为123456的用户<blockquote><p><code>db.createUser({ user:&#39;admin&#39;,pwd:&#39;123456&#39;,roles:[ { role:&#39;userAdminAnyDatabase&#39;, db: &#39;admin&#39;}]});</code></p></blockquote></li><li>尝试使用上面创建的用户信息进行连接<blockquote><p><code>db.auth(&#39;admin&#39;, &#39;123456&#39;)</code></p></blockquote></li></ul><hr><ul><li>Redis</li><li>简介:是一个开源的使用<code>ANSI C</code>语言编写、支持网络、可基于内存亦可持久化的日志型,<code>Key-Value</code>的<code>NoSQL</code>数据库，并提供多种语言的<code>API</code></li><li>镜像库地址:<a href="https://hub.docker.com/_/redis?tab=tags" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://hub.docker.com/_/redis?tab=tags</code></p></blockquote></li><li>运行容器:<blockquote><p><code>$ docker run -itd --name redis-test -p 6379:6379 redis</code></p></blockquote></li><li>通过<code>redis-cli</code>连接测试使用<code>redis</code>服务<blockquote><p><code>$ docker exec -it redis-test /bin/bash</code></p></blockquote></li></ul><hr><ul><li><p>PHP<a href="https://hub.docker.com/_/php?tab=tags" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com/_/php?tab=tags</code></p></blockquote></li><li><p>Python<a href="https://hub.docker.com/_/python?tab=tags" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com/_/python?tab=tags</code></p></blockquote></li><li><p>redis.conf<a href="https://github.com/antirez/redis/blob/unstable/redis.conf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/antirez/redis/blob/unstable/redis.conf</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Machine/Swarm-1.1</title>
    <url>/2020/02/09/Docker-Machine-1-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="docker-machine-基本命令"><a href="#docker-machine-基本命令" class="headerlink" title="docker machine-基本命令"></a>docker machine-基本命令</h3><ul><li><p>虚拟机与容器的区别:虚拟机内可以定义容器</p></li><li><p>列出已有虚拟机</p><blockquote><p><code>docker-machine ls</code></p></blockquote></li><li><p>创建虚拟机</p><blockquote><p><code>docker-machine create --driver [virtualbox] [test]</code><br>参数–driver用于指定虚拟机驱动类型,这里是virtualbox</p></blockquote></li><li><p>虚拟机驱动一览<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/drivers/</code></p></blockquote></li><li><p>查看虚拟器的ip</p><blockquote><p><code>docker-machine ip [test]</code></p></blockquote></li></ul><hr><ul><li><p>管理命令</p><blockquote><p><code>docker-machine start/restart/stop test</code></p></blockquote></li><li><p>帮助与检阅命令</p><blockquote><p><code>version/help/info</code></p></blockquote></li><li><p>官方文档<a href="https://docs.docker.com/machine/reference/create/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/reference/create/</code></p></blockquote></li></ul><hr><p><strong>指令摘要</strong></p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">kill</td><td align="left">杀死指定主机</td></tr><tr><td align="left">rm</td><td align="left">删除指定主机</td></tr><tr><td align="left">ssh</td><td align="left">连接主机</td></tr><tr><td align="left">upgrade</td><td align="left">更新</td></tr><tr><td align="left">url</td><td align="left">获取监听url</td></tr><tr><td align="left">scp</td><td align="left">复制</td></tr><tr><td align="left">regenerate-certs</td><td align="left">刷新TLS</td></tr></tbody></table><hr><ul><li><p>工作节点(worker node)</p></li><li><p>管理节点(manager node)</p></li><li><p>在VMware里安装虚拟机的虚拟机驱动时需要</p></li><li><p>点开虚拟机设置里的处理器选项卡</p></li><li><p>勾选虚拟化引擎选项卡</p></li></ul><hr><h3 id="Docker-Swarm集群-基本命令"><a href="#Docker-Swarm集群-基本命令" class="headerlink" title="Docker Swarm集群-基本命令"></a>Docker Swarm集群-基本命令</h3><ul><li><p>创建管理节点(manager node)</p><blockquote><p><code>docker-machine create -d virtualbox swarm-manager</code></p></blockquote></li><li><p>连入机器后执行</p><blockquote><p><code>docker swarm init --advertise-addr [创建机器时分配的 ip]</code></p></blockquote></li><li><p>然后拷贝输出指令</p></li><li><p>创建工作节点(worker node)</p></li><li><p>进入工作节点运行拷贝的指令将其设置为工作节点</p></li></ul><hr><ul><li><p>随机部署服务到集群中</p></li><li><p><code>alpine</code>是操作系统</p><blockquote><p><code>docker service create --replicas 1 --name 服务名 alpine ping docker.com</code></p></blockquote></li><li><p>查看部署情况</p><blockquote><p><code>docker service ps [服务名]</code></p></blockquote></li><li><p>查看具体信息</p><blockquote><p><code>docker service inspect --pretty [服务名]</code></p></blockquote></li><li><p>扩展服务到多节点(两个)</p><blockquote><p><code>docker service scale [服务名=2]</code></p></blockquote></li><li><p>删除服务</p><blockquote><p><code>docker service rm [服务名]</code></p></blockquote></li><li><p>查看所有节点</p><blockquote><p><code>docker node ls</code></p></blockquote></li><li><p>关闭服务节点</p><blockquote><p><code>docker node update --availability drain swarm-worker1</code></p></blockquote></li><li><p>开启服务节点</p><blockquote><p><code>docker node update --availability active swarm-worker1</code></p></blockquote></li><li><p><code>Active/Drain</code>分别代表开启与关闭</p></li></ul><hr><p><strong>滚动升级</strong></p><ul><li><p>前提是已存在指定服务</p></li><li><p>创建服务</p><blockquote><p><code>docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</code></p></blockquote></li><li><p>滚动更新</p><blockquote><p><code>docker service update --image [服务名:版本号] [指定已有的服务镜像]</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Swarm-集群</title>
    <url>/2020/02/09/Docker-Swarm-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h3><p><strong>概述:</strong></p><ul><li><p><code>Docker Swarm</code>是Docker的集群管理工具</p></li><li><p>它将<code>Docker主机池</code>转变为单个虚拟Docker主机</p></li><li><p><code>Docker Swarm</code>提供了标准的<code>Docker API</code></p></li><li><p>目的是使所有任何已经与Docker守护程序通信的工具都可以使用Swarm轻松地扩展到多个主机</p></li><li><p>支持的工具包括但不限于以下各项：</p></li><li><p>Dokku</p></li><li><p>Docker Compose</p></li><li><p>Docker Machine</p></li><li><p>Jenkins</p></li></ul><p><strong>原理概述:</strong></p><ul><li><code>swarm集群</code>由管理节点(manager)和工作节点(work node)构成</li><li><code>swarm mananger</code>:负责整个集群的管理工作包括集群配置,服务管理等所有跟集群有关的工作</li><li><code>work node</code>:即为<code>available node</code>,主要负责运行相应的服务来执行任务(task)</li><li>逻辑简述</li><li>管理节点(swarm manager)内存储着若干个服务(service)的副本(replicas)文件</li><li>工作节点(available/worker node)内存储这服务的标识与服务的镜像文件(container)</li><li>管理节点将所有的服务副本都分配到工作节点内，并管理与控制工作节点内的任务执行<blockquote><p>[swarm manager[service replicas]]-&gt;[available node[task[container(service:latest)]]]<br>swarm manager-&gt;available node-1/available node-2/available node-3/available node-N</p></blockquote></li></ul><hr><p><strong>应用</strong></p><ul><li><p>以<code>Docker Machine</code>与<code>virtualbox</code>进行实践，需要先确保主机已安装<code>virtualbox</code></p></li><li><p>创建docker机器:</p><blockquote><p><code>$ docker-machine create -d virtualbox swarm-manager</code></p></blockquote></li></ul><hr><ul><li><p>创建管理节点(manager node)</p></li><li><p>初始化<code>swarm</code>集群，进行初始化的这台机器，就是集群的管理节点</p><blockquote><p><code>$ docker-machine ssh swarm-manager</code><br><code>$ docker swarm init --advertise-addr 192.168.99.101</code><br><code>--advertise-addr</code>后的IP为创建机器时分配的ip</p></blockquote></li><li><p>当为机器分配IP之后，命令行会输出向集群内添加工作节点的指令(连接令牌)</p><blockquote><p><code>To add a worker to this swarm，runthe following command</code><br><code>docker swarm join --token [...]</code></p></blockquote></li></ul><hr><ul><li>创建工作节点(worker node)</li><li>复制上面输出的指令(会被自动截断)<blockquote><p><code>$ docker swarm join --token [...]</code><br>输出<code>The node joined a swarm as a worker</code></p></blockquote></li></ul><hr><ul><li>查看集群信息<blockquote><p><code>docker info</code><br>输出内容中<code>Swarm active</code>内的<code>managers</code>与<code>node</code>即为节点信息</p></blockquote></li></ul><hr><ul><li><p>部署服务器到集群中</p></li><li><p>跟集群管理有关的任何操作，都是在管理节点上操作的</p></li><li><p>随机指派任一工作节点，并于工作节点上创建任意的一个服务</p><blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name [service name] alpine ping docker.com</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li><li><p>查看<code>service</code>部署的具体信息:</p><blockquote><p><code>docker@swarm-manager:~$ docker service inspect --pretty [service name]</code></p></blockquote></li></ul><hr><ul><li><p>扩展集群服务</p></li><li><p>将service服务扩展到若干个节点</p><blockquote><p><code>docker@swarm-manager:~$ docker service scale [service name]=[节点数]</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>删除服务<blockquote><p><code>docker@swarm-manager:~$ docker service rm [service name]</code></p></blockquote></li><li>查看服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>滚动升级服务</li><li>将redis旧版本通过滚动升级至更高版本</li><li>创建一个3.0.6版本的redis<blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</code></p></blockquote></li><li>滚动升级redis<blockquote><p><code>docker@swarm-manager:~$ docker service update --image redis:3.0.7 redis</code></p></blockquote></li><li>查看redis服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps redis</code></p></blockquote></li></ul><hr><ul><li><p>停止某个节点接收新的任务</p></li><li><p>查看所有的节点：</p><blockquote><p><code>docker@swarm-manager:~$ docker node ls</code></p></blockquote></li><li><p>默认所有的节点都是<code>Active</code>, 可以接收新的任务分配</p></li><li><p>停止节点<code>swarm-worker1</code>:</p><blockquote><p><code>docker node update --availability drain swarm-worker1</code></p></blockquote></li><li><p>此时<code>swarm-worker1</code>状态变为<code>Drain</code></p></li><li><p>不会影响到集群的服务，只是<code>swarm-worker1</code>节点不再接收新的任务</p></li><li><p>会使集群的负载能力有所下降</p></li><li><p>重新激活节点指令:</p><blockquote><p><code>docker@swarm-manager:~$ docker node update --availability active swarm-worker1</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><ul><li><p>虚拟机驱动<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/drivers/</code></p></blockquote></li><li><p>官方文档<a href="https://docs.docker.com/machine/reference/create/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/reference/create/</code></p></blockquote></li></ul><hr><p><strong>其他资源</strong></p><ul><li><p>Docker官方主页<a href="https://www.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.docker.com</code></p></blockquote></li><li><p>Docker官方博客<a href="https://blog.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.docker.com/</code></p></blockquote></li><li><p>Docker官方文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/</code></p></blockquote></li><li><p>Docker Store<a href="https://store.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://store.docker.com</code></p></blockquote></li><li><p>Docker Cloud<a href="https://cloud.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://cloud.docker.com</code></p></blockquote></li><li><p>Docker Hub<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com</code></p></blockquote></li><li><p>Docker的源代码仓库<a href="https://github.com/moby/moby" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/moby/moby</code></p></blockquote></li><li><p>Docker发布版本历史<a href="https://docs.docker.com/release-notes/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/release-notes/</code></p></blockquote></li><li><p>Docker常见问题<a href="https://docs.docker.com/engine/faq/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/engine/faq/</code></p></blockquote></li><li><p>Docker远端应用 API<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/develop/sdk/</code></p></blockquote></li></ul><hr><p><strong>Docker国内镜像源</strong></p><ul><li><p>阿里云<a href="https://help.aliyun.com/document_detail/60750.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://help.aliyun.com/document_detail/60750.html</code></p></blockquote></li><li><p>网易云加速器</p><blockquote><p><code>http://hub-mirror.c.163.com</code></p></blockquote></li><li><p>中国官方加速器</p><blockquote><p><code>https://registry.docker-cn.com</code></p></blockquote></li><li><p>ustc的镜像</p><blockquote><p><code>https://docker.mirrors.ustc.edu.cn</code></p></blockquote></li><li><p>daocloud</p><blockquote><p><code>https://www.daocloud.io/mirror#accelerator-doc</code>(注册后使用)</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-1.1</title>
    <url>/2020/02/09/Docker-1-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul><li><p>查看已有镜像</p><blockquote><p><code>docker images</code></p></blockquote></li><li><p>参数:仓库源/标签/ID/创建时间/空间</p><blockquote><p><code>debian tag [镜像ID]</code> # 添加标签</p></blockquote></li><li><p>查看仓库内所有镜像文件</p><blockquote><p><code>docker search debian</code></p></blockquote></li><li><p>拉取仓库内默认版本的debian镜像<code>(debian:latest)</code></p><blockquote><p><code>docker pull debian</code></p></blockquote></li><li><p>查看所有已创建容器</p><blockquote><p><code>docker ps -a</code></p></blockquote></li><li><p>用容器启动所选镜像</p><blockquote><p><code>docker run -it --name [自定义命名] debian /bin/bash</code></p></blockquote></li></ul><hr><ul><li>启动，停止，重启所选容器<blockquote><p><code>docker start/stop/restart [容器ID]</code><br>参数:<code>·-i交互式操作</code>，<code>-t终端</code>，<code>-d后台运行</code></p></blockquote></li></ul><hr><ul><li>删除操作<blockquote><p><code>docker rmi debian</code>删除镜像<br><code>docker rm -f</code>删除容器<br><code>docker container prune</code>删除所有停止的容器</p></blockquote></li><li>容器必须停止才能进行删除</li></ul><hr><ul><li>进入后台后使用<code>docker attach</code>或<code>docker exec [容器ID]</code>进入该容器</li><li>前者暂时性，后者永久性</li><li>重新进入容器时还必须加入原来设置的启动参数</li><li>比如<code>/bin/bash和-it</code></li></ul><hr><ul><li><p>设置[service]端口映射与绑定IP</p><blockquote><p><code>docker run -p [可选的IP绑定]:[映射端口]:[原端口]/(udp/tcp) [镜像名] [启动脚本]</code><br>参数:<code>-P</code>是随机映射，<code>-p</code>是指定映射</p></blockquote></li><li><p>查看端口绑定情况</p><blockquote><p><code>docker port [服务名]</code></p></blockquote></li></ul><hr><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><ul><li><p>父子关系这里都称为上下层级关系，与阶级关系不同</p></li><li><p>上级容器可以看到下级容器的关系</p></li><li><p>建立容器网络</p><blockquote><p><code>docker network create -d bridge/overlay(网络类型) [网络命名]</code>overlay<code>应用于</code>swarm`</p></blockquote></li><li><p>后台运行一个命名为<code>test1</code>的容器并把它并入<code>test-net</code>内，并开启交互式终端系统</p><blockquote><p><code>docker run -itd --name test1 --network test-net debian /bin/bash</code></p></blockquote></li><li><p>任何加入此网络的容器都会达成互联的状态</p></li></ul><hr><ul><li><p>设定所有容器域名和DNS</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">$ vim <span class="meta-keyword">/etc/</span>docker/daemon.json</span><br><span class="line">&#123;<span class="string">"dns"</span> : [<span class="string">"111.111.111.111"</span>,<span class="string">"1.1.1.1"</span>]&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看是否生效</p><blockquote><p><code>docker run -it rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>指定容器设置域名和DNS服务器</p><blockquote><p><code>docker run -it --rm _hostname=HOSTNAME --dns=IP_ADDRESS --dns-search=DOMAIN(搜索域) debian</code></p></blockquote></li><li><p>没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></li></ul><hr><ul><li><p>登陆<code>docker hub</code></p><blockquote><p><code>docker login</code></p></blockquote></li><li><p>退出<code>docker hub</code></p><blockquote><p><code>docker logout</code></p></blockquote></li><li><p>上传镜像</p><blockquote><p><code>docker tag 本地镜像名 username/远端镜像名</code></p></blockquote></li></ul><hr><ul><li><p>随笔</p><blockquote><p><code>Docker Engine</code> 引擎<br><code>REST API</code> 通用接口<br><code>Docker daemon</code> 守护进程</p></blockquote></li><li><p>自用简易指令集</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Machine</title>
    <url>/2020/02/08/Docker-Machine/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h3><p><strong>概述:</strong></p><ul><li>可以实现在虚拟主机上安装Docker</li><li>并且可以使用<code>docker-machine</code>命令来管理主机</li><li><code>Docker Machine</code>管理的虚拟主机可以是机上的，也可以是云供应商的</li><li>使用<code>docker-machine</code>命令，可以用于启动，检查，停止和重新启动托管主机，也可以升级Docker客户端和守护程序</li><li>以及配置Docker客户端与本地主机进行通信</li><li>用于实现使用本地主机便可以操控远端的镜像容器集群</li></ul><p><strong>逻辑简述:</strong><br>[Client docker-machine[Client docker CLI[REST APT]]]-docker-machine create-&gt;[REST API[Server docker daemon]]</p><hr><p><strong>基于Linux安装Docker Machine</strong></p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>base=<span class="symbol">https:</span>/<span class="regexp">/github.com/docker</span><span class="regexp">/machine/releases</span><span class="regexp">/download/v</span>0.<span class="number">16.0</span> &amp;&amp;</span><br><span class="line">  curl -L <span class="variable">$base</span>/docker-machine-<span class="variable">$(</span>uname -s)-<span class="variable">$(</span>uname -m) &gt;<span class="regexp">/tmp/docker</span>-machine &amp;&amp;</span><br><span class="line">  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;</span><br><span class="line">  chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure><ul><li>查看版本以验证是否安装成功<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.16</span><span class="number">.0</span>, build <span class="number">9371605</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>对于machine version的使用</strong></p><ol><li><p>列出可用的机器</p><blockquote><p><code>$ docker-machine ls</code></p></blockquote></li><li><p>创建机器</p></li></ol><ul><li>创建一个名为serow的机器<blockquote><p><code>$ docker-machine create --driver virtualbox serow</code></p></blockquote></li><li>参数<code>--driver</code>用于指定用来创建机器的驱动类型，这里是<code>virtualbox</code></li></ul><ol start="3"><li><p>查看机器的 ip</p><blockquote><p><code>$ docker-machine ip serow</code></p></blockquote></li><li><p>停止机器</p><blockquote><p><code>$ docker-machine stop serow</code></p></blockquote></li><li><p>启动机器*</p><blockquote><p><code>$ docker-machine start serow</code></p></blockquote></li><li><p>进入机器*</p><blockquote><p><code>$ docker-machine ssh serow</code></p></blockquote></li></ol><hr><p><strong>docker-machine 命令参数明细</strong></p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">docker-machine active</td><td align="left">用于查看当前激活状态的Docker主机</td></tr><tr><td align="left">config</td><td align="left">查看当前激活状态Docker主机的连接信息</td></tr><tr><td align="left">creat</td><td align="left">创建Docker主机</td></tr><tr><td align="left">env</td><td align="left">显示连接到某个主机需要的环境变量</td></tr><tr><td align="left">inspect</td><td align="left">以<code>json</code>格式输出指定Docker的详细信息</td></tr><tr><td align="left">ip</td><td align="left">获取指定 Docker 主机的地址</td></tr><tr><td align="left">kill</td><td align="left">直接杀死指定的 Docker主机</td></tr><tr><td align="left">ls</td><td align="left">列出所有的管理主机</td></tr><tr><td align="left">provision</td><td align="left">重新配置指定主机</td></tr><tr><td align="left">regenerate-certs</td><td align="left">为某个主机重新生成TLS信息</td></tr><tr><td align="left">restart</td><td align="left">重启指定的主机</td></tr><tr><td align="left">rm</td><td align="left">删除某台Docker主机，对应的虚拟机也会被删除</td></tr><tr><td align="left">ssh</td><td align="left">通过SSH连接到主机上，执行命令</td></tr><tr><td align="left">scp</td><td align="left">在Docker主机之间以及Docker主机和本地主机之间通过<code>scp</code>远程复制数据</td></tr><tr><td align="left">mount</td><td align="left">使用SSHFS从计算机装载或卸载目录</td></tr><tr><td align="left">start</td><td align="left">启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td></tr><tr><td align="left">status</td><td align="left">获取指定Docker主机的状态(包括:<code>Running</code>,<code>Paused</code>,<code>Saved</code>,<code>Stopped</code>,<code>Stopping</code>,<code>Starting</code>,<code>Error</code>)等</td></tr><tr><td align="left">stop</td><td align="left">停止一个指定的Docker主机</td></tr><tr><td align="left">upgrade</td><td align="left">将一个指定主机的Docker版本更新为最新</td></tr><tr><td align="left">url</td><td align="left">获取指定Docker主机的监听URL</td></tr><tr><td align="left">version</td><td align="left">显示 Docker Machine 的版本或者主机Docker版本</td></tr><tr><td align="left">help</td><td align="left">显示帮助信息</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML-1</title>
    <url>/2020/02/08/YAML-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="YAML-基本语法与简述"><a href="#YAML-基本语法与简述" class="headerlink" title="YAML 基本语法与简述"></a>YAML 基本语法与简述</h3><p><strong>概述:</strong></p><ul><li>YAML是”YAML Ain’t a Markup Language”(YAML 不是一种标记语言)的递归缩写</li><li>在开发的这种语言时，YAML的意思其实是:”Yet Another Markup Language”(仍是一种标记语言)</li><li>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态</li><li>它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲</li><li>YAML的配置文件后缀为<code>.yml</code></li></ul><hr><p><strong>YAML的基本语法规则</strong></p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用<code>tab</code>，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li><code>&#39;#&#39;</code>表示注释</li></ul><hr><p><strong>YAML的数据类型</strong></p><ul><li>YAML支持以下几种数据类型：</li><li>对象:键值对的集合，又称为映射(mapping)/哈希(hashes) /字典(dictionary)</li><li>数组:一组按次序排列的值，又称为序列(sequence)/列表(list)</li><li>纯量(scalars):单个的、不可再分的值</li></ul><hr><p><strong>YAML对象</strong></p><ul><li><p>对象键值对使用冒号结构表示<code>key: value</code>，冒号后面要加一个空格</p></li><li><p>也可以使用<code>key:{key1: value1, key2: value2, ...}</code></p></li><li><p>还可以使用缩进表示层级关系:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">key:</span> </span><br><span class="line">    child-<span class="string">key:</span> value</span><br><span class="line">    child-<span class="string">key2:</span> value2</span><br></pre></td></tr></table></figure></li><li><p>较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的<code>key</code>，配合一个冒号加一个空格代表一个<code>value</code>:</p><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">?  </span><br><span class="line"><span class="bullet">    - </span>complexkey1</span><br><span class="line"><span class="bullet">    - </span>complexkey2</span><br><span class="line">:</span><br><span class="line"><span class="bullet">    - </span>complexvalue1</span><br><span class="line"><span class="bullet">    - </span>complexvalue2</span><br></pre></td></tr></table></figure></li><li><p>意思即对象的属性是一个数组<code>[complexkey1,complexkey2]</code>，对应的值也是一个数组<code>[complexvalue1,complexvalue2]</code></p></li></ul><hr><p><strong>YAML数组</strong></p><ul><li>以<code>&#39;-&#39;</code>开头的行表示构成一个数组:<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>A</span><br><span class="line"><span class="bullet">- </span>B</span><br><span class="line"><span class="bullet">- </span>C</span><br></pre></td></tr></table></figure></li><li>YAML 支持多维数组，可以使用行内表示:<blockquote><p><code>key: [value1, value2, ...]</code></p></blockquote></li><li>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line"><span class="ruby"> - A</span></span><br><span class="line"><span class="ruby"> - B</span></span><br><span class="line"><span class="ruby"> - C</span></span><br></pre></td></tr></table></figure></li><li>一个相对复杂的例子:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">companies:</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">id:</span> <span class="number">1</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">company1</span></span><br><span class="line">        <span class="attr">price:</span> <span class="string">200W</span></span><br><span class="line">    <span class="bullet">-</span></span><br><span class="line">        <span class="attr">id:</span> <span class="number">2</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">company2</span></span><br><span class="line">        <span class="attr">price:</span> <span class="string">500W</span></span><br></pre></td></tr></table></figure></li><li>意思是<code>companies</code>属性是一个数组，每一个数组元素又是由<code>id</code>,<code>name</code>,<code>price</code>三个属性构成</li><li>数组也可以使用流式(flow)的方式表示:<blockquote><p><code>companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]</code></p></blockquote></li></ul><hr><p><strong>复合结构</strong></p><ul><li>数组和对象可以构成复合结构，例:<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">language</span><span class="variable">s:</span></span><br><span class="line">  - Ruby</span><br><span class="line">  - Perl</span><br><span class="line">  - Python </span><br><span class="line">website<span class="variable">s:</span></span><br><span class="line">  YAML: yaml.org </span><br><span class="line">  Ruby: <span class="keyword">ruby</span>-lang.org </span><br><span class="line">  Python: <span class="keyword">python</span>.org </span><br><span class="line">  Per<span class="variable">l:</span> use.<span class="keyword">perl</span>.org</span><br></pre></td></tr></table></figure></li><li>转换为 json 为：<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attribute">languages</span>: [ <span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span>],</span><br><span class="line">  <span class="attribute">websites</span>: &#123;</span><br><span class="line">    <span class="attribute">YAML</span>: <span class="string">'yaml.org'</span>,</span><br><span class="line">    <span class="attribute">Ruby</span>: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">    <span class="attribute">Python</span>: <span class="string">'python.org'</span>,</span><br><span class="line">    <span class="attribute">Perl</span>: <span class="string">'use.perl.org'</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>纯量</strong></p><ul><li><p>纯量是最基本的，不可再分的值，包括：</p></li><li><p>字符串</p></li><li><p>布尔值</p></li><li><p>整数</p></li><li><p>浮点数</p></li><li><p>Null</p></li><li><p>时间</p></li><li><p>日期</p></li><li><p>使用一个例子来快速了解纯量的基本使用：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="literal">TRUE</span>  <span class="comment">#true,True都可以</span></span><br><span class="line">    <span class="bullet">-</span> <span class="literal">FALSE</span>  <span class="comment">#false，False都可以</span></span><br><span class="line"><span class="attr">float:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">3.14</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">6.8523015e+5</span>  <span class="comment">#可以使用科学计数法</span></span><br><span class="line"><span class="attr">int:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">123</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">0b1010_0111_0100_1010_1110</span>    <span class="comment">#二进制表示</span></span><br><span class="line"><span class="attr">null:</span></span><br><span class="line">    <span class="attr">nodeName:</span> <span class="string">'node'</span></span><br><span class="line">    <span class="attr">parent:</span> <span class="string">~</span>  <span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">哈哈</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">'Hello world'</span>  <span class="comment">#可以使用双引号或者单引号包裹特殊字符</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">newline</span></span><br><span class="line">      <span class="string">newline2</span>    <span class="comment">#字符串可以拆成多行，每一行会被转化成一个空格</span></span><br><span class="line"><span class="attr">date:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="number">2018</span><span class="number">-02</span><span class="number">-17</span>    <span class="comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span><br><span class="line"><span class="attr">datetime:</span> </span><br><span class="line">    <span class="bullet">-</span>  <span class="number">2018</span><span class="number">-02</span><span class="string">-17T15:02:31+08:00</span>    <span class="comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>引用</strong></p><ul><li><code>&amp;</code>锚点和<code>*</code>别名，可以用来引用:<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure></li><li>相当于:<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">defaults:</span></span><br><span class="line"><span class="symbol">  adapter:</span>  postgres</span><br><span class="line"><span class="symbol">  host:</span>     localhost</span><br><span class="line"></span><br><span class="line"><span class="symbol">development:</span></span><br><span class="line"><span class="symbol">  database:</span> myapp_development</span><br><span class="line"><span class="symbol">  adapter:</span>  postgres</span><br><span class="line"><span class="symbol">  host:</span>     localhost</span><br><span class="line"></span><br><span class="line"><span class="symbol">test:</span></span><br><span class="line"><span class="symbol">  database:</span> myapp_test</span><br><span class="line"><span class="symbol">  adapter:</span>  postgres</span><br><span class="line"><span class="symbol">  host:</span>     localhost</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>&amp;</code>用来建立锚点(defaults)，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点</p></blockquote><ul><li><p>下面是另一个例子:</p><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="bullet">- </span>&amp;showell Steve </span><br><span class="line"><span class="bullet">- </span>Clark </span><br><span class="line"><span class="bullet">- </span>Brian </span><br><span class="line"><span class="bullet">- </span>Oren </span><br><span class="line"><span class="bullet">- </span><span class="strong">*showell</span></span><br></pre></td></tr></table></figure></li><li><p>转为<code>JavaScript</code>代码如下:</p><blockquote><p><code>[ &#39;Steve&#39;, &#39;Clark&#39;, &#39;Brian&#39;, &#39;Oren&#39;, &#39;Steve&#39; ]</code></p></blockquote></li></ul><hr><p><strong>参考资料:</strong></p><p>YMAL官方文档:<a href="https://yaml.org/" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/</code></p><p>YMAL1.2规范文档:<a href="https://yaml.org/spec/1.2/spec.html" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/spec/1.2/spec.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
  </entry>
  <entry>
    <title>Docker Compose-3</title>
    <url>/2020/02/08/Docker-Compose-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>接<a href="https://unit-serow.github.io/2020/02/08/Docker-Compose-2/">Docker Compose-2</a></li></ul><ol><li><strong>devices</strong></li></ol><ul><li>用于指定设备映射列表</li><li>实现语法:<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">devices:</span></span><br><span class="line">  - <span class="string">"/dev/ttyUSB0:/dev/ttyUSB0"</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li><strong>dns</strong></li></ol><ul><li>用于自定义 DNS 服务器，可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dns:</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">9.9</span><span class="number">.9</span><span class="number">.9</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="3"><li><strong>dns_search</strong></li></ol><ul><li>用于自定义 DNS 搜索域</li><li>可以是单个值或列表</li><li>实现语法:<figure class="highlight ldif"><table><tr><td class="code"><pre><span class="line"><span class="attribute">dns_search</span>: example.com</span><br><span class="line"></span><br><span class="line"><span class="attribute">dns_search:</span></span><br><span class="line"><span class="attribute">  - dc1.example.com</span></span><br><span class="line"><span class="attribute">  - dc2.example.com</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="4"><li><strong>entrypoint</strong></li></ol><ul><li>用于覆盖容器默认的<code>entrypoint</code></li><li>实现语法:<blockquote><p><code>entrypoint: /code/entrypoint.sh</code></p></blockquote></li><li>或以下的列表格式:<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    -<span class="ruby"> php</span></span><br><span class="line"><span class="ruby">    - -d</span></span><br><span class="line"><span class="ruby">    - zend_extension=<span class="regexp">/usr/local</span><span class="regexp">/lib/php</span><span class="regexp">/extensions/no</span>-debug-non-zts-<span class="number">20100525</span>/xdebug.so</span></span><br><span class="line"><span class="ruby">    - -d</span></span><br><span class="line"><span class="ruby">    - memory_limit=-<span class="number">1</span></span></span><br><span class="line"><span class="ruby">    - vendor/bin/phpunit</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="5"><li><strong>env_file</strong></li></ol><ul><li>用于从文件添加环境变量</li><li>可以是单个值或列表的多个值</li><li>实现语法:<blockquote><p><code>env_file: .env</code></p></blockquote></li><li>也可以是列表格式：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">env_file:</span><br><span class="line"><span class="bullet">  - </span>./common.env</span><br><span class="line"><span class="bullet">  - </span>./apps/web.env</span><br><span class="line"><span class="bullet">  - </span>/opt/secrets.env</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="6"><li><strong>environment</strong></li></ol><ul><li>用于添加环境变量</li><li>可以使用数组或字典，任何布尔值，布尔值需要用引号引起来，以确保<code>YML解析器</code>不会将其转换为<code>True</code>或<code>False</code></li><li>实现语法:<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">environment</span>:</span><br><span class="line">  <span class="attribute">RACK_ENV</span>: development</span><br><span class="line">  <span class="attribute">SHOW</span>: <span class="string">'true'</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="7"><li><strong>expose</strong></li></ol><ul><li>用于暴露端口，但不映射到宿主机，只被连接的服务访问</li><li>实现语法(仅可以指定内部端口为参数)：<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">expose:</span><br><span class="line"> -<span class="ruby"> <span class="string">"3000"</span></span></span><br><span class="line"><span class="ruby"> - <span class="string">"8000"</span></span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="8"><li><strong>extra_hosts</strong></li></ol><ul><li>用于添加主机名映射</li><li>类似<code>docker client --add-host</code></li><li>实现语法:<figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> -<span class="ruby"> <span class="string">"somehost:162.242.195.82"</span></span></span><br><span class="line"><span class="ruby"> - <span class="string">"otherhost:50.31.209.229"</span></span></span><br></pre></td></tr></table></figure></li><li>以上会在此服务的内部容器中<code>/etc/hosts</code>创建一个具有<code>ip地址</code>和主机名的映射关系:<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line"><span class="number">162.242.195.82</span>  somehost</span><br><span class="line"><span class="number">50.31.209.229</span>   otherhost</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="9"><li><strong>healthcheck</strong></li></ol><ul><li>用于检测 docker 服务是否健康运行</li><li>实现语法:<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">healthcheck:</span></span><br><span class="line"><span class="symbol">  test:</span> [<span class="string">"CMD"</span>, <span class="string">"curl"</span>, <span class="string">"-f"</span>, <span class="string">"http://localhost"</span>] <span class="meta"># 设置检测程序</span></span><br><span class="line"><span class="symbol">  interval:</span> <span class="number">1</span>m30s <span class="meta"># 设置检测间隔</span></span><br><span class="line"><span class="symbol">  timeout:</span> <span class="number">10</span>s <span class="meta"># 设置检测超时时间</span></span><br><span class="line"><span class="symbol">  retries:</span> <span class="number">3</span> <span class="meta"># 设置重试次数</span></span><br><span class="line"><span class="symbol">  start_period:</span> <span class="number">40</span>s <span class="meta"># 启动后，多少秒开始启动检测程序</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="10"><li><strong>image</strong></li></ol><ul><li>用于指定容器运行的镜像</li><li>以下格式都可以:<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">image</span>: redis</span><br><span class="line"><span class="attribute">image</span>: <span class="attribute">ubuntu</span>:<span class="number">14.04</span></span><br><span class="line"><span class="attribute">image</span>: tutum/influxdb</span><br><span class="line"><span class="attribute">image</span>: example-registry.<span class="attribute">com</span>:<span class="number">4000</span>/postgresql</span><br><span class="line"><span class="attribute">image</span>: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="11"><li><strong>logging</strong></li></ol><ul><li><p>服务的日志记录配置</p></li><li><p><code>driver:</code>用于指定服务容器的日志记录驱动程序，默认值为<code>json-file</code></p></li><li><p>可以有以下这三种选项</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">driver:</span> <span class="string">"json-file"</span></span><br><span class="line"><span class="symbol">driver:</span> <span class="string">"syslog"</span></span><br><span class="line"><span class="symbol">driver:</span> <span class="string">"none"</span></span><br></pre></td></tr></table></figure></li><li><p>仅在<code>json-file</code>驱动程序下，可以使用以下参数，限制日志得数量和大小</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-<span class="built_in">file</span></span><br><span class="line">  options:</span><br><span class="line">    <span class="built_in">max</span>-size: <span class="string">"200k"</span> <span class="comment"># 单个文件大小为200k</span></span><br><span class="line">    <span class="built_in">max</span>-<span class="built_in">file</span>: <span class="string">"10"</span> <span class="comment"># 最多10个文件</span></span><br></pre></td></tr></table></figure></li><li><p>当达到文件限制上限，会自动删除旧得文件</p></li><li><p><code>syslog</code>驱动程序下，可以使用<code>syslog-address</code>指定日志接收地址</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">logging</span>:</span><br><span class="line">  <span class="attribute">driver</span>: syslog</span><br><span class="line">  <span class="attribute">options</span>:</span><br><span class="line">    <span class="attribute">syslog-address</span>: <span class="string">"tcp://192.168.0.42:123"</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="12"><li><strong>network_mode</strong></li></ol><ul><li><p>用于设置网络模式</p></li><li><p>实现语法:</p><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">network_mode:</span> <span class="string">"bridge"</span></span><br><span class="line"><span class="symbol">network_mode:</span> <span class="string">"host"</span></span><br><span class="line"><span class="symbol">network_mode:</span> <span class="string">"none"</span></span><br><span class="line"><span class="symbol">network_mode:</span> <span class="string">"service:[service name]"</span></span><br><span class="line"><span class="symbol">network_mode:</span> <span class="string">"container:[container name/id]"</span></span><br></pre></td></tr></table></figure></li><li><p>networks</p><blockquote><p>配置容器连接的网络，引用顶级<code>networks</code>下的条目</p></blockquote><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="attr">some-network:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">alias1</span></span><br><span class="line">      <span class="attr">other-network:</span></span><br><span class="line">        <span class="attr">aliases:</span></span><br><span class="line">         <span class="bullet">-</span> <span class="string">alias2</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">    <span class="comment"># Use a custom driver</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">custom-driver-1</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br><span class="line">    <span class="comment"># Use a custom driver which takes special options</span></span><br><span class="line">    <span class="attr">driver:</span> <span class="string">custom-driver-2</span></span><br></pre></td></tr></table></figure></li><li><p><code>aliases:</code>同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务</p></li></ul><hr><ol start="13"><li><strong>restart</strong></li></ol><ul><li><p>使用示例:</p><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">restart</span>: "no"</span><br><span class="line"><span class="keyword">restart</span>: <span class="keyword">always</span></span><br><span class="line"><span class="keyword">restart</span>: <span class="keyword">on</span>-failure</span><br><span class="line"><span class="keyword">restart</span>: unless-stopped</span><br></pre></td></tr></table></figure></li><li><p>参数说明:</p><blockquote><p><code>no</code>:是默认的重启策略，在任何情况下都不会重启容器<br><code>always</code>:容器总是重新启动<br><code>on-failure</code>:在容器非正常退出时(退出状态非0)，才会重启容器<br><code>unless-stopped</code>:在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p></blockquote></li><li><p><code>swarm集群</code>模式下，必须改用<code>restart_policy</code></p></li></ul><hr><ol start="14"><li><strong>secrets</strong></li></ol><ul><li>用于存储敏感数据</li><li>例如密码：<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">"3.1"</span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">mysql:</span></span><br><span class="line"><span class="symbol">  image:</span> mysql</span><br><span class="line"><span class="symbol">  environment:</span></span><br><span class="line"><span class="symbol">    MYSQL_ROOT_PASSWORD_FILE:</span> <span class="meta-keyword">/run/</span>secrets/my_secret</span><br><span class="line"><span class="symbol">  secrets:</span></span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line"><span class="symbol">secrets:</span></span><br><span class="line"><span class="symbol">  my_secret:</span></span><br><span class="line"><span class="symbol">    file:</span> ./my_secret.txt</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="15"><li><strong>security_opt</strong></li></ol><ul><li>修改容器默认的<code>schema</code>标签</li><li>使用说明:<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - <span class="keyword">label</span><span class="bash">:user:USER   <span class="comment"># 设置容器的用户标签</span></span></span><br><span class="line">  - <span class="keyword">label</span><span class="bash">:role:ROLE   <span class="comment"># 设置容器的角色标签</span></span></span><br><span class="line">  - <span class="keyword">label</span><span class="bash">:<span class="built_in">type</span>:TYPE   <span class="comment"># 设置容器的安全策略标签</span></span></span><br><span class="line">  - <span class="keyword">label</span><span class="bash">:level:LEVEL  <span class="comment"># 设置容器的安全等级标签</span></span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="16"><li><strong>stop_grace_period</strong></li></ol><ul><li>指定在容器无法处理<code>SIGTERM</code>(或者任何<code>stop_signal</code>的信号)，等待多久后发送<code>SIGKILL</code>信号关闭容器</li><li>实现语法:<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">stop_grace_period: <span class="number">1</span>s # 等待 <span class="number">1</span> 秒</span><br><span class="line">stop_grace_period: <span class="number">1</span>m30s # 等待 <span class="number">1</span> 分 <span class="number">30</span> 秒</span><br></pre></td></tr></table></figure></li><li>默认的等待时间是 10 秒</li></ul><hr><ol start="17"><li><strong>stop_signal</strong></li></ol><ul><li>设置停止容器的替代信号</li><li>默认情况下使用<code>SIGTERM</code></li><li>以下示例，使用<code>SIGUSR1</code>替代信号<code>SIGTERM</code>来停止容器<blockquote><p><code>stop_signal: SIGUSR1</code></p></blockquote></li></ul><hr><ol start="18"><li><strong>sysctls</strong></li></ol><ul><li>设置容器中的内核参数，可以使用数组或字典格式</li><li>实现语法:<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net<span class="selector-class">.core</span><span class="selector-class">.somaxconn</span>: <span class="number">1024</span></span><br><span class="line">  net<span class="selector-class">.ipv4</span><span class="selector-class">.tcp_syncookies</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net<span class="selector-class">.core</span>.somaxconn=<span class="number">1024</span></span><br><span class="line">  - net<span class="selector-class">.ipv4</span>.tcp_syncookies=<span class="number">0</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="19"><li><strong>tmpfs</strong></li></ol><ul><li>在容器内安装一个临时文件系统</li><li>可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">tmpfs: /<span class="keyword">run</span></span><br><span class="line"></span><br><span class="line"><span class="bash">tmpfs:</span></span><br><span class="line">  - /<span class="keyword">run</span></span><br><span class="line"><span class="bash">  - /tmp</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="20"><li><strong>ulimits</strong></li></ol><ul><li>覆盖容器默认的<code>ulimit</code></li><li>实现语法:<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure></li></ul><hr><ol start="21"><li><strong>volumes</strong></li></ol><ul><li>将主机的数据卷或着文件挂载到容器里</li><li>实现语法:<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">version</span>: <span class="string">"3.7"</span></span><br><span class="line"><span class="attribute">services</span>:</span><br><span class="line">  <span class="attribute">db</span>:</span><br><span class="line">    <span class="attribute">image</span>: <span class="attribute">postgres</span>:latest</span><br><span class="line">    <span class="attribute">volumes</span>:</span><br><span class="line">      - <span class="string">"/localhost/postgres.sock:/var/run/postgres/postgres.sock"</span></span><br><span class="line">      - <span class="string">"/localhost/data:/var/lib/postgresql/data"</span></span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose-2</title>
    <url>/2020/02/08/Docker-Compose-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>为了通过使用compose，来让docker自动化配置程序与服务，必须编写YML文件(脚本)</li></ul><ol><li><strong>version</strong></li></ol><ul><li>指定本yml依从于compose哪个版本制定的</li></ul><ol start="2"><li><strong>build</strong></li></ol><ul><li>指定为构建镜像上下文路径</li><li>例如nginx服务，指定为从上下文路径./dir/Dockerfile 所构建的镜像</li><li>参数明细:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">context</td><td align="left">上下文路径</td></tr><tr><td align="left">dockerfile</td><td align="left">指定构建镜像的Dockerfile文件命</td></tr><tr><td align="left">args</td><td align="left">添加构建参数，这是只能在构建过程中访问的环境变量</td></tr><tr><td align="left">labels</td><td align="left">设置构建镜像的标签</td></tr><tr><td align="left">target</td><td align="left">多层构建，可以指定构建哪一层</td></tr></tbody></table><hr><ol start="3"><li><strong>cap_add，cap_drop</strong><br>添加或删除容器拥有的宿主机的内核功能<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">cap_add:</span></span><br><span class="line">  - ALL <span class="meta"># 开启全部权限</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">cap_drop:</span></span><br><span class="line">  - SYS_PTRACE <span class="meta"># 关闭 ptrace权限</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><strong>cgroup_parent</strong></li></ol><ul><li>为容器指定父<code>cgroup</code>组，意味着将继承该组的资源限制<blockquote><p><code>cgroup_parent: m-executor-abcd</code></p></blockquote></li></ul><ol start="5"><li><strong>command</strong></li></ol><ul><li>覆盖容器启动的默认命令<blockquote><p><code>cmmand: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</code></p></blockquote></li></ul><ol start="6"><li><strong>container_name</strong></li></ol><ul><li>指定自定义容器名称，而不是生成的默认名称<blockquote><p><code>container_name: my-web-container</code></p></blockquote></li></ul><hr><ol start="7"><li><strong>depends_on</strong></li></ol><ul><li>设置依赖关系</li></ul><blockquote><p><code>docker-compose up</code>:以依赖性顺序启动服务，在以下示例中，先启动<code>db</code>和<code>redis</code>，才会启动<code>web</code><br><code>docker-compose up SERVICE</code>:自动包含<code>SERVICE</code>的依赖项，在以下示例中，<code>docker-compose up web</code>还将创建并启动<code>db</code>和<code>redis</code><br><code>docker-compose stop</code>:按依赖关系顺序停止服务，在以下示例中，<code>web</code>在<code>db</code>和<code>redis</code>之前停止</p></blockquote><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  web:</span></span><br><span class="line"><span class="symbol">    build:</span> .</span><br><span class="line"><span class="symbol">    depends_on:</span></span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line"><span class="symbol">  redis:</span></span><br><span class="line"><span class="symbol">    image:</span> redis</span><br><span class="line"><span class="symbol">  db:</span></span><br><span class="line"><span class="symbol">    image:</span> postgres</span><br></pre></td></tr></table></figure><ul><li>此时的<code>web</code>服务不会等待<code>redis</code>和<code>db</code>完全启动之后才启动</li></ul><hr><ol start="8"><li><strong>deploy</strong></li></ol><ul><li>指定与服务的部署和运行有关的配置</li><li>只在 swarm 模式下才会有用<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"xxx"</span>  <span class="comment"># 服务版本</span></span><br><span class="line"><span class="attr">services:</span>  <span class="comment"># 服务配置</span></span><br><span class="line">  <span class="attr">redis:</span>  <span class="comment"># redis服务</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:alpine</span>  <span class="comment"># 指定容器运行的镜像</span></span><br><span class="line">    <span class="attr">deploy:</span>  <span class="comment"># 开始定义与该镜像有关的配置</span></span><br><span class="line">      <span class="string">mode：replicated</span>  <span class="comment"># 定义需要使用此参数配置具体运行的节点数量</span></span><br><span class="line">      <span class="attr">replicas:</span> <span class="number">6</span>  </span><br><span class="line">      <span class="attr">endpoint_mode:</span> <span class="string">dnsrr</span>  <span class="comment"># 访问集群服务的方式，这里是dns轮询(DNSRR)</span></span><br><span class="line">      <span class="attr">labels:</span>  <span class="comment"># 给服务设上标签</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">"This redis service label"</span></span><br><span class="line">      <span class="attr">resources:</span> <span class="comment">#配置服务器资源使用的限制，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用，从而避免占用资源过高出现异常</span></span><br><span class="line">        <span class="attr">limits:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">'0.50'</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">50M</span></span><br><span class="line">        <span class="attr">reservations:</span></span><br><span class="line">          <span class="attr">cpus:</span> <span class="string">'0.25'</span></span><br><span class="line">          <span class="attr">memory:</span> <span class="string">20M</span></span><br><span class="line">      <span class="attr">restart_policy:</span>  <span class="comment"># 配置如何在退出容器时重新启动容器</span></span><br><span class="line">        <span class="attr">condition:</span> <span class="string">on-failure</span></span><br><span class="line">        <span class="attr">delay:</span> <span class="string">5s</span></span><br><span class="line">        <span class="attr">max_attempts:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">window:</span> <span class="string">120s</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>可选参数一览与对上述参数解释:</strong></p><ul><li><code>endpoint_mode</code>:访问集群服务的方式<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">endpoint_mode</span>: vip</span><br><span class="line"># Docker 集群服务一个对外的虚拟<span class="built_in">ip</span>，所有的请求都会通过这个虚拟<span class="built_in">ip</span>到达集群服务内部的机器</span><br><span class="line"><span class="symbol">endpoint_mode</span>: dnsrr</span><br><span class="line"># DNS 轮询(DNSRR)，所有的请求会自动轮询获取到集群<span class="built_in">ip</span>列表中的一个<span class="built_in">ip</span>地址</span><br></pre></td></tr></table></figure></li><li><code>labels</code>:在服务上设置标签，可以用容器上的<code>labels</code>(跟<code>deploy</code>同级的配置)覆盖<code>deploy</code>下的<code>labels</code></li><li><code>mode</code>:指定服务提供的模式<blockquote><p><code>replicated</code>:复制服务，复制指定服务到集群的机器上<br><code>global</code>:全局服务，服务将部署至集群的每个节点</p></blockquote></li></ul><p><strong><code>replicated</code>与<code>global</code>的区别</strong></p><ul><li>逻辑简述:</li><li>所有的节点副本都处于本地主机的集群网络内</li><li>当选择<code>replicated</code>时，服务的副本只会被复制到所选节点的机器上</li><li>而选择<code>global</code>时，服务的副本会被复制到节点的每一个机器上，包括控制节点(manager node)</li><li>工作节点(worker node)，控制节点(manager node)</li></ul><hr><ol start="9"><li><strong><code>replicas: mode</code></strong></li></ol><ul><li>当此选项后的参数为<code>replicated</code>时，需要使用此参数配置具体运行的节点数量</li></ul><ol start="10"><li><strong><code>resources:</code></strong></li></ol><ul><li>用于配置服务器资源使用的限制，例如上例子，配置<code>redis</code>集群运行需要的<code>cpu</code>的百分比和内存的占用，避免占用资源过高出现异常</li></ul><hr><ol start="11"><li><strong><code>restart_policy:</code></strong></li></ol><ul><li>用于配置如何在退出容器时重新启动容器</li><li>参数明细<blockquote><p><code>condition</code>:可选<code>none</code>，<code>on-failure</code>或者<code>any</code>(默认值:<code>any</code>)<br><code>delay</code>:设置多久之后重启(默认值:0)<br><code>max_attempts</code>:尝试重新启动容器的次数，超出次数，则不再尝试(默认值:一直重试)<br><code>window</code>:设置容器重启超时时间(默认值:0)</p></blockquote></li></ul><hr><ol start="12"><li><strong><code>rollback_config</code></strong></li></ol><ul><li>用于配置在更新失败的情况下应如何回滚服务</li><li>参数明细:<blockquote><p><code>parallelism</code>:一次要回滚的容器数，如果设置为0，则所有容器将同时回滚<br><code>delay</code>:每个容器组回滚之间等待的时间(默认为0s)<br><code>failure_action</code>:如果回滚失败的处理方法(下一条所描述的内容)，其中一个<code>continue</code>或者<code>pause</code>(默认<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在回滚期间可以容忍的故障率(默认为0)<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认<code>stop-first</code>)</p></blockquote></li></ul><hr><ol start="13"><li><strong><code>update_config</code></strong></li></ol><ul><li><p>用于配置应如何更新服务，对于配置滚动更新很有用</p></li><li><p>参数明细:</p><blockquote><p><code>parallelism</code>:一次更新的容器数<br><code>delay</code>:在更新一组容器之间等待的时间<br><code>failure_action</code>:如果更新失败的解决办法依旧是下一条所描述的内容，其中一个<code>continue</code>，<code>rollback</code>或者<code>pause</code>(默认:<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在更新过程中可以容忍的故障率<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认stop-first)</p></blockquote></li><li><p>有些低版本的服务可能不支持<code>docker compose</code>所提供的服务</p></li><li><p>还有一半，放在下一篇写</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Compose-1</title>
    <url>/2020/02/07/Docker-Compose-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p><strong>概述:</strong></p><ul><li>Compose是用于定义和运行多容器Docker应用程序的工具</li><li>通过Compose，可以使用YML文件来配置应用程序需要的所有服务</li><li>最后通过使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</li><li><a href="https://yaml.org/" target="_blank" rel="noopener">YAML</a>官方文档</li></ul><hr><p><strong>安装 Compose</strong></p><ul><li><p>Github地址:<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/docker/compose/releases</code></p></blockquote></li><li><p>下载源码包(二进制文件)</p></li><li><p>Docker Compose当前的稳定版本：</p><blockquote><p><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>其中的1.25.4为版本号，可用于指定版本</p></li><li><p>提权至可执行文件</p><blockquote><p><code>$ sudo chmod +x /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>设置环境变量的软链接</p><blockquote><p><code>$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></p></blockquote></li><li><p>查看版本，以测试是否安装成功</p><blockquote><p><code>$ docker-compose --version</code></p></blockquote></li><li><p>对于Alpine/Linux发行版，需要安装依赖包:<code>py-pip</code>，<code>python-dev</code>，<code>libffi-dev</code>，<code>openssl-dev</code>，<code>gcc</code>，<code>libc-dev</code>，以及<code>make</code></p></li></ul><hr><p><strong>使用</strong></p><ul><li>对Compose进行使用大概可分为三个步骤:<blockquote><p>使用Dockerfile定义应用程序的环境<br>使用<code>docker-compose.yml</code>文件定义构成应用程序的服务，使其可以在隔离环境中一起运行<br>最后，执行<code>docker-compose up</code>命令来启动并运行整个应用程序</p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Dockefile-1</title>
    <url>/2020/02/07/Docker-Dockefile-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><strong>概述:</strong></p><ul><li>Dockerfile是用于构建镜像的文本文件</li><li>文本内容包含构建镜像所需的指令和说明</li></ul><p><strong>关于上下文的概念:</strong></p><ul><li>上下文路径，是指Docker在构建镜像时如果需要使用到本机内的文件(比如复制)，<code>docker build</code>命令得知所指定的路径后，会将该路径下的所有内容打包</li><li>Docker的运行模式是C/S，主机为C，Docker引擎是S</li><li>实际的构建过程是在Docker引擎内完成的，所以此时无法调用到本机内的文件，此时就需要人为的把本机指定目录下的所有文件打包，并提供给Docker引擎进行调用</li><li>如果未说明最后一个参数(未指定上下文所在路径)，那么默认上下文路径就是Dockerfile所在的目录下</li><li>上下文路径下所有的文件都会打包给Docker引擎，如果无用文件过多的话会造成执行过程缓慢</li></ul><hr><p><strong>Dockerfile内的基本指令</strong></p><ol><li><strong>FROM</strong></li></ol><ul><li>定制的镜像都是基于FROM的镜像，在选择完要定义的基础镜像之后，后续的操作都是基于该基础镜像的</li><li>格式:<blockquote><p><code>FROM &lt;所选基础镜像名&gt;</code></p></blockquote></li></ul><hr><ol start="2"><li><strong>RUN</strong></li></ol><ul><li>用于执行后面跟着的命令行命令，有两种格式<blockquote><p>Shell格式: RUN [命令行命令]<br>Exec格式: RUN [“可执行文件”, “参数一”, “参数二”]</p></blockquote></li><li>Dockefile每次执行指令都会在docker上新建一层，多余的层会造成镜像膨胀</li><li>可以用&amp;&amp;符号来连接命令，从而不进行指令的线性执行，目的就是让所有的指令都集成到一层内<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">RUN</span> <span class="string">xxx \</span></span><br><span class="line">   <span class="meta">&amp;&amp;</span> <span class="string">xxx \</span></span><br><span class="line">   <span class="meta">&amp;&amp;</span> <span class="string">xxx</span></span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>CMD</strong></li></ol><ul><li>类似于<code>RUN</code>指令，用于运行程序</li><li>二者的区别在于其运行的时间点不同:<blockquote><p><code>CMD</code>在<code>docker run</code>时运行<br><code>RUN</code>是在<code>docker build</code>时运行</p></blockquote></li><li>作用:<blockquote><p>为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束<br><code>CMD</code>指令指定的程序可被<code>docker run</code>命令行参数中指定要运行的程序所覆盖</p></blockquote></li><li>格式:<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="bash"> &lt;shell 命令&gt; </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"&lt;可执行文件或命令&gt;"</span>,<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...] </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"&lt;param1&gt;"</span>,<span class="string">"&lt;param2&gt;"</span>,...]</span></span><br></pre></td></tr></table></figure><blockquote><p>第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是<code>.sh</code>，所以可以直接使用第二种格式<br><code>最后一种写法是为</code>ENTRYPOINT<code>指令指定的程序提供默认参数</code></p></blockquote></li></ul><ol start="4"><li><strong>ENTRYPOINT</strong></li></ol><ul><li><p>类似于<code>CMD</code>指令，但其不会被<code>docker run</code>的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>但如果运行<code>docker run</code>时使用了<code>--entrypoint</code>选项，此选项的参数可当作要运行的程序覆盖<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>特点就是在执行<code>docker run</code>的时候可以指定<code>ENTRYPOINT</code>运行所需的参数</p></li><li><p>但如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效</p></li><li><p>格式:</p><blockquote><p><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></p></blockquote></li><li><p>还可以搭配<code>CMD</code>命令使用:一般是变参才会使用<code>CMD</code>，这里的<code>CMD</code>等于是在给<code>ENTRYPOINT</code>传参</p></li><li><p>这里假设已有了某镜像</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> 某镜像</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"&lt;某镜像&gt;"</span>, <span class="string">"-c"</span>] <span class="comment">#定参</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"&lt;/执行脚本所在文件目录&gt;"</span>] <span class="comment">#变参</span></span></span><br></pre></td></tr></table></figure></li><li><p>不传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt;</code></p></blockquote></li><li><p>此时容器内会默认(等于)运行以下命令，启动主进程</p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>容器内会默认(等于)运行以下命令，启动主进程<code>(/执行脚本所在文件目录:假设容器内已有此文件)</code></p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>简述</p><blockquote><p>指定了参数以后可以选择以传参或不传参的模式启动<br>不用传参就是直接启动所键入命令，用传参就是使用已指定的参数</p></blockquote></li></ul><hr><ol start="5"><li><strong>COPY</strong></li></ol><ul><li>用于复制的指令，可以从上下文目录复制文件或者目录到容器内的指定路径</li><li>使用格式:<blockquote><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></blockquote></li><li>参数说明:<blockquote><p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>为可选参数，可以让用户改变复制到容器内文件的拥有者和属组<br><code>&lt;源路径&gt;</code>用于表示源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足Go的<code>filepath.Match</code>规则<br><code>&lt;目标路径&gt;</code>用于在容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p></blockquote></li></ul><ol start="6"><li><strong>ADD</strong></li></ol><ul><li>ADD和COPY的使用格式一致</li><li>同样需求下，官方推荐使用COPY</li><li>ADD的优缺点:<blockquote><p>ADD的优点:在执行<code>&lt;源文件&gt;</code>为<code>tar</code>压缩文件的话，压缩格式为<code>gzip</code>，<code>bzip2</code>以及<code>xz</code>的情况下，会自动复制并解压到<code>&lt;目标路径&gt;</code><br>ADD的缺点:在不解压的前提下，无法复制<code>tar</code>压缩文件，会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</p></blockquote></li><li>具体是否使用，可以根据所处情况是否需要自动解压来决定</li></ul><hr><ol start="7"><li><strong>ENV</strong></li></ol><ul><li><p>用于设置与定义环境变量，定义之后可以直接使用环境变量</p></li><li><p>使用格式:</p><blockquote><p><code>ENV &lt;key&gt; &lt;value&gt;</code><br><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p></blockquote></li><li><p>以下示例设置<code>NODE_VERSION = 7.2.0</code>，在后续的指令中可以直接通过<code>$NODE_VERSION</code>进行引用</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> NODE_VERSION <span class="number">7.2</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/node-v<span class="variable">$NODE_VERSION</span>-linux-x64.tar.xz"</span> \</span></span><br><span class="line"><span class="bash">  &amp;&amp; curl -SLO <span class="string">"https://nodejs.org/dist/v<span class="variable">$NODE_VERSION</span>/SHASUMS256.txt.asc"</span></span></span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>ARG</strong></li></ol><ul><li>构建参数，与<code>ENV</code>作用一致，不过作用域不一样，<code>ARG</code>设置的环境变量仅对<code>Dockerfile</code>内有效，也就是说只有<code>docker build</code>的过程中有效，构建好的镜像内不存在此环境变量</li><li>构建命令<code>docker build</code>中可以用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖</li><li>使用格式：<blockquote><p><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p></blockquote></li></ul><hr><ol start="9"><li><strong>VOLUME</strong></li></ol><ul><li>定义匿名数据卷</li><li>在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</li><li>可以避免重要的数据因容器重启而丢失</li><li>还可以避免容器不断变大</li><li>使用格式:<blockquote><p><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code><br><code>VOLUME &lt;路径&gt;</code></p></blockquote></li><li>在启动容器<code>docker run</code>的时候，可以使用参数<code>-v</code>修改挂载点</li></ul><hr><ol start="10"><li><strong>EXPOSE</strong></li></ol><ul><li>用于声明端口</li><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li><li>在运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口</li><li>使用格式:<blockquote><p><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></blockquote></li></ul><hr><ol start="11"><li><strong>WORKDIR</strong></li></ol><ul><li>用于指定工作目录</li><li>用<code>WORKDIR</code>指定的工作目录，会在构建镜像的每一层中都存在(<code>WORKDIR</code>指定的工作目录，必须是提前创建好的)</li><li>在使用<code>docker build</code>构建镜像过程中的，每一个<code>RUN</code>命令都是新建的一层，只有通过<code>WORKDIR</code>创建的目录才会一直存在</li><li>使用格式:<blockquote><p><code>WORKDIR &lt;工作目录路径&gt;</code></p></blockquote></li></ul><ol start="12"><li><strong>USER</strong></li></ol><ul><li>用于指定执行后续命令的用户和用户组，用于切换后续命令执行的用户(用户和用户组必须提前已经存在)</li><li>使用格式:<blockquote><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p></blockquote></li></ul><hr><ol start="13"><li><strong>HEALTHCHECK</strong></li></ol><ul><li>用于指定某个程序或者指令来监控Docker容器服务的运行状态</li><li>使用格式:<blockquote><p><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令<br><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code> : 这个<code>CMD</code>后面跟随的命令使用，可以参考<code>CMD</code>的用法</p></blockquote></li></ul><hr><ol start="14"><li><strong>ONBUILD</strong></li></ol><ul><li>用于延迟构建命令的执行</li><li>简述:<blockquote><p>在<code>Dockerfile</code>里用<code>ONBUILD</code>指定的命令，在本次构建镜像的过程中不会执行(假设镜像为test-build)<br>当有新的<code>Dockerfile</code>使用了之前构建的镜像<code>FROM test-build</code>，这是执行新镜像的<code>Dockerfile</code>构建时候，<code>会执行 test-build</code>的<code>Dockerfile</code>里的<code>ONBUILD</code>指定的命令</p></blockquote></li><li>使用格式:<blockquote><p><code>ONBUILD &lt;其它指令&gt;</code></p></blockquote></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-4</title>
    <url>/2020/02/06/Docker-4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Docker-镜像，网络，连接以及仓库的使用"><a href="#Docker-镜像，网络，连接以及仓库的使用" class="headerlink" title="Docker-镜像，网络，连接以及仓库的使用"></a>Docker-镜像，网络，连接以及仓库的使用</h3><p><strong>Docker 容器镜像的使用</strong></p><ul><li>管理和使用本地的docker镜像</li><li>查看本地主机已有镜像<blockquote><p><code>$ docker images</code></p></blockquote></li><li>各参数说明:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">REPOSITORY</td><td align="left">表示镜像的仓库源</td></tr><tr><td align="left">TAG</td><td align="left">镜像的标签</td></tr><tr><td align="left">IMAGE ID</td><td align="left">镜像ID</td></tr><tr><td align="left">CREATED</td><td align="left">镜像创建时间</td></tr><tr><td align="left">SIZE</td><td align="left">镜像大小</td></tr></tbody></table><ul><li>同一仓库源可以有多个<code>TAG</code>，代表这个仓库源的不同个版本</li><li><code>REPOSITORY:TAG</code>用于定义不同的镜像</li><li>例如使用<code>debian</code>，如果不指定一个镜像的版本标签，Docker 将默认使用<code>debian:latest</code>镜像</li></ul><p><strong>获取镜像</strong></p><ul><li>执行命令拉取10.2.0版本的debian镜像<br><code>$ docker pull debian:10.2.0</code><blockquote><p>获取之后可直接基于此镜像来运行容器<br>还可以从<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>上获取镜像<br><code>https://hub.docker.com/</code></p></blockquote></li></ul><p><strong>搜索镜像</strong></p><ul><li><p>执行命令搜索指定镜像名的镜像</p><blockquote><p><code>$ docker search [镜像名]</code><br>比如搜索一个httpd的镜像来用作web服务<br><code>$ docker search httpd</code></p></blockquote></li><li><p>各参数说明:</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NAME</td><td align="left">镜像仓库源的名称</td></tr><tr><td align="left">DESCRIPTION</td><td align="left">镜像的描述</td></tr><tr><td align="left">OFFICIAL</td><td align="left">是否 docker 官方发布</td></tr><tr><td align="left">stars</td><td align="left">类似 Github 里面的star</td></tr><tr><td align="left">AUTOMATED</td><td align="left">是否支持自动构建</td></tr></tbody></table></li></ul><blockquote><p>然后直接拉取镜像<br><code>$ docker pull httpd</code></p></blockquote><p><strong>删除镜像</strong></p><ul><li>执行以下命令:<blockquote><p><code>$ docker rmi 镜像名</code></p></blockquote></li></ul><hr><p><strong>创建镜像/制作镜像</strong></p><ul><li>当docker的镜像仓库中没有所需求的docker镜像时，可以制作镜像或对镜像进行修改再上传</li></ul><p><strong>更新镜像</strong></p><ul><li>从已经创建的容器中更新镜像，并且提交此镜像<blockquote><p>更新镜像之前，基于所选镜像来创建一个容器<br><code>$ docker run -t -i debian:10.2.0 /bin/bash</code><br>在容器内使用<code>apt-get update</code>命令来进行更新<br>操作完成之后，键入<code>exit</code>退出容器</p></blockquote></li><li>使用<code>docker commit</code>来提交容器副本<br><code>$ docker commit -m=&quot;has update&quot; -a=&quot;name&quot; [Containers ID] /debian:v2</code><blockquote><p><code>参数-m</code>用于指定提交的描述信息<br><code>参数-a</code>用于指定镜像作者<br><code>Containers ID</code>:容器 ID<br><code>debian:v2:</code>指定要创建的目标镜像名</p></blockquote></li><li>最后<code>docker images</code>查看新镜像，并用其启动容器</li></ul><p><strong>构建镜像</strong></p><ul><li>使用命令<code>docker build</code>，创建一个新的镜像</li><li>创建名为<code>Dockerfile</code>的文件，其中包含的指令用来指示Docker如何构建所选镜像</li><li>编写完Dockerfile之后通过docker build命令来构建一个新的镜像<blockquote><p><code>docker build -t [目标镜像名] [指定绝对路径]</code><br><code>参数-t</code>用于指定要创建的目标镜像名<br><code>参数.</code>用于指定Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</p></blockquote></li></ul><p><strong>设置镜像标签</strong></p><ul><li><code>docker tag</code>命令，为镜像添加一个新的标签<blockquote><p><code>docker tag [镜像ID] [用户名称/镜像源名(repository name)]:[新的标签名(tag)]</code></p></blockquote></li></ul><hr><p><strong>Docker 容器连接</strong></p><ul><li>容器中可以运行一些网络应用，从实现而让任意机器可以通过网络端口访问运行在docker容器内部的服务</li><li>要实现让任意机器(内部与外部)可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射</li><li>还可以指定容器绑定的网络地址，比如绑定本地主机的<code>127.0.0.1</code></li></ul><p><strong>网络端口映射的管理</strong></p><blockquote><p><code>docker run -d -P [网络服务名称] [服务的启动脚本]</code></p></blockquote><ul><li>参数说明:</li><li>参数-P用于创建容器，此时该网络服务绑定本地主机的默认端口</li><li>参数-p用于指定容器端口所绑定的主机端口</li><li>具体区别<blockquote><p>参数-P是让容器内部端口随机映射到主机的高端口<br>参数-p是让容器内部端口绑定到指定的主机端口</p></blockquote></li></ul><blockquote><p><code>docker run -d -p [原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote><ul><li>然后执行docker ps 就会发现服务已改变端口映射</li></ul><p><strong>指定容器绑定的网络地址</strong></p><ul><li>这里绑定127.0.0.1:<blockquote><p><code>docker run -d -p [127.0.0.1:原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote></li><li>此时就可以通过绑定的IP地址，来访问容器被指定绑定的接口</li><li>默认都是绑定TCP端口，如果要绑定UDP端口，可以在端口后面加上<code>/udp</code></li><li><code>docker port</code>命令可以让我们快捷地查看端口的绑定情况</li></ul><hr><h3 id="Docker-容器互连"><a href="#Docker-容器互连" class="headerlink" title="Docker 容器互连"></a>Docker 容器互连</h3><ul><li>端口映射不是唯一把Docker连接到另一个容器的方法</li><li>Docker内有一个连接系统允许将多个容器进行连通，以此共享被连接容器的信息</li><li>Docker连接会创建一个子父关系，其中父容器可以看到子容器的信息</li><li>先给容器进行统一的命名，以方便管理<blockquote><p><code>docker run -d -P --name [自定义容器名] [应用程序名称] [程序的启动脚本]</code><br><code>参数--name</code>用于定义容器名</p></blockquote></li></ul><p><strong>创建docker网络</strong></p><blockquote><p><code>docker network create -d bridge [Containers-net]</code><br><code>参数-d</code>用于指定Docker的网络类型，有<code>bridge</code>与<code>overlay</code><br>其中<code>overlay</code>网络类型用于<code>Swarm mode</code></p></blockquote><p><strong>连接容器</strong></p><ul><li>运行一个容器并连接到新建的<code>Containers-net</code>网络<blockquote><p><code>$ docker run -itd --name test1 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>打开新的终端，再运行一个容器并加入到 test-net 网络:<blockquote><p><code>$ docker run -itd --name test2 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>使用test1和test2两个容器互相ping一下以测试是否建立联系，如果没有ping命令就进行安装<blockquote><p><code>apt install iputils-ping</code></p></blockquote></li><li>可以在一个容器里安装好之后把容器包装成镜像，再以新的镜像重新运行以上两个容器</li><li>如果有多个容器之间需要互相连接，可以使用<code>Docker Compose</code></li></ul><p><strong>配置容器DNS</strong></p><ul><li><p><code>/etc/docker/daemon.json</code>文件中增加以下内容来设置全部容器的DNS:</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"dns"</span> : [</span><br><span class="line">    <span class="string">"111.111.111.111"</span>,</span><br><span class="line">    <span class="string">"3.3.3.3"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置后，启动容器的DNS会自动配置为<code>111.111.111.111 和 3.3.3.3</code></p></li><li><p>配置完，需要重启Docker服务才能生效</p><blockquote><p><code>/etc/init.d/docker restart</code></p></blockquote></li><li><p>查看容器的DNS是否生效可以使用以下命令，它会输出容器的DNS信息:</p><blockquote><p><code>$ docker run -it --rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>只想在指定的容器设置 DNS，则可以使用以下命令</p><blockquote><p><code>docker run -it --rm host_debian --dns=111.111.111.111 --dns-search=test.com debian</code></p></blockquote></li><li><p>参数说明：</p><blockquote><p>参数<code>-h HOSTNAME</code>或<code>--hostname=HOSTNAME:</code>设定容器的主机名，它会被写到容器内的<code>/etc/hostname</code>和<code>/etc/hosts</code><br>参数<code>--dns=IP_ADDRESS:</code>添加DNS服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在<code>/etc/hosts</code>中的主机名<br>参数<code>--dns-search=DOMAIN:</code>设定容器的搜索域，当设定搜索域为<code>.example.com</code>时，在搜索一个名为<code>host</code>的主机时，DNS不仅搜索<code>host</code>，还会搜索<code>host.example.com</code><br>如果在容器启动时没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></blockquote></li></ul><hr><p><strong>仓库管理</strong></p><ul><li><p>仓库(Repository)用于集中存放镜像</p></li><li><p>目前Docker官方维护了一个公共仓库Docker Hub</p></li><li><p>大部分需求都可以通过在Docker Hub中直接下载镜像来实现</p></li><li><p>网址为<code>https://hub.docker.com</code>，<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p></li><li><p>使用之前需要注册账户</p></li><li><p>登陆Docker hub执行</p><blockquote><p><code>$ docker login</code></p></blockquote></li><li><p>退出 docker hub执行</p><blockquote><p><code>$ docker logout</code></p></blockquote></li><li><p>查找镜像</p><blockquote><p><code>$ docker search [镜像名]</code></p></blockquote></li><li><p>拉取镜像</p><blockquote><p><code>$ docker pull [镜像名]</code></p></blockquote></li></ul><p><strong>推送镜像</strong></p><ul><li>把本地的镜像推送到Docker Hub</li><li><code>username</code>为Docker账号的用户名<blockquote><p><code>$ docker tag [镜像名]:[版本] [username/镜像名:版本]</code><br><code>$ docker image ls</code><br><code>$ docker push [username/镜像名:版本]</code></p></blockquote></li><li>最后查看一下<blockquote><p><code>$ docker search [username/镜像名]</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><p>官方文档:<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>Docker-3</title>
    <url>/2020/02/06/Docker-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Docker容器的基本命令与基本应用"><a href="#Docker容器的基本命令与基本应用" class="headerlink" title="Docker容器的基本命令与基本应用"></a>Docker容器的基本命令与基本应用</h3><p><strong>基本操作命令</strong></p><p><strong>拉取镜像</strong><br><code>$ docker pull --help</code><br><code>$ docker pull [OPTIONS] NAME:[:TAG|@DIGEST]</code><br>如果本地没有镜像，用pull从仓库里拉个镜像用<br><code>$ docker pull debian</code></p><p><strong>基于已有镜像启动容器服务</strong><br><code>$ docker run --help</code><br><code>$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><br><code>$ docker run -i -t debian /bin/bash</code></p><ul><li><code>参数-i</code>启动交互式选项，<code>参数-t</code>启动终端选项</li><li><code>debian</code>:也就是debian镜像</li><li><code>/bin/bash</code>:放在镜像后的是被执行指令，这里用<code>/bin/bash</code>来启动交互式<code>Shell</code></li><li>退出当前容器内终端执行<code>exit</code></li></ul><hr><p><strong>查看所有容器</strong><br><code>$ docker ps -a</code></p><ul><li>查询最后一次创建的容器<br><code>$ docker ps -l</code></li><li>输出参数说明</li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">CONTAINER ID</td><td align="left">容器ID</td></tr><tr><td align="left">IMAGE</td><td align="left">使用的镜像</td></tr><tr><td align="left">COMMAND</td><td align="left">启动容器时运行的命令</td></tr><tr><td align="left">CREATED</td><td align="left">容器的创建时间</td></tr><tr><td align="left">STATUS</td><td align="left">容器状态</td></tr><tr><td align="left">NAMES</td><td align="left">自动分配的容器名称</td></tr></tbody></table><ul><li>其中状态有七种<blockquote><p>created:已创建<br>restarting:重启中<br>running:运行中<br>removing:迁移中<br>paused:暂停<br>exited:停止<br>dead:死亡<br>PORTS:容器的端口信息和使用的连接类型(tcp\udp)</p></blockquote></li></ul><hr><p><strong>启动一个已停止的容器</strong><br><code>$ docker start [容器ID]</code></p><ul><li><code>参数-d</code>用于指定容器的运行模式，加了此参数的程序默认不会进入程序，进入容器需要使用指令<code>docker exec</code></li><li>在后台内利用容器debian运行debian-test程序</li><li><code>$ docker run -i -t -d --name debian-test debian /bin/bash</code></li></ul><p><strong>停止容器</strong><br><code>$ docker stop [容器 ID]</code></p><p><strong>重启容器</strong><br><code>$ docker restart [容器 ID]</code></p><p><strong>进入容器</strong><br><code>$ docker attach/exec --help</code></p><ul><li>在执行<code>参数-d</code>后，容器启动后会进入后台</li><li>此时想要进入容器，可以通过以下指令进入：<blockquote><p>docker attach<br>docker exec(使用docker exec命令时退出容器终端，不会导致容器的停止)<br><code>$ docker attach 容器ID</code>(如果从这个容器退出，会导致容器的停止)<br><code>$ docker exec -i -t 容器ID /bin/bash</code>(从这个容器退出，不会导致容器的停止)</p></blockquote></li></ul><p><strong>导出本地的某个容器</strong><br><code>$ docker export [容器ID] &gt; [生成的文件名(可以是tar或其他压缩文件)]</code></p><blockquote><p>把指定ID的容器快照导入到本地文件，保存地址是现在所处目录</p></blockquote><p><strong>导入容器快照</strong><br><code>$ docker import --help</code><br><code>$ docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></p><blockquote><p>将快照文件<code>debian.tar</code>导入到镜像<code>image-file/debian:v1</code>内<br><code>$ cat docket/debian.tar | docker import - image-test/debian:v1</code><br>还可以通过指定URL或者某个目录来导入<br><code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></p></blockquote><p><strong>删除容器</strong><br><code>$ docker rm -f [容器ID]</code></p><ul><li>清理所有已中止容器<br><code>$ docker container prune</code></li></ul><hr><p><strong>利用docker运行某个应用程序</strong></p><ul><li>拉取某个应用程序<br><code>$ docker pull [应用程序名]</code><br><code>$ docker run -d -P [被拉取的程序名] [运行脚本]</code><blockquote><p><code>参数-d</code>让容器在后台运行<br><code>参数-P</code>将容器内部使用的网络端口映射到我们使用的主机上<br>如果程序占用了某一端口，<code>docker ps</code>的时候会显示占用端口以及映射信息(PORST)</p></blockquote></li><li>通过<code>-p参数</code>来设置不一样的端口<br><code>$ docker run -d -p [原端口:指定端口] [被拉取的程序名] [运行脚本]</code></li></ul><p><strong>查看应用程序或容器使用的端口以及映射情况</strong><br><code>$ docker ps</code><br><code>$ docker port [容器ID/程序名]</code></p><p><strong>查看应用程序日志</strong><br><code>docker logs [容器ID/程序名]</code></p><blockquote><p>用于查看容器内部的标准输出<br><code>参数-f</code>用于让<code>docker logs</code>输出容器内部的标准输出，类似于Linux内的<code>tail -f</code>命令</p></blockquote><p><strong>查看应用程序进程</strong><br><code>$ docker top [容器ID/程序名]</code></p><p><strong>检查应用程序底层信息</strong><br><code>$ docker inspect [容器ID/程序名]</code></p><blockquote><p>会返回一个记录着关于选中应用程序的Docker容器配置和状态信息的文本</p></blockquote><p><strong>停止应用程序所在容器</strong><br><code>$ docker stop [容器ID/程序名]</code></p><p><strong>重启应用程序所在容器</strong><br><code>$ docker start [容器ID/程序名]</code></p><p><strong>移除应用程序所在容器</strong><br><code>$ docker rm [容器ID/程序名]</code></p><blockquote><p>删除容器时，容器必须是停止状态</p></blockquote><hr><p><strong>帮助命令:</strong></p><ul><li>直接执行<code>docker</code>，查看Docker客户端的所有可用指令选项</li><li>docker command –help，查看所选命令的帮助文件</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-2</title>
    <url>/2020/02/06/Docker-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Docker-Engine-Community-install"><a href="#Docker-Engine-Community-install" class="headerlink" title="Docker Engine-Community install"></a>Docker Engine-Community install</h3><p><strong>Debian Docker 安装</strong></p><ul><li>Docker Engine-Community 支持版本:<br><code>Buster 10与Stretch 9 (stable) / Raspbian Stretch</code></li><li>Docker Engine-Community 支持架构:<br><code>x86_64(或amd64)armhf，和 arm64</code></li></ul><blockquote><p>选定主机的首次安装需要设置Docker仓库，用以从仓库安装和更新Docker，而Raspbian系统必须使用shell脚本安装</p></blockquote><p><strong>设置仓库</strong></p><p>安装apt依赖包，以通过HTTPS来获取仓库</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install <span class="string">\</span></span><br><span class="line">   apt-transport-https <span class="string">\</span></span><br><span class="line">   ca-certificates <span class="string">\</span></span><br><span class="line">   curl <span class="string">\</span></span><br><span class="line">   gnupg2 <span class="string">\</span></span><br><span class="line">   software-properties-common</span><br></pre></td></tr></table></figure><p><strong>添加Docker的官方GPG密钥</strong><br><code>$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></p><blockquote><p>通过搜索指纹的最后八个字符，验证目前主机是否拥有带指纹的密匙<br>密匙:<code>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88</code><br>执行:<code>$ sudo apt-key fingerprint 0EBFCD88</code></p></blockquote><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">pub   <span class="number">4096</span>R/<span class="number">0</span>EBFCD88 <span class="number">2017</span><span class="number">-02</span><span class="number">-22</span></span><br><span class="line">      Key fingerprint = <span class="number">9</span>DC8 <span class="number">5822</span> <span class="number">9</span>FC7 DD38 <span class="number">854</span>A  E2D8 <span class="number">8</span>D81 <span class="number">803</span>C <span class="number">0</span>EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;<span class="symbol">docker@</span>docker.com&gt;</span><br><span class="line">sub   <span class="number">4096</span>R/F273FCD8 <span class="number">2017</span><span class="number">-02</span><span class="number">-22</span></span><br></pre></td></tr></table></figure><p><strong>设置稳定版仓库</strong></p><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">$ sudo<span class="built_in"> add-apt-repository </span>\</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">   $(lsb_release -cs) \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure><ul><li><code>lsb_release -cs</code>子命令用于返回Debian发行版的名称</li><li>Docker对未经测试和不受支持的Debian发行版不提供任何保证</li></ul><hr><p><strong>安装 Docker Engine-Community</strong></p><ul><li><p>更新apt包索引<br><code>$ sudo apt-get update</code></p></li><li><p>安装最新版本的 Docker Engine-Community和containerd<br><code>$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></p></li><li><p>安装指定版本的 Docker Engine-Community</p></li><li><p>列出仓库中的可用版本<br><code>apt-cache madison docker-ce</code></p></li><li><p>使用<code>docker-ce |</code>后所输出的字符串安装指定版本，然后执行:<br><code>$ sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io</code></p></li></ul><p><strong>卸载主机上Docker的旧版本</strong></p><ul><li>Docker的旧版本被称为<code>docker</code>，<code>docker.io</code>或<code>docker-engine</code><br><code>$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></li></ul><p><strong>帮助指令</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">command</span> --<span class="built_in">help</span></span><br><span class="line">man docker</span><br></pre></td></tr></table></figure><hr><p><strong>docker 镜像配置</strong></p><ul><li><p>Docker官方提供的中国镜像库:<code>https://registry.docker-cn.com</code></p></li><li><p>以添加Docker官方镜像库地址<code>https://registry.docker-cn.com</code>为例</p></li><li><p>upstart系统<br><code>$ emacs /etc/default/docker</code></p></li><li><p>修改其中<code>DOCKER_OPTS</code>的配置<br><code>DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;</code></p></li><li><p>重启服务<br><code>$ sudo service docker restart</code></p></li><li><p>systemd系统<br><code>emacs /etc/docker/daemon.json</code></p></li><li><p>如果没有就创建，在文件内添加:<br><code>{&quot;registry-mirrors&quot;:[&quot;https://registry.docker-cn.com&quot;]}</code></p></li><li><p>重启服务<br><code>$ sudo systemctl daemon-reload</code><br><code>$ sudo systemctl restart docker</code></p></li><li><p>检查配置是否生效<br><code>$ docker info</code></p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Registry Mirror<span class="variable">s:</span></span><br><span class="line">   http<span class="variable">s:</span>//registry.docker-<span class="keyword">cn</span>.<span class="keyword">com</span>/</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>参考资料:</strong></p><p>官方手册:<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p><p>官方安装手册:<a href="https://docs.docker.com/install/linux/docker-ce/debian/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/install/linux/docker-ce/debian/</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-1</title>
    <url>/2020/02/06/Docker-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="Docker的基本概述与原理简述"><a href="#Docker的基本概述与原理简述" class="headerlink" title="Docker的基本概述与原理简述"></a>Docker的基本概述与原理简述</h3><p><strong>概述:</strong></p><ul><li>基于google公司退出的Go语言实现</li><li>基于apache2.0协议，项目代码在github上进行维护</li><li>Docker项目的目标是实现轻量级的操作系统虚拟化解决方案</li><li>Docker的基础是linux容器(LXC)等技术，Docker在LXC<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>的基础上Docter进行了进一步的封装，让用户不需要去关心容器的管理，从而使其操作更为简便</li></ul><p><strong>docker和传统虚拟化方式的不同之处</strong></p><ul><li>可见容器技术Docker是在操作系统层面上实现虚拟化，直接对本机的操作系统进行复用</li><li>而传统方式则是在硬件层面上实现虚拟化</li><li>引用自官方文档:<blockquote><p>传统的(virtual machines)虚拟化技术不仅需要包含应用程序本身和必要的依赖所需要的存储空间以及容量，还需要承受若干个完整的操作系统所占有的存储空间，这些操作系统所占有的存储空间往往以GB为单位<br>Docker容器引擎只包含了其应用程序以及依赖项，它在主机操作系统的用户空间内作为一个完全被隔离且独立的进程去运行，同时与其他容器共享内核，所以说它不仅拥有VM内资源隔离和分配技术所带来的优点，还拥有更强的可移植性和效率等优势</p></blockquote></li></ul><p><strong>Docker与传统虚拟化方式相比，所拥有的优势</strong></p><ul><li>拥有更快速的交付和部署<br>Docker允许开发者在装有应用和服务本地容器做开发，从而直接集成到可持续开发流程中，以在整个开发周期中都可以完美的辅助开发者实现快速交付</li><li>高效的部署和扩容<br>因docker容器引擎的高可移植性，使其可以在任何软硬件平台上运行<br>这种可兼容的移植性可以让开发者把任何应用程序从一个硬件平台上直接迁移到另外一个硬件平台上<br>Docker的可兼容移植性和轻量特性可以很轻松的实现负载的动态管理，使开发者可以快速扩容或方便的下线某一应用和服务，这种速度将趋近实时</li><li>更高的资源利用率<br>Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小<br>以传统虚拟机的方式运行10个不同的应用就要起10个虚拟机，而Docker 只需要启动10个相互隔离的应用即可</li><li>更简单的管理<br>使用 Docker，只需要简易的修改，就可以替代以往大量的更新工作<br>所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理</li></ul><hr><p><strong>Docker引擎简述</strong></p><ul><li>Docker引擎是一个C/S结构的程序</li><li>简要流程:</li><li><code>(contiainer-manages/image-manages/network-manages/network-manages)-&gt;client docker CLI</code></li><li><code>client docker CLI-&gt;REST API-&gt;server doceker deamon</code></li><li>Server是一个常驻进程</li><li>REST API 实现了client和server间的交互协议</li><li>CLI 实现容器和镜像的管理，为用户提供统一的操作界面</li></ul><p><strong>Docker架构简述</strong></p><ul><li>Docker使用C/S架构</li><li>客户端，Docker程序与主机程序镜像由接口通信</li><li>指令由客户端发出，而Docker内部的镜像由主机经由接口提供</li><li>任何指令对镜像的操作都在Docker程序内部的独立化容器服务内完成</li></ul><p><strong>逻辑简述</strong></p><ul><li>最初由client发出管理指令</li><li>经由<code>DOCKER_HOST</code>接口操作docker daemon(程序)内的容器以及程序镜像(包括操作系统)</li><li>docker deamon中已存在其注册表内的程序由<code>DOCKER_HOST</code>接口返回给docker deamon内作为镜像使用</li><li>而程序及系统的镜像再被分布给docker deamon内部的独立容器服务所管理</li><li>简而言之就是命令最后被传输到所指定镜像的容器服务内，进入其容器，对其程序进行操作</li><li>简要流程:</li><li><code>Client(指令)-DOCKER_HOST-&gt;Docker deamon&lt;-DOCKER_HOST-Registry(注册表内已有程序)</code></li><li><code>Docker-&gt;Images(Rigistry)-&gt;Containers</code></li><li><code>从而实现Client-&gt;Containers</code></li></ul><hr><p><strong>关于Docker最基本的核心概念</strong></p><ul><li>镜像(Image)<br>Docker镜像(Image)，镜像其实就是一个只读的模板文件<br>例如：一个镜像可以包含一个完整的操作系统环境，里面仅安装了Apache或用户需要的其它应用程序<br>镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器<br>Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户可以直接从其他人那里下载一个已经做好的镜像来直接使用<br>镜像(Image)就是一堆只读层(read-only layer)的统一视角<br>这些只读层堆叠在一起，除了最下面的只读层，其它的只读层都会由指针指向它所对应的下一层<br>这些层是Docker内部的实现细节，并且能够在docker宿主机统一的的文件系统<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>上访问到</li></ul><p>简要结构流程:</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">read</span>-<span class="keyword">only</span> layer:</span><br><span class="line">Images(union <span class="keyword">file</span> <span class="built_in">system</span>):</span><br><span class="line"><span class="keyword">read</span>-<span class="keyword">only</span> layer-(指针)-&gt;<span class="keyword">read</span>-<span class="keyword">only</span> layer-(指针)-&gt;<span class="keyword">read</span>-<span class="keyword">only</span> layer-(指针)-&gt;<span class="keyword">read</span>-<span class="keyword">only</span> layer-&gt;...</span><br></pre></td></tr></table></figure><figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">read-write <span class="symbol">layer:</span></span><br><span class="line">Images(<span class="class"><span class="keyword">union</span> <span class="title">file</span> <span class="title">system</span>):</span></span><br><span class="line">bash/process-&gt;RW <span class="class"><span class="keyword">union</span> <span class="title">file</span> <span class="title">system</span></span></span><br><span class="line">read-write layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-(指针)-&gt;read-only layer-&gt;...</span><br></pre></td></tr></table></figure><ul><li><p>仓库(repository)<br>仓库(Repository)是集中存放镜像文件的目录<br>仓库和仓库注册服务器(Registry)的区别不大<br>仓库注册服务器上通常存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签(tag)<br>仓库分为公开仓库(Public)和私有仓库(Private)两种形式，最大的公开仓库是Docker Hub，存放了数量庞大的镜像供用户下载<br>国内公开的镜像仓库有很多，在我设置的友情连接里有几个我常用的镜像源的地址<br>用户也可以在本地网络内创建一个私有仓库<br>当用户创建了自己的镜像之后就可以使用 push 命令将它上传到公有或者私有仓库，这样下次在另外一台机器上使用这个镜像时候，只需要从仓库上 pull 下来就可以了<br>Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务平台</p></li><li><p>容器(container)<br>Docker 利用容器(Container)来运行应用，容器是从镜像创建的运行实例<br>它可以被启动、开始、停止、删除，每个容器都是相互隔离的、保证安全的平台<br>容器的定义和镜像近乎相同，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的<br>一个运行态容器被定义为一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程<br>所以说一个容器中的进程可以对文件进行修改、删除、创建，这些改变都将作用于可读写层</p></li><li><p>Docker 客户端(Client)<br>Docker 客户端通过命令行或者其他工具与Docker的守护进程通信<br><a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker SDK</a><br><code>https://docs.docker.com/develop/sdk/</code></p></li><li><p>Docker 主机(Host)<br>一个物理或者虚拟的机器用于执行Docker守护进程和容器</p></li></ul><hr><p><strong>参考文献与获取方式</strong></p><ul><li><p>官网<a href="https://www.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.docker.com/</code></p></blockquote></li><li><p>文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/</code></p></blockquote></li><li><p>Docker中国区镜像源</p><blockquote><p><code>https://registry.docker-cn.com</code></p></blockquote></li><li><p>获取<a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/get-docker/</code></p></blockquote></li><li><p>获取Docker Engine-Debian<a href="https://hub.docker.com/editions/community/docker-ce-server-debian" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com/editions/community/docker-ce-server-debian</code></p></blockquote></li></ul><hr><h2 id="Docker-debian安装-补充内容"><a href="#Docker-debian安装-补充内容" class="headerlink" title="Docker-debian安装(补充内容)"></a>Docker-debian安装(补充内容)</h2><h3 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h3><p><strong>使用 Docker仓库进行安装</strong></p><ul><li>首次安装Docker Engine-Community的主机需要先设置Docker仓库</li><li>以便之后可以从Docker官方的远端仓库安装和更新Docker</li><li>Raspbian 用户不能使用此方法</li><li>对于Raspbian，尚不支持使用仓库进行安装且必须改为使用shell脚本方式</li></ul><p><strong>设置仓库步骤:</strong></p><ol><li><ul><li>更新apt包索引:<blockquote><p><code>$ sudo apt-get update</code></p></blockquote></li></ul></li></ol><hr><ol start="2"><li><ul><li>安装 apt 依赖包，用于通过HTTPS来获取仓库:<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install <span class="string">\</span></span><br><span class="line">    apt-transport-https <span class="string">\</span></span><br><span class="line">    ca-certificates <span class="string">\</span></span><br><span class="line">    curl <span class="string">\</span></span><br><span class="line">    gnupg2 <span class="string">\</span></span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><ol start="3"><li><ul><li>添加Docker的官方GPG密钥:<blockquote><p><code>$ curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -</code></p></blockquote></li></ul></li></ol><hr><ol start="4"><li><ul><li>验证本地主机现在是否拥有带有指纹的密钥:<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ sudo apt-key fingerprint <span class="number">0</span>EBFCD88</span><br><span class="line"></span><br><span class="line">pub   <span class="number">4096</span>R/<span class="number">0</span>EBFCD88 <span class="number">2017</span><span class="number">-02</span><span class="number">-22</span></span><br><span class="line">      Key fingerprint = <span class="number">9</span>DC8 <span class="number">5822</span> <span class="number">9</span>FC7 DD38 <span class="number">854</span>A  E2D8 <span class="number">8</span>D81 <span class="number">803</span>C <span class="number">0</span>EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;<span class="symbol">docker@</span>docker.com&gt;</span><br><span class="line">sub   <span class="number">4096</span>R/F273FCD8 <span class="number">2017</span><span class="number">-02</span><span class="number">-22</span></span><br></pre></td></tr></table></figure><blockquote><p>9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符</p></blockquote></li></ul></li></ol><hr><ol start="5"><li><ul><li>执行指令以设置稳定版仓库:<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">$ sudo<span class="built_in"> add-apt-repository </span>\</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/debian \</span></span><br><span class="line"><span class="string">  $(lsb_release -cs) \</span></span><br><span class="line"><span class="string">  stable"</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><p><strong>安装Docker Engine-Community</strong></p><ol><li><ul><li>更新 apt 包索引:<blockquote><p><code>$ sudo apt-get update</code></p></blockquote></li></ul></li></ol><hr><ol start="2"><li><ul><li>安装最新版本的Docker Engine-Community和containerd:<blockquote><p><code>$ sudo apt-get install docker-ce docker-ce-cli containerd.io</code></p></blockquote></li></ul></li></ol><hr><ol start="3"><li><ul><li>安装特定版本:<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line">  docker-ce | <span class="number">5</span>:<span class="number">18.09</span><span class="number">.1</span>~<span class="number">3</span><span class="number">-0</span>~debian-stretch | https:<span class="comment">//download.docker.com/linux/debian stretch/stable amd64 Packages</span></span><br><span class="line">  docker-ce | <span class="number">5</span>:<span class="number">18.09</span><span class="number">.0</span>~<span class="number">3</span><span class="number">-0</span>~debian-stretch | https:<span class="comment">//download.docker.com/linux/debian stretch/stable amd64 Packages</span></span><br><span class="line">  docker-ce | <span class="number">18.06</span><span class="number">.1</span>~ce~<span class="number">3</span><span class="number">-0</span>~debian        | https:<span class="comment">//download.docker.com/linux/debian stretch/stable amd64 Packages</span></span><br><span class="line">  docker-ce | <span class="number">18.06</span><span class="number">.0</span>~ce~<span class="number">3</span><span class="number">-0</span>~debian        | https:<span class="comment">//download.docker.com/linux/debian stretch/stable amd64 Packages</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><ul><li>使用第二列中的版本字符串安装特定版本，例如<code>5:18.09.1~3-0~debian-stretch</code></li></ul><ol start="4"><li><blockquote><p>$ sudo apt-get install docker-ce=<version_string>docker-ce-cli=<version_string>containerd.io</version_string></version_string></p></blockquote></li></ol><hr><p><strong>卸载旧版本:</strong></p><ul><li>Docker 的旧版本被称为docker，docker.io或docker-engine<blockquote><p><code>$ sudo apt-get remove docker docker-engine docker.io containerd runc</code></p></blockquote></li></ul><hr><h3 id="安装Docker-Compose"><a href="#安装Docker-Compose" class="headerlink" title="安装Docker Compose"></a>安装Docker Compose</h3><ul><li><p>源代码(二进制)包地址<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/docker/compose/releases</code></p></blockquote></li><li><p>获取方式(执行):</p><blockquote><p><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code><br>1.24.1为版本号，可修改以下载其它版本</p></blockquote></li></ul><hr><h3 id="安装Docker-Machine"><a href="#安装Docker-Machine" class="headerlink" title="安装Docker Machine"></a>安装Docker Machine</h3><ul><li><p>获取方式(执行):</p><figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>base=<span class="symbol">https:</span>/<span class="regexp">/github.com/docker</span><span class="regexp">/machine/releases</span><span class="regexp">/download/v</span>0.<span class="number">16.0</span> &amp;&amp;</span><br><span class="line">  curl -L <span class="variable">$base</span>/docker-machine-<span class="variable">$(</span>uname -s)-<span class="variable">$(</span>uname -m) &gt;<span class="regexp">/tmp/docker</span>-machine &amp;&amp;</span><br><span class="line">  sudo mv /tmp/docker-machine /usr/local/bin/docker-machine &amp;&amp;</span><br><span class="line">  chmod +x /usr/local/bin/docker-machine</span><br></pre></td></tr></table></figure></li><li><p>版本检索</p><figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version <span class="number">0.16</span><span class="number">.0</span>, build <span class="number">9371605</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Docker 支持以下的Debian版本:</strong></p><blockquote><p>Buster 10<br>Stretch 9 (stable) / Raspbian Stretch<br>Docker Engine-Community 在 <code>x86_64</code> (或 <code>amd64</code> ) <code>armhf</code>，和 <code>arm64</code> 体系结构上受支持</p></blockquote><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">LXC，其名称来自Linux软件容器（Linux Containers）的缩写，一种操作系统层虚拟化（Operating system–level virtualization）技术，为Linux内核容器功能的一个用户空间接口，关于LXC更详细的内容这里先不做阐述</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">统一文件系统(Union File System)技术能够将不同的层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户的角度看来，只存在一个文件系统</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>makedown流程图-flowchart</title>
    <url>/2020/02/05/flowchart/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p><strong>概述:</strong></p><ul><li>流程图的语法大概可以分为两部分:定义元素与连接元素</li><li>定义变量所使用的语句大概结构是X=Y: Z</li><li>X是变量名，Y是操作模块名，Z是具体显示的文字内容，注意冒号后的空格，有空格的时候才能被识别</li></ul><p><strong>基本语法:</strong></p><ul><li>由于渲染的问题，这里用<code>&lt;.&gt;</code>代替</li></ul><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line"><span class="built_in">tag</span>=&gt;<span class="keyword">type</span>: content:&gt;url</span><br><span class="line"><span class="params">...</span></span><br></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ta<span class="name">g1</span><span class="comment">(...)</span>-&gt;ta<span class="name">g2</span><span class="comment">(...)</span>-&gt;ta<span class="name">g3</span><span class="comment">(...)</span></span><br><span class="line">···</span><br></pre></td></tr></table></figure><ul><li>括号内语句用逗号分隔</li></ul><p><strong>定义元素语法:</strong></p><ul><li><code>tag=&gt;type: content:&gt;url</code></li><li>tag：标签，用于连接元素时使用</li><li>type：该标签的类型，共有6种类型如下</li><li>content：流程语句中放置的内容</li><li>type:与content之间有一个空格</li><li>url：链接，与流程语句绑定</li></ul><p><strong>连接元素语法:</strong></p><ul><li>使用-&gt;符号，-&gt;表示下一步要执行的操作：</li><li><code>st-&gt;in-&gt;op-&gt;cond</code></li><li>表示的是先从st转到in，然后再到op，最后到cond</li><li>可以连续写，也可以分开写</li></ul><p><strong>判断分支语法:</strong></p><ul><li>condition是判断，可以取yes和no两种结果，对于不同结果可以有不同走向</li><li><code>cond(yes)-&gt;out</code>表示condition成立时转向out执行</li><li><code>cond(no)-&gt;op</code>表示condition不成立时转向op执行</li></ul><p><strong>操作模块说明:</strong><br>操作模块一共有以下六种:</p><table><thead><tr><th align="left">操作模块名</th><th align="left">表示含义说明</th></tr></thead><tbody><tr><td align="left">start</td><td align="left">开始</td></tr><tr><td align="left">end</td><td align="left">结束</td></tr><tr><td align="left">operation</td><td align="left">普通操作块</td></tr><tr><td align="left">subroutine</td><td align="left">子任务块</td></tr><tr><td align="left">condition</td><td align="left">判断块</td></tr><tr><td align="left">inputoutput</td><td align="left">输入输出块</td></tr></tbody></table><hr><p><strong>示例说明-1:</strong><br>竖向:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">yes</span>)</span>-&gt;</span>io-&gt;e</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">no</span>)</span>-&gt;</span>sub1<span class="function"><span class="params">(right)</span>-&gt;</span>op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-0" class="flow-chart"></div><hr><p>示例说明-2:<br>横向:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st<span class="function"><span class="params">(right)</span>-&gt;</span>op<span class="function"><span class="params">(right)</span>-&gt;</span>cond</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">yes</span>)</span>-&gt;</span>io<span class="function"><span class="params">(bottom)</span>-&gt;</span>e</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">no</span>)</span>-&gt;</span>sub1<span class="function"><span class="params">(right)</span>-&gt;</span>op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-1" class="flow-chart"></div><hr><p>实例说明-3:</p><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">···flow   </span><br><span class="line">st=&gt;start: 开始语句</span><br><span class="line"><span class="keyword">in</span>=&gt;inputoutput: 输入值</span><br><span class="line">e=&gt;end: 结束语句</span><br><span class="line">op=&gt;operation: 执行操作</span><br><span class="line">cond=&gt;condition: 是否成立？</span><br><span class="line">out=&gt;inputoutput: 输出值</span><br><span class="line"></span><br><span class="line">st-&gt;<span class="keyword">in</span>-&gt;op-&gt;cond</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">yes</span>)</span>-&gt;</span>out</span><br><span class="line">cond<span class="function"><span class="params">(<span class="literal">no</span>)</span>-&gt;</span>op</span><br><span class="line">out-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-2" class="flow-chart"></div><hr><p>示例说明-4:</p><figure class="highlight sml"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st=&gt;start: <span class="type">Start</span></span><br><span class="line">e=&gt;<span class="keyword">end</span>: <span class="type">Why</span> are you worried?</span><br><span class="line">cond1=&gt;condition: <span class="type">Do</span> you have a problem?</span><br><span class="line">cond2=&gt;condition: <span class="type">Can</span> you solve it?</span><br><span class="line"><span class="keyword">op</span>=&gt;operation: <span class="type">Since</span> you can't solve it,</span><br><span class="line"></span><br><span class="line">st-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;cond2</span><br><span class="line">cond1(no)-&gt;e</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no)-&gt;<span class="keyword">op</span>-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-3" class="flow-chart"></div><hr><p><strong>示例说明-5:</strong></p><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">···flow</span><br><span class="line">st=&gt;start: Start|<span class="type">past</span>:&gt;http://www.baidu.com</span><br><span class="line">e=&gt;<span class="keyword">end</span>: <span class="keyword">End</span>:&gt;http://www.baidu.com</span><br><span class="line">op1=&gt;operation: My Operation|<span class="type">past</span></span><br><span class="line">op2=&gt;operation: Stuff|<span class="type">current</span></span><br><span class="line">sub1=&gt;subroutine: My Subroutine|<span class="type">invalid</span></span><br><span class="line">cond=&gt;condition: Yes or No?|<span class="type">approved</span>:&gt;http://www.baidu.com</span><br><span class="line">c2=&gt;condition: Good idea|<span class="type">rejected</span></span><br><span class="line">io=&gt;inputoutput: catch something...|<span class="type">request</span></span><br><span class="line"></span><br><span class="line">st-&gt;op1(<span class="built_in">right</span>)-&gt;cond</span><br><span class="line">cond(yes, <span class="built_in">right</span>)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(<span class="built_in">left</span>)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-4" class="flow-chart"></div><hr><p>参考资料:</p><p>参考资料:<a href="http://flowchart.js.org/" target="_blank" rel="noopener">跳转</a><br><code>http://flowchart.js.org/</code></p><p>获取方式:<br><code>npm install --save hexo-filter-flowchart</code></p><p>配置方式：<br>安装完成后进入根目录修改配置文件</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">flowchart</span>: </span><br><span class="line"><span class="selector-id">#raphael</span>:<span class="selector-id">#optional</span>, <span class="selector-tag">the</span> <span class="selector-tag">source</span> <span class="selector-tag">url</span> <span class="selector-tag">of</span> <span class="selector-tag">raphael</span><span class="selector-class">.js</span> </span><br><span class="line"><span class="selector-id">#flowchart</span>:<span class="selector-id">#optional</span>, <span class="selector-tag">the</span> <span class="selector-tag">source</span> <span class="selector-tag">url</span> <span class="selector-tag">of</span> <span class="selector-tag">flowchart</span><span class="selector-class">.js</span></span><br><span class="line"><span class="selector-tag">options</span>:<span class="selector-id">#options</span> <span class="selector-tag">used</span> <span class="selector-tag">for</span> `<span class="selector-tag">drawSVG</span>`</span><br></pre></td></tr></table></figure><hr><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">st=>start: 开始框
op=>operation: 处理框
cond=>condition: 判断框(是或否?)
sub1=>subroutine: 子流程
io=>inputoutput: 输入输出框
e=>end: 结束框

st->op->cond
cond(yes)->io->e
cond(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script><textarea id="flowchart-1-code" style="display:none">st=>start: 开始框
op=>operation: 处理框
cond=>condition: 判断框(是或否?)
sub1=>subroutine: 子流程
io=>inputoutput: 输入输出框
e=>end: 结束框

st(right)->op(right)->cond
cond(yes)->io(bottom)->e
cond(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-1-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-1",options)</script><textarea id="flowchart-2-code" style="display:none">st=>start: 开始语句
in=>inputoutput: 输入值
e=>end: 结束语句
op=>operation: 执行操作
cond=>condition: 是否成立？
out=>inputoutput: 输出值

st->in->op->cond
cond(yes)->out
cond(no)->op
out->e</textarea><textarea id="flowchart-2-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-2-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-2",options)</script><textarea id="flowchart-3-code" style="display:none">st=>start: Start
e=>end: Why are you worried?
cond1=>condition: Do you have a problem?
cond2=>condition: Can you solve it?
op=>operation: Since you can't solve it,

st->cond1
cond1(yes)->cond2
cond1(no)->e
cond2(yes)->e
cond2(no)->op->e</textarea><textarea id="flowchart-3-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-3-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-3",options)</script><textarea id="flowchart-4-code" style="display:none">st=>start: Start|past:>http://www.baidu.com
e=>end: End:>http://www.baidu.com
op1=>operation: My Operation|past
op2=>operation: Stuff|current
sub1=>subroutine: My Subroutine|invalid
cond=>condition: Yes or No?|approved:>http://www.baidu.com
c2=>condition: Good idea|rejected
io=>inputoutput: catch something...|request

st->op1(right)->cond
cond(yes, right)->c2
cond(no)->sub1(left)->op1
c2(yes)->io->e
c2(no)->op2->e</textarea><textarea id="flowchart-4-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-4-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-4",options)</script><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式版本控制系统-Git-2</title>
    <url>/2020/02/04/Git-3/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第二章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第二章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第二章节"></a>分布式版本控制系统(Distributed Version Control) Git-第二章节</h3><p><strong>基本操作</strong></p><ul><li>上篇文章的末尾写了一点关于git创建新仓库和克隆项目的基本操作</li><li>这一章着重对暂存区内快照的管理与操作和分支的管理与操作进行说明</li><li>在<code>git init</code>后，在工作区的根目录会生成<code>.git</code>子目录，它就是本地主机的Git仓库，所有关于工作区项目的快照数据都存放在此目录下</li><li>Git主要工作就是创建和保存工作区中项目的快照及与其他时间段的快照进行对比</li></ul><ol><li><p><code>git add</code><br>用于将工作区修改或进行操作的任何文件添加到缓存目录，也就是暂存区<br><code>git add .</code><br>添加当前项目的所有文件</p></li><li><p><code>git status</code><br>用于查看工作区当前的状态，执行完<code>git status</code>就能看到工作区向暂存区进行的任何操作<br>可以添加参数，比如添加<code>-s参数</code>，以输出经过简化的结果<br><code>A/M filename</code>的意思是这个文件在添加到暂存区之后又有改动了</p></li><li><p><code>git diff</code><br>用以查看执行git status 输出结果的详细信息<br>参数信息</p></li></ol><ul><li><code>git diff</code>命令会输出暂存区以修改但尚未写入暂存区的改动的区别</li><li><code>git diff</code>尚未写入暂存区的改动</li><li><code>git diff --cached</code>查看已写如暂存区的改动</li><li><code>git diff HEAD</code>查看已写入暂存区的与未写入暂存区的所有改动</li><li><code>git diff --stat</code>输出简明的diff结果</li></ul><ol start="4"><li><p><code>git commit</code><br>将暂存区的内容添加到仓库中<br>因为每一次提交都要输入一次github的用户名和邮箱地址，所以可以先配置一下用户名和邮箱地址</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">git<span class="built_in"> config </span>--global user.name <span class="string">'用户名'</span></span><br><span class="line">git<span class="built_in"> config </span>--global user.email 邮箱地址</span><br></pre></td></tr></table></figure><p><code>参数-m</code>在命令行中提供提交注释，如果没有此参数，Git就会自动打开一个编辑器以填写提交信息<br><code>参数-a</code>可以跳过<code>git add</code>提交至暂存区</p></li><li><p><code>git reset HEAD filename</code><br><code>filename</code>是指已提交到暂存区的内容<br>用于取消已缓存的内容<br>执行<code>git reset HEAD</code>以取消之前的<code>git add</code>，并且不包含下一个提交完成后的暂存区快照</p></li><li><p><code>git rm</code><br>从工作区删除某个文件，需要从已跟踪文件的清单中移除，然后再去提交<br><code>git rm filename</code><br>如果该文件修改过并且已经提交到暂存区而还要删除的话，必须使用强制删除<code>参数-f</code><br><code>git rm -f filename</code><br>把文件从暂存区删除，或者说是从跟踪清单中删除，使用<code>--cached</code>参数<br><code>git rm --cached filename</code><br>使用<code>-r</code>参数用以递归删除，删除该目录下的所有文件和子目录<br><code>git rm -r</code>文件目录</p></li><li><p><code>git mv</code><br>用于移动或重命名一个文件夹，目录或软链接<br><code>git mv filename newfilename</code></p></li><li><p><code>git push</code><br>用于将本地工作区的最新消息推送到远端仓库</p></li><li><p><code>git pull</code><br>用于从远端仓库拉取最新的版本到本地工作区，并且自动与工作区内部的项目与数据自动合并(merge)</p></li><li><p><code>git fetch</code><br>用于是从远端仓库拉取最新版本到本地工作区，并且不会自动合并</p></li><li><p><code>git merge</code><br>用于从指定的分支合并到当前的分支，从而合并两个分支<br><code>git pull</code>相当于<code>git fetch + git merge</code></p></li></ol><hr><p><strong>Git查看提交日志</strong><br>12. <code>git log</code></p><ul><li><code>参数--oneline</code>查看简明版本</li><li><code>参数--graph</code>查看分支，合并等操作的日志，并显示拓扑图</li><li><code>参数--reverse</code>逆向输入所有日志</li><li><code>参数--author=用户名</code>查看指定用户的提交日志</li><li><code>参数--since，--before，--after，--until</code>查看指定日期<br>日志命令参考<a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/docs/git-log</code></li></ul><ol start="13"><li>git 标签<br><code>git tag -a 标签名</code><br>用于给当前快照打上标签</li></ol><hr><p><strong>使用Git连接远端的Github仓库</strong></p><p>添加一个新的远程仓库<br>14. <code>git remote add shortname url</code></p><p>查看当前的远程库<br>15. <code>git remote</code></p><p>拉取远程库<br>从远程仓库克隆新分支与数据<br>16. <code>git fetch alias</code><br>然后执行git merge 将远程分支到本地工作区所在的分支<br>17. <code>git merge alias/branch</code><br>从远端仓库提取更新数据并尝试合并到当前分支<br>一般执行完<code>git fetch</code>之后就会紧接着执行<code>git merge</code>，前者去对数据进行过滤，获取当前工作区没有的新数据，后者用于将新数据合并到本地工作区当前分支的项目</p><p>推送到远程仓库<br>18. <code>git push alias branch</code><br>将本地(branch)分支中的暂存区文件推到(alias)远端仓库上的(branch)分支<br>用于将本地暂存区的新数据推到某个远端仓库</p><p>删除远端仓库<br>19. <code>git remote rm [别名]</code></p><p><strong>生成ssh key</strong><br>20. * <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><ul><li>会在<code>/root/.ssh</code>目录生成密匙文件，打开<code>id_rsa.pub</code>，复制里面的key</li><li>然后进入Github并登入Github，点击头像内的<code>setting</code>选项卡内的<code>SSH and GPG keys</code>中的<code>SSH Keys</code>选项卡</li><li>将文件里的key拷贝到key中，title随意，然后<code>add ssh key</code></li><li>验证是否成功<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi <span class="keyword">Unit</span>-serow<span class="comment">! You've successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>具体可以参考一下<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="noopener">跳转</a><br><code>https://help.github.com/articles/generating-ssh-keys</code></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式版本控制系统-Git-1</title>
    <url>/2020/02/04/Git-2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第一章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第一章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第一章节"></a>分布式版本控制系统(Distributed Version Control) Git-第一章节</h3><p><strong>概述:</strong></p><ul><li>Git 是一个开源的分布式版本控制系统，用于帮助以群为单位的开发者们处理任何相同类型的项目(或称为同一项目)</li><li>Git 还可以指 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</li><li>Git 的性质使他不仅用于版本控制，还可用于内容管理 CMS 与工作管理等</li></ul><p><strong>关于 Git 的分布式</strong></p><ul><li>Git把内容按元数据的方式去存储，分布式的版本控制就是每个人都可以创建一个独立的代码仓库用于管理，各种版本的操作都可以再本地完成，每个人修改的代码都可以经过推送合并到另外一个代码仓库中，所以Git这种分布式的版本控制系统更适合个人的开发</li><li>因为分散式版本控制系统本质的关系，使得此类系统更重视对分支(branch)的支持，它们通常有较好的分支及合并的能力</li><li>在分散式版本控制系统中，开发者可以进行推(push)的动作，其意义是将自身档案库中的变更送至其他的档案库，也可以进行拉(pull)的动作，其意义是获取其他档案库的变更</li><li>处于分布式版本控制系统中的每个个体之间的关系是完全独立且自由的，他们完全自由并且完全可以参照自己的意愿来对远端的代码仓库进行实时的操作</li><li>学习Git时最重要的是对其分支管理系统的了解，这是它的本质与执行的逻辑核心</li></ul><p><strong>使用Git进行工作的通常流程</strong></p><ul><li>从远端仓库克隆代码到本地并作为工作目录</li><li>对克隆的资源进行操作</li><li>如果有人已经对其修改了，可以在本地更新资源</li><li>在提交前查看修改内容并提交修改内容</li><li>在修改完成后，如果发现错误，可以撤回并再次修改并提交</li></ul><hr><p><strong>最基本的使用</strong></p><p><code>git init</code><br>使用git init 创建或初始化一个仓库，通常是使用git的第一个命令<br>在执行完成git init命令后，git仓库会生成一个.git目录，该目录包含了所有资源的元数据，而其它项目的目录保持不变</p><p><code>git clone</code><br>从指定以存在的Git远端仓库中克隆项目<br><code>git clone repo(Git 仓库名)</code><br>还可以指定克隆的目录<br><code>git clone repo directory(本地目录)</code></p><hr><p><strong>Github域名解析地址</strong></p><blockquote><p><code>$vim /etc/hosts</code></p></blockquote><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">192<span class="selector-class">.30</span><span class="selector-class">.253</span><span class="selector-class">.113</span>    <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">192<span class="selector-class">.30</span><span class="selector-class">.252</span><span class="selector-class">.131</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">185<span class="selector-class">.31</span><span class="selector-class">.16</span><span class="selector-class">.185</span> <span class="selector-tag">github</span><span class="selector-class">.global</span><span class="selector-class">.ssl</span><span class="selector-class">.fastly</span><span class="selector-class">.net</span></span><br><span class="line">74<span class="selector-class">.125</span><span class="selector-class">.237</span><span class="selector-class">.1</span> <span class="selector-tag">dl-ssl</span><span class="selector-class">.google</span><span class="selector-class">.com</span></span><br><span class="line">173<span class="selector-class">.194</span><span class="selector-class">.127</span><span class="selector-class">.200</span> <span class="selector-tag">groups</span><span class="selector-class">.google</span><span class="selector-class">.com</span></span><br><span class="line">192<span class="selector-class">.30</span><span class="selector-class">.252</span><span class="selector-class">.131</span> <span class="selector-tag">github</span><span class="selector-class">.com</span></span><br><span class="line">185<span class="selector-class">.31</span><span class="selector-class">.16</span><span class="selector-class">.185</span> <span class="selector-tag">github</span><span class="selector-class">.global</span><span class="selector-class">.ssl</span><span class="selector-class">.fastly</span><span class="selector-class">.net</span></span><br><span class="line">74<span class="selector-class">.125</span><span class="selector-class">.128</span><span class="selector-class">.95</span> <span class="selector-tag">ajax</span><span class="selector-class">.googleapis</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客文件远端备份与恢复</title>
    <url>/2020/02/03/hexo%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="hexo博客文件远端备份与恢复"><a href="#hexo博客文件远端备份与恢复" class="headerlink" title="hexo博客文件远端备份与恢复"></a>hexo博客文件远端备份与恢复</h3><ul><li>其实就是将本地工作区的数据上传到远端仓库</li><li>因为再创建一个代码仓库有点浪费，所以用再原仓库内建立新分支的方法去备份博客</li><li>在创建新分支之前先确保博客内有默认主分支master</li></ul><p><strong>按顺序执行以下指令:</strong></p><ul><li><code>git init //创建一个新的Git仓库或初始化一个现有的仓库</code><br>该命令创建一个空的Git版本库和暂存区，基本上具有对象库，指针(HEAD)库和模板文件等等的隐藏目录.git<br>现有存储库中运行git init命令是安全的，所以不会覆盖已经存在的数据</li><li><code>git add .</code><br>将本地文件依次添加到暂存区</li><li><code>git commit -m &#39;hexo&#39;(需要进行备份的文件名，比如说hexo的根目录)</code><br>将文件数据提交至本地暂存区文件内，然后再将暂存区的改动提交到本地的版本库</li><li><code>git branch hexo</code><br>创建一个名为hexo的新分支</li><li><code>git checkout hexo</code><br>切换到hexo分支上</li><li><code>git remote add origin Github仓库地址</code><br>让仓库地址/URL实现本地与远程Github仓库的对接</li><li><code>git push origin hexo(推送文件目录)</code><br>推送本地工作区(仓库)内容到远程仓库的hexo分支，远程仓库的默认命名是origin</li></ul><p>创建新的仓库时会默认建立.gitignore文件，用于将不需要备份的文件屏蔽</p><p>以后备份的时候只需要</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">git</span> <span class="string">add .</span></span><br><span class="line"><span class="attr">git</span> <span class="string">commit -m "Backname"</span></span><br><span class="line"><span class="attr">git</span> <span class="string">push origin hexo</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g与hexo d</span></span><br></pre></td></tr></table></figure><hr><p><strong>恢复博客</strong></p><p>在本地机器上克隆博客文件的hexo分支<br><code>git clone https://github.com/yourgithubname/yourgithubname.github.io</code></p><p>分别执行以恢复博客</p><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-cli</span><br><span class="line">npm <span class="keyword">install</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git</span><br></pre></td></tr></table></figure><hr><p><strong>其他指令</strong></p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">git branch --<span class="keyword">set</span>-upstream-to=origin/分支名称 <span class="comment">//在所选仓库内设置默认分支</span></span><br><span class="line">git remote <span class="comment">//查看所有远程仓库</span></span><br><span class="line">gir remote <span class="keyword">rm</span> origin <span class="comment">//删除所关联的远程仓库地址</span></span><br><span class="line">git remote add origin 新仓库地址 <span class="comment">//添加新仓库地址</span></span><br><span class="line">git push orign master <span class="comment">//提交到新仓库中的默认分支</span></span><br><span class="line">git submodule init <span class="comment">//初始化本地配置文件</span></span><br><span class="line">git submodule <span class="keyword">update</span> <span class="comment">//抓取所有数据并检出项目中列出的合适的提交</span></span><br><span class="line">git <span class="keyword">rm</span> --cached <span class="keyword">file</span> <span class="comment">//从暂存区删除文件，工作区不做出改变</span></span><br><span class="line">git checkout . <span class="comment">//重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件</span></span><br><span class="line">git pull 参数[options]  仓库名[repository]  分支名[refspec...] <span class="comment">//从一个仓库或者本地的分支拉取并合并代码，相当于 git fetch 跟着一个 git merge FETCH_HEAD</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>版本控制系统 Git-分支</title>
    <url>/2020/02/03/Git-1/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h2 id="Git-版本控制系统"><a href="#Git-版本控制系统" class="headerlink" title="Git 版本控制系统"></a>Git 版本控制系统</h2><h3 id="远端分支的上传与本地分支的处理的执行逻辑与原理"><a href="#远端分支的上传与本地分支的处理的执行逻辑与原理" class="headerlink" title="远端分支的上传与本地分支的处理的执行逻辑与原理"></a>远端分支的上传与本地分支的处理的执行逻辑与原理</h3><p><strong>远端分支</strong></p><ul><li>在本地进行任何连接Git远端服务器或远端服务器分支的操作时，远端服务器内会创建一个默认分支，之后在本地会生成一个对应该默认分支的分支</li><li>下文描述说明:服务器的分支被称为<code>origin/master</code>，而本地的分支被称为<code>master</code></li></ul><p><strong>执行原理:</strong></p><ul><li>在本地执行<code>git clone</code>命令克隆远端数据之后，git的clone会自动将所连接远端服务器命名为origin(执行该命令就是克隆URL所指定服务器内的所有数据)</li><li>同时在远端origin服务器内创建了指向它默认主分支(master)的指针，并在远端的服务器内为分支命名为<code>origin/master</code>(默认仓库名与此仓库内的默认分支名)</li><li>然后远端的git服务器也会给本地主机添加本地的master指针，该指针与远端服务器origin的master分支指向同的目标</li><li>从而从本地就可以操作远程服务器origin的分支了(origin的任何分支-这里指master分支)，进而实现数据推送</li></ul><p><strong>逻辑关系的链接表示:</strong></p><blockquote><p>-表示线性执行的逻辑关系<br>本地主机-远程仓库-远程仓库内的若干个分支(分支也可以拥有分支)<br>默认远程仓库被命名为origin，而其下默认分支被默认命名为master<br>一般情况下，远程仓库内拥有最少一个默认分支，并将其默认定义为主分支，对主分支的定义可以进行改动</p></blockquote><hr><p><strong>本地分支</strong></p><p><strong>工作区，暂存区与版本库的概念与其中的关系介绍:</strong></p><ul><li>工作区就是本地主机的文件文件目录</li><li>暂存区(stage或index)，一般存放在隐藏目录.git下的<code>index</code>文件中,暂存区也可以被叫做索引(index)</li><li>版本库 工作区内的隐藏目录<code>.git</code>就被称之为版本库，其中包含了暂存区文件，对象库，游标(HEAD)文件与本地分支等等</li><li>正常情况下的操作都是由工作区发出命令然后传于版本库内进行各级执行</li></ul><p><strong>逻辑关系表示:</strong></p><blockquote><p>工作区-[版本库-(暂存区-本地分支/对象库)]-远端服务器<br>这里的-用于表示包含，链接与单向执行逻辑</p></blockquote><p><strong>逻辑关系:</strong></p><ul><li>当工作区内修改或新增文件之后执行git add 命令之后，暂存区的目录会被更新</li><li>同时工作区修改或新增文件的内容也被写入对象库中的一个新的对象库中，而该对象的ID也被记录在暂存区的文件索引中</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库中的对象库中</li><li>之后默认分支master或设置的本地分支经由游标(HEAD)的指向会对所选分支作出相应的更新</li><li>默认分支master或设置的本地分支指向的目录树就是提交至远端时暂存区的目录树</li><li>进而推送暂存区的目录树(也就是本地存储于所选分支内暂存区的所有数据)至远端</li></ul><p><strong>命令原理与版本库内目录简要介绍:</strong></p><ul><li><p>执行<code>git reset HEAD(游标名)</code>命令时，更新暂存区操作，暂存区的目录会被重写，而被master分支的游标所指向的目录树所交换，工作区不受影响</p></li><li><p>执行<code>git rm --cached filename</code>命令时 ，从暂存区删除文件，而工作区不做出改变</p></li><li><p>执行<code>git checkout .</code>命令时重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件，会清除工作区中未添加到暂存区的改动</p></li><li><p>执行<code>git checkout HEAD .</code>或<code>git checkout HEAD filename</code>命令时，会用游标(HEAD)指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件，不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动</p></li><li><p>执行<code>git fetch origin</code>命令用于同步数据，原理就是从中抓取本地没有的数据并且更新本地数据，同时游标(HEAD)也会更新</p></li><li><p>对象库位于<code>.git/objects</code>目录下，里面包含了创建的各种对象及内容</p></li><li><p>暂存库位于<code>.git/index</code>目录下</p></li><li><p>游标位于<code>.git/HEAD</code>目录下</p></li></ul><p>本文所描述的游标，也可以称之为指针，用指针去理解会更简单</p><h2 id="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"><a href="#论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考" class="headerlink" title="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"></a>论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考</h2><p>参考文案:</p><p>Git官网:<a href="https://git-scm.com/" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/</code></p><p>CN-Git 分支简介:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B</code></p><p>CN-Git 分支使用:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Binary File Descriptor/BFD</title>
    <url>/2020/02/02/BFD/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Binary-File-Descriptor"><a href="#GNU-Binary-File-Descriptor" class="headerlink" title="GNU Binary File Descriptor"></a>GNU Binary File Descriptor</h3><p><strong>GNU 二进制文件描述 BFD</strong></p><p><strong>概述:</strong></p><ul><li>目的是用于解决GNU项目中不同的目标文件的可移植性的主要机制</li><li>在GNU项目中对于不同目标文件可移植EFL<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>性问题的主要解决机制</li><li>BFD库还可以用来读取核心转储的结构化数据</li><li>截至至2003年，它支持25中不同体系结构的CPU上的大约50中文件格式</li></ul><p><strong>BFD的设计逻辑与执行逻辑:</strong></p><ul><li>BFD通过对目标文件<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>提供抽象视图来达成工作</li><li>BFD在内部将数据从抽象视图转到目标处理器所规定的文件格式所要求的节与数据结构/字节布局等细节</li><li>它关键的作用是处理字节序的差异<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>,包括寻址<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>算术等细节</li><li>BFD最初的设计目的是可以成为被各种工具所使用的通用库，但为了达成这一目的就需要频繁修补API来解决系统所带来的影响与容纳新系统的功能，从而限制了它的使用模式与功能</li><li>DFD的主要用户是<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GAS</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GDL</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GNU Binutils</a>和<a href="https://unit-serow.github.io/2020/02/01/Debugger/">GDB</a>，因此BFD不单独发行，所以它通常包括在Binutils和GDB的发行之中</li></ul><hr><p><strong>参考资料:</strong></p><p>参考网站-BFD的历史与故事<a href="https://www.oreilly.com/openbook/opensources/book/tiemans.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.oreilly.com/openbook/opensources/book/tiemans.html</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">ELF-可执行与可链接格式，Executable and Linkable Format简称为ELF ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">目标文件的结构:有一个有描述信息的“头”，可变量目的“段”，每个段都有一个名字，一些属性和一块数据，一个符号表，一组重定位入口顶等等</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display:inline-block;vertical-align:top;padding-right:10px">3.</span><span style="display:inline-block;vertical-align:top">比如在小端序主机和大端序目标之间，在32-bit和64-bit数据之间的正确转换和重定位入口项所指定的寻址算术的细节</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display:inline-block;vertical-align:top;padding-right:10px">4.</span><span style="display:inline-block;vertical-align:top">寻址是每种计算机中央处理器的指令集架构中的一部分，各个指令集下有不同的寻址模式，寻址模式决定了此架构下计算机语言指令所对应的运算数</span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU AutoGen</title>
    <url>/2020/02/02/AutoGen/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-AutoGen"><a href="#GNU-AutoGen" class="headerlink" title="GNU AutoGen"></a>GNU AutoGen</h3><p><strong>GNU 代码维护工具</strong></p><p><strong>概述:</strong></p><ul><li>AutoGen用于简化包含大量重复文本，指令集与宏定义的程序的创建和维护，所以在必须完全保持多个文本块同步的程序中，它能发挥很大的作用</li><li>除了CGL数据与已有的AutoGen定义之外，AutoGen还可以自定义格式或将XML文件作为输入定义</li><li>它经常被用于创建和维护处理程序选项所需的代码，处理选项需要在程序之间的不同位置同时维护多个构造，所以对于选件的维护是没有尽头的</li><li>因此，autogen带有一个名为autoopts的附加软件包，它用于简化程序选项的维护和文档编制</li><li>已知autogen可在GNU/Linux，BSD，OS/X，等其他操作系统上工作</li><li>它的最终目的是在任何具有ANSI C编译器的现代UNIX系统上运行</li></ul><hr><p><strong>参考资料:</strong></p><p>源码获取:<a href="http://autogen.sourceforge.net/data/" target="_blank" rel="noopener">跳转</a><br><code>http://autogen.sourceforge.net/data/</code></p><p>手册<a href="https://www.gnu.org/software/autogen/manual/html_node/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/manual/html_node/autogen.html</code></p><p>快捷参考<a href="https://www.gnu.org/software/autogen/man1-autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/man1-autogen.html</code></p><p>autogen官网<a href="https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html</code></p><p>开发者社区<a href="http://savannah.gnu.org/projects/autogen" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/projects/autogen</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Data Display Debugger</title>
    <url>/2020/02/02/DDD/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Data-Display-Debugger"><a href="#GNU-Data-Display-Debugger" class="headerlink" title="GNU Data Display Debugger"></a>GNU Data Display Debugger</h3><p><strong>GNU 调试器前端 DDD</strong></p><p><strong>概述:</strong></p><p>DDD:</p><ul><li>DDD基于GPL许可证发行</li><li>DDD是GNU计划的一个重要的组成部分</li><li>DDD主要用于Unix系统,并且有许多开源插件对其使用性的补充</li><li>GNU DDD是一个用于数据显示的调试器前端(Debugger front-end)，它使用motif工具包实现GUI</li><li>应用于诸如GDB,DBX,JDB,XDB,多种语言调试器和bash等命令行调试器的调试器前端，也包括GNU Make调试器等用于调试器的调试器前端</li><li>DDD拥有GUI前端的功能，可以查看源文本及其交互式图形数据的显示，将数据结构以图形化显示</li></ul><p>GCL:</p><ul><li>调试器前端就是所指调试器所使用的命令行解释器/命令行界面(CLI)，这里所指的调试器前端就是DDD</li><li>一个好的CLI可以最大程度的提高可移植性并最大程度地减少资源消耗</li><li>而最让开发者们青睐的还得是具备GUI的CLI，所以有一些GUI调试器的前端被设计成与各种GLI相兼容，还有一些GUI则针对某一个特定的GLI</li></ul><hr><p><strong>参考资料:</strong></p><p>文档<a href="https://www.gnu.org/software/ddd/manual/html_mono/ddd.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/manual/html_mono/ddd.html</code></p><p>官网<a href="https://www.gnu.org/software/ddd/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/</code></p><p>社区<a href="http://savannah.gnu.org/svn/?group=ddd" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/svn/?group=ddd</code></p><p><a href="https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html" target="_blank" rel="noopener">参考资料:</a><br><code>https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Common Lisp</title>
    <url>/2020/02/02/GCL/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Common-Lisp"><a href="#GNU-Common-Lisp" class="headerlink" title="GNU Common Lisp"></a>GNU Common Lisp</h3><p><strong>GNU Common Lisp编译器 GCL</strong></p><p><strong>概述:</strong></p><ul><li>不要与GNU CLISP和Common Lisp的概念混淆</li><li>GNU Common Lisp（GCL）是GNU计划中ANSI Common Lisp的编译器</li><li>它是Kyoto Common Lisp的演化版</li><li>它的执行过程通常是先生成C代码然后调用C的编译器来生成本机的目标代码</li><li>GCL是包括数学工具maxima，AXIOM,HOL88和ACL2在内的几个大型项目的首选实现</li><li>GCL可以在Linux或FreeBSD，microsoft windows等11种不同体系架构的系统下运行</li></ul><hr><p><strong>参考资料:</strong></p><p>FSF的GCL社区<a href="https://directory.fsf.org/wiki/Gcl" target="_blank" rel="noopener">跳转</a><br><code>https://directory.fsf.org/wiki/Gcl</code></p><p>官网社区<a href="https://www.gnu.org/software/gcl/gcl.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gcl/gcl.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU CLISP</title>
    <url>/2020/02/02/CLISP/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-ANSI-Common-Lisp"><a href="#GNU-ANSI-Common-Lisp" class="headerlink" title="GNU ANSI Common Lisp"></a>GNU ANSI Common Lisp</h3><p><strong>概述:</strong></p><p>摘要:</p><blockquote><p>用于实现 ANSI Common Lisp <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>中所描述的语言标准，并且拥有许多拓展<br>CLISP于大多数GNU与Unix系统上运行，还包括windows NT,ME等等，只需要4MB的RAM<br>common lisp是一种面向对象的通用高级编程语言<br>common lisp算是lisp语言的一种方言吧</p></blockquote><p>参考文献:<br>ANSI Common Lisp 中文翻译版<a href="https://acl.readthedocs.io/en/latest/" target="_blank" rel="noopener">跳转</a><br><code>https://acl.readthedocs.io/en/latest/</code></p><p>电子书版本<a href="https://web.archive.org/web/20020805060924/http://www.lisp.org/HyperSpec/FrontMatter/index.html" target="_blank" rel="noopener">跳转</a><br><code>https://web.archive.org/web/20020805060924/http://www.lisp.org/HyperSpec/FrontMatter/index.html</code></p><p>官方网站<a href="https://clisp.sourceforge.io/summary.html" target="_blank" rel="noopener">跳转</a></p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//clisp.sourceforge.io/summary.html</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//www.gnu.org/software/clisp/</span></span><br><span class="line"><span class="symbol">https:</span><span class="comment">//clisp.sourceforge.io/</span></span><br></pre></td></tr></table></figure><p>参考手册<a href="https://clisp.sourceforge.io/impnotes/clisp.html" target="_blank" rel="noopener">跳转</a><br><code>https://clisp.sourceforge.io/impnotes/clisp.html</code></p><p>获取:<br><a href="http/SF">跳转</a>/<a href="http://ftp.gnu.org/pub/gnu/clisp/" target="_blank" rel="noopener">跳转</a></p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line"><span class="keyword">http</span>/SF</span><br><span class="line"><span class="keyword">http</span>://<span class="keyword">ftp</span>.gnu.org/pub/gnu/clisp/</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">基于ANSI标准的common lisp语言的实现(编译器、调试器和解释器) ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Gettext</title>
    <url>/2020/02/02/Gettext/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Gettext-第一章节"><a href="#GNU-Gettext-第一章节" class="headerlink" title="GNU Gettext 第一章节"></a>GNU Gettext 第一章节</h3><p><strong>GNU 国际化(i18n)库</strong></p><p><strong>概述:</strong></p><ul><li>国际化与本地化函数库</li><li>GNU gettext是GNU translation project中最重要的一步</li><li>GNU通用性翻译计划</li><li>这个项目的达成将会让GNU拥有更大的经济与用户结构，从而拥有更多的资本</li></ul><p><strong>引用自官方文档:</strong></p><blockquote><p>在以前，通常GNU内部或大量其它的自由软件中的程序源代码都是拿英文编写或记录的，并且在与用户交互的界面所使用的也是英语<br>当世界上所有的开发人员之间使用一种通用的语言去交流会让开发的过程变得极为方便<br>但是，在全世界范围内的大多数人对于英文的理解能力和学习深度远不如母语，所以它们更愿意使用母语进行日常工作<br>并且大多数人只是希望让屏幕上其它晦涩难懂的语言少一点，而自己的母语多一点<br>所以就有了GNU Gettext<br>该软件包为程序员，翻译人员与用户提供了一套完善的工具和文档集<br>更准确的说，gnu gettext所使用的程序是一组工具，提供了一个框架来帮助其他GNU软件包生成多语言的消息</p></blockquote><p><strong>这个工具包括了以下的一组程序:</strong></p><ul><li>一套如何编写程序，从而让消息目录支持的规则</li><li>一套如何为目录本身和文件命名的规则</li><li>一个运行时库，用于支持检索翻译后的消息</li><li>一些独立程序，以各种方式处理可翻译的字符串或已翻译字符串的集合</li></ul><p>GNU Emacs拥有实现这套程序的插件或拓展，感兴趣的可以去查询有关GNU Emacs的消息</p><hr><p>逻辑简述:<br>以下内容参考自:<a href="https://www.gnu.org/software/gettext/manual/html_node/Program-Index.html#Program-Index" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/manual/html_node/Program-Index.html#Program-Index</code></p><ul><li>xgettext程序从源代码生成.pot文件，作为源代码中序翻译内容的模板</li><li>而翻译者需要工作的对象是.po文件，它是有msginit程序从.pot模板文件生成的</li><li>翻译者用maginit初始化中文翻译文件时可以执行<code>msginit --locale=cn --input=name.pot</code></li><li>然后编辑所生成的.po文件</li><li>最后.po文件需要使用msgfmt编译为.mo文件以用作发布</li><li>使其运行需要使用UNIX操作系统中的用户需要修改环境变量中的<code>LC_MESSAGES</code>或<code>LANG</code>，程序将自动从相应的.mo文件中读取语言信息</li></ul><p>使用方法:</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">在使用gettext()方法的时候通常以标记别名<span class="symbol">_</span>的形式使用</span><br><span class="line">如<span class="built_in">printf</span>(gettext(<span class="string">"name is %s. \n"</span>), first_name);</span><br><span class="line">可以写作<span class="built_in">printf</span>(<span class="symbol">_</span>(<span class="string">"name is %s.\n"</span>), first_name);</span><br></pre></td></tr></table></figure><hr><p>参考资料:<br>官方网站<a href="https://www.gnu.org/software/gettext/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/</code><br>获取<a href="https://ftp.gnu.org/pub/gnu/gettext/gettext-0.20.1.tar.gz" target="_blank" rel="noopener">跳转</a><br><code>https://ftp.gnu.org/pub/gnu/gettext/gettext-0.20.1.tar.gz</code><br>社区<a href="https://savannah.gnu.org/projects/gettext/" target="_blank" rel="noopener">跳转</a><br><code>https://savannah.gnu.org/projects/gettext/</code><br>文档<a href="https://www.gnu.org/software/gettext/manual/gettext.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/manual/gettext.html</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Portable Threads/Pth</title>
    <url>/2020/02/02/Pth/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Portable-Threads-第一章节"><a href="#GNU-Portable-Threads-第一章节" class="headerlink" title="GNU Portable Threads 第一章节"></a>GNU Portable Threads 第一章节</h3><p><strong>GNU 可移植线程库 Pth</strong></p><p><strong>概述:</strong></p><ul><li>GNU计划重要的一部分</li><li>GNU Pth 是用于UNIX平台下基于POSIX与ANSI C的用户空间线程库</li><li>GNU Pth还包含了POSIX线程的API，以达成向后兼容的目的</li></ul><p>GNU Pth使用到内核空间线程的N:1映射，所以说调度完全将完全由GNU Pth库进行<br>内核将不会干涉用户空间中任何数量的线程，所以利用不到SMP<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所拥有的机制，因为SMP必须由内核派遣</p><p><strong>存在目的:</strong></p><ul><li>GNU Pth的目的是针对任意线程的处理达到高度的可移植性</li><li>其次是为了让多线程应用提供基于优先级的调度</li></ul><hr><p><strong>参考资料:</strong></p><p>官方网站<a href="https://www.gnu.org/software/pth/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth</code></p><p>官方手册<a href="https://www.gnu.org/software/pth/pth-manual.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth/pth-manual.html</code></p><p>多线程库列表<a href="https://www.gnu.org/software/pth/related.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth/related.html</code></p><p><a href="https://www.gnu.org/software/pth/related.html" target="_blank" rel="noopener">多线程库文档，包含了Unix系统中所有对于已知多线程库的调用</a><br><code>https://www.gnu.org/software/pth/related.html</code></p><p>关于OSSP pth<a href="http://www.ossp.org/pkg/lib/pth/" target="_blank" rel="noopener">跳转</a><br><code>http://www.ossp.org/pkg/lib/pth</code></p><p>论文引用:<br><a href="http://heather.cs.ucdavis.edu/~matloff/pth.html" target="_blank" rel="noopener">对于GNU pth的使用与描述</a><br><code>http://heather.cs.ucdavis.edu/~matloff/pth.html</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">均衡多处理架构</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU C libary/Libc</title>
    <url>/2020/02/02/Libc/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-C-Library-第一章节"><a href="#GNU-C-Library-第一章节" class="headerlink" title="GNU C Library 第一章节"></a>GNU C Library 第一章节</h3><p><strong>C 标准函数库 Libc</strong></p><p><strong>概述:</strong></p><ul><li>GNU/Linux操作系统一个重要的组成部分</li><li>FSF为GNU所写，作用是配合linux内核,是Linux下基于ANSI C<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>标准的GNU C<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>标准函数库</li></ul><p><strong>存在目的:</strong></p><ul><li>目的是为linux内核的操作系统提供核心库文件，库提供了关键的API，当然也包括Linux内核的API</li><li>虽说称为C的标准函数库，但还支持很多其他的程序语言</li></ul><hr><p><strong>其它C 标准库</strong></p><p>C POSIX library</p><ul><li>C 可移植标准接口库</li><li>包含了一些在C 标准库之外的函数，这里指ANSI所定制的C 标准库</li></ul><p>CRT/C Run-time Library</p><ul><li>C 运行时期库</li><li>C 程序运行时需要这些库中的函数</li><li>包含于程序运行时使用到的一些API集合，这里的API是预先编译后存放在linux系统中的二进制代码形式的文件</li><li>CRT通常作为C编译程序发布</li><li>CRT含有初始化代码，还有错误处理代码(例如divide by zero处理)</li></ul><hr><p><strong>其它资料:</strong><br>ANSI C库可以根据头文件划分为15个类别<br>其中包括:</p><ul><li>字符类型 ()</li><li>错误码()</li><li>浮点常数 ()</li><li>数学常数 ()</li><li>标准定义 ()</li><li>标准 I/O ()</li><li>工具函数 ()</li><li>字符串操作 ()</li><li>时间和日期 ()</li><li>可变参数表 ()</li><li>信号 ()</li><li>非局部跳转 ()</li><li>本地信息 ()</li><li>程序断言 () 等等</li><li>这在其他的C语言的IDE中都是有的</li></ul><h2 id="以上内容引用自百度百科条目"><a href="#以上内容引用自百度百科条目" class="headerlink" title="以上内容引用自百度百科条目"></a>以上内容引用自百度百科<a href="https://baike.baidu.com/item/libc" target="_blank" rel="noopener">条目</a></h2><p>参考资料:</p><p>GNU C Library连接<a href="https://www.gnu.org/software/libc/involved.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libc/involved.html</code></p><p>C POSIX库参考文献<a href="https://web.archive.org/web/20100724201155/http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/funcref.htm" target="_blank" rel="noopener">跳转</a><br><code>https://web.archive.org/web/20100724201155/http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/funcref.htm</code></p><p>C 标准函式库<a href="https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html" target="_blank" rel="noopener">跳转</a><br><code>https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html</code></p><p>C POSIX library-wiki<a href="https://zh.wikipedia.org/wiki/C_POSIX_library" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/C_POSIX_library</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">由美国国家标准局所制定的C语言发布标准-是最基本的C语言函数库，包含了C语言最基本的库函数并且是C语言最初的标准</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">由LGPL许可协议发布的，自由的，公开源代码并且方便下载的C编译程序</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Libtool</title>
    <url>/2020/02/01/Libtool/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-libtool-第一章节"><a href="#GNU-libtool-第一章节" class="headerlink" title="GNU libtool 第一章节"></a>GNU libtool 第一章节</h3><p><strong>GNU 构建系统</strong></p><p><strong>概述与解释:</strong></p><ul><li>GNU Libtool是一种属于<a href="https://unit-serow.github.io/2020/01/29/Autotools/">GNU构建系统</a>的GNU程序设计工具</li><li>GNU Libtool是一个用于支持通用库的脚本程序</li><li>用于解决在不同的操作系统中使用共享库进行代码移植的复杂性，在不同的系统中建立动态链接库，以隐藏不同系统之间的差异性</li><li>从而给开发人员提供一致的接口</li><li>但还是需要底层系统对所创建链接库的支持，所以libtool不能在不支持动态连接库的系统中创建动态链接库</li></ul><hr><p><strong>存在目的:</strong></p><ul><li>用于产生/建立便携式的库，它既可以建立动态链接库，也可以建立动态链接库，还可以包含两者</li><li>GNU libtool的目的是使每一个主机类型的完整功能都可以通过一个泛用接口来产生</li><li>GNU libtool的目标是使接口一致</li></ul><hr><p><strong>使用方法</strong><br>本章节不对应用进行过多阐述<br>libtool通常与GNU建构系统中的autoconf和automake这两个工具一起使用<br>需要参照系统手册（构建通用库所需要执行的命令）以及修改相应makefile的makefile.in或makefile.in文件<br>相关内容可查询<a href="https://www.gnu.org/software/libtool/manual/libtool.html" target="_blank" rel="noopener">libtool文档</a></p><hr><p>参考资料</p><p>GNU Libtool手册<a href="https://www.gnu.org/software/libtool/manual/libtool.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libtool/manual/libtool.html</code></p><p>使用GNU Libtoo创建库<a href="https://www.ibm.com/developerworks/cn/aix/library/1007_wuxh_libtool/index.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.ibm.com/developerworks/cn/aix/library/1007_wuxh_libtool/index.html</code></p><p>官方网站<a href="https://www.gnu.org/software/libtool/news.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libtool/news.html</code></p><p>autobook<a href="http://www.sourceware.org/autobook/" target="_blank" rel="noopener">跳转</a><br><code>http://www.sourceware.org/autobook/</code></p><p>获取:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">http:</span> <span class="string">http:</span><span class="comment">//ftpmirror.gnu.org/libtool/</span></span><br><span class="line"><span class="string">ftp:</span> <span class="string">ftp:</span><span class="comment">//ftp.gnu.org/gnu/libtool/ </span></span><br><span class="line">克隆: git clone <span class="string">git:</span><span class="comment">//git.savannah.gnu.org/libtool.git</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Binutils</title>
    <url>/2020/02/01/Binutils/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Binutils-第一部分"><a href="#GNU-Binutils-第一部分" class="headerlink" title="GNU Binutils 第一部分"></a>GNU Binutils 第一部分</h3><p><strong>GNU 二进制工具包</strong></p><p><strong>工具包内包含程序</strong><br>主要包含ld与as，分别是GNU链接器-GAS与GNU汇编器-GLD</p><p><strong>其他程序</strong></p><ul><li>ar-用于建立，修改，提取归档文件(archive)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>/用于对归档/静态库做创建，修改和提取的操作</li><li>addr2line-将目标文件的虚拟地址转换为文件的行号或符号</li><li>c++filt-解码C++的符号</li><li>dlltool-用于构建与使用DLL文件，也就是创建windows动态库</li><li>gold-正在测试的功能，一个新型且效率更高的ELF的链接器</li><li>ELF是一种用于可执行文件，目标文件，共享库和核心转储的标准文件格式，可执行与可连接格式，ELF所产生的数据结构与工具不做阐述</li><li>gprof-用于显示性能的分析信息/性能分析工具</li><li>nlmconv-将目标代码转换为NetWare Loadable Module/NLM文件格式</li><li>nm-列出并显示目标文件中的符号</li><li>objcopy-复制并编译目标文件，其过程中可以修改</li><li>objdump-显示目标文件中的相关信息，可用于反汇编</li><li>ranlib-生成静态库索引</li><li>readelf-用于显示任何ELF格式文件的内容</li><li>size-列出对象总体或归档文件的节数/大小</li><li>strings-列出目标二进制文件中的可打印/可显示字符串</li><li>strip-从目标文件中移除符号</li><li>windmc-兼容windows消息的编译器，用于产生windows的消息资源</li><li>windres-windows资源文件的编译器</li></ul><hr><p><strong>杂项及存在意义</strong></p><ul><li>大部分的复杂代码都存于Binary File Descriptor library和libopcodes库内</li><li>所以它是一整套编程语言工具程序,用于处理许多格式的目标文件</li><li>这些程序大多数使用BFD-二进制文件描述库</li><li>主要的目的还是为GNU项目用于解决不同格式的目标文件的可移植性问题的主要机制</li></ul><hr><p><strong>参考:</strong></p><p>获取：</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//ftp.gnu.org/gnu/binutils</span></span><br><span class="line"><span class="string">http:</span><span class="comment">//ftpmirror.gnu.org/binutils</span></span><br><span class="line">apt-get install binutils*</span><br><span class="line">克隆：git clone <span class="string">git:</span><span class="comment">//sourceware.org/git/binutils-gdb.git</span></span><br></pre></td></tr></table></figure><p>官网<a href="https://www.gnu.org/software/binutils/binutils.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/binutils/binutils.html</code></p><p>文档<a href="https://sourceware.org/binutils/docs-2.33.1/" target="_blank" rel="noopener">跳转</a><br><code>https://sourceware.org/binutils/docs-2.33.1/</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">archive是一个包含多个被包含文件的单一库文件,它可以保证从中检索到原始的被包含文件-mumber,而member用于保存archive的各种基本属性，当member被提取后，archive的属性将被还原到初始状态</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Make</title>
    <url>/2020/02/01/Make/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Make-第一部分"><a href="#GNU-Make-第一部分" class="headerlink" title="GNU Make 第一部分"></a>GNU Make 第一部分</h3><p><strong>GNU 自动化建构</strong></p><p><strong>概述:</strong></p><ul><li>在软件开发的过程中，make通常作为一个工具程序(unility software),经由makefile，从而实现自动化构建软件</li><li>在经由makefile时make工具会根据情况转换文件形式至target，转换的同时还会检查文件的依赖关系，检查依赖关系的方式本部分不做阐述</li><li>所以在编写软件时，应该先编写一个makefile，之后再让make去进行构建和安装</li></ul><p>或称为</p><ul><li><p>用于编译源代码，从而生成结果代码，然后将结果代码链接起来，最后生成可执行文件</p></li><li><p>其中名为makefile的文件用来确定某一target文件的以来关系，然后把生成target相关的命令转给机器的shell去执行</p></li><li><p>IDE通常包含了make，make多用于UNIX下的软件开发</p></li><li><p>本质如同UNIX底层的其他基本程序，批量执行生成目标的命令，同时检查文件的依赖关系</p></li></ul><hr><p>参考<br>官方网站<a href="https://www.gnu.org/software/make/make.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/make/make.html</code></p><p>获取<br><code>http: http://ftp.gnu.org/gnu/make/</code><br><code>ftp: ftp://ftp.gnu.org/gnu/make/</code></p><p>make手册<a href="https://www.gnu.org/software/make/manual/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/make/manual/</code></p><p>makefile手册<a href="https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions</code></p><p>make源码所在目录</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta-keyword">/usr/</span>share<span class="meta-keyword">/doc/</span>make/</span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/doc/</span>make/</span><br></pre></td></tr></table></figure><p>make帮助指令</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">make</span> --<span class="keyword">help</span></span><br><span class="line">info <span class="keyword">make</span></span><br><span class="line">man <span class="keyword">make</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Compiler Collection</title>
    <url>/2020/02/01/GCC/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Compiler-Collection-第一部分"><a href="#GNU-Compiler-Collection-第一部分" class="headerlink" title="GNU Compiler Collection 第一部分"></a>GNU Compiler Collection 第一部分</h3><p><strong>GNU 编译器套装 GCC</strong></p><p><strong>概述:</strong></p><ul><li>它是GNU计划中关键的一环</li><li>基于GPL与LGPL软件许可,并且为free software-自由软件</li><li>UNIX-like，Linux，BSD类的操作系统都采用GCC为标准编译器</li><li>其他的C编译器LLVM,Clang</li><li>GCC通常是跨平台编译器的首选</li></ul><hr><p><strong>GCC的执行逻辑与过程</strong><br>GCC的作用是将源代码生成可执行文件大体需要四个步骤:</p><ul><li>预处理/预编译-preprocessing</li><li>编译-compilation</li><li>汇编-assembly</li><li>连接-linking</li></ul><p><strong>由下至上的处理过程</strong></p><ul><li>GCC先调用cpp进行预处理-预处理的作用是对源码文件中的文件包含-include,预编译语句-宏定义define等进行分析,预处理的主要功能大概分为三个:宏定义,文件包含,条件编译</li><li>然后调用cc1进行编译,这个阶段根据输入文件生成以.i为后缀的目标文件</li><li>然后调用as进行汇编工作,一般的汇编语言源码由.s为后缀,s为后缀的汇编语言文件经由编译器和汇编之后会生成.o后缀的目标文件</li><li>当所有目标文件都生成后,GCC就调用ld来完成最后阶段的工作-连接</li><li>在连接阶段,所有目标文件被自动生成并同时分配依赖条件/文件应该所处的位置</li><li>最后,该程序内所用的库函数也会被链接到所对应的位置</li></ul><hr><p><strong>GCC语言编译器的结构</strong><br>语言编译器的结构-由下至上/底层到顶层</p><ul><li>GCC内置了大量语言的编译器,每个语言的编译器都是独立的程序</li><li>编译器的作用是处理输入的源码,从而输出组合语言码</li><li>全部的语言编译器都有共同的中介架构</li><li>语言编译器的结构分为三个部分:前端接口,中介接口以及后端接口</li><li>前端接口负责解析符合此语言的原始码,并产生一个抽象语法树以及翻译此语法树,使其成为GCC的暂存器转换语言-RTL的后端，GCC编译器最佳化与静态程序解码技术应用于此时程序的代码上</li><li>最后适应于硬件架构的组合语言经由某一不可知算法产出</li></ul><hr><p><strong>参考:</strong></p><ul><li><p>官方网站<a href="https://gcc.gnu.org" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://gcc.gnu.org/</code></p></blockquote></li><li><p>获取:</p><blockquote><p><code>apt-get install gcc*</code></p></blockquote></li><li><p>涉及编译器深层原理的内容此章节不做阐述</p></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>ANSI C 光速参考目录:</strong></p><ul><li>ANSI C</li><li>C 预处理器</li><li>C Preprocessor: <a href="https://www.runoob.com/cprogramming/c-preprocessors.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-preprocessors.html</a></li></ul><p><strong>C 标准库</strong></p><ul><li><p><code>&lt;stddef.h&gt;</code> 泛用头文件</p></li><li><p><code>&lt;stdio.h&gt;</code> 通用输入输出函数</p></li><li><p><code>&lt;stdlib.h&gt;</code> 通用工具函数</p></li><li><p><code>&lt;string.h&gt;</code> 字符函数</p></li><li><p><code>&lt;time.h&gt;</code> 时间函数</p></li><li><p><code>&lt;assert.h&gt;</code> 验证宏定义</p></li><li><p><code>&lt;math.h&gt;</code> 数学函数与宏</p></li><li><p><code>&lt;ctype.h&gt;</code> 字符映射/测试</p></li><li><p><code>&lt;errno.h&gt;</code> 错误处理</p></li><li><p><code>&lt;float.h&gt;</code> 浮点值</p></li><li><p><code>&lt;limits.h&gt;</code> 变量类型</p></li><li><p><code>&lt;locale.h&gt;</code> 地域设置</p></li><li><p><code>&lt;setjmp.h&gt;</code> 绕过函数的调用与返回</p></li><li><p><code>&lt;signal.h&gt;</code> 处理执行期的不同信号</p></li><li><p><code>&lt;stdarg.h&gt;</code> 参数获取</p></li><li><p>参考网站: <a href="https://www.runoob.com/cprogramming/c-standard-library.html" target="_blank" rel="noopener">https://www.runoob.com/cprogramming/c-standard-library.html</a></p></li><li><p>参考网站: <a href="https://www.w3cschool.cn/c/c-standard-library.html" target="_blank" rel="noopener">https://www.w3cschool.cn/c/c-standard-library.html</a></p></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Debugger</title>
    <url>/2020/02/01/Debugger/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Debugger-第一部分"><a href="#GNU-Debugger-第一部分" class="headerlink" title="GNU Debugger 第一部分"></a>GNU Debugger 第一部分</h3><p><strong>GNU 调试工具 GDB</strong></p><p><strong>概述:</strong></p><p>存在的意义/作用:</p><ul><li>GDB大多数UNIX及UNIX-like下的调试工具</li><li>GDB可以根据自定义的要求启动所选程序</li><li>让被调试的程序在指定的调试断点停住，其断点可以是条件表达式，当程序被停住时可以去检查该程序中正在处理的事务</li><li>GDB还可以用于修改程序，以此来修复BUG所带来的影响</li><li>GDB相比于其他具有GUI的调式工具的优点就是具有修复网络断点以及恢复链接等功能</li><li>还可以把GDB理解为一个强大的命令行调试工具，命令行的优点就是可以形成一个完整的执行序列，以此来形成脚本程序<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li></ul><p><strong>使用方法简述:</strong></p><p><strong>启动</strong></p><ul><li>可以直接执行GDB以启动GDB命令行，<code>quit</code>退出GDB命令行</li><li>执行<code>gdb file name</code>来选中被调试的目标文件，并进入GDB命令行</li><li><code>run</code>用于执行程序，后面可以接GDB已有的缺省参数</li></ul><p><strong>断点</strong></p><ul><li>执行break命令，可以简写为b，用来给调试的程序中设置断点</li><li>从断电处继续运行执行continue命令</li><li>GDB还内置了断点的管理工具</li><li><code>info break</code> 用于显示当前GDB所有的断点信息</li><li><code>break breakpoint 编号</code> 用于删除指定编号的断点，如果不带编号将删除所有的断点</li><li><code>disable breakpoint 编号</code> 用于禁止使用指定编号的断点，同时info break的enb域变为n</li><li><code>enable breakpoint 编号</code> 允许指定断点，同时info break的enb域变为y</li></ul><p><strong>其他功能简述</strong></p><ul><li>单步执行：next不进入单步执行，step进入单步执行</li><li>函数调用：call function name调用和执行一个函数，执行finish结束当前的函数，如果有返回值就会显示其返回值</li><li>机器语言工具，信号处理与变量复制的检查</li></ul><hr><p><strong>参考资料:</strong></p><p>官方网站<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">跳转</a><br><a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">https://www.gnu.org/software/gdb/</a></p><p>GDB手册<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">跳转</a><br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p><p>深入GDB<a href="https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html" target="_blank" rel="noopener">跳转</a><br><a href="https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html" target="_blank" rel="noopener">https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html</a></p><p>开源程序的体系结构-GDB<a href="http://www.aosabook.org/en/gdb.html" target="_blank" rel="noopener">跳转</a><br><a href="http://www.aosabook.org/en/gdb.html" target="_blank" rel="noopener">http://www.aosabook.org/en/gdb.html</a><br><a href="http://www.aosabook.or" target="_blank" rel="noopener">http://www.aosabook.or</a></p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">因为UNIX下的软件基本上都是命令行的，所以它们具有天生的优势-可以很方便的把简单的已有工具的命令集成在一起，从而做出一个功能强大的程序 ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU Lib</title>
    <url>/2020/01/30/Lib/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Lib-第一部分"><a href="#GNU-Lib-第一部分" class="headerlink" title="GNU Lib 第一部分"></a>GNU Lib 第一部分</h3><p><strong>GNU 可移植性库</strong></p><p><strong>概述:</strong></p><ul><li>GNU Lib 存在的意义是实现所有gnu代码关于移植性问题处理方法的统一化</li><li>使任何基于GNU标准的软件，可以顺利的移植到任何其他的操作系统上，关于操作系统移植问题的方法统一化</li><li>所以可以把GNU Lib理解为所有基于GNU标准的软件的子程序，这些子程序将GNU软件互相链接，从而实现GNU软件包之间的完全共享</li><li>其中gcc因为libiberty库的原因，很难脱离GNU的构建树，但GNU Lib与其完全不同，构成它的子程序会实现资源等级的划分，使所有基于GNU协议的软件实现代码共享，从而解决移植性问题，而绝非去构建，安装或者链接库</li><li>因此GNU Lib没有发行版的概念，只需要将GNU Lib的源码复制到使用者的代码树中即可</li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>官网<a href="https://www.gnu.org/software/gnulib" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib</code></p><p>手册<a href="https://www.gnu.org/software/gnulib/manual" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib/manual</code></p><p>获取<br><code>git clone git: //git.savannah.gnu.org/gnulib.git</code></p><p>GNU Lib模块列表<a href="https://www.gnu.org/software/gnulib/MODULES.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib/MODULES.html</code></p><p>社区<a href="http://git.savannah.gnu.org/gitweb/?=gnulib.get" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org</code><br><code>http://git.savannah.gnu.org/gitweb/?p=gnulib.get</code></p><p>帮助指令:<code>./gnulib-tool --help</code></p><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔 2020-1.30 pm1.23</title>
    <url>/2020/01/30/%E5%AF%B9%E4%BA%8E%E8%87%AA%E8%BA%AB%E7%9A%84%E4%B8%BB%E8%A7%82%E6%80%A7%E8%AF%84%E4%BB%B7/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <div class="hbe-input-container">
  <input type="password" id="hbePass" placeholder="" />
    <label for="hbePass">输入密码</label>
    <div class="bottom-line"></div>
  </div>
  <script id="hbeData" type="hbeData" data-hmacdigest="61f87bf48e6dc1513b1c02c36f306bb4ecea147f28c47576a8e61e90a0d79019">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98aa3246934ba30dc6e13c4db354e8b3d7de513b0d9142b09e15ce6407075fa51362f935fa7e27c14cfc2d96a3dff9695a495e47e7b951425c5bfdfafb3fdc618fc76623d3d030aa49cd747691f628e2c3cfb958cc1bd5174ca0183e1afb8683ca0b0c99df4038f083f0f4afe5f0cb5290aa8d52b222a0dfac1ab3c1b99cb9627f53f6461617a96682624f101d06857740649166dc779e27b26689ee910022970039c4913a8882723f5c894df6a8acb87b46cac00ab99891c07ebe0000a7bcb72f9b92f01485880ebb3203b621a00333df2d4a2ad7f15cfacd8086c9233f184957bcd2cdfa99758742f382bd9df14b7bd5e2864024df9b1dc62fe2db8e96a354b84a149d9aba9d6c098933d02142e18dc356465794c19472b2b2f4c1f9546e10a992b179ec73149af9e73eb802573a2bc496aea359a4f7d70778332979fa9d955d2a8a4e26dcc6ec5966f30bd9d795812f7e0c27c6d5bfeae4282d7c88c2382ab3036e337d68290945b4077242a4d8f26ebb1d9c685e8ebfb29d23595a090d5e1bdb69cc274db57ca0a90360d85e816b9bd4b2e08bf2eb23198dc71e2d9d110a6120c4cebddbd3d77003bef1013b5b4a99ec3988203cefe0c96276b7f8222d582e573dd40b47adb7f013f1de17abd6196c04eb05dc119ab8595e5ffd68a0f7e1ac321662dc35d1e24096650ba34bcf1e476d65db27747b645acfe3b3336063cb64ef55cf0683b6a168299896d168a31fee77c83603f703ffbb373cf1741a195cf328e984547431ef014d85c5cf10bd4e9a6cd9eb6b73a4bfa320affe4fca4fecc1783b9bb11f1d6eaf1d008ee155bcd192fe0181d196417886c75627b5ae2bc054963354d54ad2c7b5ed851785f03fbfced574e9adfd9a32e64608eb61f5dfad6093496d37f0f65925cc5adffaa8f613d2bdc898badb79c2d52c3e8303e33a609657546858d9e294d1dbc340c525d8fa372c8f58a629012c309e18be6e3e2d35bffa1ea268f8d0c80224961160d096867e60cad7bb96abef3e2a9d0ebbbad065b959f0f4cd67e9fb1d7d710b8d3fcaaf75d60abbb4d6b7f5796ba4e2f057d3b1a3c22f554a59b4195ad1dec2a8085688ce7c6724d09f0390d0b2f19f2689e4f0527b0bb4726190e262a5635d642786c115a48a9b2b69a0e07be3a39626b960457ceaf6cf49b812d480a516b0788542c00a2ad57a3a321fab3c8a4d4c24c4b40b1f2a7045fce9eefbf50e85fc5fd7333a83d7de1fc7f05b46222d929910a7624897092a57adb420caf70362e8ed516566742a02da51aaae0cbebfd0ccb10f2351443cae9071b250d0074db3d31f15a9f638db5d9e214337d37824fb1eb715422d2ea9f93d317db461e9fb9ae071f567bc979caf239710a0f982f156c6bb429c1d3ebb45ecf2f0a147fce5d8252d1d146843175558e1d1104ad5aab16285d945a576300133fd0d76f78542e4ab4306b4a56eb1fe5c344f2b238f15f726ad67b13b5d7624a51c32dd31c00e5684659a54315584125911ef3ff29b768245157049b55bf6b86eab79a64455f8d1c88675976fcc63cbcf23e82342059713759b2a4222cf32f9fdc65690f508b06285cd27fe222915b8d989ae5fd7e5f994c6f2e7425a6957468029b59eea99e185d698381b4b876f7fccca1fdcf2951b395a6007ff42ad2773edb5f09295a4aee28e1c5ac3d57ba76913e352dea41e39bd2a22f6ebaf18302fa91a3cc7e96c23a7e35edef6b82b1446e815403a50a17bbb22b138f433d387948c8addf84fafbec0e362b0ca9a326abc2c9eafce79cd116d25277e198579e1da0ec01811c7450c56e94ccc6781d81e18c1afeb3bdb530b0febbaf389ad2eecbb3ef898144149c836f281cda47b3af6848e80740b34d51de65d287aa7ca9232ce2e0472ec8befdb4d639104a5df15ef8d33ad520939c62fa575659cabaa413a4f2a96585d184d957599297b6f2900f3690048d3ef055cc2b2151967b20f9ed5de81e8985d324389565101e20473b80660ad2d2745e69b5c5ecbc1b611954464d4111039830af4ff1abcb643871233e314cb9c8d1c672e36f5d97f180c48a289044e2bb95e7bc065bd0835e9f63f2626b2c84457d4995dcbd2cc11a56ad37f3dcc573355f789f90118b87c0d6dbac24779cc3625fcb2fce0f3b8995d437b67bde7e554628a74c1a9f85ccec7f4b058dbde1c3ddd10c39c9a8de8c313ee5bdfbe45b914d1742f6b65f54eccb410a0aae1cc52773b9728d92bc1efb056bbd29185db9e8441df88f6527e74e9227fe61235921e5268f60891071289e89b32cadb0ca5bff85b9b76bd3b0a1a3123ace5f4259f0a362d249209f8ff3c72e7357a259d64425ab8139e9cad54caf565869e5a9d6e984234a1f65e07b9d0be1f30d4abb47d2c637d4a0979520f863c335c29f27232eceb813f7969eba9aea1cd44ae1f6a6a607fd0fad107ca31c30924754b16de4043fe020888552c0ce16b9c39e9eb82c2d7fea9bf8ac5b8e46f404f56745ca4632773beab087819e8483a3cb4f24fef747f9f14bf553f9c602d28dd85c305c32a39c28a3945feab1dc4671f995159096ac1ab705352d6a6d98629bdc762b8f424d3cc3dd60ceea792be9773a0fafe32c5ddbc7b0d6afab6be076aad0f53306452d0d099b6a54807d7884e0985b91df9e35de5174d040ae0881d6eb4ecda1efa71e03bd431ca3b4895113c19e62179a2c1d605ccd529665df2d1a56ef1dc895a1014129ba3009ddd3eea3445e3410dc400c7b884cbb6fa3f224150d788df7eb83d06a0ba2a19df33605f93460b8d48621043deff0ffd535fb8e2c93f48f491eae1334dc02957275555389c80e765945a5c30e84a06573430f3df4910ce2e3cc6add65d56abed08dd92649de2a3f797e0f8766cbd14874f28feb8e2dc9487c966a7e085730fba792120ba71e60bfff5cc0a911f7af261de37c0eb76357d25faff2fe4028ec943ec2d504d566e9bbb3431478bd9c5148b85ceb7addeadcd0b4551a2fe8edc2543a18b21c5cc399bcc61232f5f9284d475636b5f9b938cce95b9a483386c8f62955a483d3ed5009cc3c2df118d311f74398775941cb977d5a695e88f93a4d72916350f61b81359acce575483a3a6c1f80cce0ba2ec19b22a98114294f575636ded2a45dd5a7b7ac7bf185e25e9366daf79c9c82e8d70e0270c7a1ac6072c8e89137e001b65fe1fc4ac83c0d4200dca480ec433e9113b403b4519438920b4543823f5f5e0df2d25e54219f9c7685a2fa7d70ecdb20a63ed32ac09def28e308e0cb39820f9878d0e1b1928d8370252ad583d444b8f1ffd44216b73930e94a06affb901d9ca34522e4e4a7bb022321a0c4157ab8566a220d42a3edf15cf9bc45634285edc91a54bf95cfcbd0612e9c16e7b6b3ff424f91ca7bc8a78aa06841d6ca4ce579d0c7bda0ab6f75786ab21ddb743fa8e634d49f8acb2e1021266887ccf389007f98b45be82b6e8687dd5c733e74784c086ee880ecd333356b5d36c80f0af7bbca8d02b7377f2eb24793dd717ba868343b0f8d817d42b32cddd3d8bfb4a34c5a6bc6c8145d016664a813686d516fb02199b52ed858a3441142a2c61f4dab86d4524cb31b98f3a9314a5b180ddc00c919a89f2d4af6c761a9ff806ce984893fc232927869ef049765c47416a1564219ece17a1e602c99c9f7de0ca243a92159db6c954391b071af9e6e5ecad6015fd73ded527f479677bdf90ba79837c391f2d5149221283d16192910d4a2287614a5f6f32f97ba574b047df71735bcc9acba23e21170dc1136ce57a504373b4f2397737633fa4edbb951bd5b8c0ab2e99b0edc375b0f94735239363b8804ee372eebc17d56fcad7ed7578678c6c084f0eecc43bdc16b7b6509aa042968be9904b674a6ba08c5ce305371e755ebcbd8203f0970ac425ba1c8cb61827baaa5f04b269d5465b9bd033a2194d3d89ed9d2315bbcbc8333c88d2a42393fbe0377becf0dcfdfb52bae21f02e49b53b76bcffee625f29b8ab23497759c3eae36722e0bf7c72e87f7f0494cab4c015e8c9cf99dc88b5f7aa3b3516d5237ea12064d140b03d306774e48d1d0feaecf545253cd6026f4e275f95b9d5efb93f09f7bc0113af87e1602cb5e47d2a7f5b3d6bdb2815e4e4f915fabd9d8f1baf83beb178fc1effaedad9d68bc1db4e341cc71ddc45c0fbe81be1f06171d6ff4a0ea2df906b46f8ddccbd250e5d6215a940ba513702710442c208236c91db3ff9010de0d54cbf28cacfd0e67bd93d03aa3e6fc13bb29768daf4350a3e12775266997c5729cb6dba132da9141b793fdb1d24a1e408fdc5defc281f663ebbace92fafee45c3f76fc38e7487fcb156e89e8ae66f486c8b93c7da002252f08fa94a1a0a95c72a2f6a23b5c152c8d8ec97b9dbd70baf203b36f7c5453ce4ba370bad8633c13ce450ed2b7dee28e555741ff07ae6d2fd9e09577adfe0179604cff2025e5738d2baa0352b3243fe0cfe0bdb690cb1261e1409f80b113026e4860bd62b39497d50fdb6eb492b731ef81abded112ec4f5a49551e4d52261cbe1676102367e37e55c247599503a84e90fba0f820077c78f0f7ae42bba20d6905d4ab8ba16db79425219c6cf13c8169a7cc58c37c36e52c1b85a63ccd77751c898a6abf70a7901b4797b93f4bce1cf5362ef7947d67d83dae37d5fa5de34162819c6e85ef38d174ec1bf37b952775808c0787f863580b1b709bbdf0f399b30ae5bbc804329be806133896c9e10e2c657218b41f3adb32458f4495eb05add32eea8148fa48796d9cb2abe1e140c183fce14b705f85e451bf8b63973b080e5ec4e833890c394b5773665b71678bce9a3294705cf061dcef410440f98471d566530e52776589668b975d710d4d930acfb92faff889a2cd04729be4ae97db66744b745f55939710ee4ad627add83f7f361c2c06d5e8edbcdd8a86f1d94a9695a5863672f6e03a839ffd589b345072e88abc47b7d5ce17e0820e08a6e4790a34964293a09364c78b8670345886ca16120cc6fb375f3a329be89c229961b643b5d5cb21d681ba6764b9c5650956cf5e3da4206dd38957d2ab8c56ba6098fe7e9c7a2f4acf431e9dcc2e4ef73c560f76b81cccbb899d5a5c42551ff06005cfe0d4c4a1bdba2fe0dfe59f8e472c626622cd74e25edd685093f577e5ec4b3e78781c4f760c89e697ac2d2de0f3f277c44a98f5782a83d6cf1d16b0ad59ce1ae2c36911b6cee0909639233d8180604469678a737dd29f9c7a7fa143525d7026dd4e871833cbae2711cd3d6034eff</script>
</div>
<script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU  Autotools</title>
    <url>/2020/01/29/Autotools/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-Autotools-第一部分"><a href="#GNU-Autotools-第一部分" class="headerlink" title="GNU Autotools 第一部分"></a>GNU Autotools 第一部分</h3><p><strong>GNU 构建系统</strong></p><p><strong>概述:</strong><br>autotools存在的目的就是用于生成makefile，从而实现降低makefile的维护难度与开发难度<br>autotools是一个工具集，并它包含了以下程序</p><ul><li>aclocal</li><li>autoscan</li><li>autoconf</li><li>autoheader</li><li>automake</li></ul><hr><p><strong>aclocal</strong><br>aclocal(automake)</p><ul><li>根据已安装的宏，用户定义宏和aclocal.m4文件中的宏将configure.ac文件所需要的宏集中定义到文件aclocal.m4文件中</li><li>aclocal由perl脚本所编写，而aclocal的定义为 <code>aclocal - create aclocal.m4 by scanning configure.ac</code></li><li>aclocal是一个由perl编写的脚本程序</li><li>aclocal根据configure.in文件中的宏所定义的内容，自动生成aclocal.m4文件</li></ul><hr><p><strong>autoscan</strong><br>autoscan(autoconf)</p><ul><li>用于扫描源代码以搜寻普通的可移植性问题，如检查编译器，库，头文件等</li><li>从而生成文件configure.scan，它是configure.ac的原型之一<br>或<br>执行逻辑:</li><li>autoscan工具用来扫描文件目录，可以用目录名作为参数，如果不使用参数的话，autoscan将会扫描当前所使用的目录</li><li>之后autoscan将从所指定的扫描目录中，将由扫描得到此目录下的源代码文件，基于此源代码生成源代码的configure.scan文件</li><li>configure.scan文件用于当作configure.in文件的模板，以此来获取configure.in文件</li><li>而configure.in的内容是一些宏，这些宏将经由autoconf工具处理并生成configure脚本</li></ul><hr><p><strong>autoheader</strong><br>autoheader(autoconf)<br>根据configure.ac中的某些宏，运行m4,<br>如ccp宏定义则声称config.h.in</p><hr><p><strong>Automake</strong><br>automake工具用于处理由事先编写好且带有预定义宏的文件，并生成makefile<br>简述:</p><ul><li>首先使用automake工具根据configure.in和Makefile.am来生成Makefile.in</li><li>然后编写宏定义文件makefile.in，再然后根据autoconf生成的configure脚本文件，最后让configure依据makefile.in来生成一个与之源码对应的makefile文件<br>或</li><li>automake将makefile.am中定义的结构建立起makefile.in，然后configure脚本将生成的makefile.in文件转换为makefie</li><li>如果在configure.ac中有特殊定义的宏，比如AC-PROG-LIBTOOL,automake会调用libtoolize，否则产生config.guess和config.sub</li></ul><p>官方网站:<a href="https://www.gnu.org/software/automake/" target="_blank" rel="noopener">https://www.gnu.org/software/automake/</a><br><a href="https://www.gnu.org/software/automake/" target="_blank" rel="noopener">跳转</a></p><p>官方文档:<code>https://www.gnu.org/software/automake/manual/automake.html</code><br><a href="https://www.gnu.org/software/automake/manual/automake.html" target="_blank" rel="noopener">跳转</a></p><p>获取方式:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">ftp:</span> <span class="string">ftp:</span><span class="comment">//ftp.gnu.org/gnu/automake/ </span></span><br><span class="line"><span class="string">http:</span> <span class="string">http:</span><span class="comment">//ftp.gnu.org/gnu/automake/</span></span><br></pre></td></tr></table></figure><p>帮助指令: <code>automake --help</code>与<code>man automake</code></p><hr><p><strong>Autoconf</strong></p><ul><li>autoconf工具用于根据configure.in文件和alocal.m4文件来产生configure文件</li><li>而此时的aclocal.m4需要用到GNU M4工具去处理</li><li>config是一个脚本，它能够设置源代码程序来适应各种不同的操作系统平台</li><li>并且根据不同的操作系统来产生合适的Makefile</li><li>从而使所扫描到的源代码程序能在不同的操作系统平台上被编译出来<br>或</li><li>作用是将configure.ac中的宏展开，生成configure脚本-一个shell脚本，此过程中可能需要用到aclocal.m4中定义的宏</li><li>以达成自动配置软件源代码包</li></ul><p>官方网站: <code>https://www.gnu.org/software/autoconf/autoconf.html</code><br><a href="https://www.gnu.org/software/autoconf/autoconf.html" target="_blank" rel="noopener">跳转</a></p><p>官方文档：<code>https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autconf.html</code><br><a href="https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.69/autoconf.html" target="_blank" rel="noopener">跳转</a></p><p>获取方式:</p><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="string">ftp:</span> <span class="string">ftp:</span><span class="comment">//ftp.gnu.org/gnu/autoconf/</span></span><br><span class="line"><span class="string">http:</span> <span class="string">http:</span><span class="comment">//ftp.gnu.org/gnu/autoconf/</span></span><br><span class="line"><span class="string">git:</span> git clone <span class="string">http:</span><span class="comment">//git.sv.gnu.org/r/autoconf.git</span></span><br><span class="line">apt-<span class="string">get:</span> apt-get install autoconf*</span><br></pre></td></tr></table></figure><p>帮助指令: <code>autoconf --help</code>与<code>man autoconf</code></p><hr><p><strong>Autotools</strong></p><p>获取方式:<br><code>apt-get install autotools</code></p><hr><p><strong>逻辑简述:</strong></p><ul><li>利用autotool组件生成configure脚本后生成makefile的执行逻辑</li><li>要生成makefile之前需要编写makefile.am文件之后再让automake工具使用autoconf所生成的configure脚本来生成所选源码文件的makefile</li><li>第一步需要先执行autoscanf命令来扫描当前目录下的源码文件，然后autoscanf会基于源码文件生成一个configure.scan文件</li><li>基于源码生成的configure.scan文件被用于当做configure.in文件的模板而存在</li><li>第二步将configure.scan的文件名改为configure.in，并对configure.in内的各种宏定义进行修改，这些宏定义内包括了用于让指向让autoconf处理configure.in文件从而生成从configure脚本</li><li>第三步执行aclocal命令，生成alocal.m4文件，因为autoconf需要aclocal.m4文件来生成configure脚本文件</li><li>第四步执行autoconf命令，生成configure脚本文件(自动配置源代码脚本文件)</li><li>第五步编写makefile.am文件，makefile.am文件用于描述定义从而让automake生成指定的宏和目标</li><li>第六步运行automake命令，可以增加参数–add-missing，从而让automake自动添加一些脚本文件</li><li>第七步运行configure脚本，从而生成基于源代码的makefile文件</li><li>最后直接使用make工具，编译并编译安装makefile就可以了，make install将会直接把可执行文件安装再/usr/local/目录下，至此完毕</li></ul><p>以上五个程序皆可称为M4宏的扩展包,文件处理的步骤与顺序，逻辑关系，应用等深度刨析第一部分里不做赘述<br>以上内容仅为主观理解，仅供参考</p><hr><h3 id="Autoconf-补充内容"><a href="#Autoconf-补充内容" class="headerlink" title="Autoconf-补充内容"></a>Autoconf-补充内容</h3><p><strong>./configure脚本常用参数解释:</strong></p><table><thead><tr><th align="left">参数</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">–help</td><td align="left">用于显示帮助信息并退出</td></tr><tr><td align="left">-prefix=/home/carl</td><td align="left">用于指定安装位置，如果安装位置不指定，默认路径为<code>/usr/local</code>下的<code>bin</code>,<code>lib</code>等文件夹</td></tr><tr><td align="left">–build</td><td align="left">用于指定此时此刻正在使用的机器，查看本机使用的可以在configure目录下执行<code>./config.guess</code></td></tr><tr><td align="left">–host</td><td align="left">用于指定编译好的程序可以运行的机器</td></tr><tr><td align="left">–target</td><td align="left">用于指定编译好的程序可以处理的其他平台<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></td></tr><tr><td align="left">CC</td><td align="left">用于指定编译工具链的名字</td></tr><tr><td align="left">CFLAGS</td><td align="left">用于指定头文件(<code>.h</code>文件)的路径，如: <code>CFLAGS=-I/usr/include -I/path/include</code></td></tr><tr><td align="left">LDFLAGS</td><td align="left">gcc等编译器会用到的一些优化参数，也可以在里面指定库文件的位置<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup></td></tr><tr><td align="left">LIBS</td><td align="left">用于告诉链接器要链接哪些库文件，如: <code>LIBS = -lpthread -liconv</code></td></tr></tbody></table><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">比如此时build的机器是x86，想运行的host机器是arm，程序可以处理的程序target是mips</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">用法: <code>LDFLAGS=-L/usr/lib -L/path/to/your/lib</code></span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GNU M4</title>
    <url>/2020/01/29/M4/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="GNU-M4-第一部分"><a href="#GNU-M4-第一部分" class="headerlink" title="GNU M4 第一部分"></a>GNU M4 第一部分</h3><p><strong>GNU 宏处理器</strong></p><p><strong>概述:</strong></p><ul><li>GNU M4是一种宏处理器</li><li>将输入拷贝到输出，同时将宏展开</li><li>宏可以是内嵌的，也可以是用户定义的</li><li>除了可以展开宏，m4还有一些内建的函数，用来引用文件，执行命令，整数运算，文本操作，循环等</li><li>m4既可以作为编译器的前端，也可以单独作为一个宏处理器</li><li>因为基于POSIX标准，所以兼容大部分SVR4<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li><li>其主要作用于GNU Autoconf project，通常是在安装autoconf时需要m4依赖才会安装它</li></ul><p>获取途径:<br>git: <code>git clone http://git.savannah.gnu.org/r/m4.git</code><br>http: <code>http://ftp.gnu.org/gnu/m4</code><br>ftp: <code>ftp://ftp.gnu.org/gnu/m4</code><br>apt-get: <code>apt-get install m4-doc或m4*</code></p><hr><p><strong>学习途径</strong></p><p>官方文档:<br><code>https://www.gnu.org/software/m4/m4.html</code><br><a href="https://www.gnu.org/software/m4/m4.html" target="_blank" rel="noopener">跳转</a></p><p>M4 宏语言手册<br><code>http://mbreen.com/m4.html</code><br><a href="http://mbreen.com/m4.html" target="_blank" rel="noopener">跳转</a></p><p>GNU M4 社区<br><code>http://savannah.gnu.org/projects/m4/</code><br><a href="http://savanah.gnu.org/project/m4" target="_blank" rel="noopener">跳转</a></p><p>默认帮助文档<br><code>m4 --help与man m4</code></p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">SVR4: UNIX操作系统的一种内核标准</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
        <category>GNU</category>
      </categories>
      <tags>
        <tag>1.认识与概述</tag>
        <tag>GNU/Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>基于debian使用hexo框架-next主题搭建并配置博客</title>
    <url>/2020/01/28/%E5%9F%BA%E4%BA%8Edebian%E4%BD%BF%E7%94%A8hexo%E6%A1%86%E6%9E%B6-next%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%B9%B6%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><h3 id="对于debian的基本配置与hexo的安装"><a href="#对于debian的基本配置与hexo的安装" class="headerlink" title="对于debian的基本配置与hexo的安装"></a>对于debian的基本配置与hexo的安装</h3><p>apt源的设置与一些基本软件的配置和准备这里就不过多阐述了<br>先修改一下/etc/hosts内的所配置IP,保证机器能ping通github.com<br><code>vim /etc/hosts</code> 内添加 <code>192.30.253.113 github.com</code></p><p>接下来安装hexo所依赖的几个程序：npm，git，node.js<br><code>apt-get install npm*</code><br><code>apt-get install git*</code><br><code>apt-get install node.js*</code><br>安装完之后检查一下版本或者whereis一下看看所否健在<br>最后再安装hexo软件<br><code>npm install -g hexo-cli</code><br>安装完–version检查一下版本</p><hr><h3 id="hexo的基本操作"><a href="#hexo的基本操作" class="headerlink" title="hexo的基本操作"></a>hexo的基本操作</h3><p>hexo –help<br><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方中文文档与手册</a><br>hexo安装完毕后可以先进行一下测试<br>于任意目录下新建一个文件夹 <code>mkdir blog</code><br>进入文件夹后分别执行<code>hexo init,hexo g,hexo s</code><br>然后使用浏览器访问<u>localhost:4000</u>查看所否成功</p><hr><h3 id="hexo链接github库"><a href="#hexo链接github库" class="headerlink" title="hexo链接github库"></a>hexo链接github库</h3><p>利用npm安装hexo部署程序/插件<br><code>npm install --save hexo-deployer-git</code><br><code>vim /*/blog/_config.yml</code><br>修改最下方的#deployment配置</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">  type:</span> git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//github.com/你所建立的仓库地址</span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure><p>执行<code>hexo d</code>开始远程部署，其中需要用户输入仓库所在帐号的帐号和密码</p><hr><h3 id="hexo修改主题"><a href="#hexo修改主题" class="headerlink" title="hexo修改主题"></a>hexo修改主题</h3><p>这里推荐两个个人感觉生态最好的两个hexo主题-next与yilia<br>进入blog目录下直接执行克隆命令<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code><br>或<br><code>git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code><br>此时的主题文件被存储于/blog/theme目录下<br><code>cd _condig.yml</code><br>修改#extensions中的theme，将原主题landscape修改为next或yilia</p><hr><h3 id="hexo安装搜索插件与RSS插件"><a href="#hexo安装搜索插件与RSS插件" class="headerlink" title="hexo安装搜索插件与RSS插件"></a>hexo安装搜索插件与RSS插件</h3><p>添加并配置RSS<br><code>npm install hexo-generator-feed --save</code><br>修改hexo配置文件为</p><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Extensions</span></span><br><span class="line"><span class="meta">## Plugins: https:<span class="comment">//hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">## Themes: https:<span class="comment">//hexo.io/themes/</span></span></span><br><span class="line"><span class="symbol">        plugins:</span></span><br><span class="line">                hexo-generator-feed</span><br><span class="line">                <span class="meta">#Feed Atom</span></span><br><span class="line"><span class="symbol">        feed:</span></span><br><span class="line"><span class="symbol">                type:</span> atom</span><br><span class="line"><span class="symbol">                path:</span> atom.xml</span><br><span class="line"><span class="symbol">                limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure><p>对主题文件添加：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">feed</span>:</span><br><span class="line">        <span class="attribute">type</span>: rss2</span><br><span class="line">        <span class="attribute">path</span>: rss2.xml</span><br><span class="line">        <span class="attribute">limit</span>: <span class="number">5</span></span><br><span class="line">        <span class="attribute">hub</span>:</span><br><span class="line">                <span class="attribute">content</span>: <span class="string">'true'</span></span><br></pre></td></tr></table></figure><p>添加并配置search-搜索<br><code>npm install hexo-generator-searchdb --save</code><br>修改hexo配置文件为</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 搜索</span></span><br><span class="line">  <span class="attr">search:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">          <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">          <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">          <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>修改主题配置文件为<br>找到local search，然后把enable设置为true</p><p>其余类似于菜单，头像，链接与装饰的配置可以<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">参考官方文档</a></p><hr><h3 id="关于文章的书写格式与基本要求"><a href="#关于文章的书写格式与基本要求" class="headerlink" title="关于文章的书写格式与基本要求"></a>关于文章的书写格式与基本要求</h3><p>hexo文章书写的语法都来自于Markdown<br>Markdown所一种可以使用普通文本编辑器编写的标记语言<br>目的是通过简单的语法来让普通文本的内容具有一定的格式<br>详情参考: <a href="https://markdown-zh.readthedocs.io/en/latest" target="_blank" rel="noopener">Markdown中文文档</a></p><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>NEXT主题优化参考:</strong></p><ul><li><p>深度优化</p><blockquote><p><a href="https://www.ipyker.com/2019/05/01/hexo-next.html" target="_blank" rel="noopener">https://www.ipyker.com/2019/05/01/hexo-next.html</a><br><a href="https://www.cnblogs.com/harlanzhang/p/10926305.html" target="_blank" rel="noopener">https://www.cnblogs.com/harlanzhang/p/10926305.html</a></p></blockquote></li><li><p>成型配置</p><blockquote><p><a href="https://github.com/ipyker/hexo-next-theme" target="_blank" rel="noopener">https://github.com/ipyker/hexo-next-theme</a></p></blockquote></li><li><p>Huihoo</p><blockquote><p><a href="https://docs.huihoo.com/" target="_blank" rel="noopener">https://docs.huihoo.com/</a><br><a href="https://docs.huihoo.com/homepage/shredderyin/emacs.html" target="_blank" rel="noopener">https://docs.huihoo.com/homepage/shredderyin/emacs.html</a></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
      <categories>
        <category>软件</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
