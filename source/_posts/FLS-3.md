---
title: FLS-3
date: 2020-02-22 16:08:52
tags: [随笔,GNU/Linux]
categories: [软件,GNU]
---

## LSF-3

* 内容接LSF-2

### 制作过程中的相关技术

1. 虚拟根目录
* 制作目标系统的最终且最基本点是让其称为一个可以独立运行的系统(不依赖主系统和临时系统的纯净系统)
* 根据Linux系统的特点它需要存放于根目录下，而第一阶段中的主系统也同样存放在根目录下
* 主系统在制作过程中是始终运行的，制作过程中要运行目标系统中的命令，从而形成了命令的执行矛盾
* 而在Linux系统中使用虚拟根目录可以解决这个矛盾
* linux内核启动时建立的根目录被定义为真正的目录，虚拟根目录可以简单的理解为:一个运行的Linux系统中可以存在多个运行环境，而每个运行环境都有自己的根目录，这些运行环境的根目录就可以被定义为虚拟根目录，任何目录都可以被设置为某个运行环境中的根目录
*  在主系统中建立一个目录，其中存放系统的基本命令，即可将该目录作为虚拟根目录启动一个新的运行环境
* 如果将主系统环境称为环境A，把在A环境下建立的新的运行环境称为环境B，则可称环境B为环境A的子环境，而环境A被称为环境B的父环境

**实现逻辑简述:**
1. 假设主系统中的根目录下存在若干文件目录
2. 指定其中某一目录作为制作目标系统的基础目录(将此目录设置为新的运行环境的根目录)
3. 此时将此目录称为X，而此目录下还可以存放若干文件目录，这里用X1，X2，X3表示
4. 基于跟目录X创建一个运行环境，此时运行目录X下将只有X1，X2，X3目录

* 用于作为新运行环境中的根目录可以是父环境中的任何命令或者目录中的目录，同时也包括父环境中的根目录

---

2. 分区的挂载
* 目标系统的最终目的是独立于主系统而运行，此时需要将目标系统装在一个分区中，而不是主系统的某个目录下
* Linux系统是通过挂载的方式使用分区，挂载就是将某个存储设备以某种文件系统链接到某个目录
* 用户查看到目录中的文件即为分区中的文件，对其中的文件进行操作与操作一般目录的文件相同
* 只要有一个空分区，将该分区格式化为主系统能识别的文件系统，并将其挂载到主系统的某个目录上就可以了
* 目标系统只需要存放到这个目录就等于存放在该分区，制作完成后就可以直接使用这个分区来启动系统，存放在目录下的第一级的文件和目录就是目标系统跟目录的内容

**实现逻辑简述**
1. 挂载主系统的根目录下的某个目录，将此目录定义为磁盘分区A，此磁盘分区下拥有若干个目录
2. 然后从磁盘分区A启动目标系统，启动之后的目标系统的根目录以及根目录下的文件即为主系统下被挂载的文件目录的中的文件，在这里还可将其称为磁盘分区A
3. 从而使目标系统脱离主系统运行

* 可以看出子环境运行的方式和目标系统重新启动后的根目录相同
* 根据此原理，制作目标系统的过程中以挂载分区的目录作为虚拟根目录创建新的运行环境，在其中可以使用目标系统的命令
* 从而解决了主系统和目标系统都需要使用根目录的矛盾
* 目标系统制作完成后，目录系统就可以从分区单独启动以此来脱离主系统

---

3. 链接文件
* 在Linux系统中有一种用来引用其它文件的符号链接文件，这里将其简称为链接文件
* 其包含有一条绝对路径或者相对路径的形式用于指向其它文件或者目录的引用
* 其所链接的文件被称为目标文件，链接文件和目标文件的文件名可以相同也可以不同
* 相同文件名的情况下目标文件和链接文件不能存放于实质相同的目录下

* 链接文件可以分为软链接与硬链接两种
> 软链接文件的读写就如同直接对目标文件进行操作，链接文件是一个独立文件，其存在并不依赖于目标文件
> 如果删除一个链接文件，它所指向的目标文件不受影响
> 如果删除了目标文件，其指向目标文件的链接文件依然存在

* 硬链接与目标文件使用同一个文件索引节点，因此只能在同一个磁盘分区中使用硬链接，并且它不能离开关联文件而独立存在
> 如果一个硬链接被移动，重命名或者删除时，其余关联到同一文件的硬链接不受影响
> 当最后一条指向该文件的硬链接被删除时，该文件内容会消失

* 软链接可以跨磁盘分区来进行目标文件的指定，而硬链接只能使用同一个磁盘分区中的文件

* 建立软链接和硬链接的命令在Linux系统中是相同的，都是ln命令，使用不同的选项以建立不同的连接方式

* ln命令的基本格式
> `ln [options] 目标文件 链接文件`
* 参数`-s`表示建立软链接，没有设置的情况下默认建立硬链接
* 目标文件可以是相对路径或绝对路径

* 在制作过程中，均使用软链接文件，即符号链接文件

---

4. 文件系统

* 文件系统是一种存储和组织计算机文件和数据的方法，以更容易的去访问和查找数据
* 文件系统类型一览
1. 磁盘文件系统:EXT2/3，XFS等等，可以直接应用在软硬盘存储设备上
2. 网络文件系统:NFS，CIFS等等
3.事务文件系统:AUFS等等
4. 内存文件系统:TmpFS等等，使用内存来模拟存储设备的文件系统，可以从内存中划出一块区域用于像磁盘文件系统那样来存放文件和目录
5. 特殊文件系统:proc，sysfs等等，具有特殊功能的文件系统，如内核文件系统

**文件系统的使用:**
* 文件系统在Linux系统中以挂载的方式使用，挂载工具为mount
> `mount [options] 设备名 目录名`
* 参数-t用于指定文件系统名称，一般mount会自动检测文件系统名称
* 如`mount /dev/sda3 /mnt`
> `/dev/sda3`是挂载分区，`/mnt`是被挂载的目录

---

5. 目录映射
* 子环境的运行方式和从分区启动的方式中，虽然根目录是一致的，但就整个系统来说还是有很多差别的
* 比如有些目录，类似于/dev或/proc等等中的内容都是系统启动过程中创建的，并且会在运行过程中发生变化
* 这些目录中的内容有时会影响系统的制作，如果想让两种方式的效果最为接近，就需要让这些目录中存放的内容相似
* 这些目录的内容多与内核相关，但子环境的运行方式所使用的是主系统中的内核
* 因此目标系统和主系统的内核应当尽量保存兼容，以此利用主系统中相应目录的内容来补充目标系统中的这些目录中的内容
* 想让主系统和目标系统对应目录中的内容保存一致，最容易的办法无非是复制目录，但因为/proc的内容是反应内核当前的情况(动态目录)，复制过来的目录并不能随着系统的运行而发生变化，所以不能采用复制的方法
* 可以用建立软链接文件的方式来让两个目录的内容一致而又不采用复制目录的方法
* 访问链接文件就如同访问它所链接到的目录一样，但软链接文件的一个问题就是目标文件或目录必须存在且可以被当前的运行环境所访问

**这里举一个例子:**
* 在主系统中的根目录下存在/proc目录，现在系统在/opt/目录下创建一个proc_a链接文件并指向/proc
* 当前运行环境中访问/opt/proc_a中的内容就如同访问/proc中的内容
* 但如果将/opt作为虚拟根目录启动一个新的运行环境时，原先的/opt/proc_a将变成/proc_a(此时此分区的文件目录与原主机的文件目录相隔离)
* 所以它指向的/proc无法在这个运行环境中被访问到，则会导致链接文件失效，所以链接文件的方法也不能使用
* 所以这里就要引出目录映射的概念了

**文件映射:**
* 被映射的源目录和映射目录内容上保存一致，对它们中任何一方目录内的改动都将直接导致另一方同样的修改
* 与链接文件处理方式不同，源目录和映射目录都必须是实际目录，而非链接文件
* 目录映射并不依赖源目录的存在位置，即使在建立好目录映射后，改变源目录的名称或者位置都不会影响到映射目录中的内容
* 因此使用映射方式建立的目录一致性将在进入新的运行环境中继续产生作用

* 映射目录方法所建立起的文件关联会直接涉及于文件所在磁盘的物理地址，所以不会因为别名或修改文件状态的操作而发生失效或错误

---

6. 工具链调整

*工具链从内部依赖转为外部依赖，不同外部依赖的转换，外部依赖转内部依赖，都属于调整依赖工具链
*调整工具链不存在内部依赖转内部依赖的情况

**这里举一个例子:**
* 将工具链分为三个部分并用实际的软件包名称来表示:
* 工具链=Binutils+GCC+Glibc
* 调整工具链的实质就是用新的Glibc代替工具链原来的Glibc，两个Glibc存放在不同目录
* 调整工具链的原因是要让工具链中的编译工具改变链接的函数库位置，这个改变只需要改变两个地方:GCC的编译配置和Binutils中ld命令的函数库查询目录
* GCC的编译默认配置被编译于GCC的相关文件中，GCC中的gcc命令有两种配置方式，一种是外部的配置文件，另一种是内部的默认配置
* gcc命令优先使用外部配置的方式，则修改配置文件就可以实现目的
* 因为GCC的配置文件很复杂而不便于重新编写，所以可采用gcc命令将默认配置导出，然后修改相应的内容并保存到特定的文件中的方法来实现目的
* gcc命令的默认导出配置方式的执行命令:`gcc -dumpspecs`
* 该命令将默认配置显示在屏幕上，只需要人为的将其存放到gcc读取配置文件的目录中
* gcc读取外部配置文件的目录可以使用此命令来获得:`dirname $(gcc -print-libgcc-file-name)`
* 该命令返回读取配置文件的目录名，接下来只需要在这个目录中创建一个名为specs的文件，并将已经人为配置完的配置文件存放在该目录中就可以了
* 执行该命令:`gcc -dumpspecs > $(dirname $(gcc -print-libgcc-file-name))/specs`
* 此时配置文件已经准备好了，目前这个文件中的内容和GCC的默认配置完全一个，只需要人为的将文件中的内容进行修改就行
* 该文件以文本内容存放，所以可以使用一般的文本编辑器来进行修改，也可以使用文本编辑器的命令来进行修改，如sed命令
* 修改其寻址函数库的目录为新函数库的所在目录即可

---
