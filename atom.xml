<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-09T05:29:31.777Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>变量-1</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E5%8F%98%E9%87%8F-1/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E5%8F%98%E9%87%8F-1/</id>
    <published>2020-03-09T05:12:41.000Z</published>
    <updated>2020-03-09T05:29:31.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>变量概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-变量"><a href="#计算机科学-变量" class="headerlink" title="计算机科学-变量"></a>计算机科学-变量</h2><ul><li>变量-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li><p>基本概念</p></li><li><p>概念整合</p></li><li><p>操作原理</p></li><li><p>标识原理</p></li><li><p>类型明细</p></li><li><p>内存分配</p></li><li><p>别名实现</p></li><li><p>参数明细</p></li><li><p>作用域与生命周期</p></li><li><p>线性表</p></li><li><p>数据结构-顺序存储结构</p></li><li><p>线性存储原理</p></li><li><p>堆栈</p></li></ul><hr><p><strong>任何数据类型与概念皆可称为变量，而变量也可以数据类型区分</strong></p><p><strong>函数结构化了变量，或称函数由变量构成</strong></p><hr><h2 id="变量概念明细"><a href="#变量概念明细" class="headerlink" title="变量概念明细:"></a>变量概念明细:</h2><ul><li>文字内关于变量的概念特指计算机科学内的变量概念</li><li>与数学间变量的概念会加以区分</li></ul><hr><p><strong>概述:</strong></p><ul><li>变量用于具体指向存储器内的存储空间的数据类型<blockquote><p>并且存储于变量内的数据是跟随程序的变化而变化的，这里类似于数学种变量的概念<br>每个不同的变量在计算机内所占有硬件的资源(存储空间或内存)都是有对应标识的(此标识概念被归纳于变量定义的概念内)</p></blockquote></li></ul><hr><p><strong>详细描述:</strong></p><ul><li>在计算机内，任何被人为定义的任何变量概念都是为了用于指向电脑内存储器的存储空间<blockquote><p>或称为，在计算机科学上，变量可以指在电脑存储器里存在值的被命名的存储空间</p></blockquote></li><li>变量所存储的内容被包含于变量的定义内，而变量名则是对于该变量所占用物理空间或称区域的命名与标识</li></ul><p><strong>语言区别:</strong></p><ul><li><p>各个程序语言之间对于变量的概念有不同的定义，但本质上都是相同的</p><blockquote><p>变量通常是可被修改的，即可以用来表示可变的状态<br>这是许多语言(如Java)的基本概念之一<br>有的语言可能定义其它术语，如C语言的左值来精确地表示这里的(可能匿名的)存储空间的概念<br>而”变量”则在变量名的意义上被强调<br>而还有些编程语言中的变量必须带有类型</p></blockquote></li><li><p>当某个已宣告变量开始使用，解释器或编译器通常会设置一个空间来存储所给出的值</p><blockquote><p>稍后该变量不再使用时，那些空间可以回收</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>也有观点认为，变量应该和数学的原意/义一致<blockquote><p>不需要允许它储存的值可变，不需要有能力表示可变状态<br>Haskell的类型变量仍然符合这个含义</p></blockquote></li></ul><hr><h2 id="概念理解整合"><a href="#概念理解整合" class="headerlink" title="概念理解整合"></a>概念理解整合</h2><ul><li>变量(Variable，scalar)</li></ul><p><strong>在程序设计中的变量所涉及的概念:</strong></p><ul><li>变量是指一个包含部分已知或未知数值或信息(即一个值)之/的存储地址<blockquote><p>以及相对应之符号名称(识别字)<br>通常使用变量名称引用存储值</p></blockquote></li></ul><p><strong>别名的意义(接上文识别字的概念):</strong></p><ul><li>用以将名称和内容分开，以能让被使用的名称独立于，所表示的精确消息之外</li><li>电脑源代码中的识别字能在运行期间绑扎一个值，且该变量的值可能在程序运行期间改变<blockquote><p>程序设计中的变量不一定能直接对应到数学中所谓的变量之概念<br>在程序设计中，变量的值不一定要为方程或数学公式之一部分</p></blockquote></li></ul><hr><p><strong>数理区别:</strong></p><ul><li>计算机变量与数学变量的区别:<blockquote><p>程序设计中的变量可使用在一段可重复的程序: 在一处赋值，然后使用于另一处，接着在一次赋值，且以相同方式再使用一次(涉及迭代概念)<br>程序设计中的变量通常会给定一个较长的名称，以描述其用途<br>而数学中的变量通常较为简洁，只给定一、两个字母，以方便抄写及操作</p></blockquote></li></ul><p><strong>别名简述:</strong></p><p><strong>变量别名/命名的概念:</strong></p><ul><li><p>一个变量的存储地址可以被不同的识别字所引用，这种情况称之为别名</p><blockquote><p>使用其中一个识别字为变量赋值，将会改变透过另一个识别字访问的值</p></blockquote></li><li><p>编译器必须将代表变量的名称替代成该数据所在的实际地址</p><blockquote><p>变量的名称，类型及地址通常会维持固定<br>但该地址所存储之数据于程序运行期间则可能会改变</p></blockquote></li></ul><hr><h2 id="变量各级操作的原理"><a href="#变量各级操作的原理" class="headerlink" title="变量各级操作的原理"></a>变量各级操作的原理</h2><h3 id="对于变量的使用"><a href="#对于变量的使用" class="headerlink" title="对于变量的使用:"></a>对于变量的使用:</h3><ul><li><p>又称引用变量</p><blockquote><p>涉及到标识符的概念</p></blockquote></li><li><p>标识符即为字符(人为输入的，用于识别所定义，或称所存在变量的字符串/数据类型)</p></li><li><p>用标识符引用变量能对变量进行访问，从而读出变量的值，改变变量的值</p><blockquote><p>或者改变变量的属性(如访问权限、状态锁定等)</p></blockquote></li><li><p>例如:</p><blockquote><p>一个变量用标识符<code>unit_serow</code>来引用<br>设定这个变量的值为1000<br>如果该变量同时也用<code>标识符g</code>来引用<br>然后通过<code>标识符g</code>将变量值改变为2000<br>那么读取<code>unit_serow</code>的值就是2000而不是1000</p></blockquote></li></ul><hr><ul><li><p>如果某种编程语言只允许同一个变量用一个标识符引用</p><blockquote><p>那么讨论”该变量的名字”就是有意义的，否则将其称之为”该变量的名字之一”</p></blockquote></li><li><p>例如:</p><blockquote><p>在前面的那个例子当中，<code>unit_serow</code>是这个变量的名字之一<br>而<code>标识符g</code>是这个变量的另外一个名字</p></blockquote></li></ul><hr><h3 id="对于变量的操作"><a href="#对于变量的操作" class="headerlink" title="对于变量的操作:"></a>对于变量的操作:</h3><ul><li><p>还可称为对于变量的管理</p></li><li><p>在指令式编程语言中</p><blockquote><p>变量的值通常能够随时访问或重新赋值</p></blockquote></li><li><p>但在逻辑式编程语言中</p><blockquote><p>根据参数透明的需求，变量被绑定到表达式并且在它的整个生命周期中保持同一个值</p></blockquote></li><li><p>在指令式编程语言中</p><blockquote><p>同样的行为用常量来表达，它和通常的变量存在反差</p></blockquote></li></ul><p><strong>不同语言的区别:</strong></p><ul><li>根据编程语言的类型系统的不同<blockquote><p>变量可能只存储一种特定的数据类型(如整型或字符串型)</p></blockquote></li><li>而另外一种情况，变量的数据类型能根据当前赋值而改变<blockquote><p>从而允许单个变量存储该编程语言支持的任何数据类型</p></blockquote></li></ul><hr><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ul><li><p>变量所涉及的不同类型</p></li><li><p>在静态类型语言中</p><blockquote><p>如Java或ML等<br>每个都变量有一个类型，也就是说只有给定种类的值能存储到该变量中<br>一个基本类型的变量只能保存基本类型的值<br>一个类类型的变量能保存空值NULL，或者保存该类型或其子类型的对象<br>一个接口类型的变量能保存空值NULL，或者该接口的任何一个实现<br>一个数组类型能保存空值NULL或者一个数组</p></blockquote></li><li><p>在动态类型语言中</p><blockquote><p>如Python等<br>便是是作为值而出现的，而不是变量来携带类型信息<br>在Common Lisp中，这两种情况同时存在:<br>变量在编译时具有一个类型(如果没有声明，就假设这个类型为超类型T)<br>值也有具有一个类型，该类型可以在运行时进行检查和识别</p></blockquote></li><li><p>变量的类型也允许在编译时多态决定</p><blockquote><p>但是，这和面向对象的函数调用(在C++中称为虚函数)的多态不同</p></blockquote></li><li><p>变量常常保存简单的数据，如整数和字符串</p><blockquote><p>但有些程序设计语言允许变量同时表示多种数据类型<br>这些语言一般也允许函数参数多态<br>其函数对变量的操作可同时适用于多种数据类型</p></blockquote></li><li><p>例如:</p><blockquote><p><code>函数length</code>可以求一个列表的长度<br>如果length的类型签名中包含一个类型变量，就可以实现参数多态<br>这样，求列表中的元素个数就与列表元素的类型无关了</p></blockquote></li></ul><hr><h3 id="变量的参数概念"><a href="#变量的参数概念" class="headerlink" title="变量的参数概念"></a>变量的参数概念</h3><ul><li><p>函数的形式参数也被称为变量</p></li><li><p>如下的C++代码段：</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> AddTwo(<span class="built_in">int</span> x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AddTwo(<span class="number">5</span>);  <span class="comment">// 结果为7</span></span><br></pre></td></tr></table></figure><ul><li>其中变量x是”形参”<blockquote><p>因为当函数被调用时会被给定一个值</p></blockquote></li><li>整数5是”实参”<blockquote><p>它给x一个值</p></blockquote></li><li>在多数语言中，函数参数具有局部的作用域<blockquote><p>这里的变量x只能在<code>AddTwo函数</code>中有效(尽管如此，其他函数也可以使用自己的变量x)</p></blockquote></li></ul><hr><h3 id="变量所对应的内存-底层概念"><a href="#变量所对应的内存-底层概念" class="headerlink" title="变量所对应的内存-底层概念"></a>变量所对应的内存-底层概念</h3><ul><li>线性存储结构(堆栈原理)示意图:<blockquote><p>线性表的顺序存储示意图</p></blockquote></li></ul><img src="/images/内存-1.png" width="40%" height="40%"><hr><ul><li><p>变量的内存分配</p></li><li><p>变量的内存空间分配和它们值的表示方法是多种多样的，这种区别体现在语言之间</p><blockquote><p>也体现在给定语言的内部使用上<br>很多语言都实现了局部变量的空间分配方式<br>局部变量保存在调用堆栈上，其生存周期维持在单个函数中，函数返回时这些内存会自动被回收(更一般的讲，变量的名字是和一些特定的连续内存块的地址绑定，对变量的操作其实是对相应的内存块进行操作)<br>对于巨大或者编译时不知道大小的数据，更常用的方法是使用”引用”<br>这时记录是值的地址而不是值本身，它们是从一种被称为栈的内存池中分配的</p></blockquote></li><li><p>绑定的变量具有值，一个抽象的值</p><blockquote><p>在程序执行时，变量的值用计算机内存中存储的一些数据对象来表示<br>程序，或者说运行时环境，必须为每个数据对象设置内存<br>由于内存是有限的<br>为了安置每一个数据对象，当数据对象不再表示某个变量的值时，相应的内存会被回收并重新使用</p></blockquote></li><li><p>在堆中分配的对象必须被释放掉，特别是当对象不再被需要时</p><blockquote><p>在具有垃圾回收机制的语言(如C#、Java和Lisp)中<br>当变量出了其作用域再也不能被引用时运行环境会自动地回收对象<br>在不具有垃圾回收机制的语言当中<br>如C语言，程序(程序员)必须显式地分配内存，而且用完之后还要释放内存<br>如果没有这样做会造成内存泄漏<br>在这种情况下，程序运行过程中堆会逐渐消耗，最终因为内存耗尽而崩溃</p></blockquote></li><li><p>当一个变量指向动态创建的数据结构时</p><blockquote><p>可能其中一些部分只能通过变量间接的访问<br>在这种环境下，垃圾回收器(或者类似的语言特性)必须处理当变量回收时只有一部分内存能够获得的情况</p></blockquote></li></ul><hr><h3 id="变量命名的原理"><a href="#变量命名的原理" class="headerlink" title="变量命名的原理"></a>变量命名的原理</h3><ul><li><p>即为变量的命名规范</p></li><li><p>与数学当中的量不同，程序设计所用的变量和常量通常都采用多字符的名字，如<code>count</code>或者<code>size</code></p><blockquote><p>而单个字符的名字一般仅用于辅助性的变量，如<code>i</code>，<code>j</code>，<code>k</code>常作为数组索引的变量</p></blockquote></li><li><p>一些命名规范是作为语法在语言层面强制执行的</p><blockquote><p>在大多数语言当中，变量名不能以数字开头，不能包含空格符<br>而标点符号是否允许存在在变量名当中就要视具体语言而定了<br>很多语言仅仅允许<code>下划线&#39;_&#39;</code>存在在变量名当中，而禁止其他所有的标点符号<br>而有些编程语言，特殊字符作为前缀或后缀添加在变量标识符当中来表明变量的类型<br>变量名的大小写敏感性也要视具体语言而定<br>大多数现代语言是大小写敏感的，一些较老的语言则不敏感<br>一些语言保留特定形式的变量名用来内部使用<br>在很多语言中，以两根下划线开头<code>__</code>的变量名常充当这种角色</p></blockquote></li><li><p>在语言语法基本的限制以外，进一步的命名风格规范也很有必要</p><blockquote><p>在机器码层面，是不会使用变量名的<br>所以计算机并不关心是否采用了准确的名字<br>正因为如此，变量名完全是作为程序员的工具而存在<br>借助这个工具程序员能更容易的编写和理解程序<br>程序员通常创建编码规范，并且坚持这些规范<br>帮助对变量命名甚至提供精确的命名规划。较短的名字便于输入<br>但是描述能力较差<br>较长的名字使程序更容易读懂，变量的意图更容易理解<br>尽管如此，冗长的变量名也可能会导致更难理解的代码</p></blockquote></li></ul><hr><p><strong>不同情况下命名规范的区别:</strong></p><ul><li><p>在源代码中</p><blockquote><p>在源代码中，变量名是将变量和内存地址绑定的一种方式<br>变量值以数据对象的形式存储在相应的地址内<br>这样该数据对象就能通过变量的名字进行访问和修改了</p></blockquote></li><li><p>在电子表格中</p><blockquote><p>在电子表格中，一个单元格可能包含参考其他单元格的公式<br>这种被参考的单元格就是一种形式的变量<br>它的值就是被参考的单元格的值</p></blockquote></li></ul><hr><h3 id="变量的作用域和生存周期"><a href="#变量的作用域和生存周期" class="headerlink" title="变量的作用域和生存周期"></a>变量的作用域和生存周期</h3><p><strong>变量作用于生存周期域的概念:</strong></p><ul><li><p>变量的作用域表示变量在原程序的文本中能被使用的范围</p><blockquote><p>变量的生存周期表示变量在程序运行过程中具有实际意义的值的时间范围<br>变量的作用域事实上是变量名字的性质<br>而变量的生存周期是变量本身是性质</p></blockquote></li><li><p>变量名字的作用域会影响它的生存周期</p></li><li><p>作用域是变量语法方面的性质</p><blockquote><p>多数语言对每一个变量(和其他名目实体)定义明确的作用域<br>这些作用域在同一个程序中可能不同<br>变量的作用域是指程序中的特定区域，在这些区域中，该变量的名字是有意义的并且变量是”可见的”<br>在进入作用域时，变量通常开始它的生命周期<br>而在离开作用域时，变量往往结束了它的生命周期</p></blockquote></li><li><p>例如:</p><blockquote><p>某个变量的语法作用域仅在特定的语句块或者子程序中<br>只有在某个函数中能访问的变量则被称为局部变量<br>在程序的任何一个地方都能引用的变量被称为全局变量</p></blockquote></li><li><p>生存周期，则是变量在运行时的性质</p><blockquote><p>在运行时，每次变量与值的绑定都具有自己的生存周期<br>绑定的生存周期是程序执行过程中的一段时间<br>在这段时间内，变量始终被关联到相同的值或者内存位置<br>在闭包的情况中，运行中的程序可能进入和离开某个生存周期很多次</p></blockquote></li><li><p>在一些代码段中，在一个变量的作用域中可能未被赋值，或者它的值已经被销毁掉了</p><blockquote><p>这类变量常被称为”生存周期外”或者”未绑定”<br>在很多语言中，试图使用未绑定的变量是一个错误<br>在其他语言中，这种行为会产生不可预期的结果，这样的变量可能被分配一个新的值<br>与之对照的是，一个变量绑定到一个超过他作用域的生存周期是被允许的<br>如Lisp的闭包和C语言的静态局部变量<br>当程序再次执行到变量的作用域时<br>变量能再次被使用，但还保持上一次的值</p></blockquote></li><li><p>为了提高空间效率，变量需要的存储空间可能要等到变量第一次使用时才申请</p><blockquote><p>不再使用后就删除<br>为了避免浪费空间，如果变量声明了但不实际使用<br>编译器通常会向程序员发出警告</p></blockquote></li><li><p>使变量的作用域尽可能的小，被认为是一个好的编程方式</p><blockquote><p>这样程序的不同部分就不会因为意外的改变对方的变量而互相影响了<br>实现上述目标的通常技术是让程序的不同部分使用不同名字空间<br>或者通过动态变量作用使用各自的私有变量</p></blockquote></li><li><p>很多程序设计语言使用保留的值(如NULL)表示没有初始化的变量</p></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下参考资料皆源于中文维基</strong></p><ul><li><p>CN-分类:变量(<a href="https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</a>)</p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8F%98%E9%87%8F</code></p></blockquote></li><li><p>CN-分类:计算机编程<a href="https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B</code></p></blockquote></li><li><p>CN-变量<a href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8</code></p></blockquote></li><li><p>CN-变量 (程序设计)<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%8F%98%E9%87%8F_(%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)</code></p></blockquote></li></ul><hr><h2 id="补充内容-C-C"><a href="#补充内容-C-C" class="headerlink" title="补充内容-C/C++"></a>补充内容-C/C++</h2><ul><li>C/C++内变量的意义与应用<blockquote><p>见下一篇文章</p></blockquote></li></ul><h3 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h3><ul><li><p>相对于编程语言(程序语言)</p></li><li><p>调用各种函数，利用正确的逻辑，来构成一个完整的程序</p></li></ul><p><strong>大体逻辑:</strong></p><ul><li><p>在函数外，也就是整个程序的内部可以定义各种常量</p><blockquote><p>然后定义各种函数，函数内定义各种变量，由变量构成各种语句<br>所谓的函数就是存储这些由变量构成的语句的区块(块结构)</p></blockquote></li><li><p>一个函数便可以称之为一个程序，或是一个功能</p><blockquote><p>之后再由若干个函数来构成一个完整的程序<br>每个函数中都应当有返回值</p></blockquote></li><li><p>所谓的常量，就是在程序当中，可以被任何函数所调用的数据类型</p></li><li><p>调用就是(即为)使用，函数就是方法，指针就是指针，用来指向某种数据类型(函数，变量等)并直接调用</p></li></ul><hr><ul><li>数据类型构建了变量与表达式</li><li>变量与表达式构建了函数</li><li>函数构建了各级功能</li><li>各级功能构建了完整的程序</li><li>其中在构建各个不同级次的程序时需要完整且正确的逻辑</li><li>在函数内的表达式与变量亦是如此</li><li>表达式，变量与函数都可以被合称为数据类型，包括指针或空值</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;变量概念理解-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>NCRE-1</title>
    <link href="https://unit-serow.github.io/2020/03/08/NCRE-1/"/>
    <id>https://unit-serow.github.io/2020/03/08/NCRE-1/</id>
    <published>2020-03-08T06:24:42.000Z</published>
    <updated>2020-03-09T05:29:55.353Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>基础概念-数据结构与算法</strong></center><a id="more"></a><h2 id="NCRE-1"><a href="#NCRE-1" class="headerlink" title="NCRE-1"></a>NCRE-1</h2><hr><h3 id="公共基础知识-1"><a href="#公共基础知识-1" class="headerlink" title="公共基础知识-1"></a>公共基础知识-1</h3><ul><li><p>网课随堂笔记</p></li><li><p>二级公共基础知识-数据结构与算法</p></li></ul><hr><p><strong>数据结构与算法</strong></p><ul><li><p>包含内容于:</p><blockquote><p>算法复杂度<br>数据结构的概念<br>栈<br>二叉树的遍历<br>二分法查找</p></blockquote></li><li><p>涉及概念:</p><blockquote><p>算法的概念，算法时间复杂度及空间复杂度的概念<br>数据结构的定义，数据逻辑结构及物理结构的定义<br>栈的定义及其运算，线性链表的存储方式<br>树与二叉树的概念，二叉树的基本性质，完全二叉树的概念，二叉树的遍历<br>二分查找法<br>冒泡排序法</p></blockquote></li></ul><p>–</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="算法的基本概念"><a href="#算法的基本概念" class="headerlink" title="算法的基本概念"></a>算法的基本概念</h3><ul><li><p>计算机解题的过程实际上是在实施某种算法，这种算法称为计算机算法</p></li><li><p>算法即为为解决任何问题而产生出的必要方法，语言，思维或逻辑的本质也可称为算法</p></li><li><p>算法的基本特征：可行性，确定性，有穷性，拥有足够的情报</p></li></ul><p><strong>算法的基本要素:</strong></p><ol><li>算法中对数据的运算和操作</li></ol><ul><li><p>一个算法由两种基本要素组成：</p><blockquote><p>一是对数据对象的运算和操作<br>二是算法的控制结构</p></blockquote></li><li><p>在一般的计算机系统中，基本的运算和操作有以此四类：算术运算，逻辑运算，关系运算和数据传输</p></li></ul><ol start="2"><li>算法的控制结构：<blockquote><p>算法中各操作之间的执行顺序称为算法的控制结构</p></blockquote></li></ol><ul><li><p>描述算法的工具通常有：</p><blockquote><p>传统的流程图，N-S结构化流程图，算法描述语言等</p></blockquote></li><li><p>一个算法一般都可以用顺序，选择，循环3种基本控制结构组合而成</p></li></ul><hr><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>算法复杂度包括算法时间复杂度及空间复杂度的概念</li></ul><ol><li>算法的时间复杂度<blockquote><p>算法的时间复杂度是指执行算法所需要的计算工作量<br>同一个算法用不同的语言实现，或者用不同的编译程序进行编译，或者在不同的计算机上运行，效率均不同<br>这表明使用绝对的时间单位衡量算法的效率是不合适的<br>撇开这些与计算机硬件，软件有关的因素，可以认为一个特定算法”运行工作量”的大小，只依赖于问题的规模(通常用整数n表示)，它是问题规模的函数<br>即为<br><code>算法的工作量=f(n)</code></p></blockquote></li></ol><p>2.算法的空间复杂度</p><blockquote><p>算法的空间复杂度是指执行这个算法所需要的内存空间<br>一个算法所占用的存储空间包括算法程序所占的空间<br>输入的初始数据所占的存储空间以及算法执行过程中所需要的额外空间<br>其中额外空间包括算法程序执行过程中的工作单元以及某种数据结构所需要的附加存储空间<br>如果额外空间量相对于问题规模来说是常数，则称该算法是原地工作的<br>在许多实际问题中，为了减少算法所占的存储空间，通常采用压缩存储技术，以便尽量减少不必要的额外空间</p></blockquote><ul><li>算法的工作量用算法所执行的基本运算次数来计算，而算法所执行的基本运算次数是问题规模的函数，即算法的工作量=f(n)<blockquote><p>n为问题规模</p></blockquote></li></ul><hr><h2 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h2><h2 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h2><ul><li><p>数据的逻辑结构和存储结构的概念</p></li><li><p>数据结构作为计算机的一门学科，主要研究和讨论以下三个方面：</p></li></ul><ol><li>数据集合中个数据元素之间所固有的逻辑关系，即数据的逻辑结构</li><li>在对数据元素进行处理时，各数据元素在计算机中的存储关系，即数据的存储结构</li><li>对各种数据结构进行的运算</li></ol><ul><li><p>数据结构基本概念：</p><blockquote><p>数据：是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符号的总称<br>数据元素：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理<br>数据对象：是性质相同的数据元素的集合，是数据的一个子集</p></blockquote></li><li><p>数据的逻辑结构是对数据元素之间的逻辑关系的描述</p><blockquote><p>它可以用一个数据元素的集合和定义在此集合中的若干关系来表示<br>数据的逻辑结构有两个要素：<br>一是数据元素的集合，通常记为D<br>二是D上的关系，它反映了数据元素之间的前后件关系，通常记为R</p></blockquote></li><li><p>一个数据结构可以表示成：<code>B=(D,R)</code></p><blockquote><p>其中B表示数据结构<br>为了反映D中各数据元素之间的前后件关系，一般用二元组来表示</p></blockquote></li><li><p>数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构(也称数据的物理结构)</p></li><li><p>由于数据元素在计算机存储空间中的位置关系可能与逻辑关系不同</p><blockquote><p>因此，为了表示存放在计算机存储空间中的各数据元素之间的逻辑关系(即前后件关系)<br>在数据的存储结构中，不仅要存放各数据元素的信息，还需要存放各数据元素之间的前后件关系的信息</p></blockquote></li><li><p>一种数据的逻辑结构根据需要可以表示成多种存储结构</p><blockquote><p>常用的存储结构有顺序，链接，索引等存储结构<br>而采用不同的存储结构，其数据处理的效率是不同的<br>因此，在进行数据处理时，选择合适的存储结构是很重要的</p></blockquote></li></ul><hr><h3 id="线性结构与非线性结构"><a href="#线性结构与非线性结构" class="headerlink" title="线性结构与非线性结构"></a>线性结构与非线性结构</h3><ul><li><p>根据数据结构中各数据元素之间前后件关系的复杂程度</p><blockquote><p>一般将数据结构分为两大类型：线性结构与非线性结构</p></blockquote></li><li><p>如果一个非空的数据结构满足下列两个条件：</p></li></ul><ol><li>有且只有一个根结点</li><li>每一个结点最多有一个前件，也最多有一个后件<blockquote><p>则称该数据结构为线性结构<br>线性结构又称线性表<br>在一个线性结构中插入或删除任何一个结点后还应是线性结构<br>如果一个数据结构不是线性结构，则称之为非线性结构</p></blockquote></li></ol><ul><li>空的数据结构被归于线性结构还是非线性结构的条件:<blockquote><p>一个空的数据结构究竟是属于线性结构还是属于非线性结构，这要根据具体情况来确定<br>如果对该数据结构的算法是按线性结构的规则来处理的，则属于线性结构<br>否则属于非线性结构</p></blockquote></li></ul><hr><h2 id="栈及线性链表"><a href="#栈及线性链表" class="headerlink" title="栈及线性链表"></a>栈及线性链表</h2><h3 id="栈及其基本运算"><a href="#栈及其基本运算" class="headerlink" title="栈及其基本运算"></a>栈及其基本运算</h3><ul><li>涉及栈的运算</li></ul><ol><li>栈的基本概念<blockquote><p>栈是限定只在一端进行插入与删除的线性表，通常称插入，删除的这一端为栈顶，另一端为栈底<br>当表中没有元素时称为空栈<br>栈顶元素总是后被插入的元素，从而也是最先被删除的元素<br>栈底元素总是最先被插入的元素，从而也是最后才能被删除的元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据的</li></ul><ol start="2"><li>栈的顺序存储及其运算</li></ol><ul><li>用一维数组<code>S(1 : m)</code>作为栈的顺序存储空间，其中m为最大容量<blockquote><p>在栈的顺序存储空间S<code>(1∶m)</code>中<br><code>S(bottom)</code>为栈底元素，<code>S(top)</code>为栈顶元素<br><code>top=0</code>表示栈空<br><code>top=m</code>表示栈满</p></blockquote></li></ul><p><strong>栈的基本运算</strong></p><ul><li>可将其归纳为三种: 入栈，退栈与读栈顶元素</li></ul><ol><li><p>入栈运算：入栈运算是指在栈顶位置插入一个新元素</p><blockquote><p>首先将栈顶指针加一(即top加1)，然后将新元素插入到栈顶指针指向的位置<br>当栈顶指针已经指向存储空间的最后一个位置时，说明栈空间已满，不可能再进行入栈操作<br>这种情况称为栈”上溢”错误</p></blockquote></li><li><p>退栈运算：退栈是指取出栈顶元素并赋给一个指定的变量</p><blockquote><p>首先将栈顶元素(栈顶指针指向的元素)赋给一个指定的变量，然后将栈顶指针减一(即top减1)<br>当栈顶指针为0时，说明栈空，不可进行退栈操作<br>这种情况称为栈的”下溢”错误</p></blockquote></li><li><p>读栈顶元素：读栈顶元素是指将栈顶元素赋给一个指定的变量</p><blockquote><p>这个运算不删除栈顶元素，只是将它赋给一个变量，因此栈顶指针不会改变<br>当栈顶指针为0时，说明栈空，读不到栈顶元素</p></blockquote></li></ol><ul><li>栈是按照”先进后出”或”后进先出”的原则组织数据，但是出栈方式有多种选择</li></ul><hr><h3 id="线性链表的基本概念"><a href="#线性链表的基本概念" class="headerlink" title="线性链表的基本概念"></a>线性链表的基本概念</h3><ul><li><p>涉及结点的组成</p></li><li><p>在链式存储方式中，要求每个结点由两部分组成：</p><blockquote><p>一部分用于存放数据元素值，称为数据域<br>另一部分用于存放指针，称为指针域<br>其中指针用于指向该结点的前一个或后一个结点(即前件或后件)</p></blockquote></li><li><p>链式存储方式既可用于表示线性结构，也可用于表示非线性结构</p></li></ul><p><strong>线性链表</strong></p><ul><li>线性表的链式存储结构称为线性链表<blockquote><p>在某些应用中，对线性链表中的每个结点设置两个指针<br>一个称为左指针，用以指向其前件结点<br>另一个称为右指针，用以指向其后件结点<br>这样的表称为双向链表</p></blockquote></li></ul><p><strong>带链的栈</strong></p><ul><li><p>栈也是线性表，也可以采用链式存储结构</p><blockquote><p>带链的栈可以用来收集计算机存储空间中所有空闲的存储结点<br>这种带链的栈称为可利用栈</p></blockquote></li><li><p>在链式结构中，存储空间位置关系与逻辑关系:</p><blockquote><p>在链式存储结构中，存储数据结构的存储空间可以不连续<br>各数据结点的存储顺序与数据元素之间的逻辑关系可以不一致<br>而数据元素之间的逻辑关系是由指针域来确定的</p></blockquote></li></ul><hr><h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><h3 id="树与二叉树及其基本性质"><a href="#树与二叉树及其基本性质" class="headerlink" title="树与二叉树及其基本性质"></a>树与二叉树及其基本性质</h3><ul><li><p>涉及树及二叉树的性质</p></li><li><p>误区警示: 满二叉树也是完全二叉树，而完全二叉树一般不是满二叉树</p></li><li><p>结构示意图:</p></li></ul><img src="/images/二叉树-1.png" width="40%" height="40%"> <img src="/images/二叉树-2.png" width="40%" height="40%"><hr><p><strong>树的基本概念</strong></p><ul><li>树(tree)是一种简单的非线性结构<blockquote><p>在树结构中，每一个结点只有一个前件，称为父结点<br>没有前件的结点只有一个，称为树的根结点<br>每一个结点可以有多个后件，它们称为该结点的子结点<br>没有后件的结点称为叶子结点</p></blockquote></li></ul><ul><li>在树结构中，一个结点所拥有的后件个数称为该结点的度<blockquote><p>叶子结点的度为0<br>在树中，所有结点中的最大的度称为树的度</p></blockquote></li></ul><p><strong>二叉树的定义及其基本性质</strong></p><p><strong>二叉树的定义</strong></p><ul><li><p>二叉树是一种很有用的非线性结构</p></li><li><p>具有以下两个特点:</p><blockquote><p>1-非空二叉树只有一个根结点<br>2-每一个结点最多有两棵子树，且分别称为该结点的左子树和右子树</p></blockquote></li><li><p>由以上特点可以看出:</p><blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树（左子树或右子树）也均为二叉树<br>而树结构中的每一个结点的度可以是任意的<br>另外，二叉树中的每个结点的子树被明显地分为左子树和右子树</p></blockquote></li><li><p>在二叉树中，一个结点可以只有左子树而没有右子树</p><blockquote><p>也可以只有右子树而没有左子树<br>当一个结点既没有左子树也没有右子树时，该结点即为叶子结点</p></blockquote></li></ul><hr><p><strong>二叉树的基本性质</strong></p><ul><li><p>二叉树具有以下几个性质：</p><blockquote><p>性质1：在二叉树的第k层上，最多有<code>2k-1 (k≥1)</code>个结点<br>性质2：深度为m的二叉树最多有<code>2m-1</code>个结点<br>性质3：在任意一棵二叉树中，度为0的结点(即叶子结点)总是比度为2的结点多一个<br>性质4：具有n个结点的二叉树，其深度至少为<code>[log2n]+1</code><br>其中[log2n]表示取log2n的整数部分<br>因为文本无法输入下标，所以本文中所有log2n都用于表示已2为底n的对数</p></blockquote></li><li><p>在二叉树的遍历中，无论是前序遍历，中序遍历还是后序遍历，二叉树的叶子结点的先后顺序都是不变的</p></li></ul><hr><p><strong>满二叉树与完全二叉树</strong></p><p><strong>满二叉树</strong></p><ul><li><p>满二叉树是指这样的一种二叉树:</p><blockquote><p>除最后一层外，每一层上的所有结点都有两个子结点<br>在满二叉树中，每一层上的结点数都达到最大值<br>即在满二叉树的第k层上有<code>2k-1</code>个结点，且深度为m的满二叉树有<code>2m-1</code>个结点</p></blockquote></li><li><p>完全二叉树是指这样的二叉树:</p><blockquote><p>除最后一层外，每一层上的结点数均达到最大值<br>在最后一层上只缺少右边的若干结点</p></blockquote></li><li><p>对于完全二叉树来说，叶子结点只可能在层次最大的两层上出现：</p><blockquote><p>对于任何一个结点，若其右分支下的子孙结点的最大层次为p<br>则其左分支下的子孙结点的最大层次或为p，或为<code>p+1</code></p></blockquote></li></ul><p><strong>完全二叉树</strong></p><ul><li><p>完全二叉树具有以下两个性质(接上文二叉树的基本性质):</p><blockquote><p>性质5: 具有n个结点的完全二叉树的深度为`[log2n]+1</p></blockquote></li><li><p>性质6: 设完全二叉树共有n个结点</p><blockquote><p>如果从根结点开始，按层次(每一层从左到右)用自然数<code>1，2，……，n</code>给结点进行编号<br>则对于编号为k（k=1，2，……，n）的结点有以下结论:<br>1-若<code>k=1</code>，则该结点为根结点，它没有父结点<br>若<code>k&gt;1</code>，则该结点的父结点编号为<code>INT(k/2) 2-若</code>2k≤n<code>，则编号为k的结点的左子结点编号为2k 否则该结点无左子结点(显然也没有右子结点) 3-若</code>2k+1≤n<code>，则编号为k的结点的右子结点编号为</code>2k+1`<br>否则该结点无右子结点</p></blockquote></li></ul><hr><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ul><li><p>涉及遍历的具体算法，以及能由两种遍历的结果推导另一种遍历的结果</p></li><li><p>在遍历二叉树的过程中，一般先遍历左子树，再遍历右子树</p></li><li><p>在先左后右的原则下，根据访问根结点的次序，二叉树的遍历分为三类:</p><blockquote><p>前序遍历，中序遍历和后序遍历</p></blockquote></li></ul><ol><li><p>前序遍历：先访问根结点、然后遍历左子树，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先访问根结点<br>然后遍历左子树，最后遍历右子树</p></blockquote></li><li><p>中序遍历：先遍历左子树、然后访问根结点，最后遍历右子树</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后访问根结点，最后遍历右子树</p></blockquote></li><li><p>后序遍历：先遍历左子树，然后遍历右子树，最后访问根结点</p><blockquote><p>并且，在遍历左、右子树时，仍然先遍历左子树<br>然后遍历右子树，最后访问根结点</p></blockquote></li></ol><ul><li>树与二叉树的不同之处<blockquote><p>在二叉树中，每一个结点的度最大为2<br>即所有子树(左子树或右子树)也均为二叉树<br>而树结构中的每一个结点的度可以是任意的</p></blockquote></li></ul><hr><h2 id="查找技术"><a href="#查找技术" class="headerlink" title="查找技术"></a>查找技术</h2><h3 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h3><ul><li><p>涉及顺序查找的算法</p></li><li><p>查找是指在一个给定的数据结构中查找某个指定的元素</p><blockquote><p>从线性表的第一个元素开始，依次将线性表中的元素与被查找的元素相比较<br>若相等则表示查找成功<br>若线性表中所有的元素都与被查找元素进行了比较但都不相等<br>则表示查找失败</p></blockquote></li><li><p>在下列两种情况下也只能采用顺序查找：</p></li></ul><ol><li>如果线性表为无序表，则不管是顺序存储结构还是链式存储结构，只能用顺序查找</li><li>即使是有序线性表，如果采用链式存储结构，也只能用顺序查找</li></ol><hr><h3 id="二分法查找"><a href="#二分法查找" class="headerlink" title="二分法查找"></a>二分法查找</h3><ul><li><p>涉及二分查找法的算法</p></li><li><p>二分法只适用于顺序存储的，按非递减排列的有序表，其方法如下：</p><blockquote><p>设有序线性表的长度为n，被查找的元素为i<br>1-将i与线性表的中间项进行比较<br>2-若i与中间项的值相等，则查找成功<br>3-若i小于中间项，则在线性表的前半部分以相同的方法查找<br>4-若i大于中间项，则在线性表的后半部分以相同的方法查找</p></blockquote></li><li><p>二分查找法适用情况</p><blockquote><p>二分查找法只适用于顺序存储的有序表<br>在此所说的有序表是指线性表中的元素按值非递减排列(即从小到大，但允许相邻元素值相等)<br>这个过程一直进行到查找成功或子表长度为0为止<br>对于长度为n的有序线性表，在最坏情况下，二分查找只需要比较<code>log2n</code>次</p></blockquote></li></ul><hr><h3 id="排序技术"><a href="#排序技术" class="headerlink" title="排序技术"></a>排序技术</h3><ul><li><p>交换类排序法</p></li><li><p>涉及排序算法的基本过程</p></li><li><p>冒泡排序法和快速排序法都属于交换类排序法</p></li></ul><p><strong>冒泡排序法</strong></p><ol><li><p>首先，从表头开始往后扫描线性表，逐次比较相邻两个元素的大小</p><blockquote><p>若前面的元素大于后面的元素，则将它们互换，不断地将两个相邻元素中的大者往后移动<br>最后最大者到了线性表的最后</p></blockquote></li><li><p>然后，从后到前扫描剩下的线性表，逐次比较相邻两个元素的大小，若后面的元素小于前面的元素，则将它们互换</p><blockquote><p>不断地将两个相邻元素中的小者往前移动<br>最后最小者到了线性表的最前面</p></blockquote></li><li><p>对剩下的线性表重复上述过程，直到剩下的线性表变空为止，此时已经排好序</p><blockquote><p>在最坏的情况下，冒泡排序需要比较次数为<code>n(n－1)/2</code>次</p></blockquote></li></ol><p><strong>快速排序法</strong></p><ul><li><p>它的基本思想是：</p><blockquote><p>任取待排序序列中的某个元素作为基准(一般取第一个元素)<br>通过一趟排序，将待排元素分为左右两个子序列<br>左子序列元素的排序码均小于或等于基准元素的排序码<br>右子序列的排序码则大于基准元素的排序码<br>然后分别对两个子序列继续进行排序<br>直至整个序列有序。</p></blockquote></li><li><p>冒泡排序和快速排序的平均执行时间:</p><blockquote><p>冒泡排序法的平均执行时间是O(n2)<br>而快速排序法的平均执行时间是O(nlog2n)</p></blockquote></li></ul><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong>以下内容参考自中文维基:</strong></p><ul><li><p>CN-具体数学<a href="https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%85%B7%E9%AB%94%E6%95%B8%E5%AD%B8</code></p></blockquote></li><li><p>CN-线性代数<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0</code></p></blockquote></li><li><p>CN-离散数学<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6</code></p></blockquote></li><li><p>CN-概率论<a href="https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E8%AE%BA</code></p></blockquote></li><li><p>CN-二分查找算法<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B%E6%BC%94%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-算法分析<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90</code></p></blockquote></li><li><p>CN-排序算法<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95</code></p></blockquote></li><li><p>CN-数据结构<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</code></p></blockquote></li><li><p>CN-二叉树<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li><li><p>CN-Category:Binary trees<a href="https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://commons.wikimedia.org/wiki/Category:Binary_trees?uselang=zh-cn</code></p></blockquote></li><li><p>CN-分类-二叉树<a href="https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E4%BA%8C%E5%8F%89%E6%A0%91</code></p></blockquote></li></ul><p><strong>以下为已使用电子书籍资源:</strong></p><ul><li><p>全国计算机二级考试公共基础知识完整版整合</p></li><li><p>计算机二级公共基础知识完整</p></li><li><p>二级公共基础知识电子书</p></li><li><p>公共基础知识总和本(无密)</p></li><li><p>资源获取-百度网盘(永久链接)<a href="https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w" target="_blank" rel="noopener">跳转</a></p><blockquote><p>链接: <code>https://pan.baidu.com/s/1r1pp7C9RCSqOGQ_YiqdK4w</code><br>提取码: aynj</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;基础概念-数据结构与算法&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>MS-SQL-1</title>
    <link href="https://unit-serow.github.io/2020/03/07/MS-SQL-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/MS-SQL-1/</id>
    <published>2020-03-07T08:43:29.000Z</published>
    <updated>2020-03-07T08:59:01.899Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>Access/MS SQL基本概念归纳</strong></center><a id="more"></a><h2 id="MS-SQL-1"><a href="#MS-SQL-1" class="headerlink" title="MS SQL-1"></a>MS SQL-1</h2><ul><li><p>网课随堂笔记</p></li><li><p>Access</p></li><li><p>MS SQL</p></li><li><p>数据库基础概念相关知识(数据抽象/数据模型/关系模型/各级关系运算)</p></li></ul><hr><h3 id="1-数据抽象"><a href="#1-数据抽象" class="headerlink" title="1. 数据抽象"></a>1. 数据抽象</h3><ul><li>设计数据库就是对数据的抽象过程:<blockquote><p><code>用户需求-抽象-&gt;概念模型-转换-&gt;[逻辑数据模型(外部模型)]-&gt;物理模型-&gt;数据库</code></p></blockquote></li><li>物理模型用于实现在数据库中对数据的存储</li><li>设计数据库的主要工作是构造数据模型</li><li>数据模型是对现实世界中数据特征的抽象</li><li>数据抽象中的数据模型主要有四种</li><li>概念模型 实体联系模型，可用于表达用户需求观点的数据全局逻辑结构的模型</li><li>ER图表示，ER图通常需要进行优化<blockquote><p><code>局部概念模型-&gt;全局概念模型</code></p></blockquote></li><li>ER图通常十分直观且形象</li></ul><hr><ul><li>逻辑模型<blockquote><p>用于表达计算机实现观点的数据库全局逻辑结构的模型<br>以树结构组织数据被称为层次模型<br>以网状结构组织数据称为网状模型<br>以二维表组织数据称之为关系模型(通常为主流数据模型)<br>ER图转化为逻辑模型<br>一对多，多对多，一对一，数据结构中存在几个实体对象，就将之称为几元联系<br>关系模式-(关系名-&gt;属性名)</p></blockquote></li><li>所有实体对象的集合被称之为关系</li></ul><hr><ul><li>内部模型<blockquote><p>即为物理模型<br>是用于表达数据库物理结构的数据库全局模型<br>以概念模型为基础，而转换处物理模型(内部模型)<br>有了物理模型，即可以在数据库中建立与之相对应的表结构</p></blockquote></li></ul><hr><ul><li>外部模型<blockquote><p>是用于表达用户使用观点的数据库局部逻辑结构的模型<br><code>[逻辑模型(若干外部模型)]</code><br>数据抽象过程</p></blockquote></li></ul><hr><ul><li><p>关系模型</p><blockquote><p>数据模型是一种严格定义的概念模型<br>关系模型精准的定义了数据结构，以及表与表之间可能发生的各种数据操作与管理，包括数据完整性操作<br>关系模型是以二维表的形式来组织数据<br>支持关系模型的数据库即为关系数据库<br>它使用若干个数据表来存储数据，此间可将一张二维表称之为关系<br>而关系的集合即为关系数据库</p></blockquote></li><li><p>关系模型的有关概念</p><blockquote><p>元组:表中的行，或称为记录<br>属性:表中的列，或称为字段与数据项<br>域:属性的取值范围<br>分量:一个属性的值<br>码:表中某个属性或属性组唯一标识一个元组<br>比如在一个表内，ID字符标识了所在行的整个元组，则称ID为码，即为关系模式约束<br><code>概念模型-&gt;逻辑模型-&gt;物理模型(内部模型)</code></p></blockquote></li><li><p>同种类型的实体集合被称之为实体型</p></li><li><p>在逻辑模型中所设计的一切概念，都被称之为关系模式</p><blockquote><p>关系模式由关系名及其属性的集合构成<br>在逻辑模型中将其称之为关系</p></blockquote></li><li><p>在内部模型中，也就是表结构，实体集为同一类型的表所属的数据集合</p><blockquote><p>在关系模型中将其称之为表</p></blockquote></li><li><p>为何把表称之为关系</p><blockquote><p>数学上把一系列域上的笛卡尔积的子集称为关系<br>而表正符合此定义</p></blockquote></li><li><p>域是一组具有相同类型的值的集合</p><blockquote><p>比如: 整型，实型或指定长度的字符串集合<br>而关系中属性的域可以被理解为属性的取值范围<br>比如学生中的性别属性，它的域就是男与女两个字符串</p></blockquote></li><li><p>笛卡尔积</p><blockquote><p>所有域的所有取值的任意集合<br>在数学中，以乘号来描述此概念<br>即<code>A*B={(x,y)|x∈A^y∈B}</code></p></blockquote></li><li><p>设集<code>A={a,b}</code>，集<code>B={0,1,2}</code></p><blockquote><p>即A的两个值乘以B的三个值<br>则两个集合的笛卡尔积为<code>{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}</code><br>如果A表示某学校学生的集合，B表示改学校所有课程的集合<br>则A与B的笛卡尔积可以用于表示所有的选课情况<br>A如果表示声母集合，B如果表示所有的声母集合，则A与B的笛卡尔积则可表示所有汉字的读音组合</p></blockquote></li><li><p>笛卡尔积并不都是有意义的</p><blockquote><p>设集<code>A={01,02}</code>,集<code>B={张三,李四}</code><br>则两个集合的笛卡尔积为<code>{(01,张三),(01,李四),(02,张三),(02,李四)}</code><br>如果A代表学号，B代表姓名，假设张三的学号是一号，而李四是二号<br>所以该笛卡尔积的结果集中，01的李四与02的张三是没有意义的</p></blockquote></li><li><p>数学上将一系列域上的笛卡尔积的子集称之为关系</p></li><li><p>而笛卡尔积中具有意义的那些元组则才被称之为关系</p></li><li><p>不是所有的二维表都是关系，关系是有以下特性的:</p><blockquote><p>关系必须规范化，比如: 每个表有多行，每个行有多列，每个行列单元都是不能再分的原子值<br>在同一关系中不允许出现相同的属性名<br>而关系中不允许有完全相同的元组<br>并且同一关系中元组及其属性的顺序可以随意</p></blockquote></li><li><p>严格的去定义表的具体规则与基本要求</p></li></ul><hr><h3 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h3><ul><li><p>关系操作与数据查询操作可以用关系代数与关系逻辑的方法描述</p></li><li><p>或用具体的数据库语言，如SQL-结构化查询语言来描述与实现</p></li><li><p>最基本的方法是代数方法，即关系代数</p><blockquote><p><code>关系A&lt;-运算集合-&gt;关系B=关系C</code><br>代数是数学概念，同时关系代数也同为数学概念<br>运算符包括一系列运算集合<br>两个不同的关系通过一个运算符的运算来获得一个新的关系结果</p></blockquote></li><li><p>关系运算的运算符有两类，即为集合运算符和专门的关系运算符</p></li><li><p>选择运算</p><blockquote><p>选择运算是从关系中找出满足条件的元组的元组的操作<br>将其记为: <code>σ[(下标)&lt;条件表达式&gt;] (R)</code><br>用处于右下角的谓词来写条件表达式<br>其中，σ是选择运算符，R是关系名</p></blockquote></li><li><p>选择运算是根据给定的条件选择关系R中的若干元组而组成的新关系，是对关系的元组进行筛选</p><blockquote><p>结果关系与原关系有着相同的模式<br>可以将其表示为: <code>σ[(下标)sex]=R(tables_name)</code><br>在<code>tables_name</code>表中，找出sex字段等于R的所有记录<br>所以选择运算是对于行的操作</p></blockquote></li></ul><hr><p><strong>投影运算</strong></p><ul><li><p>投影运算是从关系中选取若干属性组成新的关系</p></li><li><p>投影运算是从列的角度进行计算，相当于对关系进行垂直分解</p></li><li><p>投影运算符用π来表示</p><blockquote><p><code>π[(下标)A] (R)</code><br>A用于表示投影属性或属性组，R是关系名</p></blockquote></li><li><p>例子: <code>π[(下标)A], π[(下标)A1](R)</code></p><blockquote><p>在R表中对A与A1两个字段进行投影，形成新的关系，同时去掉结果关系中重复的元组</p></blockquote></li><li><p>关系代数是把表看作元组集合的关系，既然是集合就不包括重复元组</p></li><li><p>也就是说，关系代数的每个运算都是去重复的</p></li></ul><hr><p><strong>并运算</strong></p><ul><li><p>并运算属于集合运算</p><blockquote><p>集合运算的两个关系必须拥有相同的关系模式，即相同的结构<br>两个关系包含属性的个数一致<br>两个关系对应属性的域应该相同或包容</p></blockquote></li><li><p>两个已知关系R和S的并将产生一个包含R，S中所有不同元组的新关系</p><blockquote><p>将其记为: <code>R∪S</code><br>则为R并S，因此并运算可以将其理解为现实中的或者</p></blockquote></li><li><p>两个已知关系R和S的交，是属于R而且也属于S的元组组成的新关系</p><blockquote><p>将其极为: <code>R∩S</code></p></blockquote></li><li><p>实例:</p><blockquote><p>设有两张不同的表<code>tables_A</code>与<code>tables_B</code>，并且设这两个表中分别有字段a，b，c，d，其值分别为拥有4行分别1，2，3，4的矩阵数列<br>首先找表<code>tables_A</code>中的a字段，即为:<br>先在<code>tables_A</code>表中进行选择运算，寻找的条件是a字段等于1，即为找出所有a等于1类型的数据记录，然后再进行投影运算，只取c字段(基于字段/列c来对a=1进行投影计算，也可称之为映射计算)<br>并且再<code>tables_B</code>表中进行选择运算，寻找的条件是b小于3的所有记录，然后进行投影运算<br>再将表<code>tables_A</code>与表<code>tables_B</code>进行差运算<br>此时的输出数据就是<br>将表<code>tables_A</code>中将所有已经排除了表<code>tables_B</code>中b小于三的数值类型的所有数值类型<br>因此得到想要查询的类型</p></blockquote></li><li><p>可将SQL语句具体描述为</p><blockquote><p><code>(π[(下标)c], π[(下标)a=1](tables_A))) - (π[(下标)c], π[(下标)b&gt;3](tables_B)))</code></p></blockquote></li><li><p>此时应输出的查询值即为</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">a，b，c，d</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">4</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>笛卡尔积运算</strong></p><ul><li><p>设A和B是两个关系，如果A是m元关系，有i个元组</p></li><li><p>B是n元关系，有j个元组，则笛卡尔积为<code>A*B</code>是一个<code>m+n</code>元关系，则有<code>i*j</code>个元组</p></li><li><p>实例:</p></li><li><p>数据模型:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line">a，b</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line">c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>此时A关系有三个元组，同时B关系有三个元组</p></li><li><p>此时的笛卡尔积则为<code>3*3</code>，则为9个元组</p><blockquote><p>A关系的第一个元组与B关系的所有元组进行连接<br>A关系的第二个元组与B关系的所有元组进行连接<br>A关系的第三个元组与B关系的所有元组进行连接</p></blockquote></li><li><p>此结果即为此笛卡尔运算的乘积结果</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a，b，c，d，e</span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">2</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">4</span>，<span class="number">7</span>，<span class="number">6</span></span><br><span class="line"><span class="number">1</span>，<span class="number">3</span>，<span class="number">7</span>，<span class="number">8</span>，<span class="number">9</span></span><br></pre></td></tr></table></figure></li><li><p>笛卡尔积运算可以把两个运算连接到一起，从而形成一个新的关系</p><blockquote><p>由此引出连接运算与笛卡尔积的关系与区别</p></blockquote></li></ul><hr><p><strong>连接运算</strong></p><ul><li><p>连接运算是将两个关系的若干属性值拼接成一个新的关系的操作</p></li><li><p>对应的新关系中，包含满足连接条件的所有元组</p></li><li><p>即可将其记为: <code>R 连接(AθB) S</code> (连接符号于普通文本间无法输入)</p></li><li><p>其中，R与S是关系名</p><blockquote><p>A，B分别是R和S上度相等且可比的属性组<br>θ是比较运算符</p></blockquote></li><li><p>实例:</p></li><li><p>数据结构模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，a2，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，1</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li><li><p>对表<code>tables_A</code>与表<code>tables_B</code>进行以下比较连接</p></li><li><p><code>tables_A 连接(c&lt;E) tables_B</code>，即为<code>tables_A</code>中的c属性小于<code>tables_B</code>中的E属性</p></li><li><p>连接所输出的结果集为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C，E</span><br><span class="line"><span class="number">3</span>，<span class="number">8</span></span><br><span class="line"><span class="number">4</span>，<span class="number">9</span></span><br><span class="line"><span class="literal">null</span>，<span class="number">6</span></span><br></pre></td></tr></table></figure></li><li><p>此例为比较连接</p></li></ul><hr><ul><li>当比较运算符为等号时，可分为等值连接与自然连接</li></ul><p><strong>等值连接:</strong></p><ul><li>当连接条件为”=”时的连接运算 <code>R 连接(R.C=S.E) S</code>，此条件即可描述为R的C属性等于S的E属性</li></ul><p><strong>自然连接</strong></p><ul><li><p>自然连接是一种特殊的等值连接</p><blockquote><p>它要求两个关系中进行变焦的分量是相同的属性组，并且在结果中把重复的属性列去掉，可表示为: <code>R 连接 S</code></p></blockquote></li><li><p>此间的连接符号皆使用文字描述</p></li><li><p>如果将上述数据模型进行自然连接，即为将量表中的B列所拥有且相等的所有分量进行连接</p></li><li><p>连接运算与笛卡尔积运算的区别</p></li><li><p>连接运算是笛卡尔积运算和特定选择运算合并而成的一个运算</p></li><li><p>以此数据模型为例:</p></li></ul><ol><li>等值连接<blockquote><p>当<code>tables_A 连接(tables_A.C=tables_B.E) tables_b</code><br>即为将量表进行等值运算，运算条件与输出的值则为量表中分别<code>C=E</code>的值</p></blockquote></li></ol><ul><li>结果即为:<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，tables_B.B，E</span><br><span class="line">a1，b1，<span class="number">3</span>，a2，<span class="number">3</span></span><br><span class="line">a2，b3，<span class="number">6</span>，a1，<span class="number">6</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>自然连接</li></ol><ul><li><p><code>tables_A 连接 tables_B</code></p><blockquote><p>此间无任何条件</p></blockquote></li><li><p>结果即为:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A，tables_A.B，C，E</span><br><span class="line">a1，b1，<span class="number">8</span>，<span class="number">8</span></span><br><span class="line">a1，b2，<span class="number">3</span>，<span class="number">9</span></span><br><span class="line">a2，b3，<span class="number">6</span>，<span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据模型:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a1，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br><span class="line"><span class="keyword">a2，b3，7</span></span><br></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line"><span class="keyword">B，E</span></span><br><span class="line"><span class="keyword">b1，8</span></span><br><span class="line"><span class="keyword">b2，9</span></span><br><span class="line"><span class="keyword">b3，3</span></span><br><span class="line"><span class="keyword">a2，2</span></span><br><span class="line"><span class="keyword">a1，6</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>等值连接</strong></p><ul><li><code>tables_A</code>中的C属性与<code>tables_B</code>中的E属性进行比较，一直比较到有相同的元组相等时，将所在元组进行连接<blockquote><p>比如在此实例中3，6，相等，即连接结果为以上两条元组</p></blockquote></li></ul><p><strong>自然连接</strong></p><ul><li><code>tables_A</code>中的B属性和<code>tables_B</code>中的B属性进行等值比较<blockquote><p>此时b1=b1，b2=b2，b3=b3都互为相等，则互相连接，则输出结果为以上两个元组</p></blockquote></li></ul><hr><ul><li>从运算过程可以总结规律: 自然连接必定是等值连接，自然连接与等值连接的区别则在于自然连接所比较的属性必须为公共属性，或者是属性组<blockquote><p>还有一点就是自然连接所形成的新关系会自动将重复的属性去掉<br>在上例中就把<code>tables_B</code>中的B属性去掉了，因为同样的属性所产生的值也必然是相同的，所以会将重复复的值去掉</p></blockquote></li></ul><hr><p><strong>外连接</strong></p><ul><li><p>有些元组不能跟另外关系的任何一个元组匹配，一些实际应用中希望在结果中保留悬浮元组，因此就产生了外连接机制</p></li><li><p>外连接包括了左外连接，右外连接以及全外连接的概念</p></li><li><p>外连接运算的逻辑</p></li></ul><ol><li>计算内连接(比较连接，等值连接与自然连接)</li><li>然后根据左外连接，右外连接或全外连接再加上左侧关系或者右侧关系或者两侧关系中的没有匹配到的元组及悬浮元组</li><li>最后加上悬浮元组用控制NULL来填充相对与另一侧属性的属性值</li></ol><ul><li><p>实例:</p><blockquote><p>自然连接符号的右上角会标识有连接标识L左外连接，R右外连接，F全外连接</p></blockquote></li><li><p>数据模型结构:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tables_A</span><br><span class="line"></span><br><span class="line">A，<span class="keyword">B，C</span></span><br><span class="line"><span class="keyword">a3，b1，3</span></span><br><span class="line"><span class="keyword">a1，b2，4</span></span><br><span class="line"><span class="keyword">a2，b3，6</span></span><br></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tables_B</span><br><span class="line"></span><br><span class="line">D，E</span><br><span class="line">b1，<span class="number">8</span></span><br><span class="line">b2，<span class="number">9</span></span><br><span class="line">a1，<span class="number">3</span></span><br><span class="line">a2，<span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>计算机会先计算出自然连接的结果</li><li>之后再进行认为所指定的连接运算规则</li><li>然后再将所有乘积的属性置为空(NULL)</li><li>最后输出的数据集合变为结果</li></ol><ul><li>其它的运算都可以从这些基本关系的运算合并而成</li></ul><hr><ul><li><p>更多的实例这里不做过多阐述了，因为是Access与MS SQL，因此没有什么对其进行过多抽象描述的必要</p></li><li><p>知识图谱图片:</p></li></ul><img src="images/MS-SQL-2.png" width="30%" height="30%"><ul><li>相关概念图片:</li></ul><img src="images/MS-SQL-1.png" width="30%" height="30%"><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>参考URL</strong></p><ul><li><p>数据抽象级别<a href="https://blog.csdn.net/LetsStudy/article/details/79095315" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/LetsStudy/article/details/79095315</code></p></blockquote></li><li><p>数据科学的核心问题：现实问题的数据抽象与程序表达<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://new.qq.com/omn/20181003/20181003A0XITF00</code></p></blockquote></li><li><p>数据库关系模型范式总结<a href="https://blog.csdn.net/qq_36616602/article/details/85345295" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36616602/article/details/85345295</code></p></blockquote></li><li><p>数据库之父对实现关系型数据库管理系统的12条建议<a href="https://blog.csdn.net/happmaoo/article/details/83075287" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/happmaoo/article/details/83075287</code></p></blockquote></li><li><p>数据库关系运算<a href="http://baijiahao.baidu.com/s?id=1602887097860809528&wfr=spider&for=pc" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://baijiahao.baidu.com/s?id=1602887097860809528&amp;wfr=spider&amp;for=pc</code></p></blockquote></li></ul><p><strong>参考书籍:</strong></p><ul><li><p>数据库原理及应用 (2017.06-郭春生，方昕)</p></li><li><p>数据库应用技术 (2018.1-栾志军，吕海洋，付海娟主编)</p></li><li><p>数据库技术与应用-2020年春季</p><blockquote><p>第一章-数据库基础知识<br>1.4节-1.6节(数据抽象/关系模型/关系运算)</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;Access/MS SQL基本概念归纳&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="数据库" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="RDBMS" scheme="https://unit-serow.github.io/tags/RDBMS/"/>
    
  </entry>
  
  <entry>
    <title>规则</title>
    <link href="https://unit-serow.github.io/2020/03/07/%E8%A7%84%E5%88%99/"/>
    <id>https://unit-serow.github.io/2020/03/07/%E8%A7%84%E5%88%99/</id>
    <published>2020-03-06T22:14:44.000Z</published>
    <updated>2020-03-06T22:18:47.872Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>规则-主观</strong></center><a id="more"></a><hr><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><ul><li><p>目的是引人思考，而绝非让人理解，即便能够理解，也必然不够全面</p></li><li><p>论题核心: 规则/规律/逻辑</p></li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>逻辑</li><li>规律</li><li>规则</li><li>秩序</li><li>智慧</li></ul><hr><p><strong>论题及其导论:</strong></p><ul><li>何为规则？</li><li>规则由何而来？</li><li>何为秩序？</li><li>秩序从何而来？</li><li>秩序与规则的关系与本质？</li><li>规则与秩序的对立概念？</li><li>为何要追求规则与秩序？</li><li>追求规则与秩序所带来的必然结果为何种概念？</li></ul><hr><h3 id="人类-2"><a href="#人类-2" class="headerlink" title="人类-2"></a>人类-2</h3><p><strong>规则与秩序</strong></p><ul><li><p>基于规则，实现秩序</p><blockquote><p>智慧于逻辑铸就规则<br>且相对于秩序<br>规则于现实铸就秩序<br>本能与自由相对秩序<br>本质与现实相对规则</p></blockquote></li><li><p>存在即现实</p><blockquote><p>人类的社会性的前提<br>无智规则<br>无智逻辑</p></blockquote></li><li><p>规则于现实中实现的方式可分为两类</p><blockquote><p>前者为完全/绝对且纯粹的基于智慧<br>其次为基于无智逻辑，即自然规则(自然法则)，此间的规则被称为规律<br>基于智慧的规则产生了可将其称之为法则的规则与规律，法律的概念这里不做阐述<br>自然规则来源于世界与现实，是一切存在于现实的物质与概念的基础<br>自然规则定义了生命，铸就了无智逻辑<br>规则/规律铸就逻辑<br>规则与逻辑皆来源于现实/世界与空</p></blockquote></li><li><p>纯粹性规则/纯粹性秩序的实现</p><blockquote><p>即为拥有纯粹智慧的社会性形态<br>并非纯粹的共产主义<br>而是绝对的纯粹意识形态<br>无即为一切，一切终究归于无，而又源于无<br>即为规则与秩序的根源<br>无规则即为纯粹规则，无逻辑即为纯粹逻辑<br>且<br>无意识即为纯粹意识<br>但智慧是存在于现实的<br>将一切归根结底的答案，都将归于无<br>在此所讨论的一切，都将不产生任何意义<br>理智与智慧是不应存于现实的，理智与智慧是最为荒谬的概念且为最不接近(或称其为抛离/脱离)于现实/世界的概念<br>人类/智慧生物在理智状态下做做出的一切行动都是最为荒谬的…</p></blockquote></li><li><p>顺天应人，随心而行，终究是最终且最合理的结果</p><blockquote><p>纯粹的纯粹唯物主义也莫过于如此<br>但大多或称所有，所谓的存在于现实中的顺天应人的智慧<br>都为主观结果，而非空或无所产生/带来的结果<br>纯粹且绝对性的概率如果存在，顺天应人则绝对不存在<br>光凭人类的智慧恐怕是完全无法做到所谓的顺天应人<br>追求规则与秩序所带来的必然结果即为无结果(绝对追求/追求绝对的规则与秩序)</p></blockquote></li><li><p>平衡</p><blockquote><p>针对平衡的概念与深层理解与思考<br>一切概念的最优解结尾平衡，平衡即为存于现实间最美好且最完全的概念<br>为何要去追求规则与秩序<br>一切都是为了将世界/现实达到或保持所谓的平衡，无论客观与主观<br>弱者与强者间的平衡，本能与理智间的平衡，本质与智慧之间的平衡，有与无(空)之间的平衡…</p></blockquote></li></ul><hr><h3 id="相关主观概念"><a href="#相关主观概念" class="headerlink" title="相关主观概念"></a>相关主观概念</h3><ul><li>现实/世界中所存在的一切皆可对立且皆成逻辑与规则</li><li>现实层面概念所产生与存在的现实概念:</li><li>现实/世界/自然因智慧/理智的存在而产生了最荒谬的结果</li><li>因此自然/世界将永远无法达到平衡(现实/世界存在智慧)</li></ul><p><strong>而人类社会更是与其相同</strong></p><ul><li><p>人与人之间于智慧层面的差距是人类永远也无法去主观进行理解的概念</p></li><li><p>而人与人之间所产生的智慧的差距皆来源于世界</p><blockquote><p>这里也可以将世界的概念称之为自然环境与绝对性概率所产生的环境差异</p></blockquote></li><li><p>正常状态下的人类皆拥有智慧？</p><blockquote><p>不<br>所谓的智慧，并非是所有人都在乞求得到的事物<br>沉迷于精神世界或沉迷于现实世界间的智慧将永远都不配将其称之为智慧(对于无限接近于纯粹的智慧而言)<br>有的人拥有的智慧接近于纯粹，而有的人则接近于无(此类人与无智慧生物相近，也就是猿猴)<br>但无论是任何形式的智慧，无论是拥有这两种绝对的概念其中的哪一个<br>所带来的结果都是绝对荒谬的<br>而接近于纯粹智慧的智慧永远都达不到且无法拥有纯粹的智慧，因为他们存在于现实间<br>而平衡，往往是于现实间所存在的最完美智慧<br>接近于纯粹智慧的智慧(按理/此处为主观愚解)应当理解这些基本的概念<br>接近于纯粹智慧的智慧会去无限的接近于平衡的智慧，而并非一味的去追求纯粹<br>一味的去追求纯粹的智慧并非为接近纯粹智慧的智慧<br>疯子与精神病患者可能会聪明绝顶，但其拥有的绝对不是接近于绝对纯粹的智慧<br>接近于绝对纯粹的智慧会尽力的去保持应有且为原有应当的平衡<br>即为将同时存在于现实与精神世界的人体意识时刻保持平衡<br>现实/世界间应只存在”最”的概念，而不应存在”绝对”的概念<br>无<br>纯粹</p></blockquote></li><li><p>此间只可意会，无法以言语相传</p></li><li><p>此间概念应有丢失，待今后进行相应补充</p></li></ul><p><strong>死循环<del>(嵌套循环)</del></strong></p><p><strong>即永远无法到达的平衡与纯粹</strong></p><p><strong>至此</strong></p><hr><h3 id="不精之精，而至纯粹"><a href="#不精之精，而至纯粹" class="headerlink" title="不精之精，而至纯粹"></a>不精之精，而至纯粹</h3><ul><li><p>改意之于-元精者，不精之精，其体纯粹，发而为智</p></li><li><p>此句来源于易经-周易阐真-序-先天五元，发为五得</p><blockquote><p>元性者（甲），无性之性，其体柔慈，发而为仁。<br>元神者（丙），不神之神，其体圆通，发而为礼。<br>元气者（戊），无气之气，其体纯一，发而为信。<br>元情者（庚），无情之情，其体刚烈，发而为义。<br>元精者（壬），不精之精，其体纯粹，发而为智。</p></blockquote></li></ul><hr><ul><li>而之即有其词-后天五浊，感生五贼<blockquote><p>游魂（乙）主生，其性善，感则生喜。<br>识神（丁）至灵，其性贪，感则生乐。<br>妄意（己）至动，其性乱，感则生欲。<br>鬼魂（辛）主死，其性恶，感则生怒。<br>浊精（癸）至浮，其性痴，感则生哀。</p></blockquote></li></ul><hr><p><strong>其它:</strong></p><ul><li>万物皆为相生相克，此存在于现实的概念恐怕8000年前的古中国就早已经有智慧提出了</li><li>而由进现代的相对论(狭义/广义)/质能守恒定律所产生的质能方程E=mc^2则完全且绝对的证明了此存在于现实的逻辑与观点</li><li>存在于现实的纯粹唯物主义的一切/绝对基本条件即为纯粹性概率/完全性概率，此概念将对应于现代所产生的量子理论</li><li>我虽自称沉醉于纯粹的纯粹唯物主义，但我对本质即为存在于现实世界的物理学一无所知</li><li>即便是纯粹的理论物理，而能令我沉迷的只有比其更接近于纯粹的纯粹数学</li></ul><hr><p><strong>下一论题:</strong></p><ul><li>智慧的起源/根源及其本质<blockquote><p>即为一切论题的基础，一切存在(唯心主义)于现实间的根源与基础<br>智慧绝非凭空产生或来于它类，进化论于唯物主义理论中是完全存在的<br>存在于现实的一切概念与生命都不可能拥有纯粹的智慧，因为纯粹的自由完全不属于现实(精神或意识形态)</p></blockquote></li></ul><hr><ul><li>文章内所涉及的一切现实与精神概念的相关内容皆基于主观理解与描述</li><li>相对于自身有限的智慧层次而对其客观进行的理解与描述</li><li>并且我将会尽量的做到绝对存在于现实的客观，但终究有限</li></ul><hr><ul><li>Because it is there-(因为山在那里)</li><li>我所拥有的一切皆来源于现实与世界，因此我终将一无所有</li></ul><hr><ul><li>补充一点: 0与1即为无与有，此时应当联想到何物？<blockquote><p>二进制……与机械智能……</p></blockquote></li></ul><hr><p><strong>相关资料:</strong></p><ul><li>中国哲学书电子化计划 -《周易阐真》<a href="https://ctext.org/wiki.pl?if=gb&res=904129&remap=gb" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://ctext.org/wiki.pl?if=gb&amp;res=904129&amp;remap=gb</code></p></blockquote></li></ul><blockquote><p>周易闡真（易道心法真傳）- 卷首-河圖<a href="https://www.eee-learning.com/book/eee-shinfa-ch3" target="_blank" rel="noopener">跳转</a><br><code>https://www.eee-learning.com/book/eee-shinfa-ch3</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;规则-主观&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LSP-2.2</title>
    <link href="https://unit-serow.github.io/2020/03/07/LSP-2-1/"/>
    <id>https://unit-serow.github.io/2020/03/07/LSP-2-1/</id>
    <published>2020-03-06T17:59:36.000Z</published>
    <updated>2020-03-06T18:01:30.453Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用与库函数调用的执行检查与错误处理</strong></center><center><strong>UNIX/Linux-2.2</strong></center><a id="more"></a><h2 id="LSP-2-2"><a href="#LSP-2-2" class="headerlink" title="LSP-2.2"></a>LSP-2.2</h2><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-2</li></ul><hr><p><strong>涉及概念一览:</strong></p><ul><li>库函数基本检查</li><li>系统调用检查与错误处理</li><li>库函数调用检查与错误处理</li></ul><hr><h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><ul><li><p>库函数即为存在于C 标准库内的任何函数，也可以称其为函数</p><blockquote><p>设计库函数的目的是为了提供比底层系统调用更方便的调用接口</p></blockquote></li><li><p>标准C语言函数库: GNU C 语言函数库(Glibc)</p><blockquote><p>标准C语言函数库的实现跟随UNIX的实现而异<br>GNU C语言函数库即为Linux上最常用的实现</p></blockquote></li><li><p>除了标准的函数之外通常还有其它的拓展函数uClibc与dietlibc</p><blockquote><p>uClibc: htttp://<a href="http://www.ulibc.org" target="_blank" rel="noopener">www.ulibc.org</a><br>dietlibc: <a href="http://www.fefe.de/detlibc" target="_blank" rel="noopener">http://www.fefe.de/detlibc</a></p></blockquote></li><li><p>因为Linux开发的大多数开发都只能用到Glibc，所以这里将不会对其它的拓展函数库进行过多讨论</p></li><li><p>查看当前系统的Glibc版本</p><blockquote><p>直接运行其glibc的共享库文件(可执行文件)，以获取版本<br><code>$ /lib/libc.so.6</code></p></blockquote></li><li><p>确定改库存放位置的方法之一:</p><blockquote><p>针对某个与glibc动态链接的可执行文件，运行ldd程序<br>然后再检查已输出的库依赖列表，便能发现glibc共享库所处于的位置<br><code>$ ldd myprog | grep libc</code></p></blockquote></li></ul><hr><ul><li>应用程序可以通过测试常量和调用函数库这两种方法来确定系统所安装的glibc版本及其详细信息<blockquote><p>从版本2.0开始，glibc定义了两个常量<code>__GLIBC__</code>和<code>__GLIBC_MINOR__</code>，以供程序再编译时(在<code>#ifdef</code>语句中)测试使用<br>为了避免在同步机器上造成的版本不同而产生的参数差异所带来的种种问题，可以在程序内调用<code>gnu_get_libc_version()</code>来确定运行时的glibc版本</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/libc-version&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">gnu_get_libc_version</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>而对于获取glibc版本信息，还有一种方法，即为使用<code>confstr()</code>函数来获取(glibc特有的)<code>_CS_GNU_LIBC_VERSION</code>配置变量的值<blockquote><p>其返回的字符串与上述实例相同</p></blockquote></li></ul><hr><h3 id="如何处理来自系统调用的错误与如何处理来自库函数的错误"><a href="#如何处理来自系统调用的错误与如何处理来自库函数的错误" class="headerlink" title="如何处理来自系统调用的错误与如何处理来自库函数的错误"></a>如何处理来自系统调用的错误与如何处理来自库函数的错误</h3><ul><li>几乎每个系统调用和库函数都会返回某类状态值，用以表明调用成功与否<blockquote><p>如果想要深入的了解调用是否成功，必须检查对状态值进行检查<br>若调用失败，则采取相应行动<br>所以让程序显示错误消息，以防止有意想不到的时间发生，是非常有必要的<br>但是还有少数几个系统调用函数在调用时从不会失败(例如<code>getppid()</code>总是能成功返回<code>进程的ID</code>，而<code>_exit()</code>总能终止进程，则无需对此类系统调用的返回值进行检查)</p></blockquote></li></ul><hr><p><strong>如何处理来自系统调用的错误:</strong></p><ul><li>每个系统调用的手册页记录有调用可能的返回值，并指出了哪些值表示错误<blockquote><p>通常，返回值为-1则表示出错，当处于此种情况下，可以使用下列代码对系统调用进行检查</p></blockquote></li></ul><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fd = <span class="keyword">open</span>(pathname, flags, mode); <span class="comment">/* system call to open a file */</span></span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to handle the error */</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">close</span>(fd) == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/* Code to heandle the error */</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>当系统调用失败时，会将全局整形变量<code>errno</code>设为一个正值，以标识具体的错误</p><blockquote><p>程序(<code>#include</code>)包含<code>&lt;errno.h&gt;</code>头文件，该文件提供了对<code>errno</code>的声明，以及一组针对各种错误编号而定义的常量<br>所有这些符号名都以子字母E打头，在每个手册页内标题为<code>ERRORS</code>的章节内，都刊载有一份相应系统调用可能返回的<code>errno值</code>列表</p></blockquote></li><li><p>这里是利用<code>errno</code>来诊断系统调用错误的一个简单实例:</p></li></ul><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cnt</span> = read(fd, buf, numbytes);</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">cnt</span> == -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">errno</span> == EINTR)</span><br><span class="line">fpintf(stderr, <span class="string">"read was interrupted by a signal\n"</span>)</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Some other error occurred */</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure><ul><li><p>如果调用系统函数和函数库成功，<code>errno</code>绝不会被重置为0，故此改变了值不为0，还有可能是因为之前的调用失败造成的</p><blockquote><p>此外，<code>SUSv3</code>允许在函数调用成功时，将<code>errno</code>设置为非零值(但是基于没有函数会这么做)<br>因此，在进行错误检查时，必须检查首先检查函数的返回值是否表明调用出错，然后再检查<code>errno</code>确定错误原因<br>少数系统调用(比如<code>getpriority()</code>)在调用成功后，也会<code>返回-1</code><br>所以在要判断此类系统调用是否发生错误，应在调用前将<code>errno</code>设置为0，并在调用后进行检查(以上所描述的手法同样适用于某些库函数)</p></blockquote></li><li><p>系统调用失败后，常见的做法之一就是根据<code>errno</code>值来打印错误消息，提供的库函数<code>perror()</code>和<code>strerror()</code>，就是处于此目的</p><blockquote><p>此实例中函数<code>perror()</code>会打印出其<code>msg参数</code>所指向的字符串，紧跟一条与当前<code>errno值</code>相对应的消息</p></blockquote></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>以下是对系统调用错误进行错误的一种简单方式:</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fd = open(pathname, flags, mode);</span><br><span class="line"><span class="keyword">if</span> (fd == -<span class="number">1</span>) &#123;</span><br><span class="line">perror(<span class="string">"open"</span>)</span><br><span class="line"><span class="keyword">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>strerror()</code>会针对其<code>errnum</code>参数中所给定的错误号，返回相应的错误字符串</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>由<code>strerror()</code>所返回的字符串可以是静态分配的，这意味着后续对<code>sterror()</code>的调用可能会覆盖该字符串</p><blockquote><p>若无法识别<code>errnum</code>所含的错误编号，则<code>strerror()</code>会返回<code>&quot;Unknown error nnn&quot;</code>形式的字符串<br>在某些其它的视线中，在这种情况下，<code>strerror()</code>会返回<code>NULL</code></p></blockquote></li><li><p>由于<code>perror()</code>和<code>sterror()</code>都属于对语言环境敏感(locale-sensitive)的函数，故而错误描述中使用的都是本地语言</p></li></ul><hr><p><strong>处理来自库函数的错误</strong></p><ul><li>不同的库函数在调用发生错误时，所返回的数据类型和值也各不相同(可以参见每个函数的手册页)</li><li>从错误的角度来讲，可以分为以下几类:</li></ul><ol><li>某些库函数返回错误信息的方式与系统调用完全相同，则<code>返回值为-1</code>，伴之以<code>errno号</code>来标识具体错误<blockquote><p><code>remove()</code>便是其中一例，可使用该库函数来删除文件(调用<code>unlink()</code>相同调用)或目录(调用<code>rmdir()</code>相同调用)<br>对此类函数所发生的错误进行诊断，其方式与系统调用完全相同</p></blockquote></li><li>某些库函数在出错时会<code>返回-1</code>之外的其他值，但仍会设置<code>errno</code>来表明具体的出错情况<blockquote><p>例如，<code>fopen()</code>在出错时会返回一个<code>NULL指针</code>，还会根据出错的具体底层相同调用来设置<code>errno</code><br>函数<code>perror()</code>和<code>sterror()</code>都可用来诊断此类错误</p></blockquote></li><li>还有一些函数根本不使用<code>errno</code>，对此类函数来说，确定错误存在与否及其起因的方法各不相同<blockquote><p>同样可见诸于相应函数的手册页中，不应使用<code>errno</code>，<code>perror()</code>或<code>strerror()</code>来诊断错误</p></blockquote></li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li>Linux/UNIX系统编程(上册)</li><li>参考自原书3.3-3.4章节</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用与库函数调用的执行检查与错误处理&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.2&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="软件" scheme="https://unit-serow.github.io/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LSP-2-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-2/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-2/</id>
    <published>2020-03-06T10:39:20.000Z</published>
    <updated>2020-03-06T10:48:01.174Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux系统调用概念及其执行逻辑叙述</strong></center><center><strong>UNIX/Linux-2.1</strong></center><a id="more"></a><h2 id="LSP-2-1"><a href="#LSP-2-1" class="headerlink" title="LSP-2.1"></a>LSP-2.1</h2><ul><li>LSP/Linux System Prorgramming-2</li></ul><hr><h3 id="Linux-UNIX-2-1"><a href="#Linux-UNIX-2-1" class="headerlink" title="Linux/UNIX-2.1"></a>Linux/UNIX-2.1</h3><ul><li>系统编程概念-1</li><li>系统编程先决条件及其执行逻辑整合文案-1</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>系统调用及其执行逻辑刨析</li><li>对已执行的调用进行检查</li><li>逻辑简述</li></ul><hr><ul><li>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律</li></ul><hr><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li><p>系统调用是受控的内核入口，因此机制，进程可以请求内核以自己的名义去执行某些动作</p></li><li><p>以应用程序编程接口(API)的形式，内核提供有一系列服务提供程序访问(包括创建新进程，执行I/O，以及为进程间通信创建管道等)</p></li><li><p>在深入系统调用的运作方式之前，需要对其进行关注的几个问题点</p></li></ul><ol><li>系统调用是将处理器从用户态切换到和心态，以便CPU访问受到保护的内核内存</li><li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识(程序通过名称来标识系统调用，此编号机制通常与其无关)</li><li>每个系统调用可辅之以一套参数，对用户空间(亦即进程的虚拟地址空间)与内核空间之间(相互)传递的信息加以规范</li></ol><ul><li><p>从编程的角度去理解，系统调用与C语言函数的调用很相似</p><blockquote><p>然而在系统调用时，其幕后会经理诸多步骤，接下来将会对该步骤的具体逻辑进行叙述:</p></blockquote></li><li><p>这里将硬件平台-<code>x86-32</code>为例，按事件发生的顺序对这些步骤加以分析</p></li></ul><ol><li>应用程序通过调用C语言函数库中的外壳(wrapper)函数，以发起系统调用</li><li>对系统调用中断处理的例程来说，外壳函数必须保证所有的系统调用参数可用<blockquote><p>通过堆栈，这些参数传入外壳函数，但内核却希望这些参数置于特定的寄存器<br>因此，外壳函数会将上述参数复制到寄存器</p></blockquote></li><li>由于所有系统调用进入内核的方式相同，内核需要设法区分每个相同调用<blockquote><p>为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器(%eax)中</p></blockquote></li><li>外壳函数执行一条中断机器指令(<code>int 0x80</code>)，引发处理器从用户态切换到和心态，并执行系统终端<code>0x80</code>(十进制数为128)的终端矢量所指向的代码<blockquote><p>在较新的<code>x86-32</code>硬件平台实现了<code>sysenter指令</code>，较之传统的<code>int 0x80</code>中断指令，sysenter指令进入内核的速度更快，2.6内核与glibc2.3.2以后的版本都支持<code>sysenter指令</code></p></blockquote></li><li>为相应中断<code>0x80</code>，内核会调用<code>system_all()</code>例程(位于汇编文件<code>arch/i386/entry.S</code>中)来处理这次中断，具体的处理逻辑与步骤如下:<blockquote><p>1-在内核栈中保存寄存器值(这里先不做阐述)<br>2-审核系统调用编号的有效性<br>3-以系统调用编号对存放所有调用服务例程的列表(内核变量<code>sys_call_table</code>)并进行索引，发现并调用相应的系统系统调用服务例程<br>3.1-若系统调用服务例程带有参数，那么将会首先检查参数的有效性<br>3.2-例如，会检查地址指向用户空间的内存位置是否有效<br>3.3-随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改<br>3.4-以及在用户内存和内核内存间传递数据(比如在I/O操作中)<br>3.5-最后，该服务例程会将结果状态返回给<code>system_call()</code>例程<br>4.-从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中<br>5.-返回值外壳函数，同时将处理器切换回用户态</p></blockquote></li><li>若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno<blockquote><p>然后，外壳函数返回一个整型值，以表明系统调用是否成功<br>在Linux上，系统调用服务例程所遵循的惯例是调用成功则返回负值<br>发生错误时，例程会对相应erron常量取反，则返回一个负值<br>C语言函数库的外壳函数即对其再次取反(此时负负得正)，将此结果拷贝至 errno<br>同时以-1作为外壳函数的返回值返回，以此向调用程序表明有错误发生<br>上述惯例所依赖的先决条件是系统调用服务例程，若调用成功则不会返回负值<br>可是对于少数例程来说，这一前提并不成立<br>一般情况下，这也不会有问题，因为取反的errno值范围不会与调用成功返回负值的范围有交集<br>不过还有一种情况沿用这个惯例确实会出问题: 系统调用<code>fcntl()</code>的<code>F_GETOWN</code>操作，这里先不做阐述</p></blockquote></li></ol><hr><ul><li>以相同调用<code>execve()</code>为例，此图片展示了上文叙述及事件的发生序列</li><li>在<code>Linux/x86-32</code>上，<code>execve()</code>的系统调用号为<code>11(__NR_execve)</code><blockquote><p>因此，在<code>sys_call_table</code>向量中，<code>条目11</code>包含了该系统调用的服务例程<code>sys_execve()</code>的地址</p></blockquote></li><li>在Linux中，系统调用服务例程的命名通常会采取<code>sys_xyz()</code>的形式，其中<code>xyz()</code>则是所论及的系统调用</li></ul><p><strong>系统调用的执行步骤图例</strong></p><img src="/images/系统调用-1.png" width="40%" height="40%"><hr><ul><li><p>在系统调用的实际情况中，通常不需要将概念掌握并理解的如此深刻</p><blockquote><p>但即便对于一个简单的系统调用，仍要完成相当多的工作<br>因此系统调用的开销虽然很小，却也不容忽视</p></blockquote></li><li><p>这里可以将getppid()系统调用为例，研判一下发起系统调用的开销:</p><blockquote><p>该系统调用只是简单地返回调用进程的父进程ID<br>此时在一台运行着<code>Linux 2.6.25</code>的<code>x86-32</code>系统上，调用<code>getppid()</code>一千万次大约需要<code>2.2秒</code>钟，每次调用大致需要<code>0.3微秒</code><br>相形之下，在同一系统上，调用某个只返回整数的C语言函数一千万次，仅需0.11秒，约为<code>getppid()</code>耗费时间的<code>1/20</code><br>当然，大多数系统调用的开销都明显高于<code>getppid()</code></p></blockquote></li></ul><hr><ul><li>因此，从C 语言编程的角度去看，调用C语言函数库的外壳函数等同于调用相应的系统调用服务例程<blockquote><p>在今后的章节里，调用系统调用<code>xyz()</code>这类说法即意味着: 调用外壳函数，然后再由外壳函数去调用系统调用<code>xyz()</code></p></blockquote></li><li>为调试程序，或是研究程序的运作机制，可以使用<code>stace命令</code>，以便对程序发起的系统调用进行跟踪</li><li>有关与Linux系统调用机制有关的信息可参见其它书籍: [Love，2010]，[Bovet &amp; Cesati，2005]以及[Maxwell，1999]</li></ul><hr><p><strong>相关概念整合:</strong></p><ul><li><p>系统编程概念</p></li><li><p>系统编程先决条件及其执行逻辑整合文案</p></li><li><p>系统编程概念</p><blockquote><p>系统编程先决条件整合文案<br>系统调用<br>执行逻辑<br>库函数<br>GNU Libc (Glibc-GNU C 标准库)<br>无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律<br>已执行调用检查<br>库函数错误<br>系统条用错误<br>可移植性<br>特性测试宏<br>SUSv3中定义的标准系统数据类型</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>可参考URL目录</p></li><li><p>CN-CSDN-Linux系统调用手册<a href="https://blog.csdn.net/xtx1990/article/details/8173950" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/xtx1990/article/details/8173950</code></p></blockquote></li><li><p>CN-CSDN-linux常用系统调用简介<a href="https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code></p></blockquote></li><li><p>CN-个人博客-[译] Linux 系统调用权威指南（2016）<a href="https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/</code></p></blockquote></li><li><p>CN-百度文库-系统调用手册<a href="https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html</code></p></blockquote></li><li><p>CN-IBM-Linux系统调用列表<a href="https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html</code></p></blockquote></li></ul><p>CN-个人博客-Linux系统调用(syscall)原理<a href="http://gityuan.com/2016/05/21/syscall/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://gityuan.com/2016/05/21/syscall/</code></p></blockquote><hr><ul><li><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a><blockquote><p>第三章节内容<br>PDF资源可参考文章OS-1<br>手册页-Linux系统调用<br>书籍-附录A</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux系统调用概念及其执行逻辑叙述&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-2.1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LSP-1</title>
    <link href="https://unit-serow.github.io/2020/03/06/LSP-1/"/>
    <id>https://unit-serow.github.io/2020/03/06/LSP-1/</id>
    <published>2020-03-06T07:41:05.000Z</published>
    <updated>2020-03-06T07:56:52.591Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><center><strong>UNIX/Linux内核与操作系统基本概念归纳</strong></center><center><strong>UNIX/Linux-1</strong></center><a id="more"></a><h2 id="LSP-1"><a href="#LSP-1" class="headerlink" title="LSP-1"></a>LSP-1</h2><ul><li>LSP/Linux System Prorgramming</li></ul><hr><h3 id="UNIX-Linux-1"><a href="#UNIX-Linux-1" class="headerlink" title="UNIX/Linux-1"></a>UNIX/Linux-1</h3><ul><li>内核与操作系统的相关基本概念归纳</li></ul><hr><p><strong>章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><p><strong>内核</strong></p><ul><li><p>内核概念</p><blockquote><p>操作系统的核心<br>内核在狭义范围内被理解为用于管理与分配计算机硬件资源(即CPU，RAM，设备等)的核心层软件<br>在没有内核的情况下，计算机也能运行程序<br>内核的作用是对其它程序的编写和使用进行简化(通常会产生极大的简化效果)<br>者一切都要归功于内核为管理计算机的有限资源所提供的软件层</p></blockquote></li><li><p>内核文件命名机制</p><blockquote><p><code>vmunix/</code><br><code>boot/vmlinuz</code><br>内核为经由压缩的可执行文件</p></blockquote></li></ul><p><strong>内核的存在意义与职责</strong></p><ul><li><p>进程调度</p><blockquote><p>通常计算机内存在着若干个CPU(中央处理单元)以执行程序命令<br>UNIX kernel system与UNIX-like(Linux) kernel system属于抢占式多任务系统<br>多任务意指多个进程(即运行中的程序)可同时驻留于内存，且每个进程都能够获得对CPU的使用权<br>抢占用于泛指一组规则，这组规则控制着指定进程对CPU的使用权与使用时间<br>以上两者均有内核进程调度程序(而非程序本身)决定</p></blockquote></li><li><p>内存管理</p><blockquote><p>由于硬件资源的有限且软件对其硬件资源的占用，使得物理内存(RAM)被定义为有限资源<br>内核的作用就是以公平且高效的方式在进程间共享这一资源<br>多数的现代操作系统(包括Linux)采用了虚拟内存管理机制<br>使得进程与进程之间，进程与内核之间彼此隔离，以防止进程读取或修改内核或其它进程中的内存内容<br>只需将进程的一部分保存在内存中，以降低每个进程对内存的需求量与实现在RAM中同时加载更多的进程<br>此方法大幅提升了在任意时刻的CPU都有至少一个进程可以执行，以使得对CPU资源的利用更加充分的情况</p></blockquote></li><li><p>文件系统提供</p><blockquote><p>内核在磁盘之上有提供文件系统，并且允许对文件系统执行创建，获取，更新以及删除等管理操作</p></blockquote></li><li><p>创建和终止进程</p><blockquote><p>内核可以将新程序载入内存，以为其提供运行所需的资源(比如CPU，内存以及对文件的访问等)<br>这样一个处于运行状态下的程序被称之为进程<br>一旦进程执行完毕，内核还要确保释放其占用的资源，以备后续程序重新使用</p></blockquote></li><li><p>对设备与其硬件的访问</p><blockquote><p>计算机的外界设备(人体学输入设备，磁盘或磁带驱动器等)可实现计算机与外部世界的通信<br>此通信机制包括输入，输出或两者兼而有之<br>内核即为程序访问设备提供了简化版的标准接口，同时还要仲裁多个进程对每一个设备的访问</p></blockquote></li><li><p>联网的机制与其实现</p><blockquote><p>内核以用户进程的名义收发网络消息(数据包)<br>该任务包括将网络数据表路由至目标系统</p></blockquote></li><li><p>提供系统调用应用编程接口(API)</p><blockquote><p>进程可利用内核入口点(也可称其为系统调用)请求内核去执行各种任务<br>衍生概念: Linux系统内核调用API的方法与步骤，此概念将会在以后章节内进行详细刨析与实践</p></blockquote></li><li><p>通常情况下，多用户操作系统(例如Linux等)会为用户提供一种名为: 虚拟私有计算机(virtual private computer)的抽象概念</p></li><li><p>即为每个用户都可以登陆操作系统，并且其独立的操作与其它的用户大致无干(包括独立访问设备，独立运行程序，CPU，磁盘及其硬件资源独立分配等等)</p></li><li><p>此时的内核用于负责解决(多进程)访问硬件资源时可能引发的冲突，并且不对用户和进程产生任何层面的影响</p></li></ul><hr><p><strong>内核态与用户态</strong></p><blockquote><p>现代处理器架构一般允许CPI至少在两者不同的状态下允许<br>即为用户态与核心态(有时也可称之为监管态supervisor mode)<br>执行硬件执行可使得CPU在两者状态间来回切换<br>与之相对应的虚拟内存区域也可划分(标记)为用户空间部分与内核空间部分<br>在用户状态下运行时: CPU只能访问被标记为用户空间的内存，视图访问属于内核空间的内存会引发硬件异常<br>在内核状态下运行时: CPU既能访问用户空间内存，也能访问内核空间内存<br>内核状态下运行的处理器通常可以完成某些特定操作: 此特定操作包括了执行宕机(halt)，访问内存管理硬件，以及设备I/O操作的初始化等等<br>实现者们通常会利用这一硬件设计将操作系统置于内核空间以确保用户进程不能访问内核指令和数据结构，保证了其无法对操作系统执行不利于操作系统运行的操作<br>而程序员在进行日常的编程任务时有必要去习惯于利用面向进程(process-oriented)的思维方式来考虑编程问题<br>即以进程及内核的视角来检视系统</p></blockquote><hr><h3 id="Shell相关"><a href="#Shell相关" class="headerlink" title="Shell相关"></a>Shell相关</h3><ul><li>shell是用于读取用户输入指令并将其相对应的程序进行执行并相应的软件程序<blockquote><p>也可将其称之为命令解释器<br>术语: 登陆shell(login shell)用于特质用户刚登陆系统时，由系统创建，用以运行shell的进程<br>在某些操作系统内会将命令解释器集成于内核中，对于UNIX系统而言，shell只是一个用户进程<br>在UNIX系统的历史中出现过的重要shell: Bourne shell (sh)，C shell (csh)，Korn shell (ksh，bash)等等<br>分别对应了UNIX，BSD，Linux等等</p></blockquote></li></ul><hr><h3 id="操作系统层面相关概念列表"><a href="#操作系统层面相关概念列表" class="headerlink" title="操作系统层面相关概念列表"></a>操作系统层面相关概念列表</h3><ul><li>用户和组-操作系统层面概念</li><li>单根目录层级-操作系统层面概念</li><li>目录-操作系统层面概念</li><li>链接/路径和链接/符号链接-操作系统层面概念</li><li>文件/链接文件/文件类型/文件命名/文件的所有权与权限(相对于用户与操作系统)-操作系统层面概念</li><li>路径/路径命名-操作系统层面概念</li><li>当前工作目录-操作系统层面概念</li><li>文件[I/O模型]/文件描述符-操作系统层面概念</li><li>stdio函数库(C语言在执行文件I/O操作时，通常会调用C标准库内的I/O函数，也可将I/O函数称为stdio函数库)，stdio函数位于I/O系统调用层之上-操作系统层面概念</li></ul><hr><p><strong>程序-操作系统层面概念</strong></p><ul><li><p>程序的存在形式与概念:</p><blockquote><p>程序在现实中的实现可分为两种形式: 源码文件与二进制文件<br>源码文件在执行程序时需要先将其转换(编译和链接处理)为二进制文件，即机器可以理解的二进制机器语言指令</p></blockquote></li><li><p>脚本</p><blockquote><p>脚本是包含命令的文本文件，它可以由shell或其它命令解释器之类的程序直接处理</p></blockquote></li><li><p>有关程序的相关概念列表:</p><blockquote><p>过滤器<br>命令行参数</p></blockquote></li></ul><hr><p><strong>进程</strong></p><ul><li><p>进程的概念与存在意义:</p><blockquote><p>进程即为正在执行的程序实例<br>在程序执行时，内核会将程序的源码载入虚拟内存，以为程序变量分配空间，建立内核记账(bookkeeping)数据结构<br>由此记录进程有关的各种信息(如: 进程ID，用户ID，组ID及其终止状态等)</p></blockquote></li><li><p>在内核的角度去观察进程</p><blockquote><p>进程是一个个实体，内核必须在它们之间共享各种计算机资源<br>以实现让所有的可再生资源在进程间进行平等的资源共享</p></blockquote></li><li><p>进程相关概念列表</p><blockquote><p>进程的内存布局</p></blockquote></li><li><p>逻辑上可以将某一个内存划分为这几部分(也可称为几段):</p><blockquote><p>文本: 程序的指令<br>数据: 程序使用的静态变量<br>堆: 程序可以从该区域动态分配额外内存<br>栈: 随机函数调用，返回而增减的一片内存，用于为局部变量和函数调用链接信息分配存储空间</p></blockquote></li><li><p>进程相关的基础概念列表:</p></li><li><p>创建进程</p></li><li><p>创建可执行程序</p></li><li><p>进程ID</p></li><li><p>父进程ID</p></li><li><p>进程终止与终止状态</p></li><li><p>进程的用户和组标识符</p></li><li><p>特权进程</p></li><li><p>能力(概念-Capabilities/始于Linux kernel-v2.2)</p></li><li><p>init进程</p></li><li><p>守护进程</p></li><li><p>环境列表</p></li><li><p>资源限制</p></li></ul><hr><p><strong>内存映射</strong></p><ul><li>内存映射基本概念及其实现方法:<blockquote><p>调用系统函数<code>mmap()</code>的进程，会在其虚拟地址空间中创建一个新的内存映射</p></blockquote></li><li>内存映射可分为以下两类:</li></ul><ol><li>文件映射: 将文件的部分区域映射入调用进程的虚拟内存<blockquote><p>调用一旦完成，对文件映射内容的访问则转化为对应相应内存区域的字节操作，映射页面对按需自动从文件中加载</p></blockquote></li><li>相映成趣的是并无文件与之相应的匿名映射，其映射页面的内容会被初始化为0</li></ol><ul><li>由某一进程所映射的内存可以与其它进程的映射共享，而共享的方式通常有两个:</li></ul><ol><li>两个进程都针对某一文件的相同部分加以映射</li><li>由<code>fork()</code>创建的子进程自父进程处继承映射</li></ol><ul><li>内存映射有关概念:<blockquote><p>内存内容填充量分配<br>文件(I/O)，即映射内存I/O<br>进程间通信(通过内存共享映射)</p></blockquote></li></ul><hr><p><strong>静态库和共享库</strong></p><ul><li><p>所特指目标库的概念:</p><blockquote><p>所谓的目标库文件就是: 将(通常是逻辑相关的)一组函数代码加以编译，并置于一个文件中，以供其它程序调用的文件<br>此方法通常有利于程序的开发与维护</p></blockquote></li><li><p>现代UNIX系统提供两种类型的对象库: 静态库和共享库</p></li><li><p>静态库</p><blockquote><p>有时也可称之为档案文件[archives]，是早期UNIX系统中唯一的一种目标库<br>从本质上来讲，可以将静态库描述为: 是对已编译目标模块的一种结构化整合<br>使用静态库时需要在创建程序的链接命令中指定相应的库<br>主程序会在之后对静态库中隶属于各目标模块的不同函数加以引用<br>对于细节这里先不做过多描述，此后的章节内会对其进行具体且完整的刨析与使用和实践</p></blockquote></li><li><p>共享库</p><blockquote><p>共享库存在的意义亦在解决静态库所存在的问题<br>如果将程序链接到共享库，那么此时的链接器就不会把库中的目标模块复制到执行行文件中，而是在可执行文件中写入一条记录，用以表名可执行文件在运行时需要使用该共享库<br>在运行时将可执行文件载入内存的同时会由一个名为动态链接器的程序进行同步执行，以确保将可执行文件所需的动态库找到，并载入内存<br>随后实施运行时链接，解析可执行文件中的函数调用，将其与共享库中的函数定义相关联起来<br>在运行时的共享库代码在内存中秩序保存一份，且可供所有运行中的程序使用<br>且经过编译处理的函数仅在共享库内保存一份以解决磁盘空间<br>此设计还能确保各类程序在编译时会及时使用到函数的最新版本，即只需将带有函数新定义的共享库重新加以编译即可，程序将会在下次执行时自动使用新函数</p></blockquote></li></ul><hr><p><strong>进程间通信及其同步</strong></p><ul><li><p>Linux系统上运行有多个进程，其中许多都是独立运行</p><blockquote><p>然而有些进程必须相互合作以达成预期目的，因此彼此间需要通信和同步机制</p></blockquote></li><li><p>读写磁盘文件中的信息是进程通信的方法之一</p><blockquote><p>可是这种方法对于许多程序来说既慢又缺乏灵活性<br>因此，Linux像所有现代UNIX系统所实现的那样去提供了丰富进程间通信的IPC机制</p></blockquote></li><li><p>IPC机制相关概念列表/相关作用及其存在意义:</p><blockquote><p>信号(signal)，用于表示实践的发生<br>管道(即shell用户中的”|”)操作符和FIFO，用于在进程间传递数据<br>套接字，用于为同一台主机或是联网的不同主机上所允许的进程之间传递数据<br>文件锁定，用于防止其它进程读取或更新文件内容，同时运行某进程对文件的部分区域加以锁定<br>消息队列，用于在进程之间交换消息(数据包)<br>信号量(semaphore)，用于同步进程动作<br>共享内存，用于运行两个及两个以上的进程共享同一块内存</p></blockquote></li><li><p>就本质而言，FIFO和UNIX套接字的功能几近相同，即允许统一系统上并无关联的进程间彼此交换数据</p></li><li><p>两种可以并存于现在UNIX系统之中是由于FIFO来自System V，而套接字则源于BSD</p></li><li><p>IPC相关概念:</p><blockquote><p>对于信号及对其的深入刨析与讨论(依旧在后续章节对其实现与刨析)</p></blockquote></li></ul><hr><p><strong>线程</strong></p><ul><li><p>线程的基本概念描述:</p><blockquote><p>在现代UNIX实现中，每个进程都可执行多个线程<br>可将线程的概念比喻为共享同一虚拟内存及一干其它属性的进程<br>每个线程都会执行相同的程序代码，共享同一数据区域和堆<br>并且在同时，每个线程都拥有属于自己的栈，用以装载本地变量和函数调用等链接信息<br>线程之间可通过共享的全局变量进行通信<br>此外，利用上面所描述的IPC和同步机制，线程之间也能够彼此通信</p></blockquote></li><li><p>线程的优点:</p><blockquote><p>线程的优点就在于协同线程之间的数据共享(通过全局变量)更为容易<br>而且就某些算法而论，以多线程来实现比之以多进程实现要更加自然<br>再者就是多线程应用能从多处理器硬件的并行处理中受益匪浅</p></blockquote></li><li><p>有关线程的相关概念列表:</p><blockquote><p>进程组<br>shell任务控制机制<br>会话机制<br>控制终端机制<br>控制进程机制</p></blockquote></li></ul><hr><p><strong>其它操作系统层面的相关概念:</strong></p><ul><li><p>伪终端，是一对相互连接的虚拟设备，也可称之为主从设备</p><blockquote><p>在这对设备之间，设有一条IPC信道以供数据之间进行双向传递<br>并且从设备(slave device)所提供的接口，其行为方式与终端相类似<br>最知名的伪终端要数telnet和ssh之类提供网络登陆服务的应用，以及 x window 系统所提供的终端窗口实现</p></blockquote></li><li><p>日期和时间</p><blockquote><p>进程涉及两种类型时间: 真实时间与进程时间(即为CPU时间，指自进程启动而来，所占有的CPU时间总量)<br>还可进一步的将CPU时间划分为系统CPU时间和用户CPU时间，前者用于指内核模式中执行代码所占用的时间，后者用于指在用户模式中执行代码所占用的时间<br>time命令会显示出真实时间，系统CPU时间，以及执行管道中的多个线程而花费的用户CPU时间</p></blockquote></li><li><p>客户端/服务器架构</p><blockquote><p>即C/S架构<br>这里不做过多赘述</p></blockquote></li><li><p>实时性</p><blockquote><p>纯粹性概念，字面理解<br>关于实时性概念的实现与对其的具体定义这里不做过多赘述</p></blockquote></li><li><p><code>/proc</code>文件系统</p><blockquote><p>在Linux中实现并且提供了类似于其它的现代UNIX系统中的<code>/proc</code>文件系统<br>由一组目录和文件所组成，装配(mount，或称其为挂载)于<code>/proc</code>目录下<br><code>/proc</code>文件系统是一种虚拟文件系统，以文件系统目录和文件形式来提供一个指向内核数据结构的接口<br>以用于用户查看，改变和管理各种系统属性<br>关于/proc文件系统的内容这里先不做过多赘述，今后的章节内会进行刨析与实践</p></blockquote></li></ul><hr><p><strong>本章节所涉及的相关概念归纳</strong></p><ul><li>涉及概念一览(完整版本)</li><li>UNIX/Linux kernel</li><li>操作系统</li><li>shell/shell任务控制</li><li>文件</li><li>I/O模型</li><li>程序</li><li>进程/进程间通信与进程间同步</li><li>信号</li><li>线程</li><li>进程组</li><li>会话</li><li>内存/内存映射</li><li>静态库</li><li>共享库</li><li>终端控制</li><li>进程控制</li><li>伪终端</li><li>日期及时间</li><li>C/S-客户端/服务器架构</li><li>实时性</li><li><code>/proc</code>文件系统</li></ul><p><strong>本章节涉及概念一览(简化版本):</strong></p><ul><li>UNIX/Linux kernel</li><li>Shell</li><li>操作系统</li><li>数据结构</li><li>文件系统</li><li>I/O模型</li><li>程序 (C/S)</li><li>内存</li><li>终端</li><li>库文件</li><li>进程/线程</li><li><code>/proc</code>文件系统</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>所有涉及的文献资料皆来源于电子书籍</p></li><li><p><a href="http://unit-serow.com/2020/03/05/OS-1/#more" target="_blank" rel="noopener">CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)</a></p><blockquote><p>第二章节内容<br>PDF资源可参考文章OS-1</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux内核与操作系统基本概念归纳&lt;/strong&gt;&lt;/center&gt;&lt;center&gt;&lt;strong&gt;UNIX/Linux-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>自由</title>
    <link href="https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/"/>
    <id>https://unit-serow.github.io/2020/03/06/%E8%87%AA%E7%94%B1/</id>
    <published>2020-03-06T04:32:03.000Z</published>
    <updated>2020-03-06T04:33:29.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>自由-主观</strong></center><a id="more"></a><h3 id="自由"><a href="#自由" class="headerlink" title="自由"></a>自由</h3><ul><li>论题三大核心: 自由/纯粹/智慧</li></ul><p><strong>关键字:</strong></p><ul><li>纯粹</li><li>本质</li><li>自由/纯粹自由</li><li>理智/纯粹理智</li><li>本能/纯粹本能</li><li>智慧/纯粹智慧</li></ul><hr><p><strong>论题:</strong></p><ul><li>什么是自由</li><li>自由从从何而来</li><li>自由的本质是什么</li></ul><hr><p><strong>引论:</strong></p><ul><li>如何定义自由</li><li>对于自由的主观定义</li><li>所谓的自由</li><li>自由于精神层面的理解</li><li>自由于现实层面的实现</li><li>为何要去实现或追求自由</li></ul><hr><h3 id="人类-1"><a href="#人类-1" class="headerlink" title="人类-1"></a>人类-1</h3><p><strong>论题推论:</strong></p><ul><li>什么是自由</li><li>自由从何而来</li><li>自由的本质是什么</li></ul><p><strong>什么是自由?/自由从何而来?/自由的本质是什么?</strong></p><ul><li><p>自由源于人类的本质与天性，所谓天性，即为因存在于现实世界而产生的本能性质的无智逻辑(如果以具备智慧层面的生物来定义，也可称此为无逻辑)</p></li><li><p>但世事皆有因果，万物皆成逻辑(这里将不会过多的带入无的相关与衍生概念)</p></li><li><p>无智逻辑(亦可将其称之或理解为环境逻辑与自然逻辑)</p></li><li><p>存在即现实</p><blockquote><p>世界(即环境)源于空，空源于无<br>任何现实事物的本质来源于世界与环境，包括生命与智慧<br>生命是一切存在于现实的前提，但生命不会定义存在，而智慧可以定义存在<br>存在只是作为存在而存在于现实，概念将归于空-0<br>而当现实的存在被[定义]为存在于现实时，概念将归于世界，即为有-1<br>无即为无</p></blockquote></li><li><p>对于自由的主观定义</p><blockquote><p>在人类的存在还没有被定义之时，生物(即现实层面)的本质就早已被世界或环境所定义<br>此概念的逻辑为无智慧逻辑，也可将其定义于空，将不会产生任何讨论意义<br>此层面逻辑定义了人类于现实层面(世界)内最基本的性质，即存在(生命)<br>而伴随生命而存在的其它事物-现实，世界，无智逻辑(环境逻辑)<br>此间的现实中不存在于秩序，规则与存在等智慧层面的逻辑与概念</p></blockquote></li><li><p>存在即现实</p><blockquote><p>而自由与自由的概念所产生的本质皆来源于此刻<br>为什么会存在自由，有关自由的一切概念从何而来<br>自由来源于本质，而本质来源于环境与世界，世界源于空</p></blockquote></li><li><p>至此，引出我对自由的主观定义</p><blockquote><p>自由虽源于空，但绝不是凭空出现的<br>自由只是人类/生物于现实世界间所产生与拥有的本质<br>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面<br>或称为自由存在于现实层面，由此被智慧定义</p></blockquote></li><li><p>自由有可能可以被归于纯粹层面，即纯粹自由/本质(本能)自由</p><blockquote><p>自由是无智的逻辑，归于本质与本能，是人类永远不可能抛离的概念与本质<br>但人类拥有智慧，智慧可以定义与控制本质与本能<br>智慧存在于现实或精神层面之间的意义，即为定义本能或称[一切存在于世界之间的概念]<br>自由源于空，源于世界，源于本质，但绝对不会[源]于智慧<br>追求本质也是人类作为生物而存在于现实间的本质<br>一切概念与现实皆源于空，即存在-源于空</p></blockquote></li><li><p>存在即现实</p><blockquote><p>存在于现实间的本质与基本的条件/逻辑/概念—即为生命<br>即-生命归于现实，现实归于本质(人类)，本质归于空<br>至此自由是同存在/生命而存在与现实的<br>即人类/生物的本质即为存在，存在则为自由-[无规则(无秩序)/空-无]<br>人类源于空/无，人类/生物的本质即为空/无<br>自由是无概念概念，前者的概念为无，后者的概念为智慧所定义的概念<br>由源于空/源于无，自由是由无智时期就存在于现实间的概念</p></blockquote></li><li><p>生命与自由是人存在于现实的本质，本质即为无智逻辑</p><blockquote><p>于空或无间定义的概念，存在于现实间的人类或生物将永远无法抛离<br>不存在即为无意义，将不会产生任何讨论的意义<br>但不存在于现实可以进行讨论，这里先不进行讨论</p></blockquote></li><li><p>我目前还没有找到我想要找到的答案……</p><blockquote><p>拥有智慧的人类与逻辑定义了自由，由此自由存在于现实层面 <?>自由存在于现实层面，由此被智慧定义 <?> 迷惑概念<br>主观的现实逻辑混乱，有一些概念只可意会，无法言传<br>或称为我的主观智慧层次与逻辑层次未到足矣将其以言传之的境界</p></blockquote></li></ul><hr><p><strong>引论答案:</strong></p><ul><li><p>如何定义自由</p></li><li><p>对于自由的主观定义</p><blockquote><p>自由于主观智慧被定义为无逻辑概念</p></blockquote></li><li><p>所谓的自由</p></li><li><p>自由于精神层面的理解</p></li><li><p>自由于现实层面的实现</p></li><li><p>为何要去实现或追求自由</p><blockquote><p>自由源于本质，本质源于现实，讨论于智慧层面间的存在等概念将不会产生任何存在意义<br>现实源于空，空源于无</p></blockquote></li></ul><hr><ul><li><p>一切皆归于无，一切皆可定义为无</p><blockquote><p>逻辑漏洞/逻辑死角/逻辑缺口<br>或称为现实(世界/环境)漏洞/现实缺陷<br>世界也可将其主观的定义为宇宙(现实)</p></blockquote></li><li><p>无</p><blockquote><p>现实逻辑漏洞，有待思考……</p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li><p>如何实现自由，现实间的自由为何物？</p></li><li><p>为何要去实现与追求自由？</p></li><li><p>自由来源于本能，同时将终于智慧</p><blockquote><p>智慧与理智的产物-规则与秩序<br>限制了所谓的自由(即本能)<br>自由所带来的结果必然与智慧(最基本且必然的产物: 规则/秩序)相对<br>当然，由资本所带来的规则与秩序是极度不堪与肮脏的<br>纯粹的智慧终究会产生最精密的逻辑与最极端的规则与秩序<br>而拥有与持续规则与秩序的最基本的条件与概念为-[理智]<br>理智是完全相对于本能的，相对于生物的(与之完全对立且相反，这里称其为相对)<br>或称其是完全且绝对相对于低等/低智能或无智能生物的</p></blockquote></li><li><p>规则与秩序的最基本条件是理智，同时来源于智慧</p><blockquote><p>一味的追求本能与自由的后果即为-停止前进/进化<br>本能与智慧-自由与秩序-滞留与进化<br>自由在理智与智慧的层面是无意义的，是愚昧的，是与之完全/绝对相对的<br>但在本质与本能的层面是完全合理的，是必然的，是完全符合无智逻辑的，是完全正确的</p></blockquote></li><li><p>人类的本质是社会性的</p><blockquote><p>而现有/现实存在的人类/生物的最高进化概念即为-共产主义<br>智慧，理智与秩序最高的社会性形态即为共产主义社会<br>共产主义不会脱离社会性(或称共产主义就是完全建立在社会性的基础上的)，即绝对且完全不会去尝试抛离本能(抛离本能的概念将不存在于现实)<br>而共产主义的弊端即为-此概念是近乎抛离本能的(非本质)，所以成为纯粹共产主义者的前提-就是拥有绝对且成熟的理智与纯粹的智慧<br>抛离本能带来的最终结果即为-抛离自由-共产主义者的自由将必然会被社会性/所处共产主义社会形态所完全(或称绝对)剥夺</p></blockquote></li><li><p>纯粹共产主义社会没有自由可言</p><blockquote><p>因为每一个独立者都将拥有最绝对的理智与最纯粹的智慧<br>它们将不乞求于自由<br>它们将抛离生物的本能(非本质)<br>目前看来…<br>它们…注定不会是存在于现实间的人类…<br>生产力完全充足之时，将有可能实现？<br>不<br>只有当人类完全抛离生而为人/为生物的本质之时<br>才有可能实现<br>此概念将抛离于现实</p></blockquote></li><li><p>人类实现共产主义…</p><blockquote><p>机械智能能否实现共产主义？<br>只有纯粹的精神意识体，能够实现所谓的纯粹共产主义-即纯粹理想主义<br>纯粹理想主义的概念为非现实概念(即便有可能存在于现实)</p></blockquote></li><li><p>纯粹-纯粹自由/纯粹共产主义</p></li></ul><p><strong>至此</strong></p><hr><ul><li>下一论题<blockquote><p>规则与秩序</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;自由-主观&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>UNIX/PIPE-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/PIPE-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/PIPE-1/</id>
    <published>2020-03-05T06:37:00.000Z</published>
    <updated>2020-03-06T08:00:26.120Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>UNIX-PIPES概述</strong></center><a id="more"></a><h2 id="UNIX-PIPE-1"><a href="#UNIX-PIPE-1" class="headerlink" title="UNIX/PIPE-1"></a>UNIX/PIPE-1</h2><hr><h3 id="Unix-Pipeline-Pipes-1"><a href="#Unix-Pipeline-Pipes-1" class="headerlink" title="Unix-Pipeline/Pipes-1"></a>Unix-Pipeline/Pipes-1</h3><p><strong>概述:</strong></p><ul><li>管道(Pipeline)是一系列将标准输入输出链接起来的进程</li><li>其中每一个进程的输出被直接作为下一个进程的输入</li><li>每一个链接都由匿名管道实现</li><li>管道中的组成元素也被称作过滤程序</li><li>通常被用于类Unix操作系统(以及一些其他借用了这个设计的操作系统，如Windows)中</li><li>其他操作系统的这个特色源自于Unix，例如Taos和MS-DOS<blockquote><p>最终成为软件工程的管道与过滤器设计样本</p></blockquote></li><li>这个概念是由道格拉斯·麦克罗伊为Unix命令行发明的，因与物理上的管道相似而得名</li><li>UNIX管道技术需要注意的一点就是需要将管道与管线区分开来(两种截然不同的概念)</li></ul><hr><h3 id="具体描述"><a href="#具体描述" class="headerlink" title="具体描述:"></a>具体描述:</h3><p><strong>管道概念:</strong></p><ol><li>管道是用于将一系列的标准输入输出指令(代码)链接起来，从而形成进程的最基本条件</li><li>并且被链接的每一个进程的输出被直接作为下一个进程的输入</li></ol><p><strong>还可以将其描述为:</strong></p><ol><li><p>管道是将一系列标准输入输出链接起来的进程</p></li><li><p>其中每一个进程的输出被直接作为下一个进程的输入</p></li><li><p>其中每一个链接都由匿名管道实现</p></li><li><p>管道中的组成元素也被称作过滤程序</p></li></ol><ul><li><p>其概念模型非常类似于现实世界种的管道</p></li><li><p>该图片描述了某一文字终端上一个包含三个程序的管道:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>管线:</strong></p><ul><li><p>是指将计算机指令处理过程拆分为多个步骤</p></li><li><p>并通过多个硬件处理单元并行执行来加快指令执行速度</p></li><li><p>亦可称之为流水线</p><blockquote><p>因为其具体执行过程类似工厂中的流水线，并因此得名<br>可以将计算机指令比喻为流水线传送带上的产品<br>而各个硬件处理单元就是流水线旁的工人<br>每个不同的产品都需要细分为几个互不相同的部门来实现其各部件的所需<br>所以流水线中所属部门不同的工人会为了同一个产品而同时工作</p></blockquote></li></ul><hr><ul><li>微处理器</li><li>在使用流水线的处理器中一个指令不是在处理器的一个定时器信号中完成的<blockquote><p>而是被分到多个信号中去完成，但是与此同时多个指令的分任务被同时处理</p></blockquote></li><li>由于这些分任务比整个指令要简单，因此可以通过使用流水线提高定时器频率<blockquote><p>虽然每个指令需要多个信号后才能完成<br>但是通过多个指令的并行运算每个信号内一个指令可以完成<br>因此通过这个方法整个速度可以提高</p></blockquote></li></ul><hr><ul><li>流水线级</li><li>一条流水线的每个分步骤被称为流水线级<blockquote><p>它们被流水线寄存器分开除指令流水线外在现代系统中还有其它流水线<br>比如用来计算浮点数的算术流水线</p></blockquote></li></ul><hr><ul><li>管线危障(pipeline hazards)</li><li>假如，一个指令在执行的时候，需要等待流水线上前一个指令先执行完毕的话<blockquote><p>那么这两个指令相互之间彼此有依赖关系<br>这可能导致流水线冲突的现象发生<br>即为管线危障</p></blockquote></li><li>常见情况可分为四种: 资源冲突/数据冲突(指令层的数据冲突/传输层的数据冲突)/控制流冲突</li><li>通过分支预测器可以避免控制冲突<blockquote><p>在这里处理器预测性地继续运算，直到正式预测是正确为止</p></blockquote></li></ul><hr><p><strong>网络管线:</strong></p><ul><li>Unix哲学: “一切皆文件”<blockquote><p>netcat和socat这样的工具可以将管道连接到TCP/IP套接字</p></blockquote></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>管道(UNIX)</li><li>具名管道</li><li>命名管道</li><li>匿名管道</li><li>匿名命名管道</li><li>哈特曼管道</li><li>管线(流水线)</li><li>管线/流水线(计算机)</li><li>管线危障(pipeline hazards)</li><li>重定向(计算机)</li><li><code>tee指令</code><blockquote><p>该程序用于从管线内取出数据</p></blockquote></li><li>XML管道即为处理XML的管线</li><li>网络管线</li><li>UNIX</li><li>进程间通信</li><li>数字通信技术<blockquote><p>计算机通信技术</p></blockquote></li><li>管道协议</li><li>并发计算</li><li>协同控制</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>EN-System Interfaces<a href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html" target="_blank" rel="noopener">跳转</a></p></li><li><p>单一UNIX规范第7期，由国际开放标准组织发布</p><blockquote><p><code>https://pubs.opengroup.org/onlinepubs/9699919799/functions/pipe.html</code></p></blockquote></li><li><p>EN-Pipes: A Brief Introduction by The Linux Information Project (LINFO)<a href="http://www.linfo.org/pipe.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linfo.org/pipe.html</code></p></blockquote></li><li><p>获取管道的doc文案: <a href="http://www.cs.rit.edu/~swm/history/DTSS.doc" target="_blank" rel="noopener">http://www.cs.rit.edu/~swm/history/DTSS.doc</a></p></li></ul><hr><ul><li><p>以下内容参考自中文维基:</p></li><li><p>CN-分类:</p><blockquote><p>进程通信<a href="https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">跳转</a><br>进程间通信<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/Category:%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1</code><br><code>https://zh.wikipedia.org/wiki/%E8%A1%8C%E7%A8%8B%E9%96%93%E9%80%9A%E8%A8%8A</code></p></blockquote></li><li><p>CN-分类: UNIX<a href="https://zh.wikipedia.org/wiki/Category:Unix" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Unix</code></p></blockquote></li><li><p>CN-分类: 并发计算<a href="https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%B9%B6%E5%8F%91%E8%AE%A1%E7%AE%97</code></p></blockquote></li><li><p>CN-分类: 协同控制<a href="https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%8D%94%E5%90%8C%E6%8E%A7%E5%88%B6</code></p></blockquote></li><li><p>EN-分类: 指令处理<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><ul><li>CN-维基百科-点对点隧道协议: <a href="https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0</a></li><li>CN-维基百科-管道机制: <a href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(Unix)</a></li><li>CN-维基百科-管道流: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-IDC: <a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83</a></li><li>CN-维基百科-管线: <a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E6%B5%81%E6%B0%B4%E7%BA%BF_(%E8%AE%A1%E7%AE%97%E6%9C%BA)</a></li><li>CN-维基百科-命名管道: <a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93</a></li><li>EN-维基百科-管道(计算机): <a href="https://en.wikipedia.org/wiki/Pipeline_(computing)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pipeline_(computing)</a></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;UNIX-PIPES概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="UNIX" scheme="https://unit-serow.github.io/tags/UNIX/"/>
    
  </entry>
  
  <entry>
    <title>OS-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/OS-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/OS-1/</id>
    <published>2020-03-05T03:34:05.000Z</published>
    <updated>2020-03-05T05:12:06.302Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>OS-PDF/URL资源整合目录</strong></center><a id="more"></a><h2 id="Operating-System-1"><a href="#Operating-System-1" class="headerlink" title="Operating System-1"></a>Operating System-1</h2><ul><li>操作系统</li><li>Operating System/OS</li></ul><hr><h3 id="电子书资源整合目录"><a href="#电子书资源整合目录" class="headerlink" title="电子书资源整合目录"></a>电子书资源整合目录</h3><ul><li><p>可能还会利用持续利用此文本进行URL资源整合</p></li><li><p>操作系统概念</p></li><li><p>操作系统原理</p></li><li><p>操作系统设计</p></li><li><p>操作系统制作</p></li><li><p>操作系统实现</p></li></ul><hr><ul><li>操作系统分析与理解<blockquote><p>Unix操作系统<br>FreeBSD(Unix-Like)操作系统<br>Linux(Unix-Like)操作系统</p></blockquote></li></ul><hr><ul><li>中文维基-<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">操作系统</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F</code></p></blockquote></li></ul><hr><p><strong>使用资源目录:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)<a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/297382.html</code><br><code>https://pan.baidu.com/s/1ntzHejv</code></p></blockquote></li><li><p>CN-Linux系统编程手册上册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p></li><li><p>CN-Linux系统编程手册下册<a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2016-10/135953.htm</code></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)<a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/232150.html</code></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)<a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://pan.baidu.com/s/1gdKdxlT</code></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)<a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/90585.html</code></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)<a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jb51.net/books/294083.html</code></p></blockquote></li></ul><hr><p><strong>资源相关URL补充:</strong></p><ul><li><p>Linux/UNIX编程手册(分卷压缩文件)</p><blockquote><p><code>https://download.csdn.net/download/js_gary/10216486</code><br><code>https://download.csdn.net/download/js_gary/10216495</code></p></blockquote></li><li><p>FreeBSD解析</p><blockquote><p><a href="https://download.csdn.net/download/starry225/6223229" target="_blank" rel="noopener">https://download.csdn.net/download/starry225/6223229</a></p></blockquote></li></ul><hr><p><strong>整合包获取:</strong></p><ul><li>以上PDF资源整合文件的压缩包(一共七本电子书，rar格式):</li><li>百度网盘地址<a href="https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w" target="_blank" rel="noopener">永久链接</a><blockquote><p><code>https://pan.baidu.com/s/1SPRq_DI9Seey9R4iJJp_5w</code></p></blockquote></li><li>提取码: j3qc</li></ul><hr><p><strong>资源汇总:</strong></p><ul><li><p>CN-操作系统概念 (原书第7版)</p><blockquote><p><a href="https://www.jb51.net/books/297382.html" target="_blank" rel="noopener">https://www.jb51.net/books/297382.html</a><br><a href="https://pan.baidu.com/s/1ntzHejv" target="_blank" rel="noopener">https://pan.baidu.com/s/1ntzHejv</a></p></blockquote></li><li><p>CN-Linux系统编程手册上册</p></li><li><p>CN-Linux系统编程手册下册</p><blockquote><p><a href="https://www.linuxidc.com/Linux/2016-10/135953.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2016-10/135953.htm</a></p></blockquote></li><li><p>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</p><blockquote><p><a href="http://www.downcc.com/soft/302635.html" target="_blank" rel="noopener">http://www.downcc.com/soft/302635.html</a></p></blockquote></li><li><p>CN-现代操作系统 (原书第四版)</p><blockquote><p><a href="https://www.jb51.net/books/655464.html" target="_blank" rel="noopener">https://www.jb51.net/books/655464.html</a></p></blockquote></li><li><p>CN-操作系统精髓与设计原理 (原书第六版)</p><blockquote><p><a href="https://www.jb51.net/books/232150.html" target="_blank" rel="noopener">https://www.jb51.net/books/232150.html</a></p></blockquote></li><li><p>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</p></li><li><p>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</p><blockquote><p><a href="https://www.jb51.net/books/483820.html" target="_blank" rel="noopener">https://www.jb51.net/books/483820.html</a></p></blockquote></li><li><p>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</p><blockquote><p><a href="https://pan.baidu.com/s/1gdKdxlT" target="_blank" rel="noopener">https://pan.baidu.com/s/1gdKdxlT</a></p></blockquote></li><li><p>CN-深入理解UNIX系统内核 (瓦哈利亚)</p><blockquote><p><a href="https://www.jb51.net/books/609170.html" target="_blank" rel="noopener">https://www.jb51.net/books/609170.html</a></p></blockquote></li><li><p>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</p><blockquote><p><a href="https://www.jb51.net/books/294083.html" target="_blank" rel="noopener">https://www.jb51.net/books/294083.html</a></p></blockquote></li><li><p>CN-30天自制操作系统 (2012版，川和秀实)</p><blockquote><p><a href="https://www.jb51.net/books/90585.html" target="_blank" rel="noopener">https://www.jb51.net/books/90585.html</a></p></blockquote></li></ul><hr><p><strong>书籍参考目录:</strong></p><ul><li>CN-操作系统概念 (原书第九版)</li><li>CN-操作系统概念 (2007-第七版，西尔伯查茨)</li><li>CN-操作系统概念 (原书第7版，清大出版)</li><li>CN-操作系统概念精要 (原书第二版)</li></ul><hr><ul><li>CN-Linux系统编程手册上册</li><li>CN-Linux系统编程手册下册</li><li>CN-Linux系统编程: Linux系统编程 (2009年，原书第二版)</li></ul><hr><ul><li>CN-现代操作系统 (原书第四版)</li><li>CN-现代操作系统 (原书第三版)</li></ul><hr><ul><li>CN-操作系统精髓与设计原理 (原书第六版)</li><li>CN-计算机系统: 核心概念及软硬件实现 (原书第四版)</li><li>CN-操作系统设计与实现上册 (2007版，Andrew S. Tanenbaum/Albert S. Woodhull)</li><li>CN-操作系统设计与实现下册 (2007版，ANDREWS.)</li><li>CN-操作系统设计与实现 (2008版，ANDREW S.TANENBAUM/ALBERT S.WOODHULL)</li></ul><hr><ul><li>CN-UNIX操作系统设计 (2000版，Maurice J.Bach)</li><li>CN-FreeBSD操作系统设计与实现 (2006版，麦库西克)</li><li>CN-30天自制操作系统 (2012版，川和秀实)</li><li>CN-深入理解UNIX系统内核 (瓦哈利亚)</li></ul><hr><p><strong>其它:</strong></p><ul><li>书不重要</li><li>问题在于看书的人所拥有的能力</li><li>同种类型的书的本质都是相同的</li><li>找出，理解并且完全记住其中的关键字</li><li>至于对于电子书的版号的选择也无所谓的</li><li>译版与原版随意，有译版最好读译版</li><li>通常EN版的寻找难度比CN版小很多</li></ul><hr><ul><li>系统化学习目录</li><li>Operating System kernel</li><li>数字理论基础</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;OS-PDF/URL资源整合目录&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/OS/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS" scheme="https://unit-serow.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>VPS/KVM-1</title>
    <link href="https://unit-serow.github.io/2020/03/05/VPS-KVM-1/"/>
    <id>https://unit-serow.github.io/2020/03/05/VPS-KVM-1/</id>
    <published>2020-03-04T20:28:57.000Z</published>
    <updated>2020-03-05T06:53:16.497Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>VPS/KVM简要概述</strong></center><a id="more"></a><h2 id="VPS-KVM-1"><a href="#VPS-KVM-1" class="headerlink" title="VPS/KVM-1"></a>VPS/KVM-1</h2><hr><h3 id="虚拟专用服务器-Virtual-private-server"><a href="#虚拟专用服务器-Virtual-private-server" class="headerlink" title="虚拟专用服务器 (Virtual private server)"></a>虚拟专用服务器 (Virtual private server)</h3><p><strong>简述:</strong></p><ul><li>简称VPS</li><li>由容器技术或虚拟机技术实现</li><li>在容器或虚拟机中，每个VPS都拥有独立的公网IP，操作系统，磁盘空间，内存与处理器资源<blockquote><p>同时进程与系统配置之间也相互隔离<br>目的就是为了让用户和应用程序在同一个主机上模拟出完全不同，独立且相互隔离的资源占用与控制<br>以此让VPS可以完全拥有独立服务器的所有功能</p></blockquote></li><li>并且VPS为用户提供了管理配置的自由</li><li>VPS多用于企业虚拟化于IDC资源租用</li><li>VPS拥有完全的独立性，包括可以在容器内自行安装任何程序与其它对于虚拟硬件的操作<blockquote><p>远端服务器-&gt;容器/虚拟机-&gt;容器/虚拟机-&gt;用户</p></blockquote></li></ul><hr><h3 id="基于内核的虚拟机-Kernel-based-Virtual-Machine"><a href="#基于内核的虚拟机-Kernel-based-Virtual-Machine" class="headerlink" title="基于内核的虚拟机 (Kernel-based Virtual Machine)"></a>基于内核的虚拟机 (Kernel-based Virtual Machine)</h3><p><strong>简述:</strong></p><ul><li>可简称为KVM</li><li>是一种用于Linux内核中的虚拟化基础设施，可将Linux内核转化为一个虚拟机监视器</li><li>KVM于2007年2月5日被导入Linux 2.6.20核心中，基于C</li><li>KVM需要支持硬件虚拟化拓展特性的处理器</li><li>对于操作系统支持的范围较为广泛</li><li>基于多个GNY协议授权<blockquote><p>包括KVM内核模块: GPL v2<br>KVM用户模块: LGPL v2<br>QEMU虚拟CPU内核库(libqemu.a)和QEMU PC系统模拟器: LGPL<br>Linux用户模式QEMU模拟器: GPL<br>BIOS文件(bios.bin，vgabios.bin和vgabios-cirrus.bin): LGPL v2或更新</p></blockquote></li><li>KVM现由保罗·邦齐尼(Paolo Bonzini)维护</li><li>KVM 支持VirtIO半虚拟化技术-平行虚拟化技术(paravirtualization)</li></ul><hr><p><strong>内部结构:</strong></p><ul><li>KVM提供抽象的设备，但不模拟处理器</li><li>它开放了<code>/dev/kvm</code>接口，供使用者模式的主机使用:</li></ul><ol><li>设置客户虚拟机的地址空间<blockquote><p>宿主机同样也需用户可用于引导进主操作系统的固件镜像(通常为模拟PC时的自定义BIOS)</p></blockquote></li><li>为客户机模拟I/O</li><li>将客户机的视频显示映射回系统宿主机上</li></ol><ul><li><p>在Linux上，QEMU版本0.10.1及更新版就是一个用户层主机</p><blockquote><p>QEMU使用KVM以近乎原生的速度虚拟化客户机，若无KVM的话则将仅使用软件模拟</p></blockquote></li><li><p>KVM内部使用SeaBIOS作为对16位x86 BIOS的开源模拟</p></li><li><p>KVM/QEMU环境的高级概述:</p></li></ul><img src="/images/KVM-1.png" width="40%" height="40%"><hr><p><strong>相关GUI(图形化管理)工具:</strong></p><ul><li>Kimchi – 网页版KVM虚拟化管理工具</li><li>Virtual Machine Manager – 支持创建、编辑、开始于关闭基于KVM的虚拟机，同时也支持对宿主之间的实时或冷拖拽虚拟机迁移</li><li>Proxmox虚拟环境 – 一项开源的虚拟化管理包，包括KVM与LXC<blockquote><p>同时它还有裸机安装器、网页版远程管理界面、HA集群堆栈、统一存储、柔性网络及可选的商业支持</p></blockquote></li><li>OpenQRM – 用于管理不同数据中心基础设施的平台</li><li>GNOME 机柜 – Linux上用于管理libvirt客户机的Gnome界面</li><li>oVirt – 用于管理基于libvirt的KVM开源工具</li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>VPS</li><li>KVM</li><li>Virtual</li><li>CN2</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-Redhat-KVM官方网站<a href="https://www.linux-kvm.org/page/Main_Page" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux-kvm.org/page/Main_Page</code></p></blockquote></li><li><p>CN-CN2线路是什么，有哪些CN2线路的VPS<a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</code></p></blockquote></li></ul><p><strong>维基百科参考内容:</strong></p><ul><li><p>CN-虚拟主机<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA</code></p></blockquote></li><li><p>CN-虚拟专用服务器<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-服务器<a href="https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E6%9C%8D%E5%8A%A1%E5%99%A8</code></p></blockquote></li><li><p>CN-虚拟化<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>CN-硬件虚拟化<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E8%99%9A%E6%8B%9F%E5%8C%96</code></p></blockquote></li><li><p>CN-KVM-基于内核的虚拟机<a href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA</code></p></blockquote></li></ul><hr><h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a>Shadowsocks</h3><ul><li><p>境外KVM类型的VPS大约360RMB/年(美国)</p><blockquote><p>最便宜的</p></blockquote></li><li><p>官网地址: <a href="https://shadowsocks.org/en/index.html" target="_blank" rel="noopener">https://shadowsocks.org/en/index.html</a></p></li><li><p>仓库地址: <a href="https://github.com/shadowsocks" target="_blank" rel="noopener">https://github.com/shadowsocks</a></p></li></ul><hr><p><strong>可用参考:</strong></p><ul><li><p>CN-Github-SS教程</p><blockquote><p><a href="https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B" target="_blank" rel="noopener">https://github.com/233boy/ss/wiki/Shadowsocks%E6%90%AD%E5%BB%BA%E8%AF%A6%E7%BB%86%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B</a><br><a href="https://ssr.tools/252" target="_blank" rel="noopener">https://ssr.tools/252</a></p></blockquote></li><li><p>搬瓦工 (Bandwagon Host)</p><blockquote><p>VPS供应商，支持支付宝支付<br><a href="https://bwh88.net/cart.php?gid=1" target="_blank" rel="noopener">https://bwh88.net/cart.php?gid=1</a><br><a href="https://bwg.net/" target="_blank" rel="noopener">https://bwg.net/</a></p></blockquote></li><li><p>CN2: <a href="https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2" target="_blank" rel="noopener">https://blog.sprov.xyz/2019/04/09/what-is-cn2-vps/#_CN2</a></p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;VPS/KVM简要概述&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Text</title>
    <link href="https://unit-serow.github.io/2020/03/04/text/"/>
    <id>https://unit-serow.github.io/2020/03/04/text/</id>
    <published>2020-03-03T23:18:27.000Z</published>
    <updated>2020-03-04T01:11:38.154Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>常驻Text文档</strong></center><a id="more"></a><p><strong>常驻随笔文档</strong></p><ul><li>无<blockquote><p>无很容易理解<br>但很难做到<br>很难在现实中实现?<br>不<br>无不属于现实<br>无则为无<br>空源于无<br>世界源于空<br>思维源于世界<br>而思维终将归于无</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;常驻Text文档&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="https://unit-serow.github.io/2020/03/02/test/"/>
    <id>https://unit-serow.github.io/2020/03/02/test/</id>
    <published>2020-03-02T12:46:19.000Z</published>
    <updated>2020-03-08T00:48:09.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><center><strong>常驻Test文档</strong></center><a id="more"></a><p><strong>样式实验文档</strong></p><p><span id="inline-blue">text.md</span></p><p><i class="fa fa-pencil"></i></p><ul><li><p>简介加粗并居中</p><blockquote><p><code>&lt;center&gt;&lt;strong&gt;常驻Test文档&lt;/strong&gt;&lt;/center&gt;</code><br><code>&lt;!-- more --&gt;</code></p></blockquote></li><li><p>插入图片</p><blockquote><p><code>&lt;img src=&quot;图片URL&quot; width=&quot;20%&quot; height=&quot;20%&quot;&gt;</code></p></blockquote></li></ul><hr><p><strong>URL收藏目录</strong></p><ul><li><p>他人学习笔记-BLFS/CLFS<a href="https://www.cnblogs.com/renren-study-notes/p/10385413.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/renren-study-notes/p/10385413.html</code></p></blockquote></li><li><p>免费高清壁纸-宇宙<a href="https://joer.ru/?id=23&start=294" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://joer.ru/?id=23&amp;start=294</code></p></blockquote></li></ul><hr><ul><li><p>更换图片教程<a href="https://www.jianshu.com/p/30bf702f533c" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/30bf702f533c</code></p></blockquote></li><li><p>调色板<a href="https://www.colorhexa.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.colorhexa.com/</code></p></blockquote></li></ul><hr><p><strong>Emacs</strong></p><ul><li><p>这里标注一个大佬-子龙山人</p></li><li><p>知乎<a href="https://zilongshanren.com/tags/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zilongshanren.com/tags/</code></p></blockquote></li><li><p>博客<a href="https://www.zhihu.com/people/zilongshanren/answers" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.zhihu.com/people/zilongshanren/answers</code></p></blockquote></li><li><p>Github-spacemacs中文教程-子龙山人<a href="https://github.com/emacs-china/Spacemacs-rocks" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/emacs-china/Spacemacs-rocks</code></p></blockquote></li></ul><hr><ul><li>EN-GNU-An Introduction to Programming in Emacs Lisp<a href="https://www.gnu.org/software/emacs/manual/html_mono/eintr.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.gnu.org/software/emacs/manual/html_mono/eintr.html</code></p></blockquote></li></ul><hr><p><strong>在线测试网站收藏:</strong></p><ul><li><p>各类教程内的在线编译测试和各类参考手册都很好用</p></li><li><p>CN-<a href="https://www.tutorialspoint.com/compile_c_online.php" target="_blank" rel="noopener">C</a></p><blockquote><p><code>https://www.tutorialspoint.com/compile_c_online.php</code></p></blockquote></li><li><p>CN-<a href="https://tool.lu/coderunner/" target="_blank" rel="noopener">tools</a></p><blockquote><p><code>https://tool.lu/coderunner/</code></p></blockquote></li><li><p>CN-<a href="http://www.dooccn.com/" target="_blank" rel="noopener">代码测试</a></p><blockquote><p><code>http://www.dooccn.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/" target="_blank" rel="noopener">RUNOOB</a></p><blockquote><p><code>https://www.runoob.com/</code></p></blockquote></li><li><p>CN-<a href="https://www.w3school.com.cn/" target="_blank" rel="noopener">W3school</a></p><blockquote><p><code>https://www.w3school.com.cn/</code></p></blockquote></li><li><p>CN-<a href="https://www.runoob.com/w3cnote/runoob-chm.html" target="_blank" rel="noopener">离线版runoob获取</a></p><blockquote><p><code>https://www.runoob.com/w3cnote/runoob-chm.html</code></p></blockquote></li><li><p>CN-Git仓库地址<a href="https://github.com/it-ebooks/w3school" target="_blank" rel="noopener">W3cshool</a><a href="https://github.com/gagayuan/runoob-PDF-/tree/master/runoob" target="_blank" rel="noopener">Runoob-PDF</a></p><blockquote><p><code>https://github.com/it-ebooks/w3school</code><br><code>https://github.com/gagayuan/runoob-PDF-/tree/master/runoob</code></p></blockquote></li></ul><hr><p><strong>CN-LFS</strong></p><ul><li>CN-LFS-仓库: <a href="https://lctt.github.io/LFS-BOOK/" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/</a></li><li>CN-LFS-v9.0: <a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</a></li></ul><hr><h3 id="社交账户"><a href="#社交账户" class="headerlink" title="社交账户"></a>社交账户</h3><ul><li><p>Github</p><blockquote><p>ID: Unit-serow<br><a href="https://github.com/Unit-serow" target="_blank" rel="noopener">https://github.com/Unit-serow</a></p></blockquote></li><li><p>开源中国</p><blockquote><p>ID: serow<br><a href="https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0" target="_blank" rel="noopener">https://my.oschina.net/u/4472318?tab=newest&amp;catalogId=0</a></p></blockquote></li><li><p>博客园</p><blockquote><p>ID: UNITED<br><a href="https://home.cnblogs.com/u/1927298/" target="_blank" rel="noopener">https://home.cnblogs.com/u/1927298/</a></p></blockquote></li><li><p>CSDN</p><blockquote><p>ID: Unit-serow<br><a href="https://i.csdn.net/#/uc/profile" target="_blank" rel="noopener">https://i.csdn.net/#/uc/profile</a></p></blockquote></li><li><p>简书</p><blockquote><p>ID: G鬣羚<br><a href="https://www.jianshu.com/u/b852f1059757" target="_blank" rel="noopener">https://www.jianshu.com/u/b852f1059757</a></p></blockquote></li><li><p>码云</p><blockquote><p>ID: serow<br><a href="https://gitee.com/serow" target="_blank" rel="noopener">https://gitee.com/serow</a></p></blockquote></li></ul><hr><p><strong>国内的云服务平台</strong></p><ul><li>华为云: <a href="https://www.huaweicloud.com/" target="_blank" rel="noopener">https://www.huaweicloud.com/</a></li><li>阿里云: <a href="https://www.aliyun.com/" target="_blank" rel="noopener">https://www.aliyun.com/</a></li><li>腾讯云: <a href="https://cloud.tencent.com/" target="_blank" rel="noopener">https://cloud.tencent.com/</a></li><li>网易云: <a href="https://www.163yun.com/" target="_blank" rel="noopener">https://www.163yun.com/</a></li><li>百度云: <a href="https://cloud.baidu.com/" target="_blank" rel="noopener">https://cloud.baidu.com/</a></li><li>小鸟云: <a href="https://www.niaoyun.com/" target="_blank" rel="noopener">https://www.niaoyun.com/</a></li><li>七牛云: <a href="https://www.qiniu.com/" target="_blank" rel="noopener">https://www.qiniu.com/</a></li></ul><hr><p><strong>LFS-金步国</strong></p><ul><li>金步国作品集<a href="http://www.jinbuguo.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.jinbuguo.com/</code></p></blockquote></li></ul><hr><ul><li>EN-Wiki-指令处理(Category:Instruction processing)<a href="https://en.wikipedia.org/wiki/Category:Instruction_processing" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://en.wikipedia.org/wiki/Category:Instruction_processing</code></p></blockquote></li></ul><hr><img src="/images/GNU-1.png" width="60%" height="60%"><ul><li>图片来源于: <a href="https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83</a></li></ul><hr><h3 id="GNU-Linux相关URL目录"><a href="#GNU-Linux相关URL目录" class="headerlink" title="GNU/Linux相关URL目录"></a>GNU/Linux相关URL目录</h3><ul><li><p>Linux Foundation<a href="https://www.linux.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linux.com/</code></p></blockquote></li><li><p>Linux Listing of Wikis<a href="https://www.wiki.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.wiki.kernel.org/</code></p></blockquote></li><li><p>Linux 内核归档 (The Linux Kernel Archives)<a href="https://www.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/</code></p></blockquote></li><li><p>Linux 内核文档 (The Linux Kernel documentation)<a href="https://www.kernel.org/doc/html/latest/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/doc/html/latest/</code></p></blockquote></li><li><p>Linux 手册页项目 (The Linux man-pages project)<a href="https://www.kernel.org/doc/man-pages/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.kernel.org/doc/man-pages/</code></p></blockquote></li><li><p>Linux kernel 发行版镜像归档<a href="https://mirrors.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mirrors.kernel.org/</code></p></blockquote></li><li><p>Kernel.org-Git存储库<a href="https://git.kernel.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://git.kernel.org/</code></p></blockquote></li><li><p>GNU<a href="https://www.gnu.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/</code></p></blockquote></li><li><p>FSF<a href="https://www.linuxfoundation.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxfoundation.org/</code></p></blockquote></li></ul><hr><ul><li><p>GNU Hurd<a href="https://www.gnu.org/software/hurd/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/hurd/</code></p></blockquote></li><li><p>GNU Compiler Collection<a href="https://gcc.gnu.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://gcc.gnu.org/</code></p></blockquote></li><li><p>GNOME<a href="https://www.gnome.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnome.org/</code></p></blockquote></li></ul><hr><ul><li><p>廖雪峰</p><blockquote><p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></p></blockquote></li><li><p>Social-icons 图标</p><blockquote><p><a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">https://fontawesome.com/icons?d=gallery</a><br><a href="https://www.easyicon.net/iconsearch/iconset:social-icons/" target="_blank" rel="noopener">https://www.easyicon.net/iconsearch/iconset:social-icons/</a></p></blockquote></li><li><p>next主题优化</p><blockquote><p><a href="https://www.dazhuanlan.com/2019/12/11/5df04019e1c6a/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2019/12/11/5df04019e1c6a/</a><br><a href="https://bestzuo.cn/posts/blog-establish.html" target="_blank" rel="noopener">https://bestzuo.cn/posts/blog-establish.html</a><br><a href="https://io-oi.me/" target="_blank" rel="noopener">https://io-oi.me/</a><br><a href="https://enfangzhong.github.io/" target="_blank" rel="noopener">https://enfangzhong.github.io/</a></p></blockquote></li></ul><hr><ul><li>Huihoo-Free Software 相关手册<blockquote><p><a href="https://docs.huihoo.com/" target="_blank" rel="noopener">https://docs.huihoo.com/</a><br><a href="https://docs.huihoo.com/homepage/shredderyin/emacs.html" target="_blank" rel="noopener">https://docs.huihoo.com/homepage/shredderyin/emacs.html</a></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;常驻Test文档&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-02</title>
    <link href="https://unit-serow.github.io/2020/03/02/%E9%9A%8F%E7%AC%94-2020-03-02/"/>
    <id>https://unit-serow.github.io/2020/03/02/%E9%9A%8F%E7%AC%94-2020-03-02/</id>
    <published>2020-03-01T21:33:55.000Z</published>
    <updated>2020-03-08T00:47:13.016Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="34c526ac3a4f8f70b145889c2a24b531984f282d4142ab4cef43a241fa6bb6f3">0267ec72f19b8c198697a4f72870a3a81ccc4bbb82346fbbc270381ace21e5e2e8dd79591ed1f4c37b03e8d050dc383a8b65f91da77dcd3ff5c0dd5146bc3014d7fd1b9d9db79593853fea11b5489f2685a8e57bad7346cae51f02a854a8e5be2757ff84e0fc013b20cdeb93052f9710f7c011f91e0f016b697edd78f25a91d76a5a6353fefd001149eea53f6d57dcd25bddde033c0a215bab8a740f6893bf7d5fee042d574092ef95cc0f478261eeaa2b965281e0ae37aa8443d668993b1bedf1645a332b27236beea657560ce65bd8280029b2ede0b5e8f6507a8a7f627a562ea1b85312fae2385d55bd380b6cfa7996dd7e242f14ec91f3516c74fc620737db59f2ca740e1b5a48a7895dbd235c26d1079fbc5705de7393fe5106ff9795b6b9f657e7162f514a4093fb2f1cdad66c44511cc3b6bc343ac504c33d34d926a143f714642c93d922768fa801ad3bab95e91302ad5a3b0b5366535dd2304b9ed1d16ff56a3d59e0c19ab8b39a9caf6b38041b03ebd08d8142d615a2efc2a20c864151e0def798cd969e11bf95f2d42fd3fefec25c5f1eda2919ed5cf2bd72636595261aa4c30ced802f0289ea2046ad13c5b2483219d03f606a51940d08ebd645ae7f6c33f6a99996c7d29e181468ace1b0ee255d376fdb167b76c4d9abf5060e3ac2487a06b322477ea18f152499b8986754017b3ea3f9cdedcf2f5cac71c55c60977258ee869d6ac30f443e50a9d2ad27d960c3c8ac9fb3d8e84d22af814aa1616cd6e0b7ee0215c7c85aaf04f9fe40046d77a07d30e9cb0022836c193a0a607c317c5804e1892e7f5f519d5c1cee56f7f3f0da6a922e2a99410e636c5e7c0d3a14bf2b996a9778f2368db286ddaea11e89bdf81143b272c5a8389a3fac9e35bd367c6a81c0bc72afd9729f040601d48767de8d6e11dcd93173f503455672ab5135139f744d25a4de81799525a8b6fa1fb3a96eff9469f4d9166ebf0b679b83be8bd7ddc1367ea754ffd356313054f5b4d433ae4f71c7749b045dfa1caf5ad24752c24de2952590bc5728c476d351a3c9374c0cd54accb6f6d0698136f283e6facb144299294259ba73ac0358c62cf53153f42f99b23e9d5255afbb2611293a5aa3755d068896d84d844b7604fb9308ac98475583468bf520cd2079eb7b02621c410a45f308ca54d8ec38f871cb340cbd0587057e043560a01421236edb5ef1363940ff27331448d113f5234ea93d34a5c16b56b85429cb67fc6d081a560f2472aedd9bf071969cedd641cf31d1a0bd369d6874148c15694e3154976eb667858440d14f7acaa07dd9be9c91c69ff9e4c6b4752c1fe7b050937603b1c5808cafa6da150bf915d8db45ce0a41a1344b4c07bd81d2fecf8813d33c71304ebb5ef277456731bafbf49462dc8a1991e71e7070e87435983b4420d85d1f76cccab68e876258fe46104393fc53f1f1fb48ac9c5664d80aa3632f4b9964b51ee3642e8a11ce4cf549cb7cae8917f2b104593a1bbced0f8f5d738de25e8bb4997edcb421f83f5e3945350934f888224207f4b583922093232c76a3300e2c8279140cb7089f298f1117a98154cb1ff399c3954a211d0698f441acdbb92d450189c0f4ba11bf95e02258a8a729dd861f82e085b205e91703810fc04066f56cf80c44d5c017c7fc54ade5b78acebe2e42babd675f4fab345b3cd85ca0ec2e1065867feab91babffe97158633f35634149975cec915001d9abd2b53d35f4b6c904340f6ef5faa26f546e69cf0393419c3b65fbf90cf2684005630610385a3a488f91fa70126a99115c7360ed8a7d5203628c353ac86f701aa4414709f758fc677a6f79c0e9f2f3700113c830f43bf6d28af752cace0913da6da9365c91dc82ff89f331eee9a546d0a15bda2ea3725c2ce8cdab6a5c44eb648ce910be2da668ba28b67945eafefc7d12a64a428bf1ef4dae988e931277ad2c60788d5f6783c86e57e01db1693beba07e831c6946aba0105f6381ac057d69ef06eef0a81846ae01a6d0778d6eda56ccfb10c535fc90ad63756d72fef0301ed508d9e5e341c0426bae706ee1ad20522c0d2a0ae974fc5be783513e938fb7d83850ec914b6fa5ee705ade956ae7e0f8e5bcd148d69da76e05ce2ecfaf28423e8f22db9195b2217e68cd035cb18ac8ef9fc4fc68c06b9f025b4893d121e6c011ceac78b20192475f8c7476e96ebcce0eeffb081cf1d25908a991a36cdd6cc7c0aab34175d2116763ab735b660da9d29c8adb120ddc5f1f4f355121910106d25fb90dc11f2710648dab7d0bdae91c1f0d107faec0dc099debeddea1f9ca55e61d5853046426648102ffe91a949e7a882172f2c79fd8c494a8a60d1393de29f7c8bfa02a64767ab5c0a5bfb4b693b96ffe4d660e94842f6213350667fb2c427f7a41ae152dddbc3f096034c2410f058f74866b2d396f0384cf7685333a1751249996c3795f46472ff06e7f12c335beb3cc9b777e41719e6e81eae9db53a22dda8d36cac67ca4614b6e65d8f82d6b7042de2456f8d6b0c426bf658bf8f23c2a04ee61e8e5a9355657cdd547e990c519520f2bcbd4d44a54481fa0b4e30b4e5289f7dae90b3a200fbb34378e33cb3719789ecba03ecc01b2f090dd8ae4705a99dce8848da2f9e41f9f6a927846fda83596382cc0189b0005cee87d93e719bf7f4f7a002de8be5e332ddb85e78ac6de1dc04e3e53e814cbe27b0b7897c051b6e876d5ebf21b396bc3b1d203352d30658272e89bb3bb0b20c4bc892203b70c6297c0ac2d80403c7d02c1717772626b8549e9940eecfb645c916b16e932778fd81d308ba6c39786d564f3e5ebde36b5ca1afd196158bc35b837530454aee0bd7c79ab9a9439ae1fb75235029cd486aaaf00fb431bcab2f708c82589b9ed2371e7c1963f2752e115e4bf85951d591ef30b10e3b3c3af80fc8f29536821f252ee2f62a3f54e05fab2634e7c76f77a64494adb95424edf7de676980f6a792a7ffb43e230eef536e1ce3250a5d05dbfa0f36f8f61074221c37101f9900e39e62b4c556bac771490b72d5b6c4629c0a895a6b701d2656eb28f4b683780702674f5d7887ea3bdc08033734c4171c200db4659dee8530c6c87ce588bb727de3503a68f88fe168bcc412d8533a4b1de03ed9621e5c760e370774ab1f95d1d32e2d32b3d38f0d5d7f61228b9fdc7e9bef08a286425c90b111d5940a1200c05106e2fb80392ebf13e8cb813b77146b6fff64dfe7d20378854af2e0d841fd6d05e1e2e84733d922315e301999e7172fe045dcf25b27ea7db3dd84eed909112848402b8384c4ee0d41473662f9a3c3d37cd603a185bb6aeab258bfd300fba412be695b8b50a3d004cd2a6bb39d9ae86e18b453b9f3f6a4731484b0917e735f23ff5b7e6fe7d1f213ceb0f1ffae51c8774dec8b76b0f17f9153fe339a2bc3de7ad554cf5d9855369f7dfbe843e0b8ef7c38d92d50d68f473edf282025ab5bc62ade7dd3f829f7e9a04b7fc85824faeafa024fc66901b073b313965621c6b37496275b650a60ac94776934090491e542ef2a32eeaa767bd3188fb2e5ff2f278d991891e159f059f80ee85b57f82904147345e75c679f11f5a53a629a2df6aba0fd032dd6207bd4f9bf8f49e076ac2aaacbf6dfcabe0b94c3c6c8116ffb6b9bd9bf2fb763db6c9d16bc31a5fc89a6890d7c5bcf3cd74f7b444ba4ac259242529cd8b61af2421c80fe010c61a21ba0222ac26795b5e58d8fce2a6bf2f937825fd68d7aca98182f21ccfe81c276dd330f366e4f9f7d41fc7c01457a0c3473f0ee3c45c8a212599ead7d36f85c80909aca14cb6d743ae96e3b1a0c3f11d89e37ca17e8e199f719cd75d128e43a270c45d5af96b9a38b541719634de6abe919b01e6614a15d646c91f179051bae5461f187f3d4ef459af7f8a35c2842a96bcdd2ec8f5f59aed3fa3bce0859fc485c0ada346217be9c8cda1525d3e4ef211de8fb544f913e7b9e454be6644429d9f9caebf8d870689ad049daf37fa3507fba11332c0e48bfdc7afe8334d115d799f62b230a6970139fc65300978e63ca77d01dd4bf272371e9c7d5cee1afe408e89c70db6e9145407af4d4e85b7d7523bcaca8b3e3b27c254a000f7a1cf15639d1d6d004fa7fbc15e2b98d5b4fc5b1620ba4216b6b36ec83ceba984065dc876ec11f6e6ba407a47f36218be6c1ffdfb3820afb647b7e050a9c9ce86d56b3938a0e8ad81d04c49df1abc65e1ffdc92e7608bd1decd34f29f60635a5d193fbd75e8be054fbd66423f77f1736d3c6784b1c680095b42262b9ae0075e382ab112c7cf30ff8187ff8a0cd8d7d60f97dc4ab76c68dd274118ef556b5e09cfacf6ada5344dea18b612543f074425a731e069990463706929de7219f7752a584f50c601c8e78afdc37f5291a8bc12a101d047597e3570783f9f4c3d2609c678ca7dd4da94fbda6f8e642e863e1c2b00c630ca0560b4890a087bf94737a64a43349434d2eadc5041356ff2d5d20d6a6f2e08797010d9b91cef3ef2c6a1136887aeef3e4f51e3e479705e4676f7cda2d3e1f115e5d24c99de46bbf1852c7dae66b00d74a2db97566d63959aa94cb3f9604ee813701f343a40923d297fb4c9c573ff19cc4b2f1bf8c85fe77d520b3033f8f59c13ef9f2a7e7f09306e56b9a4a15fc6dde8392d9105f23d7168a2112ce42d91b412c5c120fff561b7a65b71fd03d3b80551e55cc6e5c2aaea25ba9d326c052393303441beb962225bf239a82666cc944a155d5423ee04a4dbb5f721ea778908226e3f3be62962fb3173e615d9c38cf7326b1688d197a329445c08ef02bbe30a0a4de57e8dd5f1e6b633ffbc185c3575cd8d9cf0c1e3a2207f205a5d49ba411a9e4aeb754b1a253f3670a2c1640b07422ff3c98704fd7295d8684b0b5bdc6080e8ea0141faf590c49d061b1083645fab70a8d0f3e3a642b609fb9f80439127ba2f94d101596e625e73651aed9088f83477714ae716236fe1c498e04f0baf32e7a94f9874c2906d2bdaa7cd8de86128c93781470092823e9be57a1efbdfb761f5f1c5144957d8cedc0dcc4b6e4267504c470508091e1b3386483ff79a56254836dd75709c2269169159ac94dec8074ceddc842921e4f9c6017b4b007a3cfae28c491990e1f1d20f93f58e94f7c4a3853d07346739e94f71163b19dff9119769f4ea897e8be360693ac9f7ed1f235e33a399dcf41bb956fffa9f8b2020392d3e42f3084ae7e3e55782ecec875d63c1693d0dedd21f9eedfd273850db9e1fcca708004f7abcc70e34b1dbd83cf5aa820aec88f6eb1247e4dca52d7c7421e23148d500d2a933e9979cb9812052e29a47f9ac624b5824975912d4f59e68369cd2537502c070801058d57cec75530c992b2162d2f484d18012ab1aa786ef5e8b0024a56b7a71ad92ea916aa7c1e8678bf100ccb13f4a3353c70c0b8757afd6bb75fca940e321fa9c99afe605d7d06246a0ff54d7b21e039872ac592cd654f53c8dfb615981c99a5b6307918842a6f1ff728f6bbffa0fa4d165f69465c6052056d2893b2cb9c5a93c09395d700435bf1f068b288e836203615529075e1a7803d6d4abe1df3be6282ae61c028f712bbafe2c4e526219c345a9605380c43c9faf6947663d7c6a04e40f1ac6624864c0ed78a237f83ccd3cfda85489e513489113fc181716ac677a36d29ad3e0cb65a88c6cf978f24bca1116ed6475e63c80a902fc3a0208efea95208e889b61b19a361a0f942b8bede5033b01f6cb1aaa16571434f9d79f379e498e67aeb84395e2caf72c11e22f75ddbba4be281d943cf56fe5e4d14843e6570f07f19a7053bd63025fd5d8173034ec8af7c2b2916e394549ea1cbaee54f1b7ec32414178ed0a6ba9a480127d8714b60272733b007ece5c790825c26eb1a7a75f3b8c8135e26e63afe4b47d5bc49db12009b480721f3a52a185b533ebd20c01ff4f9b8a9bae1c00d96f0a2b1babc92e37a85d4f99d59b91b5828cc00516ec80723698f202fd071b2c875412f679efc331fb51a4745c008fc5ad4a38f235ebd8fe4c8eaefa657696328c6af664cd76768b0c6e708ef80468280196594016a3bb94829e3e671536489388b20dd68c94d09cc5bf07f4200a6424645383eb436f941467a2951a2c9d0cf120d1f17d9ba1661b0e8a2fee9c06eb8420a2882c956d48ba4006f44b9657e0c3589611d9599e6042bf3b0c07c5285c2b97a5b02338b9b2c73522f92a5bb5a21fa97c81202c20f4ade9e7870a7ed83a1456b9104efe810b20b678884c0dd73666ed19b16a27a4570105aa1c504170791a86561ee20fdda3fb272820b2f37ec3191009ea6943c086e226efc312dc8f5ef23709dc8d4145a6a93f2d62a913c5e232ff89b7fd8bda3a7af4bbf89f490dbcda944601e4839483af042d546a428e24fc1f9cd79ffe870562de9fcd3f7d295a33d69c31fed14e8eee91ae56393d8ec30dc88439c53e0484d7e16ce5ace8dd1138e31cd94ff7233170b83aa8b1a426a130f9b8221de89aedfae0558e576ab075f5a7cc1612ed84a2c8d87a2ffae0f6dce135b15861457d80522390bbc2edbde76e17d73690e6ec341d4f0fc638f72c857391d200a3f0cca461252f94dfedb7d3dd9534e936084ec1025c7e4c37df766eeb79234988ad059ae3cb221e0dcf532d92b168b49fcdf0ab6d79aea862346d8e60ff93d69f354510d81046b7a37d85668e750db0e97002cf09a62667305adc6ac0fdee98fe0703813af9e08abb72d543a3f91d02b6c7b2a8ac627e2b808f7e767373602b8c4c0f77c8ae4ebba521e356a22677a1bff12d4739267f2241b8bd0e5c51d2d722a3920022dc16697c080777f555635b16ec6b5b1c40e7177575aab739d4952fb461b8421a19363b4111b83f5f85f36bd3243f17f04db1d5e56d1fac9feac05ae1dc1fdc8c50628921b8fd2f3171d83e6bb1c05d89c446304745808f6a3ae9af6457a232096dea9d5038dd11b6737c40f014343aa0a5678bb81d24c6140d1488bca8b8588d427e143743eeecca728f3291e8d954914093ec66d5fd45d0d81fa63c50dc74bd1ca02407588a23e72f7560c2762d145143cd987db0fcfcf46b6c9c1e417e3dbfc37e918b82bfc500d8b02c28b78bb9edbf3ec6771891391839e7407b9102eb7ed5625e3afb2f2790ca6631c5fcb4a3b673ed2c64ac6242df99068256f83f295217429ad41c088238647e0f724ff90f0d0573d0d3db2d27671aea24037c4b69803c9db143874012cb716775603a51abb3c6afe3a1160a581a47feec7d61bc32d6451a336764893a5ba7b37d9a46b48c2abb85211df0956a758eece7aab3baf1150e0532ee5ee1128061a0f8db138bdbe4790b549b8d82edbcfdfc79710626d70f66cf59be0df88ca5d833d62079c24b6bc1bebf628dcfb30caedb4f17475f0ba1629baa8f38ff9916f5d0b671b1c7b5819806f26fcc93db79550ffe67f420b77878bb82b09f990be7b34983ab1929e7899aa2f0aea27ced17e08f3a9809ac41e115f537a2fcae99e9728648525f819f60f8cff5626b3925da0ed3d3bed16aead2f309872683db77a4d0c3fdc54ff99d2aa1e7d598ebb896f9a2522033b9751010bbeecb0ee41810ef1b76f03a5c8cb01b4aec88f157d7d53ebd7b4baef8a05ba139e4e8c70497d95531e6327115ccba69463eb820b199ba666bb91f4c16f5a8ba07864221c317abf799d415ce05767fdf912b8bdbe30553982e506ebeba5f5a5c481c7cbb8a75a65ea51bfe3017281feb1bcfe9d34af00f5ebdd9df097049d82fbafae9d30a8f89a738b6471b1079f5d0075ba44d2b3ea1094fb659f9e51bcb29a593ff9afd56b9d9c3197d8e7eb9cfa3272b27849754294940950af8cad86b7fb678aada75229c44b16b732c8620d8c93def00752d9ac1d5a6b9f6458ca5389fa020dda651b2ed63211816943389cc6774aedaea8d071f9e559a09cdb5425abf1cd761963c71eed238cea7ae153d6bb2a9f8b3b5adb81835ecda27065b89675bac4d424bc9f134f5885a488f4a0a7e9b284e92522323314142e4db233a944dcb941d94a691f154b8953aeb4bef754a89fc0229cdc6e48c13be610e6f70f63f2d5ec6d7e0ff279022256d76af5652508c040ab84fdcfeef8014c56770ec2b17563458bf4579f3b6020f2b7299803854884eddea8cf98680a353c1fdd07924d7ccbd310729dfabbaaf7bb16ade2a82176e7abce6ad87d3a62738f0f17909f363a95548c397c0a5e1f0d0775ec9eb48a4e30f0c6dacfedfb0cba3a17829132a3e0edd682f96e0f83d7d9e2bfac8c96988c378ef5e0a9b261ada033d8ff2618a93bed9bfb17d12b31d2786336583c16634ebe25c1ceb3ba8d9d28aff5ab6d651acdcc21ffe47a0a70df43f304683948986c476756b4489f7c752593dc1828ce68d29e724bd604b19e3d5b4b171d283bb2240bc35e790540ada165b0017141ace7638c3349214d787667f19af07ea488a059556cb3f99f7f7a4ccf10cf4e66675ede1159b2c622d6ae8a37eb72dd2d59b7dceac9968ce2c69e3559168e75a53b192f133099c8632507f0c0307828f481b591a133df1ab9a74c5c52d9deca4bbb1ef8bb9470fc30c1fe441e391f0f478c42dd6290bd86eaf7b116d1418e41683a4ad418f9542da2e4ff5fd2a7bcabf0e1e58af96aa1edef1213ea11d187c6d16a0dab963a5fab87b163ba726eec87dbd400e658632b28dd88ecb88b2ae1a8afc1701de0211dddf41763f7ac0ac10ebc529941ac66b2f0c8046da250000b48c0e8d32965565a3c5e32c48ca46fc8ad2a76297f7e0d03c71f9588df6e893c69ef5cd9db859ee233142906cf3cc58afd6174875a932c28fbe37bcedccd46dbab669370c78e4d1913ef2c21645b137cbd7ad671fa4312a1362e0063398e57d5185337c57682e993503799128fc2fa5f87ee6eee7407ac1f8cf20723807219e8344920fe59d4439edcdc48d0493f2480eb4764ca4e76f57e62c8dffc7e848ec9ce99c0ae36b3a5d6e0a7fb0824da9ad96314cdfa0fc4bc80be33f099d5265903aa1f038afea86f87f03e324acca2619aaaaa2550cd5dda57e7fd5447cecccfd787ca71d22f43e6b347107b4b5794420221beebe96fcb62540996e160f39f950d4de250a8cfab55f45ec4590a9ba7c6ff18b0c854751fa547269523f305116aa263c8796baee77c3161b199a6809c22de355a76abc1283eb2b295863c4b501b7b3e35803f1e35e6e78930b8c67e34d09c583680e462af9dfa092a6d7ba16fbae2d3b10b2fb0e1542d9269a6c1ccace0da0a4e16f06ce9b1cb327ac128125123d62f0e4c2c6b10897a5b5b6ed53d12b5919f566000db4d686809d5afa05ec110e78b76d88391b9ff19bb1cb3abd974508bc56516480f075c69f52f051ba67a310c53814089e9169293c7c0fdcd7df6d1b18e6acb101b8cb63139d2a1902052176017551c209c63e4e0997449b2acce423447be4f57b4c4143f47123b2f7e27afbbd139c08ac1154422146092722ef4370e1b60f37bbc8364b1ed760a4c2fac851f9164dba23fdbc74da68b709012581e10ad36e50840fee486c82e38601d58cf70d1beacfb5dd4df55602ec301ea766383bcc17ce80c164e89f3abf69bc39306495ff47dd10bb622f7d67fb637580362f63093187bfb086993521dfce9a4036ca16125f2d5ed1b11326dbec7d40b3abfc66a536fb1330be00bbb1649b2b2a5ad730e0f6c61ed408eb3dc13933b4848191c1fc5db6e7b12eac98d5b69e7501fc0999b61d7111aa1cc037c170724d3eea0a551d2b0a1606ca54426fd0db22d2db2d067f977b573a81244c684812308daad3963e06ff3b9d8875ca1817a53b61ed5180e74710831d55a460ebad090967cbf04de916023a7e0e41aeb95e2789feea3c4d19bac3525d0542090b4223b88edf0246426700e3d7c4a735add1a53aac8fe73177d0ef93eb58ae9af7ade2383fc9a9f32485e284c6f83ecd046cfeddc8d5e555c07ce1e8a577e138d13f9ade3246de72b64b78677eea0a1c67160bb74146a7f65efb3eb2095877d29ef4707ee2623c8bf25dfca35add778e2ce1d3b45348a1bf8d39b800e45e90dc1d7eea640e6316c443f2442b00fa8bc29061ac0ef61c7c4e0f28a1e2516740f56b1a75d4557d11ee6ccc7f65cdd3728fd507b18520bb9c58e751ec65182fe97a125624411047c627fb4cc6d8224e384faacf3dfa9ac5cf5935af4cb4b6ed24644dc4aeabbe340b1f262ed5236fb7b0c8abd7f82cf8995a2ee9a4cdfd61b467b236d95cfb721e68155973d09bd12eabf5ad2a50842317627bbe8f7e8e67d009bcefb003bfeb2f78fe1c9df233c224961bcfa5fa1f12c02b727102cf370893c1d6996fe8209442f49afe0c244db50ec0e9d10572fa40e9dcbfc67f7feb285bd0f691119cbbb1c4e8319b8bc3a0a986bbf2b283c6dcbd725d98835b7369d1d88b9661012ded2ec126320f0fb2c4426248844457c5e9bb8c96d3ea7e1706a539ea4bdde8a5fc732e487c71e851fdf2837523d705cf2d7605bc52de8215dd383112596c967fe8ba5d1111e3a177b4f1745e26170c33b8aa57c8a1ee686ce25c416b41544862ee75e83e729b978180e261292f59ffb108b738f6b3b4096e9a4c8a2d1f3cdc948ef95bb51cf229c6fb5c5629f9d0fd66be167d7beb726b2d1b235a6a90dbde688e45005e98780fa4ed35a85666321eb861e3032dd08d3bef2741706d481aed647db11021ae62f8f155ae3f0d25912d0966f71bccc0976d0384dc9895193d9054ca424ec1f7d5226fd516f5da52ab86163730c402e20405fd6a334e50a59ccc4cbbe3bed1cb9215474e8d9e7cefe91d340cca392bc7be0e4e2b604e5339f720ff1355d7f04f490cc6f4c11dfa41bd584ca5f3a84161fbe41ec21b025e7bfc0d27c2b0ef1c8a8d3f66c34066fbdc6caaeab46cf5de41d58311240ee3ade0c889f94787834763d325dc2afa8fef425ceb6233ee255b7a37a77133923fdd8dd187ce2b0e6af81fd7ac4bbd399e53dc1048fcd17ebe218eeeb03b648741f83cb691bb70795b6a0523a0070e512ebb61f084e6355cb12f25906e7b422ad87cba122d5d33c4a68edf82d9ca5d856d2f5a28313565965bd1d370a9a771c6766923ef3f0c7d981507d16bd903fe5b7d97050a27992bd9dec0b34bb6baf3d6fb785fb650ffc2e19d7f8745ee670fe87e4b2a3d2614e9480f75b8df353d346bcc9d95a5232ce9a9e242640cf642542ffa41c2a487eebf2a86db3f41bfe3b0abfa47dd6c73dc1871c662a358c13c2ffa9a5ba2044aa37bc370d7ba55a2917d2cd09094a6b3282e3235cd799d0cc14412029f7de1628c65a8f070f395c13042bdcf92ac70ba9a232527a9960f7eb1b7a4b9fe0d32c64c01fffbb1b0c9156e03c633a2818a873f7a8c4dd28504ac1753e62aab3864d6ce034f782d2c1da69df2c877d5d254d01939f822be2c2c0c02c3396d46f7a75a9d238b0a8084aca5dac43d0b181f1b157fc563208b641b33082ae2d4b9a4bccafff1dccd4eeb7866a062ec1235f90ab7c43d6fe7b2a0380e1de12f8fca38765a53520eea3a90e074622f450f65ab563f424e3d3311c779bb01ac8d1e236a89ccc013529d55ff8a446051a6d84a85399ddd6b6e42227be9e4e9a2eb7cfc7743e4ea78e42eaa0a8387783fe10b04b34a0dd2033689e20250a2fbc5b98fa056bcdd4667dd26f2b08e1a793beb9e55cc7fae218774dd9bbd7f0f8e00236e190944c899566f99eea248e3c098b100e93983c670b099b7ec9806d5249036e837f28b79a88586e9716d5b7426bce33435b83f6fee236dc635b2e280a5fd56abff867653399f7a07cee9d8b881b2dae39c50b4ba2701019fcb75ad308ca45e582d2342f02d801943d93066c6f551a7</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      简易加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-3</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/</id>
    <published>2020-03-01T14:10:58.000Z</published>
    <updated>2020-03-01T14:42:36.136Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-3-3"><a href="#GNU-LFS-3-3" class="headerlink" title="GNU-LFS-3-3"></a>GNU-LFS-3-3</h2><ul><li>系统转换过程与细节描述</li></ul><hr><p><strong>文案说明:</strong></p><ul><li>本篇文案用于描述目标系统环境的最基本配置与对从临时系统进入到目标系统的各种细节的描述</li><li>参考文献及版本为LFS-v6.2/v6.3</li><li>描述主体为LFS-v6.3，LFS-v6.2会有特别标注</li><li>LFS-v6.2和LFS-v6.3的内容与执行语句通常没有本质上的区别<blockquote><p>多数都只是执行顺序或者深层的处理逻辑不同<br>但大体非常相似</p></blockquote></li><li>多数指令在目标主机的chroot环境下进行</li></ul><p><strong>目录简述:</strong></p><ul><li>系统清理</li><li>虚拟文件系统</li><li>chroot环境</li><li>标准文件系统(FHS标准)</li><li>用户与用户组的基本配置</li><li>参考资料</li></ul><hr><h3 id="系统清理"><a href="#系统清理" class="headerlink" title="系统清理"></a>系统清理</h3><p><strong>临时主机的系统清理</strong></p><ul><li><p>删除已经安装的可执行程序和库文件当中的调试符号，以节约空间(大约70 MB)</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code><br><code>$ strip --strip-unneeded /tools/{,s}bin/*</code></p></blockquote></li><li><p>命令会跳过大约20个文件，报告不能识别这些文件格式</p><blockquote><p>其中大多数是脚本而不是二进制文件</p></blockquote></li><li><p>这里需要注意的一点是千万不要在库文件上使用<code>--strip-unneeded</code>，否则会破坏其静态版本</p><blockquote><p>如果已经是过去时了的话，就得从头开始编译全部的工具链软件包了</p></blockquote></li><li><p>删除相关文档文件(info，man)，会节约20 MB</p><blockquote><p><code>$ rm -rf /tools/{info,man}</code></p></blockquote></li></ul><hr><ul><li><p>到目前为止，临时工具链已制作完毕</p></li><li><p>这一阶段开始进入目标主机环境</p></li><li><p>从现在开始不需要lfs用户来制作系统了</p></li><li><p>退出lfs用户</p><blockquote><p><code>$ exit</code></p></blockquote></li><li><p>此时为root用户环境，改变必要文件的权限与所有者</p></li><li><p>一部分的原因是为了避免不必要的安全方面所产生的问题</p></li><li><p>将$LFS/tools目录以及其中文件的所有者改为root用户</p><blockquote><p><code>$ chown -R root:root $LFS/tools</code></p></blockquote></li><li><p>这里说明一下:</p><blockquote><p>建立LFS系统的时候，在创建<code>/etc/passwd</code>文件时<br>添加的user ID和group ID是与宿主系统的user ID和group ID相同的lfs用户</p></blockquote></li></ul><hr><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><strong>挂载虚拟文件系统</strong></p><ul><li><p>为虚拟内核文件系统建立挂载目录(dev,proc,sys)</p><blockquote><p><code>$ mkdir -pv $LFS/{dev,proc,sys}</code></p></blockquote></li><li><p>创建初始设备节点(创建两个目标系统所必须的设备文件)</p><blockquote><p><code>$ mknod -m 600 $LFS/dev/console c 5 1</code><br><code>$ mknod -m 666 $LFS/dev/null c 1 3</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>内核在引导时要求某些设备节点必须存在(特别是console和null)<br>这些设备节点必须创建在 硬盘上才能使得内核在udev尚未启动之前就可以使用它们<br>此外还有当Linux以<code>init=/bin/bash</code>启动</p></blockquote></li><li><p>挂载并填充/dev目录(LFS-v6.2)</p><blockquote><p><code>$ mount --bind /dev $LFS/dev</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>LFS-v6.2推荐的向<code>/dev</code>目录填充设备的方法是在<code>/dev</code>上挂载一个虚拟文件系统(比如 tmpfs)<br>然后在设备被检测到或被访问到的时候(通常是在系统引导的过程中)动态创建设备节点<br>既然现在新的系统尚未被引导，那么就有必要通过手工挂载和填充<code>/dev</code>目录<br>这可以通过绑定挂载宿主系统的<code>/dev</code>目录<br>绑定挂载是一种特殊的挂载方式，允许本地主机上的当前用户创建一个目录或者是挂载点的镜像到其他的地方</p></blockquote></li><li><p>挂载虚拟内核文件系统</p><blockquote><p><code>$ mount -v --bind /dev $LFS/dev</code><br><code>$ mount -vt devpts devpts $LFS/dev/pts</code><br><code>$ mount -vt tmpfs shm $LFS/dev/shm</code><br><code>$ mount -vt proc proc $LFS/proc</code><br><code>$ mount -vt sysfs sysfs $LFS/sys</code></p></blockquote></li></ul><hr><ul><li>在进入chroot环境之前，可以将<code>lfs-sources/</code>里面所有源码包复制到<code>$LFS/sources/</code>目录中</li><li>这么做会让后面在构建目标系统的时候使用源代码变得更方便<blockquote><p><code>$ cp -a /lfs-sources/* $LFS/sources/</code></p></blockquote></li></ul><hr><h3 id="chroot环境"><a href="#chroot环境" class="headerlink" title="chroot环境"></a>chroot环境</h3><p><strong>进入chroot环境</strong></p><ul><li>Chroot到目标系统的目录下，以便不受主系统的影响来制作目标系统</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chroot <span class="string">"$LFS"</span> <span class="regexp">/tools/</span>bin/env -i \ </span><br><span class="line">HOME=/root TERM=<span class="string">"$TERM"</span> PS1=<span class="string">'\u:\w\$ '</span> \ </span><br><span class="line">PATH=<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/tools/</span>bin \ </span><br><span class="line"><span class="regexp">/tools/</span>bin/bash --login +h</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><code>env</code>命令的<code>参数-i</code>的作用是清除所有chroot环境变量<blockquote><p>后面是重新设定HOME,TERM,PS1, PATH等变量的值</p></blockquote></li><li><code>TERM=$TERM</code>设定虚拟根环境中的TERM的值与chroot外面的一样<blockquote><p>这个值是让像vim和less之类的程序可以正确操作<br>如果还需要重新设置其它的值，如CFLAGS或CXXFLAGS，这里是个不错的位置</p></blockquote></li></ul><hr><ul><li><p>从这里开始，不再需要LFS环境变量了，因为所有的工作都被限制在LFS文件系统里面</p><blockquote><p>这是由于已经告诉了Bash shell $LFS 是现在的根目录(<code>/</code>)<br>注意，这里<code>/tools/bin</code>位于PATH的最后面<br>也就是说当软件包的最终版本安装之后就不再使用临时工具了<br>为了使shell无法记住可执行二进制代码的位置，需要通过使用<code>+h参数</code>关闭bash的散列功能</p></blockquote></li><li><p>此时bash提示符会显示: <code>I have no name!</code>这是正常的，因为<code>/etc/passwd</code>还没有创建</p></li></ul><hr><h3 id="标准文件系统"><a href="#标准文件系统" class="headerlink" title="标准文件系统"></a>标准文件系统</h3><p><strong>创建符合FHS标准的Unix文件系统</strong></p><p><strong>创建系统目录结构(FHS标准目录树):</strong></p><blockquote><p><code>$ mkdir -pv /{bin,boot,etc/opt,home,lib,mnt,opt}</code><br><code>$ mkdir -pv /{media/{floppy,cdrom},sbin,srv,var}</code><br><code>$ install -dv -m 0750 /root</code><br><code>$ install -dv -m 1777 /tmp /var/tmp</code><br><code>$ mkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}</code><br><code>$ mkdir -pv /usr/{,local/}share/{doc,info,locale,man}</code><br><code>$ mkdir -pv /usr/{,local/}share/{misc,terminfo,zoneinfo}</code><br><code>$ mkdir -pv /usr/{,local/}share/man/man{1..8}</code></p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">for</span> <span class="keyword">dir</span> <span class="keyword">in</span> /usr /usr/<span class="keyword">local</span>; <span class="keyword">do</span></span><br><span class="line">ln -sv share/&#123;<span class="keyword">man</span>,doc,info&#125; <span class="variable">$dir</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p><code>$ mkdir -pv /var/{lock,log,mail,run,spool}</code><br><code>$ mkdir -pv /var/{opt,cache,lib/{misc,locate},local}</code></p></blockquote><hr><p><strong>创建必需的文件与符号连接</strong></p><ul><li>一些程序使用固化的路径(<code>hard-wired paths</code>)指向一些目前还不存在的程序上</li><li>为了兼容这些程序，可以创建一些符号链接</li><li>然后在软件安装之后用实际文件进行替代</li></ul><p><strong>创建必要的符号链接:</strong></p><blockquote><p><code>$ ln -sv /tools/bin/{bash,cat,echo,grep,pwd,stty} /bin</code><br><code>$ ln -sv /tools/bin/perl /usr/bin</code><br><code>$ ln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib</code><br><code>$ ln -sv /tools/lib/libstdc++.so{,.6} /usr/lib</code><br><code>$ ln -sv bash /bin/sh</code><br><code>$ touch /etc/mtab</code></p></blockquote><hr><h3 id="用户与用户组的基本配置"><a href="#用户与用户组的基本配置" class="headerlink" title="用户与用户组的基本配置"></a>用户与用户组的基本配置</h3><p><strong>配置必要的用户组</strong></p><ul><li><p>以下区块为LFS-v6.2独有</p></li><li><p>一个常规的Linux系统在<code>/etc/mtab</code>中有一个已挂载文件系统的列表正常情况下</p></li><li><p>这个文件 在我们挂载一个新的文件系统的时候会被创建</p></li><li><p>因为从此开始在chroot环境下不会再挂载任何文件系统</p></li><li><p>所以需要人为的为那些用到<code>/etc/mtab</code>的程序创建一个空文件</p><blockquote><p><code>$ touch /etc/mtab</code></p></blockquote></li><li><p>为了让<code>root用户</code>可以登录而且<code>用户名root</code>可以被识别</p></li><li><p>在这里需要创建相应的<code>/etc/passwd</code>和<code>/etc/group</code>文件</p></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat &gt; <span class="regexp">/etc/passwd</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span>0<span class="symbol">:</span>0<span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>此时root的真正密码将在后面设置(<code>&quot;x&quot;</code>在这里只是一个占位符)</li></ul><hr><ul><li>使用以下命令创建/etc/group文件(LFS-v6.2):</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>在LFS-v6.2这里创建的用户组并不是某个标准所要求的部分<blockquote><p>只是因为在随后<code>Udev配置</code>将要用到而以</p></blockquote></li></ul><hr><p><strong>创建<code>root</code>及<code>nobody用户</code>和必要的组(LFS-v6.3):</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>passwd &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>:<span class="number">0</span>:<span class="string">root:</span><span class="regexp">/root:/</span>bin/bash </span><br><span class="line"><span class="string">nobody:</span><span class="string">x:</span><span class="number">99</span>:<span class="number">99</span>:Unprivileged <span class="string">User:</span><span class="regexp">/dev/</span><span class="string">null:</span><span class="regexp">/bin/</span><span class="literal">false</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line"><span class="string">mail:</span><span class="string">x:</span><span class="number">34</span>: </span><br><span class="line"><span class="string">nogroup:</span><span class="string">x:</span><span class="number">99</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><hr><ul><li><p>因为完整的Glibc在目标系统中已经安装</p></li><li><p>而且<code>/etc/passwd</code>和<code>/etc/group</code>文件也已创建</p></li><li><p>所以用户名和组名现在可以开始使用了</p></li><li><p>重新加载bash，以使root用户起效</p><blockquote><p><code>$ exec /tools/bin/bash --login +h</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>参数+h</code>用于告诉bash不能使用其内部哈希表查找路径</p></blockquote></li></ul><hr><ul><li>程序 login, agetty, init(还有其它一些程序)使用一些日志文件来记录信息</li><li>比如谁在什么时候登录了系统等等</li><li>然而如果这些日志文件不存在，这些程序则无法写入</li><li>下面初始化这些日志文件，并设置适当的权限:</li></ul><blockquote><p><code>$ touch /var/run/utmp /var/log/{btmp,lastlog,wtmp}</code><br><code>$ chgrp -v utmp /var/run/utmp /var/log/lastlog</code><br><code>$ chmod -v 664 /var/run/utmp /var/log/lastlog</code></p></blockquote><ul><li>目录作用明细:<blockquote><p><code>/var/run/utmp</code>记录着现在登录的用户<br><code>/var/log/wtmp</code>记录所有的登录和退出<br><code>/var/log/lastlog</code>记录每个用户最后的登录信息<br><code>/var/log/btmp</code>记录错误的登录尝试</p></blockquote></li></ul><hr><ul><li>此时就已经完成了对目标主机的基础配置</li><li>同时已经进入目标主机的标准环境了</li><li>一下步即开始对目录主机进行程序编译与配置</li><li>进入源代码目录与设置LFS变量<blockquote><p><code>$ cd /sources</code><br><code>$ export LFS=/sources</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>官方-EN-LFS-v6.2</li><li>官方-EN-LFS-v6.3</li><li>金步国-CN-LFS-v6.2</li><li>孙海勇-CN-LFS-v6.3</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-3-3&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-3&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-9</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-9/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-9/</id>
    <published>2020-02-29T20:44:43.000Z</published>
    <updated>2020-03-02T02:30:03.689Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --><h2 id="LFS-9"><a href="#LFS-9" class="headerlink" title="LFS-9"></a>LFS-9</h2><hr><h3 id="实现逻辑梳理-LFS-v6-3"><a href="#实现逻辑梳理-LFS-v6-3" class="headerlink" title="实现逻辑梳理(LFS-v6.3)"></a>实现逻辑梳理(LFS-v6.3)</h3><ul><li>主观理解，仅供参考</li></ul><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol><li>将原主机分区，假设分为两个分区:<blockquote><p>一个用作swap内存交换分区，另一个用作LFS系统制作分区</p></blockquote></li><li>创建LFS系统的制作及操作目录</li><li>挂载FLS系统所对应的分区目录</li><li>在被挂载的分区目录下建立源码存放目录/sources与工具编译目录/tools</li><li>利用原主机的root环境来为文件目录分配权限，同时配置目录的符号链接<blockquote><p>以方便操作与管理</p></blockquote></li><li>创建用户lfs与用户组lfs(可以同名)</li><li>登陆用户并建立lfs用户环境</li></ol><p><strong>建立临时系统</strong></p><ul><li><p>此时将所有的文件都编译进<code>$LFS/tools</code>目录内</p></li><li><p>源代码与压缩包存储于<code>$LFS/sources</code>目录内</p></li><li><p>构建GNU工具链内工具</p></li></ul><ol><li>Binutils Pass-1</li><li>GCC Pass-1</li><li>Kernel Headers API</li><li>Gilbc<blockquote><p>在Glibc在正确编译且安装完之后:<br>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils Pass-2</li><li>GCC Pass-2</li></ol><ul><li><p>构建其它辅助工具与系统程序</p></li><li><p>编译完成时，临时系统已完整</p></li><li><p>然后利用Strip程序对环境进行清理，info与man也可以进行清理</p></li><li><p>此时可以进入下一阶段</p></li></ul><hr><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li><p>此时的临时系统将作为目标系统的辅助系统以保证存在目的</p></li><li><p>退出lfs用户</p><blockquote><p>此时回到原主机的root环境<br>从此开始的编译都由root用户进行</p></blockquote></li><li><p>此时为了避免安全上的问题</p><blockquote><p>将$LFS/tools目录权限转交给root用户<br>可以将tools目录保留，以创建多个相同版本的LFS</p></blockquote></li></ul><hr><p><strong>首先挂载虚拟内核文件系统</strong></p><ol><li>创建虚拟内核文件系统(或其它设备文件)将要挂载的目录(dev,proc,sys)</li><li>创建设备初始节点</li><li>挂载并填充/dev目录</li><li>最后挂载虚拟文件系统至上面创建的节点之内<blockquote><p>挂载的同时创建了几个最重要的文件系统</p></blockquote></li><li>这里也可以将<code>/lfs-sources/*</code>内的源码包复制到<code>$LFS/sources/</code>内<blockquote><p>以方便使用</p></blockquote></li></ol><p><strong>其它内容:</strong></p><ul><li><p>系统环境逻辑:</p><blockquote><p><code>原主机-&gt;临时系统-&gt;目标系统</code><br><code>原主机-&gt;临时系统</code><br><code>原主机-&gt;目标系统</code><br><code>目标系统&lt;-临时系统</code></p></blockquote></li><li><p>这里要重点指出它们的关系并不是线性的</p></li><li><p>主系统包含于临时系统与目标系统</p></li><li><p>进入chroot的目的是让目标系统完全独立</p><blockquote><p>但此时的目标系统还带有临时系统所编译的工具环境<br>此时的原主机进入了chroot模式，因此现在不存在原主机的概念<br>原主机即为目标系统，而目标系统内当前还拥有临时系统的环境与功能</p></blockquote></li></ul><hr><p><strong>进入chroot来进行对LFS系统的操作</strong></p><ul><li>chroot</li><li>此时根据指令来进入chroot环境</li><li>现在所做的任何工作都是为了对已经进入的chroot进行补充<blockquote><p>以构建最终的LFS系统<br>并且chroot内只能使用到临时系统所构建的工具环境<br>此时所有的工作都被限制在LFS文件系统内<br>所以<code>Bash shell $LFS</code>就是现在的根目录<code>/</code></p></blockquote></li></ul><ol><li>清除所有chroot环境变量</li><li>重新设定HOME,TERM,PS1,PATH等变量的值</li><li>创建LFS系统的系统目录结构(必须是标准目录树/完全遵守FHS标准)</li><li>配置必要的符号链接<blockquote><p>因为有一些程序使用的固化的路径(hard-wired paths)指向一些还不存在的程序上<br>为了兼容这些程序，可以创建一些符号链接，然后在程序安装之后用实际文件进行替代</p></blockquote></li><li>然后再去创建root及nobody用户和必要的组<blockquote><p>以让root用户可以登陆与用户名root可以被识别</p></blockquote></li><li>此时因为已经拥有了临时系统内所构建的glibc和刚刚创建的<code>/etc/passwd</code>和<code>/etc/group</code>文件<blockquote><p>所以现在用户名和用户组已经处于可用状态了</p></blockquote></li><li>启动新的shell</li><li>设置某些特定程序的log文件，以保证这些程序能够正常写入</li><li>最后进入源代码目录下，此时还可以将之前复制到sources下的源代码文件目录设置符号链接</li></ol><hr><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><strong>建立目标系统</strong></p><ul><li><p>此时将所有的文件都编入当前LFS主机(分区)的/usr/bin目录下</p></li><li><p>GNU工具链内工具</p></li></ul><ol><li>Linux kernel headers</li><li>Man-pages</li><li>Glibc<blockquote><p>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils</li><li>GCC</li></ol><ul><li>构建其它辅助工具与系统程序<blockquote><p>当目标主机最后一个工具-vim已经编译安装成功之后，开始进行下一阶段</p></blockquote></li></ul><hr><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul><li>此时应该先对系统做一个备份<blockquote><p>因为此时操作此系统的人处于任何原因的手残或其它的失误<br>都会导致新操作系统的完全崩坏</p></blockquote></li></ul><ol><li>然后退出此时的虚拟根环境</li><li>接着再次进入虚拟根环境(为了清理系统)</li><li>利用Strip来清理系统</li><li>清理完成之后退出chroot并重新进入chroot<blockquote><p>从现在开始，每当重新进入LFS系统的chroot环境时，都不应该需要加入<code>/tools</code>参数了<br>因为此时的LFS主机内已经拥有完整的工具环境了</p></blockquote></li><li>进入chroot环境之后进行下一步配置<blockquote><p>包括配置启动脚本(boot loader)，设备处理模块，控制台，网络配置脚本，Bash Shell启动文件等等<br>然后为设备创建惯用的符号链接</p></blockquote></li><li>为了让LFS系统能够启动，还需要配置<code>/etc/fstab</code>文件</li><li>最后安装Linux内核</li><li>当配置完内核之后，安装GRUB并配置GRUB启动菜单</li><li>退出chroot</li><li>卸载虚拟文件系统</li><li>卸载LFS自己的文件系统</li><li>此时应该能够保证GRUB引导装载程序已经被设置，并且按照其启动菜单可以自动启动LFS系统</li></ol><p><strong>shutdown -r now</strong></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><hr><ul><li>需要理解的知识点:</li></ul><ol><li>工具链的制作与配置和对于配置细节的理解<blockquote><p>包括静态库与动态库的配置，应用与理解<br>打上该打的补丁(patch)，批处理文件(sed)，链接器与汇编器的使用与配置(as/ld)</p></blockquote></li><li>链接的过程与程序配置文件的编写<blockquote><p>在进入下一个阶段时对软链接的使用</p></blockquote></li><li>从一个系统到达另一个系统的配置环节<blockquote><p>清理工具(Strip)<br>固化代码</p></blockquote></li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-LFS-v6.6(非官方)<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><h3 id="LFS-补充内容"><a href="#LFS-补充内容" class="headerlink" title="LFS-补充内容"></a>LFS-补充内容</h3><ul><li><p>临时系统环境搭建(分区)</p></li><li><p>临时工具链安装与说明</p></li><li><p>临时工具链配置与说明</p></li><li><p>目标系统环境搭建(chroot)</p></li><li><p>目标工具链安装与说明</p></li><li><p>目标工具链配置与说明</p></li><li><p>然后以chroot进入纯粹的目标系统进行程序编译与安装</p></li><li><p>再然后进行对启动脚本与其它系统所需的最基本脚本进行配置</p></li><li><p>最后再创建fstab与编译并配置内核，重启系统结束</p></li><li><p>具体的脚本配置根据当前本地主机的内核版本而定</p></li><li><p>可参考LFS官方文案，这里不做过多赘述</p></li></ul><hr><ul><li>LFS-v6.2/v6.3所需的最基本脚本配置文件与程序</li></ul><ol><li>配置，编译并安装 LFS-Bootscripts-6.3</li><li>配置setclock脚本 (Configuring the setclock Script)</li><li>配置Linux控制台 (Configuring the Linux Console)</li><li>配置sysklogd脚本 (Configuring the sysklogd Script)</li><li>创建/etc/inputrc文件 (Creating the /etc/inputrc File)</li><li>配置Bash Shell启动文件 (The Bash Shell Startup Files)</li><li>配置localnet脚本 (Configuring the localnet Script)</li><li>自定义/etc/hosts文件 (Customizing the /etc/hosts File)</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li><li>配置网络脚本 (Creating the /etc/fstab File)</li><li>配置，编译并安装Linux-2.6.22.5</li><li>配置GRUB以使得系统可引导 (Making the LFS System Bootable)</li><li>重启操作系统 (Rebooting the System)</li></ol><hr><p><strong>参考资料:</strong></p><ul><li><p>LFS-v6.2/v6.3</p></li><li><p>EN-LFS-书籍仓库<a href="http://www.linuxfromscratch.org/lfs/downloads/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/</code></p></blockquote></li><li><p>EN-LFS-v6.2<a href="http://www.linuxfromscratch.org/lfs/downloads/6.2/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.2/</code></p></blockquote></li><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>具体的中文版可参考金钟国及其所属团队的译本</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 09 2020 13:33:04 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-9&quot;&gt;&lt;a href=&quot;#LFS-9&quot; class=&quot;headerlink&quot; title=&quot;LFS-9&quot;&gt;&lt;/a&gt;LFS-9&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-8</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-8/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-8/</id>
    <published>2020-02-29T20:40:11.000Z</published>
    <updated>2020-02-29T20:44:36.228Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><h2 id="LFS-8"><a href="#LFS-8" class="headerlink" title="LFS-8"></a>LFS-8</h2><hr><h3 id="LFS-v6-3基本程序一览"><a href="#LFS-v6-3基本程序一览" class="headerlink" title="LFS-v6.3基本程序一览"></a>LFS-v6.3基本程序一览</h3><ul><li>LFS-v6.3内软件目录(包含版本与章节)</li><li>不包含[GNU 工具链]内程序</li></ul><p><strong>参考资料:</strong></p><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-6.6非官方<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><p><strong>临时主机程序目录</strong></p><p>5.13. Ncurses-5.6<br>5.14. Bash-3.2<br>5.15. Bzip2-1.0.4<br>5.16. Coreutils-6.9<br>5.17. Diffutils-2.8.1<br>5.18. Findutils-4.2.31<br>5.19. Gawk-3.1.5<br>5.20. Gettext-0.16.1<br>5.21. Grep-2.5.1a<br>5.22. Gzip-1.3.12<br>5.23. Make-3.81<br>5.24. Patch-2.5.4<br>5.25. Perl-5.8.8<br>5.26. Sed-4.1.5<br>5.27. Tar-1.18<br>5.28. Texinfo-4.9<br>5.29. Util-linux-2.12r</p><hr><p><strong>目标主机程序目录</strong></p><p>6.13. Berkeley DB-4.5.20<br>6.14. Sed-4.1.5<br>6.15. E2fsprogs-1.40.2<br>6.16. Coreutils-6.9<br>6.17. Iana-Etc-2.20<br>6.18. M4-1.4.10<br>6.19. Bison-2.3<br>6.20. Ncurses-5.6<br>6.21. Procps-3.2.7<br>6.22. Libtool-1.5.24<br>6.23. Perl-5.8.8<br>6.24. Readline-5.2<br>6.25. Zlib-1.2.3<br>6.26. Autoconf-2.61<br>6.27. Automake-1.10<br>6.28. Bash-3.2<br>6.29. Bzip2-1.0.4<br>6.30. Diffutils-2.8.1<br>6.31. File-4.21<br>6.32. Findutils-4.2.31<br>6.33. Flex-2.5.33<br>6.34. GRUB-0.97<br>6.35. Gawk-3.1.5<br>6.36. Gettext-0.16.1<br>6.37. Grep-2.5.1a<br>6.38. Groff-1.18.1.4<br>6.39. Gzip-1.3.12<br>6.40. Inetutils-1.5<br>6.41. IPRoute2-2.6.20-070313<br>6.42. Kbd-1.12<br>6.43. Less-406<br>6.44. Make-3.81<br>6.45. Man-DB-2.4.4<br>6.46. Mktemp-1.5<br>6.47. Module-Init-Tools-3.2.2<br>6.48. Patch-2.5.4<br>6.49. Psmisc-22.5<br>6.50. Shadow-4.0.18.1<br>6.51. Sysklogd-1.4.1<br>6.52. Sysvinit-2.86<br>6.53. Tar-1.18<br>6.54. Texinfo-4.9<br>6.55. Udev-113<br>6.56. Util-linux-2.12r<br>6.57. Vim-7.1</p><hr><p><strong>最终阶段程序</strong></p><p>7.2. LFS-Bootscripts-6.3<br>Linux-2.6.22.5</p><hr><h2 id="相关指令参考"><a href="#相关指令参考" class="headerlink" title="相关指令参考"></a>相关指令参考</h2><ul><li>patch</li><li>sed</li><li>ld</li><li>strip</li></ul><hr><h3 id="patch命令"><a href="#patch命令" class="headerlink" title="patch命令"></a>patch命令</h3><ul><li><p>Linux patch命令用于修补文件(为文件打上补丁)</p><blockquote><p>patch指令让用户利用设置修补文件的方式，修改，更新原始文件<br>倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行<br>如果配合修补文件的方式则能一次修补大批文件<br>这也是Linux系统核心的升级方法之一</p></blockquote></li><li><p>语法:</p><blockquote><p><code>patch [参数] [选项] [原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-patch.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-patch.html</a></p></blockquote></li><li><p>实例:</p></li><li><p><code>$ patch -Np1 i ../expect-5.43.0-spawn-1.patch</code></p><blockquote><p>将<code>expect</code>工具打上补丁<code>expect-5.43.0-spawn-1.patch</code></p></blockquote></li></ul><hr><h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><ul><li><p>Linux sed 命令的作用是利用脚本来处理文本文件</p></li><li><p>sed可依照脚本的指令来处理，编辑文本文件</p></li><li><p>sed主要用来自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等</p></li><li><p>命令语法:</p><blockquote><p><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-sed.html</a></p></blockquote></li><li><p>实例:</p></li><li><p>利用sed命令来确保在非bootstrap编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ld命令"><a href="#ld命令" class="headerlink" title="ld命令"></a>ld命令</h3><ul><li><p>ld 命令是二进制工具集GNU Binutils的一员，是GNU的链接器，用于将目标文件与库链接为可执行文件或库文件</p></li><li><p>命令语法:</p><blockquote><p><code>$ ld [OPTIONS] OBJFILES</code></p></blockquote></li><li><p>实例:</p></li><li><p>链接目标文件生成可执行文件</p></li><li><p>给定C++目标文件<code>test.o</code>与<code>main.o</code>，生成可执行文件<code>test.out</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ld /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o &amp;&amp;</span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtbegin</span>.<span class="title">o</span> /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtend</span>.<span class="title">o</span> &amp;&amp;</span></span><br><span class="line">-L/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5 &amp;&amp;</span></span><br><span class="line">-L/usr/lib64 -L/usr/<span class="class"><span class="keyword">lib</span> -<span class="title">lstdc</span>++ -<span class="title">lm</span> -<span class="title">lgcc_s</span> -<span class="title">lc</span> -<span class="title">lgcc</span>  <span class="title">main</span>.<span class="title">o</span> <span class="title">test</span>.<span class="title">o</span> -<span class="title">o</span> <span class="title">test</span>.<span class="title">out</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>具体参考:<br><a href="https://www.gnu.org/software/binutils/" target="_blank" rel="noopener">https://www.gnu.org/software/binutils/</a><br><a href="https://www.linux.org/docs/man1/ld.html" target="_blank" rel="noopener">https://www.linux.org/docs/man1/ld.html</a><br><a href="https://blog.csdn.net/K346K346/article/details/89088652" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/89088652</a><br><a href="https://dablelv.blog.csdn.net/article/details/88094902" target="_blank" rel="noopener">https://dablelv.blog.csdn.net/article/details/88094902</a><br><a href="http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat" target="_blank" rel="noopener">http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat</a></p></blockquote><ul><li>ld和ld.so的区别<a href="https://www.cnblogs.com/foohack/p/4105717.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.cnblogs.com/foohack/p/4105717.html</code></p></blockquote></li></ul><hr><h3 id="Strip"><a href="#Strip" class="headerlink" title="Strip"></a>Strip</h3><ul><li><p>从特定文件中剥掉一些符号信息和调试信息，使文件变小</p></li><li><p>strip - Discard symbols from object files(from man strip)</p></li><li><p>具体语法:</p><blockquote><p><code>$ strip [-xxx bfdname |--xxx=bfdname]</code><br>strip 之后的任何选项都是自定义参数，这里将不会做过多阐述<br>参考自: <a href="https://blog.csdn.net/qq_37858386/article/details/78559490" target="_blank" rel="noopener">https://blog.csdn.net/qq_37858386/article/details/78559490</a></p></blockquote></li><li><p>实例:</p></li><li><p>清理<code>/tools/lib</code>内所有的debug文件</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-8&quot;&gt;&lt;a href=&quot;#LFS-8&quot; class=&quot;headerlink&quot; title=&quot;LFS-8&quot;&gt;&lt;/a&gt;LFS-8&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-2</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/</id>
    <published>2020-02-29T16:58:18.000Z</published>
    <updated>2020-02-29T16:59:17.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-2"><a href="#GNU-LFS-3-2" class="headerlink" title="GNU LFS-3-2"></a>GNU LFS-3-2</h3><hr><p><strong>目标主机-2</strong></p><ul><li>GCC</li><li>Binutils</li><li>LFS-v6.2/v6.3</li></ul><hr><h3 id="Binutils"><a href="#Binutils" class="headerlink" title="Binutils"></a>Binutils</h3><p><strong>Binutils-2.17/Binutils-2.16.1</strong></p><blockquote><p><code>$ tar xvf $LFS/binutils-2.17/2.16.1.tar.bz2</code><br><code>$ mkdir -v ../binutils-build</code><br><code>$ cd ../binutils-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ../binutils<span class="number">-2.17</span>/<span class="number">2.16</span><span class="number">.1</span>/configure --prefix=/usr \</span><br><span class="line">            --enable-<span class="keyword">shared</span></span><br></pre></td></tr></table></figure></li><li><p>源码编译:</p><blockquote><p><code>$ make tooldir=/usr</code></p></blockquote></li></ul><p><strong>make参数含义:</strong></p><ul><li><p>参数<code>tooldir=/usr</code></p><blockquote><p>通常情况下，tooldir(可执行文件的安装目录)是<code>$(exec_prefix)/$(target_alias)</code><br>例如在i686机器上，将是<code>tt class=&quot;filename&quot;&gt;/usr/i686-pc-linux-gnu</code><br>因为此时只为自己的系统进 行编译，就并不需要在<code>/usr</code>目录后面再存在特殊的后缀<br><code>$(exec_prefix)/$(target_alias)</code>只是在交叉编译时(比如在Intel机器上编译将要在PowerPC上执行的程序)才用到</p></blockquote></li><li><p>编译测试套件:</p><blockquote><p><code>$ make check</code></p></blockquote></li><li><p>编译安装软件包</p><blockquote><p><code>$ make tooldir=/usr install</code></p></blockquote></li><li><p>安装某些软件包需要的<code>libiberty头文件</code></p><blockquote><p><code>$ cp -v ../binutils-2.17/2.16.1/include/libiberty.h /usr/include</code></p></blockquote></li><li><p>Binutils的内容这里不做过多阐述，可参考原文第6.11.2章节</p></li></ul><hr><h3 id="GCC-4-1-2-GCC-4-0-3"><a href="#GCC-4-1-2-GCC-4-0-3" class="headerlink" title="GCC-4.1.2/GCC-4.0.3"></a>GCC-4.1.2/GCC-4.0.3</h3><blockquote><p><code>$ tar xvf $LFS/gcc-4.1.2/4.0.3.tar.bz2</code><br><code>$ cd gcc-4.1.2/4.0.3</code></p></blockquote><ul><li><p>先使用一个sed命令来禁止GCC安装它自己的<code>libiberty.a</code></p></li><li><p>这里将使用Binutils附带的<code>libiberty.a</code>来代替</p><blockquote><p><code>$ sed -i &#39;s/install_to_$(INSTALL_DEST) //&#39; libiberty/Makefile.in</code></p></blockquote></li><li><p>在临时主机中应用的bootstrap编译中，编译器会有<code>-fomit-frame-pointer</code>的标志</p></li><li><p>非bootstrap编译默认是忽略这个标志的，可以应用下面的sed命令来确保编译的可靠性</p><blockquote><p><code>$ sed -i &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in</code></p></blockquote></li><li><p><code>fixincludes脚本</code>偶尔会因为修改系统的头文件而出错</p></li><li><p>因为GCC-4.1.2/4.0.3和Glibc-2.5.1/2.3.6是不需要修改的，运行下面的命令可以避免<code>fixincludes脚本</code>运行:</p><blockquote><p><code>$ sed -i &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in</code></p></blockquote></li><li><p>GCC中提供了一个<code>gccbug脚本</code>，会在编译时侦测<code>mktemp</code>是否存在，并且在测试中加强代码</p></li><li><p>这将会导致脚本使用一些不算很随机的名字来命名临时文件</p></li><li><p>因为我们后面会安装mktemp ，这里就将人为的去模仿它的存在:</p><blockquote><p><code>$ sed -i &#39;s/@have_mktemp_command@/yes/&#39; gcc/gccbug.in</code></p></blockquote></li></ul><blockquote><p><code>$ mkdir -v ../gcc-build</code><br><code>$ cd ../gcc-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/(gcc-4.1.2/4.0.3)/configure <span class="attribute">--prefix</span>=/usr \ </span><br><span class="line"><span class="attribute">--libexecdir</span>=/usr/lib \</span><br><span class="line">--enable-shared \ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix \</span><br><span class="line">--enable-__cxa_atexit \ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu \</span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++</span><br></pre></td></tr></table></figure></li><li><p>参数作用与目标主机内的作用相同，这里不做过多阐述</p></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li>预编译测试:<blockquote><p><code>$ make -k check</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>有的软件包希望C PreProcessor(预处理器)安装在<code>/lib</code>目录下，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv ../usr/bin/cpp /lib</code></p></blockquote></li><li><p>许多软件包使用cc作为C编译器的名字，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv gcc /usr/bin/cc</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-1</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/</id>
    <published>2020-02-29T16:12:11.000Z</published>
    <updated>2020-02-29T16:14:12.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-1"><a href="#GNU-LFS-3-1" class="headerlink" title="GNU-LFS-3-1"></a>GNU-LFS-3-1</h3><ul><li>此下任何关于LFS的讨论都是基于LFS-v6.2/6.3的LiveCD与手册之上的</li><li>程序内所拥有的文件与库这里不做阐述，可参考LFS-v6.2/6.3手册内容</li></ul><hr><p><strong>目标主机-1</strong></p><ul><li>内核头文件安装</li><li>Glibc安装</li><li>目标主机工具链解析</li><li>LFS-v6.2/v6.3</li><li>LFS-v6.3-LiveCD</li></ul><h3 id="内核头文件"><a href="#内核头文件" class="headerlink" title="内核头文件"></a>内核头文件</h3><p><strong>LFS-v6.3</strong></p><ul><li>[Linux-2.6.22.5]安装流程<blockquote><p><code>$ tar xvf $LFS/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code><br><code>$ sed -i &#39;/scsi/d&#39; include/Kbuild</code><br><code>$ make mrproper</code><br><code>$ make headers_check</code><br><code>$ make INSTALL_HDR_PATH=dest headers_install</code><br><code>$ cp -rv dest/include/* /usr/include</code><br><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Linux-Libc-Headers-2.6.12.0</strong></p><ul><li><p>添加一个用户空间头文件和新内核对于<code>inotify</code>特性的系统调用支持:</p><blockquote><p><code>$ patch -Np1 -i ../linux-libc-headers-2.6.12.0-inotify-3.patch</code></p></blockquote></li><li><p>安装内核头文件:</p><blockquote><p><code>$ install -dv /usr/include/asm</code><br><code>$ cp -Rv include/asm-i386/* /usr/include/asm</code><br><code>$ cp -Rv include/linux /usr/include</code></p></blockquote></li><li><p>确保这些头文件的所有者是root:</p><blockquote><p><code>$ chown -Rv root:root /usr/include/{asm,linux}</code></p></blockquote></li><li><p>确保用户可以读取这些头文件:</p><blockquote><p><code>$ find /usr/include/{asm,linux} -type d -exec chmod -v 755 {} \;</code><br><code>$ find /usr/include/{asm,linux} -type f -exec chmod -v 644 {} \;</code></p></blockquote></li><li><p>此时安装的头文件为<code>/usr/include/{asm,linux}/*.h</code></p></li><li><p>头文件内容可参考LFS-v6.2的6.7.2章节，这里不做过多阐述</p></li></ul><hr><p><strong>Man-pages-2.63/Man-pages-2.34</strong></p><ul><li>直接进行编译安装:<blockquote><p><code>$ tar xvf $LFS/man-pages-2.63.tar.bz2</code><br><code>$ cd man-pages-2.63</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf man-pages-2.63</code></p></blockquote></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><p><strong>Glibc-2.5.1/2.3.6</strong></p><ul><li><p>在进行之前请检查一下是否glibc-2.5.1和glibc-build这两个目录已经被删除，如果没有删除请删除后在继续</p></li><li><p>将glibc-libidn包解压到Glibc的源码目录:</p><blockquote><p><code>$ tar xvf $LFS/glibc-2.5.1.tar.bz2</code><br><code>$ cd glibc-2.5.1</code><br><code>$ tar -xvf $LFS/glibc-libidn-2.5.1.tar.gz</code><br><code>$ mv glibc-libidn-2.5.1 libidn</code></p></blockquote></li><li><p>应用下面这个patch来修正软件包在<code>sys/kd.h</code>之后包含<code>linux/types.h</code>导致编译错误:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-linux_types-1.patch</code></p></blockquote></li><li><p>添加一个头文件来定义为新内核对于inotify特性的系统调用函数:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-inotify-1.patch</code></p></blockquote></li><li><p>抑制locale的安装，以避免出现bash的bug</p><blockquote><p><code>$ sed -i &#39;/vi_VN.TCVN/d&#39; localedata/SUPPORTED</code></p></blockquote></li><li><p>当运行make install时，一个叫<code>test-installation.pl</code>的脚本会在我们新安装的Glibc上做一个小的完整性测试</p></li><li><p>然而，由于我们的<code>toolchain</code>仍然指向<code>/tools</code>目录，完整性测试会导致使用错误的Glibc</p></li><li><p>所以必须强制脚本测试刚安装的脚本</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i \ </span><br><span class="line">'s|<span class="type">libs</span> -o|<span class="type">libs</span> -L/usr/lib -Wl,-dynamic-linker=/lib/ld-linux.so<span class="number">.2</span> -o|<span class="type">' \   </span></span><br><span class="line"><span class="type">scripts</span>/test-installation.pl</span><br></pre></td></tr></table></figure></li><li><p>继续运行指令:</p><blockquote><p><code>$ sed -i &#39;s|@BASH@|/bin/bash|&#39; elf/ldd.bash.in</code><br><code>$ mkdir -v</code><br><code>$ ../glibc-build</code><br><code>$ cd ../glibc-build</code></p></blockquote></li><li><p>配置安装脚本:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure </span><br><span class="line">-<span class="ruby">-prefix=<span class="regexp">/usr \ </span></span></span><br><span class="line"><span class="ruby">--disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \ </span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--libexecdir=<span class="regexp">/usr/lib</span><span class="regexp">/glibc</span></span></span><br></pre></td></tr></table></figure></li><li><p>新参数说明:</p></li><li><p>参数<code>--libexecdir=/usr/lib/glibc</code></p><blockquote><p>把<code>pt_chown</code>程序的位置从默认的<code>/usr/libexec</code>改为<code>/usr/lib/glibc</code></p></blockquote></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li><p>对结果进行测试:</p><blockquote><p><code>$ make -k check 2&gt;&amp;1 | tee glibc-check-log</code><br><code>$ grep Error glibc-check-log</code></p></blockquote></li><li><p>在安装Glibc的过程中，它会警告缺少<code>/etc/ld.so.conf</code>文件</p></li><li><p>其实这没什么关系，不过下面的命令能修正它:</p><blockquote><p><code>$ touch /etc/ld.so.conf</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>(LFS-v6.2独有)此部还需要安装<code>inotify头文件</code>到系统头文件的地方:</p><blockquote><p><code>$ cp -v ../glibc-2.3.6/sysdeps/unix/sysv/linux/inotify.h \ /usr/include/sys</code></p></blockquote></li><li><p>一次安装所有列在<code>glibc-2.3.6/localedata/SUPPORTED</code>中的<code>locales</code></p><blockquote><p><code>$ make localedata/install-locales</code></p></blockquote></li></ul><hr><p><strong>配置Glibc</strong></p><ul><li><p>此时需要建立<code>/etc/nsswitch.conf</code>文件</p></li><li><p>因为在这个文件丢失或不正确的情况下，Glibc会使用默认配置，而Glibc的默认配置无法很好地在网络环境下工作</p></li><li><p>并且我们也需要设置自己的时区</p></li><li><p>建立一个新的<code>/etc/nsswitch.conf</code>文件:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/nsswitch.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"># Begin /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">passwd: <span class="keyword">files</span> </span><br><span class="line">group: <span class="keyword">files</span> </span><br><span class="line">shado<span class="variable">w:</span> <span class="keyword">files</span></span><br><span class="line">host<span class="variable">s:</span> <span class="keyword">files</span> dns </span><br><span class="line">network<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">protocol<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">service<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">ether<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">rpc: <span class="keyword">files</span> </span><br><span class="line"># End /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>设置时区:</p><blockquote><p><code>$ cp -v --remove-destination /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p></blockquote></li><li><p>配置动态链接库加载程序</p></li><li><p>写入配置</p></li><li><p>LFS-v6.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;ld.so.conf &lt;&lt; &quot;EOF&quot; </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib </span><br><span class="line">&#x2F;opt&#x2F;lib </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>LFS-v6.2</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"># Begin /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span></span><br><span class="line">/usr/<span class="keyword">local</span>/lib </span><br><span class="line">/opt/lib</span><br><span class="line"># End /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote><ul><li>glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误，还有一些能引起错误的LFS手册上有所提及</li><li>由此某些情况的错误可以无视</li></ul><hr><h3 id="调整目标主机工具链"><a href="#调整目标主机工具链" class="headerlink" title="调整目标主机工具链"></a>调整目标主机工具链</h3><ul><li><p>现在，最终的C库已经安装好了，此时需要再次调整工具链，让本章随后编译的那些工具都连接到这个库上</p></li><li><p>基本上，就是把临系统时增加中调整工具链那里做的调整给取消掉</p></li><li><p>在临时系统中，工具链使用的库是从宿主系统的<code>/{,usr/}lib</code>转向新安装的<code>/tools/lib</code>目录</p></li><li><p>同样的，现在工具链使用的库将从临时的<code>/tools/lib</code>转向LFS系统最终的<code>/{,usr/}lib</code>目录</p></li><li><p>首先，备份<code>/tools</code>下的链接</p><blockquote><p>用刚才在临时主机中编译的链接器来替换<br>再创建一个链接到在<code>/tools/$(gcc -dumpmachine)/bin</code>中的副本</p></blockquote></li><li><p>执行以下命令:</p><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote></li><li><p>接下来，修正GCC的specs文件，使它指向新的动态链接器</p></li><li><p>这样GCC才能知道在哪能发 现开始文件</p></li><li><p>这里应用一个sed命令:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | sed <span class="string">\</span> </span><br><span class="line">-e <span class="string">'s@/tools/lib/ld-linux.so.2@/lib/ld-linux.so.2@g'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*startfile_prefix_spec:/&#123;n;s@.*@/usr/lib/ @&#125;'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*cpp:/&#123;n;s@$@ -isystem /usr/include@&#125;'</span> &gt; <span class="string">\</span> </span><br><span class="line">`dirname $(gcc --<span class="built_in">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>还可以利用perl命令</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | \ </span><br><span class="line">perl -p -e's<span class="comment">@/tools/lib/ld-linux.so.2@</span>/<span class="keyword">lib</span>/ld-linux.so<span class="number">.2</span><span class="comment">@g;' \</span></span><br><span class="line"><span class="comment">-e 's@</span>\*startfile_prefix_spec:\n<span class="comment">@$_/usr/lib/ @</span>g;' &gt; \</span><br><span class="line">`dirname$(gcc --<span class="keyword">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>如果此时本地主机的系统平台上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须把上面命令里的<code>ldlinux.so.2</code>换成此时本地主机的系统平台上动态连接器的名字</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-1&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-1&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-4</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/</id>
    <published>2020-02-29T11:26:43.000Z</published>
    <updated>2020-02-29T11:27:56.144Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-4"><a href="#GNU-LFS-2-4" class="headerlink" title="GNU LFS-2-4"></a>GNU LFS-2-4</h2><ul><li>[GNU 工具链]全面逻辑梳理</li><li>重点在于配置链接器与工具链的逻辑</li></ul><hr><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul><li>可以将临时主机的工具链搭建分为两部分</li><li>前半部分为第一遍编译并安装GCC，Binutils和内核头文件</li><li>后半部分为编译并安装Glibc，在配置完Glibc之后，正式调整临时工具链并再次安装GCC与Binutils</li><li>第一步与第二部和第五步与第六步的顺序没有严格规定</li><li>但对GCC与Binutils的第二次编译安装必须在先配置并且编译安装完Glibc之后再进行</li></ul><hr><ul><li><code>Binutils-&gt;GCC-&gt;Headres-&gt;GLibc-&gt;Tools调整-&gt;Binutils-&gt;GCC/C++补丁</code></li><li>参考至<code>LFSv6.2/6.3</code></li></ul><hr><ul><li>因为这里所使用的LiveCD是LFS官方提供的</li><li>由于官方于6.3版本之后就停止维护了</li><li>所以这里只介绍6.3及以下版本</li></ul><hr><ul><li>这里将以下七个工具所需要的</li><li>每个工具编译的重要步骤</li><li>与对工具链的链接和链接器的配置进行了逻辑的梳理</li></ul><hr><h3 id="1-Binutils-Pass-1"><a href="#1-Binutils-Pass-1" class="headerlink" title="1. Binutils Pass-1"></a>1. Binutils Pass-1</h3><ul><li>编译并安装过后</li><li>为调整工具链而准备链接器</li></ul><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/tools/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote><ul><li>参数<code>-C ld LIB_PATH=/tools/lib</code></li><li>指定<code>Makefile</code>的<code>LIB_PATH</code>变量值</li><li>使其明确指向临时工具目录，以覆盖默认值</li><li>这个变量同时还指定了链接器的默认库搜索路径</li><li>在编译完Glibc后就会用到</li></ul><hr><h3 id="2-GCC-Pass-1"><a href="#2-GCC-Pass-1" class="headerlink" title="2. GCC Pass-1"></a>2. GCC Pass-1</h3><ul><li>编译并安装过后</li><li>创建gcc的符号链接为cc，以保证兼容性<blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li></ul><hr><h3 id="3-kernel-headers-API"><a href="#3-kernel-headers-API" class="headerlink" title="3. kernel headers API"></a>3. kernel headers API</h3><ul><li>将头文件编译并复制到所需目录</li></ul><hr><h3 id="4-Glibc"><a href="#4-Glibc" class="headerlink" title="4. Glibc"></a>4. Glibc</h3><ul><li>编译并安装C标准库</li><li>执行<code>touch /tools/etc/ld.so.conf</code></li><li>以修补安装过程中缺少的<code>/tools/etc/ld.so.conf</code></li></ul><hr><h3 id="5-调整工具链-LFS-v6-2-v6-3"><a href="#5-调整工具链-LFS-v6-2-v6-3" class="headerlink" title="5. 调整工具链(LFS-v6.2/v6.3)"></a>5. 调整工具链(LFS-v6.2/v6.3)</h3><ul><li><p>在临时系统的C标准库安装好之后</p></li><li><p>需要将临时工具链中的所有工具都连接到C标准库之上</p></li><li><p>为了达到这个目标，必须调整链接器和编译器的space文件</p></li><li><p>因为Binutils Pass-1的时候以经调整过链接器了</p></li><li><p>所以现在需要做的只是将其重新命名并被正确的找到和使用</p></li><li><p>方法是备份原来的链接器，然后再用调整过的链接器来替代</p></li><li><p>最后再创建一个指向<code>/tools/$(gcc -dumpmachine)/bin</code>中链接器副本的链接</p></li></ul><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote><ul><li>从现在开始，所有程序都将连接到<code>/tools/lib</code>中的库文件</li></ul><hr><ul><li><p>接下来需要做的就是修正GCC中的spaces文件</p></li><li><p>目的是使他指向一个新的动态链接器</p></li><li><p>本质上就是把specs中所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>这里用的是sed命令，有两种语法(分别是LFS-v6.2与LFS-v6.3)</p></li><li><p>如果当前的本地主机上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须人为的把以下命令里的<code>ldlinux.so.2</code>换成本地主机的系统平台上动态连接器的名</p></li><li><p>LFS-v6.2</p></li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFIL</span><br></pre></td></tr></table></figure><ul><li>LFS-v6.3</li></ul><blockquote><p><code>$ gcc -dumpspecs | sed &#39;s@^/lib/ld-linux.so.2@/tools&amp;@g&#39; &gt;</code>dirname $(gcc -print-libgcc-file-name)<code>/ specs</code></p></blockquote><hr><ul><li><p>最后删除GCC专属头文件目录中的头文件，以避免宿主机中的头文件污染编译环境</p></li><li><p>这里的命令v6.2与v6.3没有区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>工具链的调整方法有好几种</p></li><li><p>而且不同版本GCC的specs可能会有不同</p></li><li><p>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>还直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件</p></li></ul><hr><h3 id="6-Binutils-Pass-2"><a href="#6-Binutils-Pass-2" class="headerlink" title="6. Binutils Pass-2"></a>6. Binutils Pass-2</h3><ul><li><p>编译并安装</p></li><li><p>编译配置中配置参数<code>--with-lib-path=/tools/lib</code></p></li><li><p>以指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code></p></li><li><p>以防止连接器搜索宿主系统的库目录</p></li><li><p>最后为目标主机的调整工具链阶段配置链接器:</p><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/usr/lib:/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote></li></ul><hr><h3 id="7-GCC-C-补丁-Pass-2"><a href="#7-GCC-C-补丁-Pass-2" class="headerlink" title="7. GCC/C++补丁 Pass-2"></a>7. GCC/C++补丁 Pass-2</h3><ul><li><p>在GCC编译过程中会运行<code>fixincludes脚本</code>来扫描系统头文件目录</p></li><li><p>并找出需要修正的头文件，然后把修正后的头文件放到GCC专属头文件目录里</p></li><li><p>因为现在GCC和Glibc已经安装完毕，而且它们的头文件已知无需修正</p></li><li><p>所以这里并不需要<code>fixincludes脚本</code></p></li><li><p>必须先禁止fixincludes运行，以保证编译环境不受原主机所污染</p><blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig} &amp;&amp;</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li><p>因为在前几步中编译的GCC Pass-1中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项</p></li><li><p>而非<code>bootstrap</code>编译则默认忽略了该选项</p></li><li><p>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项</p></li><li><p>用以保持一致性:</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure><ul><li><p>然后使用补丁修改补丁修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置:</p><blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li><p>该命令同时还把/usr/include`从GCC的头文件搜索路径里删掉</p></li><li><p>现在预先打补丁而不是在安装GCC之后调整specs文件可以保证新的动态连接器在编译GCC的时候就用上</p></li><li><p>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></li><li><p>然后配置编译器，并进行编译与编译安装</p></li><li><p>关于GCC的C++是在LFS-v9.0中出现的，这里先不做过多阐述</p></li></ul><hr><ul><li>至此结束临时主机的[GNU 工具链]配置环节</li><li>下一步即为配置其它的辅助命令与工具链所处的大环境</li><li>从而为目标主机提供应有的功能与服务</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Mar 09 2020 13:33:03 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-2-4&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-4&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
