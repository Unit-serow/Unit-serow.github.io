---
title: 数据类型-4
date: 2020-03-12 09:55:21
tags: [随笔,C]
categories: [软件,C/C++]
---


<center><strong>数据类型-运算符与表达式-1</center></strong>

<!-- more -->

## 数据类型-4

* 重点为运算符与表达式

---

### 基本运算符

**涉及概念:**

* 一元运算符
* 二元运算符
* 左值与右值
* 表达式和语句
* 基本循环及其符合语句
* 副作用与序列点

---

### 左值与右值

**右值**

* 右值(rvale)，通常只能是字面常量
> 而字面常量不能常量赋值，因为常量本身就是它的值
> 因此，在使用赋值运算符=时，左侧的项必须是一个变量名
> 实际上，赋值运算符左侧必须引用一个存储位置，而最简单方法就是使用变量名
> 不过指针也可用于指向一个存储位置
> 概括地说，C 使用可修改的左值(modifiable lvalue)标记那些可赋值的实体(物理内存)

* 术语概览: 数值对象，左值，右值和运算符

* 赋值表达式语句的目的是把值存储到内存位置上
* 用于存储值的数据存储区域被称之为对象(data object)
* C 标准中只有提到赋值的概念时，才有可能涉及到对象这个术语
* 使用变量名是表示对象的唯一方法，除此之外还有其它的方法，例如指定数组的元素，结构的成员，或者使用指针表达式(指针中存储的是它所指对象的地址)
* 相关的具体细节这里不做过多阐述

**左值**

* 左值(lvalue)是C的术语，用于表示特定数据对象的名称或表达式
> 因此，对象指的是实际的数据存储，而左值是用于表示或定位存储位置的标签

* 对于早期的C，左值所涉及的意义:
1. 它指定一个对象，所以引用内存中的地址
2. 它可以在赋值运算符的左侧，左值(lvalue)中的l源自left

* 但后来的C标准中新增了const限定符，用const创建的变量为只读变量，即为不可修改
> 因此，const标识符可以满足上面的第一项，而无法满足第二项
> 一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧
> 有些左值不能用于赋值运算符的左侧，因此，标准对左值的定义已经不能满足当前的状况
> 为此，C标准新定义了一个术语: 可修改的左值(modifable lvalue)，此方法用于标识可修改的对象
> 所以，赋值运算符的左侧应该是可修改的值，当前标准建议，使用术语对象定位值(object locator value)更好

---

**右值**

* 右值(rvalue)指的是能赋值给可修改左值的量，且本身不是左值
> 右值中的r源自right
* 右值可以是常量，变量或其它可求值的表达式(如，函数调用)
> 实际上，当前标准在描述这一概念时使用的是表达式的值(value of an expression)，而非右值
> 右值示例: bmw = 2002;，此时的2002则为右值

* 左值就是用于引用某指定内存位置的标识符，而右值即为存储于该内存位置的值

* 在名称学习时，被称为"项"(如，赋值运算符左侧的项)的就是运算符对象(operand)
> 运算对象指的就是运算符操作的对象
> 还可以类似的将"=运算符的左侧对象"称之为是"应该是可修改的左值"

---

## 基本的算术运算符-一元/二元运算符

### 二元运算符

* 二元运算符最基本的定义是运算对象至少是两个值
* 最基本的二元运算符是四则运算标识符

**加法运算符**

* 加法运算符(addition operator)用于加法运算，使其两侧的值相加
> 而相加的值(运算对象)可以是对象，也可以是常量
> 比如 icome = salary + bribes;，计算机会查看加法运算符右侧的两个变量，即为右值，将其相加，然后将相加的和(返回的结果)赋值给变量income
> 这里需要注意的一点是，income，salary，bribes都是可修改的左值，因为每个变量都标识了一个可被赋值的数据对象
> 但是，表达式salary + brives是一个右值

**减法运算符**

* 减法运算符(subtraction operator)用于减法运算，使其左侧的数减去右侧的数
> 例如，下面的语句把200.0赋给takehome：
> takehome = 224.00 – 24.00;
> +和-运算符都被称为二元运算符(binary operator)，即这些运算符需要两个运算对象才能完成操作

---

### 一元运算符

* 一元运算符(unary operator)
* 一元运算符就是符号运算符，即仅需要运算一个运算对象的运算符
> 类似于赋值运算符=，数值标识符-，+(正值与负值)，指针标识符&和*等等

**符号运算符:-和+**

* 减号还可用于标明或改变一个值的代数符号
> rocky = -12;，以这种方式使用的负号被称之为一元运算符

* 在C90标准中新增了一元+运算符，它不会改变运算对象的值或符号
> 只能这样使用: dozen = +12;
> 此时编译器不会报错，但是在以前，这样做是不被允许的

**图解说明:**

* 二元运算符和一元运算符:

<img src="/images/数据类型-4/运算符-1.png" width="30%" height="30%">

---

**乘法运算符**

* 符号*表示乘法
> `cm = 2.56 * inch;`，该语句就是用2.56乘以inch，并将结果赋值给cm
> 因为C 内没有平方函数与指数函数，所以只能用循环语句来实现平方与其它指数级增长

**除法运算符**

* C使用符号/来表示除法
* 符号/左侧的值是被除数，右侧的值是除数
> 例如，此表达式中four的值是`4.0: four = 12.0/3.0;`

* 整数除法和浮点数除法不同
> 浮点数除法的结果是浮点数，而整数除法的结果是整数
> 整数是没有小数部分的数
> 这使得5除以3很让人头痛，因为实际结果有小数部分
* 在C语言中，整数除法结果的小数部分被丢弃
> 这一过程被称为截断(truncation)

* 一般情况下最好避免混合类型的出现，即同一个除法表达式内同时出现整数与浮点数
> 因为计算机不能真正的使用浮点数去除以整数，所以编译器会把两个运算对象转换成相同的类型
> 即在进行出发运算之前，将整数转换为浮点数，或将浮点数转换为整数

* 在C99标准以前，C语言给语言的实现者留有一些空间
> 让他们来决定如何进行负数的整数除法
> 一种方法是，舍入过程采用小于或等于浮点数的最大整数
> 当然，对于`3.8`而言，处理后的3符合这一描述
> 但是当需要处理`-3.8`时，该方法建议四舍五入为`-4`
> 因为`-4` 小于`-3.8`
> 但是，另一种舍入方法是直接丢弃小数部分
> 这种方法被称为"趋零截断"，即把`-3.8`转换成`-3`
> 在C99以前， 不同的实现采用不同的方法
> 但是C99规定使用趋零截断
> 所以，应把-`3.8`转换成`-3`

---

* 当同一个表达式内出现了多种不同种类的运算符时，运算符会出现优先级限制

**图片说明:**

* 目前为止文章内涉及的运算符优先级(从低至高):

<img src="/images/数据类型-4/运算符优先级-1.png" width="30%" height="30%">

* 优先级和求值顺序
> 运算符的优先级为表达式中的求值顺序提供了重要的依据，但是并没有规定所有的顺序
> 所以 C 给实现者留出了选择的余地

---

### 其它运算符

* C 中有大约40个运算符，有些运算符比其它运算符常用的多
> 这里只对最常用的运算符进行讨论

**sizefo运算符与其相关类型**

1. sizeof运算符和`size_t`类型
> sizeof运算符以字节为单位返回运算对象的大小(在C中，1字节定义为char类型占用的空间大小)
> 过去，1字节通常是8位，但是一些字符集可能使用更大的字节
> 运算对象可以是具体的数据对象(如，变量名)或类型
> 如果运算对象是类型(如， float)，则必须用圆括号将其括起来

* C 规定，sizeof返回`size_t`类型的值
> 这是一个无符号整数类型， 但它不是新类型
* `size_t`是语言定义的标准类型
> C 有一个typedef机制
> 允许程序员为现有类型创建别名
> 例如:
> `typedef double real;`
> 这样，real就是double的别名
* 现在，可以声明一个real类型的变量:
> `real deal; // 使用typedef`
> 编译器查看real时会发现，在typedef声明中real已成为double的别名
> 于是把deal创建为double 类型的变量
> 类似地，C 头文件系统可以使用typedef把`size_t`作为`unsigned int`或`unsigned long`的别名
> 这样，在使用`size_t`类型时，编译器会根据不同的系统替换标准类型
* C99 做了进一步调整，新增了`%zd`转换说明用于`printf()`显示`size_t`类型的值
> 如果系统不支持`%zd`，可使用`%u`或`%lu`代替`%zd`

---

**求模运算符**

2. 求模运算符(modulus operator): `%`

* 用于整数运算
* 求模运算符给出其左侧整数除以右侧整数的余数(remainder)
> 例如，`13 % 5`(读作"13求模5")得3，因为13比5的两倍多3，即13除以5的余数是3
> 求模运算符只能用于整数，不能用于浮点数
* 求模运算符常用于控制程序流
> 例如，假设此时正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用
> 这种情况可以在程序中对月份求 模3(即，month % 3)，并检查结果是否为0
> 如果为0，便加进额外的费用

* 求模运算符作得出的结果就是所谓的取余运算所得出的结果
* 负数也可以进行求模运算，于C99开始支持了趋零截断

---

**递增运算符**

* 递增运算符(increment operator)-即为'++'

* 用于执行简单的任务，将其运算对象递增1
> 该运算符以两种方式出现
> 第1种方式，++出现在其作用的变量前面， 这是前缀模式
> 第2种方式，++出现在其作用的变量后面，这是后缀模式
>  两种模式的区别在于递增行为发生的时间不同

---

**while循环的执行逻辑**

* 根据所规定条件，对条件进行循环执行
* 例如规定了一个条件为`shoe < 18`，并且每执行一次就进行一次递加(++)的表达式
> 执行的逻辑是shoe的值递增1，然后和18进行比较，如果递增后的值小于18，则再次执行所规定的循环条件(即为所在花括号内的所有语句)
> 然后，shoe的值再递增1，以此重复刚才的不做，知道shoe的值不小于18为止

**图解示意:**

* 执行一次循环:

<img src="/images/数据类型-4//images/while循环-1.png" width="30%" height="30%">

---


**关于前缀递增和后缀递增**

* 这里举一个例子:
> `q = 2*++a;`，此语句为前缀形式递增，首先，a递增1，然后，2乘以a，并将结果赋给q
> `q =2*a++;`，此语句为后缀形式递增，首先，2乘以a，并将结果赋给q，然后，a递增1

* 单独使用递增运算符时(如，ego++;)，使用哪种形式都没关系
> 但是，当运算符和运算对象是更复杂表达式的一部分时(如上面的示例)
> 使用前缀或后缀的效果不同

---

**递减运算符**

* 每种形式的递增运算符都有一个递减运算符(decrement operator)与之对应
* 用--代替++即可:
> `--count; // 前缀形式的递减运算符`
> `count--; // 后缀形式的递减运算符`

* `>`运算符表示"大于"，`<`运算符表示"小于"，它们都是关系运算符(relational operator)

---

**递增运算符的优先级问题**

* 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高
> 因此，`x*y++`表示的是`(x)*(y++)`，而不是`(x+y)++`
> 不过后者无效，因为递增和递减运算符只能影响一个变量(或者更普遍地说，只能影响一个可修改的左值)
> 而组合`x*y`本身不是可修改的左值

---

**不要自作聪明**

* 如果一次用太多递增运算符，自己都会糊涂-CN-C Primer Plus-第5.3.6章节

---

### 表达式和语句

* 术语: 表达式(expression)和语句(statement)
* C 的基本程序步骤由语句组成，而大多数语句都由表达式构成

**表达式:**

* 表达式(expression)由运算符和运算对象组成(运算对象是运算符操作的对象)
> 最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式

* 运算对象可以是常量，变量或二者的组合
> 一些表达式由子表达式(subexpression)组成(子表达式即较小的表达式)

* 每个表达式都有一个值
> C 表达式的一个最重要的特性是，每个表达式都有一个值
> 要获得这个值，必须根据运算符优先级规定的顺序来执行操作
> 关于表达式的值的具体描述这里不做赘述，因为它是一个范围极大的纯粹性概念
> 计算机中表达式的概念与数学中的表达式相同，值即为表达式的结果

---

**语句**

* 语句(statement)是C程序的基本构建块
> 一条语句相当于一条完整的计算机指令
> 在C中，大部分语句都以分号`';'`结尾

* 声明创建了名称和类型，并为其分配内存位置
> 注意，声明不是表达式语句
> 也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值:
> `int port /* 不是表达式，没有值 */`
* 赋值表达式语句在程序中很常用: 它为变量分配一个值
> 赋值表达式语句的结构是: 一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾
> 注意，在while循环中有一个赋值表达式语句
> 赋值表达式 语句是表达式语句的一个示例
* 函数表达式语句会引起函数调用
> 在该例中，调用printf()函数打印结果
> while语句有3个不同的部分: 首先是关键字while，然后圆括号中是待测试的条件，最后如果测试条件为真，则执行while循环体中的语句
> 多条语句需要用花括号括起来

* 图片-简单的while循环结构:


<img src="/images/数据类型-4/while循环-2.png" width="30%" height="30%">

* 这种语句是复合语句
> 该例的while循环中只有一条语句
> 可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句
> while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂

---

**关于副作用与序列点:**

* 类似于while之类的迭代循环语句通常还会有副作用(side effect)和序列点(sequence point)等概念，这里不做过多赘述
> 所谓的副作用，就是对于变量的赋值结果(此间的赋值结果由右值的表达式决定)
> 或称其为经由人工定义所得出的等式结果
> 所谓的序列点，就是程序执行的点，再该点上，所有的副作用都在进入下一步之前发生
> C 中的语句用分号`';'`来标记若干个序列点
> 其寓意就是在一个语句中，赋值运算符，递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成
> 还有一点就是，任何一个完整表达式的结束也是一个序列点

**关于完型表达式:**

* 完整表达式(full expression)
> 就是指这个表 达式不是另一个更大表达式的子表达式
> 例如，表达式语句中的表达式和while循环中的作为测试条件的表达式
> 都是完整表达式
> 序列点有助于分析后缀递增何时发生
> 千万要避免写出带有模棱两可逻辑的语句

**关于复合语句(块)**

* 复合语句(compound statement)是用花括号括起来的一条或多条语句
> 或称之为复合语句(或块)由花括号括起来的一条或多条语句组成
> 复合语句也称为块(block)
> 任何的程序都可以使用块以让while语句包含多条语句
> 在声明与描述复合语句的构成时，需要注意书写风格，其中最重要的是对于代码缩进的掌控

* 图片-带有符合语句的while循环

<img src="/images/数据类型-4/while循环-3.png" width="30%" height="30%">

---

### 补充内容-1

### 类型转换

* 通常，在语句和表达式中应使用类型相同的变量和常量
> 但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉
> 而是采用一套规则进行自动类型转换
> 虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下
> 许多UNIX系统都使用lint程序检查类型"冲突"
> 如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题
> 最好先了解 一些基本的类型转换规则

* 对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)
> 即将选中类型分别转化为被转换类型的更高界别和更低级别的类型

* 类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int
> 例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高
> 之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int

**规则明细:**

1. 当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int
> 如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)
> 在K&R那时的C中，float会被自动转换成double(目前的C不是这样)
由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)

2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别

3. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型
> 这个过程可能导致类型升级或降级(demotion)
> 所谓降级，是指把一 种类型转换成更低级别的类型

4. 当作为函数参数传递时，char和short被转换成int，float被转换成 double
> 而函数原型会覆盖自动升级

* 类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦
> 原因很简单: 较低类型可能放不下整个数字
> 例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334

* 如果待转换的值与目标类型不匹配怎么办? 
> 这取决于转换涉及的类型
> 待赋值的值与目标类型不匹配时，规则如下:

1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略
> 例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256

2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异

3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的

* 如果把一个浮点值转换成整数类型会怎样?
> 当浮点类型被降级为整数类型时，原来的浮点值会被截断
> 例如，23.12和23.99都会被截断为23，而`-23.5`会被截断为`-23`

* 一般而言不应该混合使用类型(因此有些语言直接不允许这样做)
> 但是偶尔这样做也是有用的
> C语言的原则是避免给程序员设置障碍
> 但是程序员必须承担使用的风险和责任

---

### 函数参数

一般函数的形式: void xxx(void)
前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型
比如 void pound(int n)，参数名必须遵循C的命名规则

声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参
该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n
如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n
此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参

所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)
也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n

关于实参和形参的其它说明:

* 在英文中，argument和parameter经常可以互换使用
* 但是C99标准规定了: 
> 对于actual argument或actual parameter使用术语argument(译为实参)
> 对于formal argument或formal parameter使用术语parameter(译为形参)
> 为遵循这一规定，则可以说形参是变量
> 实参是函数调用提供的值，实参被赋给相应的形参

* 根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参
> 类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参

---

* 变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突
> 如果在函数pound()中用times代替n，那么这个times与某函数中的times不同
> 也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的

---

关于函数的调用:

* pound()函数的全称为void pound(int n);
* 假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n
> 因此，如果要对该函数调用结果进行输出，必然是五个字符

**关于函数原型(定义):**

* 程序开头的函数原型
> 原型(prototype)即是函数的声明，描述了函数的返回值和参数
> pound()函数的原型说明了两点:
> 该函数没有返回值(函数名前面有void关键字)
> 该函数有一个int类型的参数
> 该例中，函数原型告诉编译器pound()需要一个int类型的参数
> 假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型
> 即，传递的值为浮点时，就改变为float等等

* 在 ANSI C 之前，C 使用的是函数声明，而不是函数原型
> 函数声明只指明了函数名和返回类型，而并没有指明参数类型
> 为了向下兼容，C 现在仍然允许这样的形式: `void pound(); /* ANSI C 之前的函数声明 */`

* 如果在上例中某函数的内部使用了该条声明来代替了`pound(int n);`
> 由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型
> 此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告
> 此时在函数调用中现实的使用强制类型转换，可以修复此问题: `pound ((int)f)` // 把f强制类型转换为正确的类型
> 注意，如果f的值太大，超过了int类型表示的范围，这样做也不行
> 强制类型转换强 调了转换类型的意图，对编译器而言也是如此

---

* 虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型
* 因此，C会进行自动类型转换
> 尽管如此，也不要养成依赖自动类型转换的习惯
> 应该显式选择合适的类型或使用强制类型转换
> 这样就不用担心出现不必要的自动类型转换了

---


### 补充内容-1

### 类型转换

* 通常，在语句和表达式中应使用类型相同的变量和常量
> 但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉
> 而是采用一套规则进行自动类型转换
> 虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下
> 许多UNIX系统都使用lint程序检查类型"冲突"
> 如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题
> 最好先了解 一些基本的类型转换规则

* 对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)
> 即将选中类型分别转化为被转换类型的更高界别和更低级别的类型

* 类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int
> 例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高
> 之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int

**规则明细:**

1. 当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int
> 如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)
> 在K&R那时的C中，float会被自动转换成double(目前的C不是这样)
由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)

2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别

3. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型
> 这个过程可能导致类型升级或降级(demotion)
> 所谓降级，是指把一 种类型转换成更低级别的类型

4. 当作为函数参数传递时，char和short被转换成int，float被转换成 double
> 而函数原型会覆盖自动升级

* 类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦
> 原因很简单: 较低类型可能放不下整个数字
> 例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334

* 如果待转换的值与目标类型不匹配怎么办? 
> 这取决于转换涉及的类型
> 待赋值的值与目标类型不匹配时，规则如下:

1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略
> 例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256

2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异

3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的

* 如果把一个浮点值转换成整数类型会怎样?
> 当浮点类型被降级为整数类型时，原来的浮点值会被截断
> 例如，23.12和23.99都会被截断为23，而`-23.5`会被截断为`-23`

* 一般而言不应该混合使用类型(因此有些语言直接不允许这样做)
> 但是偶尔这样做也是有用的
> C语言的原则是避免给程序员设置障碍
> 但是程序员必须承担使用的风险和责任

---

### 函数参数

* 一般函数的形式: void xxx(void)
> 前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型
> 比如 void pound(int n)，参数名必须遵循C的命名规则

* 声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参
> 该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n
> 如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n
> 此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参

* 所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)
> 也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n

**关于实参和形参的其它说明:**

* 在英文中，argument和parameter经常可以互换使用
* 但是C99标准规定了: 
> 对于actual argument或actual parameter使用术语argument(译为实参)
> 对于formal argument或formal parameter使用术语parameter(译为形参)
> 为遵循这一规定，则可以说形参是变量
> 实参是函数调用提供的值，实参被赋给相应的形参

* 根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参
> 类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参

---

* 变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突
> 如果在函数pound()中用times代替n，那么这个times与某函数中的times不同
> 也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的

---

**关于函数的调用:**

* pound()函数的全称为void pound(int n);
* 假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n
> 因此，如果要对该函数调用结果进行输出，必然是五个字符

**关于函数原型(定义):**

* 程序开头的函数原型
> 原型(prototype)即是函数的声明，描述了函数的返回值和参数
> pound()函数的原型说明了两点:
> 该函数没有返回值(函数名前面有void关键字)
> 该函数有一个int类型的参数
> 该例中，函数原型告诉编译器pound()需要一个int类型的参数
> 假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型
> 即，传递的值为浮点时，就改变为float等等

* 在 ANSI C 之前，C 使用的是函数声明，而不是函数原型
> 函数声明只指明了函数名和返回类型，而并没有指明参数类型
> 为了向下兼容，C 现在仍然允许这样的形式: `void pound(); /* ANSI C 之前的函数声明 */`

* 如果在上例中某函数的内部使用了该条声明来代替了`pound(int n);`
> 由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型
> 此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告
> 此时在函数调用中现实的使用强制类型转换，可以修复此问题: `pound ((int)f)` // 把f强制类型转换为正确的类型
> 注意，如果f的值太大，超过了int类型表示的范围，这样做也不行
> 强制类型转换强 调了转换类型的意图，对编译器而言也是如此

---

* 虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型
* 因此，C会进行自动类型转换
> 尽管如此，也不要养成依赖自动类型转换的习惯
> 应该显式选择合适的类型或使用强制类型转换
> 这样就不用担心出现不必要的自动类型转换了

---

### 补充内容-2

* C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符
> 一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值
> 只需要一个 运算对象的运算符(如负号和sizeof)称为一元运算符，需要两个运算对象的运算符(如加法运算符和乘法运算符)称为二元运算符
* 表达式由运算符和运算对象组成
> 在C语言中，每个表达式都有一个 值，包括赋值表达式和比较表达式
> 运算符优先级规则决定了表达式中各项 的求值顺序
> 当两个运算符共享一个运算对象时，先进行优先级高的运算
> 如果运算符的优先级相等，由结合律(从左往右或从右往左)决定求值顺序
* 大部分语句都以分号结尾
> 最常用的语句是表达式语句
* 用花括号括起 来的一条或多条语句构成了复合语句(或称为块)
* while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句
* 在C语言中，许多类型转换都是自动进行的
> 当char和short类型出现在 表达式里或作为函数的参数(函数原型除外)时，都会被升级为int类型
> float类型在函数参数中时，会被升级为double类型
> 在K&R C(不是ANSI C)下，表达式中的float也会被升级为double类型
> 当把一种类型的值赋给 另一种类型的变量时，值将被转换成与变量的类型相同
> 当把较大类型转换 成较小类型时(如，long转换成short，或 double 转换成 float)，可能会丢失数据
> 根据之前介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型
* 定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数
> 然后，在函数调用中传入的值会被赋给这个变量
> 这样，在函数中 就可以使用该值了

---



