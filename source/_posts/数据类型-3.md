---
title: 数据类型-3
date: 2020-03-11 20:31:21
tags: [随笔,C]
categories: [软件,C/C++]
---


<center><strong>数据类型-数组/字符串类型-1</strong></center>

<!-- more -->

### 数据类型-3

* 数据类型/派生类型/数组/字符串
* 字符串存储原理
* 数组存储原理

---

### 字符串

**概述:**
* 字符串(character string)
* 本质上是一个或多个字符的序列，即为字符数据类型的数组，可表示为"xxx yyy"
* 双引号不是字符串的一部分，双引号只是用于告知编译器括起来的是字符串，正如单引号用于标识单个字符

**char类型数组和null字符**
* 因为 C 中没有专门用于存储字符串的变量类型，所以字符串都被存储在char类型的数组当中
* 数组由连续的存储单元构成，所以字符串中的字符类型都被存储在相邻的存储单元中，即每个单元存储一个字符

**具体图示**

* 数组中的字符串:

<img src="/images/字符串-1.png" width="30%" height="30%">

* 这里需要注意的是图片中数组末尾的字符`\0`
> 这是空字符(null character)，C内用它来标记字符串的结束
> 空字符并非数字0，它是非打印字符，其ASCII码值是(或称其为等价于)0
> 所以C中的字符串一定以空字符结束，即意味着数组的容量必须比至少比带存储字符串中的字符数多1
> 因此，在一个有若干个存储单元的字符串中，只能存储若干字符串数量减一个字符，剩下一个字节留给空字符

---

### 数组

**概述:**
* 可以将数组看作是一行连续的多个存储单元
* 或称为数组是同类型数据元素的有序序列
* 这里用一个包含着40个存储单元(每个单元存储一个char类型的值)且已被创建(已存在)的数组来举例
> `char name[40];`
> name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量，char用于表示每个元素的类型

**具体图解**

* 声明一个变量和声明一个数组:

<img src="/images/字符串声明-1.png" width="30%" height="30%">

* 字符串就是在拥有一个数组的前提下，把字符串中的字符逐个放入数组，同时还要记得在末尾加上一个`\0`
> 好在计算机可以自己去处理这些细节问题

---

* 用格式化输出标识符`%s`来格式化输出字符串类型，但scanf()函数只会读取字符串中的一个单词，而非整个句子
> 此时需要用到其它的输入函数，如`fgets()`，以用于读取一般的字符串
> 因为本质是由基本字符类型构成的数组，所以字符串的打印顺序与所存储的内存地址也是与字符类型相同的
> 即为完全线性

---

### 字符串和字符的区别

* 字符串常量"x"和字符常量'x'完全不同
* 区别之一是在于'x'是基本类型char
> 而"x"是派生类型char 数组
* 区别之二是"x"实际上是由两个字符组成的，即为'x'和空字符`\0`

**图片描述:**

* 字符'x'和字符串"x":

<img src="/images/字符和字符串的区别-1.png" width="30%" height="30%">

---

### strlen()方法(函数)

* 用于输出给出字符串中的字符长度
* 因为1字节存储一个字符，所以给人最直观的感受就是与sizeof运算符(以字节为单位给出对象的大小)的输出相同，但事实绝非如此
* 使用`strlen()`方法(函数)时需要先对头文件`string.h`进行预处理`#include`，以对其进行支持

* 当被定义数组内有40个存储单元，但是只用了不到40个单元用于存储被输入字符串
> 此时`strlen()`方法得出的结果是被存储字符串的字符长度，当为11时，即为11个
> 但数组内还需要多出来一个单元用于存储空字符，但`strlen()`方法并不会将其计入

**图示说明:**

* strlen()函数知道在何处停止:

<img src="/images/strlen机制说明-1.png" width="30%" height="30%">

**strlen()与sizeof运算符方法的区别**

* 假如让`strlen()`方法去存储一个常量字符串，`strlen()`方法将会只返回字符串中的字符(包括空格和标点符号)
* 但是`sizeof`运算符将会把字符串末尾不可见的空字符也算在内

* `sizeof`运算符和`strlen()`方法的格式化输出标识符是通用的，即为`%zd`转换说明
> 并且`sizeof`和`strlen()`返回的实际类型通常是`unsigned`或`unsigned long`

* `sizefo`后加不加圆括号取决于运算对象是类型还是特定量
> 对于类型需要写为类似于`sizeof(char)`的形式
> 而对于特定量，则可以写成`sizeof name`的形式
> 只不过每种形式都可以加上圆括号，可以为了增加可读性而去这么做

---

### [#define]

**常量和 C 预处理器**

* 如果将全局变量当成常量，程序可能会在无意之间修改它的值
* 所以 C 中为此提供了C 预处理器，预处理器可以用来定义常量
* 基本语法与使用:
> `#define NAME value`
> `#define XXX 0.001`
> 此时程序中的所有XXX都会被替换称0.001，这一过程被称之为编译时替换(compile-time substitution)
> 通常在运行程序时，程序中所有的替换就均已完成，这样定义常量可将其称之为明示常量(manifest constant)
> 因为预处理器处理的替换机制，所以末尾不用加分号

* 在 C 中还有一个约定成俗的规定，常量的命名最好是大写，以便区分程序中其它的变量
> 另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量(如，`c_level`或`k_line`)

* 符号常量的命名规则与变量相同，即可以使用大小写的字母，数字，下划线和首位字符不能为数字

* `#define`指令还可用于定义字符和字符串常量，前者用单引号，后者用双引号
> 即为`#define BEEP '\a'`或`#define TEE 'T'`
> 需要注意的就是符号常量后面的内容用来代替符号常量

---

**const限定符**

* const关键字于C90标准添加，用于限定一个变量为只读
* 作用与`#define`相同，并且比其更灵活

* 基本语法:
> `const int XXX = 10`
> 此时XXX在程序中不可更改，其值为10

---

**明示常量:**

### limits.h

* C内的每个头文件都定义了一系列供实现使用的明示常量
> 比如C的头文件`limits.h`和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息

* 而`limits.h`头文件包含了以下类似的代码
> `#define INT_MAX +32767`
> `#define INT_MIN -32768`
> 这些明示常量代表`int类型`可表示的最大值和最小值
> 如果系统使用32位的int，该头文件会为这些明示常量提供不同的值

* 如果在程序中包含`limits.h`头文件，就可编写下面的代码:
> `printf("Maximum int value on this system = %d\n", INT_MAX);`
> 如果系统使用4字节的int，`limits.h`头文件会提供符合4字节int的`INT_MAX和INT_MIN`
> 以下表图片内列出了`limits.h`中能找到的一些明示常量
> 文章内会对每个头文件的内部构成与使用方法进行刨析
> 每种类型的头文件在系统内的C标准库内都有明确的说明

**图示说明:**

* `limits.h`中的一些明示常量

<img src="/images/C-头文件/C-limits.h头文件-1.png" width="30%" height="30%">

---

### float.h

* 类似地，`float.h`头文件中也定义一些明示常量
> 如`FLT_DIG和 DBL_DIG`，分别表示`float类型`和`double类型`的有效数字位数
> 以下表图片内列出了`float.h`中的一些明示常量(可以使用文本编辑器打开并查看系统使用的float.h头文件)
> 表中所列都与float类型相关
> 把明示常量名中的FLT分别替换成DBL和LDBL
> 即可分别表示double和long double类型对应的明示常量(表中假设系统使用2的幂来表示浮点数)

**图示说明:**

* float.h中的一些明示常量:

<img src="/images/C-头文件/C-float.h头文件-1.png" width="30%" height="30%">

* 编译器要完全支持C99标准才能识别`LLONG_MIN`标识符

---

### printf()方法与scanf()方法

**概述:**
* `printf()`函数和`scanf()`函数能让用户可以与程序实现交互
> 它们是基本/标准的输入/输出函数，或简称为I/O函数
> 其除了I/O功能，还有很多其它的功能
> 因为考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()，尽管如此，各版本之间偶尔有一些差异
> 而C90 和C99 标准规定了这些函数的标准版本
> 虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同
> 两个函数都使用格式字符串和参数列表

---

**printf()**

* 请求`printf()`函数打印数据的指令要与待打印数据的类型相匹配
> 例如， 打印整数时使用`%d`，打印字符时使用`%c`
> 这些符号被称为转换说明(conversion specification)，即为格式化输出标识符
> 它们指定了如何把数据转换成可显示的形式。

* 以下列表图片为ANSI C标准为`printf()`提供的转换说明与搁置相对应的输出类型

* 转换说明及其打印的输出结果:

<img src="/images/C-标准库/C-printf函数-1.png" width="30%" height="30%">

---

### 补充内容

* 格式字符串包含两种形式不同的信息:
> 实际要打印的字符
> 与转换说明

**图片说明:**

* printf()的参数

<img src="/images/printf格式-1.png" width="20%" height="20%">

* 剖析格式字符串图片:

<img src="/images/字符串格式-1.png" width="20%" height="20%">

* 格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果

---

**printf()的转换说明修饰符**

* 在%和转换字符之间插入修饰符可修饰基本的转换说明
* 转换说明修饰符类型的可移植性需要特别注意
* 整数类型和浮点数类型使用不同类型的转换类型
* 关于转换说明修饰符的列表这里不做过多阐述
* 可参考[C Primer Plus 第6版-中文版]-第201页

---

**转换说明的意义:**

* 转换说明把以二进制格式储存在计算机中的值转换成一系列字符(字符串)以便于显示
> 例如，数字76在计算机内部的存储格式是二进制数01001100
> `%d`转换说明将其转换成字符7和6，并显示为76
> `%x`转换说明把相同的值(01001100)转换成十六进制记数法4c
> `%c`转换说明把01001100转换成字符L

* 转换(conversion)可能会误导读者认为原始值被转替换成转换后的值
> 实际上，转换说明是翻译说明
> `%d`的意思是"把给定的值翻译成十进制整数文本并打印出来"

---

### scanf()方法简述

* 输入函数-scanf()
> scanf()是最通用的一个输入函数，因为其可以读取不同格式的数据

* 如果要将其储 存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的
* scanf()把输入的字符串转换成整数，浮点数，字符或字符串
> 而printf()正好与它相反，把整数，浮点数，字符和字符串转换成显示在屏幕上的文本

* scanf()和printf()类似，也使用格式字符串和参数列表
> scanf()中的格式 字符串表明字符输入流的目标数据类型
> 两个函数主要的区别在参数列表中
> printf()函数使用变量，常量和表达式，而scanf()函数使用指向变量的指针
> 关于指针的两条最简单的规则:
> 如果用scanf()读取基本变量类型的值，在变量名前加上一个&
> 如果用scanf()把字符串读入字符数组中，不要使用&

* scanf()函数使用空白(换行符，制表符和空格)把输入分成多个字段
> 在依次把转换说明和字段匹配时跳过空白

* scanf()函数所用的转换说明与printf()函数几乎相同
> 主要的区别是，对 于float类型和double类型
> printf()都使用`%f`,`%e`,`%E`,`%g`和`%G`转换说明
> 而scanf()只把它们用于float类型，对于double类型时要使用l修饰符
* C99-ANSI C中scanf()的转换说明这里不做过多赘述，可参考书籍
* scanf()进入输入的原理与对应的物理模式这里不做阐述，将来会对其进行补充
> 转换符和I/O函数不需要学的特别细，具体的使用和记忆可以在实践中执行

---



