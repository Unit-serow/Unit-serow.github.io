---
title: LSP-2-1
date: 2020-03-06 18:39:20
tags: [OS,随笔,GNU/Linux]
categories: [软件,OS]
---


<center><strong>UNIX/Linux系统调用概念及其执行逻辑叙述</strong></center>
<center><strong>UNIX/Linux-2.1</strong></center>

<!-- more -->

## LSP-2.1

* LSP/Linux System Prorgramming-2

---

### Linux/UNIX-2.1

* 系统编程概念-1
* 系统编程先决条件及其执行逻辑整合文案-1

---

**章节涉及概念一览(简化版本):**

* 系统调用及其执行逻辑刨析
* 对已执行的调用进行检查
* 逻辑简述

---

* 无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律

---

### 系统调用

* 系统调用是受控的内核入口，因此机制，进程可以请求内核以自己的名义去执行某些动作
* 以应用程序编程接口(API)的形式，内核提供有一系列服务提供程序访问(包括创建新进程，执行I/O，以及为进程间通信创建管道等)

* 在深入系统调用的运作方式之前，需要对其进行关注的几个问题点
1. 系统调用是将处理器从用户态切换到和心态，以便CPU访问受到保护的内核内存
2. 系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识(程序通过名称来标识系统调用，此编号机制通常与其无关)
3. 每个系统调用可辅之以一套参数，对用户空间(亦即进程的虚拟地址空间)与内核空间之间(相互)传递的信息加以规范

* 从编程的角度去理解，系统调用与C语言函数的调用很相似
> 然而在系统调用时，其幕后会经理诸多步骤，接下来将会对该步骤的具体逻辑进行叙述:

* 这里将硬件平台-`x86-32`为例，按事件发生的顺序对这些步骤加以分析
1. 应用程序通过调用C语言函数库中的外壳(wrapper)函数，以发起系统调用
2. 对系统调用中断处理的例程来说，外壳函数必须保证所有的系统调用参数可用
> 通过堆栈，这些参数传入外壳函数，但内核却希望这些参数置于特定的寄存器
> 因此，外壳函数会将上述参数复制到寄存器
3. 由于所有系统调用进入内核的方式相同，内核需要设法区分每个相同调用
> 为此，外壳函数会将系统调用编号复制到一个特殊的CPU寄存器(%eax)中
4. 外壳函数执行一条中断机器指令(`int 0x80`)，引发处理器从用户态切换到和心态，并执行系统终端`0x80`(十进制数为128)的终端矢量所指向的代码
> 在较新的`x86-32`硬件平台实现了`sysenter指令`，较之传统的`int 0x80`中断指令，sysenter指令进入内核的速度更快，2.6内核与glibc2.3.2以后的版本都支持`sysenter指令`
5. 为相应中断`0x80`，内核会调用`system_all()`例程(位于汇编文件`arch/i386/entry.S`中)来处理这次中断，具体的处理逻辑与步骤如下:
> 1-在内核栈中保存寄存器值(这里先不做阐述)
> 2-审核系统调用编号的有效性
> 3-以系统调用编号对存放所有调用服务例程的列表(内核变量`sys_call_table`)并进行索引，发现并调用相应的系统系统调用服务例程
> 3.1-若系统调用服务例程带有参数，那么将会首先检查参数的有效性
> 3.2-例如，会检查地址指向用户空间的内存位置是否有效
> 3.3-随后，该服务例程会执行必要的任务，这可能涉及对特定参数中指定地址处的值进行修改
> 3.4-以及在用户内存和内核内存间传递数据(比如在I/O操作中)
> 3.5-最后，该服务例程会将结果状态返回给`system_call()`例程
> 4.-从内核栈中恢复各寄存器值，并将系统调用返回值置于栈中
> 5.-返回值外壳函数，同时将处理器切换回用户态
6. 若系统调用服务例程的返回值表明调用有误，外壳函数会使用该值来设置全局变量 errno
> 然后，外壳函数返回一个整型值，以表明系统调用是否成功
> 在Linux上，系统调用服务例程所遵循的惯例是调用成功则返回负值
> 发生错误时，例程会对相应erron常量取反，则返回一个负值
> C语言函数库的外壳函数即对其再次取反(此时负负得正)，将此结果拷贝至 errno
> 同时以-1作为外壳函数的返回值返回，以此向调用程序表明有错误发生
> 上述惯例所依赖的先决条件是系统调用服务例程，若调用成功则不会返回负值
> 可是对于少数例程来说，这一前提并不成立
> 一般情况下，这也不会有问题，因为取反的errno值范围不会与调用成功返回负值的范围有交集
> 不过还有一种情况沿用这个惯例确实会出问题: 系统调用`fcntl()`的`F_GETOWN`操作，这里先不做阐述

---

* 以相同调用`execve()`为例，此图片展示了上文叙述及事件的发生序列
* 在`Linux/x86-32`上，`execve()`的系统调用号为`11(__NR_execve)`
> 因此，在`sys_call_table`向量中，`条目11`包含了该系统调用的服务例程`sys_execve()`的地址
* 在Linux中，系统调用服务例程的命名通常会采取`sys_xyz()`的形式，其中`xyz()`则是所论及的系统调用

**系统调用的执行步骤图例**

<img src="/images/系统调用-1.png" width="40%" height="40%">

---

* 在系统调用的实际情况中，通常不需要将概念掌握并理解的如此深刻
> 但即便对于一个简单的系统调用，仍要完成相当多的工作
> 因此系统调用的开销虽然很小，却也不容忽视

* 这里可以将getppid()系统调用为例，研判一下发起系统调用的开销:
> 该系统调用只是简单地返回调用进程的父进程ID
> 此时在一台运行着`Linux 2.6.25`的`x86-32`系统上，调用`getppid()`一千万次大约需要`2.2秒`钟，每次调用大致需要`0.3微秒`
> 相形之下，在同一系统上，调用某个只返回整数的C语言函数一千万次，仅需0.11秒，约为`getppid()`耗费时间的`1/20`
> 当然，大多数系统调用的开销都明显高于`getppid()`

---

* 因此，从C 语言编程的角度去看，调用C语言函数库的外壳函数等同于调用相应的系统调用服务例程
> 在今后的章节里，调用系统调用`xyz()`这类说法即意味着: 调用外壳函数，然后再由外壳函数去调用系统调用`xyz()`
* 为调试程序，或是研究程序的运作机制，可以使用`stace命令`，以便对程序发起的系统调用进行跟踪
* 有关与Linux系统调用机制有关的信息可参见其它书籍: [Love，2010]，[Bovet & Cesati，2005]以及[Maxwell，1999]

---

**相关概念整合:**

* 系统编程概念
* 系统编程先决条件及其执行逻辑整合文案

* 系统编程概念
> 系统编程先决条件整合文案
> 系统调用
> 执行逻辑
> 库函数
> GNU Libc (Glibc-GNU C 标准库)
> 无论何时，只要执行了系统调用或库函数，检查调用的返回状态以确定是否成功，这是一条编程的铁规律
> 已执行调用检查
> 库函数错误
> 系统条用错误
> 可移植性
> 特性测试宏
> SUSv3中定义的标准系统数据类型

---

### 参考文献

* 可参考URL目录

* CN-CSDN-Linux系统调用手册[跳转](https://blog.csdn.net/xtx1990/article/details/8173950)
> `https://blog.csdn.net/xtx1990/article/details/8173950`

* CN-CSDN-linux常用系统调用简介[跳转](https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task)
> `https://blog.csdn.net/gwq5210/article/details/41345339?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task`

* CN-个人博客-[译] Linux 系统调用权威指南（2016）[跳转](https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/)
> `https://arthurchiao.github.io/blog/system-call-definitive-guide-zh/`

* CN-百度文库-系统调用手册[跳转](https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html)
> `https://wenku.baidu.com/view/7c742c6b25c52cc58bd6be09.html`

* CN-IBM-Linux系统调用列表[跳转](https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html)
> `https://www.ibm.com/developerworks/cn/linux/kernel/syscall/part1/appendix.html`

CN-个人博客-Linux系统调用(syscall)原理[跳转](http://gityuan.com/2016/05/21/syscall/)
> `http://gityuan.com/2016/05/21/syscall/`

---

* [CN-Linux/UNIX 系统编程手册-上册(Michael Kerrisk)](http://unit-serow.com/2020/03/05/OS-1/#more)
> 第三章节内容
> PDF资源可参考文章OS-1
> 手册页-Linux系统调用
> 书籍-附录A

---




