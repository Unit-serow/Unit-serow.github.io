<!-- build time:Sun Feb 09 2020 13:52:10 GMT+0800 (中国标准时间) --><!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32.ico?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon32.ico?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/atom.xml" title="UNIT" type="application/atom+xml"><meta property="og:type" content="website"><meta property="og:title" content="UNIT"><meta property="og:url" content="https://unit-serow.github.io/index.html"><meta property="og:site_name" content="UNIT"><meta property="article:author" content="serow"><meta name="twitter:card" content="summary"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"5.1.4",sidebar:{position:"right",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://unit-serow.github.io/"><title>UNIT - 不精之精，而至纯粹</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-right page-home"><div class="headband"></div><a href="https://github.com/2721304117" target="_blank" rel="noopener"><img width="149" height="149" style="position:absolute;top:0;right:0;border:0" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_white_ffffff.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">UNIT</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">不精之精，而至纯粹</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/09/Docker-Swarm-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/09/Docker-Swarm-1/" itemprop="url">Docker Swarm-集群</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-09T13:47:40+08:00">2020-02-09 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Swarm-集群管理"><a href="#Swarm-集群管理" class="headerlink" title="Swarm 集群管理"></a>Swarm 集群管理</h3><p><strong>概述:</strong></p><ul><li><p><code>Docker Swarm</code>是Docker的集群管理工具</p></li><li><p>它将<code>Docker主机池</code>转变为单个虚拟Docker主机</p></li><li><p><code>Docker Swarm</code>提供了标准的<code>Docker API</code></p></li><li><p>目的是使所有任何已经与Docker守护程序通信的工具都可以使用Swarm轻松地扩展到多个主机</p></li><li><p>支持的工具包括但不限于以下各项：</p></li><li><p>Dokku</p></li><li><p>Docker Compose</p></li><li><p>Docker Machine</p></li><li><p>Jenkins</p></li></ul><p><strong>原理概述:</strong></p><ul><li><code>swarm集群</code>由管理节点(manager)和工作节点(work node)构成</li><li><code>swarm mananger</code>:负责整个集群的管理工作包括集群配置,服务管理等所有跟集群有关的工作</li><li><code>work node</code>:即为<code>available node</code>,主要负责运行相应的服务来执行任务(task)</li><li>逻辑简述</li><li>管理节点(swarm manager)内存储着若干个服务(service)的副本(replicas)文件</li><li>工作节点(available/worker node)内存储这服务的标识与服务的镜像文件(container)</li><li>管理节点将所有的服务副本都分配到工作节点内，并管理与控制工作节点内的任务执行<blockquote><p>[swarm manager[service replicas]]-&gt;[available node[task[container(service:latest)]]]<br>swarm manager-&gt;available node-1/available node-2/available node-3/available node-N</p></blockquote></li></ul><hr><p><strong>应用</strong></p><ul><li><p>以<code>Docker Machine</code>与<code>virtualbox</code>进行实践，需要先确保主机已安装<code>virtualbox</code></p></li><li><p>创建docker机器:</p><blockquote><p><code>$ docker-machine create -d virtualbox swarm-manager</code></p></blockquote></li></ul><hr><ul><li><p>创建管理节点(manager node)</p></li><li><p>初始化<code>swarm</code>集群，进行初始化的这台机器，就是集群的管理节点</p><blockquote><p><code>$ docker-machine ssh swarm-manager</code><br><code>$ docker swarm init --advertise-addr 192.168.99.101</code><br><code>--advertise-addr</code>后的IP为创建机器时分配的ip</p></blockquote></li><li><p>当为机器分配IP之后，命令行会输出向集群内添加工作节点的指令(连接令牌)</p><blockquote><p><code>To add a worker to this swarm，runthe following command</code><br><code>docker swarm join --token [...]</code></p></blockquote></li></ul><hr><ul><li>创建工作节点(worker node)</li><li>复制上面输出的指令(会被自动截断)<blockquote><p><code>$ docker swarm join --token [...]</code><br>输出<code>The node joined a swarm as a worker</code></p></blockquote></li></ul><hr><ul><li>查看集群信息<blockquote><p><code>docker info</code><br>输出内容中<code>Swarm active</code>内的<code>managers</code>与<code>node</code>即为节点信息</p></blockquote></li></ul><hr><ul><li><p>部署服务器到集群中</p></li><li><p>跟集群管理有关的任何操作，都是在管理节点上操作的</p></li><li><p>随机指派任一工作节点，并于工作节点上创建任意的一个服务</p><blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name [service name] alpine ping docker.com</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li><li><p>查看<code>service</code>部署的具体信息:</p><blockquote><p><code>docker@swarm-manager:~$ docker service inspect --pretty [service name]</code></p></blockquote></li></ul><hr><ul><li><p>扩展集群服务</p></li><li><p>将service服务扩展到若干个节点</p><blockquote><p><code>docker@swarm-manager:~$ docker service scale [service name]=[节点数]</code></p></blockquote></li><li><p>查看服务部署情况:</p><blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>删除服务<blockquote><p><code>docker@swarm-manager:~$ docker service rm [service name]</code></p></blockquote></li><li>查看服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps [service name]</code></p></blockquote></li></ul><hr><ul><li>滚动升级服务</li><li>将redis旧版本通过滚动升级至更高版本</li><li>创建一个3.0.6版本的redis<blockquote><p><code>docker@swarm-manager:~$ docker service create --replicas 1 --name redis --update-delay 10s redis:3.0.6</code></p></blockquote></li><li>滚动升级redis<blockquote><p><code>docker@swarm-manager:~$ docker service update --image redis:3.0.7 redis</code></p></blockquote></li><li>查看redis服务部署情况:<blockquote><p><code>docker@swarm-manager:~$ docker service ps redis</code></p></blockquote></li></ul><hr><ul><li><p>停止某个节点接收新的任务</p></li><li><p>查看所有的节点：</p><blockquote><p><code>docker@swarm-manager:~$ docker node ls</code></p></blockquote></li><li><p>默认所有的节点都是<code>Active</code>, 可以接收新的任务分配</p></li><li><p>停止节点<code>swarm-worker1</code>:</p><blockquote><p><code>docker node update --availability drain swarm-worker1</code></p></blockquote></li><li><p>此时<code>swarm-worker1</code>状态变为<code>Drain</code></p></li><li><p>不会影响到集群的服务，只是<code>swarm-worker1</code>节点不再接收新的任务</p></li><li><p>会使集群的负载能力有所下降</p></li><li><p>重新激活节点指令:</p><blockquote><p><code>docker@swarm-manager:~$ docker node update --availability active swarm-worker1</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><ul><li><p>虚拟机驱动<a href="https://docs.docker.com/machine/drivers/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/drivers/</code></p></blockquote></li><li><p>官方文档<a href="https://docs.docker.com/machine/reference/create/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/machine/reference/create/</code></p></blockquote></li></ul><hr><p><strong>其他资源</strong></p><ul><li><p>Docker官方主页<a href="https://www.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.docker.com</code></p></blockquote></li><li><p>Docker官方博客<a href="https://blog.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.docker.com/</code></p></blockquote></li><li><p>Docker官方文档<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/</code></p></blockquote></li><li><p>Docker Store<a href="https://store.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://store.docker.com</code></p></blockquote></li><li><p>Docker Cloud<a href="https://cloud.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://cloud.docker.com</code></p></blockquote></li><li><p>Docker Hub<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://hub.docker.com</code></p></blockquote></li><li><p>Docker的源代码仓库<a href="https://github.com/moby/moby" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/moby/moby</code></p></blockquote></li><li><p>Docker发布版本历史<a href="https://docs.docker.com/release-notes/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/release-notes/</code></p></blockquote></li><li><p>Docker常见问题<a href="https://docs.docker.com/engine/faq/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/engine/faq/</code></p></blockquote></li><li><p>Docker远端应用 API<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://docs.docker.com/develop/sdk/</code></p></blockquote></li></ul><hr><p><strong>Docker国内镜像源</strong></p><ul><li><p>阿里云<a href="https://help.aliyun.com/document_detail/60750.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://help.aliyun.com/document_detail/60750.html</code></p></blockquote></li><li><p>网易云加速器</p><blockquote><p><code>http://hub-mirror.c.163.com</code></p></blockquote></li><li><p>中国官方加速器</p><blockquote><p><code>https://registry.docker-cn.com</code></p></blockquote></li><li><p>ustc的镜像</p><blockquote><p><code>https://docker.mirrors.ustc.edu.cn</code></p></blockquote></li><li><p>daocloud</p><blockquote><p><code>https://www.daocloud.io/mirror#accelerator-doc</code>(注册后使用)</p></blockquote></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/09/Docker-1-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/09/Docker-1-1/" itemprop="url">Docker-1.1</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-09T03:11:01+08:00">2020-02-09 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul><li><p>查看已有镜像</p><blockquote><p><code>docker images</code></p></blockquote></li><li><p>参数:仓库源/标签/ID/创建时间/空间</p><blockquote><p><code>debian tag [镜像ID]</code> # 添加标签</p></blockquote></li><li><p>查看仓库内所有镜像文件</p><blockquote><p><code>docker search debian</code></p></blockquote></li><li><p>拉取仓库内默认版本的debian镜像<code>(debian:latest)</code></p><blockquote><p><code>docker pull debian</code></p></blockquote></li><li><p>查看所有已创建容器</p><blockquote><p><code>docker ps -a</code></p></blockquote></li><li><p>用容器启动所选镜像</p><blockquote><p><code>docker run -it --name [自定义命名] debian /bin/bash</code></p></blockquote></li></ul><hr><ul><li>启动，停止，重启所选容器<blockquote><p><code>docker start/stop/restart [容器ID]</code><br>参数:<code>·-i交互式操作</code>，<code>-t终端</code>，<code>-d后台运行</code></p></blockquote></li></ul><hr><ul><li>删除操作<blockquote><p><code>docker rmi debian</code>删除镜像<br><code>docker rm -f</code>删除容器<br><code>docker container prune</code>删除所有停止的容器</p></blockquote></li><li>容器必须停止才能进行删除</li></ul><hr><ul><li>进入后台后使用<code>docker attach</code>或<code>docker exec [容器ID]</code>进入该容器</li><li>前者暂时性，后者永久性</li><li>重新进入容器时还必须加入原来设置的启动参数</li><li>比如<code>/bin/bash和-it</code></li></ul><hr><ul><li><p>设置[service]端口映射与绑定IP</p><blockquote><p><code>docker run -p [可选的IP绑定]:[映射端口]:[原端口]/(udp/tcp) [镜像名] [启动脚本]</code><br>参数:<code>-P</code>是随机映射，<code>-p</code>是指定映射</p></blockquote></li><li><p>查看端口绑定情况</p><blockquote><p><code>docker port [服务名]</code></p></blockquote></li></ul><hr><h3 id="容器网络"><a href="#容器网络" class="headerlink" title="容器网络"></a>容器网络</h3><ul><li><p>父子关系这里都称为上下层级关系，与阶级关系不同</p></li><li><p>上级容器可以看到下级容器的关系</p></li><li><p>建立容器网络</p><blockquote><p><code>docker network create -d bridge/overlay(网络类型) [网络命名]</code>overlay<code>应用于</code>swarm`</p></blockquote></li><li><p>后台运行一个命名为<code>test1</code>的容器并把它并入<code>test-net</code>内，并开启交互式终端系统</p><blockquote><p><code>docker run -itd --name test1 --network test-net debian /bin/bash</code></p></blockquote></li><li><p>任何加入此网络的容器都会达成互联的状态</p></li></ul><hr><ul><li><p>设定所有容器域名和DNS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</span><br><span class="line">&#123;&quot;dns&quot; : [&quot;111.111.111.111&quot;,&quot;1.1.1.1&quot;]&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看是否生效</p><blockquote><p><code>docker run -it rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>指定容器设置域名和DNS服务器</p><blockquote><p><code>docker run -it --rm _hostname=HOSTNAME --dns=IP_ADDRESS --dns-search=DOMAIN(搜索域) debian</code></p></blockquote></li><li><p>没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></li></ul><hr><ul><li><p>登陆<code>docker hub</code></p><blockquote><p><code>docker login</code></p></blockquote></li><li><p>退出<code>docker hub</code></p><blockquote><p><code>docker logout</code></p></blockquote></li><li><p>上传镜像</p><blockquote><p><code>docker tag 本地镜像名 username/远端镜像名</code></p></blockquote></li></ul><hr><ul><li><p>随笔</p><blockquote><p><code>Docker Engine</code> 引擎<br><code>REST API</code> 通用接口<br><code>Docker daemon</code> 守护进程</p></blockquote></li><li><p>自用简易指令集</p></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/08/Docker-Machine/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/08/Docker-Machine/" itemprop="url">Docker-Machine</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-08T18:23:23+08:00">2020-02-08 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Docker-Machine"><a href="#Docker-Machine" class="headerlink" title="Docker Machine"></a>Docker Machine</h3><p><strong>概述:</strong></p><ul><li>可以实现在虚拟主机上安装Docker</li><li>并且可以使用<code>docker-machine</code>命令来管理主机</li><li><code>Docker Machine</code>管理的虚拟主机可以是机上的，也可以是云供应商的</li><li>使用<code>docker-machine</code>命令，可以用于启动，检查，停止和重新启动托管主机，也可以升级Docker客户端和守护程序</li><li>以及配置Docker客户端与本地主机进行通信</li><li>用于实现使用本地主机便可以操控远端的镜像容器集群</li></ul><p><strong>逻辑简述:</strong><br>[Client docker-machine[Client docker CLI[REST APT]]]-docker-machine create-&gt;[REST API[Server docker daemon]]</p><hr><p><strong>基于Linux安装Docker Machine</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ base&#x3D;https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;machine&#x2F;releases&#x2F;download&#x2F;v0.16.0 &amp;&amp;</span><br><span class="line">  curl -L $base&#x2F;docker-machine-$(uname -s)-$(uname -m) &gt;&#x2F;tmp&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  sudo mv &#x2F;tmp&#x2F;docker-machine &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine &amp;&amp;</span><br><span class="line">  chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-machine</span><br></pre></td></tr></table></figure><ul><li>查看版本以验证是否安装成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-machine version</span><br><span class="line">docker-machine version 0.16.0, build 9371605</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>对于machine version的使用</strong></p><ol><li><p>列出可用的机器</p><blockquote><p><code>$ docker-machine ls</code></p></blockquote></li><li><p>创建机器</p></li></ol><ul><li>创建一个名为serow的机器<blockquote><p><code>$ docker-machine create --driver virtualbox serow</code></p></blockquote></li><li>参数<code>--driver</code>用于指定用来创建机器的驱动类型，这里是<code>virtualbox</code></li></ul><ol start="3"><li><p>查看机器的 ip</p><blockquote><p><code>$ docker-machine ip serow</code></p></blockquote></li><li><p>停止机器</p><blockquote><p><code>$ docker-machine stop serow</code></p></blockquote></li><li><p>启动机器*</p><blockquote><p><code>$ docker-machine start serow</code></p></blockquote></li><li><p>进入机器*</p><blockquote><p><code>$ docker-machine ssh serow</code></p></blockquote></li></ol><hr><p><strong>docker-machine 命令参数明细</strong></p><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">docker-machine active</td><td align="left">用于查看当前激活状态的Docker主机</td></tr><tr><td align="left">config</td><td align="left">查看当前激活状态Docker主机的连接信息</td></tr><tr><td align="left">creat</td><td align="left">创建Docker主机</td></tr><tr><td align="left">env</td><td align="left">显示连接到某个主机需要的环境变量</td></tr><tr><td align="left">inspect</td><td align="left">以<code>json</code>格式输出指定Docker的详细信息</td></tr><tr><td align="left">ip</td><td align="left">获取指定 Docker 主机的地址</td></tr><tr><td align="left">kill</td><td align="left">直接杀死指定的 Docker主机</td></tr><tr><td align="left">ls</td><td align="left">列出所有的管理主机</td></tr><tr><td align="left">provision</td><td align="left">重新配置指定主机</td></tr><tr><td align="left">regenerate-certs</td><td align="left">为某个主机重新生成TLS信息</td></tr><tr><td align="left">restart</td><td align="left">重启指定的主机</td></tr><tr><td align="left">rm</td><td align="left">删除某台Docker主机，对应的虚拟机也会被删除</td></tr><tr><td align="left">ssh</td><td align="left">通过SSH连接到主机上，执行命令</td></tr><tr><td align="left">scp</td><td align="left">在Docker主机之间以及Docker主机和本地主机之间通过<code>scp</code>远程复制数据</td></tr><tr><td align="left">mount</td><td align="left">使用SSHFS从计算机装载或卸载目录</td></tr><tr><td align="left">start</td><td align="left">启动一个指定的Docker主机，如果对象是个虚拟机，该虚拟机将被启动</td></tr><tr><td align="left">status</td><td align="left">获取指定Docker主机的状态(包括:<code>Running</code>,<code>Paused</code>,<code>Saved</code>,<code>Stopped</code>,<code>Stopping</code>,<code>Starting</code>,<code>Error</code>)等</td></tr><tr><td align="left">stop</td><td align="left">停止一个指定的Docker主机</td></tr><tr><td align="left">upgrade</td><td align="left">将一个指定主机的Docker版本更新为最新</td></tr><tr><td align="left">url</td><td align="left">获取指定Docker主机的监听URL</td></tr><tr><td align="left">version</td><td align="left">显示 Docker Machine 的版本或者主机Docker版本</td></tr><tr><td align="left">help</td><td align="left">显示帮助信息</td></tr></tbody></table></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/08/YAML-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/08/YAML-1/" itemprop="url">YAML-1</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-08T17:48:07+08:00">2020-02-08 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="YAML-基本语法与简述"><a href="#YAML-基本语法与简述" class="headerlink" title="YAML 基本语法与简述"></a>YAML 基本语法与简述</h3><p><strong>概述:</strong></p><ul><li>YAML是”YAML Ain’t a Markup Language”(YAML 不是一种标记语言)的递归缩写</li><li>在开发的这种语言时，YAML的意思其实是:”Yet Another Markup Language”(仍是一种标记语言)</li><li>YAML的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态</li><li>它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲</li><li>YAML的配置文件后缀为<code>.yml</code></li></ul><hr><p><strong>YAML的基本语法规则</strong></p><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用<code>tab</code>，只允许空格</li><li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li><li><code>&#39;#&#39;</code>表示注释</li></ul><hr><p><strong>YAML的数据类型</strong></p><ul><li>YAML支持以下几种数据类型：</li><li>对象:键值对的集合，又称为映射(mapping)/哈希(hashes) /字典(dictionary)</li><li>数组:一组按次序排列的值，又称为序列(sequence)/列表(list)</li><li>纯量(scalars):单个的、不可再分的值</li></ul><hr><p><strong>YAML对象</strong></p><ul><li><p>对象键值对使用冒号结构表示<code>key: value</code>，冒号后面要加一个空格</p></li><li><p>也可以使用<code>key:{key1: value1, key2: value2, ...}</code></p></li><li><p>还可以使用缩进表示层级关系:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">key: </span><br><span class="line">    child-key: value</span><br><span class="line">    child-key2: value2</span><br></pre></td></tr></table></figure></li><li><p>较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的<code>key</code>，配合一个冒号加一个空格代表一个<code>value</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">?  </span><br><span class="line">    - complexkey1</span><br><span class="line">    - complexkey2</span><br><span class="line">:</span><br><span class="line">    - complexvalue1</span><br><span class="line">    - complexvalue2</span><br></pre></td></tr></table></figure></li><li><p>意思即对象的属性是一个数组<code>[complexkey1,complexkey2]</code>，对应的值也是一个数组<code>[complexvalue1,complexvalue2]</code></p></li></ul><hr><p><strong>YAML数组</strong></p><ul><li>以<code>&#39;-&#39;</code>开头的行表示构成一个数组:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- A</span><br><span class="line">- B</span><br><span class="line">- C</span><br></pre></td></tr></table></figure></li><li>YAML 支持多维数组，可以使用行内表示:<blockquote><p><code>key: [value1, value2, ...]</code></p></blockquote></li><li>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line"> - A</span><br><span class="line"> - B</span><br><span class="line"> - C</span><br></pre></td></tr></table></figure></li><li>一个相对复杂的例子:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">companies:</span><br><span class="line">    -</span><br><span class="line">        id: 1</span><br><span class="line">        name: company1</span><br><span class="line">        price: 200W</span><br><span class="line">    -</span><br><span class="line">        id: 2</span><br><span class="line">        name: company2</span><br><span class="line">        price: 500W</span><br></pre></td></tr></table></figure></li><li>意思是<code>companies</code>属性是一个数组，每一个数组元素又是由<code>id</code>,<code>name</code>,<code>price</code>三个属性构成</li><li>数组也可以使用流式(flow)的方式表示:<blockquote><p><code>companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]</code></p></blockquote></li></ul><hr><p><strong>复合结构</strong></p><ul><li>数组和对象可以构成复合结构，例:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">languages:</span><br><span class="line">  - Ruby</span><br><span class="line">  - Perl</span><br><span class="line">  - Python </span><br><span class="line">websites:</span><br><span class="line">  YAML: yaml.org </span><br><span class="line">  Ruby: ruby-lang.org </span><br><span class="line">  Python: python.org </span><br><span class="line">  Perl: use.perl.org</span><br></pre></td></tr></table></figure></li><li>转换为 json 为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  languages: [ &#39;Ruby&#39;, &#39;Perl&#39;, &#39;Python&#39;],</span><br><span class="line">  websites: &#123;</span><br><span class="line">    YAML: &#39;yaml.org&#39;,</span><br><span class="line">    Ruby: &#39;ruby-lang.org&#39;,</span><br><span class="line">    Python: &#39;python.org&#39;,</span><br><span class="line">    Perl: &#39;use.perl.org&#39; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>纯量</strong></p><ul><li><p>纯量是最基本的，不可再分的值，包括：</p></li><li><p>字符串</p></li><li><p>布尔值</p></li><li><p>整数</p></li><li><p>浮点数</p></li><li><p>Null</p></li><li><p>时间</p></li><li><p>日期</p></li><li><p>使用一个例子来快速了解纯量的基本使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">boolean: </span><br><span class="line">    - TRUE  #true,True都可以</span><br><span class="line">    - FALSE  #false，False都可以</span><br><span class="line">float:</span><br><span class="line">    - 3.14</span><br><span class="line">    - 6.8523015e+5  #可以使用科学计数法</span><br><span class="line">int:</span><br><span class="line">    - 123</span><br><span class="line">    - 0b1010_0111_0100_1010_1110    #二进制表示</span><br><span class="line">null:</span><br><span class="line">    nodeName: &#39;node&#39;</span><br><span class="line">    parent: ~  #使用~表示null</span><br><span class="line">string:</span><br><span class="line">    - 哈哈</span><br><span class="line">    - &#39;Hello world&#39;  #可以使用双引号或者单引号包裹特殊字符</span><br><span class="line">    - newline</span><br><span class="line">      newline2    #字符串可以拆成多行，每一行会被转化成一个空格</span><br><span class="line">date:</span><br><span class="line">    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd</span><br><span class="line">datetime: </span><br><span class="line">    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>引用</strong></p><ul><li><code>&amp;</code>锚点和<code>*</code>别名，可以用来引用:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">defaults: &amp;defaults</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  &lt;&lt;: *defaults</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  &lt;&lt;: *defaults</span><br></pre></td></tr></table></figure></li><li>相当于:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>&amp;</code>用来建立锚点(defaults)，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点</p></blockquote><ul><li><p>下面是另一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &amp;showell Steve </span><br><span class="line">- Clark </span><br><span class="line">- Brian </span><br><span class="line">- Oren </span><br><span class="line">- *showell</span><br></pre></td></tr></table></figure></li><li><p>转为<code>JavaScript</code>代码如下:</p><blockquote><p><code>[ &#39;Steve&#39;, &#39;Clark&#39;, &#39;Brian&#39;, &#39;Oren&#39;, &#39;Steve&#39; ]</code></p></blockquote></li></ul><hr><p><strong>参考资料:</strong></p><p>YMAL官方文档:<a href="https://yaml.org/" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/</code></p><p>YMAL1.2规范文档:<a href="https://yaml.org/spec/1.2/spec.html" target="_blank" rel="noopener">跳转</a><br><code>https://yaml.org/spec/1.2/spec.html</code></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/08/Docker-Compose-3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/08/Docker-Compose-3/" itemprop="url">Docker Compose-3</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-08T16:51:05+08:00">2020-02-08 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>接<a href="https://unit-serow.github.io/2020/02/08/Docker-Compose-2/">Docker Compose-2</a></li></ul><ol><li><strong>devices</strong></li></ol><ul><li>用于指定设备映射列表</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices:</span><br><span class="line">  - &quot;&#x2F;dev&#x2F;ttyUSB0:&#x2F;dev&#x2F;ttyUSB0&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li><strong>dns</strong></li></ol><ul><li>用于自定义 DNS 服务器，可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="3"><li><strong>dns_search</strong></li></ol><ul><li>用于自定义 DNS 搜索域</li><li>可以是单个值或列表</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns_search: example.com</span><br><span class="line"></span><br><span class="line">dns_search:</span><br><span class="line">  - dc1.example.com</span><br><span class="line">  - dc2.example.com</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="4"><li><strong>entrypoint</strong></li></ol><ul><li>用于覆盖容器默认的<code>entrypoint</code></li><li>实现语法:<blockquote><p><code>entrypoint: /code/entrypoint.sh</code></p></blockquote></li><li>或以下的列表格式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;extensions&#x2F;no-debug-non-zts-20100525&#x2F;xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit&#x3D;-1</span><br><span class="line">    - vendor&#x2F;bin&#x2F;phpunit</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="5"><li><strong>env_file</strong></li></ol><ul><li>用于从文件添加环境变量</li><li>可以是单个值或列表的多个值</li><li>实现语法:<blockquote><p><code>env_file: .env</code></p></blockquote></li><li>也可以是列表格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">env_file:</span><br><span class="line">  - .&#x2F;common.env</span><br><span class="line">  - .&#x2F;apps&#x2F;web.env</span><br><span class="line">  - &#x2F;opt&#x2F;secrets.env</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="6"><li><strong>environment</strong></li></ol><ul><li>用于添加环境变量</li><li>可以使用数组或字典，任何布尔值，布尔值需要用引号引起来，以确保<code>YML解析器</code>不会将其转换为<code>True</code>或<code>False</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &#39;true&#39;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="7"><li><strong>expose</strong></li></ol><ul><li>用于暴露端口，但不映射到宿主机，只被连接的服务访问</li><li>实现语法(仅可以指定内部端口为参数)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expose:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;8000&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="8"><li><strong>extra_hosts</strong></li></ol><ul><li>用于添加主机名映射</li><li>类似<code>docker client --add-host</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br></pre></td></tr></table></figure></li><li>以上会在此服务的内部容器中<code>/etc/hosts</code>创建一个具有<code>ip地址</code>和主机名的映射关系:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="9"><li><strong>healthcheck</strong></li></ol><ul><li>用于检测 docker 服务是否健康运行</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http:&#x2F;&#x2F;localhost&quot;] # 设置检测程序</span><br><span class="line">  interval: 1m30s # 设置检测间隔</span><br><span class="line">  timeout: 10s # 设置检测超时时间</span><br><span class="line">  retries: 3 # 设置重试次数</span><br><span class="line">  start_period: 40s # 启动后，多少秒开始启动检测程序</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="10"><li><strong>image</strong></li></ol><ul><li>用于指定容器运行的镜像</li><li>以下格式都可以:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum&#x2F;influxdb</span><br><span class="line">image: example-registry.com:4000&#x2F;postgresql</span><br><span class="line">image: a4bc65fd # 镜像id</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="11"><li><strong>logging</strong></li></ol><ul><li><p>服务的日志记录配置</p></li><li><p><code>driver:</code>用于指定服务容器的日志记录驱动程序，默认值为<code>json-file</code></p></li><li><p>可以有以下这三种选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure></li><li><p>仅在<code>json-file</code>驱动程序下，可以使用以下参数，限制日志得数量和大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: json-file</span><br><span class="line">  options:</span><br><span class="line">    max-size: &quot;200k&quot; # 单个文件大小为200k</span><br><span class="line">    max-file: &quot;10&quot; # 最多10个文件</span><br></pre></td></tr></table></figure></li><li><p>当达到文件限制上限，会自动删除旧得文件</p></li><li><p><code>syslog</code>驱动程序下，可以使用<code>syslog-address</code>指定日志接收地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp:&#x2F;&#x2F;192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="12"><li><strong>network_mode</strong></li></ol><ul><li><p>用于设置网络模式</p></li><li><p>实现语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name&#x2F;id]&quot;</span><br></pre></td></tr></table></figure></li><li><p>networks</p><blockquote><p>配置容器连接的网络，引用顶级<code>networks</code>下的条目</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">      some-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias1</span><br><span class="line">      other-network:</span><br><span class="line">        aliases:</span><br><span class="line">         - alias2</span><br><span class="line">networks:</span><br><span class="line">  some-network:</span><br><span class="line">    # Use a custom driver</span><br><span class="line">    driver: custom-driver-1</span><br><span class="line">  other-network:</span><br><span class="line">    # Use a custom driver which takes special options</span><br><span class="line">    driver: custom-driver-2</span><br></pre></td></tr></table></figure></li><li><p><code>aliases:</code>同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务</p></li></ul><hr><ol start="13"><li><strong>restart</strong></li></ol><ul><li><p>使用示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure></li><li><p>参数说明:</p><blockquote><p><code>no</code>:是默认的重启策略，在任何情况下都不会重启容器<br><code>always</code>:容器总是重新启动<br><code>on-failure</code>:在容器非正常退出时(退出状态非0)，才会重启容器<br><code>unless-stopped</code>:在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</p></blockquote></li><li><p><code>swarm集群</code>模式下，必须改用<code>restart_policy</code></p></li></ul><hr><ol start="14"><li><strong>secrets</strong></li></ol><ul><li>用于存储敏感数据</li><li>例如密码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.1&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">mysql:</span><br><span class="line">  image: mysql</span><br><span class="line">  environment:</span><br><span class="line">    MYSQL_ROOT_PASSWORD_FILE: &#x2F;run&#x2F;secrets&#x2F;my_secret</span><br><span class="line">  secrets:</span><br><span class="line">    - my_secret</span><br><span class="line"></span><br><span class="line">secrets:</span><br><span class="line">  my_secret:</span><br><span class="line">    file: .&#x2F;my_secret.txt</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="15"><li><strong>security_opt</strong></li></ol><ul><li>修改容器默认的<code>schema</code>标签</li><li>使用说明:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">security-opt：</span><br><span class="line">  - label:user:USER   # 设置容器的用户标签</span><br><span class="line">  - label:role:ROLE   # 设置容器的角色标签</span><br><span class="line">  - label:type:TYPE   # 设置容器的安全策略标签</span><br><span class="line">  - label:level:LEVEL  # 设置容器的安全等级标签</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="16"><li><strong>stop_grace_period</strong></li></ol><ul><li>指定在容器无法处理<code>SIGTERM</code>(或者任何<code>stop_signal</code>的信号)，等待多久后发送<code>SIGKILL</code>信号关闭容器</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop_grace_period: 1s # 等待 1 秒</span><br><span class="line">stop_grace_period: 1m30s # 等待 1 分 30 秒</span><br></pre></td></tr></table></figure></li><li>默认的等待时间是 10 秒</li></ul><hr><ol start="17"><li><strong>stop_signal</strong></li></ol><ul><li>设置停止容器的替代信号</li><li>默认情况下使用<code>SIGTERM</code></li><li>以下示例，使用<code>SIGUSR1</code>替代信号<code>SIGTERM</code>来停止容器<blockquote><p><code>stop_signal: SIGUSR1</code></p></blockquote></li></ul><hr><ol start="18"><li><strong>sysctls</strong></li></ol><ul><li>设置容器中的内核参数，可以使用数组或字典格式</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line"></span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn&#x3D;1024</span><br><span class="line">  - net.ipv4.tcp_syncookies&#x3D;0</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="19"><li><strong>tmpfs</strong></li></ol><ul><li>在容器内安装一个临时文件系统</li><li>可以是单个值或列表的多个值</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmpfs: &#x2F;run</span><br><span class="line"></span><br><span class="line">tmpfs:</span><br><span class="line">  - &#x2F;run</span><br><span class="line">  - &#x2F;tmp</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="20"><li><strong>ulimits</strong></li></ol><ul><li>覆盖容器默认的<code>ulimit</code></li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="21"><li><strong>volumes</strong></li></ol><ul><li>将主机的数据卷或着文件挂载到容器里</li><li>实现语法:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;postgres.sock:&#x2F;var&#x2F;run&#x2F;postgres&#x2F;postgres.sock&quot;</span><br><span class="line">      - &quot;&#x2F;localhost&#x2F;data:&#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&quot;</span><br></pre></td></tr></table></figure></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/08/Docker-Compose-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/08/Docker-Compose-2/" itemprop="url">Docker Compose-2</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-08T14:42:09+08:00">2020-02-08 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Compose内的YML指令参考"><a href="#Compose内的YML指令参考" class="headerlink" title="Compose内的YML指令参考"></a>Compose内的YML指令参考</h3><ul><li>为了通过使用compose，来让docker自动化配置程序与服务，必须编写YML文件(脚本)</li></ul><ol><li><strong>version</strong></li></ol><ul><li>指定本yml依从于compose哪个版本制定的</li></ul><ol start="2"><li><strong>build</strong></li></ol><ul><li>指定为构建镜像上下文路径</li><li>例如nginx服务，指定为从上下文路径./dir/Dockerfile 所构建的镜像</li><li>参数明细:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">context</td><td align="left">上下文路径</td></tr><tr><td align="left">dockerfile</td><td align="left">指定构建镜像的Dockerfile文件命</td></tr><tr><td align="left">args</td><td align="left">添加构建参数，这是只能在构建过程中访问的环境变量</td></tr><tr><td align="left">labels</td><td align="left">设置构建镜像的标签</td></tr><tr><td align="left">target</td><td align="left">多层构建，可以指定构建哪一层</td></tr></tbody></table><hr><ol start="3"><li><strong>cap_add，cap_drop</strong><br>添加或删除容器拥有的宿主机的内核功能<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cap_add:</span><br><span class="line">  - ALL # 开启全部权限</span><br><span class="line"></span><br><span class="line">cap_drop:</span><br><span class="line">  - SYS_PTRACE # 关闭 ptrace权限</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><strong>cgroup_parent</strong></li></ol><ul><li>为容器指定父<code>cgroup</code>组，意味着将继承该组的资源限制<blockquote><p><code>cgroup_parent: m-executor-abcd</code></p></blockquote></li></ul><ol start="5"><li><strong>command</strong></li></ol><ul><li>覆盖容器启动的默认命令<blockquote><p><code>cmmand: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</code></p></blockquote></li></ul><ol start="6"><li><strong>container_name</strong></li></ol><ul><li>指定自定义容器名称，而不是生成的默认名称<blockquote><p><code>container_name: my-web-container</code></p></blockquote></li></ul><hr><ol start="7"><li><strong>depends_on</strong></li></ol><ul><li>设置依赖关系</li></ul><blockquote><p><code>docker-compose up</code>:以依赖性顺序启动服务，在以下示例中，先启动<code>db</code>和<code>redis</code>，才会启动<code>web</code><br><code>docker-compose up SERVICE</code>:自动包含<code>SERVICE</code>的依赖项，在以下示例中，<code>docker-compose up web</code>还将创建并启动<code>db</code>和<code>redis</code><br><code>docker-compose stop</code>:按依赖关系顺序停止服务，在以下示例中，<code>web</code>在<code>db</code>和<code>redis</code>之前停止</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><ul><li>此时的<code>web</code>服务不会等待<code>redis</code>和<code>db</code>完全启动之后才启动</li></ul><hr><ol start="8"><li><strong>deploy</strong></li></ol><ul><li>指定与服务的部署和运行有关的配置</li><li>只在 swarm 模式下才会有用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;xxx&quot;  # 服务版本</span><br><span class="line">services:  # 服务配置</span><br><span class="line">  redis:  # redis服务</span><br><span class="line">    image: redis:alpine  # 指定容器运行的镜像</span><br><span class="line">    deploy:  # 开始定义与该镜像有关的配置</span><br><span class="line">      mode：replicated  # 定义需要使用此参数配置具体运行的节点数量</span><br><span class="line">      replicas: 6  </span><br><span class="line">      endpoint_mode: dnsrr  # 访问集群服务的方式，这里是dns轮询(DNSRR)</span><br><span class="line">      labels:  # 给服务设上标签</span><br><span class="line">        description: &quot;This redis service label&quot;</span><br><span class="line">      resources: #配置服务器资源使用的限制，配置 redis 集群运行需要的 cpu 的百分比 和 内存的占用，从而避免占用资源过高出现异常</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &#39;0.50&#39;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &#39;0.25&#39;</span><br><span class="line">          memory: 20M</span><br><span class="line">      restart_policy:  # 配置如何在退出容器时重新启动容器</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure></li></ul><p><strong>可选参数一览与对上述参数解释:</strong></p><ul><li><code>endpoint_mode</code>:访问集群服务的方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">endpoint_mode: vip</span><br><span class="line"># Docker 集群服务一个对外的虚拟ip，所有的请求都会通过这个虚拟ip到达集群服务内部的机器</span><br><span class="line">endpoint_mode: dnsrr</span><br><span class="line"># DNS 轮询(DNSRR)，所有的请求会自动轮询获取到集群ip列表中的一个ip地址</span><br></pre></td></tr></table></figure></li><li><code>labels</code>:在服务上设置标签，可以用容器上的<code>labels</code>(跟<code>deploy</code>同级的配置)覆盖<code>deploy</code>下的<code>labels</code></li><li><code>mode</code>:指定服务提供的模式<blockquote><p><code>replicated</code>:复制服务，复制指定服务到集群的机器上<br><code>global</code>:全局服务，服务将部署至集群的每个节点</p></blockquote></li></ul><p><strong><code>replicated</code>与<code>global</code>的区别</strong></p><ul><li>逻辑简述:</li><li>所有的节点副本都处于本地主机的集群网络内</li><li>当选择<code>replicated</code>时，服务的副本只会被复制到所选节点的机器上</li><li>而选择<code>global</code>时，服务的副本会被复制到节点的每一个机器上，包括控制节点(manager node)</li><li>工作节点(worker node)，控制节点(manager node)</li></ul><hr><ol start="9"><li><strong><code>replicas: mode</code></strong></li></ol><ul><li>当此选项后的参数为<code>replicated</code>时，需要使用此参数配置具体运行的节点数量</li></ul><ol start="10"><li><strong><code>resources:</code></strong></li></ol><ul><li>用于配置服务器资源使用的限制，例如上例子，配置<code>redis</code>集群运行需要的<code>cpu</code>的百分比和内存的占用，避免占用资源过高出现异常</li></ul><hr><ol start="11"><li><strong><code>restart_policy:</code></strong></li></ol><ul><li>用于配置如何在退出容器时重新启动容器</li><li>参数明细<blockquote><p><code>condition</code>:可选<code>none</code>，<code>on-failure</code>或者<code>any</code>(默认值:<code>any</code>)<br><code>delay</code>:设置多久之后重启(默认值:0)<br><code>max_attempts</code>:尝试重新启动容器的次数，超出次数，则不再尝试(默认值:一直重试)<br><code>window</code>:设置容器重启超时时间(默认值:0)</p></blockquote></li></ul><hr><ol start="12"><li><strong><code>rollback_config</code></strong></li></ol><ul><li>用于配置在更新失败的情况下应如何回滚服务</li><li>参数明细:<blockquote><p><code>parallelism</code>:一次要回滚的容器数，如果设置为0，则所有容器将同时回滚<br><code>delay</code>:每个容器组回滚之间等待的时间(默认为0s)<br><code>failure_action</code>:如果回滚失败的处理方法(下一条所描述的内容)，其中一个<code>continue</code>或者<code>pause</code>(默认<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在回滚期间可以容忍的故障率(默认为0)<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认<code>stop-first</code>)</p></blockquote></li></ul><hr><ol start="13"><li><strong><code>update_config</code></strong></li></ol><ul><li><p>用于配置应如何更新服务，对于配置滚动更新很有用</p></li><li><p>参数明细:</p><blockquote><p><code>parallelism</code>:一次更新的容器数<br><code>delay</code>:在更新一组容器之间等待的时间<br><code>failure_action</code>:如果更新失败的解决办法依旧是下一条所描述的内容，其中一个<code>continue</code>，<code>rollback</code>或者<code>pause</code>(默认:<code>pause</code>)<br><code>monitor</code>:每个容器更新后，持续观察是否失败了的时间(<code>ns|us|ms|s|m|h</code>)(默认为0s)<br><code>max_failure_ratio</code>:在更新过程中可以容忍的故障率<br><code>order</code>:回滚期间的操作顺序，其中一个<code>stop-first</code>(串行回滚)，或者<code>start-first</code>(并行回滚)(默认stop-first)</p></blockquote></li><li><p>有些低版本的服务可能不支持<code>docker compose</code>所提供的服务</p></li><li><p>还有一半，放在下一篇写</p></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/07/Docker-Compose-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/07/Docker-Compose-1/" itemprop="url">Docker Compose-1</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-07T16:47:40+08:00">2020-02-07 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p><strong>概述:</strong></p><ul><li>Compose是用于定义和运行多容器Docker应用程序的工具</li><li>通过Compose，可以使用YML文件来配置应用程序需要的所有服务</li><li>最后通过使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</li><li><a href="https://yaml.org/" target="_blank" rel="noopener">YAML</a>官方文档</li></ul><hr><p><strong>安装 Compose</strong></p><ul><li><p>Github地址:<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://github.com/docker/compose/releases</code></p></blockquote></li><li><p>下载源码包(二进制文件)</p></li><li><p>Docker Compose当前的稳定版本：</p><blockquote><p><code>$ sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.4/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>其中的1.25.4为版本号，可用于指定版本</p></li><li><p>提权至可执行文件</p><blockquote><p><code>$ sudo chmod +x /usr/local/bin/docker-compose</code></p></blockquote></li><li><p>设置环境变量的软链接</p><blockquote><p><code>$ sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</code></p></blockquote></li><li><p>查看版本，以测试是否安装成功</p><blockquote><p><code>$ docker-compose --version</code></p></blockquote></li><li><p>对于Alpine/Linux发行版，需要安装依赖包:<code>py-pip</code>，<code>python-dev</code>，<code>libffi-dev</code>，<code>openssl-dev</code>，<code>gcc</code>，<code>libc-dev</code>，以及<code>make</code></p></li></ul><hr><p><strong>使用</strong></p><ul><li>对Compose进行使用大概可分为三个步骤:<blockquote><p>使用Dockerfile定义应用程序的环境<br>使用<code>docker-compose.yml</code>文件定义构成应用程序的服务，使其可以在隔离环境中一起运行<br>最后，执行<code>docker-compose up</code>命令来启动并运行整个应用程序</p></blockquote></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/07/Docker-Dockefile-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/07/Docker-Dockefile-1/" itemprop="url">Docker Dockefile-1</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-07T16:44:44+08:00">2020-02-07 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p><strong>概述:</strong></p><ul><li>Dockerfile是用于构建镜像的文本文件</li><li>文本内容包含构建镜像所需的指令和说明</li></ul><p><strong>关于上下文的概念:</strong></p><ul><li>上下文路径，是指Docker在构建镜像时如果需要使用到本机内的文件(比如复制)，<code>docker build</code>命令得知所指定的路径后，会将该路径下的所有内容打包</li><li>Docker的运行模式是C/S，主机为C，Docker引擎是S</li><li>实际的构建过程是在Docker引擎内完成的，所以此时无法调用到本机内的文件，此时就需要人为的把本机指定目录下的所有文件打包，并提供给Docker引擎进行调用</li><li>如果未说明最后一个参数(未指定上下文所在路径)，那么默认上下文路径就是Dockerfile所在的目录下</li><li>上下文路径下所有的文件都会打包给Docker引擎，如果无用文件过多的话会造成执行过程缓慢</li></ul><hr><p><strong>Dockerfile内的基本指令</strong></p><ol><li><strong>FROM</strong></li></ol><ul><li>定制的镜像都是基于FROM的镜像，在选择完要定义的基础镜像之后，后续的操作都是基于该基础镜像的</li><li>格式:<blockquote><p><code>FROM &lt;所选基础镜像名&gt;</code></p></blockquote></li></ul><hr><ol start="2"><li><strong>RUN</strong></li></ol><ul><li>用于执行后面跟着的命令行命令，有两种格式<blockquote><p>Shell格式: RUN [命令行命令]<br>Exec格式: RUN [“可执行文件”, “参数一”, “参数二”]</p></blockquote></li><li>Dockefile每次执行指令都会在docker上新建一层，多余的层会造成镜像膨胀</li><li>可以用&amp;&amp;符号来连接命令，从而不进行指令的线性执行，目的就是让所有的指令都集成到一层内<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN xxx \</span><br><span class="line">   &amp;&amp; xxx \</span><br><span class="line">   &amp;&amp; xxx</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><strong>CMD</strong></li></ol><ul><li>类似于<code>RUN</code>指令，用于运行程序</li><li>二者的区别在于其运行的时间点不同:<blockquote><p><code>CMD</code>在<code>docker run</code>时运行<br><code>RUN</code>是在<code>docker build</code>时运行</p></blockquote></li><li>作用:<blockquote><p>为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束<br><code>CMD</code>指令指定的程序可被<code>docker run</code>命令行参数中指定要运行的程序所覆盖</p></blockquote></li><li>格式:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;shell 命令&gt; </span><br><span class="line">CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </span><br><span class="line">CMD [&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</span><br></pre></td></tr></table></figure><blockquote><p>第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是<code>.sh</code>，所以可以直接使用第二种格式<br><code>最后一种写法是为</code>ENTRYPOINT<code>指令指定的程序提供默认参数</code></p></blockquote></li></ul><ol start="4"><li><strong>ENTRYPOINT</strong></li></ol><ul><li><p>类似于<code>CMD</code>指令，但其不会被<code>docker run</code>的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>但如果运行<code>docker run</code>时使用了<code>--entrypoint</code>选项，此选项的参数可当作要运行的程序覆盖<code>ENTRYPOINT</code>指令指定的程序</p></li><li><p>特点就是在执行<code>docker run</code>的时候可以指定<code>ENTRYPOINT</code>运行所需的参数</p></li><li><p>但如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效</p></li><li><p>格式:</p><blockquote><p><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></p></blockquote></li><li><p>还可以搭配<code>CMD</code>命令使用:一般是变参才会使用<code>CMD</code>，这里的<code>CMD</code>等于是在给<code>ENTRYPOINT</code>传参</p></li><li><p>这里假设已有了某镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM 某镜像</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;&lt;某镜像&gt;&quot;, &quot;-c&quot;] #定参</span><br><span class="line">CMD [&quot;&lt;&#x2F;执行脚本所在文件目录&gt;&quot;] #变参</span><br></pre></td></tr></table></figure></li><li><p>不传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt;</code></p></blockquote></li><li><p>此时容器内会默认(等于)运行以下命令，启动主进程</p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>传参运行</p><blockquote><p><code>$ docker run &lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>容器内会默认(等于)运行以下命令，启动主进程<code>(/执行脚本所在文件目录:假设容器内已有此文件)</code></p><blockquote><p><code>&lt;某镜像&gt; -c &lt;/执行脚本所在文件目录&gt;</code></p></blockquote></li><li><p>简述</p><blockquote><p>指定了参数以后可以选择以传参或不传参的模式启动<br>不用传参就是直接启动所键入命令，用传参就是使用已指定的参数</p></blockquote></li></ul><hr><ol start="5"><li><strong>COPY</strong></li></ol><ul><li>用于复制的指令，可以从上下文目录复制文件或者目录到容器内的指定路径</li><li>使用格式:<blockquote><p><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;</code><br><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></p></blockquote></li><li>参数说明:<blockquote><p><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>为可选参数，可以让用户改变复制到容器内文件的拥有者和属组<br><code>&lt;源路径&gt;</code>用于表示源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足Go的<code>filepath.Match</code>规则<br><code>&lt;目标路径&gt;</code>用于在容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</p></blockquote></li></ul><ol start="6"><li><strong>ADD</strong></li></ol><ul><li>ADD和COPY的使用格式一致</li><li>同样需求下，官方推荐使用COPY</li><li>ADD的优缺点:<blockquote><p>ADD的优点:在执行<code>&lt;源文件&gt;</code>为<code>tar</code>压缩文件的话，压缩格式为<code>gzip</code>，<code>bzip2</code>以及<code>xz</code>的情况下，会自动复制并解压到<code>&lt;目标路径&gt;</code><br>ADD的缺点:在不解压的前提下，无法复制<code>tar</code>压缩文件，会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢</p></blockquote></li><li>具体是否使用，可以根据所处情况是否需要自动解压来决定</li></ul><hr><ol start="7"><li><strong>ENV</strong></li></ol><ul><li><p>用于设置与定义环境变量，定义之后可以直接使用环境变量</p></li><li><p>使用格式:</p><blockquote><p><code>ENV &lt;key&gt; &lt;value&gt;</code><br><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></p></blockquote></li><li><p>以下示例设置<code>NODE_VERSION = 7.2.0</code>，在后续的指令中可以直接通过<code>$NODE_VERSION</code>进行引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line"></span><br><span class="line">RUN curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;node-v$NODE_VERSION-linux-x64.tar.xz&quot; \</span><br><span class="line">  &amp;&amp; curl -SLO &quot;https:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v$NODE_VERSION&#x2F;SHASUMS256.txt.asc&quot;</span><br></pre></td></tr></table></figure></li></ul><ol start="8"><li><strong>ARG</strong></li></ol><ul><li>构建参数，与<code>ENV</code>作用一致，不过作用域不一样，<code>ARG</code>设置的环境变量仅对<code>Dockerfile</code>内有效，也就是说只有<code>docker build</code>的过程中有效，构建好的镜像内不存在此环境变量</li><li>构建命令<code>docker build</code>中可以用<code>--build-arg &lt;参数名&gt;=&lt;值&gt;</code>来覆盖</li><li>使用格式：<blockquote><p><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></p></blockquote></li></ul><hr><ol start="9"><li><strong>VOLUME</strong></li></ol><ul><li>定义匿名数据卷</li><li>在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</li><li>可以避免重要的数据因容器重启而丢失</li><li>还可以避免容器不断变大</li><li>使用格式:<blockquote><p><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code><br><code>VOLUME &lt;路径&gt;</code></p></blockquote></li><li>在启动容器<code>docker run</code>的时候，可以使用参数<code>-v</code>修改挂载点</li></ul><hr><ol start="10"><li><strong>EXPOSE</strong></li></ol><ul><li>用于声明端口</li><li>帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射</li><li>在运行时使用随机端口映射时，也就是<code>docker run -P</code>时，会自动随机映射<code>EXPOSE</code>的端口</li><li>使用格式:<blockquote><p><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></p></blockquote></li></ul><hr><ol start="11"><li><strong>WORKDIR</strong></li></ol><ul><li>用于指定工作目录</li><li>用<code>WORKDIR</code>指定的工作目录，会在构建镜像的每一层中都存在(<code>WORKDIR</code>指定的工作目录，必须是提前创建好的)</li><li>在使用<code>docker build</code>构建镜像过程中的，每一个<code>RUN</code>命令都是新建的一层，只有通过<code>WORKDIR</code>创建的目录才会一直存在</li><li>使用格式:<blockquote><p><code>WORKDIR &lt;工作目录路径&gt;</code></p></blockquote></li></ul><ol start="12"><li><strong>USER</strong></li></ol><ul><li>用于指定执行后续命令的用户和用户组，用于切换后续命令执行的用户(用户和用户组必须提前已经存在)</li><li>使用格式:<blockquote><p><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p></blockquote></li></ul><hr><ol start="13"><li><strong>HEALTHCHECK</strong></li></ol><ul><li>用于指定某个程序或者指令来监控Docker容器服务的运行状态</li><li>使用格式:<blockquote><p><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令<br><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令<br><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code> : 这个<code>CMD</code>后面跟随的命令使用，可以参考<code>CMD</code>的用法</p></blockquote></li></ul><hr><ol start="14"><li><strong>ONBUILD</strong></li></ol><ul><li>用于延迟构建命令的执行</li><li>简述:<blockquote><p>在<code>Dockerfile</code>里用<code>ONBUILD</code>指定的命令，在本次构建镜像的过程中不会执行(假设镜像为test-build)<br>当有新的<code>Dockerfile</code>使用了之前构建的镜像<code>FROM test-build</code>，这是执行新镜像的<code>Dockerfile</code>构建时候，<code>会执行 test-build</code>的<code>Dockerfile</code>里的<code>ONBUILD</code>指定的命令</p></blockquote></li><li>使用格式:<blockquote><p><code>ONBUILD &lt;其它指令&gt;</code></p></blockquote></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/06/Docker-4/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/06/Docker-4/" itemprop="url">Docker-4</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-06T21:17:20+08:00">2020-02-06</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Docker-镜像，网络，连接以及仓库的使用"><a href="#Docker-镜像，网络，连接以及仓库的使用" class="headerlink" title="Docker-镜像，网络，连接以及仓库的使用"></a>Docker-镜像，网络，连接以及仓库的使用</h3><p><strong>Docker 容器镜像的使用</strong></p><ul><li>管理和使用本地的docker镜像</li><li>查看本地主机已有镜像<blockquote><p><code>$ docker images</code></p></blockquote></li><li>各参数说明:</li></ul><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">REPOSITORY</td><td align="left">表示镜像的仓库源</td></tr><tr><td align="left">TAG</td><td align="left">镜像的标签</td></tr><tr><td align="left">IMAGE ID</td><td align="left">镜像ID</td></tr><tr><td align="left">CREATED</td><td align="left">镜像创建时间</td></tr><tr><td align="left">SIZE</td><td align="left">镜像大小</td></tr></tbody></table><ul><li>同一仓库源可以有多个<code>TAG</code>，代表这个仓库源的不同个版本</li><li><code>REPOSITORY:TAG</code>用于定义不同的镜像</li><li>例如使用<code>debian</code>，如果不指定一个镜像的版本标签，Docker 将默认使用<code>debian:latest</code>镜像</li></ul><p><strong>获取镜像</strong></p><ul><li>执行命令拉取10.2.0版本的debian镜像<br><code>$ docker pull debian:10.2.0</code><blockquote><p>获取之后可直接基于此镜像来运行容器<br>还可以从<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>上获取镜像<br><code>https://hub.docker.com/</code></p></blockquote></li></ul><p><strong>搜索镜像</strong></p><ul><li><p>执行命令搜索指定镜像名的镜像</p><blockquote><p><code>$ docker search [镜像名]</code><br>比如搜索一个httpd的镜像来用作web服务<br><code>$ docker search httpd</code></p></blockquote></li><li><p>各参数说明:</p><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">NAME</td><td align="left">镜像仓库源的名称</td></tr><tr><td align="left">DESCRIPTION</td><td align="left">镜像的描述</td></tr><tr><td align="left">OFFICIAL</td><td align="left">是否 docker 官方发布</td></tr><tr><td align="left">stars</td><td align="left">类似 Github 里面的star</td></tr><tr><td align="left">AUTOMATED</td><td align="left">是否支持自动构建</td></tr></tbody></table></li></ul><blockquote><p>然后直接拉取镜像<br><code>$ docker pull httpd</code></p></blockquote><p><strong>删除镜像</strong></p><ul><li>执行以下命令:<blockquote><p><code>$ docker rmi 镜像名</code></p></blockquote></li></ul><hr><p><strong>创建镜像/制作镜像</strong></p><ul><li>当docker的镜像仓库中没有所需求的docker镜像时，可以制作镜像或对镜像进行修改再上传</li></ul><p><strong>更新镜像</strong></p><ul><li>从已经创建的容器中更新镜像，并且提交此镜像<blockquote><p>更新镜像之前，基于所选镜像来创建一个容器<br><code>$ docker run -t -i debian:10.2.0 /bin/bash</code><br>在容器内使用<code>apt-get update</code>命令来进行更新<br>操作完成之后，键入<code>exit</code>退出容器</p></blockquote></li><li>使用<code>docker commit</code>来提交容器副本<br><code>$ docker commit -m=&quot;has update&quot; -a=&quot;name&quot; [Containers ID] /debian:v2</code><blockquote><p><code>参数-m</code>用于指定提交的描述信息<br><code>参数-a</code>用于指定镜像作者<br><code>Containers ID</code>:容器 ID<br><code>debian:v2:</code>指定要创建的目标镜像名</p></blockquote></li><li>最后<code>docker images</code>查看新镜像，并用其启动容器</li></ul><p><strong>构建镜像</strong></p><ul><li>使用命令<code>docker build</code>，创建一个新的镜像</li><li>创建名为<code>Dockerfile</code>的文件，其中包含的指令用来指示Docker如何构建所选镜像</li><li>编写完Dockerfile之后通过docker build命令来构建一个新的镜像<blockquote><p><code>docker build -t [目标镜像名] [指定绝对路径]</code><br><code>参数-t</code>用于指定要创建的目标镜像名<br><code>参数.</code>用于指定Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</p></blockquote></li></ul><p><strong>设置镜像标签</strong></p><ul><li><code>docker tag</code>命令，为镜像添加一个新的标签<blockquote><p><code>docker tag [镜像ID] [用户名称/镜像源名(repository name)]:[新的标签名(tag)]</code></p></blockquote></li></ul><hr><p><strong>Docker 容器连接</strong></p><ul><li>容器中可以运行一些网络应用，从实现而让任意机器可以通过网络端口访问运行在docker容器内部的服务</li><li>要实现让任意机器(内部与外部)可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射</li><li>还可以指定容器绑定的网络地址，比如绑定本地主机的<code>127.0.0.1</code></li></ul><p><strong>网络端口映射的管理</strong></p><blockquote><p><code>docker run -d -P [网络服务名称] [服务的启动脚本]</code></p></blockquote><ul><li>参数说明:</li><li>参数-P用于创建容器，此时该网络服务绑定本地主机的默认端口</li><li>参数-p用于指定容器端口所绑定的主机端口</li><li>具体区别<blockquote><p>参数-P是让容器内部端口随机映射到主机的高端口<br>参数-p是让容器内部端口绑定到指定的主机端口</p></blockquote></li></ul><blockquote><p><code>docker run -d -p [原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote><ul><li>然后执行docker ps 就会发现服务已改变端口映射</li></ul><p><strong>指定容器绑定的网络地址</strong></p><ul><li>这里绑定127.0.0.1:<blockquote><p><code>docker run -d -p [127.0.0.1:原端口:指定绑定端口] [应用程序名称] [程序的启动脚本]</code></p></blockquote></li><li>此时就可以通过绑定的IP地址，来访问容器被指定绑定的接口</li><li>默认都是绑定TCP端口，如果要绑定UDP端口，可以在端口后面加上<code>/udp</code></li><li><code>docker port</code>命令可以让我们快捷地查看端口的绑定情况</li></ul><hr><h3 id="Docker-容器互连"><a href="#Docker-容器互连" class="headerlink" title="Docker 容器互连"></a>Docker 容器互连</h3><ul><li>端口映射不是唯一把Docker连接到另一个容器的方法</li><li>Docker内有一个连接系统允许将多个容器进行连通，以此共享被连接容器的信息</li><li>Docker连接会创建一个子父关系，其中父容器可以看到子容器的信息</li><li>先给容器进行统一的命名，以方便管理<blockquote><p><code>docker run -d -P --name [自定义容器名] [应用程序名称] [程序的启动脚本]</code><br><code>参数--name</code>用于定义容器名</p></blockquote></li></ul><p><strong>创建docker网络</strong></p><blockquote><p><code>docker network create -d bridge [Containers-net]</code><br><code>参数-d</code>用于指定Docker的网络类型，有<code>bridge</code>与<code>overlay</code><br>其中<code>overlay</code>网络类型用于<code>Swarm mode</code></p></blockquote><p><strong>连接容器</strong></p><ul><li>运行一个容器并连接到新建的<code>Containers-net</code>网络<blockquote><p><code>$ docker run -itd --name test1 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>打开新的终端，再运行一个容器并加入到 test-net 网络:<blockquote><p><code>$ docker run -itd --name test2 --network Containers-net debian /bin/bash</code></p></blockquote></li><li>使用test1和test2两个容器互相ping一下以测试是否建立联系，如果没有ping命令就进行安装<blockquote><p><code>apt install iputils-ping</code></p></blockquote></li><li>可以在一个容器里安装好之后把容器包装成镜像，再以新的镜像重新运行以上两个容器</li><li>如果有多个容器之间需要互相连接，可以使用<code>Docker Compose</code></li></ul><p><strong>配置容器DNS</strong></p><ul><li><p><code>/etc/docker/daemon.json</code>文件中增加以下内容来设置全部容器的DNS:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dns&quot; : [</span><br><span class="line">    &quot;111.111.111.111&quot;,</span><br><span class="line">    &quot;3.3.3.3&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置后，启动容器的DNS会自动配置为<code>111.111.111.111 和 3.3.3.3</code></p></li><li><p>配置完，需要重启Docker服务才能生效</p><blockquote><p><code>/etc/init.d/docker restart</code></p></blockquote></li><li><p>查看容器的DNS是否生效可以使用以下命令，它会输出容器的DNS信息:</p><blockquote><p><code>$ docker run -it --rm debian cat etc/resolv.conf</code></p></blockquote></li><li><p>只想在指定的容器设置 DNS，则可以使用以下命令</p><blockquote><p><code>docker run -it --rm host_debian --dns=111.111.111.111 --dns-search=test.com debian</code></p></blockquote></li><li><p>参数说明：</p><blockquote><p>参数<code>-h HOSTNAME</code>或<code>--hostname=HOSTNAME:</code>设定容器的主机名，它会被写到容器内的<code>/etc/hostname</code>和<code>/etc/hosts</code><br>参数<code>--dns=IP_ADDRESS:</code>添加DNS服务器到容器的<code>/etc/resolv.conf</code>中，让容器用这个服务器来解析所有不在<code>/etc/hosts</code>中的主机名<br>参数<code>--dns-search=DOMAIN:</code>设定容器的搜索域，当设定搜索域为<code>.example.com</code>时，在搜索一个名为<code>host</code>的主机时，DNS不仅搜索<code>host</code>，还会搜索<code>host.example.com</code><br>如果在容器启动时没有指定<code>--dns</code>和<code>--dns-search</code>，Docker会默认用宿主主机上的<code>/etc/resolv.conf</code>来配置容器的DNS</p></blockquote></li></ul><hr><p><strong>仓库管理</strong></p><ul><li><p>仓库(Repository)用于集中存放镜像</p></li><li><p>目前Docker官方维护了一个公共仓库Docker Hub</p></li><li><p>大部分需求都可以通过在Docker Hub中直接下载镜像来实现</p></li><li><p>网址为<code>https://hub.docker.com</code>，<a href="https://hub.docker.com" target="_blank" rel="noopener">跳转</a></p></li><li><p>使用之前需要注册账户</p></li><li><p>登陆Docker hub执行</p><blockquote><p><code>$ docker login</code></p></blockquote></li><li><p>退出 docker hub执行</p><blockquote><p><code>$ docker logout</code></p></blockquote></li><li><p>查找镜像</p><blockquote><p><code>$ docker search [镜像名]</code></p></blockquote></li><li><p>拉取镜像</p><blockquote><p><code>$ docker pull [镜像名]</code></p></blockquote></li></ul><p><strong>推送镜像</strong></p><ul><li>把本地的镜像推送到Docker Hub</li><li><code>username</code>为Docker账号的用户名<blockquote><p><code>$ docker tag [镜像名]:[版本] [username/镜像名:版本]</code><br><code>$ docker image ls</code><br><code>$ docker push [username/镜像名:版本]</code></p></blockquote></li><li>最后查看一下<blockquote><p><code>$ docker search [username/镜像名]</code></p></blockquote></li></ul><hr><p><strong>参考资料</strong></p><p>官方文档:<a href="https://docs.docker.com/" target="_blank" rel="noopener">跳转</a><br><code>https://docs.docker.com/</code></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://unit-serow.github.io/2020/02/06/Docker-3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="serow"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.png"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="UNIT"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2020/02/06/Docker-3/" itemprop="url">Docker-3</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-06T18:44:34+08:00">2020-02-06 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/" itemprop="url" rel="index"><span itemprop="name">软件</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/" itemprop="url" rel="index"><span itemprop="name">虚拟化</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Docker容器的基本命令与基本应用"><a href="#Docker容器的基本命令与基本应用" class="headerlink" title="Docker容器的基本命令与基本应用"></a>Docker容器的基本命令与基本应用</h3><p><strong>基本操作命令</strong></p><p><strong>拉取镜像</strong><br><code>$ docker pull --help</code><br><code>$ docker pull [OPTIONS] NAME:[:TAG|@DIGEST]</code><br>如果本地没有镜像，用pull从仓库里拉个镜像用<br><code>$ docker pull debian</code></p><p><strong>基于已有镜像启动容器服务</strong><br><code>$ docker run --help</code><br><code>$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code><br><code>$ docker run -i -t debian /bin/bash</code></p><ul><li><code>参数-i</code>启动交互式选项，<code>参数-t</code>启动终端选项</li><li><code>debian</code>:也就是debian镜像</li><li><code>/bin/bash</code>:放在镜像后的是被执行指令，这里用<code>/bin/bash</code>来启动交互式<code>Shell</code></li><li>退出当前容器内终端执行<code>exit</code></li></ul><hr><p><strong>查看所有容器</strong><br><code>$ docker ps -a</code></p><ul><li>查询最后一次创建的容器<br><code>$ docker ps -l</code></li></ul><p><strong>启动一个已停止的容器</strong><br><code>$ docker start [容器ID]</code></p><ul><li><code>参数-d</code>用于指定容器的运行模式，加了此参数的程序默认不会进入程序，进入容器需要使用指令<code>docker exec</code></li><li>在后台内利用容器debian运行debian-test程序</li><li><code>$ docker run -i -t -d --name debian-test debian /bin/bash</code></li></ul><p><strong>停止容器</strong><br><code>$ docker stop [容器 ID]</code></p><p><strong>重启容器</strong><br><code>$ docker restart [容器 ID]</code></p><p><strong>进入容器</strong><br><code>$ docker attach/exec --help</code></p><ul><li>在执行<code>参数-d</code>后，容器启动后会进入后台</li><li>此时想要进入容器，可以通过以下指令进入：<blockquote><p>docker attach<br>docker exec(使用docker exec命令时退出容器终端，不会导致容器的停止)<br><code>$ docker attach 容器ID</code>(如果从这个容器退出，会导致容器的停止)<br><code>$ docker exec -i -t 容器ID /bin/bash</code>(从这个容器退出，不会导致容器的停止)</p></blockquote></li></ul><p><strong>导出本地的某个容器</strong><br><code>$ docker export [容器ID] &gt; [生成的文件名(可以是tar或其他压缩文件)]</code></p><blockquote><p>把指定ID的容器快照导入到本地文件，保存地址是现在所处目录</p></blockquote><p><strong>导入容器快照</strong><br><code>$ docker import --help</code><br><code>$ docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code></p><blockquote><p>将快照文件<code>debian.tar</code>导入到镜像<code>image-file/debian:v1</code>内<br><code>$ cat docket/debian.tar | docker import - image-test/debian:v1</code><br>还可以通过指定URL或者某个目录来导入<br><code>$ docker import http://example.com/exampleimage.tgz example/imagerepo</code></p></blockquote><p><strong>删除容器</strong><br><code>$ docker rm -f [容器ID]</code></p><ul><li>清理所有已中止容器<br><code>$ docker container prune</code></li></ul><hr><p><strong>利用docker运行某个应用程序</strong></p><ul><li>拉取某个应用程序<br><code>$ docker pull [应用程序名]</code><br><code>$ docker run -d -P [被拉取的程序名] [运行脚本]</code><blockquote><p><code>参数-d</code>让容器在后台运行<br><code>参数-P</code>将容器内部使用的网络端口映射到我们使用的主机上<br>如果程序占用了某一端口，<code>docker ps</code>的时候会显示占用端口以及映射信息(PORST)</p></blockquote></li><li>通过<code>-p参数</code>来设置不一样的端口<br><code>$ docker run -d -p [原端口:指定端口] [被拉取的程序名] [运行脚本]</code></li></ul><p><strong>查看应用程序或容器使用的端口以及映射情况</strong><br><code>$ docker ps</code><br><code>$ docker port [容器ID/程序名]</code></p><p><strong>查看应用程序日志</strong><br><code>docker logs [容器ID/程序名]</code></p><blockquote><p>用于查看容器内部的标准输出<br><code>参数-f</code>用于让<code>docker logs</code>输出容器内部的标准输出，类似于Linux内的<code>tail -f</code>命令</p></blockquote><p><strong>查看应用程序进程</strong><br><code>$ docker top [容器ID/程序名]</code></p><p><strong>检查应用程序底层信息</strong><br><code>$ docker inspect [容器ID/程序名]</code></p><blockquote><p>会返回一个记录着关于选中应用程序的Docker容器配置和状态信息的文本</p></blockquote><p><strong>停止应用程序所在容器</strong><br><code>$ docker stop [容器ID/程序名]</code></p><p><strong>重启应用程序所在容器</strong><br><code>$ docker start [容器ID/程序名]</code></p><p><strong>移除应用程序所在容器</strong><br><code>$ docker rm [容器ID/程序名]</code></p><blockquote><p>删除容器时，容器必须是停止状态</p></blockquote><hr><p><strong>帮助命令:</strong></p><ul><li>直接执行<code>docker</code>，查看Docker客户端的所有可用指令选项</li><li>docker command –help，查看所选命令的帮助文件</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div><div></div></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="serow"><p class="site-author-name" itemprop="name">serow</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/%7C%7C%20archive"><span class="site-state-item-count">35</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">8</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Unit-serow" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i></a> </span><span class="links-of-author-item"><a href="mailto:unit.serow@gmail.com" target="_blank" title="E-Mail"><i class="fa fa-fw fa-envelope"></i></a> </span><span class="links-of-author-item"><a href="https://plus.google.com/unit.serow" target="_blank" title="Google"><i class="fa fa-fw fa-google"></i></a> </span><span class="links-of-author-item"><a href="https://user.qzone.qq.com/2721304117" target="_blank" title="QQ"><i class="fa fa-fw fa-qq"></i></a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-inline"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 快捷链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://www.gnu.org/home.zh-cn.html/" title="GNU" target="_blank">GNU</a></li><li class="links-of-blogroll-item"><a href="https://www.debian.org/" title="Debian" target="_blank">Debian</a></li><li class="links-of-blogroll-item"><a href="https://www.centos.org/" title="CentOS" target="_blank">CentOS</a></li><li class="links-of-blogroll-item"><a href="https://www.gentoo.org/" title="Gentoo" target="_blank">Gentoo</a></li><li class="links-of-blogroll-item"><a href="https://en.wikipedia.org/Wiki/wiki" title="Wiki-EN" target="_blank">Wiki-EN</a></li><li class="links-of-blogroll-item"><a href="https://zh.wikipedia.org/wiki/Wiki" title="Wiki-CN" target="_blank">Wiki-CN</a></li><li class="links-of-blogroll-item"><a href="https://baike.baidu.com" title="百度百科" target="_blank">百度百科</a></li><li class="links-of-blogroll-item"><a href="https://www.gnu.org/prep/ftp.html" title="GNU 镜像源" target="_blank">GNU 镜像源</a></li><li class="links-of-blogroll-item"><a href="https://mirrors.cloud.tencent.com/" title="腾讯镜像源" target="_blank">腾讯镜像源</a></li><li class="links-of-blogroll-item"><a href="https://developer.aliyun.com/mirror/" title="阿里镜像源" target="_blank">阿里镜像源</a></li><li class="links-of-blogroll-item"><a href="https://mirrors.163.com/" title="网易镜像源" target="_blank">网易镜像源</a></li></ul></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">serow</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script></body></html><!-- rebuild by neat -->