---
title: MS-SQL-1
date: 2020-03-07 16:43:29
tags: [随笔,RDBMS]
categories: [软件,数据库]
---

<center><strong>Access/MS SQL基本概念归纳</strong></center>

<!-- more -->

## MS SQL-1

* 网课随堂笔记
* Access
* MS SQL

* 数据库基础概念相关知识(数据抽象/数据模型/关系模型/各级关系运算)

---

### 1. 数据抽象

* 设计数据库就是对数据的抽象过程:
> `用户需求-抽象->概念模型-转换->[逻辑数据模型(外部模型)]->物理模型->数据库`
* 物理模型用于实现在数据库中对数据的存储
* 设计数据库的主要工作是构造数据模型
* 数据模型是对现实世界中数据特征的抽象
* 数据抽象中的数据模型主要有四种
* 概念模型 实体联系模型，可用于表达用户需求观点的数据全局逻辑结构的模型
* ER图表示，ER图通常需要进行优化
> `局部概念模型->全局概念模型`
* ER图通常十分直观且形象

---

* 逻辑模型
> 用于表达计算机实现观点的数据库全局逻辑结构的模型
> 以树结构组织数据被称为层次模型
> 以网状结构组织数据称为网状模型
> 以二维表组织数据称之为关系模型(通常为主流数据模型)
> ER图转化为逻辑模型
> 一对多，多对多，一对一，数据结构中存在几个实体对象，就将之称为几元联系
> 关系模式-(关系名->属性名)
* 所有实体对象的集合被称之为关系
---
* 内部模型
> 即为物理模型
> 是用于表达数据库物理结构的数据库全局模型
> 以概念模型为基础，而转换处物理模型(内部模型)
> 有了物理模型，即可以在数据库中建立与之相对应的表结构
---
* 外部模型
> 是用于表达用户使用观点的数据库局部逻辑结构的模型
> `[逻辑模型(若干外部模型)]`
> 数据抽象过程

---

* 关系模型
> 数据模型是一种严格定义的概念模型
> 关系模型精准的定义了数据结构，以及表与表之间可能发生的各种数据操作与管理，包括数据完整性操作
> 关系模型是以二维表的形式来组织数据
> 支持关系模型的数据库即为关系数据库
> 它使用若干个数据表来存储数据，此间可将一张二维表称之为关系
> 而关系的集合即为关系数据库

* 关系模型的有关概念
> 元组:表中的行，或称为记录
> 属性:表中的列，或称为字段与数据项
> 域:属性的取值范围
> 分量:一个属性的值
> 码:表中某个属性或属性组唯一标识一个元组
> 比如在一个表内，ID字符标识了所在行的整个元组，则称ID为码，即为关系模式约束
> `概念模型->逻辑模型->物理模型(内部模型)`

* 同种类型的实体集合被称之为实体型

* 在逻辑模型中所设计的一切概念，都被称之为关系模式
> 关系模式由关系名及其属性的集合构成
> 在逻辑模型中将其称之为关系

* 在内部模型中，也就是表结构，实体集为同一类型的表所属的数据集合
> 在关系模型中将其称之为表

* 为何把表称之为关系
> 数学上把一系列域上的笛卡尔积的子集称为关系
> 而表正符合此定义

* 域是一组具有相同类型的值的集合
> 比如: 整型，实型或指定长度的字符串集合
> 而关系中属性的域可以被理解为属性的取值范围
> 比如学生中的性别属性，它的域就是男与女两个字符串

* 笛卡尔积
> 所有域的所有取值的任意集合
> 在数学中，以乘号来描述此概念
> 即`A*B={(x,y)|x∈A^y∈B}`

* 设集`A={a,b}`，集`B={0,1,2}`
> 即A的两个值乘以B的三个值
> 则两个集合的笛卡尔积为`{(a,0),(a,1),(a,2),(b,0),(b,1),(b,2)}`
> 如果A表示某学校学生的集合，B表示改学校所有课程的集合
> 则A与B的笛卡尔积可以用于表示所有的选课情况
> A如果表示声母集合，B如果表示所有的声母集合，则A与B的笛卡尔积则可表示所有汉字的读音组合

* 笛卡尔积并不都是有意义的
> 设集`A={01,02}`,集`B={张三,李四}`
> 则两个集合的笛卡尔积为`{(01,张三),(01,李四),(02,张三),(02,李四)}`
> 如果A代表学号，B代表姓名，假设张三的学号是一号，而李四是二号
> 所以该笛卡尔积的结果集中，01的李四与02的张三是没有意义的

* 数学上将一系列域上的笛卡尔积的子集称之为关系
* 而笛卡尔积中具有意义的那些元组则才被称之为关系

* 不是所有的二维表都是关系，关系是有以下特性的:
> 关系必须规范化，比如: 每个表有多行，每个行有多列，每个行列单元都是不能再分的原子值
> 在同一关系中不允许出现相同的属性名
> 而关系中不允许有完全相同的元组
> 并且同一关系中元组及其属性的顺序可以随意

* 严格的去定义表的具体规则与基本要求

---

### 关系运算

* 关系操作与数据查询操作可以用关系代数与关系逻辑的方法描述
* 或用具体的数据库语言，如SQL-结构化查询语言来描述与实现
* 最基本的方法是代数方法，即关系代数
> `关系A<-运算集合->关系B=关系C`
> 代数是数学概念，同时关系代数也同为数学概念
> 运算符包括一系列运算集合
> 两个不同的关系通过一个运算符的运算来获得一个新的关系结果

* 关系运算的运算符有两类，即为集合运算符和专门的关系运算符

* 选择运算
> 选择运算是从关系中找出满足条件的元组的元组的操作
> 将其记为: `σ[(下标)<条件表达式>] (R)`
> 用处于右下角的谓词来写条件表达式
> 其中，σ是选择运算符，R是关系名

* 选择运算是根据给定的条件选择关系R中的若干元组而组成的新关系，是对关系的元组进行筛选
> 结果关系与原关系有着相同的模式
> 可以将其表示为: `σ[(下标)sex]=R(tables_name)`
> 在`tables_name`表中，找出sex字段等于R的所有记录
> 所以选择运算是对于行的操作

---

**投影运算**

* 投影运算是从关系中选取若干属性组成新的关系
* 投影运算是从列的角度进行计算，相当于对关系进行垂直分解
* 投影运算符用π来表示
> `π[(下标)A] (R)`
> A用于表示投影属性或属性组，R是关系名

* 例子: `π[(下标)A], π[(下标)A1](R)`
> 在R表中对A与A1两个字段进行投影，形成新的关系，同时去掉结果关系中重复的元组

* 关系代数是把表看作元组集合的关系，既然是集合就不包括重复元组
* 也就是说，关系代数的每个运算都是去重复的

---

**并运算**

* 并运算属于集合运算
> 集合运算的两个关系必须拥有相同的关系模式，即相同的结构
> 两个关系包含属性的个数一致
> 两个关系对应属性的域应该相同或包容

* 两个已知关系R和S的并将产生一个包含R，S中所有不同元组的新关系
> 将其记为: `R∪S` 
> 则为R并S，因此并运算可以将其理解为现实中的或者

* 两个已知关系R和S的交，是属于R而且也属于S的元组组成的新关系
> 将其极为: `R∩S`

* 实例:
> 设有两张不同的表`tables_A`与`tables_B`，并且设这两个表中分别有字段a，b，c，d，其值分别为拥有4行分别1，2，3，4的矩阵数列
> 首先找表`tables_A`中的a字段，即为:
> 先在`tables_A`表中进行选择运算，寻找的条件是a字段等于1，即为找出所有a等于1类型的数据记录，然后再进行投影运算，只取c字段(基于字段/列c来对a=1进行投影计算，也可称之为映射计算)
> 并且再`tables_B`表中进行选择运算，寻找的条件是b小于3的所有记录，然后进行投影运算
> 再将表`tables_A`与表`tables_B`进行差运算
> 此时的输出数据就是
> 将表`tables_A`中将所有已经排除了表`tables_B`中b小于三的数值类型的所有数值类型
> 因此得到想要查询的类型

* 可将SQL语句具体描述为
> `(π[(下标)c], π[(下标)a=1](tables_A))) - (π[(下标)c], π[(下标)b>3](tables_B)))`

* 此时应输出的查询值即为
```
a，b
1，2
```

* 使用数据模型:
```
tables_A
a，b，c，d
1，2，3，4
1，2，3，4
1，2，3，4
1，2，3，4
```
```
tables_B
a，b，c，d
1，2，3，4
1，2，3，4
1，2，3，4
1，2，3，4
```

---

**笛卡尔积运算**

* 设A和B是两个关系，如果A是m元关系，有i个元组
* B是n元关系，有j个元组，则笛卡尔积为`A*B`是一个`m+n`元关系，则有`i*j`个元组

* 实例:

* 数据模型:
```
tables_A
a，b
1，2
3，4
1，3
```
```
tables_B
c，d，e
1，2，3
4，7，6
7，8，9
```
* 此时A关系有三个元组，同时B关系有三个元组

* 此时的笛卡尔积则为`3*3`，则为9个元组
> A关系的第一个元组与B关系的所有元组进行连接
> A关系的第二个元组与B关系的所有元组进行连接
> A关系的第三个元组与B关系的所有元组进行连接

* 此结果即为此笛卡尔运算的乘积结果
```
a，b，c，d，e
1，2，1，2，3
1，2，4，7，6
1，2，7，8，9
3，4，1，2，3
3，4，4，7，6
3，4，7，8，9
1，3，1，2，3
1，3，4，7，6
1，3，7，8，9
```

* 笛卡尔积运算可以把两个运算连接到一起，从而形成一个新的关系
> 由此引出连接运算与笛卡尔积的关系与区别

---

**连接运算**

* 连接运算是将两个关系的若干属性值拼接成一个新的关系的操作
* 对应的新关系中，包含满足连接条件的所有元组
* 即可将其记为: `R 连接(AθB)  S` (连接符号于普通文本间无法输入)

* 其中，R与S是关系名
> A，B分别是R和S上度相等且可比的属性组
> θ是比较运算符

* 实例:

* 数据结构模型:
```
tables_A

A，B，C
a1，a2，3
a1，b2，4
a2，b3，6
a2，b3，7
```
```
tables_B

B，E
b1，8
b2，9
b3，1
a2，2
a1，6
```

* 对表`tables_A`与表`tables_B`进行以下比较连接
* `tables_A 连接(c<E) tables_B`，即为`tables_A`中的c属性小于`tables_B`中的E属性
* 连接所输出的结果集为:
```
C，E
3，8
4，9
null，6
```

* 此例为比较连接

---

* 当比较运算符为等号时，可分为等值连接与自然连接

**等值连接:**

* 当连接条件为"="时的连接运算 `R 连接(R.C=S.E) S`，此条件即可描述为R的C属性等于S的E属性

**自然连接**

* 自然连接是一种特殊的等值连接
> 它要求两个关系中进行变焦的分量是相同的属性组，并且在结果中把重复的属性列去掉，可表示为: `R 连接 S`
* 此间的连接符号皆使用文字描述
* 如果将上述数据模型进行自然连接，即为将量表中的B列所拥有且相等的所有分量进行连接
* 连接运算与笛卡尔积运算的区别
* 连接运算是笛卡尔积运算和特定选择运算合并而成的一个运算

* 以此数据模型为例:

1. 等值连接
> 当`tables_A 连接(tables_A.C=tables_B.E) tables_b`
> 即为将量表进行等值运算，运算条件与输出的值则为量表中分别`C=E`的值

* 结果即为:
```
A，tables_A.B，C，tables_B.B，E
a1，b1，3，a2，3
a2，b3，6，a1，6
```

2. 自然连接

* `tables_A 连接 tables_B`
> 此间无任何条件

* 结果即为:
```
A，tables_A.B，C，E
a1，b1，8，8
a1，b2，3，9
a2，b3，6，3
```

* 使用数据模型:
```
tables_A

A，B，C
a1，b1，3
a1，b2，4
a2，b3，6
a2，b3，7
```
```
tables_B

B，E
b1，8
b2，9
b3，3
a2，2
a1，6
```

---

**等值连接**

* `tables_A`中的C属性与`tables_B`中的E属性进行比较，一直比较到有相同的元组相等时，将所在元组进行连接
> 比如在此实例中3，6，相等，即连接结果为以上两条元组

**自然连接**

* `tables_A`中的B属性和`tables_B`中的B属性进行等值比较
> 此时b1=b1，b2=b2，b3=b3都互为相等，则互相连接，则输出结果为以上两个元组

---

* 从运算过程可以总结规律: 自然连接必定是等值连接，自然连接与等值连接的区别则在于自然连接所比较的属性必须为公共属性，或者是属性组
> 还有一点就是自然连接所形成的新关系会自动将重复的属性去掉
> 在上例中就把`tables_B`中的B属性去掉了，因为同样的属性所产生的值也必然是相同的，所以会将重复复的值去掉

---

**外连接**

* 有些元组不能跟另外关系的任何一个元组匹配，一些实际应用中希望在结果中保留悬浮元组，因此就产生了外连接机制
* 外连接包括了左外连接，右外连接以及全外连接的概念

* 外连接运算的逻辑
1. 计算内连接(比较连接，等值连接与自然连接)
2. 然后根据左外连接，右外连接或全外连接再加上左侧关系或者右侧关系或者两侧关系中的没有匹配到的元组及悬浮元组
3. 最后加上悬浮元组用控制NULL来填充相对与另一侧属性的属性值

* 实例:
> 自然连接符号的右上角会标识有连接标识L左外连接，R右外连接，F全外连接

* 数据模型结构:
```
tables_A

A，B，C
a3，b1，3
a1，b2，4
a2，b3，6
```
```
tables_B

D，E
b1，8
b2，9
a1，3
a2，2
```

1. 计算机会先计算出自然连接的结果
2. 之后再进行认为所指定的连接运算规则
3. 然后再将所有乘积的属性置为空(NULL)
4. 最后输出的数据集合变为结果

* 其它的运算都可以从这些基本关系的运算合并而成

---

* 更多的实例这里不做过多阐述了，因为是Access与MS SQL，因此没有什么对其进行过多抽象描述的必要

* 知识图谱图片:

<img src="images/MS-SQL-2.png" width="30%" height="30%">

* 相关概念图片:

<img src="images/MS-SQL-1.png" width="30%" height="30%">

---

### 参考文献

**参考URL**

* 数据抽象级别[跳转](https://blog.csdn.net/LetsStudy/article/details/79095315)
> `https://blog.csdn.net/LetsStudy/article/details/79095315`

* 数据科学的核心问题：现实问题的数据抽象与程序表达[跳转](https://blog.csdn.net/qq_36616602/article/details/85345295)
> `https://new.qq.com/omn/20181003/20181003A0XITF00`

* 数据库关系模型范式总结[跳转](https://blog.csdn.net/qq_36616602/article/details/85345295)
> `https://blog.csdn.net/qq_36616602/article/details/85345295`

* 数据库之父对实现关系型数据库管理系统的12条建议[跳转](https://blog.csdn.net/happmaoo/article/details/83075287)
> `https://blog.csdn.net/happmaoo/article/details/83075287`

* 数据库关系运算[跳转](http://baijiahao.baidu.com/s?id=1602887097860809528&wfr=spider&for=pc)
> `http://baijiahao.baidu.com/s?id=1602887097860809528&wfr=spider&for=pc`

**参考书籍:**

* 数据库原理及应用 (2017.06-郭春生，方昕)
* 数据库应用技术 (2018.1-栾志军，吕海洋，付海娟主编)

* 数据库技术与应用-2020年春季
> 第一章-数据库基础知识
> 1.4节-1.6节(数据抽象/关系模型/关系运算)

---



