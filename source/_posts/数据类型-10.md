---
title: 数据类型-10
date: 2020-03-22 02:58:59
tags: [随笔,C]
categories: [软件,C/C++]
---

<center><strong>数据类型-数组类型&指针类型</strong></center>

<!-- more -->

## 数据类型-10

---

## 数组&指针

**相关内容:**

* static关键字
* 一元运算符: `&`，`*`
* 数组基础概念刨析(泛用概念之一)
* 指针，指针和数组的关系
* 函数对于数组的处理
* 二维数组~多维数组

**相关介绍:**

* 当在当前程序中需要处理大量相关数据时，通常使用数组能高效便捷地处理这种数据
* 同时可以函数把模块化编程的优势应用到数组，并且数组与指针的关系非常密切

---

## 数组

### 数组-基本概念

**概述:**

* 数组由数据类型相同的一系列元素组成
> 需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型
> 编译器根据这些信息正确地创建数组
> 普通变量可以使用的类型，数组元素都可以用

* 通常情况下，使用方括号([])来表明数组，方括号中的数字表明数组中的元素个数，方括号前则为对数组的命名，即为内存标识符
> 要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素
> 数组元素的编号从0开始，所以xxx[0]表示xxx数组的第1个元素

---

**关于初始化数组:**

* 数组通常被用来储存程序需要的数据
> 例如一个内含12个整数元素的 数组可以储存12个月的天数
> 在这种情况下，在程序一开始就初始化数组比较好

* 只储存单个值的变量有时也称为标量变量(scalar variable)
> 初始化这种变量即为给变量赋值，将右值通过赋值符号赋给左值

* ANSI C 初始化数组的基本语法:
> `int unit[7] = {1,2,3,4,5,6,7,}`

* 用以逗号分隔的值列表(用花括号括起来)来初始化数组， 各值之间用逗号分隔
> 在逗号和值之间可以使用空格
> 根据上面的初始化， 把1赋给数组的首元素(powers[0])，以此类推
> 不支持ANSI的编译器会把这种形式的初始化识别为语法错误
> 在数组声明前加上关键字static可解决此问题

* 还可以给数组内的存储容量，也就是放括号内的数组用#define设置为符号常量
> 比如: #define serow 10~int unit[serow] = {1,2,3,4...,10};
> 如果要需要将10换一个其它的字符，子需要修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方

* 关于使用const声明数组
> 有时需要把数组设置为只读
> 这样，程序只能从数组中检索值，不能把新值写入数组
> 要创建只读数组，应该用const声明和初始化数组
> 因此可以将其写为: const int unit[serow] = {1,2,3,4...,10};

* 这样修改后，程序在运行过程中就不能修改该数组中的内容
> 和普通变量一样，应该使用声明来初始化const数据
> 因为一旦声明为const，便不能再给它赋值
> 明确了这一点，就可以在其它的代码块中使用const了

**关于初始化数组失败:**

* 使用数组前必须先初始化它
> 与普通变量类似，在使用数组元素之前， 必须先给它们赋初值
> 因为编译器使用的值是内存相应位置上的现有值

**关于存储类别警告:**

* 数组和其他变量类似，可以把数组创建成不同的存储类别(storageclass)
> 关于存储类别的相关内容这里不做过多赘述
> 多数的数组都属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static
> 多数的变量和数组都是自动存储类别

* 不同的存储类别有不同的属性，除此之外还有其它的存储类别
> 对于一些其它存储类别的变量和数组，如果在声明时未初始化
> 编译器会自动把它们的值设置为0

**关于初始化列表中的项数应与数组的大小不一致问题:**

* 假如有此种情况: #define SIZE 4~int some_data[SIZE] = {1,2};
> 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0
> 也就是说，如果不初始化数组， 数组元素和未初始化的普通变量一样，其中储存的都是垃圾值
> 但是，如果部分初始化数组，剩余的元素就会被初始化为0
> 如果初始化列表的项数多于数组元素个数，编译器则会将其视为错误

* 同时还可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数
> 类似于: `int days[] = {1,2,3,4};`
> 使用此类方法时要注意以下两点
> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小
> 整个数组的大小除以单个元素的 大小就是数组元素的个数

* 这里写一个程序用作示例:

```
#include <stdio.h>

int main(void)
{
	const int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31 };
	int index;
	for (index = 0; index < sizeof days / sizeof days[0]; index++)
	printf("Month %2 has %d days.\n", index + 1, days[index]);
	return 0;
}
```

* 关于该程序需要注意以下两点:
> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小
> 注意for循环中的测试条件
> 由于人工计算容易出错，所以让计算机来计算数组的大小
> sizeof运算符给出它的运算对象的大小(以字节为单 位)
> 所以sizeof days是整个数组的大小(以字节为单位)，sizeof day[0]是数组中一个元素的大小(以字节为单位)
> 整个数组的大小除以单个元素的大小就是数组元素的个数

* 下面是该程序的输出:

```
Month 1 has 31 days.
Month 2 has 28 days.
Month 3 has 31 days.
Month 4 has 30 days.
Month 5 has 31 days.
Month 6 has 30 days.
Month 7 has 31 days.
Month 8 has 31 days.
Month 9 has 30 days.
Month 10 has 31 days.
```

* 这里1的本意是防止初始化值的个数超过数组的大小，让程序找出数组大小
> 程序中初始化时用了10个值，结果就只打印了10个值
> 这就是自动计数的弊端，即为无法察觉初始化列表中的项数有误

* 还有一种初始化数组的方法，但这种方法仅限于初始化字符数组
> 这里先不做过多赘述

* 所谓的初始化，用一种不是太严谨的方法来描述的话就是给其变量赋值，只不过是第一次对其赋值

---

**关于指定初始化器/C 99:**

* C99 增加了一个新特性: 指定初始化器(designated initializer)
> 利用该特性可以初始化指定的数组元素
> 例如，只初始化数组中的最后一个元素
> 对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素， 才能初始化它:
> `int arr[6] = {0,0,0,0,0,212};	// 传统的语法`
> 而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素:
> `int arr[6] = {[5] = 212};	// 把arr[5]初始化为212`
> 对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0

* 以此程序进行示例说明:

```
#include <stdio.h>
#define MONTHS 12

int main(void)
{
	int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29};
	int i;
	for (i = 0; i < MONTHS; i++)
	printf("%2d %d\n", i + 1, days[i]);
	return 0;
}
```

---

**待补充**

---

* 数组类型前面关于数据类型的文章有所提及
* 关于 C 数组&指针在后面的文章内会进行补充性质的刨析(尤其是针对于指针)

---



