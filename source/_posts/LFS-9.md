---
title: LFS-9
date: 2020-03-01 04:44:43
tags: [随笔,GNU/Linux]
categories: [软件,GNU]
---

## LFS-9

---

### 实现逻辑梳理(LFS-v6.3)

* 主观理解，仅供参考

### 第一阶段

1. 将原主机分区，假设分为两个分区:
> 一个用作swap内存交换分区，另一个用作LFS系统制作分区
2. 创建LFS系统的制作及操作目录
3. 挂载FLS系统所对应的分区目录
4. 在被挂载的分区目录下建立源码存放目录/sources与工具编译目录/tools
5. 利用原主机的root环境来为文件目录分配权限，同时配置目录的符号链接
> 以方便操作与管理
6. 创建用户lfs与用户组lfs(可以同名)
7. 登陆用户并建立lfs用户环境

**建立临时系统**

* 此时将所有的文件都编译进`$LFS/tools`目录内
* 源代码与压缩包存储于`$LFS/sources`目录内

* 构建GNU工具链内工具
1. Binutils Pass-1
2. GCC Pass-1
3. Kernel Headers API
4. Gilbc
> 在Glibc在正确编译且安装完之后:
> 调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内
> 修正GCC的specs文件，使其指向新的动态链接器
> 以此让GCC知道在哪能发现开始文件
5. Binutils Pass-2
6. GCC Pass-2

* 构建其它辅助工具与系统程序

* 编译完成时，临时系统已完整
* 然后利用Strip程序对环境进行清理，info与man也可以进行清理
* 此时可以进入下一阶段

---

### 第二阶段

* 此时的临时系统将作为目标系统的辅助系统以保证存在目的

* 退出lfs用户
> 此时回到原主机的root环境
> 从此开始的编译都由root用户进行
* 此时为了避免安全上的问题
> 将$LFS/tools目录权限转交给root用户
> 可以将tools目录保留，以创建多个相同版本的LFS
---
**首先挂载虚拟内核文件系统**

1. 创建虚拟内核文件系统(或其它设备文件)将要挂载的目录(dev,proc,sys)
2. 创建设备初始节点
3. 挂载并填充/dev目录
4. 最后挂载虚拟文件系统至上面创建的节点之内
> 挂载的同时创建了几个最重要的文件系统
5. 这里也可以将`/lfs-sources/*`内的源码包复制到`$LFS/sources/`内
> 以方便使用

**其它内容:**
* 系统环境逻辑:
> `原主机->临时系统->目标系统`
> `原主机->临时系统`
> `原主机->目标系统`
> `目标系统<-临时系统`

* 这里要重点指出它们的关系并不是线性的
* 主系统包含于临时系统与目标系统
* 进入chroot的目的是让目标系统完全独立
> 但此时的目标系统还带有临时系统所编译的工具环境
> 此时的原主机进入了chroot模式，因此现在不存在原主机的概念
> 原主机即为目标系统，而目标系统内当前还拥有临时系统的环境与功能


---
**进入chroot来进行对LFS系统的操作**

* chroot
* 此时根据指令来进入chroot环境
* 现在所做的任何工作都是为了对已经进入的chroot进行补充
> 以构建最终的LFS系统
> 并且chroot内只能使用到临时系统所构建的工具环境
> 此时所有的工作都被限制在LFS文件系统内
> 所以`Bash shell $LFS`就是现在的根目录`/`

1. 清除所有chroot环境变量
2. 重新设定HOME,TERM,PS1,PATH等变量的值
3. 创建LFS系统的系统目录结构(必须是标准目录树/完全遵守FHS标准)
4. 配置必要的符号链接
> 因为有一些程序使用的固化的路径(hard-wired paths)指向一些还不存在的程序上
> 为了兼容这些程序，可以创建一些符号链接，然后在程序安装之后用实际文件进行替代
5. 然后再去创建root及nobody用户和必要的组 
> 以让root用户可以登陆与用户名root可以被识别
6. 此时因为已经拥有了临时系统内所构建的glibc和刚刚创建的`/etc/passwd`和`/etc/group`文件
> 所以现在用户名和用户组已经处于可用状态了
7. 启动新的shell
8. 设置某些特定程序的log文件，以保证这些程序能够正常写入
9. 最后进入源代码目录下，此时还可以将之前复制到sources下的源代码文件目录设置符号链接

---

### 第三阶段

**建立目标系统**

* 此时将所有的文件都编入当前LFS主机(分区)的/usr/bin目录下

* GNU工具链内工具
1. Linux kernel headers
2. Man-pages
3. Glibc
> 调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内
> 修正GCC的specs文件，使其指向新的动态链接器
> 以此让GCC知道在哪能发现开始文件
4. Binutils
5. GCC

* 构建其它辅助工具与系统程序
> 当目标主机最后一个工具-vim已经编译安装成功之后，开始进行下一阶段

---

### 第四阶段

* 此时应该先对系统做一个备份
> 因为此时操作此系统的人处于任何原因的手残或其它的失误
> 都会导致新操作系统的完全崩坏

1. 然后退出此时的虚拟根环境
2. 接着再次进入虚拟根环境(为了清理系统)
3. 利用Strip来清理系统
4. 清理完成之后退出chroot并重新进入chroot
> 从现在开始，每当重新进入LFS系统的chroot环境时，都不应该需要加入`/tools`参数了
> 因为此时的LFS主机内已经拥有完整的工具环境了
5. 进入chroot环境之后进行下一步配置
> 包括配置启动脚本(boot loader)，设备处理模块，控制台，网络配置脚本，Bash Shell启动文件等等
> 然后为设备创建惯用的符号链接
6. 为了让LFS系统能够启动，还需要配置`/etc/fstab`文件
7. 最后安装Linux内核
8. 当配置完内核之后，安装GRUB并配置GRUB启动菜单
9. 退出chroot
10. 卸载虚拟文件系统
11. 卸载LFS自己的文件系统
12. 此时应该能够保证GRUB引导装载程序已经被设置，并且按照其启动菜单可以自动启动LFS系统

**shutdown -r now**

### 结束

---

* 需要理解的知识点:
1. 工具链的制作与配置和对于配置细节的理解
> 包括静态库与动态库的配置，应用与理解
> 打上该打的补丁(patch)，批处理文件(sed)，链接器与汇编器的使用与配置(as/ld)
2. 链接的过程与程序配置文件的编写
> 在进入下一个阶段时对软链接的使用
3. 从一个系统到达另一个系统的配置环节
> 清理工具(Strip)
> 固化代码

---

### 参考资料

* EN-LFS-v6.3[跳转](http://www.linuxfromscratch.org/lfs/downloads/6.3/)
> `http://www.linuxfromscratch.org/lfs/downloads/6.3/`

* CN-LFS-v6.6(非官方)[跳转](http://www.ha97.com/book/lfs-book-6.6/)
> `http://www.ha97.com/book/lfs-book-6.6/`

---



