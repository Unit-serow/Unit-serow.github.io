---
title: 数据类型-1
date: 2020-03-09 18:23:24
tags: [随笔,C]
categories: [无,concept]
---

<center><strong>数据类型概念理解-1</strong></center>

<!-- more -->

## 计算机科学-数据类型

* 数据类型-1

---

**涉及概念整合列表:**

* 数据类型
* 数据类型-变量
* 数据类型-函数
* 参数传递
* 形参与实参
* 内存
* 堆
* 栈
* 变量 (局部/全局)
* 修饰符
* 数据类型
* 存储类

---

* 数据类型-变量
* 数据类型-存储类
* 数据类型-常量
* 数据类型-函数
* 数据类型-数组
* 数据类型-指针
* 数据类型-结构体
* 数据类型-共用体

---

## 数据类型

**概念简述:**

* 在计算机科学内，任何存在于客观概念与主观概念的现实或抽象世界内的一切概念，都可称为之为数据
* 在计算机内，一切皆为数据，数据即为数字与数理逻辑所构成的任何概念
* 这里所谈论的一切概念，都是基于 C 程序语言内的
* 在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统
* 变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式
* 数据类型的概念即为系统化的将任何存在于程序语言内数据进行准确的/系统化类型划分
* 还可以更直观的将其称为数据类型系统(相对于程序语言)

**类别明细:**

* 数据类型系统内包含于的数据类型可划分位四种类别，分别为:

1. 基本类型
> 被划分为算术类型，包含于两种类型: 整数类型与浮点类型
> 在整数类型内: 各种类型的存储大小与系统的位数和系统的类别有关，但目前通用的以64位为主
> 在浮点类型内: 可将浮点类型分为float-单精度浮点类型，double/long double-双精度浮点类型
> > 后续进行详细介绍

2. 枚举类型
> 被划分为算术类型，被用于定义在程序种只能赋予其一定的离散整数的变量
> 后续进行详细介绍

3. void类型
> 被划分为类型说明符，类型说明符void用于表明没有可用的值

**一般用于以下三种情况:**

1. 函数的返回值为空
> C 中有各种函数都不返回值，或者可以说它们返回空
> 不返回值的函数的返回类型为空
> 例如`void exit (int status);`
2. 函数参数为空
> C 中有各种函数不接受任何参数
> 不带参数的函数可以接受一个 void
> 例如`int rand(void);`
3. 指针指向void
> 类型为`void *`的指针代表对象的地址，而不是类型
> 例如，内存分配函数`void *malloc( size_t size );`
> 返回指向 void 的指针，可以转换为任何数据类型
> 后续进行详细介绍
---
4. 派生类型
包含于: 指针类型，数组类型，结构类型，公用体类型和函数类型
> 后续进行详细介绍

* 关于聚合类型
> 数组类型和结构类型被统称为聚合类型
> 函数的类型指的是函数返回值的类型

* 在 C 程序语言内可以对数据类型进行转换或强制转换操作

---

## 变量

* 文章先进行正文归纳，再进行笔记归纳


### C 变量

**对于涉及概念的系统化整理和解析**

* 变量其实只不过是程序可操作的存储区的名称
* C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局
> 该范围内的值都可以存储在内存中，运算符可应用于变量上

* 基于数据基本类型，有以下几种基本的变量类型:

* C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等

---

* 对于变量的概念，无非就是定义，声明，赋值，以及调用
* 其中声明和定义对于程序员来说是同时进行的，即在声明时就将其定义或不进行定义，只进行声明
* 定义即为为所定义变量分配内存空间

* 定义一个变量，就是告诉编译器在内存的何处创建属于当前被定义变量的存储区域
> 变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表
> 并且定义变量时所指定的数据类型必须是有效的数据类型
> 在不带初始化的定义中，带有静态存储持续时间的变量会被隐式初始化NULL(所有字节的值皆为0)，其它所有变量的初始值是未定义的

* 声明一个变量，变量声明的作用是向编译器保证变量以指定的类型和名称而存在，也可将其称之为专属于该变量的标识符，或变量标识符
> 所以编译器在不需要知道变量完整细节的情况下也能进行进一步的编译
> 对于变量的声明，或称为将变量赋予专属的标识符，只在编译时有它的意义，在程序链接时编译器需要实际的变量声明

* 对于变量声明有两种情况:
1. 需要建立存储空间，例如 `int a`在声明的同时就建立了存储控件
2. 不需要建立存储空间，通过使用extern关键字声明变量而不定义它，例如 `extern int a`其中变量a是可以在别的文件种定义的
> 所以除非有extern关键字，否则都是对变量的定义

**关于 C 的左值(Lvalues)和右值(Rvalues)**

* C 中有两种类型的表达式: 

1. 左值(Lvalue):
> 指向内存位置的表达式被称为左值(lvalue)表达式
> 左值可以出现在赋值号的左边或右边

2. 右值(Rvalue):
> 术语右值(rvalue)指的是存储在内存中某些地址的数值
> 右值是不能对其进行赋值的表达式
> 也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边

**用途总结:**

1. 当需要保存数据的时候，需要lvalues
2. 当需要读取数据的时候，需要rvalues

* lvalues 和 rvalues 角色的相互转换
> 根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为 rvalues
>  rvalues 永远不能转换为 lvalues

---

**变量的全局变量与局部变量的概念简述:**

* 全局变量就是在任何的函数外，整体的程序内所定义的变量，所以将会在整个程序内生效
* 而局部变量就是在函数内所声明的变量，所以只在函数内生效

* 在定义了全局变量后，在函数内调用该变量的方法:
* 为变量加上`extern`关键字即可跳过定义，直接使用:
> `extern int a`

---

**全局变量和局部变量在内存中的区别**

* 全局变量保存在内存的全局存储区中，占用静态的存储单元
* 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元

* C语言经过编译之后将内存分为以下几个区域：
1. 栈(stack): 由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址
> 操作方式类似数据结构中的栈
2. 堆(heap): 用于程序动态申请分配和释放空间
> C语言中的`malloc`和`free`，C++中的`new`和`delete`均是在堆中进行的
> 正常情况下，程序员申请的空间在使用结束后应该释放
> 若程序员没有释放空间，则程序结束时系统自动回收
> 注意: 这里的"堆"并不是数据结构中的"堆"
3. 全局(静态)存储区: 分为DATA段和BSS段
> DATA段(全局初始化区)存放初始化的全局变量和静态变量
> BSS段(全局未初始化区)存放未初始化的全局变量和静态变量
> 程序运行结束时自动释放
> 其中BBS段在程序执行之前会被系统自动清0
> 所以未初始化的全局变量和静态变量在程序执行之前已经为0
4. 文字常量区: 存放常量字符串
> 程序结束后由系统释放
5. 程序代码区: 存放程序的二进制代码。

* 所以C语言中的全局变量和局部变量在内存中是有区别的
* C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中
> 并且占用永久性的存储单元
> 局部变量，即自动变量，保存在栈中
> 只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元

* 可以分析以下程序的运行结果，以便更直观的去了解其区别:
```
#include <stdio.h>
#include <stdlib.h>
int k1 = 1;
int k2;
static int k3 = 2;
static int k4;
int main( )
{  staticint m1=2, m2;
    inti=1;
    char*p;
    charstr[10] = "hello";
    char*q = "hello";
    p= (char *)malloc( 100 );
    free(p);
    printf("栈区-变量地址  i：%p\n", &i);
    printf("                p：%p\n", &p);
    printf("              str：%p\n", str);
    printf("                q：%p\n", &q);
    printf("堆区地址-动态申请：%p\n", p);
    printf("全局外部有初值 k1：%p\n", &k1);
    printf("    外部无初值 k2：%p\n", &k2);
    printf("静态外部有初值 k3：%p\n", &k3);
    printf("    外静无初值 k4：%p\n", &k4);
    printf("  内静态有初值 m1：%p\n", &m1);
    printf("  内静态无初值 m2：%p\n", &m2);
    printf("文字常量地址    ：%p, %s\n",q, q);
    printf("程序区地址      ：%p\n",&main);
    return0;
}
```

---

### C 存储类

* 这里对于存储类的说明只针对于变量
* 存储类定义 C 程序中变量或函数的范围(可见性)和生命周期
> 所谓的声明周期与可见性(范围)就是指定变量在程序或函数内所生效的时间，或将其称之为在内存内所产生存在意义的阶段
* 这些说明符放置在它们所修饰的类型之前
> 例如 `auto int mouth` 

* C 程序中可用的存储类:
> auto
> register
> static
> extern

**C内各存储类明细:**

**auto 存储类**
* auto 存储类是所有局部变量默认的存储类
* auto 只能用在函数内，即 auto 只能修饰局部变量

**register 存储类**

* register 存储类用于定义存储在寄存器中而不是RAM中的局部变量
> 这意味着变量的最大尺寸等于寄存器的大小(通常是一个词)，且不能对它应用一元的`'&'`运算符(因为它没有内存位置)

* 存在意义
> 在寄存器只用于需要快速访问的变量时进行使用，比如计数器
> 还应注意的是，定义`'register'`并不意味着变量将被存储在寄存器中
> 它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制

---

**static 存储类**

* static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁
> 因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值


* static 修饰符也可以应用于全局变量
> 当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内

* 全局声明的一个 static 变量或方法可以被任何函数或方法调用
> 只要这些方法出现在跟 static 变量或方法同一个文件中

* 即在程序内的任何函数内对任何经由此声明的变量，不会在任何此调用时时进行重置

**extern 存储类**

* extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的
* 即为当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置
* 当有多个文件且定义了一个可以在其它文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用
* 可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数
* extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候

---

**存储类整合说明:**

* auto 是局部变量的默认存储类, 限定变量只能在函数内部使用
* register 代表了寄存器变量，不在内存中使用
* static是全局变量的默认存储类,表示变量在程序生命周期内可见
* extern 表示全局变量，即对程序内所有文件可见，类似于Java中的public关键字

---

**C 语言中全局变量，局部变量，静态全局变量，静态局部变量的区别**

**从作用域进行区分:**
1. 全局变量具有全局作用域
> 全局变量只需在一个源文件中定义，就可以作用于所有的源文件
> 当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量

2. 静态局部变量具有局部作用域
> 它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在
> 它和全局变量的区别在于全局变量对所有的函数都是可见的
> 而静态局部变量只对定义自己的函数体始终可见

3. 局部变量也只有局部作用域
> 它是自动对象(auto)
> 它在程序运行期间不是一直存在，而是只在函数执行期间存在
> 函数的一次调用执行结束后，变量被撤销
> 其所占用的内存也被收回

4. 静态全局变量也具有全局作用域
> 它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里
> 不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域
> 这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量

**从分配内存空间来区分**

1. 全局变量，静态局部变量，静态全局变量都在静态存储区分配空间
> 而局部变量在栈里分配空间

2. 全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式
> 这两者在存储方式上并无不同
> 这两者的区别虽在于，非静态全局变量的作用域是整个源程序
> 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的
> 而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效
> 在同一源程序的其它源文件中不能使用它
> 由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用
> 因此可以避免在其它源文件中引起错误

* 静态变量会被放在程序的静态数据存储区(全局可见)中
> 这样可以在下一次调用的时候还可以保持原来的赋值
> 这一点是它与堆栈变量和堆变量的区别

* 变量用static告知编译器，自己仅仅在变量的作用范围内可见
> 这一点是它与全局变量的区别

* 从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期
> 把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围
> 因此static 这个说明符在不同的地方所起的作用是不同的，应予以注意

**其它说明:**

* A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度
* B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度
* C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见
* D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为: 带"内部存储器"功能的的函数)
* E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针

---

* 其它的相关概念与具体的使用在以后实践时会进行相应的补充

* C语言最大的优势是对于底层硬件结构的管理，其指针和其它缺省变量是最接近于内存的

---

### 相关概念

**涉及概念**

* 数据结构
* 堆
* 栈
* 变量 (局部/全局)
* 修饰符
* 数据类型
* 存储类

**未涉及概念**

* 常量
* 运算符
* 判断
* 循环

---

## 补充内容

---

### 变量作用域

**C 作用域规则及其概念**

* 所谓的变量作用域，就是变量所能够产生作用的代码块所属区域
* 任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问

* C 语言中有三个地方可以声明变量:
1. 在函数或块内部的局部变量
2. 在所有函数外部的全局变量
3. 在形式参数的函数参数定义中

* 相关概念: 局部变量，全局变量和形式参数

**局部变量**

* 在某个函数或块的内部声明的变量称为局部变量
> 它们只能被该函数或该代码块内部的语句使用
> 局部变量在函数外部是不可知的

**全局变量**

* 全局变量是定义在函数外部，通常是在程序的顶部
> 全局变量在整个程序生命周期内都是有效的
> 在任意的函数内部能访问全局变量

* 全局变量可以被任何函数访问
> 也就是说，全局变量在声明后整个程序中都是可用的

**形式参数**

* 函数的参数，形式参数，被当作该函数内的局部变量
> 如果与全局变量同名它们会优先使用

* 全局变量与局部变量在内存中的区别：
> 全局变量保存在内存的全局存储区中，占用静态的存储单元
> 局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元

* 通常使用static修饰符/关键字来定义全局/局部变量

**初始化局部/全局变量**

* 在定义全局或局部变量时需要先对其进行初始化
> 初始化局部变量和全局变量
> 当局部变量被定义时，系统不会对其初始化，必须人为/自行的对其初始化
> 定义全局变量时，系统会自动对其初始化
> 初始化即为对其变量进行赋值

**全局变量自动初始化的值如下所示:**

|数据类型|初始化默认值|
|:----|:----|
|int|0|
|char|'\0'|
|float|0|
|double|0|
|pointer|NULL|

* 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果
> 比如因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值

---

### 数据类型-派生类型/函数类型

* 函数的本质是存储结构化语句的数据类型
* 语句可以由变量或其它任何的数据类型构成
* 还可以说，任何的C程序都是由函数数据类型构成的

* 函数是一组一起执行一个任务的语句
> 每个C程序都至少有一个函数，即主函数`main()`
> 所有简单的程序都可以定义其他额外的函数
> 还可以把代码划分到不同的函数中
> 如何划分代码到不同的函数中是由人为所的
> 但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的

* 函数声明告诉编译器函数的名称，返回类型和参数
> 函数定义提供了函数的实际主体

* C 标准库提供了大量的程序可以调用的内置函数
> 例如，函数`strcat()`用来连接两个字符串，函数`memcpy()`用来复制内存到另一个位置

* 函数还有很多叫法，比如方法，子例程或程序，等等

**定义函数的基本语法-C:**

```
return_type function_name( parameter list )
{
   body of the function
}
```

**参数说明:**

* 在 C 语言中，函数由一个函数头和一个函数主体组成
> 下面列出一个函数的所有组成部分:

1. 返回类型: 一个函数可以返回一个值
> `return_type`是函数返回的值的数据类型
> 有些函数执行所需的操作而不返回值
> 在这种情况下，`return_type`是关键字`void`
2. 函数名称: 这是函数的实际名称
> 函数名和参数列表一起构成了函数签名
3. 参数: 参数就像是占位符
> 当函数被调用时，您向参数传递一个值，这个值被称为实际参数
> 参数列表包括函数参数的类型，顺序，数量
> 参数是可选的，也就是说，函数可能不包含参数
4. 函数主体: 函数主体包含一组定义函数执行任务的语句

---

**函数声明**

* 函数声明会告诉编译器函数名称及如何调用函数
> 函数的实际主体可以单独定义

* 函数声明包括以下几个部分：
> `return_type function_name( parameter list );`

* 在函数声明中，参数的名称并不重要，只有参数的类型是必需的

* 在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的
> 在这种情况下，您应该在调用函数的文件顶部声明函数

---

**调用函数**

* 创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务

* 当程序调用函数时，程序控制权会转移给被调用的函数
> 被调用的函数执行已定义的任务，当函数的返回语句被执行时
> 或到达函数的结束括号时，会把程序控制权交还给主程序

* 调用函数时，传递所需参数
> 如果函数返回一个值，则可以存储返回值

---

**函数参数**

* 如果函数要使用参数，则必须声明接受参数值的变量
> 这些变量称为函数的形式参数

* 形式参数就像函数内的其他局部变量
> 在进入函数时被创建，退出函数时被销毁

* 当调用函数时，有两种向函数传递参数的方式：

1. 传值调用: 该方法把参数的实际值复制给函数的形式参数
> 在这种情况下，修改函数内的形式参数不会影响实际参数
2. 引用调用: 通过指针传递方式，形参为指向实参地址的指针
> 当对形参的指向操作时，就相当于对实参本身进行的操作

* 默认情况下，C 使用传值调用来传递参数
> 一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数

---

**内部函数与外部函数**

* 根据函数能否被其他源文件调用，可以将函数区分为内部函数和外部函数

**内部函数**

* 如果一个函数只能被本文件中其他函数所调用，它称为内部函数
> 在定义内部函数时，在函数名和函数类型的前面加 static，即
> `static 类型名 函数名 (形参表)`
> 例如，函数的首行：
`static int max(int a,int b)`

* 内部函数又称静态函数
> 使用内部函数，可以使函数的作用域只局限于所在文件
> 即使在不同的文件中有同名的内部函数，也互不干扰
> 提高了程序的可靠性

**外部函数**

> 如果在定义函数时，在函数的首部的最左端加关键字 extern
> 则此函数是外部函数，可供其它文件调用
> 如函数首部可以为
> `extern int max (int a,int b)`
> C 语言规定，如果在定义函数时省略 extern，则默认为外部函数

* 在需要调用此函数的其他文件中，需要对此函数作声明(即使在本文件中调用一个函数，也要用函数原型来声明)
> 在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数 

---

**内联函数**

* 内联函数是指用inline关键字修饰的函数
> 在类内定义的函数被默认成内联函数
> 内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质

* 内联扩展是用来消除函数调用时的时间开销
> 它通常用于频繁执行的函数，对于小内存空间的函数非常受益

* 使用内联函数的时候要注意:
> 递归函数不能定义为内联函数
> 内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数
> 内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数
> 对内联函数不能进行异常的接口声明

---

### 形参与实参

* 形参与实参出现在函数中

* 形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用
* 实参出现在主调函数中，进入被调函数后，实参变量也不能使用 

**关于调用:**

* 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元
> 因此，形参只在函数内部有效
函数调用结束返回主调用函数后则不能再使用该形参变量

* 实参可以是常量，变量，表达式，函数等
> 无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参
> 因此应预先用赋值，输入等办法使参数获得确定值

**指针影响:**

* 不是指针类型在内存中位置不同:
* 当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量
> 它们在内存中位于不同的位置，形参将实参的内容复制一份
> 在该函数运行结束的时候形参被释放，而实参内容不会改变


**形式参数**

* 形式参数即为只是作为某种形式而存在于程序种的参数
> 此类参数即为未进行赋值或者使用的参数

**实际参数**

* 实际参数即为已经对其赋值或已经进行使用的参数

* 从字面上理解，所谓形式参数即只只是声明了一个作为参数的变量，并未直接进行赋值使用，而实际参数则相反

* 关于C语言形参与实参的区别:
> 实参可以是变量，变量与表达式，实参与形参
> 实参与形参类型相同或赋值兼容
> 在调用函数过程中发生的实参与形参之间的数据传递，常称为"虚实结合"

1. 在定义函数中制定的形参，在没有出现函数调用时不占用内存中的存储单元
> 在函数调用时才分配内存
2. 将实参的值传递给形参
3. 在执行函数时，由于形参已经有值
> 可以用形参进行运算
4. 通过return语句将函数值返回，若无返回值，则无return
5. 调用结束后，形参被释放掉，实参保留原值(单向传值)

---

* 可能还需要对其进行大量的补充，实践时会进行说明

---

* 数据类型-派生类型/数组
* 数据类型-派生类型/指针
* 数据类型-派生类型/结构体类型
* 数据类型-派生类型/共用体类型
* 数据类型-派生类型/函数类型

---



