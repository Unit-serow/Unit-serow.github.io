<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-01T14:42:36.136Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GNU-LFS-3-3</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-3/</id>
    <published>2020-03-01T14:10:58.000Z</published>
    <updated>2020-03-01T14:42:36.136Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 22:42:43 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-3-3"><a href="#GNU-LFS-3-3" class="headerlink" title="GNU-LFS-3-3"></a>GNU-LFS-3-3</h2><ul><li>系统转换过程与细节描述</li></ul><hr><p><strong>文案说明:</strong></p><ul><li>本篇文案用于描述目标系统环境的最基本配置与对从临时系统进入到目标系统的各种细节的描述</li><li>参考文献及版本为LFS-v6.2/v6.3</li><li>描述主体为LFS-v6.3，LFS-v6.2会有特别标注</li><li>LFS-v6.2和LFS-v6.3的内容与执行语句通常没有本质上的区别<blockquote><p>多数都只是执行顺序或者深层的处理逻辑不同<br>但大体非常相似</p></blockquote></li><li>多数指令在目标主机的chroot环境下进行</li></ul><p><strong>目录简述:</strong></p><ul><li>系统清理</li><li>虚拟文件系统</li><li>chroot环境</li><li>标准文件系统(FHS标准)</li><li>用户与用户组的基本配置</li><li>参考资料</li></ul><hr><h3 id="系统清理"><a href="#系统清理" class="headerlink" title="系统清理"></a>系统清理</h3><p><strong>临时主机的系统清理</strong></p><ul><li><p>删除已经安装的可执行程序和库文件当中的调试符号，以节约空间(大约70 MB)</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code><br><code>$ strip --strip-unneeded /tools/{,s}bin/*</code></p></blockquote></li><li><p>命令会跳过大约20个文件，报告不能识别这些文件格式</p><blockquote><p>其中大多数是脚本而不是二进制文件</p></blockquote></li><li><p>这里需要注意的一点是千万不要在库文件上使用<code>--strip-unneeded</code>，否则会破坏其静态版本</p><blockquote><p>如果已经是过去时了的话，就得从头开始编译全部的工具链软件包了</p></blockquote></li><li><p>删除相关文档文件(info，man)，会节约20 MB</p><blockquote><p><code>$ rm -rf /tools/{info,man}</code></p></blockquote></li></ul><hr><ul><li><p>到目前为止，临时工具链已制作完毕</p></li><li><p>这一阶段开始进入目标主机环境</p></li><li><p>从现在开始不需要lfs用户来制作系统了</p></li><li><p>退出lfs用户</p><blockquote><p><code>$ exit</code></p></blockquote></li><li><p>此时为root用户环境，改变必要文件的权限与所有者</p></li><li><p>一部分的原因是为了避免不必要的安全方面所产生的问题</p></li><li><p>将$LFS/tools目录以及其中文件的所有者改为root用户</p><blockquote><p><code>$ chown -R root:root $LFS/tools</code></p></blockquote></li><li><p>这里说明一下:</p><blockquote><p>建立LFS系统的时候，在创建<code>/etc/passwd</code>文件时<br>添加的user ID和group ID是与宿主系统的user ID和group ID相同的lfs用户</p></blockquote></li></ul><hr><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p><strong>挂载虚拟文件系统</strong></p><ul><li><p>为虚拟内核文件系统建立挂载目录(dev,proc,sys)</p><blockquote><p><code>$ mkdir -pv $LFS/{dev,proc,sys}</code></p></blockquote></li><li><p>创建初始设备节点(创建两个目标系统所必须的设备文件)</p><blockquote><p><code>$ mknod -m 600 $LFS/dev/console c 5 1</code><br><code>$ mknod -m 666 $LFS/dev/null c 1 3</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>内核在引导时要求某些设备节点必须存在(特别是console和null)<br>这些设备节点必须创建在 硬盘上才能使得内核在udev尚未启动之前就可以使用它们<br>此外还有当Linux以<code>init=/bin/bash</code>启动</p></blockquote></li><li><p>挂载并填充/dev目录(LFS-v6.2)</p><blockquote><p><code>$ mount --bind /dev $LFS/dev</code></p></blockquote></li><li><p>具体说明:</p><blockquote><p>LFS-v6.2推荐的向<code>/dev</code>目录填充设备的方法是在<code>/dev</code>上挂载一个虚拟文件系统(比如 tmpfs)<br>然后在设备被检测到或被访问到的时候(通常是在系统引导的过程中)动态创建设备节点<br>既然现在新的系统尚未被引导，那么就有必要通过手工挂载和填充<code>/dev</code>目录<br>这可以通过绑定挂载宿主系统的<code>/dev</code>目录<br>绑定挂载是一种特殊的挂载方式，允许本地主机上的当前用户创建一个目录或者是挂载点的镜像到其他的地方</p></blockquote></li><li><p>挂载虚拟内核文件系统</p><blockquote><p><code>$ mount -v --bind /dev $LFS/dev</code><br><code>$ mount -vt devpts devpts $LFS/dev/pts</code><br><code>$ mount -vt tmpfs shm $LFS/dev/shm</code><br><code>$ mount -vt proc proc $LFS/proc</code><br><code>$ mount -vt sysfs sysfs $LFS/sys</code></p></blockquote></li></ul><hr><ul><li>在进入chroot环境之前，可以将<code>lfs-sources/</code>里面所有源码包复制到<code>$LFS/sources/</code>目录中</li><li>这么做会让后面在构建目标系统的时候使用源代码变得更方便<blockquote><p><code>$ cp -a /lfs-sources/* $LFS/sources/</code></p></blockquote></li></ul><hr><h3 id="chroot环境"><a href="#chroot环境" class="headerlink" title="chroot环境"></a>chroot环境</h3><p><strong>进入chroot环境</strong></p><ul><li>Chroot到目标系统的目录下，以便不受主系统的影响来制作目标系统</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ chroot <span class="string">"$LFS"</span> <span class="regexp">/tools/</span>bin/env -i \ </span><br><span class="line">HOME=/root TERM=<span class="string">"$TERM"</span> PS1=<span class="string">'\u:\w\$ '</span> \ </span><br><span class="line">PATH=<span class="regexp">/bin:/</span>usr<span class="regexp">/bin:/</span><span class="string">sbin:</span><span class="regexp">/usr/</span><span class="string">sbin:</span><span class="regexp">/tools/</span>bin \ </span><br><span class="line"><span class="regexp">/tools/</span>bin/bash --login +h</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li><code>env</code>命令的<code>参数-i</code>的作用是清除所有chroot环境变量<blockquote><p>后面是重新设定HOME,TERM,PS1, PATH等变量的值</p></blockquote></li><li><code>TERM=$TERM</code>设定虚拟根环境中的TERM的值与chroot外面的一样<blockquote><p>这个值是让像vim和less之类的程序可以正确操作<br>如果还需要重新设置其它的值，如CFLAGS或CXXFLAGS，这里是个不错的位置</p></blockquote></li></ul><hr><ul><li><p>从这里开始，不再需要LFS环境变量了，因为所有的工作都被限制在LFS文件系统里面</p><blockquote><p>这是由于已经告诉了Bash shell $LFS 是现在的根目录(<code>/</code>)<br>注意，这里<code>/tools/bin</code>位于PATH的最后面<br>也就是说当软件包的最终版本安装之后就不再使用临时工具了<br>为了使shell无法记住可执行二进制代码的位置，需要通过使用<code>+h参数</code>关闭bash的散列功能</p></blockquote></li><li><p>此时bash提示符会显示: <code>I have no name!</code>这是正常的，因为<code>/etc/passwd</code>还没有创建</p></li></ul><hr><h3 id="标准文件系统"><a href="#标准文件系统" class="headerlink" title="标准文件系统"></a>标准文件系统</h3><p><strong>创建符合FHS标准的Unix文件系统</strong></p><p><strong>创建系统目录结构(FHS标准目录树):</strong></p><blockquote><p><code>$ mkdir -pv /{bin,boot,etc/opt,home,lib,mnt,opt}</code><br><code>$ mkdir -pv /{media/{floppy,cdrom},sbin,srv,var}</code><br><code>$ install -dv -m 0750 /root</code><br><code>$ install -dv -m 1777 /tmp /var/tmp</code><br><code>$ mkdir -pv /usr/{,local/}{bin,include,lib,sbin,src}</code><br><code>$ mkdir -pv /usr/{,local/}share/{doc,info,locale,man}</code><br><code>$ mkdir -pv /usr/{,local/}share/{misc,terminfo,zoneinfo}</code><br><code>$ mkdir -pv /usr/{,local/}share/man/man{1..8}</code></p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">for</span> <span class="keyword">dir</span> <span class="keyword">in</span> /usr /usr/<span class="keyword">local</span>; <span class="keyword">do</span></span><br><span class="line">ln -sv share/&#123;<span class="keyword">man</span>,doc,info&#125; <span class="variable">$dir</span></span><br><span class="line">done</span><br></pre></td></tr></table></figure><blockquote><p><code>$ mkdir -pv /var/{lock,log,mail,run,spool}</code><br><code>$ mkdir -pv /var/{opt,cache,lib/{misc,locate},local}</code></p></blockquote><hr><p><strong>创建必需的文件与符号连接</strong></p><ul><li>一些程序使用固化的路径(<code>hard-wired paths</code>)指向一些目前还不存在的程序上</li><li>为了兼容这些程序，可以创建一些符号链接</li><li>然后在软件安装之后用实际文件进行替代</li></ul><p><strong>创建必要的符号链接:</strong></p><blockquote><p><code>$ ln -sv /tools/bin/{bash,cat,echo,grep,pwd,stty} /bin</code><br><code>$ ln -sv /tools/bin/perl /usr/bin</code><br><code>$ ln -sv /tools/lib/libgcc_s.so{,.1} /usr/lib</code><br><code>$ ln -sv /tools/lib/libstdc++.so{,.6} /usr/lib</code><br><code>$ ln -sv bash /bin/sh</code><br><code>$ touch /etc/mtab</code></p></blockquote><hr><h3 id="用户与用户组的基本配置"><a href="#用户与用户组的基本配置" class="headerlink" title="用户与用户组的基本配置"></a>用户与用户组的基本配置</h3><p><strong>配置必要的用户组</strong></p><ul><li><p>以下区块为LFS-v6.2独有</p></li><li><p>一个常规的Linux系统在<code>/etc/mtab</code>中有一个已挂载文件系统的列表正常情况下</p></li><li><p>这个文件 在我们挂载一个新的文件系统的时候会被创建</p></li><li><p>因为从此开始在chroot环境下不会再挂载任何文件系统</p></li><li><p>所以需要人为的为那些用到<code>/etc/mtab</code>的程序创建一个空文件</p><blockquote><p><code>$ touch /etc/mtab</code></p></blockquote></li><li><p>为了让<code>root用户</code>可以登录而且<code>用户名root</code>可以被识别</p></li><li><p>在这里需要创建相应的<code>/etc/passwd</code>和<code>/etc/group</code>文件</p></li></ul><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>cat &gt; <span class="regexp">/etc/passwd</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="symbol">root:</span><span class="symbol">x:</span>0<span class="symbol">:</span>0<span class="symbol">:root</span><span class="symbol">:/root</span><span class="symbol">:/bin/bash</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>此时root的真正密码将在后面设置(<code>&quot;x&quot;</code>在这里只是一个占位符)</li></ul><hr><ul><li>使用以下命令创建/etc/group文件(LFS-v6.2):</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ul><li>在LFS-v6.2这里创建的用户组并不是某个标准所要求的部分<blockquote><p>只是因为在随后<code>Udev配置</code>将要用到而以</p></blockquote></li></ul><hr><p><strong>创建<code>root</code>及<code>nobody用户</code>和必要的组(LFS-v6.3):</strong></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>passwd &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>:<span class="number">0</span>:<span class="string">root:</span><span class="regexp">/root:/</span>bin/bash </span><br><span class="line"><span class="string">nobody:</span><span class="string">x:</span><span class="number">99</span>:<span class="number">99</span>:Unprivileged <span class="string">User:</span><span class="regexp">/dev/</span><span class="string">null:</span><span class="regexp">/bin/</span><span class="literal">false</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; <span class="regexp">/etc/</span>group &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="string">root:</span><span class="string">x:</span><span class="number">0</span>: </span><br><span class="line"><span class="string">bin:</span><span class="string">x:</span><span class="number">1</span>: </span><br><span class="line"><span class="string">sys:</span><span class="string">x:</span><span class="number">2</span>: </span><br><span class="line"><span class="string">kmem:</span><span class="string">x:</span><span class="number">3</span>: </span><br><span class="line"><span class="string">tty:</span><span class="string">x:</span><span class="number">4</span>: </span><br><span class="line"><span class="string">tape:</span><span class="string">x:</span><span class="number">5</span>: </span><br><span class="line"><span class="string">daemon:</span><span class="string">x:</span><span class="number">6</span>: </span><br><span class="line"><span class="string">floppy:</span><span class="string">x:</span><span class="number">7</span>:</span><br><span class="line"><span class="string">disk:</span><span class="string">x:</span><span class="number">8</span>: </span><br><span class="line"><span class="string">lp:</span><span class="string">x:</span><span class="number">9</span>: </span><br><span class="line"><span class="string">dialout:</span><span class="string">x:</span><span class="number">10</span>: </span><br><span class="line"><span class="string">audio:</span><span class="string">x:</span><span class="number">11</span>: </span><br><span class="line"><span class="string">video:</span><span class="string">x:</span><span class="number">12</span>: </span><br><span class="line"><span class="string">utmp:</span><span class="string">x:</span><span class="number">13</span>: </span><br><span class="line"><span class="string">usb:</span><span class="string">x:</span><span class="number">14</span>: </span><br><span class="line"><span class="string">cdrom:</span><span class="string">x:</span><span class="number">15</span>: </span><br><span class="line"><span class="string">mail:</span><span class="string">x:</span><span class="number">34</span>: </span><br><span class="line"><span class="string">nogroup:</span><span class="string">x:</span><span class="number">99</span>: </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><hr><ul><li><p>因为完整的Glibc在目标系统中已经安装</p></li><li><p>而且<code>/etc/passwd</code>和<code>/etc/group</code>文件也已创建</p></li><li><p>所以用户名和组名现在可以开始使用了</p></li><li><p>重新加载bash，以使root用户起效</p><blockquote><p><code>$ exec /tools/bin/bash --login +h</code></p></blockquote></li><li><p>参数说明:</p><blockquote><p><code>参数+h</code>用于告诉bash不能使用其内部哈希表查找路径</p></blockquote></li></ul><hr><ul><li>程序 login, agetty, init(还有其它一些程序)使用一些日志文件来记录信息</li><li>比如谁在什么时候登录了系统等等</li><li>然而如果这些日志文件不存在，这些程序则无法写入</li><li>下面初始化这些日志文件，并设置适当的权限:</li></ul><blockquote><p><code>$ touch /var/run/utmp /var/log/{btmp,lastlog,wtmp}</code><br><code>$ chgrp -v utmp /var/run/utmp /var/log/lastlog</code><br><code>$ chmod -v 664 /var/run/utmp /var/log/lastlog</code></p></blockquote><ul><li>目录作用明细:<blockquote><p><code>/var/run/utmp</code>记录着现在登录的用户<br><code>/var/log/wtmp</code>记录所有的登录和退出<br><code>/var/log/lastlog</code>记录每个用户最后的登录信息<br><code>/var/log/btmp</code>记录错误的登录尝试</p></blockquote></li></ul><hr><ul><li>此时就已经完成了对目标主机的基础配置</li><li>同时已经进入目标主机的标准环境了</li><li>一下步即开始对目录主机进行程序编译与配置</li><li>进入源代码目录与设置LFS变量<blockquote><p><code>$ cd /sources</code><br><code>$ export LFS=/sources</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>官方-EN-LFS-v6.2</li><li>官方-EN-LFS-v6.3</li><li>金步国-CN-LFS-v6.2</li><li>孙海勇-CN-LFS-v6.3</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 22:42:43 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-3-3&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-3&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-9</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-9/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-9/</id>
    <published>2020-02-29T20:44:43.000Z</published>
    <updated>2020-02-29T20:45:36.448Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 04:45:43 GMT+0800 (中国标准时间) --><h2 id="LFS-9"><a href="#LFS-9" class="headerlink" title="LFS-9"></a>LFS-9</h2><hr><h3 id="实现逻辑梳理-LFS-v6-3"><a href="#实现逻辑梳理-LFS-v6-3" class="headerlink" title="实现逻辑梳理(LFS-v6.3)"></a>实现逻辑梳理(LFS-v6.3)</h3><ul><li>主观理解，仅供参考</li></ul><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><ol><li>将原主机分区，假设分为两个分区:<blockquote><p>一个用作swap内存交换分区，另一个用作LFS系统制作分区</p></blockquote></li><li>创建LFS系统的制作及操作目录</li><li>挂载FLS系统所对应的分区目录</li><li>在被挂载的分区目录下建立源码存放目录/sources与工具编译目录/tools</li><li>利用原主机的root环境来为文件目录分配权限，同时配置目录的符号链接<blockquote><p>以方便操作与管理</p></blockquote></li><li>创建用户lfs与用户组lfs(可以同名)</li><li>登陆用户并建立lfs用户环境</li></ol><p><strong>建立临时系统</strong></p><ul><li><p>此时将所有的文件都编译进<code>$LFS/tools</code>目录内</p></li><li><p>源代码与压缩包存储于<code>$LFS/sources</code>目录内</p></li><li><p>构建GNU工具链内工具</p></li></ul><ol><li>Binutils Pass-1</li><li>GCC Pass-1</li><li>Kernel Headers API</li><li>Gilbc<blockquote><p>在Glibc在正确编译且安装完之后:<br>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils Pass-2</li><li>GCC Pass-2</li></ol><ul><li><p>构建其它辅助工具与系统程序</p></li><li><p>编译完成时，临时系统已完整</p></li><li><p>然后利用Strip程序对环境进行清理，info与man也可以进行清理</p></li><li><p>此时可以进入下一阶段</p></li></ul><hr><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><ul><li><p>此时的临时系统将作为目标系统的辅助系统以保证存在目的</p></li><li><p>退出lfs用户</p><blockquote><p>此时回到原主机的root环境<br>从此开始的编译都由root用户进行</p></blockquote></li><li><p>此时为了避免安全上的问题</p><blockquote><p>将$LFS/tools目录权限转交给root用户<br>可以将tools目录保留，以创建多个相同版本的LFS</p></blockquote></li></ul><hr><p><strong>首先挂载虚拟内核文件系统</strong></p><ol><li>创建虚拟内核文件系统(或其它设备文件)将要挂载的目录(dev,proc,sys)</li><li>创建设备初始节点</li><li>挂载并填充/dev目录</li><li>最后挂载虚拟文件系统至上面创建的节点之内<blockquote><p>挂载的同时创建了几个最重要的文件系统</p></blockquote></li><li>这里也可以将<code>/lfs-sources/*</code>内的源码包复制到<code>$LFS/sources/</code>内<blockquote><p>以方便使用</p></blockquote></li></ol><p><strong>其它内容:</strong></p><ul><li><p>系统环境逻辑:</p><blockquote><p><code>原主机-&gt;临时系统-&gt;目标系统</code><br><code>原主机-&gt;临时系统</code><br><code>原主机-&gt;目标系统</code><br><code>目标系统&lt;-临时系统</code></p></blockquote></li><li><p>这里要重点指出它们的关系并不是线性的</p></li><li><p>主系统包含于临时系统与目标系统</p></li><li><p>进入chroot的目的是让目标系统完全独立</p><blockquote><p>但此时的目标系统还带有临时系统所编译的工具环境<br>此时的原主机进入了chroot模式，因此现在不存在原主机的概念<br>原主机即为目标系统，而目标系统内当前还拥有临时系统的环境与功能</p></blockquote></li></ul><hr><p><strong>进入chroot来进行对LFS系统的操作</strong></p><ul><li>chroot</li><li>此时根据指令来进入chroot环境</li><li>现在所做的任何工作都是为了对已经进入的chroot进行补充<blockquote><p>以构建最终的LFS系统<br>并且chroot内只能使用到临时系统所构建的工具环境<br>此时所有的工作都被限制在LFS文件系统内<br>所以<code>Bash shell $LFS</code>就是现在的根目录<code>/</code></p></blockquote></li></ul><ol><li>清除所有chroot环境变量</li><li>重新设定HOME,TERM,PS1,PATH等变量的值</li><li>创建LFS系统的系统目录结构(必须是标准目录树/完全遵守FHS标准)</li><li>配置必要的符号链接<blockquote><p>因为有一些程序使用的固化的路径(hard-wired paths)指向一些还不存在的程序上<br>为了兼容这些程序，可以创建一些符号链接，然后在程序安装之后用实际文件进行替代</p></blockquote></li><li>然后再去创建root及nobody用户和必要的组<blockquote><p>以让root用户可以登陆与用户名root可以被识别</p></blockquote></li><li>此时因为已经拥有了临时系统内所构建的glibc和刚刚创建的<code>/etc/passwd</code>和<code>/etc/group</code>文件<blockquote><p>所以现在用户名和用户组已经处于可用状态了</p></blockquote></li><li>启动新的shell</li><li>设置某些特定程序的log文件，以保证这些程序能够正常写入</li><li>最后进入源代码目录下，此时还可以将之前复制到sources下的源代码文件目录设置符号链接</li></ol><hr><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p><strong>建立目标系统</strong></p><ul><li><p>此时将所有的文件都编入当前LFS主机(分区)的/usr/bin目录下</p></li><li><p>GNU工具链内工具</p></li></ul><ol><li>Linux kernel headers</li><li>Man-pages</li><li>Glibc<blockquote><p>调整工具链，以此让以后所有的被编译与安装的工具都链接到C标准库内<br>修正GCC的specs文件，使其指向新的动态链接器<br>以此让GCC知道在哪能发现开始文件</p></blockquote></li><li>Binutils</li><li>GCC</li></ol><ul><li>构建其它辅助工具与系统程序<blockquote><p>当目标主机最后一个工具-vim已经编译安装成功之后，开始进行下一阶段</p></blockquote></li></ul><hr><h3 id="第四阶段"><a href="#第四阶段" class="headerlink" title="第四阶段"></a>第四阶段</h3><ul><li>此时应该先对系统做一个备份<blockquote><p>因为此时操作此系统的人处于任何原因的手残或其它的失误<br>都会导致新操作系统的完全崩坏</p></blockquote></li></ul><ol><li>然后退出此时的虚拟根环境</li><li>接着再次进入虚拟根环境(为了清理系统)</li><li>利用Strip来清理系统</li><li>清理完成之后退出chroot并重新进入chroot<blockquote><p>从现在开始，每当重新进入LFS系统的chroot环境时，都不应该需要加入<code>/tools</code>参数了<br>因为此时的LFS主机内已经拥有完整的工具环境了</p></blockquote></li><li>进入chroot环境之后进行下一步配置<blockquote><p>包括配置启动脚本(boot loader)，设备处理模块，控制台，网络配置脚本，Bash Shell启动文件等等<br>然后为设备创建惯用的符号链接</p></blockquote></li><li>为了让LFS系统能够启动，还需要配置<code>/etc/fstab</code>文件</li><li>最后安装Linux内核</li><li>当配置完内核之后，安装GRUB并配置GRUB启动菜单</li><li>退出chroot</li><li>卸载虚拟文件系统</li><li>卸载LFS自己的文件系统</li><li>此时应该能够保证GRUB引导装载程序已经被设置，并且按照其启动菜单可以自动启动LFS系统</li></ol><p><strong>shutdown -r now</strong></p><h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><hr><ul><li>需要理解的知识点:</li></ul><ol><li>工具链的制作与配置和对于配置细节的理解<blockquote><p>包括静态库与动态库的配置，应用与理解<br>打上该打的补丁(patch)，批处理文件(sed)，链接器与汇编器的使用与配置(as/ld)</p></blockquote></li><li>链接的过程与程序配置文件的编写<blockquote><p>在进入下一个阶段时对软链接的使用</p></blockquote></li><li>从一个系统到达另一个系统的配置环节<blockquote><p>清理工具(Strip)<br>固化代码</p></blockquote></li></ol><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-LFS-v6.6(非官方)<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 04:45:43 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-9&quot;&gt;&lt;a href=&quot;#LFS-9&quot; class=&quot;headerlink&quot; title=&quot;LFS-9&quot;&gt;&lt;/a&gt;LFS-9&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-8</title>
    <link href="https://unit-serow.github.io/2020/03/01/LFS-8/"/>
    <id>https://unit-serow.github.io/2020/03/01/LFS-8/</id>
    <published>2020-02-29T20:40:11.000Z</published>
    <updated>2020-02-29T20:44:36.228Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 04:45:43 GMT+0800 (中国标准时间) --><h2 id="LFS-8"><a href="#LFS-8" class="headerlink" title="LFS-8"></a>LFS-8</h2><hr><h3 id="LFS-v6-3基本程序一览"><a href="#LFS-v6-3基本程序一览" class="headerlink" title="LFS-v6.3基本程序一览"></a>LFS-v6.3基本程序一览</h3><ul><li>LFS-v6.3内软件目录(包含版本与章节)</li><li>不包含[GNU 工具链]内程序</li></ul><p><strong>参考资料:</strong></p><ul><li><p>EN-LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/downloads/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/6.3/</code></p></blockquote></li><li><p>CN-6.6非官方<a href="http://www.ha97.com/book/lfs-book-6.6/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ha97.com/book/lfs-book-6.6/</code></p></blockquote></li></ul><hr><p><strong>临时主机程序目录</strong></p><p>5.13. Ncurses-5.6<br>5.14. Bash-3.2<br>5.15. Bzip2-1.0.4<br>5.16. Coreutils-6.9<br>5.17. Diffutils-2.8.1<br>5.18. Findutils-4.2.31<br>5.19. Gawk-3.1.5<br>5.20. Gettext-0.16.1<br>5.21. Grep-2.5.1a<br>5.22. Gzip-1.3.12<br>5.23. Make-3.81<br>5.24. Patch-2.5.4<br>5.25. Perl-5.8.8<br>5.26. Sed-4.1.5<br>5.27. Tar-1.18<br>5.28. Texinfo-4.9<br>5.29. Util-linux-2.12r</p><hr><p><strong>目标主机程序目录</strong></p><p>6.13. Berkeley DB-4.5.20<br>6.14. Sed-4.1.5<br>6.15. E2fsprogs-1.40.2<br>6.16. Coreutils-6.9<br>6.17. Iana-Etc-2.20<br>6.18. M4-1.4.10<br>6.19. Bison-2.3<br>6.20. Ncurses-5.6<br>6.21. Procps-3.2.7<br>6.22. Libtool-1.5.24<br>6.23. Perl-5.8.8<br>6.24. Readline-5.2<br>6.25. Zlib-1.2.3<br>6.26. Autoconf-2.61<br>6.27. Automake-1.10<br>6.28. Bash-3.2<br>6.29. Bzip2-1.0.4<br>6.30. Diffutils-2.8.1<br>6.31. File-4.21<br>6.32. Findutils-4.2.31<br>6.33. Flex-2.5.33<br>6.34. GRUB-0.97<br>6.35. Gawk-3.1.5<br>6.36. Gettext-0.16.1<br>6.37. Grep-2.5.1a<br>6.38. Groff-1.18.1.4<br>6.39. Gzip-1.3.12<br>6.40. Inetutils-1.5<br>6.41. IPRoute2-2.6.20-070313<br>6.42. Kbd-1.12<br>6.43. Less-406<br>6.44. Make-3.81<br>6.45. Man-DB-2.4.4<br>6.46. Mktemp-1.5<br>6.47. Module-Init-Tools-3.2.2<br>6.48. Patch-2.5.4<br>6.49. Psmisc-22.5<br>6.50. Shadow-4.0.18.1<br>6.51. Sysklogd-1.4.1<br>6.52. Sysvinit-2.86<br>6.53. Tar-1.18<br>6.54. Texinfo-4.9<br>6.55. Udev-113<br>6.56. Util-linux-2.12r<br>6.57. Vim-7.1</p><hr><p><strong>最终阶段程序</strong></p><p>7.2. LFS-Bootscripts-6.3<br>Linux-2.6.22.5</p><hr><h2 id="相关指令参考"><a href="#相关指令参考" class="headerlink" title="相关指令参考"></a>相关指令参考</h2><ul><li>patch</li><li>sed</li><li>ld</li><li>strip</li></ul><hr><h3 id="patch命令"><a href="#patch命令" class="headerlink" title="patch命令"></a>patch命令</h3><ul><li><p>Linux patch命令用于修补文件(为文件打上补丁)</p><blockquote><p>patch指令让用户利用设置修补文件的方式，修改，更新原始文件<br>倘若一次仅修改一个文件，可直接在指令列中下达指令依序执行<br>如果配合修补文件的方式则能一次修补大批文件<br>这也是Linux系统核心的升级方法之一</p></blockquote></li><li><p>语法:</p><blockquote><p><code>patch [参数] [选项] [原始文件 &lt;修补文件&gt;] 或 path [-p &lt;剥离层级&gt;] &lt; [修补文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-patch.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-patch.html</a></p></blockquote></li><li><p>实例:</p></li><li><p><code>$ patch -Np1 i ../expect-5.43.0-spawn-1.patch</code></p><blockquote><p>将<code>expect</code>工具打上补丁<code>expect-5.43.0-spawn-1.patch</code></p></blockquote></li></ul><hr><h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><ul><li><p>Linux sed 命令的作用是利用脚本来处理文本文件</p></li><li><p>sed可依照脚本的指令来处理，编辑文本文件</p></li><li><p>sed主要用来自动编辑一个或多个文件，简化对文件的反复操作，编写转换程序等</p></li><li><p>命令语法:</p><blockquote><p><code>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</code><br>具体参考: <a href="https://www.runoob.com/linux/linux-comm-sed.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-sed.html</a></p></blockquote></li><li><p>实例:</p></li><li><p>利用sed命令来确保在非bootstrap编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="ld命令"><a href="#ld命令" class="headerlink" title="ld命令"></a>ld命令</h3><ul><li><p>ld 命令是二进制工具集GNU Binutils的一员，是GNU的链接器，用于将目标文件与库链接为可执行文件或库文件</p></li><li><p>命令语法:</p><blockquote><p><code>$ ld [OPTIONS] OBJFILES</code></p></blockquote></li><li><p>实例:</p></li><li><p>链接目标文件生成可执行文件</p></li><li><p>给定C++目标文件<code>test.o</code>与<code>main.o</code>，生成可执行文件<code>test.out</code></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ld /usr/lib64/crt1.o /usr/lib64/crti.o /usr/lib64/crtn.o &amp;&amp;</span><br><span class="line">/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtbegin</span>.<span class="title">o</span> /<span class="title">usr</span>/<span class="title">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5/<span class="title">crtend</span>.<span class="title">o</span> &amp;&amp;</span></span><br><span class="line">-L/usr/<span class="class"><span class="keyword">lib</span>/<span class="title">gcc</span>/<span class="title">x86_64</span>-<span class="title">redhat</span>-<span class="title">linux</span>/4.8.5 &amp;&amp;</span></span><br><span class="line">-L/usr/lib64 -L/usr/<span class="class"><span class="keyword">lib</span> -<span class="title">lstdc</span>++ -<span class="title">lm</span> -<span class="title">lgcc_s</span> -<span class="title">lc</span> -<span class="title">lgcc</span>  <span class="title">main</span>.<span class="title">o</span> <span class="title">test</span>.<span class="title">o</span> -<span class="title">o</span> <span class="title">test</span>.<span class="title">out</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>具体参考:<br><a href="https://www.gnu.org/software/binutils/" target="_blank" rel="noopener">https://www.gnu.org/software/binutils/</a><br><a href="https://www.linux.org/docs/man1/ld.html" target="_blank" rel="noopener">https://www.linux.org/docs/man1/ld.html</a><br><a href="https://blog.csdn.net/K346K346/article/details/89088652" target="_blank" rel="noopener">https://blog.csdn.net/K346K346/article/details/89088652</a><br><a href="https://dablelv.blog.csdn.net/article/details/88094902" target="_blank" rel="noopener">https://dablelv.blog.csdn.net/article/details/88094902</a><br><a href="http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat" target="_blank" rel="noopener">http://stackoverflow.com/questions/14179969/whats-the-different-between-l-libpath-and-etc-ld-so-conf-configure-the-libpat</a></p></blockquote><ul><li>ld和ld.so的区别<a href="https://www.cnblogs.com/foohack/p/4105717.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.cnblogs.com/foohack/p/4105717.html</code></p></blockquote></li></ul><hr><h3 id="Strip"><a href="#Strip" class="headerlink" title="Strip"></a>Strip</h3><ul><li><p>从特定文件中剥掉一些符号信息和调试信息，使文件变小</p></li><li><p>strip - Discard symbols from object files(from man strip)</p></li><li><p>具体语法:</p><blockquote><p><code>$ strip [-xxx bfdname |--xxx=bfdname]</code><br>strip 之后的任何选项都是自定义参数，这里将不会做过多阐述<br>参考自: <a href="https://blog.csdn.net/qq_37858386/article/details/78559490" target="_blank" rel="noopener">https://blog.csdn.net/qq_37858386/article/details/78559490</a></p></blockquote></li><li><p>实例:</p></li><li><p>清理<code>/tools/lib</code>内所有的debug文件</p><blockquote><p><code>$ strip --strip-debug /tools/lib/*</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 04:45:43 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-8&quot;&gt;&lt;a href=&quot;#LFS-8&quot; class=&quot;headerlink&quot; title=&quot;LFS-8&quot;&gt;&lt;/a&gt;LFS-8&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-2</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-2/</id>
    <published>2020-02-29T16:58:18.000Z</published>
    <updated>2020-02-29T16:59:17.247Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 01:00:17 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-2"><a href="#GNU-LFS-3-2" class="headerlink" title="GNU LFS-3-2"></a>GNU LFS-3-2</h3><hr><p><strong>目标主机-2</strong></p><ul><li>GCC</li><li>Binutils</li><li>LFS-v6.2/v6.3</li></ul><hr><h3 id="Binutils"><a href="#Binutils" class="headerlink" title="Binutils"></a>Binutils</h3><p><strong>Binutils-2.17/Binutils-2.16.1</strong></p><blockquote><p><code>$ tar xvf $LFS/binutils-2.17/2.16.1.tar.bz2</code><br><code>$ mkdir -v ../binutils-build</code><br><code>$ cd ../binutils-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ../binutils<span class="number">-2.17</span>/<span class="number">2.16</span><span class="number">.1</span>/configure --prefix=/usr \</span><br><span class="line">            --enable-<span class="keyword">shared</span></span><br></pre></td></tr></table></figure></li><li><p>源码编译:</p><blockquote><p><code>$ make tooldir=/usr</code></p></blockquote></li></ul><p><strong>make参数含义:</strong></p><ul><li><p>参数<code>tooldir=/usr</code></p><blockquote><p>通常情况下，tooldir(可执行文件的安装目录)是<code>$(exec_prefix)/$(target_alias)</code><br>例如在i686机器上，将是<code>tt class=&quot;filename&quot;&gt;/usr/i686-pc-linux-gnu</code><br>因为此时只为自己的系统进 行编译，就并不需要在<code>/usr</code>目录后面再存在特殊的后缀<br><code>$(exec_prefix)/$(target_alias)</code>只是在交叉编译时(比如在Intel机器上编译将要在PowerPC上执行的程序)才用到</p></blockquote></li><li><p>编译测试套件:</p><blockquote><p><code>$ make check</code></p></blockquote></li><li><p>编译安装软件包</p><blockquote><p><code>$ make tooldir=/usr install</code></p></blockquote></li><li><p>安装某些软件包需要的<code>libiberty头文件</code></p><blockquote><p><code>$ cp -v ../binutils-2.17/2.16.1/include/libiberty.h /usr/include</code></p></blockquote></li><li><p>Binutils的内容这里不做过多阐述，可参考原文第6.11.2章节</p></li></ul><hr><h3 id="GCC-4-1-2-GCC-4-0-3"><a href="#GCC-4-1-2-GCC-4-0-3" class="headerlink" title="GCC-4.1.2/GCC-4.0.3"></a>GCC-4.1.2/GCC-4.0.3</h3><blockquote><p><code>$ tar xvf $LFS/gcc-4.1.2/4.0.3.tar.bz2</code><br><code>$ cd gcc-4.1.2/4.0.3</code></p></blockquote><ul><li><p>先使用一个sed命令来禁止GCC安装它自己的<code>libiberty.a</code></p></li><li><p>这里将使用Binutils附带的<code>libiberty.a</code>来代替</p><blockquote><p><code>$ sed -i &#39;s/install_to_$(INSTALL_DEST) //&#39; libiberty/Makefile.in</code></p></blockquote></li><li><p>在临时主机中应用的bootstrap编译中，编译器会有<code>-fomit-frame-pointer</code>的标志</p></li><li><p>非bootstrap编译默认是忽略这个标志的，可以应用下面的sed命令来确保编译的可靠性</p><blockquote><p><code>$ sed -i &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in</code></p></blockquote></li><li><p><code>fixincludes脚本</code>偶尔会因为修改系统的头文件而出错</p></li><li><p>因为GCC-4.1.2/4.0.3和Glibc-2.5.1/2.3.6是不需要修改的，运行下面的命令可以避免<code>fixincludes脚本</code>运行:</p><blockquote><p><code>$ sed -i &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in</code></p></blockquote></li><li><p>GCC中提供了一个<code>gccbug脚本</code>，会在编译时侦测<code>mktemp</code>是否存在，并且在测试中加强代码</p></li><li><p>这将会导致脚本使用一些不算很随机的名字来命名临时文件</p></li><li><p>因为我们后面会安装mktemp ，这里就将人为的去模仿它的存在:</p><blockquote><p><code>$ sed -i &#39;s/@have_mktemp_command@/yes/&#39; gcc/gccbug.in</code></p></blockquote></li></ul><blockquote><p><code>$ mkdir -v ../gcc-build</code><br><code>$ cd ../gcc-build</code></p></blockquote><ul><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/(gcc-4.1.2/4.0.3)/configure <span class="attribute">--prefix</span>=/usr \ </span><br><span class="line"><span class="attribute">--libexecdir</span>=/usr/lib \</span><br><span class="line">--enable-shared \ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix \</span><br><span class="line">--enable-__cxa_atexit \ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu \</span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++</span><br></pre></td></tr></table></figure></li><li><p>参数作用与目标主机内的作用相同，这里不做过多阐述</p></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li>预编译测试:<blockquote><p><code>$ make -k check</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>有的软件包希望C PreProcessor(预处理器)安装在<code>/lib</code>目录下，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv ../usr/bin/cpp /lib</code></p></blockquote></li><li><p>许多软件包使用cc作为C编译器的名字，为了满足它们的要求</p></li><li><p>需要创建如下符号链接:</p><blockquote><p><code>$ ln -sv gcc /usr/bin/cc</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 01:00:17 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-3-1</title>
    <link href="https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/"/>
    <id>https://unit-serow.github.io/2020/03/01/GNU-LFS-3-1/</id>
    <published>2020-02-29T16:12:11.000Z</published>
    <updated>2020-02-29T16:14:12.545Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 00:16:31 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-3-1"><a href="#GNU-LFS-3-1" class="headerlink" title="GNU-LFS-3-1"></a>GNU-LFS-3-1</h3><ul><li>此下任何关于LFS的讨论都是基于LFS-v6.2/6.3的LiveCD与手册之上的</li><li>程序内所拥有的文件与库这里不做阐述，可参考LFS-v6.2/6.3手册内容</li></ul><hr><p><strong>目标主机-1</strong></p><ul><li>内核头文件安装</li><li>Glibc安装</li><li>目标主机工具链解析</li><li>LFS-v6.2/v6.3</li><li>LFS-v6.3-LiveCD</li></ul><h3 id="内核头文件"><a href="#内核头文件" class="headerlink" title="内核头文件"></a>内核头文件</h3><p><strong>LFS-v6.3</strong></p><ul><li>[Linux-2.6.22.5]安装流程<blockquote><p><code>$ tar xvf $LFS/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code><br><code>$ sed -i &#39;/scsi/d&#39; include/Kbuild</code><br><code>$ make mrproper</code><br><code>$ make headers_check</code><br><code>$ make INSTALL_HDR_PATH=dest headers_install</code><br><code>$ cp -rv dest/include/* /usr/include</code><br><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Linux-Libc-Headers-2.6.12.0</strong></p><ul><li><p>添加一个用户空间头文件和新内核对于<code>inotify</code>特性的系统调用支持:</p><blockquote><p><code>$ patch -Np1 -i ../linux-libc-headers-2.6.12.0-inotify-3.patch</code></p></blockquote></li><li><p>安装内核头文件:</p><blockquote><p><code>$ install -dv /usr/include/asm</code><br><code>$ cp -Rv include/asm-i386/* /usr/include/asm</code><br><code>$ cp -Rv include/linux /usr/include</code></p></blockquote></li><li><p>确保这些头文件的所有者是root:</p><blockquote><p><code>$ chown -Rv root:root /usr/include/{asm,linux}</code></p></blockquote></li><li><p>确保用户可以读取这些头文件:</p><blockquote><p><code>$ find /usr/include/{asm,linux} -type d -exec chmod -v 755 {} \;</code><br><code>$ find /usr/include/{asm,linux} -type f -exec chmod -v 644 {} \;</code></p></blockquote></li><li><p>此时安装的头文件为<code>/usr/include/{asm,linux}/*.h</code></p></li><li><p>头文件内容可参考LFS-v6.2的6.7.2章节，这里不做过多阐述</p></li></ul><hr><p><strong>Man-pages-2.63/Man-pages-2.34</strong></p><ul><li>直接进行编译安装:<blockquote><p><code>$ tar xvf $LFS/man-pages-2.63.tar.bz2</code><br><code>$ cd man-pages-2.63</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf man-pages-2.63</code></p></blockquote></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><p><strong>Glibc-2.5.1/2.3.6</strong></p><ul><li><p>在进行之前请检查一下是否glibc-2.5.1和glibc-build这两个目录已经被删除，如果没有删除请删除后在继续</p></li><li><p>将glibc-libidn包解压到Glibc的源码目录:</p><blockquote><p><code>$ tar xvf $LFS/glibc-2.5.1.tar.bz2</code><br><code>$ cd glibc-2.5.1</code><br><code>$ tar -xvf $LFS/glibc-libidn-2.5.1.tar.gz</code><br><code>$ mv glibc-libidn-2.5.1 libidn</code></p></blockquote></li><li><p>应用下面这个patch来修正软件包在<code>sys/kd.h</code>之后包含<code>linux/types.h</code>导致编译错误:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-linux_types-1.patch</code></p></blockquote></li><li><p>添加一个头文件来定义为新内核对于inotify特性的系统调用函数:</p><blockquote><p><code>$ patch -Np1 -i ../glibc-2.3.6-inotify-1.patch</code></p></blockquote></li><li><p>抑制locale的安装，以避免出现bash的bug</p><blockquote><p><code>$ sed -i &#39;/vi_VN.TCVN/d&#39; localedata/SUPPORTED</code></p></blockquote></li><li><p>当运行make install时，一个叫<code>test-installation.pl</code>的脚本会在我们新安装的Glibc上做一个小的完整性测试</p></li><li><p>然而，由于我们的<code>toolchain</code>仍然指向<code>/tools</code>目录，完整性测试会导致使用错误的Glibc</p></li><li><p>所以必须强制脚本测试刚安装的脚本</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i \ </span><br><span class="line">'s|<span class="type">libs</span> -o|<span class="type">libs</span> -L/usr/lib -Wl,-dynamic-linker=/lib/ld-linux.so<span class="number">.2</span> -o|<span class="type">' \   </span></span><br><span class="line"><span class="type">scripts</span>/test-installation.pl</span><br></pre></td></tr></table></figure></li><li><p>继续运行指令:</p><blockquote><p><code>$ sed -i &#39;s|@BASH@|/bin/bash|&#39; elf/ldd.bash.in</code><br><code>$ mkdir -v</code><br><code>$ ../glibc-build</code><br><code>$ cd ../glibc-build</code></p></blockquote></li><li><p>配置安装脚本:</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure </span><br><span class="line">-<span class="ruby">-prefix=<span class="regexp">/usr \ </span></span></span><br><span class="line"><span class="ruby">--disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \ </span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--libexecdir=<span class="regexp">/usr/lib</span><span class="regexp">/glibc</span></span></span><br></pre></td></tr></table></figure></li><li><p>新参数说明:</p></li><li><p>参数<code>--libexecdir=/usr/lib/glibc</code></p><blockquote><p>把<code>pt_chown</code>程序的位置从默认的<code>/usr/libexec</code>改为<code>/usr/lib/glibc</code></p></blockquote></li></ul><blockquote><p><code>$ make</code></p></blockquote><ul><li><p>对结果进行测试:</p><blockquote><p><code>$ make -k check 2&gt;&amp;1 | tee glibc-check-log</code><br><code>$ grep Error glibc-check-log</code></p></blockquote></li><li><p>在安装Glibc的过程中，它会警告缺少<code>/etc/ld.so.conf</code>文件</p></li><li><p>其实这没什么关系，不过下面的命令能修正它:</p><blockquote><p><code>$ touch /etc/ld.so.conf</code></p></blockquote></li></ul><blockquote><p><code>$ make install</code></p></blockquote><ul><li><p>(LFS-v6.2独有)此部还需要安装<code>inotify头文件</code>到系统头文件的地方:</p><blockquote><p><code>$ cp -v ../glibc-2.3.6/sysdeps/unix/sysv/linux/inotify.h \ /usr/include/sys</code></p></blockquote></li><li><p>一次安装所有列在<code>glibc-2.3.6/localedata/SUPPORTED</code>中的<code>locales</code></p><blockquote><p><code>$ make localedata/install-locales</code></p></blockquote></li></ul><hr><p><strong>配置Glibc</strong></p><ul><li><p>此时需要建立<code>/etc/nsswitch.conf</code>文件</p></li><li><p>因为在这个文件丢失或不正确的情况下，Glibc会使用默认配置，而Glibc的默认配置无法很好地在网络环境下工作</p></li><li><p>并且我们也需要设置自己的时区</p></li><li><p>建立一个新的<code>/etc/nsswitch.conf</code>文件:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/nsswitch.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"># Begin /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">passwd: <span class="keyword">files</span> </span><br><span class="line">group: <span class="keyword">files</span> </span><br><span class="line">shado<span class="variable">w:</span> <span class="keyword">files</span></span><br><span class="line">host<span class="variable">s:</span> <span class="keyword">files</span> dns </span><br><span class="line">network<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">protocol<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">service<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">ether<span class="variable">s:</span> <span class="keyword">files</span> </span><br><span class="line">rpc: <span class="keyword">files</span> </span><br><span class="line"># End /etc/nsswitch.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>设置时区:</p><blockquote><p><code>$ cp -v --remove-destination /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p></blockquote></li><li><p>配置动态链接库加载程序</p></li><li><p>写入配置</p></li><li><p>LFS-v6.3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; &#x2F;etc&#x2F;ld.so.conf &lt;&lt; &quot;EOF&quot; </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib </span><br><span class="line">&#x2F;opt&#x2F;lib </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>LFS-v6.2</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> &gt; /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"># Begin /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span></span><br><span class="line">/usr/<span class="keyword">local</span>/lib </span><br><span class="line">/opt/lib</span><br><span class="line"># End /etc/ld.<span class="keyword">so</span>.<span class="keyword">conf</span> </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote><ul><li>glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误，还有一些能引起错误的LFS手册上有所提及</li><li>由此某些情况的错误可以无视</li></ul><hr><h3 id="调整目标主机工具链"><a href="#调整目标主机工具链" class="headerlink" title="调整目标主机工具链"></a>调整目标主机工具链</h3><ul><li><p>现在，最终的C库已经安装好了，此时需要再次调整工具链，让本章随后编译的那些工具都连接到这个库上</p></li><li><p>基本上，就是把临系统时增加中调整工具链那里做的调整给取消掉</p></li><li><p>在临时系统中，工具链使用的库是从宿主系统的<code>/{,usr/}lib</code>转向新安装的<code>/tools/lib</code>目录</p></li><li><p>同样的，现在工具链使用的库将从临时的<code>/tools/lib</code>转向LFS系统最终的<code>/{,usr/}lib</code>目录</p></li><li><p>首先，备份<code>/tools</code>下的链接</p><blockquote><p>用刚才在临时主机中编译的链接器来替换<br>再创建一个链接到在<code>/tools/$(gcc -dumpmachine)/bin</code>中的副本</p></blockquote></li><li><p>执行以下命令:</p><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote></li><li><p>接下来，修正GCC的specs文件，使它指向新的动态链接器</p></li><li><p>这样GCC才能知道在哪能发 现开始文件</p></li><li><p>这里应用一个sed命令:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | sed <span class="string">\</span> </span><br><span class="line">-e <span class="string">'s@/tools/lib/ld-linux.so.2@/lib/ld-linux.so.2@g'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*startfile_prefix_spec:/&#123;n;s@.*@/usr/lib/ @&#125;'</span> <span class="string">\</span> </span><br><span class="line">-e <span class="string">'/\*cpp:/&#123;n;s@$@ -isystem /usr/include@&#125;'</span> &gt; <span class="string">\</span> </span><br><span class="line">`dirname $(gcc --<span class="built_in">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>还可以利用perl命令</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs | \ </span><br><span class="line">perl -p -e's<span class="comment">@/tools/lib/ld-linux.so.2@</span>/<span class="keyword">lib</span>/ld-linux.so<span class="number">.2</span><span class="comment">@g;' \</span></span><br><span class="line"><span class="comment">-e 's@</span>\*startfile_prefix_spec:\n<span class="comment">@$_/usr/lib/ @</span>g;' &gt; \</span><br><span class="line">`dirname$(gcc --<span class="keyword">print</span>-libgcc-file-name)`/specs</span><br></pre></td></tr></table></figure></li><li><p>如果此时本地主机的系统平台上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须把上面命令里的<code>ldlinux.so.2</code>换成此时本地主机的系统平台上动态连接器的名字</p></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 00:16:31 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-3-1&quot;&gt;&lt;a href=&quot;#GNU-LFS-3-1&quot; class=&quot;headerlink&quot; title=&quot;GNU-LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-4</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-4/</id>
    <published>2020-02-29T11:26:43.000Z</published>
    <updated>2020-02-29T11:27:56.144Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 19:28:06 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-4"><a href="#GNU-LFS-2-4" class="headerlink" title="GNU LFS-2-4"></a>GNU LFS-2-4</h2><ul><li>[GNU 工具链]全面逻辑梳理</li><li>重点在于配置链接器与工具链的逻辑</li></ul><hr><h3 id="简要说明"><a href="#简要说明" class="headerlink" title="简要说明"></a>简要说明</h3><ul><li>可以将临时主机的工具链搭建分为两部分</li><li>前半部分为第一遍编译并安装GCC，Binutils和内核头文件</li><li>后半部分为编译并安装Glibc，在配置完Glibc之后，正式调整临时工具链并再次安装GCC与Binutils</li><li>第一步与第二部和第五步与第六步的顺序没有严格规定</li><li>但对GCC与Binutils的第二次编译安装必须在先配置并且编译安装完Glibc之后再进行</li></ul><hr><ul><li><code>Binutils-&gt;GCC-&gt;Headres-&gt;GLibc-&gt;Tools调整-&gt;Binutils-&gt;GCC/C++补丁</code></li><li>参考至<code>LFSv6.2/6.3</code></li></ul><hr><ul><li>因为这里所使用的LiveCD是LFS官方提供的</li><li>由于官方于6.3版本之后就停止维护了</li><li>所以这里只介绍6.3及以下版本</li></ul><hr><ul><li>这里将以下七个工具所需要的</li><li>每个工具编译的重要步骤</li><li>与对工具链的链接和链接器的配置进行了逻辑的梳理</li></ul><hr><h3 id="1-Binutils-Pass-1"><a href="#1-Binutils-Pass-1" class="headerlink" title="1. Binutils Pass-1"></a>1. Binutils Pass-1</h3><ul><li>编译并安装过后</li><li>为调整工具链而准备链接器</li></ul><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/tools/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote><ul><li>参数<code>-C ld LIB_PATH=/tools/lib</code></li><li>指定<code>Makefile</code>的<code>LIB_PATH</code>变量值</li><li>使其明确指向临时工具目录，以覆盖默认值</li><li>这个变量同时还指定了链接器的默认库搜索路径</li><li>在编译完Glibc后就会用到</li></ul><hr><h3 id="2-GCC-Pass-1"><a href="#2-GCC-Pass-1" class="headerlink" title="2. GCC Pass-1"></a>2. GCC Pass-1</h3><ul><li>编译并安装过后</li><li>创建gcc的符号链接为cc，以保证兼容性<blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li></ul><hr><h3 id="3-kernel-headers-API"><a href="#3-kernel-headers-API" class="headerlink" title="3. kernel headers API"></a>3. kernel headers API</h3><ul><li>将头文件编译并复制到所需目录</li></ul><hr><h3 id="4-Glibc"><a href="#4-Glibc" class="headerlink" title="4. Glibc"></a>4. Glibc</h3><ul><li>编译并安装C标准库</li><li>执行<code>touch /tools/etc/ld.so.conf</code></li><li>以修补安装过程中缺少的<code>/tools/etc/ld.so.conf</code></li></ul><hr><h3 id="5-调整工具链-LFS-v6-2-v6-3"><a href="#5-调整工具链-LFS-v6-2-v6-3" class="headerlink" title="5. 调整工具链(LFS-v6.2/v6.3)"></a>5. 调整工具链(LFS-v6.2/v6.3)</h3><ul><li><p>在临时系统的C标准库安装好之后</p></li><li><p>需要将临时工具链中的所有工具都连接到C标准库之上</p></li><li><p>为了达到这个目标，必须调整链接器和编译器的space文件</p></li><li><p>因为Binutils Pass-1的时候以经调整过链接器了</p></li><li><p>所以现在需要做的只是将其重新命名并被正确的找到和使用</p></li><li><p>方法是备份原来的链接器，然后再用调整过的链接器来替代</p></li><li><p>最后再创建一个指向<code>/tools/$(gcc -dumpmachine)/bin</code>中链接器副本的链接</p></li></ul><blockquote><p><code>$ mv -v /tools/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}</code><br><code>$ mv -v /tools/bin/{ld-new,ld}</code><br><code>$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld</code></p></blockquote><ul><li>从现在开始，所有程序都将连接到<code>/tools/lib</code>中的库文件</li></ul><hr><ul><li><p>接下来需要做的就是修正GCC中的spaces文件</p></li><li><p>目的是使他指向一个新的动态链接器</p></li><li><p>本质上就是把specs中所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>这里用的是sed命令，有两种语法(分别是LFS-v6.2与LFS-v6.3)</p></li><li><p>如果当前的本地主机上的动态连接器的名字不是<code>ld-linux.so.2</code></p></li><li><p>必须人为的把以下命令里的<code>ldlinux.so.2</code>换成本地主机的系统平台上动态连接器的名</p></li><li><p>LFS-v6.2</p></li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFIL</span><br></pre></td></tr></table></figure><ul><li>LFS-v6.3</li></ul><blockquote><p><code>$ gcc -dumpspecs | sed &#39;s@^/lib/ld-linux.so.2@/tools&amp;@g&#39; &gt;</code>dirname $(gcc -print-libgcc-file-name)<code>/ specs</code></p></blockquote><hr><ul><li><p>最后删除GCC专属头文件目录中的头文件，以避免宿主机中的头文件污染编译环境</p></li><li><p>这里的命令v6.2与v6.3没有区别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>工具链的调整方法有好几种</p></li><li><p>而且不同版本GCC的specs可能会有不同</p></li><li><p>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成<code>/tools/lib/ld-linux.so.2</code></p></li><li><p>还直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件</p></li></ul><hr><h3 id="6-Binutils-Pass-2"><a href="#6-Binutils-Pass-2" class="headerlink" title="6. Binutils Pass-2"></a>6. Binutils Pass-2</h3><ul><li><p>编译并安装</p></li><li><p>编译配置中配置参数<code>--with-lib-path=/tools/lib</code></p></li><li><p>以指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code></p></li><li><p>以防止连接器搜索宿主系统的库目录</p></li><li><p>最后为目标主机的调整工具链阶段配置链接器:</p><blockquote><p><code>$ make -C ld clean</code><br><code>$ make -C ld LIB_PATH=/usr/lib:/lib</code><br><code>$ cp -v ld/ld-new /tools/bin</code></p></blockquote></li></ul><hr><h3 id="7-GCC-C-补丁-Pass-2"><a href="#7-GCC-C-补丁-Pass-2" class="headerlink" title="7. GCC/C++补丁 Pass-2"></a>7. GCC/C++补丁 Pass-2</h3><ul><li><p>在GCC编译过程中会运行<code>fixincludes脚本</code>来扫描系统头文件目录</p></li><li><p>并找出需要修正的头文件，然后把修正后的头文件放到GCC专属头文件目录里</p></li><li><p>因为现在GCC和Glibc已经安装完毕，而且它们的头文件已知无需修正</p></li><li><p>所以这里并不需要<code>fixincludes脚本</code></p></li><li><p>必须先禁止fixincludes运行，以保证编译环境不受原主机所污染</p><blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig} &amp;&amp;</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li><p>因为在前几步中编译的GCC Pass-1中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项</p></li><li><p>而非<code>bootstrap</code>编译则默认忽略了该选项</p></li><li><p>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项</p></li><li><p>用以保持一致性:</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cp -v gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>&#123;,.tmp&#125; &amp;&amp;</span><br><span class="line">sed 's/^XCFLAGS =$/&amp; -fomit-frame-pointer/' gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span>.tmp \</span><br><span class="line">&gt; gcc/<span class="module-access"><span class="module"><span class="identifier">Makefile</span>.</span></span><span class="keyword">in</span></span><br></pre></td></tr></table></figure><ul><li><p>然后使用补丁修改补丁修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置:</p><blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li><p>该命令同时还把/usr/include`从GCC的头文件搜索路径里删掉</p></li><li><p>现在预先打补丁而不是在安装GCC之后调整specs文件可以保证新的动态连接器在编译GCC的时候就用上</p></li><li><p>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></li><li><p>然后配置编译器，并进行编译与编译安装</p></li><li><p>关于GCC的C++是在LFS-v9.0中出现的，这里先不做过多阐述</p></li></ul><hr><ul><li>至此结束临时主机的[GNU 工具链]配置环节</li><li>下一步即为配置其它的辅助命令与工具链所处的大环境</li><li>从而为目标主机提供应有的功能与服务</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 19:28:06 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-2-4&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-4&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-3</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-3/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-3/</id>
    <published>2020-02-29T11:22:36.000Z</published>
    <updated>2020-02-29T11:26:27.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 19:28:06 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-3"><a href="#GNU-LFS-2-3" class="headerlink" title="GNU LFS-2.3"></a>GNU LFS-2.3</h3><ul><li>GCC Pass-2</li><li>Bintils Pass-2</li></ul><hr><h3 id="Bintils-Pass-2"><a href="#Bintils-Pass-2" class="headerlink" title="Bintils Pass-2"></a>Bintils Pass-2</h3><ul><li>Binutils-2.16.1/LFS-6.2 Pass-2 154 MB 1.1 SBU</li><li>Binutils-2.17/LFS-6.3 Pass 2</li><li>Binutils-2.32/LFS-9.0 Pass-2 879 MB 1.1 SUB</li></ul><hr><p><strong>Binutils-2.16.1/2.17</strong></p><ul><li>解压文件并进入编译目录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2 </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li></ul><p>编译配置</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="string">../binutils-2.17</span><span class="params">(-2.16.1)</span><span class="string">/configure</span> <span class="params">--prefix=/tools</span> \</span><br><span class="line"><span class="params">--disable-nls</span> \ </span><br><span class="line"><span class="params">--with-lib-path=/tools/lib</span></span><br></pre></td></tr></table></figure><ul><li><p>新参数含义:</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这个选项指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为<code>/tools/lib</code><br>以防止连接器搜索宿主系统的库目录</p></blockquote></li><li><p>编译及安装</p><blockquote><p><code>$ make</code><br><code>$ make install</code></p></blockquote></li><li><p>为目标机器的工具链调整配置连接器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new/tools/bin</span><br></pre></td></tr></table></figure></li><li><p>最后清理一下</p><blockquote><p><code>$ cd .. rm -rf binutils-build</code><br><code>$ rm -rf binutils-2.17</code></p></blockquote></li></ul><hr><p><strong>Binutils-2.32</strong></p><ul><li>编译配置<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                \ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                 \ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib         \ </span><br><span class="line"><span class="built_in">..</span>/configure                 \    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools          \    </span><br><span class="line">--disable-nls             \    </span><br><span class="line">--disable-werror        \   </span><br><span class="line"><span class="attribute">--with-lib-path</span>=/tools/lib  \  </span><br><span class="line"> --with-sysroot</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数含义:</strong></p><ul><li><p>参数<code>CC=$LFS_TGT-gcc</code>,<code>AR=$LFS_TGT-ar</code>,<code>RANLIB=$LFS_TGT-ranlib</code></p><blockquote><p>因为这是真正的原生编译Binutils，设置这些变量能确保编译系统使用交叉编译器和相关的工具，而不是 宿主系统中已有的</p></blockquote></li><li><p>参数<code>--with-lib-path=/tools/lib</code></p><blockquote><p>这告诉配置脚本在编译Binutils的时候指定库搜索目录，此处将<code>/tools/lib</code>传递到链接器</p></blockquote></li><li><p>参数<code>--with-sysroot sysroot</code></p><blockquote><p>功能使链接器可以找到包括在其命令行中的其它共享对象明确需要的共享对象<br>否则的话，在某些主机上一些软件包可能会编译不成功</p></blockquote></li><li><p>之后进行编译安装</p></li><li><p>为目标机器中的工具链阶段准备链接器</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>make -C ld clean </span><br><span class="line"><span class="variable">$ </span>make -C ld LIB_PATH=<span class="regexp">/usr/lib</span><span class="symbol">:/lib</span> </span><br><span class="line"><span class="variable">$ </span>cp -v ld/ld-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>make 参数说明</strong></p><ul><li>参数<code>-C ld clean</code><blockquote><p>用于告诉make程序移除所有ld子目录中编译过的文件</p></blockquote></li><li>参数<code>-C ld LIB_PATH=/usr/lib:/lib</code><blockquote><p>这个选项重新编译ld子目录中的所有文件<br>在命令行中指定<code>Makefile</code>的<code>LIB_PATH</code>变量可以使我们能 够重写临时工具的默认值并指向正确的最终路径<br>该变量的值指定链接器的默认库搜索路径<br>目标主机中会用到这个准备</p></blockquote></li></ul><hr><h3 id="GCC-Pass-2"><a href="#GCC-Pass-2" class="headerlink" title="GCC Pass-2"></a>GCC Pass-2</h3><ul><li>GCC 9.2.0 LFS-9.0 3.7 GB/15 SBU</li><li>GCC 4.1.2 LFS-6.3</li><li>GCC 4.0.3 LFS-6.2 443 MB/4.2 SBU</li></ul><hr><p><strong>GCC 4.1.2/4.0.3 Pass-2</strong></p><blockquote><p><code>$ tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</code><br><code>$ cd gcc-4.1.2</code></p></blockquote><ul><li>禁止fixincludes脚本运行，以保证编译环境不被污染<blockquote><p><code>$ cp -v gcc/Makefile.in{,.orig}</code><br><code>$ sed &#39;s@\./fixinc\.sh@-c true@&#39; gcc/Makefile.in.orig &gt; gcc/Makefile.in</code></p></blockquote></li><li>因为在之前的<code>GCC Pass-1</code>中进行的<code>bootstrap</code>编译使用了<code>-fomit-frame-pointer</code>选项，而非bootstrap`编译则默认忽略了该选项</li><li>所以需要使用下面的sed命令来确保在非<code>bootstrap</code>编译时也同样使用<code>-fomit-frame-pointer</code>选项，以保持一致性<blockquote><p><code>$ cp -v gcc/Makefile.in{,.tmp}</code><br><code>$ sed &#39;s/^XCFLAGS =$/&amp; -fomit-frame-pointer/&#39; gcc/Makefile.in.tmp gcc \</code><br><code>&gt; Makefile.in</code></p></blockquote></li><li>使用下面的补丁来修改GCC的缺省动态连接器(通常是<code>ld-linux.so.2</code>)的位置，同时把<code>/usr/include</code>从GCC的头文件搜索路径里删掉:<blockquote><p><code>$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch</code></p></blockquote></li><li>预先打补丁而不是在安装GCC之后调整specs文件的作用是:<blockquote><p>可以保证新的动态连接器在编译GCC的时候就用上<br>也就是说，随后的所有临时程序都会连接到新的Glibc上</p></blockquote></li><li>此补丁非常重要，必须进行使用才能成功编译</li></ul><ul><li>GCC Pass-2 编译配置:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -v <span class="built_in">..</span>/gcc-build</span><br><span class="line">$ cd <span class="built_in">..</span>/gcc-build </span><br><span class="line">$ <span class="built_in">..</span>/gcc-4.1.2/configure <span class="attribute">--prefix</span>=/tools \ </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools \ </span><br><span class="line"><span class="attribute">--enable-clocale</span>=gnu \</span><br><span class="line">--enable-shared \ </span><br><span class="line"><span class="attribute">--enable-threads</span>=posix \</span><br><span class="line">--enable-__cxa_atexit \ </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++ \</span><br><span class="line">--disable-libstdcxx-pch</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数解析:</strong><br><code>--prefix=/tools</code><br><code>--with-local-prefix=/tools</code></p><ul><li>参数<code>--enable-clocale=gnu</code><blockquote><p>用于确保确保C++库在任何情况下都使用正确的locale模块</p></blockquote></li><li>参数<code>--enable-threads=posix</code><blockquote><p>用于使C++异常能处理多线程代码</p></blockquote></li><li>参数<code>--enable-__cxa_atexit</code><blockquote><p>用<code>__cxa_atexit</code>代替<code>atexit</code>来登记C++对象的本地静态和全局析构函数<br>这是为了完全符合标准对析构函数的处理规定</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>用于编译C和C++语言的编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译头(PCH)，它占用了很大空间，并且在此版本中用不到它</p></blockquote></li></ul><hr><p><strong>编译安装并清理:</strong></p><blockquote><p><code>$ make</code><br><code>$ make install</code><br><code>$ cd ..</code><br><code>$ rm -rf gcc-build</code><br><code>$ rm -rf gcc-4.1.2</code></p></blockquote><hr><p><strong>GCC 9.2.0 Pass-2</strong></p><ul><li><p>因为在第一次编译GCC的时候安装了一些内部系统头文件</p></li><li><p>其中的一个<code>limits.h</code>会反过来包括对应的系统头文件<code>limits.h</code>，在本次的实例中，是<code>/tools/include/limits.h</code></p></li><li><p>但是，第一次编译gcc的时候<code>/tools/include/limits.h</code>并不存在</p></li><li><p>因此GCC安装的内部头文件只是部分的自包含文件，并不包括系 统头文件的扩展功能</p></li><li><p>这足以编译临时libc，但是这次编译GCC要求完整的内部头文件</p></li><li><p>使用和正常情况下GCC编译系统使用的相同的命令创建一个完整版本的内部头文件:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat gcc/limitx.h gcc/glimits.h gcc/limity.h &gt; \  </span><br><span class="line">`dirname <span class="constructor">$($LFS_TGT-<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`/<span class="keyword">include</span>-fixed/limits.h</span><br></pre></td></tr></table></figure></li><li><p>再一次更改 GCC 的默认动态链接器的位置，使用安装在<code>/tools</code>的那个</p></li><li><p>执行以下配置:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ for file in gcc/config/&#123;linux,i386/linux&#123;,64&#125;&#125;<span class="string">.h</span> </span><br><span class="line">do  </span><br><span class="line">cp -uv $file&#123;,<span class="string">.orig</span>&#125;  </span><br><span class="line">sed -e 's@<span class="string">/lib</span>\<span class="params">(64\)</span>\?\<span class="params">(32\)</span>\?<span class="string">/ld</span>@<span class="string">/tools</span>&amp;@g' \</span><br><span class="line">       -e 's@<span class="string">/usr</span>@<span class="string">/tools</span>@g' $file.orig &gt; $file  </span><br><span class="line"><span class="keyword">echo</span> ' </span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_1 </span></span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_2 </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/" </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file  </span></span><br><span class="line">touch $file.orig </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>环境上构建，为64位库改变默认目录名至<code>lib</code>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $(uname -m) <span class="keyword">in</span>  </span><br><span class="line">x86_64)    </span><br><span class="line">sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \        </span><br><span class="line">-i.orig gcc/config/i386/t-linux64  </span><br><span class="line">;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure></li><li><p>和第一次编译GCC一样，它要求GMP,MPFR和MPC软件包</p></li><li><p>解压tar包并把它们重名为到所需的文件夹名</p></li><li><p>执行以下命令:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xf ../mpfr<span class="number">-4.0</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v mpfr<span class="number">-4.0</span><span class="number">.2</span> mpfr </span><br><span class="line">$ tar -xf ../gmp<span class="number">-6.1</span><span class="number">.2</span>.tar.xz </span><br><span class="line">$ mv -v gmp<span class="number">-6.1</span><span class="number">.2</span> gmp </span><br><span class="line">$ tar -xf ../mpc<span class="number">-1.1</span><span class="number">.0</span>.tar.gz </span><br><span class="line">$ mv -v mpc<span class="number">-1.1</span><span class="number">.0</span> mpc</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>在开始编译 GCC 之前，注意要取消所有会覆盖默认优化选项的环境变量</p></li><li><p>编译配置:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="variable">$LFS_TGT</span>-gcc                                   \ </span><br><span class="line"><span class="attribute">CXX</span>=<span class="variable">$LFS_TGT</span>-g++                               \ </span><br><span class="line"><span class="attribute">AR</span>=<span class="variable">$LFS_TGT</span>-ar                                 \ </span><br><span class="line"><span class="attribute">RANLIB</span>=<span class="variable">$LFS_TGT</span>-ranlib                             \ </span><br><span class="line"><span class="built_in">..</span>/configure                                      \    </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                                \    </span><br><span class="line"><span class="attribute">--with-local-prefix</span>=/tools                 \    </span><br><span class="line"><span class="attribute">--with-native-system-header-dir</span>=/tools/include    \    </span><br><span class="line"><span class="attribute">--enable-languages</span>=c,c++                                \    </span><br><span class="line">--disable-libstdcxx-pch                               \    </span><br><span class="line">--disable-multilib                                     \    </span><br><span class="line">--disable-bootstrap                            \    </span><br><span class="line">--disable-libgomp</span><br></pre></td></tr></table></figure></li></ul><p><strong>新参数说明:</strong></p><ul><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保编译了C 和C++编译器</p></blockquote></li><li>参数<code>--disable-libstdcxx-pch</code><blockquote><p>不为<code>libstdc++</code>编译预编译的头文件(PCH)<br>这会花费很多时间，却对我们没有用处</p></blockquote></li><li>参数<code>--disable-bootstrap</code><blockquote><p>对于原生编译的 GCC，默认是做一个[引导]构建<br>这不仅会编译GCC一次，而是会编译很多次</p></blockquote></li></ul><hr><ul><li>然后执行编译安装等操作</li><li>在编译并安装过后，可以为其设置符号链接(<code>gcc-&gt;cc</code>)<blockquote><p><code>$ ln -sv gcc /tools/bin/cc</code></p></blockquote></li><li>很多程序和脚本执行cc而不是gcc来保证程序的通用性<blockquote><p>并且在所有的Unix类型的系统上都能用<br>而非仅局限于安装了GCC的Unix 类型的系统</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>LFS-v6.2</li><li>LFS-v6.3</li><li>LFS-v9.0</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 19:28:06 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-2-3&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-3&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-2</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-2/</id>
    <published>2020-02-29T00:28:41.000Z</published>
    <updated>2020-02-29T00:31:56.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 08:32:01 GMT+0800 (中国标准时间) --><h3 id="GNU-LFS-2-2"><a href="#GNU-LFS-2-2" class="headerlink" title="GNU LFS-2-2"></a>GNU LFS-2-2</h3><ul><li><p>内容简述</p><blockquote><p>Linux Kernel Headeres(CN-LFS-6.2/6.3/9.0)<br>Glibc/Libstdc++(CN-LFS-6.2/6.3/9.0)<br>第一遍的工具链调整(CN-LFS-6.2/6.3/9.0)</p></blockquote></li><li><p>说明内容:</p></li><li><p>本篇内容将新版和旧版的资料相融合(将新版补充旧版的内容)</p></li><li><p>同时将其它的学习资料补充进LFS官方的文档内</p></li><li><p>在区分版本说明时，会先去介绍6.3再解释其它版本</p></li></ul><hr><h3 id="Linux-API-Headers"><a href="#Linux-API-Headers" class="headerlink" title="Linux API Headers"></a>Linux API Headers</h3><ul><li><p>每个版本的Linux kernel headers的名字都不一样</p></li><li><p>这里整合性的指出了三个版本的安装方法，分别是:</p><blockquote><p>Linux-2.6.22.5 API Headers(LFS-6.3)<br>Linux-5.2.8 API (LFS-9.0)<br>Linux-Libc-Headers-2.6.12.0 (LFS-6.2)</p></blockquote></li><li><p>新建编译目录和清理工作这里就不做过多阐述了</p></li></ul><hr><p><strong>Version-2.6.22.5(LFS-v6.3)</strong></p><ul><li>解压并进入文件夹<blockquote><p><code>$ tar xvf /lfs-sources/linux-2.6.22.5.tar.bz2</code><br><code>$ cd linux-2.6.22.5</code></p></blockquote></li></ul><p>清除所有存在的多余依赖关系:</p><blockquote><p><code>$ make mrproper</code></p></blockquote><p>编译头文件</p><blockquote><p><code>$ make headers_check</code></p></blockquote><ul><li><p>从源代码中提取用户可见的内核头文件到指定位置</p><blockquote><p><code>$ make INSTALL_HDR_PATH=dest headers_install</code></p></blockquote></li><li><p>保存在一个临时本地文件夹中然后复制到所需的位置</p><blockquote><p><code>$ cp -rv dest/include/* /tools/include</code></p></blockquote></li><li><p>清理</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf linux-2.6.22.5</code></p></blockquote></li></ul><hr><p><strong>Version-5.2.8(LFS-v9.0)</strong></p><ul><li><p>大致构建用时: 0.1 SBU</p></li><li><p>所需磁盘空间: 960 MB</p></li><li><p>清除依赖项</p><blockquote><p><code>$ make mrproper</code></p></blockquote></li><li><p>从源代码中提取用户可见的内核头文件</p></li><li><p>把它们保存在一个临时本地文件夹中然后复制到所需的位置</p></li><li><p>因为解压过程会移除目标文件夹中任何已有的文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">make</span> INSTALL_HDR_PATH=dest headers_install</span><br><span class="line"><span class="keyword">cp</span> -<span class="keyword">rv</span> dest/include/* /tools/include</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>Version-2.6.12.0(LFS-未知版本)</strong></p><ul><li><p>Linux-Libc-Headers-2.6.12.0</p></li><li><p>Linux-Libc-Headers内包含了纯净的内核头文件</p></li><li><p>预计编译时间：少于0.1</p></li><li><p>SBU所需磁盘空间：27MB</p></li><li><p>安装这些头文件所需指令:</p><blockquote><p><code>cp -Rv include/asm-i386 /tools/include/asm</code><br><code>cp -Rv include/linux /tools/include</code></p></blockquote></li><li><p>asm-i386为架构参数，需要自行进行调整</p></li></ul><hr><h3 id="Glibc"><a href="#Glibc" class="headerlink" title="Glibc"></a>Glibc</h3><ul><li>Glibc-2.5.1</li><li>Glibc-2.30</li></ul><hr><p><strong>Glibc-2.5.1</strong></p><ul><li><p>LFS-v6.3</p></li><li><p>解压并进入编译目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/glibc-2.5.1.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v glibc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> glibc-build</span></span><br></pre></td></tr></table></figure></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../glibc-2.5.1/configure --prefix=/tools \</span><br><span class="line">-<span class="ruby">-disable-profile \</span></span><br><span class="line"><span class="ruby">--enable-add-ons \</span></span><br><span class="line"><span class="ruby">--enable-kernel=<span class="number">2.6</span>.<span class="number">0</span> \</span></span><br><span class="line"><span class="ruby">--with-binutils=<span class="regexp">/tools/bin</span> \ </span></span><br><span class="line"><span class="ruby">--without-gd \</span></span><br><span class="line"><span class="ruby">--with-headers=<span class="regexp">/tools/include</span> \ </span></span><br><span class="line"><span class="ruby">--without-selinux</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>--prefix=/tools</code></p><blockquote><p>用于指定安装目录</p></blockquote></li><li><p>参数<code>--disable-profile</code></p></li><li><p>参数<code>--enable-add-ons</code></p><blockquote><p>用于指示Glibc使用附加的NPTL包作为线程库</p></blockquote></li><li><p>参数<code>--enable-kernel=2.6.0</code></p><blockquote><p>用于告诉Glibc编译支持2.6.x内核的库</p></blockquote></li><li><p>参数<code>--with-binutils=/tools/bin</code></p><blockquote><p>用于保证在编译Glibc时不会用错Binutils程序</p></blockquote></li><li><p>参数<code>--without-gd</code></p><blockquote><p>可以保证不生成memusagestat程序</p></blockquote></li><li><p>参数<code>--with-headers=/tools/include</code></p><blockquote><p>数指示Glibc按照前面刚刚安装到tools目录中的内核头文件编译自己<br>从而精确的知道内核的特性以根据这些特性对自己进行最佳化编译</p></blockquote></li><li><p>参数<code>--without-selinux</code></p><blockquote><p>用于明确禁用含有SELinux特性的Glibc，以防止会出现许多操作失败的结果</p></blockquote></li><li><p>其中参数<code>--enable-kernel=2.6.0</code>，只是为了说明kernel的大版本</p><blockquote><p>所以不需要根据实际的kernel版本来改<br>即使是用linux-2.6.15也一样只写2.6.0就可以了</p></blockquote></li><li><p>编译至二进制格式</p><blockquote><p><code>$make</code></p></blockquote></li><li><p>配置链接器</p><blockquote><p><code>$ mkdir -v /tools/etc</code><br><code>$ touch /tools/etc/ld.so.conf</code></p></blockquote></li><li><p>编译安装</p><blockquote><p><code>$ make install</code></p></blockquote></li><li><p>清理工作</p><blockquote><p><code>$ cd ..</code><br><code>$ rm -rf glibc-build</code><br><code>$ rm -rf glibc-2.5.1</code></p></blockquote></li></ul><hr><p><strong>Glibc-2.30</strong></p><ul><li><p>Glibc 软件包包含了主要的 C 函数库</p></li><li><p>这个库提供了分配内存，搜索目录，打开关闭文件，读写文件，操作字 符串，模式匹配，基础算法等基本程序</p></li><li><p>大致构建用时: 4.8 SBU</p></li><li><p>所需磁盘空间: 896 MB</p></li><li><p>编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">..</span>/glibc-2.5.1/configure              \      </span><br><span class="line"><span class="attribute">--prefix</span>=/tools                    \      </span><br><span class="line"><span class="attribute">--host</span>=<span class="variable">$LFS_TGT</span>                    \      </span><br><span class="line"><span class="attribute">--build</span>=$(../scripts/config.guess) \      </span><br><span class="line"><span class="attribute">--enable-kernel</span>=3.2                \      </span><br><span class="line"><span class="attribute">--with-headers</span>=/tools/include</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p><code>$ --host=$LFS_TGT, --build=$(../scripts/config.guess)</code></p><blockquote><p>这些选项的组合效果是Glibc的构建系统配置它自己用<code>/tools</code>里面的交叉链接器和交叉编译器交叉编译自己</p></blockquote></li><li><p><code>$ --enable-kernel=3.2</code></p><blockquote><p>这告诉Glibc编译能支持3.2以及之后的内核库<br>更早的内核版本不受支持</p></blockquote></li><li><p><code>$ --with-headers=/tools/include</code>告诉Glibc利用刚刚安装在tools文件夹中的头文件编译自身</p><blockquote><p>此能够根据内核的具体特性提供更好的优化</p></blockquote></li><li><p>在新版本的配置中，不仅需要安装C语言的标准库，还需要安装与配置对C++支持的标准库</p></li><li><p>Libstdc++是标准的C++库</p></li><li><p>需要用它来编译C++ 代码(GCC的一部分是用C++写的)</p></li><li><p>但是在构建GCC Pass-1时，我们需要推迟它的安装进程，因为依赖的glibc，还未部署在<code>/tools</code>目录中</p></li><li><p>大致构建用时: 0.5 SBU</p></li><li><p>所需磁盘空间: 879 MB</p></li><li><p>记得新建源码编译目录与编译完清理，这里不对此部分进行赘述了</p></li><li><p>因为Libstdc++是GCC源文件的一部分</p></li><li><p>所以首先应该解压GCC的压缩包，然后进入<code>gcc-9.2.0</code>文件夹</p></li><li><p>编译配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ../libstdc++-v3/configure             \    </span><br><span class="line">-<span class="ruby">-host=$LFS_TGT                 \    </span></span><br><span class="line"><span class="ruby">--prefix=<span class="regexp">/tools                 \    </span></span></span><br><span class="line"><span class="ruby">--disable-multilib              \    </span></span><br><span class="line"><span class="ruby">--disable-nls                   \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-threads     \    </span></span><br><span class="line"><span class="ruby">--disable-libstdcxx-pch         \    </span></span><br><span class="line"><span class="ruby">--with-gxx-<span class="keyword">include</span>-dir=<span class="regexp">/tools/</span>$LFS_TGT/<span class="keyword">include</span>/c++<span class="regexp">/9.2.0</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>配置说明:</strong></p><ul><li><p>参数<code>--host=...</code></p><blockquote><p>用于指示使用我们刚才编译的交叉编译器，而不是<code>/usr/bin</code>中的</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-threads</code></p><blockquote><p>由于我们还没有编译C线程库，C++的也还不能编译</p></blockquote></li><li><p>参数<code>--disable-libstdcxx-pch</code></p><blockquote><p>此选项防止安装预编译文件，此步骤并不需要</p></blockquote></li><li><p>参数<code>--with-gxx-include-dir=/tools/$LFS_TGT/include/c++/9.2.0</code></p><blockquote><p>这是C++编译器搜索标准include文件的位置<br>在一般的编译中，这个信息自动从顶层文件夹中传入Libstdc++ configure选项<br>在我们的例子中，必须明确给出这信息</p></blockquote></li><li><p>进行编译安装</p><blockquote><p>$ make<br>$ make install</p></blockquote></li></ul><hr><p><strong>其它情况</strong></p><ul><li>在编译过程中可能会发生以下警告</li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">configure: WARNING: </span><br><span class="line"><span class="comment">*** These auxiliary programs are missing or </span></span><br><span class="line"><span class="comment">*** incompatible versions: msgfmt </span></span><br><span class="line"><span class="comment">*** some features will be disabled. </span></span><br><span class="line"><span class="comment">*** Check the INSTALL file for required versions.</span></span><br></pre></td></tr></table></figure><ul><li>msgfmt程序的缺失或者不兼容通常是无害的</li><li>这个msgfmt程序是Gettext软件包的一部分，主机发行版应该提供了</li></ul><hr><h3 id="调整工具链"><a href="#调整工具链" class="headerlink" title="调整工具链"></a>调整工具链</h3><ul><li>根据自身情况进行工具链调整</li><li>以下实例为LFS-v6.3的配置代码</li><li>同时也包括了部分LFS-v6.2的内容</li></ul><hr><p><strong>调整思路:</strong></p><ul><li>因为现在临时的C库已经装好，接下来本章中要编译的所有工具应该连接到这些库上</li><li>为了达到这个目标，需要调整连接器和编译器的specs文件</li><li>在第一遍编译Binutils快结束时已经调整过的连接器，现在需要被重新命名以便可以被正确的找到和使用</li><li>首先备份原来的连接器，然后用调整过的连接器来替代</li><li>最后还要创建一个指向<code>/tools/$(gcc-dumpmachine)/bin</code>中连接器副本的连接</li><li>如果当前本地主机的系统平台上，动态连接器的名字不是<code>ld-linux.so.2</code></li><li>必须人为的把spaces配置里的<code>ldlinux.so.2</code>换成你的系统平台上动态连接器的名字</li></ul><hr><ul><li>以下为工具链配置代码(LFS-6.3)<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/&#123;ld,ld-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;ld-<span class="keyword">new</span>,ld&#125; </span><br><span class="line">$ ln -sv /tools/bin/ld /tools/<span class="constructor">$(<span class="params">gcc</span> -<span class="params">dumpmachine</span>)</span>/bin/ld </span><br><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure></li></ul><p><strong>语句内容刨析:</strong></p><ul><li>符号链接部分</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/$(gcc -dumpmachine)/bin/&#123;<span class="keyword">ld</span>,<span class="keyword">ld</span>-old&#125; </span><br><span class="line">$ mv -v /tools/bin/&#123;<span class="keyword">ld</span>-new,<span class="keyword">ld</span>&#125; </span><br><span class="line">$ ln -sv /tools/bin/<span class="keyword">ld</span> /tools/$(gcc -dumpmachine)/bin/<span class="keyword">ld</span></span><br></pre></td></tr></table></figure><ul><li><p>就是几个符号链接</p></li><li><p>当设置完成之后，所有程序都将连接到<code>/tools/lib</code>中的库文件</p></li><li><p>space部分</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -dumpspecs <span class="pattern-match">| sed 's@^<span class="operator">/</span>lib<span class="operator">/</span>ld-linux.so.2@<span class="operator">/</span>tools&amp;@g' &gt; `dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span> specs </span></span><br><span class="line"><span class="pattern-match"><span class="constructor">$</span> <span class="constructor">GCC_INCLUDEDIR</span>=`dirname <span class="constructor">$(<span class="params">gcc</span> -<span class="params">print</span>-<span class="params">libgcc</span>-<span class="params">file</span>-<span class="params">name</span>)</span>`<span class="operator">/</span><span class="keyword">include</span> <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">find <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span> -maxdepth 0 -xtype d -exec rm -rvf '&#123;&#125;' \; <span class="operator">&amp;&amp;</span> </span></span><br><span class="line"><span class="pattern-match">rm -vf `grep -l "<span class="constructor">DO</span> <span class="constructor">NOT</span> <span class="constructor">EDIT</span> <span class="constructor">THIS</span> <span class="constructor">FILE</span>" <span class="constructor">$</span>&#123;<span class="constructor">GCC_INCLUDEDIR</span>&#125;<span class="operator">/</span><span class="operator">*</span>` <span class="operator">&amp;&amp;</span></span></span><br><span class="line"><span class="pattern-match">unset <span class="constructor">GCC_INCLUDEDIR</span></span></span><br></pre></td></tr></table></figure><p>此代码还可以拆成以下两部分</p><ul><li><p>部分一</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">$</span> SPECFILE=`dirname <span class="symbol">$</span>(gcc -print-libgcc-<span class="keyword">file</span>-name)`/specs &amp;&amp; </span><br><span class="line">gcc -dumpspecs &gt; <span class="symbol">$</span>SPECFILE &amp;&amp;</span><br><span class="line">sed <span class="string">'s@^/lib/ld-linux.so.2@/tools&amp;@g'</span><span class="symbol">$</span>SPECFILE &gt; tempspecfile &amp;&amp;</span><br><span class="line">mv -vf tempspecfile <span class="symbol">$</span>SPECFILE &amp;&amp; </span><br><span class="line">unset SPECFILE</span><br></pre></td></tr></table></figure></li><li><p>用于修正GCC的specs文件，使它指向新的动态连接器</p></li><li><p>只需要像以上那样使用一个简单的sed命令就能做到</p></li><li><p>同时也可以手动编辑specs文件</p><blockquote><p>本质上就是把所有的<code>/lib/ld-linux.so.2</code>都替换成<code>/tools/lib/ld-linux.so.2</code>就行</p></blockquote></li><li><p>部分二</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ GCC_INCLUDEDIR=`dirname $(gcc -<span class="built_in">print</span>-libgcc-file-name)`/include &amp;&amp;</span><br><span class="line">find <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/* -maxdepth 0 -xtype d -<span class="built_in">exec</span> rm -rvf <span class="string">'&#123;&#125;'</span> \; &amp;&amp;</span><br><span class="line">rm -vf `grep -l <span class="string">"DO NOT EDIT THIS FILE"</span> <span class="variable">$&#123;GCC_INCLUDEDIR&#125;</span>/*` &amp;&amp;</span><br><span class="line"><span class="built_in">unset</span> GCC_INCLUDEDIR</span><br></pre></td></tr></table></figure></li><li><p>用于删除GCC专属头文件目录中的头文件</p><blockquote><p>以避免宿主系统中的头文件污染编译环境</p></blockquote></li></ul><hr><ul><li>相关说明<blockquote><p>工具链的调整方法有好几种，而且不同版本GCC的specs可能会有不同<br>但实际上都是把specs文件中的<code>/lib/ld-linux.so.2</code>替换成了<code>/tools/lib/ld-linux.so.2</code><br>所以即使有些文章在调整工具链上的命令和LFS手册上的不一样也不用太奇怪<br>当然也可以 直接用<code>gcc -dumpspecs</code>导出后手工直接编辑specs文件<br>spaces必须加以检查以确保被修改的配置的的确确生效了</p></blockquote></li></ul><hr><h3 id="内容参考"><a href="#内容参考" class="headerlink" title="内容参考"></a>内容参考</h3><ul><li>CN-LFS-v9.0</li><li>CN-LFS-v6.3</li><li>CN-LFS-v6.2</li><li>在LFS-1的URL资源整合目录里都有说明</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 08:32:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-LFS-2-2&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-2&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GNU-LFS-2-1</title>
    <link href="https://unit-serow.github.io/2020/02/29/GNU-LFS-2-1/"/>
    <id>https://unit-serow.github.io/2020/02/29/GNU-LFS-2-1/</id>
    <published>2020-02-28T17:06:14.000Z</published>
    <updated>2020-02-29T16:16:23.695Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 00:16:31 GMT+0800 (中国标准时间) --><h2 id="GNU-LFS-2-1"><a href="#GNU-LFS-2-1" class="headerlink" title="GNU LFS-2-1"></a>GNU LFS-2-1</h2><hr><h3 id="构造临时系统-1-0"><a href="#构造临时系统-1-0" class="headerlink" title="构造临时系统-1.0"></a>构造临时系统-1.0</h3><ul><li>1.0-为第一遍编译并安装临时工具链内Binutils与GCC</li></ul><p><strong>概述:</strong></p><ul><li><p>对于临时系统的简述</p></li><li><p>目的是何构造一个最小的Linux系统</p></li><li><p>该系统将包含刚好足够构建目标主机中最终LFS系统所需的工具，以及一个比最小环境具有更好用户便利性的工作环境</p></li><li><p>使用的软件包皆为v6.3版本的LFS-liveCD中拥有的软件包</p></li><li><p>本文只介绍基本的[GNU 工具链]的搭建参考于v6.3与v9.0(对6.3进行补充，对9.0进行说明)</p><blockquote><p>v6.3和v9.0都有进行举例说明</p></blockquote></li><li><p>构建这个最小系统有两个步骤:</p><blockquote><p>第一步: 构建一个与宿主系统无关的新工具链(编译器、汇编器、链接器、 库和一些有用的工具)<br>第二步: 使用该工具链，去构建其它的基础工具</p></blockquote></li><li><p>临时系统中编译得到的文件将被安装在目录<code>$LFS/tools</code>中</p><blockquote><p>以确保在下一章中安装的文件和宿主系统生成的目录相互分离<br>由于此处编译的软件包都是临时性的，因此可以人为的去避免出现污染后面即将构成的LFS系统的情况发生</p></blockquote></li></ul><p><strong>需要特别注意的几点:</strong></p><ul><li>在构建的过程需要注意的问题</li></ul><ol><li>把所有源文件和补丁放到 chroot 环境可访问的目录，例如<code>/mnt/lfs/sources/</code><blockquote><p>但是千万不 能把源文件放在<code>/mnt/lfs/tools/</code>中</p></blockquote></li><li>进入到源文件目录</li><li>对于每个软件包:<blockquote><p>a. 用tar程序解压要编译的软件包<br>同时在临时系统目录中，确保解压软件包时本地主机使用的是lfs用户<br>b. 进入到解压后创建的目录中<br>c. 根据指南说明编译软件包<br>d. 回退到源文件目录<br>e. 除非特别说明，删除解压出来的目录</p></blockquote></li></ol><hr><ul><li><p>进入LFS包编译目录</p><blockquote><p><code>cd $LFS/sources</code></p></blockquote></li><li><p>第一遍编译[GNU 工具链]说明:</p><blockquote><p>在编译完成之后，通常需要运行测试套件<br>但此时测试套件框架(Tcl，Expect和DejaGNU)还没有就绪<br>同时因为此时是所有工作的初期阶段<br>所以此进行测试的收效甚微，因为第一遍编译的程序很快会被第二遍的代</p></blockquote></li></ul><hr><h3 id="1-0-0"><a href="#1-0-0" class="headerlink" title="1.0.0"></a>1.0.0</h3><p><strong>Binutils-2.17/2.32-Pass 1</strong><br><strong>安装交叉编译的Binutils</strong></p><ul><li><p>目标软件包简述:</p><blockquote><p>Binutils 软件包包含一个链接器，一个汇编器，以及其它处理目标文件的工具<br>大致构建用时: 1 SBU<br>所需磁盘空间: 580 MB</p></blockquote></li><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/binutils-2.17.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> binutils-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3配置编译</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> <span class="string">../binutils-2.17/configure</span> <span class="params">--prefix=/tools</span>  \</span><br><span class="line">            <span class="params">--disable-nls</span> \</span><br><span class="line">            <span class="params">--disable-werror</span></span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span>  <span class="built_in">..</span>/binutils-2.32/configure <span class="attribute">--prefix</span>=/tools            \</span><br><span class="line">             <span class="attribute">--with-sysroot</span>=<span class="variable">$LFS</span>        \</span><br><span class="line">             <span class="attribute">--with-lib-path</span>=/tools/lib \</span><br><span class="line">             <span class="attribute">--target</span>=<span class="variable">$LFS_TGT</span>          \</span><br><span class="line">             --disable-nls              \</span><br><span class="line">             --disable-werror</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>CC=&quot;gcc -B/usr/bin/&quot;</code>该选项强制gcc使用宿主系统中/usr/bin目录下的连接器</p><blockquote><p>这样做的必要是因为新生成的ld可能与某些宿主系统的gcc不兼容</p></blockquote></li><li><p>参数<code>--prefix=/tools</code>用于告诉配置脚本将<code>Binutils程序</code>安装到<code>/tools</code>文件夹</p></li><li><p>参数<code>--with-sysroot=$LFS</code>用于交叉编译，告诉编译系统在<code>$LFS</code>中查找所需的目标系统库</p></li><li><p>参数<code>--with-lib-path=/tools/lib</code>指定需要配置使用的链接器的库路径</p></li><li><p>参数<code>--target=$LFS_TGT</code>，因为<code>LFS_TGT</code>变量中的机器描述和<code>config.guess</code>脚本返回的值略有不同，这个选项会告诉<code>configure</code>脚本调整<code>Binutils</code>的构建系统来构建一个交叉链接器</p></li><li><p>参数<code>--disable-nls</code>会禁止国际化(i18n)，因为国际化对临时工具来说没有必要</p></li><li><p>参数<code>--disable-werror</code>会防止来自宿主编译器的警告事件导致停止编译</p></li><li><p>继续编译并进行编译安装</p><blockquote><p>$make<br>$make install</p></blockquote></li><li><p>为调整工具链步骤准备连接器</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make -C <span class="keyword">ld</span> clean </span><br><span class="line">$ make -C <span class="keyword">ld</span> LIB_PATH=/tools/lib</span><br><span class="line">$ <span class="keyword">cp</span> -v <span class="keyword">ld</span>/<span class="keyword">ld</span>-new /tools/bin</span><br></pre></td></tr></table></figure></li></ul><p><strong>参数说明:</strong></p><ul><li><p>参数<code>-C ld clean</code></p><blockquote><p>用于告诉make程序删除所有ld子目录中编译生成的文件</p></blockquote></li><li><p>参数<code>-C ld LIB_PATH=/tools/lib</code></p><blockquote><p>用于这个选项重新编译ld子目录中的所有文件</p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf binutils-2.17</span></span><br></pre></td></tr></table></figure></li><li><p>如果是在<code>x86_64</code>上构建，创建符号链接，以确保工具链的完整性:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">case</span> $(uname -m) in  </span><br><span class="line">x86_64) mkdir -v /tools/<span class="class"><span class="keyword">lib</span> &amp;&amp; <span class="title">ln</span> -<span class="title">sv</span> <span class="title">lib</span> /<span class="title">tools</span>/<span class="title">lib64</span> ;</span>; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.16.2</code>的<code>Binutils内容</code></p></li></ul><hr><h3 id="2-0-0"><a href="#2-0-0" class="headerlink" title="2.0.0"></a>2.0.0</h3><p><strong>GCC-4.12/9.2.0 Pass-1</strong><br><strong>安装交叉编译的GCC</strong></p><ul><li>目标软件包简述:<blockquote><p>GCC软件包包括GNU编译器集，其中有C和C++的编译器<br>大致构建用时: 12 SBU<br>所需磁盘空间: 3.1 GB</p></blockquote></li></ul><p><strong>以下内容为LFS-v6.3的GCC编译过程</strong></p><ul><li><p>创建目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tar xvf /lfs-sources/gcc-4.1.2.tar.bz2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir -v gcc-build</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> gcc-build</span></span><br></pre></td></tr></table></figure></li><li><p>v6.3编译配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">CC</span>=<span class="string">"gcc -B/usr/bin/"</span> <span class="built_in">..</span>/gcc-4.1.2/configure <span class="attribute">--prefix</span>=/tools \ </span><br><span class="line">       <span class="attribute">--with-local-prefix</span>=/tools \</span><br><span class="line">       --disable-nls \</span><br><span class="line">       --enable-shared \</span><br><span class="line">       <span class="attribute">--enable-languages</span>=c</span><br></pre></td></tr></table></figure></li><li><p>v9.0编译配置</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CC=<span class="string">"gcc -B/usr/bin/"</span> ../gcc-<span class="number">9.2</span>.<span class="number">0</span>/configure       <span class="string">\</span></span><br><span class="line"> --target=$LFS_TGT                              <span class="string">\</span></span><br><span class="line"> --prefix=/tools                                <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-glibc-version=<span class="number">2.11</span>                      <span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-sysroot=$LFS                            <span class="string">\</span> </span><br><span class="line">  --<span class="keyword">with</span>-newlib                                  <span class="string">\</span> </span><br><span class="line"> --without-headers                              <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-local-prefix=/tools                     <span class="string">\</span> </span><br><span class="line"> --<span class="keyword">with</span>-<span class="keyword">native</span>-system-header-dir=/tools/include <span class="string">\</span> </span><br><span class="line"> --disable-nls                                  <span class="string">\</span></span><br><span class="line"> --disable-shared                               <span class="string">\</span></span><br><span class="line"> --disable-multilib                             <span class="string">\</span> </span><br><span class="line"> --disable-decimal-float                        <span class="string">\</span> </span><br><span class="line"> --disable-threads                              <span class="string">\</span> </span><br><span class="line"> --disable-libatomic                            <span class="string">\</span> </span><br><span class="line"> --disable-libgomp                              <span class="string">\</span> </span><br><span class="line"> --disable-libquadmath                          <span class="string">\</span> </span><br><span class="line"> --disable-libssp                               <span class="string">\</span> </span><br><span class="line"> --disable-libvtv                               <span class="string">\</span></span><br><span class="line"> --disable-libstdcxx                            <span class="string">\</span> </span><br><span class="line"> --enable-languages=c,c++</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>配置含义(参数说明):</strong></p><ul><li>参数<code>--with-newlib</code><blockquote><p>由于还没有可用的C库，这确保编译libgcc时定义了常数<code>inhibit_libc</code><br>这可以防止编译任何需要libc支持的代码</p></blockquote></li><li>参数<code>--without-headers</code><blockquote><p>在创建完整的交叉编译器时，GCC要求标准头文件和目标系统兼容<br>对于我们的目的来说，不需要这些头文件<br>这个选项可以防止GCC查找它们</p></blockquote></li><li>参数<code>--with-local-prefix=/tools GCC</code><blockquote><p>此参数会查找本地已安装的include文件的系统位置<br>默认是<code>/usr/local</code><br>把它设置为<code>/tools</code>能把主机位置中的<code>/usr/local</code>从GCC的搜索路径中排除</p></blockquote></li><li>参数<code>--with-native-system-header-dir=/tools/include</code><blockquote><p>GCC默认会在/usr/include中查找系统头文件<br>和<code>sysroot</code>选项一起使用，会转换为<code>$LFS/usr/include</code><br>在后面两个章节中头文件会被安装到<code>$LFS/tools/include</code><br>这个选项确保 gcc 能正确找 到它们<br>第二次编译 GCC 时，同样的选项可以保证不会去寻找主机系统的头文件</p></blockquote></li><li>参数<code>--disable-shared</code><blockquote><p>这个选项强制GCC静态链接到它的内部库<br>我们这样做是为了避免主机系统可能出现的问题</p></blockquote></li><li>参数:<blockquote><p><code>--disable-decimal-float</code>,<code>--disable-threads</code>,<code>--disable-libatomic</code>,<code>--disablelibgomp</code>,<br><code>--disable-libquadmath</code>,<code>--disable-libssp</code>,<code>--disable-libvtv</code>,<code>--disablelibstdcxx</code><br>这些选项取消了对十进制浮点数扩展，线程化，<code>libatomic</code>，<code>libgomp</code>，<code>libquadmath</code>，<code>libssp</code>，<code>libvtv</code>，<code>libcilkrts</code>和<code>C++</code>标准库的支持<br>这些功能在编译 交叉编译器的时候会导致编译失败，对于交叉编译临时 libc 来说也没有必要</p></blockquote></li><li>参数<code>--disable-multilib</code><blockquote><p>在<code>x86_64</code>机器上，LFS 还不支持<code>multilib</code>配置<br>这个选项对 x86 来说无害</p></blockquote></li><li>参数<code>--enable-languages=c,c++</code><blockquote><p>这个选项确保只编译 C 和 C++ 编译器<br>这些是现在唯一需要的语言</p></blockquote></li><li>此时只编译了GCC里的C编译器</li></ul><hr><ul><li><p>编译并安装</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; $ make bootstrap</span></span><br><span class="line"><span class="quote">&gt; $ make install</span></span><br></pre></td></tr></table></figure></li><li><p>创建符号连接(工具链)</p><blockquote><p><code>$ ln -vs gcc /tools/bin/cc</code></p></blockquote></li><li><p>清理工作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> .. </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-build </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf gcc-4.1.2</span></span><br></pre></td></tr></table></figure></li><li><p>该软件包的详细信息位于<code>Section#6.21.2</code>的GCC软件包内容里</p></li></ul><hr><ul><li>对于工具链内的工具或其它软件的编译安装大致可分为以下几步:</li></ul><ol><li>创建目录</li><li>配置编译器与其脚本文件</li><li>编译并安装</li><li>配置工具链</li></ol><ul><li>配置其它独有(针对于不同工具的特殊配置)性质</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>金钟国的v6.3-LFS</p></li><li><p>孙海勇的v6.3-LFS</p></li><li><p>LFS-v9.0</p></li><li><p><code>5.4. Binutils-2.18 - 第一遍</code><a href="https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blbl.dev/lfs_6.4_zhcn/chapter05/binutils-pass1.html</code></p></blockquote></li><li><p><code>gcc -B/usr/bin -B</code>的含义<a href="https://www.169it.com/tech-qa-linux/article-10702497996978005026.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.169it.com/tech-qa-linux/article-10702497996978005026.html</code></p></blockquote></li><li><p>百度知道<a href="https://zhidao.baidu.com/question/501313846.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zhidao.baidu.com/question/501313846.html</code></p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>对于9.2.0版本的GCC的补充内容</strong></p><ul><li><p>需要GMP，MPFR和MPC 软件包</p></li><li><p>在本地的主机发行版中可能并不包括这些软件包，它们将和GCC一起编译</p></li><li><p>将每个解压软件包到 GCC 的目录下，并重命名解压后得到的目录，以便GCC编译过程中能自动使用这些软件</p></li><li><p>执行以下命令:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tar -xf ../mpfr<span class="number">-4.0</span><span class="number">.2</span>.tar.xz</span><br><span class="line">$ mv -v mpfr<span class="number">-4.0</span><span class="number">.2</span> mpfr </span><br><span class="line">$ tar -xf ../gmp<span class="number">-6.1</span><span class="number">.2</span>.tar.xz</span><br><span class="line">$ mv -v gmp<span class="number">-6.1</span><span class="number">.2</span> gmp</span><br><span class="line">$ tar -xf ../mpc<span class="number">-1.1</span><span class="number">.0</span>.tar.gz</span><br><span class="line">$ mv -v mpc<span class="number">-1.1</span><span class="number">.0</span> mpc</span><br></pre></td></tr></table></figure></li><li><p>下面的指令将会修改GCC默认的动态链接器的位置，安装到<code>/tools</code>目录中的</p></li><li><p>并将<code>/usr/include</code>从GCC的include检索路径中移除</p></li><li><p>执行以下命令:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ for file in gcc/config/&#123;linux,i386/linux&#123;,64&#125;&#125;<span class="string">.h</span> </span><br><span class="line">do  </span><br><span class="line">cp -uv $file&#123;,<span class="string">.orig</span>&#125;  </span><br><span class="line">sed -e 's@<span class="string">/lib</span>\<span class="params">(64\)</span>\?\<span class="params">(32\)</span>\?<span class="string">/ld</span>@<span class="string">/tools</span>&amp;@g' \</span><br><span class="line">-e 's@<span class="string">/usr</span>@<span class="string">/tools</span>@g' $file.orig &gt; $file  </span><br><span class="line"><span class="keyword">echo</span> ' </span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_1 </span></span><br><span class="line"><span class="comment">#undef STANDARD_STARTFILE_PREFIX_2 </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_1 "/tools/lib/" </span></span><br><span class="line"><span class="comment">#define STANDARD_STARTFILE_PREFIX_2 ""' &gt;&gt; $file  </span></span><br><span class="line">touch $file.orig </span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>参数解析:</strong></p><p><strong>执行逻辑说明:</strong></p><ol><li>首先复制文件<code>gcc/config/linux. h</code>,<code>gcc/config/i386/linux.h</code>，和<code>gcc/config/i368/linux64.h</code></li><li>然后给复制的文件加上<code>.orig</code>后缀</li><li>然后第一个sed表达式在每个<code>/lib/ld</code>,<code>/lib64/ld</code>或者<code>/lib32/ld</code>实例前面增加<code>/tools</code><blockquote><p>第二个sed表达式替换<code>/usr</code>的硬编码实例</p></blockquote></li><li>然后添加这改变默认<code>startfile前缀</code>到文件末尾的定义语句<blockquote><p>此时需要注意<code>/tools/lib/</code>后面的<code>/</code>是必须的</p></blockquote></li><li>最后用<code>touch</code>更新复制文件的时间戳<blockquote><p>当与<code>cp -u</code>一起使用时，可以防止命令被无意中运行两次造成对原始文件意外的更改</p></blockquote></li></ol><hr><ul><li>在<code>x86_64</code>的主机上，为64位的库设置默认目录名至[lib]:</li><li>执行以下命令:<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span><span class="keyword">case</span> <span class="variable">$(</span>uname -m) <span class="keyword">in</span>  </span><br><span class="line">x86_64)</span><br><span class="line">sed -e <span class="string">'/m64=/s/lib64/lib/'</span> \        </span><br><span class="line">-i.orig gcc/config/i386/t-linux64 </span><br><span class="line">;; </span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><ul><li><p>在LFS-v6.3版本中</p></li><li><p>这里要注意第一遍编译的时候编译器参数需要指定:<code>CC=&quot;gcc -B/usr/bin/</code></p><blockquote><p>用以强制gcc使用宿主系统中/usr/bin目录下的连接器</p></blockquote></li><li><p>ld-GNU链接器</p></li><li><p>在第一次工具链调整之后需要进行一次可用性测试</p></li><li><p>在第二次编译安装完成GCC后需要进行一次可用性测试</p></li><li><p>测试组件</p><blockquote><p>Tcl-8.4.15<br>Expect-5.43.0<br>DejaGNU-1.4.4</p></blockquote></li></ul><hr><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>参考自LFS-v9.0第5.5章节</p></li><li><p>LFS-v9.0<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>LFS-v6.2</p><blockquote><p>参考金步国的中文译本</p></blockquote></li><li><p>LFS-v6.3</p><blockquote><p>参考孙海勇的中文译本</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 00:16:31 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-LFS-2-1&quot;&gt;&lt;a href=&quot;#GNU-LFS-2-1&quot; class=&quot;headerlink&quot; title=&quot;GNU LFS-
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU-LFS-1</title>
    <link href="https://unit-serow.github.io/2020/02/28/GNU-LFS-1/"/>
    <id>https://unit-serow.github.io/2020/02/28/GNU-LFS-1/</id>
    <published>2020-02-28T15:31:21.000Z</published>
    <updated>2020-02-29T17:00:11.358Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 01:00:17 GMT+0800 (中国标准时间) --><h3 id="LFS-1"><a href="#LFS-1" class="headerlink" title="LFS-1"></a>LFS-1</h3><ul><li>参考资料为CN-[LFS-BOOK(v9.0)]-PDF版</li></ul><hr><p><strong>文案说明:</strong></p><ul><li><p>GNU LFS-1-x 为LFS基本配置描述</p></li><li><p>GNU LFS-2-x 为临时系统描述</p></li><li><p>GNU LFS-3-x 为目标主机描述</p></li><li><p>进入chroot来操作目标主机</p></li><li><p>因为文章内关于LFS-v6.3或LFS-v6.2的内容使用了相近的解释，所以对于版本参数的描述可能有些凌乱</p></li><li><p>所以版本的问题需要就具体情况而定，文章里不会做对版本的细致区别</p></li><li><p>6.2和6.3版本的LFS有一个比较大的区别就是内核文件的不同，其它近乎相同</p></li><li><p>同时文章内的内容与资料仅供参考，具体实践还需查阅官方文档</p></li><li><p>使用6.3版本的原因是因为LFS官方的LiveCD的最新版本为6.3版本</p></li></ul><p><strong>本地主机环境一览:</strong></p><ul><li>原主机环境准备</li><li>主机内存(RAM)为4GB</li><li>主机磁盘为30GB</li><li>CPU为4核-2.2GHZ</li><li>本地主机硬盘接口类型为SCSI</li><li>磁盘分区表类型为MBR(GPT/GUID不做阐述)</li><li>磁盘启动引导类型为BIOS(UEFI不做阐述)</li><li>CD使用LFS-liveCD-v6.3(2007)</li></ul><hr><h3 id="1-0-0-1-2-7"><a href="#1-0-0-1-2-7" class="headerlink" title="1.0.0-1.2.7"></a>1.0.0-1.2.7</h3><p><strong>1.0.0</strong></p><ul><li>使用cfdisk工具对原主机进行分区(也可以使用fdisk工具进行分区操作)<blockquote><p><code>$cfdisk /dev/sda</code></p></blockquote></li></ul><p><strong>1.1.0 格式化磁盘分区</strong></p><ul><li><p>Swap分区(swap)</p><blockquote><p><code>$mkswap /dev/&lt;yyy&gt;</code><br><code>$mkswap /dev/sda1</code></p></blockquote></li><li><p>LFS分区(ext)</p><blockquote><p><code>$mkfs -v -t ext4/ext3 /dev/&lt;xxx&gt;</code><br><code>$mkfs.ext4/ext3 /dev/sda2</code><br><code>$mkfs -v -t ext3 /dev/sda2</code></p></blockquote></li><li><p>格式化为ext3文件系统</p><blockquote><p><code>mke2fs -jv /dev/&lt;xxx&gt;</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>前者为标准格式，后者为实例</li><li>在原主机磁盘上创建新分区</li><li>由于是LFS官方提供的liveCD，所以此时的原主机没有任何分区</li><li>这里创建两个本地的主分区: /dev/sda1用于交换分区(swap)，/dev/sda2用作目标主机制作环境，分区文件格式为ext3(或ext3/ext4等等)</li><li>存储容量分别是7000B与530000B(拟定，因本地主机的处理器指令集位数问题，实际情况会发生细微变动)</li></ul><hr><p><strong>1.2.0 设置LFS所处目录的系统变量</strong></p><ul><li>因为整个实现过程需要多次用到LFS系统的目录，所以先将LFS系统目录设置为LFS变量(变量名自拟，这里为LFS，即$LFS)</li><li>因为这里将要把LFS分区挂载到/mnt目录中，所以可以将LFS系统目录建立到/mnt目录内，以下指令直接创建环境变量:<blockquote><p><code>$export LFS=/mnt/lfs</code></p></blockquote></li></ul><p><strong>1.2.1 将新分区(LFS系统分区)进行挂载</strong></p><ul><li>挂载的目是访问所被挂载的分区，上一步中将分区所在目录设为了$LFS变量所指向的地址</li><li>创建挂载点<blockquote><p><code>mkdir -pv $LFS</code></p></blockquote></li><li>挂载LFS分区及其文件系统(文件可以自动识别，即便不加也是可以的)<blockquote><p><code>mount -v -t ext3/ext4 /dev/&lt;xxx&gt; $LFS</code><br><code>mount -v -t ext3 /dev/sda2 $LFS</code><br><code>mount /dev/sda2 $LFS</code></p></blockquote></li><li>(非必要)挂载并使用swap分区<blockquote><p><code>/sbin/swapon -v /dev/&lt;zzz&gt;</code></p></blockquote></li></ul><p><strong>相关实例与指令具体说明:</strong></p><ul><li>这里与以后的说明都将/dev/sda2分区称为LFS分区，即目标系统根目录</li><li>交换分区(swap)的作用是可以有效的解决编译过程中所需内存的不足，所以可以分出一个小型磁盘分区来当作swap空间</li><li>所以swap的容量可以按需分配，而sda2当然是越大越好</li><li>宿主机(原主机)和LFS分区的swap是公用的，如果原宿主机拥有swap，就没有必要再新建一个了</li><li>有关于磁盘分区的标志与其它分区表类型和启动引导类型的内容这里就不做过多赘述了</li></ul><hr><p><strong>1.2.2 创建必要目录以及目录权限分配</strong></p><ul><li><p>今后在第二阶段(临时系统)制作的时候会将所有的软件编译到<code>$LFS/tools</code>中，以便与第三阶段时所编译的软件完全分离</p></li><li><p>在目标系统成型后，便可将其遗弃</p></li><li><p>执行以下操作需要root权限</p></li><li><p>创建工具链目录<code>$LFS/tools</code></p><blockquote><p><code>mkdir -v $LFS/tools</code></p></blockquote></li><li><p>在原主机内创建符号链接，用以指向LFS分区中新建的目录(/tools)</p></li><li><p>此时所创建的符号链接将永远指向<code>/tools</code>文件夹</p><blockquote><p>即编译器，汇编器，链接器无论是在临时系统或是目标系统中都可以进行使用</p></blockquote></li><li><p>配置符号链接</p><blockquote><p><code>ln -sv $LFS/tools /</code></p></blockquote></li></ul><p><strong>1.2.3 创建源代码编译用目录</strong></p><blockquote><p><code>mkdir -v $LFS/sources</code></p></blockquote><ul><li>权限分配<blockquote><p><code>chmod -v a+wt $LFS/sources</code></p></blockquote></li></ul><hr><p><strong>1.2.4 添加LFS用户(自定义非特权用户命名)</strong></p><ul><li>因为以root用户登陆时，一个操作失误便可以摧毁整个操作系统，所以在此需要新建一个非特权用户来对软件包进行编译</li><li>同时也是为了建立一个干净的工作环境，这里创建一个名为lfs的新用于作为新组(同样命名为lfs)的成员</li><li>添加新用户:<blockquote><p><code>groupadd lfs</code></p></blockquote></li><li>将新用户lfs的shell设为默认bash，并将用户lfs添加到lfs组中，同时为lfs用户创建主目录</li><li>并对用户输入位置设置为空设备(null)，以防止可能从框架目录复制文件的情况<blockquote><p><code>useradd -s /bin/bash -g lfs -m -k /dev/null lfs</code></p></blockquote></li><li>设置lfs用户密码，可以为空<blockquote><p><code>passwd lfs</code></p></blockquote></li><li>将目录所有者改变为lfs<blockquote><p><code>chown -v lfs $LFS/tools</code></p></blockquote></li><li>同时为用户lfs赋予访问$LFS/tools目录的所有权限<blockquote><p><code>chown -v lfs $LFS/sources</code></p></blockquote></li><li>以lfs身份登陆主机</li><li>切换用户并启动shell环境<blockquote><p><code>su - lfs</code></p></blockquote></li></ul><hr><p><strong>1.2.5 设置环境</strong></p><ul><li>通过为bash shell创建两个开机启动文件，来设置合适的工作环境</li><li>以lfs用户的身份来创建一个新的<code>.bash_profile</code>文件<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ~/.bash_profile &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line">exec env -i <span class="attribute">HOME</span>=<span class="variable">$HOME</span> <span class="attribute">TERM</span>=<span class="variable">$TERM</span> <span class="attribute">PS1</span>=<span class="string">'\u:\w\$ '</span> /bin/bash </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li>当以lfs用户身份登录时，初始shell通常是一个login的shell</li></ul><ol><li>它先读取宿主机的<code>/etc/profile</code>文件(很可能包括一些设定和环境变量)</li><li>然后是<code>.bash_profile</code>文件</li><li><code>.bash_profile</code>中的命令<code>exec env -i.../bin/bash</code>用一个除了HOME，TERM和PS1变量外</li><li>其他环境完全为空的新shell代替运行中的shell</li><li>这能确保不会有潜在的和意想不到的危险环境变量，从宿主机泄露到构建环境中</li><li>这样做主要是为了确保环境的干净</li></ol><hr><p><strong>1.2.6 配置<code>.bashrc</code>文件</strong></p><ul><li>新的shell实例是一个<code>non-login</code>的shell</li><li>它不会读取<code>/etc/profile</code>或者<code>.bash_profile</code>文件，而是读取<code>.bashrc</code></li><li>创建<code>.bashrc</code>文件:<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ~/.bashrc &lt;&lt; <span class="string">"EOF"</span> </span><br><span class="line"><span class="builtin-name">set</span> +h </span><br><span class="line">umask 022 </span><br><span class="line"><span class="attribute">LFS</span>=/mnt/lfs </span><br><span class="line"><span class="attribute">LC_ALL</span>=POSIX </span><br><span class="line"><span class="attribute">LFS_TGT</span>=$(uname -m)-lfs-linux-gnu </span><br><span class="line"><span class="attribute">PATH</span>=/tools/bin:/bin:/usr/bin </span><br><span class="line"><span class="builtin-name">export</span> LFS LC_ALL LFS_TGT PATH </span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><p><strong>具体说明:</strong></p><ul><li><code>set +h</code>命令关闭了bash的哈希功能</li><li>设置用户文件新建时的掩码(umask)为 022，以确保新建的文件和目录只有其所有者可写，但任何人都可读可执行</li><li>LFS 变量应设置成选定的挂载点</li><li><code>LC_ALL变量</code>控制某些程序的本地化，使它们的消息遵循特定国家的惯例</li><li>设置<code>LC_ALL</code>为<code>POSIX</code>或<code>C</code>(两者是等价的)，以确保在chroot环境中一切能如期望的那样进行</li><li><code>LFS_TGT变量</code>设置了一个虽非默认，但在构建交叉编译器、连接器和交叉编译临时工作链时，用得上到的兼容的机器说明</li><li>通过把<code>/tools/bin</code>放在标准<code>PATH变量</code>的前面，使得所有在临时主机中安装的程序，一经安装shell便能马上使用</li><li>与之配合的关闭哈希功能，能在临时主机环境中的程序在可用的情况下，限制使用宿主机中旧程序的风险</li></ul><hr><ul><li>1.2.7 启用配置</li><li>最后，启用刚才创建的用户配置</li><li>为构建临时工具完全准备好环境:<blockquote><p><code>source ~/.bash_profile</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 01:00:17 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;LFS-1&quot;&gt;&lt;a href=&quot;#LFS-1&quot; class=&quot;headerlink&quot; title=&quot;LFS-1&quot;&gt;&lt;/a&gt;LFS-1&lt;/h3
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="GNU\Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>Disk-1</title>
    <link href="https://unit-serow.github.io/2020/02/28/Disk/"/>
    <id>https://unit-serow.github.io/2020/02/28/Disk/</id>
    <published>2020-02-28T03:08:36.000Z</published>
    <updated>2020-03-01T01:18:35.035Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 01 2020 09:18:41 GMT+0800 (中国标准时间) --><h2 id="Disk-1"><a href="#Disk-1" class="headerlink" title="Disk-1"></a>Disk-1</h2><hr><h3 id="Disk-引导逻辑全过程描述"><a href="#Disk-引导逻辑全过程描述" class="headerlink" title="Disk 引导逻辑全过程描述"></a>Disk 引导逻辑全过程描述</h3><ul><li>磁盘从底层固件引导至操作系统启动所对应的执行逻辑</li><li>本篇内容仅为主观描述，仅供参考</li></ul><p><strong>执行逻辑简述:</strong></p><p>Linux</p><blockquote><p><code>BIOS/UEFI(ROM)-&gt;MBR/GPT/GUID-(LBA/CHS)-&gt;VBR-&gt;grldr-&gt;boot loader-&gt;GRUB/LILO...-&gt;启动整个Linux系统</code></p></blockquote><p>windows</p><blockquote><p><code>BIOS-&gt;MBR-&gt;DPT-&gt;PBR-&gt;Bootmgr-&gt;BCD-&gt;系统选择界面--&gt;选择windows-NT-&gt;Winload.exe-&gt;内核加载等 -&gt;启动整个windows-NT系统</code></p></blockquote><p><strong>文字描述:</strong></p><ul><li><ol><li>先给基于ROM的固件BIOS/UEFI通电(启动/运行)，以加载磁盘主引导程序</li></ol></li><li><ol start="2"><li>POST(Power-On Self-Test)，基于BIOS程序进行对本地主机的硬件自检</li></ol></li><li><ol start="3"><li>基于对应固件类别来加载引导扇区(Boot Sequence)<blockquote><p>BIOS根据Boot Sequence中的顺序，将最前面的存储设备的引导扇区的内容加载到内存中，并跳转到引导程序的第一条指令</p></blockquote></li></ol></li><li><ol start="4"><li>再通过基于主引导记录类型(MBR/GPT/GUID)来指定的寻址模式(LBA/CHS)来寻找已有的开机引导程序(进入磁盘启动环节)<blockquote><p>关于MBR与GPT的内容可参考历史文章</p></blockquote></li></ol></li><li><ol start="5"><li>基于某个类别的主引导记录类型利用分区表将控制权转交给硬盘的某个分区<blockquote><p>此时在四个主分区里面，只有一个是激活的计算机会读取激活分区的第一个扇区，叫做卷引导记录(Volume Boot Record，缩写为VBR，也可称为分区引导记录，Partition Boot Record，缩写为PBR)<br>卷引导记录的有以下主要作用:<br>寻找激活分区根目录下的grldr(Grub),NTLDR(XP),bootmgr(Win7 above),btldr.mbr(BootLink)等可用于引导的程序</p></blockquote></li></ol></li><li><ol start="6"><li>执行启动管理器(boot loader)，此时卷引导记录搜索到激活分区中的启动管理器，将控制权交给启动管理器运行<blockquote><p>boot loader是系统预先安装的程序，用以实现由用户选择启动哪一个操作系统<br>启动管理器寻找激活分区中的启动配置数据(如: Win7中的BCD文件、XP中的boot.ini文件)，根据启动配置数据，在显示器上显示多操作系统选择画面<br>然后选择相应的操作系统<br>最后控制权交给操作系统<br>Linux环境中，目前最流行的启动管理器是Grub<br>在windows下为启动管理器bootmgr(xp中的ntldr文件)</p></blockquote></li></ol></li><li><ol start="7"><li>下一步是将控制权转交给操作系统，以此让操作系统的内核首先被载入内存</li></ol></li><li><ol start="8"><li>最后实现磁盘内操作系统的启动</li></ol></li><li><p><em>或*</em></p></li><li><ol><li>由BIOS/UEFI寻找第一个可启动设备(通常为Disk)</li></ol></li><li><ol start="2"><li>然后从MBR/GPT/GUID中基于的寻址模式来加载启动程序</li></ol></li><li><ol start="3"><li>最终把代码控制权交给GRUB(或其它引导程序)</li></ol></li><li><p>所谓操作系统的引导过程是将存放在硬盘上的静态的操作系统装载到内存中，并开始执行操作系统的过程</p></li><li><p>每一个不同类别的工具都有完全不同的执行逻辑与所执行步骤对应的执行标志，这里先不做过多阐述</p></li></ul><hr><p><strong>相关概念:</strong></p><ul><li>引导扇区: 主引导记录(主引导扇区)/全局唯一标识符(全局唯一标识分区表)<blockquote><p>MBR/GPT/GUID</p></blockquote></li><li>磁盘引导程序所基于的寻址模式(LBA/CHS)</li><li>LVM/RAID(逻辑卷管理/磁盘阵列)</li><li>BIOS/UEFI(固件系统)</li><li>磁盘/磁盘分区所属数据类型/文件系统</li><li>磁盘映像文件格式</li><li>磁盘驱动/硬件驱动/设备驱动</li><li>扩展分区(Extended partition)和逻辑分区(logical partition)<blockquote><p>扩展引导记录(Extended boot record)缩写为EBR</p></blockquote></li><li>MBR/GPT分区表</li><li>启动管理器(boot loader)</li></ul><hr><p><strong>磁盘缓存(Disk Buffer/Disk Cache)相关概述:</strong></p><ul><li><p>用于将下载到的数据先保存于系统为软件分配的内存空间中(这个内存空间被称之为”内存池”)</p><blockquote><p>当保存到内存池中的数据达到一个程度时，便会将数据保存到硬盘中<br>这样可以减少实际的磁盘操作，有效的保护磁盘免于重复的读写操作而导致的损坏</p></blockquote></li><li><p>磁盘缓存是为了减少CPU透过I/O读取磁盘驱动器的次数</p><blockquote><p>提升磁盘I/O的效率，用一块存储器来存储访问较频繁的磁盘内容<br>因为存储器的访问是电子动作，而磁盘的访问是机械动作，感觉上磁盘I/O变得较为快速</p></blockquote></li><li><p>普遍的磁盘通常有32MB或64MB缓存，现在市售上128MB与256MB也十分常见</p><blockquote><p>旧的硬盘则有8MB或16MB</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-磁盘缓存<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A3%81%E7%9B%98%E7%BC%93%E5%AD%98</code></p></blockquote></li><li><p>CN-阮一峰-计算机是如何启动的?<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ruanyifeng.com/blog/2013/02/booting.html</code></p></blockquote></li><li><p>CSDN-操作系统引导过程<a href="https://blog.csdn.net/jonathan321/article/details/51987680" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/jonathan321/article/details/51987680</code></p></blockquote></li><li><p>CSDN-操作系统引导程序学习笔记<a href="https://blog.csdn.net/aice_dachong/article/details/50843240" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/aice_dachong/article/details/50843240</code></p></blockquote></li><li><p>CSDN-操作系统概念：系统引导过程、引导程序、固件<a href="https://blog.csdn.net/qq_36328643/article/details/79922425" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/qq_36328643/article/details/79922425</code></p></blockquote></li></ul><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><p><strong>硬盘的物理结构描述与图解:</strong></p><ul><li>磁盘的物理结构图例-1</li></ul><img src="/images/disk-images/磁盘-1.png" width="20%" height="20%"><ul><li>磁道(Track)</li><li>柱面(Cylinder)</li><li>扇区(Sector)</li><li>磁头(Heads)</li><li>盘片(Platters)</li><li>每个碟片都有两面，因此也会相对应每碟片有2个磁头</li></ul><hr><ul><li>磁盘的物理结构图例-2</li></ul><img src="/images/disk-images/磁盘-6.png" width="20%" height="20%"><ul><li>A: 磁道</li><li>B: 扇面</li><li>C: 扇区</li><li>D: 簇(扇区组)</li><li>在硬盘上定位某一数据记录位置—C扇区，使用了三维定位</li></ul><hr><ul><li>其它磁盘物理结构有关图片</li></ul><img src="/images/disk-images/磁盘-2.png" width="20%" height="20%"> <img src="/images/disk-images/磁盘-3.png" width="20%" height="20%"> <img src="/images/disk-images/磁盘-4.png" width="20%" height="20%"> <img src="/images/disk-images/磁盘-5.png" width="20%" height="20%"><hr><p><strong>图片来源:</strong></p><ul><li><p>CN-简书<a href="https://www.jianshu.com/p/42308db1fcde" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.jianshu.com/p/42308db1fcde</code></p></blockquote></li><li><p>CN Wiki-GPT<a href="https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8</code></p></blockquote></li><li><p>CN Wiki-磁盘<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 01 2020 09:18:41 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Disk-1&quot;&gt;&lt;a href=&quot;#Disk-1&quot; class=&quot;headerlink&quot; title=&quot;Disk-1&quot;&gt;&lt;/a&gt;Disk-1
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Disk" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Disk/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU GRUB</title>
    <link href="https://unit-serow.github.io/2020/02/28/GNU-GRUB/"/>
    <id>https://unit-serow.github.io/2020/02/28/GNU-GRUB/</id>
    <published>2020-02-27T17:04:40.000Z</published>
    <updated>2020-02-27T17:06:05.278Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h3 id="GRUB-简述"><a href="#GRUB-简述" class="headerlink" title="GRUB 简述"></a>GRUB 简述</h3><ul><li>概述</li><li>启动过程(逻辑)</li><li>特性(相对于LILO或其它的引导程序)</li><li>相关概念</li></ul><p><strong>概述:</strong></p><ul><li>GNU GRUB，简称GRUB</li><li>基于GNU通用公共许可证</li><li>是一个来自GNU项目的启动引导程序</li><li>GRUB是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统并在计算机启动时选择希望运行的操作系统</li><li>GRUB可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数</li><li>GNU GRUB的前身为Grand Unified Bootloader</li><li>它主要用于类Unix系统</li><li>同大多Linux发行版一样，GNU系统也采用GNU GRUB作为它的启动器</li><li>Solaris从10 1/06版开始在x86系统上也采用GNU GRUB作为启动器</li></ul><hr><p><strong>GRUB启动过程:</strong></p><ol><li>计算机启动后，BIOS将寻找第一个可启动的设备(通常为硬盘)</li><li>而后从MBR中加载启动程序，然后把控制交给这段代码</li><li>MBR位于硬盘的前512字节内</li></ol><ul><li>GRUB第一版的启动过程</li></ul><ol><li>GRUB的步骤1包含在MBR中<blockquote><p>由于受MBR的大小限制，步骤1所做的几乎只是装载GRUB的下一步骤(存放在硬盘的其它位置)</p></blockquote></li><li>步骤1既可以直接装载步骤2，也可以装载步骤1.5: GRUB的步骤1.5包含在MBR后面的30千字节中</li><li>步骤1.5加载步骤2</li><li>当步骤2启动后，它将呈现一个界面来让用户选择启动的操作系统<blockquote><p>这步通常采用的是图形菜单的形式，如果图形方式不可用或者用户需要更高级的控制<br>可以使用GRUB的命令行提示，通过它，用户可以手工指定启动参数<br>GRUB还可以设置超时后自动从某一个内核启动</p></blockquote></li></ol><ul><li>GRUB第二版的启动过程</li><li>与GRUB第一版相似的是，<code>boot.img</code>像步骤1一样在MBR或在启动分区中<blockquote><p>但是，它可以从任何LBA48地址的一个扇区中读取</p></blockquote></li></ul><ol><li>它(boot.img)将读取core.img(产生于diskboot.img)的第一个扇区以用来后面读取core.img的剩余部分</li><li>core.img正常情况下跟步骤1.5储存在同一地方并且有着同样的问题<blockquote><p>可是，当他被移动到一个文件系统或一个纯粹的分区时会比在步骤1.5移动或删除引起更少的麻烦<br>一旦完成读取，core.img会读取默认的配置文件和其他需要的模块</p></blockquote></li></ol><ul><li>当GRUB启动后的执行逻辑(NT内核的特点)</li><li>一旦选择了启动选项，GRUB把选择的内核加载内存并把控制交给内核<blockquote><p>在此步骤中，对于Windows之类不支持多启动标准的操作系统，GRUB也可以通过链式启动把控制传给其它启动器<br>在这种情况下，其它操作系统的启动程序被GRUB保存了下来</p></blockquote></li><li>与内核不同，其它操作系统如同直接自MBR启动<blockquote><p>类似Windows的启动菜单，也许是另一个启动管理器，它允许在多个不支持多启动的操作系统中做进一步的选择<br>在已有Windows的系统上面，或者包含多个Windows版本的系统上安装现代的Linux而不修改原操作系统，即属于这类情况</p></blockquote></li></ul><hr><p><strong>GRUB特点:</strong></p><ul><li><p>GRUB的一个重要的特性是安装它不需依附一个操作系统</p><blockquote><p>但是，这种安装需要一个Linux/Windows副本<br>由于单独工作，GRUB实质上是一个微型系统，通过链式启动的方式，它可以启动所有安装的主流操作系统</p></blockquote></li><li><p>与LILO不同，修改GRUB的配置文件后，不必把GRUB重新安装到MBR或者某个分区中</p></li><li><p>在Linux中，<code>$grub-install</code>命令是用来把GRUB的步骤1安装到MBR或者分区中的</p><blockquote><p>GRUB的配置文件、步骤2以及其它文件必须安装到某个可用的分区中<br>如果这些文件或者分区不可用，步骤1将把用户留在命令行界面</p></blockquote></li><li><p>GRUB Legacy的配置文件</p><blockquote><p>为<code>/boot/grub/menu.lst</code>或<code>/boot/grub/grub.conf</code></p></blockquote></li><li><p>GRUB 2的配置文件</p><blockquote><p>为<code>/boot/grub/grub.conf</code></p></blockquote></li><li><p>除了硬盘外，GRUB也可安装到光盘、软盘和闪存盘等移动介质中</p><blockquote><p>以此引导一台无法从硬盘启动的系统</p></blockquote></li></ul><hr><p><strong>相关概念(关键字):</strong></p><ul><li>LILO</li><li>SYSLINUX</li><li>GRUB</li><li>UEFI</li><li>BIOS</li><li>MBR</li><li>GPT</li><li>NTLDR</li><li>Windows Boot Manager</li></ul><hr><h3 id="GRUB-使用方法与相关指令简述"><a href="#GRUB-使用方法与相关指令简述" class="headerlink" title="GRUB 使用方法与相关指令简述"></a>GRUB 使用方法与相关指令简述</h3><ul><li>grub命令是多重引导程序grub的命令行shell工具</li><li>基本语法:<blockquote><p><code>$grub [options]</code></p></blockquote></li><li>直接键入grub则直接进入grub命令行</li><li>其它参数这里不过过多阐述</li></ul><hr><ul><li><p>正常启动情况下，屏幕上出现grub的启动项选择菜单时按<code>c键</code>也是可以进入<code>grub&gt;</code>状态的</p></li><li><p>grub指令最重要且最常用的功能就是用来启动损坏的或者是LFS的已独立系统</p></li><li><p>用grub的命令来手工启动系统只需要用到四个命令<code>boot</code>，<code>kernel</code>，<code>initrd</code>，<code>boot</code></p></li><li><p>参数<code>--help</code>用于显示帮助信息</p></li><li><p>列出当前电脑上可能的磁盘设备</p><blockquote><p><code>grub&gt; root (hd/sd</code><br>然后按两次TAB键<br>通常会输出硬盘为<code>hd0/hd1</code>或<code>sd0/sd1</code>等</p></blockquote></li><li><p>选择本地主机的安装Linux系统的硬盘</p></li><li><p>比如<code>hd0</code>，执行</p><blockquote><p><code>grub&gt; root (hd0,</code><br>再按两次TAB键<br>通常输出并列出本地主机第一块硬盘上的分区情况<br>此时可以知道哪个是swap交换分区(0x82)或哪个是Linux分区(0x83)</p></blockquote></li><li><p>然后选择可能的/boot目录所在的分区</p><blockquote><p>执行<code>root (hd0, 1)</code>并回车</p></blockquote></li><li><p>查看所选分区是否为<code>/boot</code>所在分区(根目录分区判断)</p><blockquote><p><code>grub&gt; cat /xxx/xxx</code><br>xxx为指定文件目录<br>按两次TAB键</p></blockquote></li><li><p>这里以输入<code>cat /sbin/init</code>来举例，连按两次TAB键之后参考以下两种情况:</p></li></ul><ol><li>如果出现一些init开头的文件，则说明该分区为<code>/</code>所在的分区</li><li>如果没有出现/sbin/init文件，说明(hd0,1)分区仅仅是<code>/boot</code>分区而不是<code>/</code>分区<blockquote><p>此时需要重新输入<code>$root (hd0,N)</code>命令，这里N是某个Linux分区<br>然后再试<code>cat /sbin/init</code>， 直到屏幕上出现<code>/sbin/init</code><br>则说明找到了<code>/</code>分区<br>严格来说，应该是<code>/sbin</code>目录所在的分区</p></blockquote></li></ol><ul><li><p>此指令还可用于判断所选分区内的文件目录与拥有文件，利用所存储文件的类别来判断分区的作用及分区名</p></li><li><p>这里的关键问题是如何确定系统的几个分区: <code>/boot</code>，<code>/</code>与<code>/sbin</code></p></li><li><p>比如输入<code>cat /boot/vm</code>并按两次TAB键</p><blockquote><p>如果出现一些<code>vm</code>开头的文件，比如<code>vmlinuz-2.6.15-26-386</code>说明这里是<code>/boot</code>所在的分区</p></blockquote></li><li><p>再输入<code>cat /boot/initrd</code>并按两次TAB键</p><blockquote><p>如果出现一些<code>initrd</code>开头的文件，比如<code>initrd.img-2.6.15-26-386</code>说明这个<code>/boot</code>所在的分区有<code>initrd</code>即<code>ramdisk</code>镜像</p></blockquote></li></ul><p><strong>通用指令集:</strong></p><ul><li>一般情况下，依次输入以下命令即可以进入(启动)系统<blockquote><p><code>root (hd0,1)</code> # 此时假设<code>/dev/hda2</code>是本地主机的<code>/boot</code>所在的分区<br><code>kernel /boot/vmlinuz-2.6.15-26-386 ro dev=/dev/hda3</code> # 此时假设<code>/dev/hda3</code>是本地主机的根目录<code>/</code>所在的分区<br><code>initrd /boot/initrd.img-2.6.15-26-386</code><br><code>boot</code><br>双引号</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-WIKI-GNU GRUB<a href="https://zh.wikipedia.org/wiki/GNU_GRUB" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU_GRUB</code></p></blockquote></li><li><p>EN-GNU 官网<a href="https://www.gnu.org/software/grub/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/grub/</code></p></blockquote></li><li><p>EN-GNU 手册<a href="https://www.gnu.org/software/grub/manual/grub/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnu.org/software/grub/manual/grub/</code></p></blockquote></li><li><p>CN-GRUB 2 中文指南<a href="http://wiki.ubuntu-tw.org/index.php?title=GRUB_2_%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://wiki.ubuntu-tw.org/index.php?title=GRUB_2_%E4%B8%AD%E6%96%87%E6%8C%87%E5%8D%97</code></p></blockquote></li><li><p>CN-GRUB入门教程(Ubantu论坛)<a href="https://forum.ubuntu.org.cn/viewtopic.php?t=2475" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://forum.ubuntu.org.cn/viewtopic.php?t=2475</code></p></blockquote></li><li><p>EN-mmap.page<a href="https://mmap.page/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://mmap.page/</code></p></blockquote></li><li><p>CN-GRUB指令集整合<a href="https://man.linuxde.net/grub" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://man.linuxde.net/grub</code></p></blockquote></li><li><p>CN-Linux命令大全<a href="https://man.linuxde.net/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://man.linuxde.net/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GRUB-简述&quot;&gt;&lt;a href=&quot;#GRUB-简述&quot; class=&quot;headerlink&quot; title=&quot;GRUB 简述&quot;&gt;&lt;/a&gt;GRU
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Disk" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Disk/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Toolchain/GNU toolchain</title>
    <link href="https://unit-serow.github.io/2020/02/27/Toolchain-GNU-toolchain/"/>
    <id>https://unit-serow.github.io/2020/02/27/Toolchain-GNU-toolchain/</id>
    <published>2020-02-27T13:08:35.000Z</published>
    <updated>2020-02-27T14:00:05.546Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="工具链基本概念简述-1"><a href="#工具链基本概念简述-1" class="headerlink" title="工具链基本概念简述-1"></a>工具链基本概念简述-1</h2><ul><li>此模块只做简单的概述与对于概念的浅层理解</li><li>工具环境所需要的包这里不做过多赘述(与工具链无关)</li></ul><hr><h3 id="工具链"><a href="#工具链" class="headerlink" title="工具链"></a>工具链</h3><p><strong>概述:</strong></p><ul><li>Toolchain</li><li>在开发软件过程中，一组工具链(toolchain)是一系列用于制作软件程序的工具</li><li>这些工具一般一个接一个地运用，上一个工具的输出即是下一个工具的输入，因此得名</li><li>但工具链这个词汇也可指涉这些工具并无此相依运行的限制</li><li>工具链与集成开发环境形成对照，分别代表了两种不同风格的软件开发环境</li></ul><p><strong>基本构成:</strong></p><ul><li>通常一个软件开发的工具链由以下组成:</li></ul><ol><li>编译器</li><li>链接器 (将源代码/目标代码转换成可执行程序档)</li><li>库 (提供与操作系统之间的界面)</li><li>调试器 (用来测试、调试所产出的程序)</li></ol><hr><h3 id="GNU-工具链"><a href="#GNU-工具链" class="headerlink" title="GNU 工具链"></a>GNU 工具链</h3><p><strong>概述:</strong></p><ul><li>GNU toolchain</li><li>是一个包含了由GNU计划所产生的各种编程工具的集合，由自由软件基金会负责维护工作</li><li>这些工具形成了一条工具链，用于开发应用程序和操作系统</li><li>同时与集成开发环境相对应</li></ul><p><strong>GNU工具链组成:</strong></p><ul><li>GNU make：用于编译和构建的自动工具</li><li>GNU编译器集合 (GCC) 一组多种编程语言的编译器</li><li>GNU Binutils: 包含链接器、汇编器和其它工具的工具集</li><li>GNU Bison: 编译器编译程序，经常和 Flex词法分析器 配合使用</li><li>GNU m4: m4 宏预处理器</li><li>GNU Debugger (GDB):代码调试工具</li><li>GNU构建系统 (autotools):<blockquote><p>Autoconf<br>Autoheader<br>Automake<br>Libtool</p></blockquote></li><li>GNU C Library: GNU C标准函数库</li><li>GNU Classpath</li></ul><hr><h3 id="交叉工具链"><a href="#交叉工具链" class="headerlink" title="交叉工具链:"></a>交叉工具链:</h3><p><strong>概述:</strong></p><ul><li><p>用于提供编译，链接，处理等功能</p></li><li><p>就是为了编译，链接，处理和调试跨平台体系结构的程序代码</p></li><li><p>每次执行工具链软件时，通过带有不同的参数，可以实现编译，链接，处理或者调试等不同的功能</p></li><li><p>从工具链的组成上来说，它一般由多个程序构成，分别对应着各个功能</p></li><li><p>所谓的交叉工具链是由以下两个概念组合而成的:</p></li></ul><ol><li>交叉编译: 是A机器上编译生成，运行在B机器上<blockquote><p>两个机子有不同的机器指令</p></blockquote></li><li>工具链: 一般由编译器，连接器，解释器和调试器组成</li></ol><hr><h3 id="交叉编译器"><a href="#交叉编译器" class="headerlink" title="交叉编译器:"></a>交叉编译器:</h3><ul><li>是指一个在某个系统平台下可以产生另一个系统平台的可执行文件的编译器</li><li>交叉编译器在目标系统平台(开发出来的应用程序序所运行的平台)难以或不容易编译时非常有用</li><li>交叉编译器的存在对于从一个开发主机为多个平台编译代码是非常有必要的</li><li>直接在平台上编译有时行不通，例如在一个嵌入式系统的单片机 ，因为它们没有操作系统，所以直接编译行不通</li><li>交叉编译器和源代码至源代码编译器不同，交叉编译器用于二进制代码的跨平台软件开发<blockquote><p>而源到源编译器是将某种编程语言的程序源代码作为输入<br>生成以另一种编程语言构成的等效源代码的编译器，但两者都是编程工具</p></blockquote></li><li>交叉编译器的基本用法就是将构建环境与目标环境分开</li><li>常在下面几种情况中使用(具体使用方法这里不做过多赘述):<blockquote><p>嵌入式电脑<br>编译多个目标库<br>引导一个新平台(Bootstrapping)<br>程序虚拟机(比如JVM)</p></blockquote></li></ul><hr><ul><li>工具链用途简述:</li><li>GNU工具链在针对嵌入式系统的Linux内核、BSD及其它软件的开发中起着至关重要的作用</li><li>GNU工具链中的部分工具也被Solaris, Mac OS X, Microsoft Windows (via Cygwin and MinGW/MSYS) and Sony PlayStation 3等其它平台直接使用或进行了移植</li></ul><hr><p><strong>工具链相关概念(关键字):</strong></p><ul><li>工具链</li><li>GNU 工具链</li><li>集成开发环境</li><li>编译器/标准库/链接器/调试器</li><li>交叉编译器</li><li>分布式/并发版本控制系统(CVS,Git等等)</li><li>工具链环境</li></ul><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><p><strong>工具链环境:</strong></p><ul><li>所谓的工具链环境就是:<blockquote><p>不光包含于工具链的基本组件<br>还包含于各类辅助指令所对应的工具与程序的本地系统环境</p></blockquote></li></ul><hr><h3 id="GNU工具链组件完全性参考"><a href="#GNU工具链组件完全性参考" class="headerlink" title="GNU工具链组件完全性参考:"></a>GNU工具链组件完全性参考:</h3><p><strong>基本工具:</strong></p><ul><li>GNU make: 用于编译和构建的自动工具</li><li>GNU编译器集(GCC): 一组多种编程语言的编译器</li><li>GNU Binutils: 包含链接器，汇编器和其它工具的工具集</li><li>GNU调试工具(GDB): 代码调试工具</li><li>GNU自动化生成工具(autotools): 自动化检查软件编译过程的工具</li></ul><hr><p><strong>工具链体系:</strong></p><ul><li>此部分用于描述工具链的相关概念与结构，以实现对工具链实施完整的分析</li><li>本文选取LFS的工具链来说明工具链体系内的软件包组成及依赖关系</li><li>为了使以上不同类别的所属工具形成一个互相关联且互相依赖的工具链体系</li><li>必须安装与配置以下软件包工具与相关程序及源码来构成与实现其工具链体系的依赖关系</li></ul><p><strong>所需软件一览:</strong></p><p><strong>Binutils(汇编器):</strong></p><ul><li>包含的程序:<blockquote><p><code>addr2line，ar，as，c++filt，elfedit，gprof，ld，ld.bfd</code>，<br><code>nm，objcopy，objdump，ranlib，readelf，size，strings 和 strip</code></p></blockquote></li><li>包含的库:<blockquote><p><code>libiberty，libbfd</code> 和 <code>libopcodes</code></p></blockquote></li></ul><p><strong>GCC(编译器):</strong></p><ul><li>包含的程序:<blockquote><p><code>c++，cc(到 gcc 的链接)，cpp，g++，gcc</code>，<br><code>gcc-ar，gcc-nm，gcc-ranlib，gccbug</code> 和 <code>gcov</code></p></blockquote></li><li>包含的库:<blockquote><p><code>libgcc，libgcov，libgomp，liblto_plugin，libmudflap</code>，<br><code>libquadmath，libssp，libstdc++，libsupc++</code></p></blockquote></li><li>依赖的包: <code>gmp，mpfr，mpc</code></li></ul><p><strong>Linux API Headers:</strong></p><ul><li>这个是可选包，如果是为了做一个通用工具链，必须将其换成相应平台的头文件包</li><li>包含的头文件:<blockquote><p><code>/usr/include/asm/*.h</code>，<code>/usr/include/asm-generic/*.h</code>，<br><code>/usr/include/drm/*.h</code>，<code>/usr/include/linux/*.h</code>，<code>/usr/include/mtd/*.h</code>，<br><code>/usr/include/rdma/*.h</code>，<code>/usr/include/scsi/*.h</code>，<br><code>/usr/include/sound/*.h</code>，<code>/usr/include/video/*.h</code>，<code>/usr/include/xen/*.h</code></p></blockquote></li></ul><p><strong>Glibc:</strong></p><ul><li>可以根据标准LFS系统的制作方法来安装Glic(可以大幅度简化实现难度)</li><li>包含的程序:<blockquote><p><code>catchsegv，gencat，getconf，getent，iconv，iconvconfig</code>，<br><code>ldconfig，ldd，lddlibc4，locale, localedef，makedb，mtrace，nscd</code>，<br><code>pcprofiledump，pldd，pt_chown，rpcgen, sln, sotruss, sprof, tzselect, xtrace, zdump 和 zic</code></p></blockquote></li><li>包含的库:<blockquote><p><code>ld.so</code>，<code>libBrokenLocale</code>，<code>libSegFault</code>，<code>libanl</code>，<code>libbsd-compat</code>，<code>libc</code>，<code>libcidn</code>，<code>libcrypt</code>，<br><code>libdl</code>，<code>libg</code>，<code>libieee</code>，<code>libm</code>，<code>libmcheck</code>，<code>libmemusage</code>，<code>libnsl</code>，<code>libnss</code>，<code>libpcprofile</code>，<code>libpthread</code>，<br><code>libresolv</code>，<code>librpcsvc</code>，<code>librt</code>，<code>libthread_db</code>，<code>libutil</code></p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><p>CN-WIKI GNU核心工具组<a href="https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%85%B7%E7%BB%84</code></p></blockquote></li><li><p>CN-WIKI GNU工具链<a href="https://zh.wikipedia.org/wiki/GNU%E5%B7%A5%E5%85%B7%E9%93%BE" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/GNU%E5%B7%A5%E5%85%B7%E9%93%BE</code></p></blockquote></li><li><p>CN-WIKI 交叉工具链<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</code></p></blockquote></li><li><p>百度百科 交叉工具链<a href="https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E5%B7%A5%E5%85%B7%E9%93%BE/2503696" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.baidu.com/item/%E4%BA%A4%E5%8F%89%E5%B7%A5%E5%85%B7%E9%93%BE/2503696</code></p></blockquote></li><li><p>CN-WIKI 交叉编译器<a href="https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BA%A4%E5%8F%89%E7%B7%A8%E8%AD%AF%E5%99%A8</code></p></blockquote></li><li><p>Linux From Scratch (简体中文版/版本: 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Chapter (5.x. 构建临时系统) 与 (5.2. 工具链技术说明)<br><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>工具链技术分析与实现(GNU 工具链)<a href="https://www.cnblogs.com/Leo_wl/p/3405580.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/Leo_wl/p/3405580.html</code></p></blockquote></li></ul><hr><h2 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容"></a>补充内容</h2><h3 id="工具链技术实现"><a href="#工具链技术实现" class="headerlink" title="工具链技术实现"></a>工具链技术实现</h3><ul><li>GNU 工具链</li></ul><h3 id="工具链的使用方式"><a href="#工具链的使用方式" class="headerlink" title="工具链的使用方式"></a>工具链的使用方式</h3><ul><li><p>工具链的目的是提供一个临时可用的编译工作环境，通过chroot来完成在工具环境中进行开发、编译、制作工作</p></li><li><p>为了制作出干净、可移植的工具环境，建议创建一个专用于制作工具链的用户，这也是LFS推荐的</p></li><li><p>在使用工具链之前，此时的本地环境身份应该是root</p></li><li><p>首先挂载虚拟文件系统，然后进入到chroot环境中</p></li></ul><ol><li><strong>挂载虚拟文件系统</strong></li></ol><ul><li><p>可以将以下代码保存为相应的Shell脚本文件，添加执行权限即可使用</p></li><li><p>使用顺序是先挂载虚拟文件系统、后进入chroot环境</p></li><li><p>下方代码只适用于LFS的构建，可根据需求做适当的变量替换，原理和步骤是相同的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">mount -o <span class="built_in">bind</span> /dev <span class="variable">$LFS</span>/dev</span><br><span class="line">mount -t devpts devpts <span class="variable">$LFS</span>/dev/pts -o gid=5,mode=620</span><br><span class="line">mount -t proc proc <span class="variable">$LFS</span>/proc</span><br><span class="line">mount -t sysfs sysfs <span class="variable">$LFS</span>/sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -h <span class="variable">$LFS</span>/dev/shm ]; <span class="keyword">then</span></span><br><span class="line">  link=$(readlink <span class="variable">$LFS</span>/dev/shm)</span><br><span class="line">  mkdir -p <span class="variable">$LFS</span>/<span class="variable">$link</span></span><br><span class="line">  mount -t tmpfs shm <span class="variable">$LFS</span>/<span class="variable">$link</span></span><br><span class="line">  <span class="built_in">unset</span> link</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  mount -t tmpfs shm <span class="variable">$LFS</span>/dev/shm</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>进入到Chroot环境执行以下代码:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">chroot <span class="string">"<span class="variable">$LFS</span>"</span> /tools/bin/env -i \</span><br><span class="line">    HOME=/root                  \</span><br><span class="line">    TERM=<span class="string">"<span class="variable">$TERM</span>"</span>                \</span><br><span class="line">    PS1=<span class="string">'\u:\w\$ '</span>              \</span><br><span class="line">    PATH=/tools/bin:/tools/sbin:/bin:/usr/bin:/sbin:/usr/sbin \</span><br><span class="line">    /tools/bin/bash --login +h</span><br></pre></td></tr></table></figure><hr><ul><li><p>Linux From Scratch (简体中文版/版本: 9.0)<a href="https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf" target="_blank" rel="noopener">跳转</a></p><blockquote><p>Chapter (5.x. 构建临时系统) 与 (5.2. 工具链技术说明)<br><code>https://lctt.github.io/LFS-BOOK/lfs-sysv/LFS-BOOK.pdf</code></p></blockquote></li><li><p>工具链技术分析与实现(GNU 工具链)<a href="https://www.cnblogs.com/Leo_wl/p/3405580.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/Leo_wl/p/3405580.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;工具链基本概念简述-1&quot;&gt;&lt;a href=&quot;#工具链基本概念简述-1&quot; class=&quot;headerlink&quot; title=&quot;工具链基本概念简
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-7</title>
    <link href="https://unit-serow.github.io/2020/02/27/LFS-7/"/>
    <id>https://unit-serow.github.io/2020/02/27/LFS-7/</id>
    <published>2020-02-27T08:53:15.000Z</published>
    <updated>2020-02-27T08:54:57.998Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h3 id="LFS-7"><a href="#LFS-7" class="headerlink" title="LFS-7"></a>LFS-7</h3><ul><li>内核编译等内容</li><li>有关GRUB的内容会再做补充</li></ul><hr><h3 id="相关指令-通用执行逻辑简述"><a href="#相关指令-通用执行逻辑简述" class="headerlink" title="相关指令(通用执行逻辑简述)"></a>相关指令(通用执行逻辑简述)</h3><ul><li>清理编译所处环境的内核依赖树<blockquote><p><code>$makemrpoper</code></p></blockquote></li></ul><hr><ul><li><p>通过菜单驱动的界面配置内核</p></li><li><p>BLFS包含一些有关LFS外部软件包的特定内核配置要求的信息<a href="http://www.linuxfromscratch.org/blfs/view/svn/longindex.html#kernel-config-index" target="_blank" rel="noopener">BLFS-kernel</a></p></li><li><p>基本语法</p><blockquote><p><code>make LANG=&lt;host_LANG_value&gt; LC_ALL= menuconfig</code></p></blockquote></li><li><p>参数含义:</p><blockquote><p>make将语言环境设置建立为主机上使用的语言环境设置(这个参数建立主机上使用的locale设置)<br>UTF-8 的linux文本控制台上的菜单配置ncurses 接口线图需要这个值<br>确保用主机上的<code>$LANG变量代替&lt;host_LANG_value&gt;(还可以说是用主机中变量&lt;host_LANG_value&gt;的值替换$LANG)</code><br>如果主机没有设置，还可以使用<code>$LC_ALL或$LC_CTYPE</code>的值代替</p></blockquote></li><li><p>另外在某一些场合使用<code>$make oldconfig</code>可能更合适</p><blockquote><p>更多信息可参考README文件</p></blockquote></li><li><p>还有一种方法，可以跳过配置内核的步骤</p><blockquote><p>直接把宿主系统里的内核配置文件<code>.config</code>(如果存在的话)复制到解压后的linux-2.6.32.8目录<br>FLS官方说明这里不推荐这么去做<br>考察全部的配置菜单并从头开始创建内核配置是更好的办法</p></blockquote></li></ul><hr><ul><li><p>编译内核映像和所选模块</p><blockquote><p>make</p></blockquote></li><li><p>参数说明</p><blockquote><p>如果使用内核模块，可能需要<code>/etc/modprobe.d</code>目录中的模块配置<br>关于模块和内核配置的信息请参考 Section 7.9内的LFS 系统的设备和模块处理内容和linux-2.6.32.8/Documentation目录的内核文档<br><code>modprobe.conf(5)</code>也可能有用</p></blockquote></li></ul><hr><ul><li><p>如果内核配置使用模块，执行模块安装指令:</p><blockquote><p><code>make modules_install</code></p></blockquote></li><li><p>当内核编译完成后，还需要一些步骤来完成安装</p></li><li><p>比如需要把一些文件拷贝到/boot目录</p></li></ul><hr><ul><li><p>内核镜像文件所在的路径因所处主机使用的平台不同而不同</p></li><li><p>下面的文件名可以更改为符合本地主机的配置</p></li><li><p>但为了与下一节描述的启动过程的自动安装兼容，文件名的词干应该是vmlinux</p></li><li><p>x86平台上运行以下命令:</p><blockquote><p><code>cp -v arch/x86/boot/bzImage /boot/vmlinux-2.6.32.8-lfs-6.6</code></p></blockquote></li><li><p>System.map是内核的符号文件</p></li><li><p>它映射了内核API中每个函数的入口， 以及正在运行内核的数据结构的地址</p></li><li><p>在调查内核问题时，使用它作为一种资源， 运行以下的命令安装此文件:</p><blockquote><p><code>cp -v System.map /boot/System.map-2.6.32.8</code></p></blockquote></li><li><p>上面<code>make menuconfig</code>这一步产生的内核配置文件<code>.config</code>包含了刚刚编译的内核的所有配置选项</p></li><li><p>最好保留这个文件以备将来参考:</p><blockquote><p><code>cp -v .config /boot/config-2.6.32.8</code></p></blockquote></li><li><p>安装Linux内核文档:</p><blockquote><p><code>install -d /usr/share/doc/linux-2.6.32.8</code><br><code>cp -r Documentation/* /usr/share/doc/linux-2.6.32.8</code></p></blockquote></li></ul><hr><p><strong>配置Linux模块装载顺序:</strong></p><ul><li><p>需要创建<code>/etc/modprobe.d/usb.conf</code>文件</p><blockquote><p>以便如果将USB驱动(<code>ehci_hcd， ohci_hcd 和uhci_hcd</code>)编译成模块时，它们会按正确的顺序装载<br>为了避免在启动时出现警告，<code>ehci_hcd</code>必须在<code>ohci_hcd和uhci_hcd</code>之前装载</p></blockquote></li><li><p>通过运行下面的命令来建立一个新文件/etc/modprobe.d/usb.conf:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">install -v -m755 -d <span class="string">/etc/modprobe.d</span></span><br><span class="line">cat &gt; <span class="string">/etc/modprobe.d/usb.conf</span> &lt;&lt; <span class="string">"EOF"</span></span><br><span class="line"><span class="comment"># Begin /etc/modprobe.d/usb.conf</span></span><br><span class="line"></span><br><span class="line">install ohci_hcd <span class="string">/sbin/modprobe</span> ehci_hcd ; <span class="string">/sbin/modprobe</span> -i ohci_hcd ; <span class="literal">true</span></span><br><span class="line">install uhci_hcd <span class="string">/sbin/modprobe</span> ehci_hcd ; <span class="string">/sbin/modprobe</span> -i uhci_hcd ; <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># End /etc/modprobe.d/usb.conf</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>注意事项:</strong></p><ul><li><p>重要的一点是要注意到内核源码目录里的文件所有者不是root</p><blockquote><p>只要是用 root(像在chroot环境里做的那样)用户解压软件包，解压出来的文件的用户和组ID是这个软件包打包者计算机上的用户和组ID<br>对于其它软件包， 这通常不是问题， 因为安装完这些软件包之后源码目录就删除了<br>但是 Linux 内核源码树常常会保存很长的时间， 这样就有可能打包者的用户 ID 和您计算机上某个用户的 ID 相同<br>从而让您计算机上的这个用户获得了内核源码的写权限</p></blockquote></li><li><p>如果准备保留内核源代码，在<code>linux-2.6.32.8</code>目录上执行<code>chown -R 0:0</code>命令以确保全部文件的所有者是<code>root</code></p></li><li><p>一些内核文档建议建立一个从<code>/usr/src/linux</code>指向源码目录的符号链接</p><blockquote><p>这只是一个对 2.6 以前版本内核的特殊要求，并且在 LFS 系统上是不允许这样做的<br>因为基本的LFS系统完成以后，安装其他软件包时可能会因此而引起问题</p></blockquote></li><li><p>系统include目录中的头问题件应该总是保持Glibc编译时的那个版本</p><blockquote><p>这也是Linux内核tar包中的干净的头文件<br>因而，它们绝不要被替换成原始的内核头文件和其他干净的头文件</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><ul><li><p>LFS-v6.3<a href="http://www.linuxfromscratch.org/lfs/view/6.3/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/</code></p></blockquote></li><li><p>LFS-v9.3 重新启动系统<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter09/reboot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter09/reboot.html</code></p></blockquote></li><li><p>CSDN参考资料<a href="https://blog.csdn.net/Sugar_girl/article/details/78713316" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/Sugar_girl/article/details/78713316</code></p></blockquote></li><li><p>LFS内核配置全面信息<a href="http://www.linuxfromscratch.org/hints/downloads/files/kernel-configuration.txt" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/hints/downloads/files/kernel-configuration.txt</code></p></blockquote></li><li><p>LFS-v6.3-第八章第三节<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html</code></p></blockquote></li><li><p>Beyond Linux From Scratch (System V Edition) - Version 2020-02-27<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/blfs/view/svn/longindex.html#kernel-config-index</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;LFS-7&quot;&gt;&lt;a href=&quot;#LFS-7&quot; class=&quot;headerlink&quot; title=&quot;LFS-7&quot;&gt;&lt;/a&gt;LFS-7&lt;/h3
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-6</title>
    <link href="https://unit-serow.github.io/2020/02/26/LFS-6/"/>
    <id>https://unit-serow.github.io/2020/02/26/LFS-6/</id>
    <published>2020-02-26T12:38:21.000Z</published>
    <updated>2020-02-26T12:40:18.873Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="LFS-6"><a href="#LFS-6" class="headerlink" title="LFS-6"></a>LFS-6</h2><hr><h3 id="LFS实现逻辑补充"><a href="#LFS实现逻辑补充" class="headerlink" title="LFS实现逻辑补充"></a>LFS实现逻辑补充</h3><p><strong>LFS的实现大致可分为以下四个阶段:</strong></p><ul><li>一阶段</li></ul><p>1.创建目标系统目录<br>2.创建临时系统目录</p><ul><li>二阶段</li></ul><p>3.建立预工具链</p><ul><li>三阶段</li></ul><p>4.建立临时系统<br>5.建立目标工具链</p><ul><li>四阶段</li></ul><p>6.建立目标系统<br>7.收尾工作</p><hr><h2 id="临时系统"><a href="#临时系统" class="headerlink" title="临时系统"></a>临时系统</h2><ol start="3"><li><strong>建立预工具链</strong></li></ol><ul><li><p>预工具链</p></li><li><p>汇编器Binutils，编译器GCC，标准库Glibc</p></li><li><p>以及主系统(内核头接口/API headers)</p><blockquote><p>API headers/GCC/BIN/GLI</p></blockquote></li><li><p>调整工具链</p><blockquote><p>每次安装完工具链想用工具集时都需要适当的调整工具链并对工具链进行测试</p></blockquote></li><li><p>Glibc编译过程中需要设置内核版本参数(可忽略小版本只写大版本)</p></li><li><p>二次安装工具目录(GCC/Bintils)</p></li><li><p>Tcl-v8.4</p></li><li><p>Expect-v5.4</p></li><li><p>DejaGNU-v1.4</p></li><li><p>GCC-Pass2</p></li><li><p>Binutils-Pass2</p></li><li><p>其它辅助程序(工具)</p></li><li><p>Tcl/Expect/DejaGNU为代码(二进制)编译文件测试工具</p><blockquote><p><code>$make check</code></p></blockquote></li></ul><hr><h3 id="预工具链安装逻辑"><a href="#预工具链安装逻辑" class="headerlink" title="预工具链安装逻辑:"></a>预工具链安装逻辑:</h3><ol><li>Binutils-2.17 - Pass 1</li><li>GCC-4.1.2 - Pass 1</li><li>Linux-2.6.22.5 API Headers</li><li>Glibc-2.5.1</li><li>Adjusting the Toolchain(调整工具链)</li><li>Tcl-8.4.15</li><li>Expect-5.43.0</li><li>DejaGNU-1.4.4</li><li>GCC-4.1.2 - Pass 2</li><li>Binutils-2.17 - Pass 2</li><li>其它辅助工具</li></ol><hr><p><strong>所对应LFS内章节内容:</strong></p><ol start="5"><li>Constructing a Temporary System(建立一个临时系统)</li></ol><ul><li>Introduction (介绍与说明)</li><li>Toolchain Technical Notes (工具链技术说明)</li><li>Binutils-2.17 - Pass 1 (汇编器)</li><li>GCC-4.1.2 - Pass 1 (编译器)</li><li>Linux-2.6.22.5 API Headers (内核接口)</li><li>Glibc-2.5.1 (标准库)</li><li>至</li><li>Util-linux-2.12r (UTIL)</li><li>Stripping (抛离)</li><li>Changing Ownership (改变所有权)</li><li>临时系统建立至此截止</li></ul><hr><h2 id="目标系统"><a href="#目标系统" class="headerlink" title="目标系统"></a>目标系统</h2><p><strong>第一步(进行必要配置):</strong></p><ol><li>建立目标系统的文件目录结构</li><li>创建与配置必要软链接</li><li>创建root及nobody用户和必要的组</li><li>此时可以选择是否重新加载bash</li><li>加载以使root用户起效</li><li>创建和设置几个临时文件和日志文件</li></ol><p><strong>第二步(建立目标工具链):</strong></p><ul><li>包括安装逻辑说明</li><li>Linux-2.6.22.5 API Headers - 1</li><li>Man-pages-2.63 - 2</li><li>Glibc-2.5.1 - 3</li><li>Re-adjusting the Toolchain(工具链调试) - 4</li><li>Binutils-2.17 - 5</li><li>GCC-4.1.2 - 6</li><li>其它辅助工具 (Shell/Bash，M4，Autotools等等) - 7</li><li>至此，一直到所有软件安装完毕后，进行工具链调试(v6.3的FSL中最后一个工具通常是vim)</li><li>之后退出chroot环境，设置启动脚本</li><li>下一步即为第七章-设置系统启动脚本然后进行最终的内核编译(Kernel Compile)</li></ul><hr><h3 id="建立目标工具链以及目标工具链环境"><a href="#建立目标工具链以及目标工具链环境" class="headerlink" title="建立目标工具链以及目标工具链环境:"></a>建立目标工具链以及目标工具链环境:</h3><p><strong>参考章节</strong></p><p><strong>三.建立LFS系统(III.Building the LFS System)</strong></p><ol start="6"><li>Installing Basic System Software (6.安装基本系统软件)</li></ol><ul><li>Introduction (介绍)</li><li>Preparing Virtual Kernel File Systems (准备虚拟内核文件系统)</li><li>Package Management (包装管理)</li><li>Entering the Chroot Environment (进入Chroot环境)</li><li>Creating Directories (创建目录)</li><li>Creating Essential Files and Symlinks (创建基本文件和符号链接)</li><li>Linux-2.6.22.5 API Headers (Linux-2.6.22.5 API标头)</li><li>Man-pages-2.63 (Man-帮助手册)</li><li>Glibc-2.5.1 (标准库)</li><li>Re-adjusting the Toolchain (重新调整工具链)</li><li>Binutils-2.17 (汇编器)</li><li>GCC-4.1.2 (编译器)</li><li>至</li><li>About Debugging Symbols (调试符相关内容)</li><li>Stripping Again (再次抛离)</li><li>Cleaning Up (清理环境)</li><li>目标系统环境已搭建完毕</li></ul><hr><h3 id="系统启动脚本设置与编译-包括编写"><a href="#系统启动脚本设置与编译-包括编写" class="headerlink" title="系统启动脚本设置与编译(包括编写)"></a>系统启动脚本设置与编译(包括编写)</h3><p><strong>参考自LFS英文版第七章内容:</strong><br><strong>7. Setting Up System Bootscripts</strong></p><ul><li>介绍 (Introduction)</li><li>LFS-Bootscripts-6.3 (LFS-boot 脚本)</li><li>至</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li></ul><p><strong>配置逻辑说明:</strong></p><ol><li>编译并安装 LFS-Bootscripts-6.3 (LFS-Bootscripts-6.3)</li><li>配置LFS系统上的设备和模块处理 (Device and Module Handling on an LFS System)</li><li>配置setclock脚本 (Configuring the setclock Script)</li><li>配置Linux控制台 (Configuring the Linux Console)</li><li>配置sysklogd脚本 (Configuring the sysklogd Script)</li><li>创建/etc/inputrc文件 (Creating the /etc/inputrc File)</li><li>Bash Shell启动文件 (The Bash Shell Startup Files)</li><li>配置本地网脚本 (Configuring the localnet Script)</li><li>定制/etc/hosts文件 (Customizing the /etc/hosts File)</li><li>创建到设备的自定义符号链接 (Creating Custom Symlinks to Devices)</li><li>配置网络脚本 (Configuring the network Script)</li></ol><ul><li>至此结束系统启动脚本配置，下一步即为内核编译</li></ul><hr><h3 id="配置LFS系统引导项-内核编译"><a href="#配置LFS系统引导项-内核编译" class="headerlink" title="配置LFS系统引导项(内核编译)"></a>配置LFS系统引导项(内核编译)</h3><p><strong>参考自FLS文档第八章</strong><br><strong>8. Making the LFS System Bootable</strong></p><p><strong>配置逻辑介绍(参考内容):</strong></p><ol><li>介绍 (Introduction)</li><li>创建/etc /fstab文件 (Creating the /etc/fstab File)</li><li>Linux-2.6.22.5 (Linux-2.6.22.5编译，配置并安装)</li><li>使LFS系统可启动 (Making the LFS System Bootable)</li></ol><ul><li>相关指令集可参考官方文档</li><li>有关第三项的详细说明与配置参考下一篇文章</li></ul><hr><p><strong>其它内容:</strong></p><ul><li>具体配置内容与描述可参考官方文档(EN/CN)</li><li>这里使用的是LFS官方的LiveCD，官方早已停止维护，所以版本已经很老了</li><li>最新的版本是<code>lfslivecd-x86_64-6.3-r2145.iso</code>(614.510KB)-2007</li><li>这里使用的版本是<code>lfslivecd-x86-6.3-r2145.iso</code>(32位版本/648.638KB)-2007</li><li>在<a href="http://unit-serow.com/2020/02/22/LFS-1/#more" target="_blank" rel="noopener">LFS-1</a>这篇文章内有有关LFS所有资料的链接<blockquote><p><code>http://unit-serow.com/2020/02/22/LFS-1/#more</code></p></blockquote></li></ul><hr><ul><li>对于目标系统中的任何工具的编译完成之后，最好进行编译文件(二进制文件)测试是否正确且可用</li><li>即便有错误，只要不是太多或可以通过下一步的应用测试，就可以先无视掉</li><li>等到目标系统内核建立并编译完成之后再对目标Debug进行修补与维护</li><li>测试指令(测试动态链接库): <code>$make check</code></li><li>测试时间长短由工具决定</li><li>有些二进制包在测试时可能会发生几处无关紧要的错误，但不会影响安装和正常使用<blockquote><p>比如类似于找不到man的动态链接库之类的错误</p></blockquote></li><li>有时测试不能顺利结束，可以根据报错来判断问题所在<blockquote><p>多半是文件依赖，动态库，文件映射或配置文件缺失等问题</p></blockquote></li></ul><hr><h3 id="需调整工具链"><a href="#需调整工具链" class="headerlink" title="需调整工具链:"></a>需调整工具链:</h3><ul><li><p>工具链一(预/临时工具链):</p><blockquote><p>预工具链与临时工具链(GCC/Glibc/Binutils/Linux Kernel API Headers)<br>调整specs文件<br>调试与测试所属工具链环境</p></blockquote></li><li><p>工具链二(目标工具链):</p><blockquote><p>目标工具链(GCC/Glibc/Linux Kernel API Headers/Binutils/Man-pages)<br>调整specs文件<br>调试与测试所属工具链环境</p></blockquote></li><li><p>最后执行Strip命令并进入新的chroot环境</p></li><li><p>即为拥有两次抛离过程</p><blockquote><p>第一次是主系统-临时系统<br>第二次是临时系统-目标系统<br>最后保证目标系统可以独立运行并将其独立(完全抛离原系统)</p></blockquote></li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>具体的配置代码与安装代码可参考LFS官方中/英文书籍</li><li>CN-参考资料FSL为6.3版本<a href="http://www.linuxfromscratch.org/lfs/view/6.3/index.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/index.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-6&quot;&gt;&lt;a href=&quot;#LFS-6&quot; class=&quot;headerlink&quot; title=&quot;LFS-6&quot;&gt;&lt;/a&gt;LFS-6&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>LFS-5</title>
    <link href="https://unit-serow.github.io/2020/02/26/LFS-5/"/>
    <id>https://unit-serow.github.io/2020/02/26/LFS-5/</id>
    <published>2020-02-25T20:21:50.000Z</published>
    <updated>2020-02-28T03:11:00.406Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --><h2 id="LFS-5"><a href="#LFS-5" class="headerlink" title="LFS-5"></a>LFS-5</h2><ul><li>应用笔记以及经验总结</li></ul><hr><h3 id="首要逻辑说明"><a href="#首要逻辑说明" class="headerlink" title="首要逻辑说明:"></a>首要逻辑说明:</h3><ul><li>编译工具就是汇编工具与语言编译器(Binutils/GCC)</li><li>汇编工具，语言编译器，对应语言标准库被合称为工具链(Binutils/GCC/Glibc)<blockquote><p>工具链的配置即为以上三个工具的配置<br>因为让编译工具生成可执行文件需要对应标准库，所以这里将标准库算到工具链内(严格来说标准库并不是工具)</p></blockquote></li><li>辅助命令</li><li>文件(目录)映射</li></ul><hr><ol><li>创建目标系统目录</li><li>创建临时系统目录</li><li>建立预工具链</li><li>建立临时系统</li><li>建立目标工具链</li><li>建立目标系统</li><li>收尾工作</li></ol><hr><p><strong>作用解释:</strong></p><ul><li><code>CC=&quot;gcc -B/usr/bin&quot;</code></li><li>在第一遍编译GCC中是调用/tools内的gcc<blockquote><p>调用GCC作为编译器，指定GCC运行环境为/usr/bin</p></blockquote></li><li>在第一遍编译Binutils时是调用/tools内的GCC，接下来指定链接器指向</li><li>在第二遍编译Binutils中是在调用host中的GCC</li></ul><hr><p><strong>注意事项(相关内容):</strong></p><ul><li>设置工具链的时候必须保证工具处于可用状态</li><li>有些程序和工具可能需要编译及安装两遍以上</li><li>在目标机器内Glibc的测试比较容易出现错误，比如机器慢就有可能出现超时的错误<blockquote><p>还有一些能引起错误的LFS手册上有所提及<br>类似于超时这种 错误有时候很难避免<br>只能跳过去或进行多次编译以及安装</p></blockquote></li><li>跳过对于目标机器内Glibc及其工具链的测试</li><li>有一两个Error就忽略吧</li><li>测试代码并统计<blockquote><p><code>$make check</code><br>测试统计有可能会出现个别失败<br>有时会完全成功</p></blockquote></li><li>参考资料均来自十年前(最少)</li><li>参考资料本身没什么太大问题</li></ul><hr><h3 id="问题一览"><a href="#问题一览" class="headerlink" title="问题一览"></a>问题一览</h3><ul><li>待解决问题<blockquote><p>v6.2 无内核头部配置文件<br>v6.3 第二次编译C函数库(Glibc)时出错<br>v6.3 目标工具链-Binutils编译出现错误，没有通过测试，并且已无视<br>v6.3 目标工具链-GCC编译出现几处错误，但不影响使用并已成功通过安装测试与应用测试<br>v6.3 测试Automake-1.10工具源代码编译文件时出现三个错误，但无伤大雅<br>v6.3 Linux内核编译出现问题(kernel version:2.6.22.5)<br>v6.3 找不到GCC</p></blockquote></li></ul><hr><ul><li>目标机器内的Glibc标准函数库测试错误问题已解决</li><li>目标机器内的GCC编译器问题已解决</li><li>目标工具链内的GCC安装与应用测试成功</li><li>编译Coreutils-6.9出现两处Error<blockquote><p>动态链接库测试中编译帮助文件<code>man目录</code>失效<br><code>BEGIN failed--compilation aborted at ./help2man line 28</code><br>离开<code>*/man</code>目录<br>已经无视，并且进行代码测试后也是这个问题</p></blockquote></li><li>Procps-3.2.7(Top)<blockquote><p><code>collect2: ld returned 1 exit status</code><br>make停止<br>安装失败</p></blockquote></li><li>Perl-5.8.8<blockquote><p>动态链接库测试中编译出现两条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Readline-5.2<blockquote><p>动态链接库测试中编译出现一条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Automake-1.10<blockquote><p>动态链接库测试中编译出现三条错误<br>并不妨碍正常编译安装，并且编译安装成功</p></blockquote></li><li>Psmisc-22.5<blockquote><p>cannot find tinfo，ncurses or termcap libraries<br>无法找到无法找到tinfo、ncurses或termcap库<br>编译失败</p></blockquote></li><li>Udev-113<blockquote><p>make test测试与安装无错误</p></blockquote></li><li>到达第七章与第八章之间的退出chroot出现问题<blockquote><p>根据LFS官方手册配置，进入新的系统环境下GCC丢失<br>未解决</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>开源中国<a href="https://www.oschina.net/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.oschina.net/</code></p></blockquote></li></ul><hr><ul><li>LFS注册<a href="http://www.linuxfromscratch.org/cgi-bin/lfscounter.php" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/cgi-bin/lfscounter.php</code></p></blockquote></li></ul><hr><ul><li>LFS-6.3版本<a href="http://www.linuxfromscratch.org/lfs/view/6.3/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/</code></p></blockquote></li></ul><hr><ul><li>LFS-6.3内核编译(kernel version:2.6.22.5)<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html" target="_blank" rel="noopener">跳转</a><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter08/kernel.html</code></p></blockquote></li></ul><hr><ul><li>冲天飞豹Blog(已经挂了)<blockquote><p><code>http://youbest.cublog.cn/</code></p></blockquote></li></ul><hr><ul><li>LFS-PDF<a href="https://pan.baidu.com/s/1nZARmQlO63fh5BVGug4gPg" target="_blank" rel="noopener">跳转</a><blockquote><p>链接:<code>https://pan.baidu.com/s/1nZARmQlO63fh5BVGug4gPg</code><br>提取码:414z</p></blockquote></li></ul><hr><h3 id="重要工具与程序简述-小部分-最新版本"><a href="#重要工具与程序简述-小部分-最新版本" class="headerlink" title="重要工具与程序简述(小部分/最新版本):"></a>重要工具与程序简述(小部分/最新版本):</h3><ul><li><p>Glibc (2.30) - 16,189 KB:</p><blockquote><p>主页: <code>http://www.gnu.org/software/libc/</code><br>下载: <code>http://ftp.gnu.org/gnu/glibc/glibc-2.30.tar.xz</code><br>MD5 校验和: <code>2b1dbdf27b28620752956c061d62f60c</code></p></blockquote></li><li><p>GCC (9.2.0) - 68,953 KB:</p><blockquote><p>主页: <code>https://gcc.gnu.org/</code><br>下载: <code>http://ftp.gnu.org/gnu/gcc/gcc-9.2.0/gcc-9.2.0.tar.xz</code><br>MD5 校验和: <code>3818ad8600447f05349098232c2ddc78</code></p></blockquote></li><li><p>Linux (5.2.8) - 104,555 KB:</p><blockquote><p>主页: <code>https://www.kernel.org/</code><br>下载: <code>https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.2.8.tar.xz</code><br>MD5 校验和: <code>602dd0ecb8646e539fefb2beb6eb6fe0</code></p></blockquote></li><li><p>Binutils (2.32) - 20,288 KB:</p><blockquote><p>主页: <code>http://www.gnu.org/software/binutils/</code><br>下载: <code>http://ftp.gnu.org/gnu/binutils/binutils-2.32.tar.xz</code><br>MD5 校验和: <code>0d174cdaf85721c5723bf52355be41e6</code></p></blockquote></li><li><p>GRUB (2.04) - 6,245 KB:</p><blockquote><p>主页: <code>http://www.gnu.org/software/grub/</code><br>下载: <code>https://ftp.gnu.org/gnu/grub/grub-2.04.tar.xz</code><br>MD5 校验和: <code>5aaca6713b47ca2456d8324a58755ac7</code></p></blockquote></li><li><p>LFS-Bootscripts (20190524) - 32 KB:</p><blockquote><p>下载: <code>http://www.linuxfromscratch.org/lfs/downloads/9.0/lfs-bootscripts-20190524.tar.xz</code><br>MD5 校验和: <code>c91b11e366649c9cec60c2552820fed5</code></p></blockquote></li></ul><hr><ul><li><p>Autoconf (2.69) - 1,186 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/autoconf/" target="_blank" rel="noopener">http://www.gnu.org/software/autoconf/</a><br>下载： <a href="http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.xz</a><br>MD5 校验和： 50f97f4159805e374639a73e2636f22e</p></blockquote></li><li><p>Automake (1.16.1) - 1,499 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/automake/" target="_blank" rel="noopener">http://www.gnu.org/software/automake/</a><br>下载： <a href="http://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/automake/automake-1.16.1.tar.xz</a><br>MD5 校验和： 53f38e7591fa57c3d2cee682be668e5b</p></blockquote></li><li><p>Bash (5.0) - 9,898 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/bash/" target="_blank" rel="noopener">http://www.gnu.org/software/bash/</a><br>下载： <a href="http://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/bash/bash-5.0.tar.gz</a><br>MD5 校验和： 2b44b47b905be16f45709648f671820b</p></blockquote></li><li><p>File (5.37) - 867 KB:</p><blockquote><p>主页： <a href="https://www.darwinsys.com/file/" target="_blank" rel="noopener">https://www.darwinsys.com/file/</a><br>下载： <a href="ftp://ftp.astron.com/pub/file/file-5.37.tar.gz" target="_blank" rel="noopener">ftp://ftp.astron.com/pub/file/file-5.37.tar.gz</a><br>MD5 校验和： 80c29aca745466c6c24d11f059329075</p></blockquote></li><li><p>Libtool (2.4.6) - 951 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/libtool/" target="_blank" rel="noopener">http://www.gnu.org/software/libtool/</a><br>下载： <a href="http://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.xz</a><br>MD5 校验和： 1bfb9b923f2c1339b4d2ce1807064aa5</p></blockquote></li><li><p>M4 (1.4.18) - 1,180 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/m4/" target="_blank" rel="noopener">http://www.gnu.org/software/m4/</a><br>下载： <a href="http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.xz</a><br>MD5 校验和： 730bb15d96fffe47e148d1e09235af82</p></blockquote></li><li><p>Make (4.2.1) - 1,932 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/make/" target="_blank" rel="noopener">http://www.gnu.org/software/make/</a><br>下载： <a href="http://ftp.gnu.org/gnu/make/make-4.2.1.tar.gz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/make/make-4.2.1.tar.gz</a><br>MD5 校验和： 7d0dcb6c474b258aab4d54098f2cf5a7</p></blockquote></li><li><p>OpenSSL (1.1.1c) - 8,657 KB:</p><blockquote><p>主页： <a href="https://www.openssl.org/" target="_blank" rel="noopener">https://www.openssl.org/</a><br>下载： <a href="https://www.openssl.org/source/openssl-1.1.1c.tar.gz" target="_blank" rel="noopener">https://www.openssl.org/source/openssl-1.1.1c.tar.gz</a><br>MD5 校验和： 15e21da6efe8aa0e0768ffd8cd37a5f6</p></blockquote></li></ul><hr><ul><li><p>Gawk (5.0.1) - 3,063 KB:</p><blockquote><p>主页： <a href="http://www.gnu.org/software/gawk/" target="_blank" rel="noopener">http://www.gnu.org/software/gawk/</a><br>下载： <a href="http://ftp.gnu.org/gnu/gawk/gawk-5.0.1.tar.xz" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/gawk/gawk-5.0.1.tar.xz</a><br>MD5 校验和： f9db3f6715207c6f13719713abc9c707</p></blockquote></li><li><p>Util-linux (2.34) - 4,859 KB:</p><blockquote><p>主页： <a href="http://freecode.com/projects/util-linux" target="_blank" rel="noopener">http://freecode.com/projects/util-linux</a><br>下载： <a href="https://www.kernel.org/pub/linux/utils/util-linux/v2.34/util-linux-2.34.tar.xz" target="_blank" rel="noopener">https://www.kernel.org/pub/linux/utils/util-linux/v2.34/util-linux-2.34.tar.xz</a><br>MD5 校验和： a78cbeaed9c39094b96a48ba8f891d50</p></blockquote></li><li><p>Zlib (1.2.11) - 457 KB:</p><blockquote><p>主页： <a href="https://www.zlib.net/" target="_blank" rel="noopener">https://www.zlib.net/</a><br>下载： <a href="https://zlib.net/zlib-1.2.11.tar.xz" target="_blank" rel="noopener">https://zlib.net/zlib-1.2.11.tar.xz</a><br>MD5 校验和： 85adef240c5f370b308da8c938951a68</p></blockquote></li></ul><hr><p><strong>补丁:</strong></p><ul><li><p>Coreutils 国际化修复补丁 - 168 KB:</p><blockquote><p>下载： <a href="http://www.linuxfromscratch.org/patches/lfs/9.0/coreutils-8.31-i18n-1.patch" target="_blank" rel="noopener">http://www.linuxfromscratch.org/patches/lfs/9.0/coreutils-8.31-i18n-1.patch</a><br>MD5 校验和： a9404fb575dfd5514f3c8f4120f9ca7d</p></blockquote></li><li><p>Glibc FHS 补丁 - 2.8 KB:</p><blockquote><p>下载： <a href="http://www.linuxfromscratch.org/patches/lfs/9.0/glibc-2.30-fhs-1.patch" target="_blank" rel="noopener">http://www.linuxfromscratch.org/patches/lfs/9.0/glibc-2.30-fhs-1.patch</a><br>MD5 校验和： 9a5997c3452909b1769918c759eff8a2</p></blockquote></li></ul><hr><h3 id="已解决问题一览"><a href="#已解决问题一览" class="headerlink" title="已解决问题一览"></a>已解决问题一览</h3><ul><li>如果实在找不到GCC且有难以解决的问题，可以先利用已有的临时主机中的/tools目录来对目标主机进行错误与空白修补</li><li>各参数作用这里不做过多赘述，可参考LFS官方手册</li></ul><hr><ul><li>参考自LFS-v6.3版本第6.4-Entering the Chroot Environment至6.59-Stripping Again章节</li><li>第七章末尾找不到GCC的问题已解决<blockquote><p>需要先完全配置才能去抛离上一级系统目录环境(此时需要脱离的是临时系统)<br>在第六章开头理解出问题了<br>在查询了FSL官方的英文文档之后<br>发现退出chroot的代码只需要执行一遍<br>chroot及附带配置的作用是抛离前(是属于目标系统的)的配置<br>使用Strip对文件(二进制压缩包)进行清理</p></blockquote></li></ul><p><strong>可参考以下指令:</strong></p><ol><li><p>退出chroot环境:</p><blockquote><p><code>$logout</code></p></blockquote></li><li><p>为Strip而进入chroot环境:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chroot <span class="variable">$LFS</span> /tools/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM=$TERM PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span> \</span><br><span class="line">    /tools/bin/bash --login</span><br></pre></td></tr></table></figure></li><li><p>Strip:</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tools/bin/find /&#123;,usr/&#125;&#123;bin,<span class="class"><span class="keyword">lib</span>,<span class="title">sbin</span>&#125; -<span class="title">type</span> <span class="title">f</span> \</span></span><br><span class="line">  -exec /tools/bin/strip --strip-debug <span class="string">'&#123;&#125;'</span> <span class="string">';'</span></span><br></pre></td></tr></table></figure></li></ol><hr><ul><li>摘选自LFS-v6.3/EN-CN(翻译)<blockquote><p>A large number of files will be reported as having their file format not recognized.<br>These warnings can be safely ignored.<br>These warnings indicate that those files are scripts instead of binaries.</p></blockquote></li><li>翻译内容:<blockquote><p>大量文件将被报告为文件格式无法识别<br>可以安全地忽略这些警告<br>这些警告表明这些文件是脚本而不是二进制文件</p></blockquote></li></ul><hr><p><strong>补充内容:</strong></p><ul><li><p>摘选自FSL官方文档:</p><blockquote><p>From now on, when reentering the chroot environment after exiting, use the following modified chroot command:</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chroot <span class="string">"$LFS"</span> /usr/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM="$TERM" PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span> \</span><br><span class="line">    /bin/bash --login</span><br></pre></td></tr></table></figure><blockquote><p>The reason for this is that the programs in /tools are no longer needed. Since they are no longer needed you can delete the /tools directory if so desired.</p></blockquote></li><li><p>翻译内容:</p><blockquote><p>从现在开始，退出后重新进入chroot环境时，请使用以下修改后的chroot命令：<br>这样做的原因是/tools不再需要其中的程序<br>因为不再需要它们，所以可以根据需要来决定是否去删除/tools目录</p></blockquote></li></ul><hr><p><strong>补充内容:</strong></p><ul><li>6.4章节中描述的带有临时机器中的/tools文件夹的目标机器<blockquote><p>It is time to enter the chroot environment to begin building and installing the final LFS system. As user root, run the following command to enter the realm that is, at the moment, populated with only the temporary tools:</p></blockquote></li><li>翻译内容:<blockquote><p>现在是时候进入chroot环境开始构建和安装最终的LFS系统了<br>以user root身份，运行以下命令以输入当前仅由临时工具填充的领域:</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chroot <span class="string">"$LFS"</span> /tools/bin/env -i \</span><br><span class="line">    HOME=<span class="regexp">/root TERM="$TERM" PS1='\u:\w\$ ' \</span></span><br><span class="line"><span class="regexp">    PATH=/bin</span><span class="symbol">:/usr/bin</span><span class="symbol">:/sbin</span><span class="symbol">:/usr/sbin</span><span class="symbol">:/tools/bin</span> \</span><br><span class="line">    /tools/bin/bash --login +h</span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>重点内容-1</strong></p><ul><li>6.2.章节 准备虚拟内核文件系统</li><li>6.22章节 挂载和激活/dev</li></ul><hr><p><strong>解决思路:</strong></p><ul><li>把/tools的内容转到<code>/usr</code>内<blockquote><p>为什么<code>cc/gcc</code>工具会不生效<br><code>GCC/Binutils/Glibc/Linux-2.6.22.5</code>已成功编译并安装入目标主机的<code>/usr</code>或<code>/usr/bin</code>文件目录内<br>每次的重新开始都是对经验的不断累积</p></blockquote></li><li>孙海勇在LinuxSir上的LFS教程-26-27页与29页</li><li><code>LFS 7.4 chapter 6.7: make: gcc: Command not found</code><a href="https://unix.stackexchange.com/questions/110184/lfs-7-4-chapter-6-7-make-gcc-command-not-found" target="_blank" rel="noopener">跳转</a><blockquote><p>LFS 7.4-第6.7章:make: gcc: 找不到命令<br><code>https://unix.stackexchange.com/questions/110184/lfs-7-4-chapter-6-7-make-gcc-command-not-found</code></p></blockquote></li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>6.4 Entering the Chroot Environment<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/chroot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/chroot.html</code></p></blockquote></li><li><p>6.59. Stripping Again<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/strippingagain.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/strippingagain.html</code></p></blockquote></li><li><p>6.60. Cleaning Up<a href="http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/revisedchroot.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/view/6.3/chapter06/revisedchroot.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:37 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;LFS-5&quot;&gt;&lt;a href=&quot;#LFS-5&quot; class=&quot;headerlink&quot; title=&quot;LFS-5&quot;&gt;&lt;/a&gt;LFS-5&lt;/h2
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>GNU Privacy Guard/GPG-1</title>
    <link href="https://unit-serow.github.io/2020/02/24/GPG-1/"/>
    <id>https://unit-serow.github.io/2020/02/24/GPG-1/</id>
    <published>2020-02-24T10:17:18.000Z</published>
    <updated>2020-02-24T10:18:52.880Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="GNU-Privacy-Guard-GPG-1"><a href="#GNU-Privacy-Guard-GPG-1" class="headerlink" title="GNU Privacy Guard/GPG-1"></a>GNU Privacy Guard/GPG-1</h2><h3 id="简要概述与参考资料整理"><a href="#简要概述与参考资料整理" class="headerlink" title="简要概述与参考资料整理"></a>简要概述与参考资料整理</h3><ul><li><p>数据完整性(Data integrity)</p></li><li><p>使用工具:</p></li><li><p>GPG(GNU Privacy Guard)</p><blockquote><p>Linux GPG<br>GNU PG</p></blockquote></li></ul><hr><h3 id="命令简述"><a href="#命令简述" class="headerlink" title="命令简述:"></a>命令简述:</h3><ul><li><p>生成密钥</p><blockquote><p><code>$gpg --gen-key</code><br>安装提示对密钥进行配置</p></blockquote></li><li><p>列出密钥</p><blockquote><p><code>$gpg --list-keys</code></p></blockquote></li><li><p>删除密钥</p><blockquote><p><code>gpg --delete-key [用户ID]</code></p></blockquote></li><li><p>输入密钥</p><blockquote><p><code>gpg --import [密钥文件]</code></p></blockquote></li><li><p>加密文件</p><blockquote><p><code>gpg --recipient [用户ID] --output [file name] --encrypt [file name]</code></p></blockquote></li><li><p>解密并输出内容</p><blockquote><p><code>gpg [file name]</code></p></blockquote></li><li><p>文件签名(二进制存储)</p><blockquote><p><code>gpg --sign [file name]</code></p></blockquote></li><li><p>文件签名(ASCII码存储)</p><blockquote><p><code>gpg --clearsign [file name]</code></p></blockquote></li><li><p>生成单独的签名文件(二进制存储)</p><blockquote><p><code>gpg --detach-sign [file name]</code></p></blockquote></li><li><p>生成单独的签名文件(ASCII码存储)</p><blockquote><p><code>gpg --armor --detach-sign [file name]</code></p></blockquote></li><li><p>验证签名</p><blockquote><p><code>gpg --verify [file name].[asc] [file name]</code></p></blockquote></li><li><p>等等</p></li></ul><hr><p><strong>其它说明:</strong></p><ul><li>方括号为可选参数</li><li>这里的数据完整性以数据签名实现</li><li>压缩所选文件或目录并进行哈希加密实现数字签名</li><li>不进行压缩进行数字加密</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>GPG</li><li>PGP</li><li>GPG2</li><li>RSA加密算法(对称加密算法)</li><li>数据校检</li><li>数字签名</li><li>数据完整性</li><li>软件包签名</li><li>压缩文件签名</li><li>数据库数据完整性</li><li>文件目录数据完整性</li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><strong>以下内容参考自中文维基与百度百科:</strong></p><p><strong>中文维基</strong></p><ul><li><p>数据完整性<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7</code></p></blockquote></li><li><p>数字签名<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%B0%BD%E7%AB%A0</code></p></blockquote></li></ul><p><strong>百度百科</strong></p><ul><li><p>数据完整性<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7</code></p></blockquote></li><li><p>数据校检<a href="https://baike.so.com/doc/741565-784957.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://baike.so.com/doc/741565-784957.html</code></p></blockquote></li></ul><hr><p><strong>参考文献:</strong></p><ul><li><p>Linux下使用GPG加密解密的说明及示例<a href="https://www.linuxidc.com/Linux/2015-02/113015.htm" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.linuxidc.com/Linux/2015-02/113015.htm</code></p></blockquote></li><li><p>如何在Linux下使用GPG(GnuPG)加密及解密<a href="https://jingyan.baidu.com/album/3d69c5513244a7f0ce02d751.html?picindex=1" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://jingyan.baidu.com/album/3d69c5513244a7f0ce02d751.html?picindex=1</code></p></blockquote></li><li><p>GPG简要介绍<a href="http://www.ruanyifeng.com/blog/2013/07/gpg.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.ruanyifeng.com/blog/2013/07/gpg.html</code></p></blockquote></li><li><p>Gnu隐私卫士(GnuPG)袖珍HOWTO(中文版)<a href="https://www.gnupg.org/howtos/zh/index.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.gnupg.org/howtos/zh/index.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;GNU-Privacy-Guard-GPG-1&quot;&gt;&lt;a href=&quot;#GNU-Privacy-Guard-GPG-1&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Password" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Password/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Linux Containers/LXC-1</title>
    <link href="https://unit-serow.github.io/2020/02/24/LXC-1/"/>
    <id>https://unit-serow.github.io/2020/02/24/LXC-1/</id>
    <published>2020-02-24T08:32:34.000Z</published>
    <updated>2020-02-24T08:34:54.444Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="Linux-Containers-LXC-1"><a href="#Linux-Containers-LXC-1" class="headerlink" title="Linux Containers/LXC-1"></a>Linux Containers/LXC-1</h2><p><strong>相关内容:</strong></p><ul><li>LXC(Linux Containers)</li><li>linux内核映射文件</li><li>文件映射</li></ul><hr><h3 id="LXC-Linux-Containers"><a href="#LXC-Linux-Containers" class="headerlink" title="LXC(Linux Containers)"></a>LXC(Linux Containers)</h3><p><strong>概述:</strong></p><ul><li>其名称来自Linux软件容器(Linux Containers)的缩写</li><li>是一种操作系统层虚拟化（Operating system–level virtualization)技术</li><li>作用是为Linux内核容器功能的一个用户空间接口</li></ul><hr><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><ol><li><strong>实现方法:</strong></li></ol><ul><li>在Linux内核中，提供了cgroups功能，来达成资源的区隔化<blockquote><p>它同时也提供了名称空间区隔化的功能，使应用程序看到的操作系统环境被区隔成独立区间，包括行程树，网络，用户id，以及挂载的文件系统<br>但是cgroups并不一定需要引导任何虚拟机<br>LXC利用cgroups与名称空间的功能，提供应用软件一个独立的操作系统环境<br>LXC不需要Hypervisor这个软件层，软件容器(Container)本身极为轻量化，提升了创建虚拟机的速度<br>软件Docker被用来管理LXC的环境</p></blockquote></li></ul><hr><ul><li>执行流程简述:<blockquote><p>它将应用软件系统打包成一个软件容器(Container)，内含应用软件本身的代码，以及所需要的操作系统核心和库<br>透过统一的名字空间和共享API来分配不同软件容器的可用硬件资源，创造出应用程序的独立沙箱运行环境<br>从而使得Linux用户可以容易的创建和管理系统或应用容器</p></blockquote></li></ul><hr><ol start="2"><li><strong>具体实现:</strong></li></ol><ul><li><p>当前的LXC使用下列内核功能来控制进程:</p><blockquote><p>内核名字空间(进程间通信，uts，mount，pid，network和user)<br>AppArmor和SELinux配置<br>Seccomp策略<br>chroot(使用<code>pivot_root</code>)<br>Kernel Capibilities<br>控制组(cgroups)</p></blockquote></li><li><p>因此，LXC通常被认为介于“加强版”的chroot和完全成熟的虚拟机之间的技术。LXC的目标是创建一个尽可能与标准安装的Linux相同但又不需要分离内核的环境</p></li></ul><hr><ol start="3"><li><strong>具体使用:</strong></li></ol><ul><li>Proxmox VE:它直到4.0版才使用LXC技术，在此之前的版本都是使用OpenVZ技术</li><li>Docker:它在0.9版之前都是使用LXC技术，但在0.9版之后，已不再是唯一且默认的运行环境</li></ul><hr><h3 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h3><p><strong>概述:</strong></p><ul><li>内存映射文件(Memory-mapped file)，或称”文件映射”与”映射文件”</li><li>是一段虚内存逐字节对应于一个文件或类文件的资源，使得应用程序处理映射部分如同访问主内存</li></ul><hr><p><strong>内存映射文件分为以下两种:</strong></p><ul><li>Persisted<blockquote><p>Persisted文件与硬盘文件相关联，当关闭内存映射时，数据被写入对应的硬盘文件中<br>适合于很大的文件</p></blockquote></li><li>Non-persisted<blockquote><p>Non-persisted文件并不关联于硬盘文件。当关闭内存映射文件，所有数据被抛弃<br>适用于创建进程间通信的共享内存</p></blockquote></li></ul><p><strong>作用:</strong></p><ol><li>最常见用途是绝大多数操作系统(包括Microsoft Windows与Unix-like系统)用于加载进程</li><li>另一个用途是多个进程的共享内存</li><li>第三个用途是对大文件的读写</li></ol><p><strong>优势:</strong></p><ol><li>主要用处是增加I/O性能，特别是用于大文件</li><li>对于小文件，内存映射文件会导致碎片空间浪费，因为内存映射总是要对齐页边界，这起码是4 KiB<blockquote><p>因而一个5 KiB文件将会映射占用8 KiB内存，浪费了3 KiB内存</p></blockquote></li><li>访问内存映射文件比直接文件读写要快几个数量级</li></ol><p><strong>缺点(弊端):</strong></p><ol><li>内存映射文件需要在进程的占用一块很大的连续逻辑地址空间</li><li>对于Intel的IA-32的4 GiB逻辑地址空间，可用的连续地址空间远远小于<code>2---3GiB</code><blockquote><p>相关联的文件的I/O错误(如可拔出驱动器或光驱被弹出，磁盘满时写操作等)的内存映射文件会向应用程序报告SIGSEGV/SIGBUS信号(POSIX环境)<br>或<code>EXECUTE_IN_PAGE_ERROR</code>结构化异常(Windows环境)<br>但通常的内存操作是无需考虑这些异常的</p></blockquote></li><li>有内存管理单元(MMU)才支持内存映射文件</li></ol><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><p>官方网站<a href="https://linuxcontainers.org/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linuxcontainers.org/</code></p></blockquote></li><li><p>LXC官方文档<a href="https://linuxcontainers.org/lxc/introduction/" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://linuxcontainers.org/lxc/introduction/</code></p></blockquote></li></ul><hr><p><strong>以下内容参考自中文维基:</strong></p><ul><li><p>虚拟内存<a href="https://zh.wikipedia.org/wiki/Category:%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98</code></p></blockquote></li><li><p>磁盘文件系统<a href="https://zh.wikipedia.org/wiki/Category:%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F</code></p></blockquote></li><li><p>Linux容器化<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%AE%B9%E5%99%A8%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%AE%B9%E5%99%A8%E5%8C%96</code></p></blockquote></li><li><p>Linux内核功能<a href="https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:Linux%E5%86%85%E6%A0%B8%E5%8A%9F%E8%83%BD</code></p></blockquote></li><li><p>操作系统层虚拟化<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E4%BD%9C%E6%A5%AD%E7%B3%BB%E7%B5%B1%E5%B1%A4%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li><li><p>DevOps<a href="https://zh.wikipedia.org/wiki/DevOps" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/DevOps</code></p></blockquote></li><li><p>虚拟化技术(Virtualization)<a href="https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E5%8C%96</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Linux-Containers-LXC-1&quot;&gt;&lt;a href=&quot;#Linux-Containers-LXC-1&quot; class=&quot;heade
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="虚拟化" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Debian-3</title>
    <link href="https://unit-serow.github.io/2020/02/23/Debian-3/"/>
    <id>https://unit-serow.github.io/2020/02/23/Debian-3/</id>
    <published>2020-02-23T10:57:21.000Z</published>
    <updated>2020-02-23T15:48:44.028Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="Debian-GNU-Linux-3"><a href="#Debian-GNU-Linux-3" class="headerlink" title="Debian GNU/Linux-3"></a>Debian GNU/Linux-3</h2><h3 id="Linux-磁盘管理"><a href="#Linux-磁盘管理" class="headerlink" title="Linux 磁盘管理"></a>Linux 磁盘管理</h3><hr><ul><li>本篇文章会不断进行补充</li></ul><p><strong>常见的分区有以下三个:</strong></p><ul><li>fdisk</li><li>cfdisk</li><li>partman</li></ul><hr><p><strong>cfdisk用法</strong></p><ul><li>简易分区管理工具</li><li>这里的磁盘类型是<code>SCSI</code>，<code>IDE</code>则为<code>hda</code>，<code>SATA</code>与<code>NVMe</code>这里不进行过多赘述</li><li>具体可以查看<code>man手册</code>与<code>help帮助</code>指令</li><li>基本流程:<code>创建分区-&gt;配置文件系统根目录与其它选项(作用/用途)-&gt;格式化文件系统-&gt;文件系统挂载并使用</code></li></ul><p><strong>创建分区:</strong></p><ol><li>键入指令<code>$cfdisk /dev/sda</code></li><li>选择任意分区(最好是空白分区，已有分区需要先进行删除)</li><li><code>选择[new选项]-&gt;[primary选项]-&gt;[指定容量数值(以字节为单位)]</code></li><li><code>选择[write选择]-&gt;键入[yes保存修改]-&gt;选择[quit选项退出工具]</code></li></ol><ul><li>参数说明:</li><li>primary 主分区</li><li>extended 扩展分区</li></ul><hr><p><strong>交换分区操作:</strong></p><ul><li><p>格式化交换分区指令(这里将sda1格式化为交换分区)</p><blockquote><p><code>$mkswap /dev/sda1</code></p></blockquote></li><li><p>使用交换分区</p><blockquote><p><code>$swapon [交换分区设备名/交换文件]</code><br><code>$swapon /dev/sda</code></p></blockquote></li><li><p>查看内存信息来检查是否已启用交换分区</p><blockquote><p><code>$free</code></p></blockquote></li><li><p>取消交换分区</p><blockquote><p><code>$swapoff /dev/sda1</code></p></blockquote></li></ul><hr><p><strong>其它概念(交换分区):</strong></p><p><strong>swap</strong></p><ul><li>swap的部分内容就是开启了多少交换空间，其空间大小是开启使用的交换分区或者文件大小的总和</li><li>交换分区可以同时存在多个并可以同时使用</li><li>同时也可以使用文件格式的交换空间</li></ul><p><strong>交换空间</strong></p><ul><li>一般主机系统里会有两个磁盘分区</li><li>一个是交换空间，另一个则是其它的任何分区</li><li>第一个分区计划为用于交换空间</li><li>交换空间又可被称为交换内存空间</li><li>使用这种文件系统的分区被称为交换分区，用于进行系统过程中的内存交换</li></ul><hr><p><strong>格式化分区操作:</strong></p><ul><li>将磁盘分区格式化为指定的文件系统</li><li>有以下几种语法格式:<blockquote><p><code>mkfs.ext2/ext3/ext4/xfs等等 /dev/sdaxxx/(指定磁盘)</code><br><code>mkfs.文件系统 [分区或设备名]</code><br><code>mkfs [options] [指定磁盘文件格式] /dev/sdaxxx/(指定磁盘)</code><br>参数<code>-v</code>，<code>-t</code>等等<br>例如:<code>mkfs -t ext4 /dev/sda3</code></p></blockquote></li></ul><hr><p><strong>磁盘(光盘或设备)挂载:</strong></p><ul><li><p>基本语法格式:</p><blockquote><p><code>mount -o loop [/dev/sdaxxx(指定磁盘)] [/mnt(被挂载目录)]</code><br><code>mount -t ext4(指定磁盘文件系统) /dev/sda4 /mnt</code></p></blockquote></li><li><p>卸载光盘</p><blockquote><p><code>umount /mnt</code><br><code>umount /dev/sda2</code></p></blockquote></li><li><p>mount查看磁盘文件系统挂载情况</p><blockquote><p>参数<code>-h</code>返回容量单位</p></blockquote></li><li><p>mount输出参数说明:</p><blockquote><p>ro表示只读<br>rw为可读可写</p></blockquote></li></ul><hr><p><strong>查看磁盘文件系统挂载情况:</strong></p><blockquote><p><code>$df</code></p></blockquote><hr><p><strong>磁盘文件系统修复:</strong></p><ul><li><p>fsck</p><blockquote><p>fsck(file system consistency check)</p></blockquote></li><li><p>是Unix和类Unix系统上用于检查文件系统完整性的工具</p></li><li><p>基本命令格式:</p><blockquote><p><code>fsck -y /dev/sda1(指定磁盘)</code></p></blockquote></li><li><p>fuser</p><blockquote><p><code>fuser -m /boot</code> 输出选项模块对应线程的pid<br><code>fuser -mk /boot</code> kill掉所选进程的pid</p></blockquote></li></ul><hr><p><strong>其它概念:</strong></p><ul><li>hda一般是指IDE接口的硬盘，hda一般指第一块硬盘，类似的有hdb,hdc等</li><li>sda一般是指SATA接口的硬盘，sda一般指第一块硬盘，类似的有sdb,sdc等</li><li>现在的内核都会把硬盘，移动硬盘，U盘之类的识别为sdX的形式</li></ul><hr><p><strong>参考资料:</strong></p><ul><li><p>Debian 分区程序<a href="https://www.debian.org/releases/wheezy/mips/apcs05.html.zh-cn" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.debian.org/releases/wheezy/mips/apcs05.html.zh-cn</code></p></blockquote></li><li><p>从零开始的Linux From Scratch<a href="http://www.linuxfromscratch.org/lfs/downloads/9.1-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>http://www.linuxfromscratch.org/lfs/downloads/9.1-rc1/LFS-BOOK-9.1-rc1-NOCHUNKS.html</code></p></blockquote></li></ul><hr><p><strong>问题解决方案:</strong></p><p><strong>1.找不到fdisk指令</strong></p><ul><li><p>查看路径:</p><blockquote><p><code>whereis cfdisk</code></p></blockquote></li><li><p>输出现有PATH变量路径</p><blockquote><p><code>echo $PATH</code></p></blockquote></li><li><p>配置软链接</p><blockquote><p><code>ln -sv [软件所在路径] [PATH所指定路径]</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Debian-GNU-Linux-3&quot;&gt;&lt;a href=&quot;#Debian-GNU-Linux-3&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Debian GNU/Linux-2</title>
    <link href="https://unit-serow.github.io/2020/02/23/Debian-2/"/>
    <id>https://unit-serow.github.io/2020/02/23/Debian-2/</id>
    <published>2020-02-22T17:36:50.000Z</published>
    <updated>2020-02-23T10:59:35.171Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --><h2 id="Debian-GNU-Linux-2"><a href="#Debian-GNU-Linux-2" class="headerlink" title="Debian GNU/Linux-2"></a>Debian GNU/Linux-2</h2><ul><li>网络配置问题统一解决方案</li></ul><h3 id="Debian网络配置基本命令"><a href="#Debian网络配置基本命令" class="headerlink" title="Debian网络配置基本命令"></a>Debian网络配置基本命令</h3><ul><li><p>输出网卡与网络配置情况</p><blockquote><p><code>ip -a/ifconfig</code></p></blockquote></li><li><p>查看所有已有网卡</p><blockquote><p><code>networkctl</code></p></blockquote></li><li><p>网卡配置目录</p><blockquote><p>/etc/network/interfaces</p></blockquote></li></ul><p><strong>网卡配置说明:</strong></p><ul><li><p>配置静态IP地址</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">auto eth0 #开机自动激活</span><br><span class="line">iface eth0 inte static #静态IP</span><br><span class="line">address<span class="built_in"> IP </span>#本机IP</span><br><span class="line">netmask 255.255.255.0 #子网掩码</span><br><span class="line"><span class="comment"># network IP</span></span><br><span class="line"><span class="comment"># broadcast IP</span></span><br><span class="line">gateway<span class="built_in"> IP</span>#路由网关</span><br></pre></td></tr></table></figure></li><li><p>DHCP自动获取(动态IP地址)</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">auto</span> <span class="string">eth0</span></span><br><span class="line"><span class="attr">iface</span> <span class="string">eth0 inet dhcp</span></span><br></pre></td></tr></table></figure></li><li><p>配置好之后保存配置，重启网卡(多种方式)</p><blockquote><p><code>service networking restart</code> #service工具<br><code>systemctl restart network</code> #systemctl工具<br><code>/etc/init.d/network-manager restart</code><br><code>/etc/init.d/networking restart</code></p></blockquote></li><li><p>重启指定网卡</p><blockquote><p><code>ifdown eth0</code><br><code>ifup eth0</code></p></blockquote></li><li><p>配置DNS</p><blockquote><p><code>vi /etc/resolv.conf</code><br><code>nameserver 0.0.0.0</code></p></blockquote></li></ul><hr><h3 id="名称与各参数简述与解释"><a href="#名称与各参数简述与解释" class="headerlink" title="名称与各参数简述与解释:"></a>名称与各参数简述与解释:</h3><p><strong>eth(ethernet)</strong></p><blockquote><p>有线网卡<br>物理网卡<br>如:eth0，eth1，eth2…则代表网卡一，网卡二，网卡三…<br>还可称为en</p></blockquote><hr><ul><li>eth各接口说明<blockquote><p>eth0=lan接口<br>eth1=wan接口<br>br-lan=lan网桥<br>br-lan 虚拟设备，用于LAN口设备桥接，可以用<code>brctl show</code>查看使用情况</p></blockquote></li></ul><hr><ul><li>en(ethernet)标识说明:<blockquote><p>o:主板板载网卡，集成是的设备索引号<br>p:独立网卡，PCI网卡<br>s:热插拔网卡，USB之类的扩展槽索引号<br>nnn(数字):MAC地址+主板信息计算得出唯一序列</p></blockquote></li></ul><hr><p><strong>lo</strong></p><blockquote><p>代表localhost，即127.0.0.1<br>虚拟设备，自身的回环网设备</p></blockquote><hr><p><strong>ens</strong></p><blockquote><p>ens33为自动备援模式，名称定为ens33<br>eno1表示主板BIOS内置的网卡<br>ens1表示主板BIOS中内置的PCI-E网卡<br>enp2s0为PCI-E独立网卡<br>eth0:如果没有使用以上任何一个，则将返回默认的网卡名</p></blockquote><hr><ul><li>wlan<blockquote><p>无线网卡<br>wlan0=无限端口</p></blockquote></li></ul><hr><p><strong>网络接口的传统命名方式(可预测命名方案)</strong><br><strong>传统命名:</strong></p><ul><li>以太网:ethX,[0,oo)<blockquote><p>例如eth0，eth1…</p></blockquote></li><li>PPP网络:pppX, [0,…]<blockquote><p>例如，ppp0, ppp1, …</p></blockquote></li></ul><hr><h3 id="NONA"><a href="#NONA" class="headerlink" title="NONA"></a>NONA</h3><ol><li><p>设置网卡</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">nano</span> <span class="string">/etc/network/interfaces</span>  <span class="string">/etc/network/interfacesbak</span>   <span class="comment">#备份原有配置文件</span></span><br><span class="line"><span class="string">nano</span> <span class="string">/etc/network/interfaces</span>   <span class="comment">#编辑网网卡配置文件</span></span><br><span class="line"><span class="string">auto</span> <span class="string">lo</span></span><br><span class="line"><span class="string">auto</span> <span class="string">eth0</span>  <span class="comment">#开机自动连接网络</span></span><br><span class="line"><span class="string">iface</span> <span class="string">lo</span> <span class="string">inet</span> <span class="string">loopback</span></span><br><span class="line"><span class="string">allow-hotplug</span> <span class="string">eth0</span></span><br><span class="line"><span class="string">iface</span> <span class="string">eth0</span> <span class="string">inet</span> <span class="string">static</span>   <span class="comment">#static表示使用固定ip，dhcp表述使用动态ip</span></span><br><span class="line"><span class="string">address</span> <span class="number">192.168</span><span class="number">.21</span><span class="number">.166</span>   <span class="comment">#设置ip地址</span></span><br><span class="line"><span class="string">netmask</span> <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  <span class="comment">#设置子网掩码</span></span><br><span class="line"><span class="string">gateway</span> <span class="number">192.168</span><span class="number">.21</span><span class="number">.2</span>    <span class="comment">#设置网关</span></span><br><span class="line"><span class="string">ctrl+o</span>   <span class="comment">#保存配置</span></span><br><span class="line"><span class="string">ctrl+x</span>   <span class="comment">#退出</span></span><br></pre></td></tr></table></figure></li><li><p>设置DNS</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">cp</span>  <span class="string">/etc/resolv.conf</span>   <span class="string">/etc/resolv.confbak</span>    <span class="comment">#备份原有dns配置文件</span></span><br><span class="line"><span class="string">nano</span> <span class="string">/etc/resolv.conf</span>   <span class="comment">#编辑配置文件</span></span><br><span class="line"><span class="string">nameserver</span> <span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>   <span class="comment">#设置首选dns</span></span><br><span class="line"><span class="string">nameserver</span> <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span>   <span class="comment">#设置备用dns</span></span><br><span class="line"><span class="string">ctrl+o</span>   <span class="comment">#保存配置</span></span><br><span class="line"><span class="string">ctrl+x</span>   <span class="comment">#退出</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li>网络上关于以下概念的资料数不胜数，这里就不再多做阐述了</li></ul><p><strong>OSI七层模型:</strong></p><blockquote><p>由上至下简述(程序至底层)<br>应用层/表示层/会话层/传输层/网络层/数据链路层/物理层<br>上层依赖于下层，下层为上层提供服务<br>OSI内的每一层模型都有属于自己的协议集与功能集<br>层与层之间相互独立且相互依赖</p></blockquote><ul><li><p>中文维基<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B</code></p></blockquote></li><li><p>TCP/IP</p><blockquote><p>IP:互联网协议<br>TCP:传输控制协议<br>三次握手与四次握手<br>任何基于互联网协议蔟与协议套组都基于TCP/IP</p></blockquote></li><li><p>HTTP</p><blockquote><p>超文本传输协议<br>无状态协议<br>大部分实现都是基于TCP的</p></blockquote></li><li><p>DNS</p><blockquote><p>域名系统</p></blockquote></li><li><p>其它常用协议</p><blockquote><p>应用层:BGP/DHCP/HTTPS/IMAP/NNTP/NTP/POP/SMTP/SNMP/SSH/Telnet等等<br>传输层:UDP/TLS/SSL/DCCP等等<br>网络层:IP/ICMP/IGMP/IPsec等等<br>链接层:APR/PPP/DSL/ISDN等等</p></blockquote></li></ul><hr><h3 id="操作流程-逻辑-整合-简述"><a href="#操作流程-逻辑-整合-简述" class="headerlink" title="操作流程(逻辑)整合/简述"></a>操作流程(逻辑)整合/简述</h3><ol><li>查看网络配置</li><li>查看已有网卡</li><li>启动或重启网卡</li><li>设置配置文件(静态IP或动态IP)</li><li>配置网关</li><li>配置DNS</li><li>保存配置并重启网卡</li></ol><ul><li>任何网络与本地的流量与数据的传输都需要经过本地或无限的网卡</li><li>流量与数据的抓取也只是读取经由网卡的信息并进行输出</li><li>配置无线或有限网的前提是所处的物理环境已有网络支持</li><li>网卡用于联网的虚拟信息处理方式，网络离不开物理层面的支持</li><li>网卡被归纳为设备内</li></ul><hr><p><strong>参考资料:</strong></p><ul><li>Linux系统运维<a href="https://www.osyunwei.com/" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://www.osyunwei.com/</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sat Feb 29 2020 01:17:36 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Debian-GNU-Linux-2&quot;&gt;&lt;a href=&quot;#Debian-GNU-Linux-2&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
