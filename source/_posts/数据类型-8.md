---
title: 数据类型-8
date: 2020-03-17 11:41:51
tags: [随笔,C]
categories: [软件,C/C++]
---

<center><strong>数据类型-I/O-1</strong></center>

<!-- more -->

### 数据类型-8

* C I/O 原理解析-1

---

### 字符输入/输出与输入验证

---

**相关内容:**

* 输入，输出以及缓冲输入和无缓冲输入的区别
* 通过键盘模拟文件结尾条件
* 使用重定向将程序与文件相连接
* 创建更完善的用户界面

---

**相关概念:**

* 输入(input)&输出(output)
* 常见的输入和输出设备
> 包括如键盘，U盘，扫描仪和激光打印机等
* 如何处理输入数据和输出数据
* 执行输入和输出任务的函数
> 即用于输入和输出的函数(简称I/O函数)
* I/O函数(如printf()，scanf()，getchar()，putchar()等)
> 其负责将信息传送到程序中
> I/O函数的基本概念解析
* 关于设计与用户交互的界面

---

**关于C 的 I/O 函数**

* 最初，输入/输出函数不是C定义的一部分
> C把开发这些函数的任务留给编译器的实现者来完成
> 在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型
> ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些极为常用的
> 由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性
> 因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数
> 其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面
> 这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序
> 这里所提及的 I/O函数 是所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统
> 处理文件输入/输出 的程序也可以使用这些函数
> 许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配，此时则需要输入验证相关的问题和解决方案

---

### 单字符I/O

* 即为getchar()和putchar()
> getchar()和putchar()每次只处理一个字符
> 虽然效率对于人为编写与阅读的不佳，但这种方法很适合计算机
> 并且这是绝大多数文本(即，普通文字)处理程序所用的核心方法
> 这里会提到有关这些函数的工作方式

* 自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联
> 这就是为什么程序中要包含这个头文件的原因
> 实际上getchar()和putchar()都不是真正的函数，它们被定义为供预处理器使用的宏

* 如果在程序中同时使用了getchar()和putchar()函数
> 在运行程序后，getchar()函数会将用户以键盘输入的值传递至程序中的putchar()函数
> 然后putchar()函数会将值直接显示/输出在/至屏幕上
> 其涉及概念即为关于C的键盘输入处理，缓冲和标准输入文件

---

### C 缓冲区

* 在老式操作系统中运行getchar()函数的输入循环并以putchar()进行输出
> 其系统在回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入
> 即正在等待的程序可立即使用输入的字符
> 而现在的大部分系统在用户按下Enter键之前不会重复打印刚输入的字符
> 这种输入形式属于缓冲输入

* 此时用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区
> 按下Enter键后，程序才可使用用户输入的字符

* 以下图片比较了这两种输入:

* 缓冲输入和无缓冲输入:

<img src="/images/数据类型-8/缓冲输入和无缓冲输入-1.png" width="40%" height="40%">

---

**关于缓冲区的存在意义:**

* 首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间
> 其次，如果用户打错字符，可以直接通过键盘修正错误
> 即当最后按下Enter键时，传输的是正确的输入

* 虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入
> 例如在游戏中，玩家通常希望按下一个键就执行相应的指令
> 因此，缓冲输入和无缓冲输入都有用武之地

* 缓冲分为两类: 完全缓冲I/O和行缓冲I/O

* 完全缓冲 I/O
> 完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)
> 其通常出现在文件输入中
> 缓冲区的大小取决于系统，常见的大小是512字节和4096字节

* 行缓冲 I/O
> 行缓冲I/O指的是在出现换行符时刷新缓冲区
> 键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区

**关于使用缓冲输入还是无缓冲输入**

* ANSI C和后续的C标准都规定输入是缓冲的
> 不过最初K&R把这个决定权交给了编译器的编写者
> ANSI C决定把缓冲输入作为标准的原因是: 一些计算机不允许无缓冲输入
> 如果当前使用的计算机允许无缓冲输入，那么当前所用的C编译器很可能会提供一个无缓冲输入的选项
> 例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数
> 其原型都在conio.h头文件中
> 这些函数包 括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数(回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击 键后对应的字符不显示)
> UNIX系统使用另一种不同的方式控制缓冲
> 在UNIX系统中，可以使用ioctl()函数(该函数属于UNIX库，但是不属于C标准)指定待输入的类型，然后用getchar()执行相应的操作
> 在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用
> 总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统
> 这里假设所有的输入都是缓冲输入，即不会涉及无缓冲输入

---

**有关结束键盘输入**

* 在某些程序中，只要输入的字符中不含#，那么程序在读到#时才会结束
> 同时#也是一个普通的字符，有时在程序中不免会用到
> 所以应该用一个文本中用不到的字符来标记输入完成
> 此时就实现了让这样的字符不会无意间出现在输入中，即在不希望结束程序的时候终止程序时

---

### 文件&流&键盘-输入

**文件输入:**

* 文件(file)是存储器中储存信息的区域
> 通常，文件都保存在某种永久存储器中(如，硬盘，U盘或DVD等)
> 毫无疑问，文件对于计算机系统 相当重要
> 例如编写的C程序就保存在文件中，同时用来编译C程序的程序也保存在文件中
> 后者说明，某些程序需要访问指定的文件
> 当编译储存在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容
> 当编译器处理完后，会关闭该文件
> 其他程序，例如文字处理器，不仅要打开，读取和关闭文件，还要把数据写入文件

* C 是一门强大且灵活的语言，有许多用于打开，读取，写入和关闭文件的库函数
> 从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件
> 这些直接调用操作系统的函数被称为底层 I/O (low-level I/O)
> 由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做
> 然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件
> 这涉及创建用于处理文件的标准模型和一套标准I/O函数
> 在这一层面上，具体的C实现负责处理不同系统的差 异，以便用户使用统一的界面

**有关 I/O 的差异问题:**

* 例如，不同的系统储存文件的方式不同
> 有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处
> 而有些系统在文件中创建一份文件描述

* 在处理文件方面
> 有些系统使用单个换行符标记行末尾
> 而其他系统可能使用回车符和换行符的组合来表示行末尾

* 文件大小方面
> 有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量

* 如果使用标准I/O包，就不用考虑这些差异
> 此时可以使用`if(ch == '\n')`来检查换行符
> 即使用系统实际用的是回车符和换行符的组合来标记行末尾
> I/O函数会在两种表达式法之间相互转换

* 从概念上看，C程序处理的是流而不是直接处理文件
> 流(stream)是一个实际输入或输出映射的理想化数据流
> 这意味着不同属性和不同种类的输入，由属性更统一的流来表示
> 于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成

* 这里着重理解 C 把输入和输出设备视为存储设备上的普通文件
> 尤其是把键盘和显示设备视为每个C程序自动打开的文件
> 有关对于文件的深入讨论这里不做多余赘述

* stdin流表示键盘输入，stdout流表示屏幕输出
> getchar()，putchar()，printf()和scanf()函数都是标准I/O包的成员，负责处理这两个流
> 以上的内容则说明了可以用处理文件的方式来处理键盘输入
> 例如， 程序读文件时要能检测文件的末尾才知道应在何处停止
> 因此，C 的输入函数内置了文件结尾检测器
> 既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入
> 下面会从文件开始讨论如何结束文件

---

### 文件结尾

* 计算机操作系统要以某种方式判断文件的开始和结束
> 检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾
> CP/M，IBMDOS和MS-DOS的文本文件曾经用过这种方法
> 如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾
> 这曾经是操作系统使用的唯一标记， 不过现在有一些其他的选择，例如记录文件的大小
> 所以现代的文本文件不 一定有嵌入的Ctrl+Z
> 但是如果有，该操作系统会将其视为一个文件结尾标记

* 以下图片演示了这种方法:

* 带文件结尾标记的文件:

<img src="/images/数据类型-8/带文件结尾标记的文件-1.png" width="40%" height="40%">

---

* 操作系统使用的另一种方法是储存文件大小的信息
> 如果文件有3000字节，程序在读到3000字节时便达到文件的末尾
> MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z
> 新版的DOS也使用这种方法处理文本文件
> UNIX使用这种方法处理所有的文件
> 无论操作系统实际使用何种方法检测文件结尾
> 在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值
> 即EOF(end of file的缩写)
> scanf()函数检测到文件结尾时也返回EOF
> 通常， EOF定义在stdio.h文件中:
> `#define EOF (-1)`

* 为什么是-1? 
> 因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集
> 但是，如果系统能识别扩展字符集，该函数的返回值可能在 0～255之间
> 无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 文件结尾
> 某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同
> 如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题
> 这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号

**关于如何在程序中使用EOF**

* 把getchar()的返回值和EOF作比较
> 如果两值不同，就说明没有到达文件结尾
> 也就是说，可以使用下面这样的表达式:
> `while ((ch = getchar()) != EOF)`
> 如果正在读取的是键盘输入不是文件的情况:
> 绝大部分系统(不是全部)都有办法通过键盘模拟文件结尾条件

* 这里以该程序举例(echo_eof.c):

```
#include <stdio.h>

int main(void)
{
	int ch;
	while ((ch = getchar()) != EOF)
		putchar(ch);
	return 0;
}
```

* 在使用EOF时需要注意下面几点:
1. 不用定义EOF，因为stdio.h中已经定义过了
2. 不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值
3. 变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数
> 但是EOF的值是-1
> 还好，getchar()函数实际返回值的类型是 int，所以它可以读取EOF字符
> 如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式
4. 由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据
> ch是整数不会影响putchar()，该函数仍然会打印等价的字符
> 使用该程序进行键盘输入，要设法输入EOF字符
> 不能只输入字符 EOF，也不能只输入-1(输入-1会传送两个字符: 一个连字符和一个数字 1)
5. 正确的方法是，必须找出当前系统的要求
> 例如，在大多数UNIX和 Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号
> 许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号
> 一些系统把任意位置 的Ctrl+Z解释成文件结尾信号

* 下面是在UNIX系统下运行echo_eof.c程序的缓冲示例:
```
She　walks　in　beauty,　like　the　night
She　walks　in　beauty,　like　the　night
Of　cloudless　climes　and　starry　skies...
Of　cloudless　climes　and　starry　skies...
Lord　Byron
Lord　Byron
[Ctrl+D]
```

* 每次按下Enter键，系统便会处理缓冲区中储存的字符
> 并在下一行打印该输入行的副本
> 这个过程一直持续到以UNIX风格模拟文件结尾(按下Ctrl+D)
> 在PC中，要按下Ctrl+Z

* 既然`echo_eof.c`程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么
> 假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止
> 或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据
> 用`echo_eof.c`来储存在文件中输入的内容
> 假设同时使用这两种方法: 把输入从一个文件定向到`echo_eof.c`中，并把输出发送至另一个文件
> 然后便可以使用`echo_eof.c`来拷贝文件
> 这个小程序有查看文件内容，创建一个新文件，拷贝文件的潜力
> 关键是要控制输入流和输出流
* 注意模拟EOF和图形界面
> 模拟EOF的概念是在使用文本界面的命令行环境中产生的
> 在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号
> 但是在一些实际应用中，却不能很好地转换成图形界面(如Windows和Macintosh)
> 这些用户界面包含更复杂的鼠标移动和按钮点击
> 程序要模拟EOF的行为依赖于编译器和项目类型
> 例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的 设置

---

**待补充**

---

### 补充内容-1

---

### 重定向和文件

* 输入和输出涉及函数，数据和设备
> 例如，假设某一个程序内使用输入函数getchar()用作被设定内容的输出方法
> 输出设备这里将其假设为键盘，输入数据流由字符组成

* 假设此时希望输入函数和数据类型不变，仅改变程序查找数据的位置
* 程序判断查找输入的位置的方法与逻辑:
> 在默认情况下，C程序使用标准I/O包查找标准输入作为输入源
> 即为stdin流，它是把数据读入计算机的常用方式
> 它可以是一个过时的设备，如磁带，穿孔卡或电传打印机
> 或者(假设)是键盘，甚至是一 些先进技术，如语音输入
> 然而，现代计算机非常灵活，可以让它到别处查找输入
> 尤其是，可以让一个程序从文件中查找输入，而不是从键盘

* 程序可以通过两种方式使用文件
> 第一种方法:
> 显式使用特定的函数打开文件，关闭文件，读取文件，写入文件，诸如此类，这里不对此种方法进行过多赘述
> 第二种方法:
> 设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出
> 换言之，把stdin流重新赋给文件
> 继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么 位置获取数据
> 虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，一般会用于普通的文件处理技术
> 重定向的一个主要问题与操作系统有关，与C无关
> 尽管如此，许多C 环境中(包括UNIX，Linux和Windows命令提示模式)都有重定向特性
> 而且一些C实现还在某些缺乏重定向特性的系统中模拟它
> 在UNIX上运行苹果 OS X，可以用UNIX命令行模式启动Terminal应用程序

---

### UNIX&Linux&Windows-重定向

**UNIX**

* UNIX(运行命令行模式时)，Linux(ditto)和Window命令行提示(模仿旧式DOS命令行环境)都能重定向输入，输出
> 重定向输入让程序使用文件而不是键盘来输入
> 重定向输出让程序输出至文件而不是屏幕

1. 重定向输入

* 假设已经编译了`echo_eof.c`程序，并把可执行版本放入一个名为`echo_eof`(或者在Windows系统中名为`echo_eof.exe`)的文件中
> 运行该程序，输入可执行文件名: `echo_eof`
> 该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入
> 现在，假设要用该程序处理名为words的文本文件
> 文本文件(text file)是内含文本的文件，其中储存的数据是人类可识别的字符
> 文件的内容可以是 一篇散文或者C程序
> 内含机器语言指令的文件(如储存可执行程序的文 件)不是文本文件
> 由于该程序的操作对象是字符，所以要使用文本文件
> 只需用此命令代替上面的命令即可: `echo_eof < words`
> 符号是UNIX和DOS/Windows的重定向运算符
> 该运算符使words文件与stdin流相关联，把文件中的内容导入`echo_eof`程序
> `echo_eof`程序本身并不知道(或不关心)输入的内容是来自文件还是键盘
> 它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾
> 因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备

* 重定向需要注意的几点
> 对于UNIX，Linux和Windows命令提示，<两侧的空格是可选的
> 一些系统，如AmigaDOS(那些喜欢怀旧的人使用的系统)，支持重定向
> 但是在重定向符号和文件名之间不允许有空格

* 下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示符
> 在Windows/DOS系统中见到的DOS提示可能是A>或C>
```
$ echo_eof < words
The world is too much with us: late and soon,
Getting and spending, we lay waste our powers:
Little we see in Nature that is ours;
We have given our hearts away, a sordid boon!
$
```

---

2. 重定向输出

* 现在假设要用`echo_eof`把键盘输入的内容发送到名为mywords的文件中
> 然后，输入以下命令并开始输入:
> `echo_eof > mywords`
> >符号是第2个重定向运算符
? 它创建了一个名为mywords的新文件，然后把`echo_eof`的输出(即为人为去输入字符的副本)重定向至该文件中
> 重定向把stdout从显示设备(即为显示器)赋给mywords文件
> 如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容(但是，许多操作系统有保护现有文件的选项，使其成为只读文件)
> 所有出现在屏幕的字母都是人为进行输入的，其副本储存在文件中
> 在下一行的开始处按下Ctrl+D(UNIX)或Ctrl+Z(DOS)即可结束该程序
> 还有一点就是必须在每行的末尾单击Enter键才能把缓冲区的内容发送给程序

---

3. 组合重定向

* 现在假设希望制作一份mywords文件的副本，并命名为savewords
> 只需输入以下命令即可:
> `echo_eof < mywords > savewords`
> 下面的命令也起作用，因为命令与重定向运算符的顺序无关:
> `echo_eof > savewords < mywords`
> 注意: 在一条命令中，输入文件名和输出文件名不能相同
> `echo_eof < mywords > mywords....<--错误`
> 原因是> mywords在输入之前已导致原mywords的长度被截断为0

* 总之，在UNIX，Linux或Windows/DOS系统中使用两个重定向运算符(<和>)时，要遵循以下原则:
> 重定向运算符连接一个可执行程序(包括标准操作系统命令)和一个数据文件
> 不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序
> 使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件
> 通常，文件名和运算符之间的空格不是必须的
> 除非是偶尔在UNIX shell，Linux shell或Windows命令行提示模式中使用的有特殊含义的字符
> 例如刚才的`echo_eof<words`

* 以上介绍的都是正确的例子，下面来看一下错误的例子: 
> addup和count 是两个可执行程序，fish和beets是两个文本文件:
```
fish > beets		←违反第1条规则
addup < count		←违反第1条规则
addup < fish < beets	←违反第2条规则
count > beets fish		←违反第2条规则
```

* UNIX，Linux或Windows/DOS还有>>运算符，该运算符可以把数据添加到现有文件的末尾
> 而 | 运算符能把一个文件的输出连接到另一个文件的输入
> 其它更加深入的内容可参考书籍: UNIX Primer Plus，Third Edition(Wilson，Pierce和Wessler合著)

**其它内容:**

* 绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序
> 或只在C编译器允许的情况下重定向C程序
> 假设prog是可执行程序名，file1和file2是文件名

* 把输出重定向至文件: >
> `prog >file1`
* 把输入重定向至文件: <
> `prog <file2`
* 组合重定向:
> `prog　<file2　>file1`
> `prog　>file1　<file2`
* 这两种形式都是把file2作为输入，file1作为输出

* 一些系统要求重定向运算符左侧有一个空格，右侧没有空格
> 而其他系 统(如UNIX)允许在重定位运算符两侧有空格或没有空格

---

**关于创建更友好的用户界面:**

* 大部分人偶尔会写一些中看不中用的程序
> 还好，C提供了大量工具让输入更顺畅，处理过程更顺利
> 不过，学习这些工具会导致新的问题
> 最基本的要求是让交互数据输 入更方便
> 并且减少错误输入的影响

---

**关于使用缓冲输入:**

* 缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入
> 但是，在使用输入的字符时，它也会给程序员带来麻烦
> 一般的缓冲输入会要求用户按下Enter键发送输入
> 但同时这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符

---

**关于混合数值和字符输入:**

* 假设程序要求用getchar()处理字符输入，用scanf()处理数值输入
> 这两个函数都能很好地完成任务，但是不能把它们混用
> 因为getchar()读取每个字符，包括空格，制表符和换行符
> 而scanf()在读取数字时则会跳过空格，制表符和换行符

* 要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格
> 另外，如果该程序不在getchar()测试时
> 而在scanf()阶段终止程序会更好

---

**关于输入验证:**

* 在实际应用中，用户不一定会按照程序的指令行事
> 用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败
> 作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误
> 这样才能编写出能检测并处理这些问题的程序

---

### 输入流和数字

* 在编写处理错误输入的代码时应该很清楚C是如何处理输入的

* 考虑下面的输入:
> `is 28 12.4`
> 在人类的眼中，它就像是一个由字符，整数和浮点数组成的字符串
> 但是对 C 程序而言，这是一个字节流
> 第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等
> 所以，如果`get_long()`函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字
> 因为这些数字只是该输入行中的其他字符:
```
while ((ch = getchar()) != '\n')
putchar(ch); // 处理错误的输入
```
> 虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值

* 例如，考虑下面的输入:
> `42`
> 如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中
> 如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中
> 如果使用%d转换说明，scanf()同样会读取两个字符
> 但是随后会计算出它们对应的整数值: 4×10+2，即42，然后将 表示该整数的二进制数储存在int类型的变量中
> 如果使用%f转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0
> 用内部的浮点表示法表示该值，并将结果储存在float类型的变量中

* 简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值
> 使用转换说明(如%d或%f)限制了可接受输入的字符类型
> 而getchar()和使用%c的scanf()接受所有的字符

---

**关于菜单浏览:**

* 许多计算机程序都把菜单作为用户界面的一部分
> 菜单给用户提供方便的同时，却给程序员带来了一些麻烦

* 将会涉及的问题:
* 菜单给用户提供了一份响应程序的选项
> 假设有下面一个例子:
```
Enter the letter of your choice:
a. advice b. bell
c. count q. quit
```

* 理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务
> 作为一名程序员，自然希望这一过程能顺利进行
> 因此，第1个目标是: 当用户遵循指令时程序顺利运行
> 第2个目标是: 当用户没有遵循指令时，程序也能顺利运行
> 显而易见，要实现第2个目标难度较大，因为很难预料用户在使用程序时的所有错误情况
> 现在的应用程序通常使用图形界面，可以点击按钮，查看对话框，触摸图标
> 而不是示例中的命令行模式
> 但是，两者的处理过程大致相同: 给用户提供选项，检查并执行用户的响应，保护程序不受误操作的影响
> 除了界面不同，它们底层的程序结构也几乎相同
> 但是，使用图形界面更容易通过限制选项控制输入

---

**关于任务**

* 这里将更具体地分析一个菜单程序需要执行哪些任务
* 它要获取用户的响应，根据响应选择要执行的动作
> 另外，程序应该提供返回菜单的选项
* C 的switch语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签
> 使用while语句可以实现重复访问菜单的功能
> 因此写出以下伪代码:
> 获取选项
> 当选项不是'q'时
> 转至相应的选项并执行
> 获取下一个选项

---

**关于让使执行更顺利**

* 当决定实现某个程序时
> 就要开始考虑如何让程序顺利运行(顺利运 行指的是，处理正确输入和错误输入时都能顺利运行)
> 例如，能做的是让"获取选项"部分的代码筛选掉不合适的响应，只把正确的响应传入switch
> 这表明需要为输入过程提供一个只返回正确响应的函数

* 混合字符和数值输入会产生一些问题，创建菜单也有这样的问题

* 还要注意在处理较复杂的任务时，如何让函数把任务委派给另一个函数
> 这样让程序更模块化

---

**关键概念:**

* C程序把输入作为传入的字节流
> getchar()函数把每个字符解释成一个字符编码
> scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值
> 许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出

* 程序通常接受特殊形式的输入
> 可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况
> 让程序更强健更友好

* 对于一个小型程序，输入验证可能是代码中最复杂的部分
> 处理这类问题有多种方案
> 例如，如果用户输入错误类型的信息，可以终止程序
> 也可以给用户提供有限次或无限次机会重新输入

---

**本章小结:**

* 许多程序使用 getchar()逐字符读取输入
> 通常，系统使用行缓冲输入， 即当用户按下Enter键后输入才被传送给程序
> 按下Enter键也传送了一个换行符，编程时要注意处理这个换行符
> ANSI C把缓冲输入作为标准

* 通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同文件形式，是C语言的特性之一
> getchar()和scanf()函数也属于这一系列
> 当检测到文件结尾时，这两个函数都返回EOF(被定义在stdio.h头文件中)
> 在不同系统中模拟文件结尾条件的方式稍有不同
> 在UNIX系统中，在一行开始处按下Ctrl+D可以模拟文件结尾条件
> 而在DOS系统中则使用Ctrl+Z

* 许多操作系统(包括UNIX和DOS)都有重定向的特性，因此可以用文件代替键盘和屏幕进行输入和输出
> 读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号，或者用于重定向文件
> 混合使用getchar()和scanf()时，如果在调用getchar()之前，scanf()在输 入行留下一个换行符会导致一些问题
> 不过，意识到这个问题就可以在程序中妥善处理

* 编写程序时，要认真设计用户界面
> 事先预料一些用户可能会犯的错误
> 然后设计程序妥善处理这些错误情况

---



