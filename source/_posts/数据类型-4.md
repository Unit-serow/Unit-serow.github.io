---
title: 数据类型-4
date: 2020-03-12 09:55:21
tags: [随笔,C]
categories: [软件,C/C++]
---


<center><strong>数据类型-运算符与表达式-1</center></strong>

<!-- more -->

## 数据类型-4

* 重点为运算符与表达式

---

### 基本运算符

**涉及概念:**

* 一元运算符
* 二元运算符
* 左值与右值
* 表达式和语句
* 基本循环及其符合语句
* 副作用与序列点

---

### 左值与右值

**右值**

* 右值(rvale)，通常只能是字面常量
> 而字面常量不能常量赋值，因为常量本身就是它的值
> 因此，在使用赋值运算符=时，左侧的项必须是一个变量名
> 实际上，赋值运算符左侧必须引用一个存储位置，而最简单方法就是使用变量名
> 不过指针也可用于指向一个存储位置
> 概括地说，C 使用可修改的左值(modifiable lvalue)标记那些可赋值的实体(物理内存)

* 术语概览: 数值对象，左值，右值和运算符

* 赋值表达式语句的目的是把值存储到内存位置上
* 用于存储值的数据存储区域被称之为对象(data object)
* C 标准中只有提到赋值的概念时，才有可能涉及到对象这个术语
* 使用变量名是表示对象的唯一方法，除此之外还有其它的方法，例如指定数组的元素，结构的成员，或者使用指针表达式(指针中存储的是它所指对象的地址)
* 相关的具体细节这里不做过多阐述

**左值**

* 左值(lvalue)是C的术语，用于表示特定数据对象的名称或表达式
> 因此，对象指的是实际的数据存储，而左值是用于表示或定位存储位置的标签

* 对于早期的C，左值所涉及的意义:
1. 它指定一个对象，所以引用内存中的地址
2. 它可以在赋值运算符的左侧，左值(lvalue)中的l源自left

* 但后来的C标准中新增了const限定符，用const创建的变量为只读变量，即为不可修改
> 因此，const标识符可以满足上面的第一项，而无法满足第二项
> 一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧
> 有些左值不能用于赋值运算符的左侧，因此，标准对左值的定义已经不能满足当前的状况
> 为此，C标准新定义了一个术语: 可修改的左值(modifable lvalue)，此方法用于标识可修改的对象
> 所以，赋值运算符的左侧应该是可修改的值，当前标准建议，使用术语对象定位值(object locator value)更好

---

**右值**

* 右值(rvalue)指的是能赋值给可修改左值的量，且本身不是左值
> 右值中的r源自right
* 右值可以是常量，变量或其它可求值的表达式(如，函数调用)
> 实际上，当前标准在描述这一概念时使用的是表达式的值(value of an expression)，而非右值
> 右值示例: bmw = 2002;，此时的2002则为右值

* 左值就是用于引用某指定内存位置的标识符，而右值即为存储于该内存位置的值

* 在名称学习时，被称为"项"(如，赋值运算符左侧的项)的就是运算符对象(operand)
> 运算对象指的就是运算符操作的对象
> 还可以类似的将"=运算符的左侧对象"称之为是"应该是可修改的左值"

---

## 基本的算术运算符-一元/二元运算符

### 二元运算符

* 二元运算符最基本的定义是运算对象至少是两个值
* 最基本的二元运算符是四则运算标识符

**加法运算符**

* 加法运算符(addition operator)用于加法运算，使其两侧的值相加
> 而相加的值(运算对象)可以是对象，也可以是常量
> 比如 icome = salary + bribes;，计算机会查看加法运算符右侧的两个变量，即为右值，将其相加，然后将相加的和(返回的结果)赋值给变量income
> 这里需要注意的一点是，income，salary，bribes都是可修改的左值，因为每个变量都标识了一个可被赋值的数据对象
> 但是，表达式salary + brives是一个右值

**减法运算符**

* 减法运算符(subtraction operator)用于减法运算，使其左侧的数减去右侧的数
> 例如，下面的语句把200.0赋给takehome：
> takehome = 224.00 – 24.00;
> +和-运算符都被称为二元运算符(binary operator)，即这些运算符需要两个运算对象才能完成操作

---

### 一元运算符

* 一元运算符(unary operator)
* 一元运算符就是符号运算符，即仅需要运算一个运算对象的运算符
> 类似于赋值运算符=，数值标识符-，+(正值与负值)，指针标识符&和*等等

**符号运算符:-和+**

* 减号还可用于标明或改变一个值的代数符号
> rocky = -12;，以这种方式使用的负号被称之为一元运算符

* 在C90标准中新增了一元+运算符，它不会改变运算对象的值或符号
> 只能这样使用: dozen = +12;
> 此时编译器不会报错，但是在以前，这样做是不被允许的

**图解说明:**

* 二元运算符和一元运算符:

<img src="/images/数据类型-4/运算符-1.png" width="30%" height="30%">

---

**乘法运算符**

* 符号*表示乘法
> `cm = 2.56 * inch;`，该语句就是用2.56乘以inch，并将结果赋值给cm
> 因为C 内没有平方函数与指数函数，所以只能用循环语句来实现平方与其它指数级增长

**除法运算符**

* C使用符号/来表示除法
* 符号/左侧的值是被除数，右侧的值是除数
> 例如，此表达式中four的值是`4.0: four = 12.0/3.0;`

* 整数除法和浮点数除法不同
> 浮点数除法的结果是浮点数，而整数除法的结果是整数
> 整数是没有小数部分的数
> 这使得5除以3很让人头痛，因为实际结果有小数部分
* 在C语言中，整数除法结果的小数部分被丢弃
> 这一过程被称为截断(truncation)

* 一般情况下最好避免混合类型的出现，即同一个除法表达式内同时出现整数与浮点数
> 因为计算机不能真正的使用浮点数去除以整数，所以编译器会把两个运算对象转换成相同的类型
> 即在进行出发运算之前，将整数转换为浮点数，或将浮点数转换为整数

* 在C99标准以前，C语言给语言的实现者留有一些空间
> 让他们来决定如何进行负数的整数除法
> 一种方法是，舍入过程采用小于或等于浮点数的最大整数
> 当然，对于`3.8`而言，处理后的3符合这一描述
> 但是当需要处理`-3.8`时，该方法建议四舍五入为`-4`
> 因为`-4` 小于`-3.8`
> 但是，另一种舍入方法是直接丢弃小数部分
> 这种方法被称为"趋零截断"，即把`-3.8`转换成`-3`
> 在C99以前， 不同的实现采用不同的方法
> 但是C99规定使用趋零截断
> 所以，应把-`3.8`转换成`-3`

---

* 当同一个表达式内出现了多种不同种类的运算符时，运算符会出现优先级限制

**图片说明:**

* 目前为止文章内涉及的运算符优先级(从低至高):

<img src="/images/数据类型-4/运算符优先级-1.png" width="30%" height="30%">

* 优先级和求值顺序
> 运算符的优先级为表达式中的求值顺序提供了重要的依据，但是并没有规定所有的顺序
> 所以 C 给实现者留出了选择的余地

---

### 其它运算符

* C 中有大约40个运算符，有些运算符比其它运算符常用的多
> 这里只对最常用的运算符进行讨论

**sizefo运算符与其相关类型**

1. sizeof运算符和`size_t`类型
> sizeof运算符以字节为单位返回运算对象的大小(在C中，1字节定义为char类型占用的空间大小)
> 过去，1字节通常是8位，但是一些字符集可能使用更大的字节
> 运算对象可以是具体的数据对象(如，变量名)或类型
> 如果运算对象是类型(如， float)，则必须用圆括号将其括起来

* C 规定，sizeof返回`size_t`类型的值
> 这是一个无符号整数类型， 但它不是新类型
* `size_t`是语言定义的标准类型
> C 有一个typedef机制
> 允许程序员为现有类型创建别名
> 例如:
> `typedef double real;`
> 这样，real就是double的别名
* 现在，可以声明一个real类型的变量:
> `real deal; // 使用typedef`
> 编译器查看real时会发现，在typedef声明中real已成为double的别名
> 于是把deal创建为double 类型的变量
> 类似地，C 头文件系统可以使用typedef把`size_t`作为`unsigned int`或`unsigned long`的别名
> 这样，在使用`size_t`类型时，编译器会根据不同的系统替换标准类型
* C99 做了进一步调整，新增了`%zd`转换说明用于`printf()`显示`size_t`类型的值
> 如果系统不支持`%zd`，可使用`%u`或`%lu`代替`%zd`

---

**求模运算符**

2. 求模运算符(modulus operator): `%`

* 用于整数运算
* 求模运算符给出其左侧整数除以右侧整数的余数(remainder)
> 例如，`13 % 5`(读作"13求模5")得3，因为13比5的两倍多3，即13除以5的余数是3
> 求模运算符只能用于整数，不能用于浮点数
* 求模运算符常用于控制程序流
> 例如，假设此时正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用
> 这种情况可以在程序中对月份求 模3(即，month % 3)，并检查结果是否为0
> 如果为0，便加进额外的费用

* 求模运算符作得出的结果就是所谓的取余运算所得出的结果
* 负数也可以进行求模运算，于C99开始支持了趋零截断

---

**递增运算符**

* 递增运算符(increment operator)-即为'++'

* 用于执行简单的任务，将其运算对象递增1
> 该运算符以两种方式出现
> 第1种方式，++出现在其作用的变量前面， 这是前缀模式
> 第2种方式，++出现在其作用的变量后面，这是后缀模式
>  两种模式的区别在于递增行为发生的时间不同

---

**while循环的执行逻辑**

* 根据所规定条件，对条件进行循环执行
* 例如规定了一个条件为`shoe < 18`，并且每执行一次就进行一次递加(++)的表达式
> 执行的逻辑是shoe的值递增1，然后和18进行比较，如果递增后的值小于18，则再次执行所规定的循环条件(即为所在花括号内的所有语句)
> 然后，shoe的值再递增1，以此重复刚才的不做，知道shoe的值不小于18为止

**图解示意:**

* 执行一次循环:

<img src="/images/数据类型-4//images/while循环-1.png" width="30%" height="30%">

---


**关于前缀递增和后缀递增**

* 这里举一个例子:
> `q = 2*++a;`，此语句为前缀形式递增，首先，a递增1，然后，2乘以a，并将结果赋给q
> `q =2*a++;`，此语句为后缀形式递增，首先，2乘以a，并将结果赋给q，然后，a递增1

* 单独使用递增运算符时(如，ego++;)，使用哪种形式都没关系
> 但是，当运算符和运算对象是更复杂表达式的一部分时(如上面的示例)
> 使用前缀或后缀的效果不同

---

**递减运算符**

* 每种形式的递增运算符都有一个递减运算符(decrement operator)与之对应
* 用--代替++即可:
> `--count; // 前缀形式的递减运算符`
> `count--; // 后缀形式的递减运算符`

* `>`运算符表示"大于"，`<`运算符表示"小于"，它们都是关系运算符(relational operator)

---

**递增运算符的优先级问题**

* 递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高
> 因此，`x*y++`表示的是`(x)*(y++)`，而不是`(x+y)++`
> 不过后者无效，因为递增和递减运算符只能影响一个变量(或者更普遍地说，只能影响一个可修改的左值)
> 而组合`x*y`本身不是可修改的左值

---

**不要自作聪明**

* 如果一次用太多递增运算符，自己都会糊涂-CN-C Primer Plus-第5.3.6章节

---

### 表达式和语句

* 术语: 表达式(expression)和语句(statement)
* C 的基本程序步骤由语句组成，而大多数语句都由表达式构成

**表达式:**

* 表达式(expression)由运算符和运算对象组成(运算对象是运算符操作的对象)
> 最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式

* 运算对象可以是常量，变量或二者的组合
> 一些表达式由子表达式(subexpression)组成(子表达式即较小的表达式)

* 每个表达式都有一个值
> C 表达式的一个最重要的特性是，每个表达式都有一个值
> 要获得这个值，必须根据运算符优先级规定的顺序来执行操作
> 关于表达式的值的具体描述这里不做赘述，因为它是一个范围极大的纯粹性概念
> 计算机中表达式的概念与数学中的表达式相同，值即为表达式的结果

---

**语句**

* 语句(statement)是C程序的基本构建块
> 一条语句相当于一条完整的计算机指令
> 在C中，大部分语句都以分号`';'`结尾

* 声明创建了名称和类型，并为其分配内存位置
> 注意，声明不是表达式语句
> 也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值:
> `int port /* 不是表达式，没有值 */`
* 赋值表达式语句在程序中很常用: 它为变量分配一个值
> 赋值表达式语句的结构是: 一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾
> 注意，在while循环中有一个赋值表达式语句
> 赋值表达式 语句是表达式语句的一个示例
* 函数表达式语句会引起函数调用
> 在该例中，调用printf()函数打印结果
> while语句有3个不同的部分: 首先是关键字while，然后圆括号中是待测试的条件，最后如果测试条件为真，则执行while循环体中的语句
> 多条语句需要用花括号括起来

* 图片-简单的while循环结构:


<img src="/images/数据类型-4/while循环-2.png" width="30%" height="30%">

* 这种语句是复合语句
> 该例的while循环中只有一条语句
> 可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句
> while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂

---

**关于副作用与序列点:**

* 类似于while之类的迭代循环语句通常还会有副作用(side effect)和序列点(sequence point)等概念，这里不做过多赘述
> 所谓的副作用，就是对于变量的赋值结果(此间的赋值结果由右值的表达式决定)
> 或称其为经由人工定义所得出的等式结果
> 所谓的序列点，就是程序执行的点，再该点上，所有的副作用都在进入下一步之前发生
> C 中的语句用分号`';'`来标记若干个序列点
> 其寓意就是在一个语句中，赋值运算符，递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成
> 还有一点就是，任何一个完整表达式的结束也是一个序列点

**关于完型表达式:**

* 完整表达式(full expression)
> 就是指这个表 达式不是另一个更大表达式的子表达式
> 例如，表达式语句中的表达式和while循环中的作为测试条件的表达式
> 都是完整表达式
> 序列点有助于分析后缀递增何时发生
> 千万要避免写出带有模棱两可逻辑的语句

**关于复合语句(块)**

* 复合语句(compound statement)是用花括号括起来的一条或多条语句
> 或称之为复合语句(或块)由花括号括起来的一条或多条语句组成
> 复合语句也称为块(block)
> 任何的程序都可以使用块以让while语句包含多条语句
> 在声明与描述复合语句的构成时，需要注意书写风格，其中最重要的是对于代码缩进的掌控

* 图片-带有符合语句的while循环

<img src="/images/数据类型-4/while循环-3.png" width="30%" height="30%">

---



