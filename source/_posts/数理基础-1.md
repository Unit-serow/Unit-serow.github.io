---
title: 数理基础-1
mathjax: true
date: 2020-04-07 23:56:01
tags: [随笔,data structure & algorithm]
categories: [软件,data structure & algorithm]
---

<center><strong>数理基础-1</strong></center>
<center><strong>数据结构与算法: C语言实现-1</strong></center>

<!-- more -->

### data structure & algorithm

* 数据结构 & 算法
* C 语言实现-1

---

* 引论
* 基本的数理知识
> 指数
> 对数
> 级数
> 模运算
> 证明方法
> 递归
> 离散数学

---

### 引论简述

**问题一:**

* 设有一组N个数而要确定其中第k个最大者
> 可以将这种问题称之为选择问题(selection problem)
> 此种显而易见的问题的解决方法有很多

**方法一:**

* 改问题的一种解法就是将这N个数读进一个数组中，再通过某种简单的算法
> 比如冒泡排序算法，以递归顺序将数组排序，然后返回位置k上的元素
* 还可以先把前k个元素读入数组并以递减的顺序对其排序，接着将剩下的元素再逐个读入
> 当新元素被读到时，如果它小于数组中的第k个元素时，则忽略，否则就将其放到数组中正确的位置上，同时将数组中的一个元素挤出数组
> 当算法终止时，位于第k个位置上的元素则作为答案返回

* 以上两种算法再合理的时间量内均不能结束，如果以存在其它更好的算法为前提
> 还依旧在现实中对其进行实现则不切合实际
> 关于此种问题的解决算法(方法)还有很多，接下来将会进行刨析，这里不做过多赘述

**问题二:**

* 第二个问题是解决一个流行的字谜
> 输入是由一些字母和单词的二维数组组成
> 目标是要找出字谜中的单词，这些单词可能是水平，垂直或沿对角线以任何方向放置的

* 以下图所示，该字谜由单词this，two，fat和that组成
> 单词this从第一行第一列的位置即(1，1)处开始并延伸至(1，4)
> 单词two从(1，1)到(3，1)，fat从(4，1)到(2，3)
> 而that则从(4，4)到(1，1)

* 字谜示例图片:

<img src="/images/数理基础-1/字谜游戏-1.png" width="40%" height="40%">

* 现在至少有两种直观的方法来求解该问题

**方法一:**

* 对单词表中的每个单词检查，检查到每一个有序三元组(行，列，方向)，验证是否有单词存在
> 此种方法需要大量嵌套的for循环，但它基本上是最直观的算法

**方法二:**

* 对于每一个尚未进行到字谜最后的有序四元组(行，列，方向，字符数)
> 可以测试所指的单词是否在单词表中，此种方法也将导致使用大量嵌套的for循环
> 如果在任意单词中的最大字符数已知，那么此种算法将有可能比上一种更节省一些时间

* 上述两种方法相对来说都不算太难编码并可求解发表于杂志上的许多现实的字谜游戏
> 这些字谜通常由16行16列以及40个左右的单词
> 然而可以将这些字谜视为只给出谜板(puzzle board)而单词表基本上是译本英语词典
> 则上面提出的两种解法则需要相当可观的时间来解决这个问题，所以两种方法都是不可接受的
> 不过这样的问题还是有可能在数秒内解决的，当然即便单词表很大的情况下也可以

* 在许多问题中，一个重要的观念是: 写处一个可以工作的程序并不够
> 如果这个程序在巨大的数据集上运行，那么运行时间就变成了重要的问题
> 之后的内容将会对此进行解析: 在对于大量数据的输入时，如何去预估程序的运行时间
> 尤其是如何在尚未具体编码的情况下比较两个程序的运行时间
> 还包括了彻底解决并改进程序运行速度以及确定程序瓶颈的方法
> 这些方法可以用于找到需要大力优化的那些代码段

---

### 基本的数理知识

* 包括了:
> 需要记住并且熟练运用的基础数理概念
> 并能够基于实际问题来推导出的基本公式
> 与基本证明方法的一些基本数理知识

**指数:**

* 指数基本公式图片:

<img src="/images/数理基础-1/指数基本公式-1.png" width="40%" height="40%">

* $X^{A} X^{B} = X^{A+B}$
* $\frac{X^A} {X^B} = X^{A-B}$
* $\left(X^{A}\right)^{B} = X^{AB}$
* $X^N+X^N = 2X^N ≠ X^2N$
* $2^N + 2^N = 2^{N+1}$

---

**对数公式:**

* 在计算机科学中，除非有特别的声明，所有的对数都是以二为底的
> 定义: $X^A = B$ ，当且仅当$\log_x{B} = A$

* 由此定义得出以下推论&定理等式:

* 定理一: $\log_A{B} = \frac{\log_C{B}} {\log_C{A}}; C>0$

* 证明:
> 令$X = \log_C{B}$，$Y = \log_C{A}$，以及$Z = \log_A{B}$
> 此时由对数的定义得: $C^X = B$，$C^Y = A$及其$A^Z = B$
> 联合这三个等式则产生$\left(C^Y\right)^Z = C^X = B$
> 因此，$X = YZ$，即意味着$Z = X/Y$
> 定理由此得证

* 定理二: $\log AB = \log A + \log B$

* 证明:
> 令$X = \log A$，$Y = \log B$，以及$Z = \log AB$
> 此时由于假设默认的底为2，$2^X = A$，$2^Y = B$及$2^Z = AB$
> 联合最后的三个等式则有: $2^X2^Y = 2^Z = AB$
> 因此 $X + Y = Z$
> 定理由此可证

* 其它一些有用的公式如下，它们都能够用类似的方法去推导
> $\log A/B = \log A - \log B$
> $\log\left(A^B\right) = B \log A$
> $\log X < X$(对所有的X>0成立)
> $\log 1 = 0$，$\log 2 = 1$，$\log 1 024 = 10$，$\log 1 048 576 = 20$
> 以上指数公式皆以2为底数

* 对数函数f(x)和指数函数g(x)互为反函数
> 由反函数的相关原理可知道f(1)=0，也就是说对数函数log1=0
* 指数函数和对数函数相应的图像是关于y=x对称的
> 对数函数始终过(0,1)点，指数函数则过(1,0)点

---

**级数公式:**

* 最基础的公式:

* $\sum\limits_{i=0}^{N} 2^i=2 = 2^{N+1} - 1$
* 与
* $\sum\limits_{i=0}^{N} = \frac{A^{N+1} - 1} {A - 1}$

* 在第二个公式中，如果$0 < A < 1$，则有:
> $\sum\limits_{i=0}^{N} A^i ≤ \frac{1} {1 - A}$

* 当N趋于$\infty$时该和趋向于$1/(1 - A)$
> 这些公式是几何级数公式

* 如果用下面的方法推导关于$\sum^{\infty}_{i=0}A^i$ $(0 < A < 1)$的公式
> 令S表示和，此时 $S = 1 + A + A^2 + A^3 + A^4 + A^5 + ······$
> 于是有: $AS = A + A^2 + A^3 + A^4 + A^5 + ······$

* 如果将两个等式相减(这种运算只能对收敛级数进行)，等号右边所有的项取消，只留下1
> $S - AS = 1$，这就是说 $S = \frac{1} {1-A}$

* 可以用相同的方法计算$\sum_{\infty}^{i=1} i/2^i$，它是一个经常出现的和
> 可以将其表示为: $S = \frac{1}{2} + \frac{2}{2^2} + \frac{4}{2^4} + \frac{5}{2^5} + ······$
> 用2乘之得到: $2S = 1 + \frac{2}{2} + \frac{3}{2^2} + frac{4}{2^3} + \frac{5}{2^4} + \frac{6}{2^5} + ······$
> 因此得出S=2

* 分析中另一种常用类型的级数是算术级数
* 任何这样的级数都可以通过基本公式来计算其值
> $\sum\limits_{N}^{i=1} i = \frac{N\left(N+1\right)}{2} ≈ \frac{N^2}{2}$

* 例如，为求出和$2+5+8+···+\left(3k - 1\right)$
> 将其改写为$3(1+2+3+···+k)-(1+1+1+···+1)$，显然，它就是$3k\left(k+1\right)/2-k$
> 另一种记忆的方法则是将第一项与最后一项相加(和为$3k+1$)，第二项与倒数第二项相加(和也是$3k+1$)，等等
> 由于有$k/2$个这样的数对，因此总和就是$k(3k+1)/2$，这与前面的答案相同

* 现在介绍下面的两个较为不常见的公式:
> $\sum\limits_{i=1}^{N} i^2 = \frac{N\left(N+1\right)\left(2N+1\right)}{6} ≈ \frac{N^3}{3}$
> $\sum\limits_{i=1}^{N} i^k ≈ \frac{N^{k+1}{| k+1 |}} k ≠ -1$

* 当k=-1时，后一个的公式不成立
> 此时则需要以下公式，这个公式在计算机科学中的使用要远比在数学其它科目中使用的多
> 数$H_N$被称为调和数，其和叫做调和和
* 下面近似中的误差趋向于$\gamma ≈ 0.57721566$，这个值被称为欧拉常数(Euler's constant)
> $H_N = \sum\limits_{i=1}^{N}\frac{1}{i} ≈ \log_{e}N$

* 以下两个公式只不过是一般的代数运算:
> $\sum\limits_{i=1}^{N} f\left(N\right) = Nf\left(N\right)$
> $\sum\limits_{i=n_0}^{N} f(i) = \sum\limits_{i=1}^{N} f(i) - \sum\limits_{i=1}^{n_{0}-1} f(i)$

---

### 参考资料:

* 数据结构与算法分析 -C 语言描述 第二版
> 第一章节

---



