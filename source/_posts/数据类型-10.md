---
title: 数据类型-10
date: 2020-03-22 02:58:59
tags: [随笔,C]
categories: [软件,C/C++]
---

<center><strong>数据类型-数组类型&指针类型</strong></center>

<!-- more -->

## 数据类型-10

---

## 数组&指针

**相关内容:**

* static关键字
* 一元运算符: `&`，`*`
* 数组基础概念刨析(泛用概念之一)
* 指针，指针和数组的关系
* 函数对于数组的处理
* 二维数组~多维数组

**相关介绍:**

* 当在当前程序中需要处理大量相关数据时，通常使用数组能高效便捷地处理这种数据
* 同时可以函数把模块化编程的优势应用到数组，并且数组与指针的关系非常密切

---

## 数组

### 数组-基本概念

**概述:**

* 数组由数据类型相同的一系列元素组成
> 需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型
> 编译器根据这些信息正确地创建数组
> 普通变量可以使用的类型，数组元素都可以用

* 通常情况下，使用方括号([])来表明数组，方括号中的数字表明数组中的元素个数，方括号前则为对数组的命名，即为内存标识符
> 要访问数组中的元素，通过使用数组下标数(也称为索引)表示数组中的各元素
> 数组元素的编号从0开始，所以xxx[0]表示xxx数组的第1个元素

---

**关于初始化数组:**

* 数组通常被用来储存程序需要的数据
> 例如一个内含12个整数元素的 数组可以储存12个月的天数
> 在这种情况下，在程序一开始就初始化数组比较好

* 只储存单个值的变量有时也称为标量变量(scalar variable)
> 初始化这种变量即为给变量赋值，将右值通过赋值符号赋给左值

* ANSI C 初始化数组的基本语法:
> `int unit[7] = {1,2,3,4,5,6,7,}`

* 用以逗号分隔的值列表(用花括号括起来)来初始化数组， 各值之间用逗号分隔
> 在逗号和值之间可以使用空格
> 根据上面的初始化， 把1赋给数组的首元素(powers[0])，以此类推
> 不支持ANSI的编译器会把这种形式的初始化识别为语法错误
> 在数组声明前加上关键字static可解决此问题

* 还可以给数组内的存储容量，也就是放括号内的数组用#define设置为符号常量
> 比如: #define serow 10~int unit[serow] = {1,2,3,4...,10};
> 如果要需要将10换一个其它的字符，子需要修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方

* 关于使用const声明数组
> 有时需要把数组设置为只读
> 这样，程序只能从数组中检索值，不能把新值写入数组
> 要创建只读数组，应该用const声明和初始化数组
> 因此可以将其写为: const int unit[serow] = {1,2,3,4...,10};

* 这样修改后，程序在运行过程中就不能修改该数组中的内容
> 和普通变量一样，应该使用声明来初始化const数据
> 因为一旦声明为const，便不能再给它赋值
> 明确了这一点，就可以在其它的代码块中使用const了

**关于初始化数组失败:**

* 使用数组前必须先初始化它
> 与普通变量类似，在使用数组元素之前， 必须先给它们赋初值
> 因为编译器使用的值是内存相应位置上的现有值

**关于存储类别警告:**

* 数组和其他变量类似，可以把数组创建成不同的存储类别(storageclass)
> 关于存储类别的相关内容这里不做过多赘述
> 多数的数组都属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static
> 多数的变量和数组都是自动存储类别

* 不同的存储类别有不同的属性，除此之外还有其它的存储类别
> 对于一些其它存储类别的变量和数组，如果在声明时未初始化
> 编译器会自动把它们的值设置为0

**关于初始化列表中的项数应与数组的大小不一致问题:**

* 假如有此种情况: #define SIZE 4~int some_data[SIZE] = {1,2};
> 当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0
> 也就是说，如果不初始化数组， 数组元素和未初始化的普通变量一样，其中储存的都是垃圾值
> 但是，如果部分初始化数组，剩余的元素就会被初始化为0
> 如果初始化列表的项数多于数组元素个数，编译器则会将其视为错误

* 同时还可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数
> 类似于: `int days[] = {1,2,3,4};`
> 使用此类方法时要注意以下两点
> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小
> 整个数组的大小除以单个元素的 大小就是数组元素的个数

* 这里写一个程序用作示例:

```
#include <stdio.h>

int main(void)
{
	const int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31 };
	int index;
	for (index = 0; index < sizeof days / sizeof days[0]; index++)
	printf("Month %2 has %d days.\n", index + 1, days[index]);
	return 0;
}
```

* 关于该程序需要注意以下两点:
> 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小
> 注意for循环中的测试条件
> 由于人工计算容易出错，所以让计算机来计算数组的大小
> sizeof运算符给出它的运算对象的大小(以字节为单 位)
> 所以sizeof days是整个数组的大小(以字节为单位)，sizeof day[0]是数组中一个元素的大小(以字节为单位)
> 整个数组的大小除以单个元素的大小就是数组元素的个数

* 下面是该程序的输出:

```
Month 1 has 31 days.
Month 2 has 28 days.
Month 3 has 31 days.
Month 4 has 30 days.
Month 5 has 31 days.
Month 6 has 30 days.
Month 7 has 31 days.
Month 8 has 31 days.
Month 9 has 30 days.
Month 10 has 31 days.
```

* 这里1的本意是防止初始化值的个数超过数组的大小，让程序找出数组大小
> 程序中初始化时用了10个值，结果就只打印了10个值
> 这就是自动计数的弊端，即为无法察觉初始化列表中的项数有误

* 还有一种初始化数组的方法，但这种方法仅限于初始化字符数组
> 这里先不做过多赘述

* 所谓的初始化，用一种不是太严谨的方法来描述的话就是给其变量赋值，只不过是第一次对其赋值

---

**关于指定初始化器/C 99:**

* C99 增加了一个新特性: 指定初始化器(designated initializer)
> 利用该特性可以初始化指定的数组元素
> 例如，只初始化数组中的最后一个元素
> 对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素， 才能初始化它:
> `int arr[6] = {0,0,0,0,0,212};	// 传统的语法`
> 而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素:
> `int arr[6] = {[5] = 212};	// 把arr[5]初始化为212`
> 对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0

* 以此程序进行示例说明:

```
#include <stdio.h>
#define MONTHS 12

int main(void)
{
	int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1] = 29};
	int i;
	for (i = 0; i < MONTHS; i++)
	printf("%2d %d\n", i + 1, days[i]);
	return 0;
}
```

---

**待补充**

---

* 数组类型前面关于数据类型的文章有所提及
* 关于 C 数组&指针在后面的文章内会进行补充性质的刨析(尤其是针对于指针)

---

## 补充内容

### 数组与指针-补全

* 时隔半个月的补全计划，已经颓废太久了......

---

* 所参考书籍资料已经更换为CN-【《The C Programming Language》/《C 程序设计语言》】
> 章节: 5.1-5.12

* 所涉及概念
> 指针与地址
> 指针与函数参数
> 指针与数组
> 地址算术运算
> 字符指针与函数
> 指针数组以及指向指针的指针
> 多维数组
> 指针数组的初始化
> 指针与多维数组
> 命令行参数
> 指向复杂函数的指针
> 复杂声明

---

### 指针与地址

* ANSI C 明确的制定了操纵指针的规则
* ANSI C 使用类型`void*`(指向void的指针)代替`char*`作为通用的指针类型

* 通常的机器都有一系列连续编号或编址的存储单元，这些存储单元可以单个进行操纵，也可以以连续成组的方式操纵
> 通常情况下，机器的一个字节可以存放一个char类型的数据，两个相邻的字节存储单元即可以存储一个short(短整型)类型的数据
> 则四个相邻的字节存储单元可以存储一个long(长整型)类型的数据
> 指针是能够存放一个地址的一组存储单元(通常是两个或四个字节)

* 以以下图片种所示的关系为例，这里将其设为: c的类型为char，并且p是指向c的指针

/images/数据类型-10/指针-1.png

* 一元运算符`&`可用于取一个对象的地址
> 则`p = &c;`语句将把c的地址赋值给变量p，则可将p称为指向c的指针
> 地址运算符&只能应用于内存中的对象，即变量与数组元素
> 它不能作用于表达式，常量或register类型的变量

* 一元运算符`*`是间接寻址或间接引用运算符
> 当其作用于指针时，将访问指针所指向的对象
> 这里假设x与y是整数，而ip是指向int的指针
> 以下代码段说明了如何在程序中声明指针以及如何使用运算符`&`和`*`
```
int x = 1, y =2, z[10];
int *ip; /* 此时的ip是指向int类型的指针 */

ip = &x; /* ip现在指向x */
y = *ip; /* y的值现在为1 */
*ip = 0; /* x的值现在为0 */
ip = &z[0]; /* ip现在指向z[0] */
```

* 具体说明-1:
> `int *ip;` 这么声明是为了更加便于记忆，该声明语句表明表达式`*ip`的结果是int类型
> 这种声明变量的语法与声明该变量所在的表达式的语法类似
> 同样的原因，对函数的声明也可以采用这种方式
> 例如此声明: `double *dp, atof(char *)`
> 这里表明了在表达式中，*dp和atof(s)的值都是double类型，且atof的参数是指向char类型的指针

* 这里需要去主义的一点就是指针只能指向某种特定类型的对象，也就是说每个指针都必须指向某种特定的数据类型
> 还有一个例外的情况是指向void类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身
* 如果指针ip指向整形变量x，那么在x可以出现的任何上下文种都可以使用`*ip`
> 因此，语句: `*ip = *ip + 10;` 即为把`*ip`的值增加10

* 一元运算符`*`和`&`的优先级比算术运算符的优先级高
> 因此，赋值语句`y = *ip + 1`将把`*ip`指向的对象的值取出并加1，然后再将结果赋值给y
* 而此赋值语句: `*ip += 1`则将ip指向的对象的值加1，它将等同于`++*ip`或`(*ip)++`语句的执行结果
> 语句(*ip)++种的圆括号是必须的，否则该表达式将对ip进行加一计算，而不是对ip指向的对象进行加一计算
> 这是因为类似于`*`和`++`这样的一元运算符遵循从右至左的结合顺序

* 最后需要说明的一点就是，由于指针也是变量，所以在程序中可以直接使用，而不必通过间接引用的方法去使用
> 例如，如果iq是另一个指向整形的指针，那么语句`iq = ip`将把ip中的值拷贝到iq中，这样，指针iq也将指向ip指向的对象

---

### 指针与函数参数

* 由于 C 是以传值的方式将参数值传递给调用函数
> 因此被调用函数不能直接修改主函数中变量的值
> 所谓的参数值传递即为线性规则传递
> 当被调用函数内的进行参数传递的执行逻辑为非线性传递时
> 之后对其被调用函数内的变量值传递将不会达到预想的结果

```
void swap(int x, int y)
{
   int temp;
   
   temp = x;
   x = y;
   y = temp;
}
```

> 则下列语句将无法达到该目的
> `swap(a, b);`

* 这是因为由于参数传递采用传值的方式，因此上述的swap函数不会影响到调用它的例程中的参数a和b的值
> 该函数仅仅交换了a和b的副本的值

* 此时的解决方法为: 可以使主调程序将指向所要交换的变量的指针传递给被调用函数
> 即为: `swap(&a, &b)`

* 由于一元运算符&用来取变量的地址，这样&a就是一个指向变量a的指针
> swap函数的所有参数都声明为指针，并且通过这些指针来间接访问他们所指向的操作数
> 即为以下程序:

```
void swap(int *px, int *py) /* 交换*px和*py */
{
   int temp;

   temp = *px;
   *px = *py;
   *py = temp;
}
```

* 指针参数使得被调用函数能够访问和修改主调函数中对象的值

* 上述内容的图片说明:

/images/数据类型-10/指针-2.png

* 说白了就是利用指针来完成类似于跳跃式或将其称之为非线性的逻辑值传递

---

### 指针与数组

* 在 C 中，指针与数组之间的关系非常密切
> 通过数组下标所能完成的任何操作都可以通过指针来实现
> 一般来说，用指针编写的程序比用数组下标编写的程序的执行速度更快
> 另一方面就是用指针实现的程序可能会更加令人费解

* 这里声明一个整形数组: `int a[10];`
> 定义了一个长度为10的数组a
> 或将其称之为定义了一个由10个对象组成的集合，这10个对象存在相邻的内存区域中
> 名字分别为a[0],a[1],...,a[9]

* 图示说明:

/images/数据类型-10/数组-1.png

* a[i]则表示该数组的第i个元素，调用逻辑为完全线性
> 如果pa的声明为`int *pa`则说明它是一个指向整形对象的指针
> 那么，赋值语句pa = &a[10];则可以将指针pa指向数组a的第0个元素
> 也就是说，pa的值为数组元素a[0]的地址

* 如下图所示

/images/数据类型-10/数组-1.png

* 这样的话赋值语句`x = *pa;`将会把数组元素a[0]中的内容复制到变量x中

* 如果pa指向数组元素中的某个特定元素，那么根据指针的运算定义，pa+1将指向下一个元素
> 则pa+i将指向数组元素之后的第i个元素，而pa-i则指向pa所指向数组元素之前的第i个元素
> 因此，如果指针pa指向a[0]，那么`*(pa+1)`引用的将会是数组a[1]的内容
> pa+i是数组元素a[i]的地址，`*(pa+i)`引用的则是数组元素a[i]的内容

* 如下图所示:

/images/数据类型-10/数组-3.png

---

* 所以说，无论数组a中元素的类型或数组的长度是什么，上面所阐述的结论都将成立
> 指针加1就意味着pa+1指向pa所指向的对象的下一个对象
> 相应的，pa+i指向pa所指向的对象之后的第i个对象

* 下标和指针运算之间具有密切的对应关系
> 根据定义，数组类型的变量或表达式的值是该数组第0个元素的地址
> 执行赋值语句`pa = &a[0];`后，pa和a具有相同的值
> 因为数组名所代表的就是数组最开始的第一个元素
> 所以赋值语句pa=&a[0]也可以写成此种形式: pa = a;

* 对数组元素a[i]的引用也可以写成`*(a+i)这种形式`
> 在计算数组元素a[i]的值时，C 实际上会先将其转化为`*(a+i)`的形式，然后再进行求值
> 因此再程序种这两种形式是完全等价的

* 如果对这两种等价的表示分别施加地址运算符&
> 便可以得出此结论: &a[i]和a+i的含义也是相同的
> a+i是a之后的第i个元素的地址

* 相应的，如果pa是一个指针，那么，再表达式中也可以在它的后面加下标
> `pa[i]`与`*(pa+i)`是等价的
> 简而言之，一个数组和下标实现的表达式可等价地通过指针和偏移量实现

* 但是这里还需要去必须记住的一点就是数组名和指针之间有一个不同之处
> 指针是一个变量，因此，在 C 内，语句pa=a和pa++都是合法的
> 但数组名不是变量，因此，类似于a=pa和a++形式的语句是非法的

* 当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址
> 在被调用函数中，该参数是一个局部变量
> 因此，数组名参数必须是一个指针，也就是一个存储地址的变量

* 如果将数组名传递给函数，函数则可以根据情况来判断是按照数组处理还是按照指针处理，随后根据相应的方式去操作该函数
> 为了直观且恰当的描述函数，在函数中甚至可以同时使用数组和指针这两种表示方法
> 也可以将指向子数组起始位置的指针传递给函数，以此将数组的一部分传递给了函数
> 还有一点就是引用数组边界之外的任何对象都是非法的

* 我也不知道为什么这么一个简单的概念要重复这么多遍

---

**截止至5.3-待补充**

---



