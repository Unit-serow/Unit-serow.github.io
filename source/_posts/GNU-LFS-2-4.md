---
title: GNU-LFS-2-4
date: 2020-02-29 19:26:43
tags: [随笔,GNU/Linux]
categories: [软件,GNU]
---

## GNU LFS-2-4

* [GNU 工具链]全面逻辑梳理
* 重点在于配置链接器与工具链的逻辑

---

### 简要说明

* 可以将临时主机的工具链搭建分为两部分
* 前半部分为第一遍编译并安装GCC，Binutils和内核头文件
* 后半部分为编译并安装Glibc，在配置完Glibc之后，正式调整临时工具链并再次安装GCC与Binutils
* 第一步与第二部和第五步与第六步的顺序没有严格规定
* 但对GCC与Binutils的第二次编译安装必须在先配置并且编译安装完Glibc之后再进行
---
* `Binutils->GCC->Headres->GLibc->Tools调整->Binutils->GCC/C++补丁`
* 参考至`LFSv6.2/6.3`
---
* 因为这里所使用的LiveCD是LFS官方提供的
* 由于官方于6.3版本之后就停止维护了
* 所以这里只介绍6.3及以下版本
---
* 这里将以下七个工具所需要的
* 每个工具编译的重要步骤
* 与对工具链的链接和链接器的配置进行了逻辑的梳理

---

### 1. Binutils Pass-1

* 编译并安装过后
* 为调整工具链而准备链接器

> `$ make -C ld clean`
> `$ make -C ld LIB_PATH=/tools/lib` 
> `$ cp -v ld/ld-new /tools/bin`

* 参数`-C ld LIB_PATH=/tools/lib`
* 指定`Makefile`的`LIB_PATH`变量值
* 使其明确指向临时工具目录，以覆盖默认值
* 这个变量同时还指定了链接器的默认库搜索路径
* 在编译完Glibc后就会用到

---

### 2. GCC Pass-1

* 编译并安装过后
* 创建gcc的符号链接为cc，以保证兼容性
> `$ ln -vs gcc /tools/bin/cc`

---

### 3. kernel headers API

* 将头文件编译并复制到所需目录

---

### 4. Glibc
* 编译并安装C标准库
* 执行`touch /tools/etc/ld.so.conf`
* 以修补安装过程中缺少的`/tools/etc/ld.so.conf`

---

### 5. 调整工具链(LFS-v6.2/v6.3)
* 在临时系统的C标准库安装好之后
* 需要将临时工具链中的所有工具都连接到C标准库之上
* 为了达到这个目标，必须调整链接器和编译器的space文件

* 因为Binutils Pass-1的时候以经调整过链接器了
* 所以现在需要做的只是将其重新命名并被正确的找到和使用
* 方法是备份原来的链接器，然后再用调整过的链接器来替代
* 最后再创建一个指向`/tools/$(gcc -dumpmachine)/bin`中链接器副本的链接

> `$ mv -v /tools/bin/{ld,ld-old}`
> `$ mv -v /tools/$(gcc -dumpmachine)/bin/{ld,ld-old}`
> `$ mv -v /tools/bin/{ld-new,ld}`
> `$ ln -sv /tools/bin/ld /tools/$(gcc -dumpmachine)/bin/ld`

* 从现在开始，所有程序都将连接到`/tools/lib`中的库文件

---

* 接下来需要做的就是修正GCC中的spaces文件
* 目的是使他指向一个新的动态链接器
* 本质上就是把specs中所有的`/lib/ld-linux.so.2`都替换成`/tools/lib/ld-linux.so.2`
* 这里用的是sed命令，有两种语法(分别是LFS-v6.2与LFS-v6.3)
* 如果当前的本地主机上的动态连接器的名字不是`ld-linux.so.2`
* 必须人为的把以下命令里的`ldlinux.so.2`换成本地主机的系统平台上动态连接器的名

* LFS-v6.2

```
$ SPECFILE=`dirname $(gcc -print-libgcc-file-name)`/specs && 
gcc -dumpspecs > $SPECFILE &&
sed 's@^/lib/ld-linux.so.2@/tools&@g'	$SPECFILE > tempspecfile &&
mv -vf tempspecfile	 $SPECFILE && 
unset SPECFIL
```

* LFS-v6.3

> `$ gcc -dumpspecs | sed 's@^/lib/ld-linux.so.2@/tools&@g' > `dirname $(gcc -print-libgcc-file-name)`/ specs `

---

* 最后删除GCC专属头文件目录中的头文件，以避免宿主机中的头文件污染编译环境
* 这里的命令v6.2与v6.3没有区别
```
$ GCC_INCLUDEDIR=`dirname $(gcc -print-libgcc-file-name)`/include &&
find ${GCC_INCLUDEDIR}/* -maxdepth 0 -xtype d -exec rm -rvf '{}' \; &&
rm -vf `grep -l "DO NOT EDIT THIS FILE" ${GCC_INCLUDEDIR}/*` &&
unset GCC_INCLUDEDIR
```

* 工具链的调整方法有好几种
* 而且不同版本GCC的specs可能会有不同
* 但实际上都是把specs文件中的`/lib/ld-linux.so.2`替换成`/tools/lib/ld-linux.so.2`
* 还直接用`gcc -dumpspecs`导出后手工直接编辑specs文件

---

### 6. Binutils Pass-2
* 编译并安装
* 编译配置中配置参数`--with-lib-path=/tools/lib`
* 以指示configure脚本在Binutils编译过程中将传递给连接器的库搜索路径设为`/tools/lib`
* 以防止连接器搜索宿主系统的库目录

* 最后为目标主机的调整工具链阶段配置链接器:
> `$ make -C ld clean`
> `$ make -C ld LIB_PATH=/usr/lib:/lib` 
> `$ cp -v ld/ld-new /tools/bin`

---

### 7. GCC/C++补丁 Pass-2

* 在GCC编译过程中会运行`fixincludes脚本`来扫描系统头文件目录
* 并找出需要修正的头文件，然后把修正后的头文件放到GCC专属头文件目录里
* 因为现在GCC和Glibc已经安装完毕，而且它们的头文件已知无需修正
* 所以这里并不需要`fixincludes脚本`

* 必须先禁止fixincludes运行，以保证编译环境不受原主机所污染
> `$ cp -v gcc/Makefile.in{,.orig} &&`
> `$ sed 's@\./fixinc\.sh@-c true@' gcc/Makefile.in.orig > gcc/Makefile.in`

* 因为在前几步中编译的GCC Pass-1中进行的`bootstrap`编译使用了`-fomit-frame-pointer`选项
* 而非`bootstrap`编译则默认忽略了该选项
* 所以需要使用下面的sed命令来确保在非`bootstrap`编译时也同样使用`-fomit-frame-pointer`选项
* 用以保持一致性:

```
$ cp -v gcc/Makefile.in{,.tmp} &&
sed 's/^XCFLAGS =$/& -fomit-frame-pointer/' gcc/Makefile.in.tmp \
	> gcc/Makefile.in
```

* 然后使用补丁修改补丁修改GCC的缺省动态连接器(通常是`ld-linux.so.2`)的位置:
> `$ patch -Np1 -i /lfs-sources/gcc-4.1.2-specs-1.patch`

* 该命令同时还把/usr/include`从GCC的头文件搜索路径里删掉
* 现在预先打补丁而不是在安装GCC之后调整specs文件可以保证新的动态连接器在编译GCC的时候就用上
* 也就是说，随后的所有临时程序都会连接到新的Glibc上

* 然后配置编译器，并进行编译与编译安装

* 关于GCC的C++是在LFS-v9.0中出现的，这里先不做过多阐述

---

* 至此结束临时主机的[GNU 工具链]配置环节
* 下一步即为配置其它的辅助命令与工具链所处的大环境
* 从而为目标主机提供应有的功能与服务

---



