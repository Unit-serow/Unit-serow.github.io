---
title: 数据类型-9.1
date: 2020-03-19 21:15:38
tags: [随笔,C]
categories: [软件,C/C++]
---

<center><strong>数据类型-函数-1</strong></center>

<!-- more -->

### 数据类型-9.1

* 函数-基本概念

---

### 函数-基本概念

**涉及概念:**

* return关键字
* 一元运算符
* 方法的类型，定义，参数，及其返回值

---

**相关概念:**

* 函数参数内对指针类型变量的调用
* ANSI C 原型
* 递归

--- 

**结构化组织程序:**

* C 的设计思想
> 在 C 内，函数用作构件块，而所谓的程序即为由代码块拼接而成
> 至今为止所涉及的C 标准库的函数有如: printf()，scanf()，getchar()，putchar()和strlen()
> C 内还允许创建函数

---

**关于函数:**

* 函数(function)是完成特定任务的独立程序代码单元
> 语法规则定义了函数的结构和使用方式
> 虽然C中的函数和其他语言中的函数，子程序，过程作用相同，但是细节上略有不同
> 一些函数执行某些动作，如printf()把数据打印到屏幕上
> 一些函数找出一个值供程序使用， 如strlen()把指定字符串的长度返回给程序
> 一般而言，函数可以同时具备以上两种功能

* 关于使用函数:
> 使用函数可以省去编写重复代码的苦差
> 如果程序要多次完成某项任务，那么只需编写一个合适的函数
> 就可以在需要时使用这个函数，或者在不同的程序中使用该函数
> 就像许多程序中使用putchar()一样
> 其次，即使程序只完成某项任务一次，也值得使用函数
> 因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改并完善

* 这里假设已经定义了若干个函数声明，并于主函数mian()内进行了符合逻辑的功能性调用
> 接下来要做事就是将这若干个函数声明进行定义补充，还称其为为其进行细节描述
> 描述性的函数名能清楚地表达函数的用途和组织结构
> 然后，单独设计和测试每个函数，直到函数都能正常完成任务
> 如果这些函数够通用，还可以用于其他程序

**其它内容:**

* 许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的"黑盒"
> 如果不是自己编写函数，根本不用关心黑盒的内部行为
> 例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及printf()生成的输出
> 无需了解 printf()的内部代码
> 以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上
> 因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务， 以及函数和程序整体的关系

* 为了解函数而需要做到的基本理解: 正确地定义函数，如何调用函数和如何建立函数间的通信

---

### 函数-基本使用

* 以下的说明都基于该程序:
```
#include <stdio.h>
#define NAME "GIGATHINK, INC."
#define ADDRESS "101 Megabuck Plaza"
#define PLACE "Megapolis, CA 94904"
#define WIDTH 40

void starbar(void);

int main(void)
{
	starbar();
	printf("%s\n", NAME);
	printf("%s\n", ADDRESS);
	printf("%s\n", PLACE);
	starbar();
	return 0;
}

void starbar(void)
{
	int count;
	for (count = 1; count <= WIDTH; count++)
	putchar('*');
	putchar('\n');
}
```

* 其输出结果为:
```
****************************************
GIGATHINK, INC.
101 Megabuck Plaza
Megapolis, CA 94904
****************************************
```

---

**程序分析:**

* 程序在三处使用了starbar标识符: 函数原型(function prototype)告诉编译器函数starbar()的类型
> 函数调用(function call)表明在此处执行函数
> 函数定义(function definition)明确地指定了函数要做什么

* 函数和变量一样，有多种类型
> 任何程序在使用函数之前都要声明该函数的类型
> 因此，在main()函数定义的前面出现了下面的ANSI C风格的函数

* 原型：
> `void starbar(void);`
> 圆括号表明starbar是一个函数名
> 第1个void是函数类型，void类型表明函数没有返回值
> 第2个void(在圆括号中)表明该函数不带参数
> 分号表明这是在声明函数，不是定义函数
> 也就是说，这行声明了程序将使用一个名为starbar()，没有返回值，没有参数的函数，并告诉编译器在别处查找该函数的定义

* 对于不识别ANSI C风格原型的编译器，只需声明函数的类 型，如下所示：
> `void starbar();`
> 注意，一些老版本的编译器甚至连void都识别不了
> 如果使用这种编译器，就要把没有返回值的函数声明为int类型
> 当然，最好还是换一个新的编译器

* 一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型
> 这些信息称为该函数的签名(signature)
> 对于starbar()函数而言，其签名是该函数没有返回值，没有参数
> 程序把 starbar()原型置于 main()的前面
> 当然，也可以放在main()里面的声明变量处，放在哪个位置都可以

* 在main()中，执行到下面的语句时调用了starbar()函数：
> `starbar();`
> 这是调用void类型函数的一种形式
> 当计算机执行到starbar();语句时， 会找到该函数的定义并执行其中的内容
> 执行完starbar()中的代码后，计算机返回主调函数(calling function)继续执行下一行(本例中，主调函数是main())
> 更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码

* 程序中strarbar()和main()的定义形式相同
> 首先函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以右花括号结束
> 注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()
> 而不是调用函数或声明函数原型

* 程序把starbar()和main()放在一个文件中
> 当然，也可以把它们分别放在两个文件中
> 把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数
> 如果把函数放在一个单独的文件中，要把#define和#include指令也放入该文件
> 稍后会讨论使用多个文件的情况
> 现在，先把所有的函数都放在一个文件中
> main()的右花括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器starbar()是一个函数

---

**图解说明:**

* 以上程序所属的程序流:

<img src="/images/数据类型-9/函数-基本流程-1.png" width="40%" height="40%">

* 一个简单函数的结构:

<img src="/images/数据类型-9/一个简单函数的结构-1.png" width="40%" height="40%">

* starbar()函数中的变量count是局部变量(local variable)
> 意思是该变量只属于starbar()函数
> 可以在程序中的其他地方(包括main()中)使用 count，这不会引起名称冲突，它们是同名的不同变量
> 如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号
> 不用给该函数提供任何输入，因为调用它不需要其他信息
> 而且，它没有返回值，所以也不给 main()提供(或返回)任何信息
> 简而言之，starbar()不需要与主调函数通信

* 关于函数间的通信稍后进行阐述

---

**待补充**

---

561~640/79

---



