---
title: 数据类型-2
date: 2020-03-11 13:15:27
tags: [随笔,C]
categories: [无,concept]
---

<center><strong>存储原理-算术类型-1</strong></center>

<!-- more -->

## 基本数据类型存储原理

* 数据类型系统-基本类型
* 算术类型，其包含了整数类型与浮点类型
* 这里的数值大小以 C 的 C11 标准为例
> C 标准对基本数据类型只规定了允许的最小大小

---

* 常用基本数据类型占用空间(64位机器为例)

1. 整数类型/char: 1个字节
2. 整数类型/int: 4个字节
3. 浮点类型/float: 4个字节
4. 浮点类型/double: 8个字节

* 以 ISO C 标准为例
> 此规定规定int的取值范围最小为`-32768～32767`

---

## 整数存储原理

* 在计算机内的整数与数学一样，即为没有小数部分的实数
* 计算机以二进制数字的模式来存储整数
* 存储的位置即为变量标识符所对应的内存地址，与其指令集所指的CPU寄存器
* 变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式
* 同时还可将其称之为数据类型系统的基本类型部分
* 被归纳于算术类型，包括了整数类型与浮点类型
* 这里以C为例
* C语言中的整数类型可表示不 同的取值范围和正负值，一般情况使用int类型即可，但是为满足特定任务和 机器的要求，还可以选择其他类型
* int类型是有符号整型，即int类型的值必须是整数，可以是正整数，负整数或零
* 一般而言，储存一个int要占用一个 机器字长
* 声明之后便为被声明的若干个int大小的变量赋予名称并分配内存空间
* 可以赋值或初始化变量(initialize)
* 简而言之，声明为变量创建和标记存储空间，并为其指定初始值
* C语言把大多数整型常量视为int类型，但是非 常大的整数除外
* 并且int类型拥有常量概念

**声明执行逻辑图示:**

* 定义并初始化变量:

<img src="/images/整数类型原理图片/数据类型声明-1.png" width="30%" height="30%">


**举例说明:**

* 例如7则以对应的二进制111来存储
> 因此，要在8位字节中储存 该数字，需要把前5位都设置成0，后3位设置成1

**图解说明:**

* 使用二进制编码储存整数7

<img src="/images/整数类型原理图片/整数类型-1.png" width="30%" height="30%">

---

### 关于整数值的范围

**整数类型**

* 下表列出了关于标准整数类型的存储大小和值范围的细节：

|类型|存储大小|值范围|
|:----|:----|:----|
|char|1 字节|-128 到 127 或 0 到 255|
|unsigned char|1 字节|0 到 255|
|signed char|1 字节|-128 到 127|
|int|2 或 4 字节|-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647|
|unsigned int|2 或 4 字节|0 到 65,535 或 0 到 4,294,967,295|
|short|2 字节|-32,768 到 32,767|
|unsigned short|2 字节|0 到 65,535|
|long|4 字节|-2,147,483,648 到 2,147,483,647|
|unsigned long|4 字节|0 到 4,294,967,295|

* 同时还可以使用sizeof运算符，即表达式sizeof(type)，以获取某个类型或某个变量对象或存储类型在特定硬件平台的准确存储字节大小

**图解说明**

* 注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主
> 以下列出了32位系统与64位系统的存储大小的差别(windows 相同):

<img src="/images/整数类型原理图片/C-32-64.png" width="30%" height="30%">


---

## 浮点类型存储原理

* 在计算机中，浮点数与数学中实数的概念差不多
* 比如`2.75`,`3.16E7`,`7.00`和`2e-8`都是浮点数，即在一个值后面加上一个小数点，该值就成为一个浮点值
* 所以7是整数，`7.00`是浮点数
* e记数法简述: `3.16E7`表示`3.16×10^7`，其中E的作用就是10倍原数的对应指数级单位

* 浮点数和整数的储存方案不同
* 计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分
* 在十进制下，可以把7.0写成 0.7E1，但这里，0.7是小数部分，1是指数部分
* 当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂

* 整数没有小数部分，浮点数有小数部分
* 且浮点数可以表示的范围比整数大
* 对于一些算术运算(如，两个很大的数相减)，浮点数损失的精度更多

**图示说明:**

* 一个储存浮点数的例子，以浮点格式(十进制)储存π的值

<img src="/images/整数类型原理图片/浮点数类型.png" width="30%" height="30%">


* 因为在任何区间内(如，1.0 到 2.0 之间)都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值
* 浮点数通常只是实际值的近似值
* 例如，7.0可能被储存为浮点值6.99999，稍后讨论精度
* 在过去，浮点运算比整数运算慢
* 不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距

---

### 关于浮点值的范围

**浮点类型**

* 下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：

|类型|存储大小|值范围|精度|
|:----|:----|:----|:----|
|float|4 字节|1.2E-38 到 3.4E+38|6 位小数|
|double|8 字节|2.3E-308 到 1.7E+308|15 位小数|
|long double|16 字节|3.4E-4932 到 1.1E+4932|19 位小数|

* 头文件`float.h`定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节

---

## C 数据类型转换

* C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型
* 在 C 语言中也可以对数据类型进行强制转换

**自动转换规则:**

1. 浮点数赋给整型，该浮点数小数被舍去；
2. 整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中； 

* 强制类型转换形式: [(类型说明符) (表达式)]

---

### 关于不同进制的说明:

* 2进制，8进制和16进制

* 以0为前缀用于表示8进制
> 比如十进制转换为8进制则为020
* 以0x或0X为前缀用于表示16进制
> 比如十进制数转为16进制则为0x10或0X10

* 使用不同的进制是为了方便，其可以完全保证不会影响被存储的方式
* 可以使用标识符`%d`，`%o/%x`来分别显示(格式化输出)八进制与十六进制数字
* 而使用标识符`%#o`，`%#x`，`%#X`可以显示各进制的前缀(0，0x和0X)，也就是分别在转换(格式化输出)的说明中假如警号(#)

---

* 整数类型还包括char-字符类型与其它的表示符类型，比如像long，short等等，这里先不做过多赘述
* 字符类型还包括了字符与字符串(String)的概念

---

**图片资料补充:**

* 转义序列(转义标识符)图示:

<img src="/images/整数类型原理图片/转义标识符-1.png" width="30%" height="30%">

* int系列类型的常量写法示例:

<img src="/images/整数类型原理图片/int中的常量写法.png" width="30%" height="30%">

---


### 补充内容-1

* `scanf()`函数中的&标识符用于把输入的字符赋值给所对应变量
> 相当于创建了一个指向变量其它数据对象位置的指针

* 而格式化输出标识符(转换符)
> 类似于`%c`，`%o`，`%d`，`%f`之类的
> 作用是决定数据的显示方式，而不是存储方式

* 数据显示和数据存储的示例图片:

<img src="/images/格式化输出标识符-1.png" width="40%" height="40%">

---

* 编译器对char的实现也有不同，有的将其实现为有符号类型，即代表char可表示的范围是-`128~127`
* 而有些C编译器把char实现为无符号类型，即为表示-`0~255`
* 至于想要准确的确定正在使用的编译器是如何实现`char类型`的，可以去查询相应的编译器手册与`limits.sh`头文件
* 但是根据C90标准，C内允许在char关键字钱使用`signed`与`unsigned`标识符，以此来消除编译器对char默认类型的影响
* `signed char`表示有符号类型，而`unsigned char`表示无符号类型

---

### 类型归纳列表

**基本数据类型**

* 关键字:
* 基本数据类型由11个关键字组成: `int`、`long`、`short`、`unsigned`、`char`、 `float`、`double`、`signed`、`_Bool`、`_Complex`和`_Imaginary`

**有符号整型:**
> 有符号整型可用于表示正整数和负整数
* `int`——系统给定的基本整数类型
> C语言规定`int类型`不小于16位
* `short`或`short int`——最大的`short类型`整数小于或等于最大的`int类型`整数
> C语言规定`short类型`至少占16位
* `long`或`long int`——该类型可表示的整数大于或等于最大的`int类型`整数
> C语言规定`long类型`至少占32位
* `long long`或`long long int`——该类型可表示的整数大于或等于最大的`long类型`整数
> Long long类型至少占64位
---
* 一般而言，`long类型`占用的内存比`short类型`大
> int类型的宽度要么和`long类型`相同，要么和`short类型`相同
> 例如，旧DOS系统的PC提供16位的short和int，以及32位的long
> Windows 95系统提供16位的short以及32位的int 和long

---

**无符号整型：**

* 无符号整型只能用于表示零和正整数
> 因此无符号整型可表示的正整数 比有符号整型的大

* 在整型类型前加上关键字`unsigned`表明该类型是无符号整型: `unsignedint`、`unsigned long`、`unsigned short`
> 单独的`unsigned`相当于`unsignedint`

* 字符类型:
* 可打印出来的符号(如A，&和+)都是字符
> 根据定义，`char类型`表示 一个字符要占用`1字节`内存
> 出于历史原因，`1字节`通常是8位，但是如果要表示基本字符集，也可以是`16位`或更大

* char——字符类型的关键字
》 有些编译器使用有符号的char，而有些则使用无符号的char
》 在需要时，可在char前面加上关键字`signed`或`unsigned`来指明具体使用哪一种类型

* 布尔类型:
* 布尔值表示`true`和`false`
> C语言用1表示`true`，0表示`false`
* `_Bool`——布尔类型的关键字
> 布尔类型是无符号`int类型`，所占用的空间只要能储存0或1即可

* 实浮点类型:
* 实浮点类型可表示正浮点数和负浮点数
* float——系统的基本浮点类型，可精确表示至少6位有效数字
* double——储存浮点数的范围(可能)更大，能表示比`float类型`更多的有效数字(至少 10位，通常会更多)和更大的指数
* long long——储存浮点数的范围(可能)比double更大，能表示比double更多的有效数字和更大的指数

* 复数和虚数浮点数:
* 虚数类型是可选的类型
* 复数的实部和虚部类型都基于实浮点类型来构成:
> `float _Complex`
> `double _Complex`
> `long double _Complex`
> `float _Imaginary`
> `double _Imaginary`
> `long long _Imaginary`

---

### 打印出类型大小

* `sizeof()`函数的使用

* sizeof是 C 的内置运算符，用于以字节为单位给定指定的类型大小
> C99和C11提供`%zd`转换说明匹配sizeof的返回类型
> 而一些不支持C99和C11的编译器可以用`%u`或`%lu`来代替`%zd`

* 示例程序:
```
#include <stdio.h>

int main(void)
{
	printf(" Type int has a size of %zd bytes.\n", sizeof(int));
		printf(" Type char has a size of %zd bytes.\n", sizeof(char));
			printf(" Type long has a size of %zd bytes.\n", sizeof(long));
				printf(" Type long long has a size of %zd bytes.\n", sizeof(long long));
					printf(" Type double has a size of %zd bytes.\n", sizeof(double));
						printf(" Type long double has a size of %zd bytes.\n", sizeof(long double));

					return 0;

}
```

* 输出结果:
```
Type int has a size of 4 bytes.
Type char has a size of 1 bytes.
Type long has a size of 8 bytes.
Type long long has a size of 8 bytes.
Type double has a size of 8 bytes.
Type long double has a size of 16 bytes.
```

* 该程序列出了6种类型的大小，也可以把程序中类型换成的其他类型
> 注意，因为C语言定义了`char类型`是1字节，所以`char类型`的大 小一定是1字节
> 而在`char类型`为16位，`double类型`为`64位`的系统中，`sizeof`给出的`double`是4字节
* 在`limits.h`和`float.h`头文件中有类型限制的相关信息
> 顺带一提，注意该程序最后几行`printf()`语句都被分为两行
> 只要不在引号内部或一个单词中间断行，就可以这样写

---

### printf()方法与scanf()方法补充内容

* `printf()`和`scanf()`函数用第1个参数表明后续有多少个参数
> 即第1个字 符串中的转换说明与后面的参数一一对应
> `printf("A %d B %f", xxx, yyy)`
> 即A对应于xxx，B对应于yyy

* 程序员要负责确保转换说明的数量，类型与后面参数的数量，类型相匹配
> 现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确
> 但是，该机制对`printf()`和`scanf()`不起作用，因为这两个函数的参数个数可变

---

* C语言提供了大量的数值类型，目的是为程序员提供方便
> 那以整数类型为例，C认为一种整型不够，提供了有符号，无符号，以及大小不同的整型，以满足不同程序的需求

* 计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别
> 即使两个32位存储单元储存的位组合完全相同，但是一个解释为`float类型`，另一个解释为`long类型`
> 这两个相同的位组合表示的值也完全不同。
> 例如，在PC中，假设一个位组合表示`float类型`的数256.0
> 如果将其解释为`long类型`，得到的值是113246208
> C语言允许编写混合数据类型的表达式， 但是会进行自动类型转换
> 以便在实际运算时统一使用一种类型

* 计算机在内存中用数值编码来表示字符
> 美国最常用的是`ASCII码`，除此之外C也支持其他编码
> 字符常量是计算机系统使用的数值编码的符号表示
> 它表示为单引号括起来的字符，如`'A'`

* 需要完全理解通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型
* 浮点数可以写成固定的小数点的形式或指数形式，C99和C11提供了第三章的表示方法，即用十六进制数和二的幂来表示(如，`0xa.1fp10`)
* C语言中用单引号`' '`来表示字符常量，还有转义序列的概念(`'\n'`)，另外，还可以在八进制和十六进制数前面加上一个反斜杠(如: '\007')，用以表示ASCII码中的一个字符
* 还可可移植数据类型等概念
> C99新增了两个头文件`stdint.h`和`inttypes.h`
* `printf()`函数根据转换说明打印各种类型的值
> 转换说明最简单的形式由一个百分号(%)和一个转换字符组成，如`%d`或`%f`

---

**转义序列(格式化输出标识符)-URL参考列表:**

* CN-CSDN-C语言中字符串的格式化[跳转](https://blog.csdn.net/hudashi/article/details/7080078)
> `https://blog.csdn.net/hudashi/article/details/7080078`

* CN-CSDN-C字符串格式化[跳转](https://blog.csdn.net/hudashi/article/details/7080078)
> `https://www.cnblogs.com/mcxfate/p/10618114.html`

* CN-CSDN-C 和 C++ 字符串格式化[跳转](https://blog.csdn.net/freeking101/article/details/78935559)
> `https://blog.csdn.net/freeking101/article/details/78935559`

* c/c++的字符串格式化汇总[跳转](https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html)
> `https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html`

---



