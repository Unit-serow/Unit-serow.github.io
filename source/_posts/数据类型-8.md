---
title: 数据类型-8
date: 2020-03-17 11:41:51
tags: [随笔,C]
categories: [软件,C/C++]
---

<center><strong>数据类型-I/O-1</strong></center>

<!-- more -->

### 数据类型-8

* C I/O 原理解析-1

---

### 字符输入/输出与输入验证

---

**相关内容:**

* 输入，输出以及缓冲输入和无缓冲输入的区别
* 通过键盘模拟文件结尾条件
* 使用重定向将程序与文件相连接
* 创建更完善的用户界面

---

**相关概念:**

* 输入(input)&输出(output)
* 常见的输入和输出设备
> 包括如键盘，U盘，扫描仪和激光打印机等
* 如何处理输入数据和输出数据
* 执行输入和输出任务的函数
> 即用于输入和输出的函数(简称I/O函数)
* I/O函数(如printf()，scanf()，getchar()，putchar()等)
> 其负责将信息传送到程序中
> I/O函数的基本概念解析
* 关于设计与用户交互的界面

---

**关于C 的 I/O 函数**

* 最初，输入/输出函数不是C定义的一部分
> C把开发这些函数的任务留给编译器的实现者来完成
> 在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型
> ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些极为常用的
> 由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性
> 因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数
> 其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面
> 这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序
> 这里所提及的 I/O函数 是所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统
> 处理文件输入/输出 的程序也可以使用这些函数
> 许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配，此时则需要输入验证相关的问题和解决方案

---

### 单字符I/O

* 即为getchar()和putchar()
> getchar()和putchar()每次只处理一个字符
> 虽然效率对于人为编写与阅读的不佳，但这种方法很适合计算机
> 并且这是绝大多数文本(即，普通文字)处理程序所用的核心方法
> 这里会提到有关这些函数的工作方式

* 自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联
> 这就是为什么程序中要包含这个头文件的原因
> 实际上getchar()和putchar()都不是真正的函数，它们被定义为供预处理器使用的宏

* 如果在程序中同时使用了getchar()和putchar()函数
> 在运行程序后，getchar()函数会将用户以键盘输入的值传递至程序中的putchar()函数
> 然后putchar()函数会将值直接显示/输出在/至屏幕上
> 其涉及概念即为关于C的键盘输入处理，缓冲和标准输入文件

---

### C 缓冲区

* 在老式操作系统中运行getchar()函数的输入循环并以putchar()进行输出
> 其系统在回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入
> 即正在等待的程序可立即使用输入的字符
> 而现在的大部分系统在用户按下Enter键之前不会重复打印刚输入的字符
> 这种输入形式属于缓冲输入

* 此时用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区
> 按下Enter键后，程序才可使用用户输入的字符

* 以下图片比较了这两种输入:

* 缓冲输入和无缓冲输入:

<img src="/images/数据类型-8/缓冲输入和无缓冲输入-1.png" width="40%" height="40%">

---

**关于缓冲区的存在意义:**

* 首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间
> 其次，如果用户打错字符，可以直接通过键盘修正错误
> 即当最后按下Enter键时，传输的是正确的输入

* 虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入
> 例如在游戏中，玩家通常希望按下一个键就执行相应的指令
> 因此，缓冲输入和无缓冲输入都有用武之地

* 缓冲分为两类: 完全缓冲I/O和行缓冲I/O

* 完全缓冲 I/O
> 完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)
> 其通常出现在文件输入中
> 缓冲区的大小取决于系统，常见的大小是512字节和4096字节

* 行缓冲 I/O
> 行缓冲I/O指的是在出现换行符时刷新缓冲区
> 键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区

**关于使用缓冲输入还是无缓冲输入**

* ANSI C和后续的C标准都规定输入是缓冲的
> 不过最初K&R把这个决定权交给了编译器的编写者
> ANSI C决定把缓冲输入作为标准的原因是: 一些计算机不允许无缓冲输入
> 如果当前使用的计算机允许无缓冲输入，那么当前所用的C编译器很可能会提供一个无缓冲输入的选项
> 例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数
> 其原型都在conio.h头文件中
> 这些函数包 括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数(回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击 键后对应的字符不显示)
> UNIX系统使用另一种不同的方式控制缓冲
> 在UNIX系统中，可以使用ioctl()函数(该函数属于UNIX库，但是不属于C标准)指定待输入的类型，然后用getchar()执行相应的操作
> 在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用
> 总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统
> 这里假设所有的输入都是缓冲输入，即不会涉及无缓冲输入

---

**有关结束键盘输入**

* 在某些程序中，只要输入的字符中不含#，那么程序在读到#时才会结束
> 同时#也是一个普通的字符，有时在程序中不免会用到
> 所以应该用一个文本中用不到的字符来标记输入完成
> 此时就实现了让这样的字符不会无意间出现在输入中，即在不希望结束程序的时候终止程序时

---

### 文件&流&键盘-输入

**文件输入:**

* 文件(file)是存储器中储存信息的区域
> 通常，文件都保存在某种永久存储器中(如，硬盘，U盘或DVD等)
> 毫无疑问，文件对于计算机系统 相当重要
> 例如编写的C程序就保存在文件中，同时用来编译C程序的程序也保存在文件中
> 后者说明，某些程序需要访问指定的文件
> 当编译储存在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容
> 当编译器处理完后，会关闭该文件
> 其他程序，例如文字处理器，不仅要打开，读取和关闭文件，还要把数据写入文件

* C 是一门强大且灵活的语言，有许多用于打开，读取，写入和关闭文件的库函数
> 从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件
> 这些直接调用操作系统的函数被称为底层 I/O (low-level I/O)
> 由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做
> 然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件
> 这涉及创建用于处理文件的标准模型和一套标准I/O函数
> 在这一层面上，具体的C实现负责处理不同系统的差 异，以便用户使用统一的界面

**有关 I/O 的差异问题:**

* 例如，不同的系统储存文件的方式不同
> 有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处
> 而有些系统在文件中创建一份文件描述

* 在处理文件方面
> 有些系统使用单个换行符标记行末尾
> 而其他系统可能使用回车符和换行符的组合来表示行末尾

* 文件大小方面
> 有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量

* 如果使用标准I/O包，就不用考虑这些差异
> 此时可以使用`if(ch == '\n')`来检查换行符
> 即使用系统实际用的是回车符和换行符的组合来标记行末尾
> I/O函数会在两种表达式法之间相互转换

* 从概念上看，C程序处理的是流而不是直接处理文件
> 流(stream)是一个实际输入或输出映射的理想化数据流
> 这意味着不同属性和不同种类的输入，由属性更统一的流来表示
> 于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成

* 这里着重理解 C 把输入和输出设备视为存储设备上的普通文件
> 尤其是把键盘和显示设备视为每个C程序自动打开的文件
> 有关对于文件的深入讨论这里不做多余赘述

* stdin流表示键盘输入，stdout流表示屏幕输出
> getchar()，putchar()，printf()和scanf()函数都是标准I/O包的成员，负责处理这两个流
> 以上的内容则说明了可以用处理文件的方式来处理键盘输入
> 例如， 程序读文件时要能检测文件的末尾才知道应在何处停止
> 因此，C 的输入函数内置了文件结尾检测器
> 既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入
> 下面会从文件开始讨论如何结束文件

---

### 文件结尾

* 计算机操作系统要以某种方式判断文件的开始和结束
> 检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾
> CP/M，IBMDOS和MS-DOS的文本文件曾经用过这种方法
> 如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾
> 这曾经是操作系统使用的唯一标记， 不过现在有一些其他的选择，例如记录文件的大小
> 所以现代的文本文件不 一定有嵌入的Ctrl+Z
> 但是如果有，该操作系统会将其视为一个文件结尾标记

* 以下图片演示了这种方法:

* 带文件结尾标记的文件:

<img src="/images/数据类型-8/带文件结尾标记的文件-1.png" width="40%" height="40%">

---

* 操作系统使用的另一种方法是储存文件大小的信息
> 如果文件有3000字节，程序在读到3000字节时便达到文件的末尾
> MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z
> 新版的DOS也使用这种方法处理文本文件
> UNIX使用这种方法处理所有的文件
> 无论操作系统实际使用何种方法检测文件结尾
> 在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值
> 即EOF(end of file的缩写)
> scanf()函数检测到文件结尾时也返回EOF
> 通常， EOF定义在stdio.h文件中:
> `#define EOF (-1)`

* 为什么是-1? 
> 因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集
> 但是，如果系统能识别扩展字符集，该函数的返回值可能在 0～255之间
> 无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 文件结尾
> 某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同
> 如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题
> 这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号

**关于如何在程序中使用EOF**

* 把getchar()的返回值和EOF作比较
> 如果两值不同，就说明没有到达文件结尾
> 也就是说，可以使用下面这样的表达式:
> `while ((ch = getchar()) != EOF)`
> 如果正在读取的是键盘输入不是文件的情况:
> 绝大部分系统(不是全部)都有办法通过键盘模拟文件结尾条件

* 这里以该程序举例(echo_eof.c):

```
#include <stdio.h>

int main(void)
{
	int ch;
	while ((ch = getchar()) != EOF)
		putchar(ch);
	return 0;
}
```

* 在使用EOF时需要注意下面几点:
1. 不用定义EOF，因为stdio.h中已经定义过了
2. 不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值
3. 变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数
> 但是EOF的值是-1
> 还好，getchar()函数实际返回值的类型是 int，所以它可以读取EOF字符
> 如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式
4. 由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据
> ch是整数不会影响putchar()，该函数仍然会打印等价的字符
> 使用该程序进行键盘输入，要设法输入EOF字符
> 不能只输入字符 EOF，也不能只输入-1(输入-1会传送两个字符: 一个连字符和一个数字 1)
5. 正确的方法是，必须找出当前系统的要求
> 例如，在大多数UNIX和 Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号
> 许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号
> 一些系统把任意位置 的Ctrl+Z解释成文件结尾信号

* 下面是在UNIX系统下运行echo_eof.c程序的缓冲示例:
```
She　walks　in　beauty,　like　the　night
She　walks　in　beauty,　like　the　night
Of　cloudless　climes　and　starry　skies...
Of　cloudless　climes　and　starry　skies...
Lord　Byron
Lord　Byron
[Ctrl+D]
```

* 每次按下Enter键，系统便会处理缓冲区中储存的字符
> 并在下一行打印该输入行的副本
> 这个过程一直持续到以UNIX风格模拟文件结尾(按下Ctrl+D)
> 在PC中，要按下Ctrl+Z

* 既然`echo_eof.c`程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么
> 假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止
> 或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据
> 用`echo_eof.c`来储存在文件中输入的内容
> 假设同时使用这两种方法: 把输入从一个文件定向到`echo_eof.c`中，并把输出发送至另一个文件
> 然后便可以使用`echo_eof.c`来拷贝文件
> 这个小程序有查看文件内容，创建一个新文件，拷贝文件的潜力
> 关键是要控制输入流和输出流
* 注意模拟EOF和图形界面
> 模拟EOF的概念是在使用文本界面的命令行环境中产生的
> 在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号
> 但是在一些实际应用中，却不能很好地转换成图形界面(如Windows和Macintosh)
> 这些用户界面包含更复杂的鼠标移动和按钮点击
> 程序要模拟EOF的行为依赖于编译器和项目类型
> 例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的 设置

---

**待补充**

---



