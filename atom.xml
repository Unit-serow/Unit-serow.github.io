<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>不精之精，而至纯粹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-03-20T13:44:05.439Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随笔-2020-03-20</title>
    <link href="https://unit-serow.github.io/2020/03/20/%E9%9A%8F%E7%AC%94-2020-03-20/"/>
    <id>https://unit-serow.github.io/2020/03/20/%E9%9A%8F%E7%AC%94-2020-03-20/</id>
    <published>2020-03-20T13:41:31.000Z</published>
    <updated>2020-03-20T13:44:05.439Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="360be0e72b3aa9938d3de91406dbaec88e97d44333f3946a0edbfff4ba080f1f">0267ec72f19b8c198697a4f72870a3a8076f26d3dae1e3b600bc2b0ef7b9973fc0fb4a7d675328f3921866770bb0d5193f9b8dcbcf28ff02ef3cc1b2c7aad3d855ebe3ceb25532da0f3dfa36c901cf52d2f971926bc1f1d85f95389240b4b86b92fff1b6e0fe3c22d916ef1cbc94aa998ec72579dc4528100df6c794e0b92444dc44825e0c825c1b0b782147328f2269d72952643f8987fce54d07b1dcc23b6017d640234ad44f6747ccd718b04aa1fe144fd81a4bbe2a884d5fa1b628180c14352600355edda17abcd363d5a21c1b1e8768ec269b1a5d7bb7ccaff74ba1a886c3664b81a35e50b173a8449a4a483d91c388c102c82687ed67d5c3f1c21d9d0248b10f95f6d8e9df651e04a85fd1129e400d7bc592e5bfba377b0cd11286637e9e157e3942aee3ea3711e0c5e0bb731d245284251ed3657ff36c630360c6bad3ff422df22c1a2ae5a791b149a4d83bc134515a20daed19c2daaddf0c90e16bb0deea1e2cd0683ab24be85ebab04608d85caa1a01ba91d73f607856a24dfda49c42284d5f2a2dc0f96e68d70d586a6712a147a5708b5b58fc1c15cfe5de4f567da953f79f488da09127e79204fb8303d352f88a83136f4512607d6269eefae13f59d1fd88bce3cebe92e7796f0e00db04e6622ae1d5e920bf3e15bfc7787d5cd0b2a0a5e137357a659c813a243574614338f0d5fd33a077eb3fd2e5e68bbe9e622cbd4d88a798e637a275288d2fe7ee5d8b4880cda6abaaa3ba917a0d523835716f9f6513e3d86bd8aaec4b2330ebd89aea3a328ea295d6dbbc73a01d20ee7876a74a2d91e825d8bbfc0bb20bb2e79e2570b6d6f77b3bd745819722bc3a4a4b0ee3910bee1ef1ec43a40c279f34904c184cea0c84f4abebf28883ed18045d1b544840af5a6b286097f04ed0106b391a1e040c79735a517007e4d1cdfdc2724221987d59f8390bf4d2281f3486c1f43eaa74a5a5eb5f76d8dbfdfc3017e7d15bc252aeb994c72111ccb5de27ecea2e1b7e28cc18209ddef9a17c60fce6e2e046baae39c40ba2beed525764cfa5870bf8052d6e4a6453f5ecb77d563c19def83b703405d24e07cdf35daf70282bc6b20baf88685bade275fea3adaa4517434f2355f8d0c8f830e788494f814ffb183ae7a6ca704d0cc4954b49dc3ee861b0618a405bf7d81971da6f8321182face379be1819b77d540f391a80f2b10843d03838e605a8f55e243a9611a0a8c274d6dfdc156c9c8fac1b28b25ac379fb3fd4b4c8e6abfaafd4784ccee0d51043a6821a80c286467f1a668cd374b054a2661c10cb18865c3cfcd8e8411b167dc47274d9d1cb2372c4a8e7f7db02f6ce49680ddd89d162273d5fba98f8a051d0b3be52c9c8cbf34eb5dbf6aa14fdad049131bf7f10da74ba1bf7937895d83befb0478bade21166b6bc3f49872d4af644586fa0fc0d09b45d21a1d24a886e9c64f573a11a682a45237ae8f1fba6dab9e647fe23e2ecd6f12a2df5dcebff89eee19c782fbdf9d28f1bb5d3c0030e8034063b9f2586f5e21d95881c55f87b5265f0ba252171b5cc580f503b92932a7835b4439bdd299334d6f14e85ee69f2f0608e380e9904344b43feb720032030392b6b5e90b7f4640270ddbd3f897ecd0af4773d9bef89eec01245335eeba7103bfe4a8be6d68940ff8d8847f43d6e39d341a671eb8f8c9b197fe55b745479b7be129d5c3acf5bfe47f1e6021ea53e5dbc7d2a397237718f21e175b893c6c8f934b6ef0b9c11a9801094a2a31ae8510ec5d4ebd6c9ba81f5892011c6e9cb74d191438115c47bd7c66d913b009b1825234b6778e963e2b44f75f3128e9791ebcbb27c9563cc7ac71828862467e5a90841afa5dc4ea5f67123e16a73d4e763bd32ac4eaeb9fedd8ed7fcdbe82330b9a6039ee1db0854de3f58a8e70d4dc49ac088e5bd9edec131be28b87cfce1be020b5410d8db545b3d4d3b184203091d6e6de85cabb30c449814a2c4fe00f0f9f8619683c281c17e2e5243d51c00b8980b6b23138878d567c9eaf69bab48ab962136c5219b2998d88a43d68bc2f2d18da821d13c9f8ababcc9ce169133dc50ba0b974a61a27b573448f7ab306ef505c38fd52ea01a260607a4b169b11f0a639f782b0f4ac22bfef4cef36646361589813069b72a22c38ce01ce9e706a8204af3e7156c82b1e0dd0ab7a8cb700e34e9125ef2bfd4608a0baac5ce0818a0eea7494dcf7ee3dcde01b641f82938e0d95cd93779661e377f081c4cd0d5b4c7eb04929493845fc2a1a14b11ba0e20694833a753597a58cf267eb554a10dc398671bcfa72535b633797f46c9086c28c04083eaf1981027a386ae9f9e6a3c4d5db1cd7074e4618e859e4b0a6f9bfd4546ead6451bec68908c1c7189266421dbfcfc305ab2f1e076987177c27bff515b593f65ce815b5f1b0e6e05e5d83ffc75995036d8be6664600918ff21b378159b8b9dba449f82da172a8ce7c02bc6bd3f68fc3e4533199eeaa3dc2a8691a5f411d87c94e80a92573b355cbbfdf64486dda36724d88cfe92a341ded6057294c81720ebc98ff1df454e29606db68f4338ebcfdea601f5b776f19dc64e55955bfb4b187f2bf655ad45a83b53ccf422ddf0d49b7ae38a4cc1c68e6c2d0a97e25a3e474f0e6686f2b5a96b4a20c7703c78f22fac9653c5e9b5ead6bfd1e5f2a93b80d26bdaf23dea89c5b3035bf25e4609e7dc2ed88e0bdb231cf2e135e1338c2ce8fb849b1bf5a59ca81583b8922b3b1e4593c8018eb4f85fd553f910c8098f8bd731a6d7379755f4e3b7b47009a8a8b2e6c3fe170300c1366bdc363cf33e17009cabcd20863bc0b399e75a2c01844bc316ae6e29ef62fc71bf2b58c53b36602ae897e50a736fc826a40d20d40c7a152d620ae319a336f60ac685fbe1a21fa0a5533e7325b64616f1e4e58b2483a842d5dc668e8ff9dc35afdbe4a6f77d87b917ba9bf2d3ebebfc1a9e913546318e620dce10a5a0bada35ccaf44a5370692e019f98de820dfaf67bf351c855d48d5a210cb18b282c577e992bbf045812c297ddad50cdc07e8fef8d129016bee2d3c92933acac9f1b3ec62a255aea47134e1739543210f248ec5b6b3813d17aa341d504f0cbf1cd933a734ef4fa98e9bbf53d14e3b9954bb52a7b9453a2e9a3fd9ab50e57c6352fecb757cb1300fe99b8bb46f9c95a7d3c44f025395f0dbd77a72f950fd5e7663e24bf19974b7ff254baa494b9f273b8d4f6430b1e4be63afaed177331f4f4f69832d5e1566f26848a983e34856d895ba3eff4d752adbf700b725b6cd795ffab3974509626876ed1e70707a3425fdbf80de86d742d988bad2ae2da8b53ce0b868a13f61900ba591801d80f397341033210de1de82e28ddf5bc825d1096d55bca6032d553a15a4343914e37b52493ed7b190e4bd0fa3ca2b31ec33feaa0e89677805891e1a11c8a825721bfa484a64218bc1b0e902885e02733a6854ea8f155a3977d2c252c414dea48e84f90481d2b2b715f904cdbf6ff3c2d03bb94cf188ffa9549099318def3637c20c313ac7d1c1ab46dcdfacb4902061a5b1eba38d58f6641b0a64b244024cd4174cee64495587fbbab299566cd04d8ae2bbbe5c3862378659dc24145e4e42311dc094edc8f11bf7c56e6e2a990b3d47a77f0645667c53c6a492a8df8b2958ab5f80eefcd4f6e52eca57526189839f28103501115f5bdc28ebd33c9df587bed668a957af3e754becffd48c3c582e5d07c2b6708320034d13b9d06f228600123d0b48d058bcc596f43236993d0a0ed325ead9172a280597674253f7c353128664726f2a6f0474755b37a082cbdb6a55802f6e542e8e50ef87f11b3846db8eed111e7569ddbe227163334c62c9035ec3e97ddc24a47c6b4af39b07210d18d5db77c14ef93c58c416eb0d1bf193baa6dc8097040a96d3c4384e78b5f8fbeb76d8531d484da6cdce38a558b104d68ea26614be32dd363b3e426b5864ade2f188d238788acbe794da742d76fd4115071132f9ba4a185b3435f76a9403c1227ed3f79271eef72259cf1e61140fba092a2d649045775bbb3332ae53628d45b32a40bf00206a2df800de5fd27b4f3d9d9cfe4bb621f4f852c0ad3d9af3f351c9641c0c22a7f0c329355bba09bc867f85cd1637aa1616ab15b8a0c9e01e322835b4b9a0f9899421a9492bd714305f75958fc6485f3ea0c711c379b47f406f4271c9fa8a9a537022bbe4cbd67ad59fdef49100392dfcb619c21af313983de99fe62b39546c99d4531432561c8003d74299f1ce929a314aa8bb3f5b4b5d3ae545dc17b5d98a7838da8d57fd3d6e733e2fbb9023f6788e020f78341acce5963329b9893d8158d3ab3e7df73fa3afef2765b7323f36b904464059fce18980033519e135642a8ab5a5d428524b5513931358692c5a1a32629949c6f9ac6ebc3749bbc85000b35713b56317792fcd2aaf46d7c922a6fcffdcd928caed20e5edc579b348c7112f2d02729c0706279fe3d26885dcdb92361f078b47a106ab8a86e1f7629fedf7287ea3a0d319328ebe457c28596470435ba6f4b47d97970a6b0ab5c5697793ef62825fe770f6f5218826978106683e112980d4e23be51030faa0890b117f7388340841fc79f4bf1c011375cddc1d68799767d9d790febed7ab464e2f755cbeb7bf97d22ea5914f14a18bd8e3257c5c2bf5851fcd68edc3a295b0ec5f9131013ff3e0069dba146cdb7400732ec2f2822c1e819af99f70a093f0b3f213a1215eba61e0d10c397e62a6d38c3b88d7c13908d3562b027c91fa0480313954512af1f2ef92961a7b3c557365c8adfc70c571cfe96e0643f7ef5a330e225ebdf186e396f4c5c29f2b5a3f1f3f8d0f1cc4b18ab72dd94fb7e43909561ee8aa6f69869db5f37d47c51c787119c157dc043dbbe8bbbabbd441b9820cf5908b777db19e139dd3b195811647f347f15d7b1ad680c4cd8c534bcaaba760d78d088000da38772d58dbac2d86348d7380a1372966d7328822f54f5fa9d1f368829c881555ff71751e1d904a393627dffe4a037712148e8ae4d5010adb597bd7d6f3b5a9c128ebf081561d2746a2fccf7409fd84b55d03c2812f472de04ea9dee77a82a36ea8af7a55cbf39548cd48aaa65648d3fd53a2c93a2fe7985e33b6a3e5117800035be545d82d45612aca44dc6c25b513d1433aeac61f95f1917e22a54c10d2b703a120bcfc221219817ac0b3224846249941f4684c21a44bd4496f1e431d72237ff02527eabec827cc858081f7863520707df434bb6b2274372e0719c8ba83bdd147c1614b016ddb36950641dde5f2a5fa5c578320a50c1332b9c7c5234c153b261ae82ca096ba9b6b7acb75da8b29b3c927eb0cc1557334090166edb78cc4ca39c87b06729a1027cc20bc65d199bea05eb5d28925bcd4fb0aec196ac9b653c88354a587be1d9d4600a5903d97e3456c2ea926f8677469dd726fca069123ec032d980cc74889f332039312c269cca47b9a598413fb29298adc7072fa6b2b6edac34a274aa9c8b47066c94c093c4e18bdadb835148e7f29be5b650486e0324011c0bb5d430507c412f9ec374458aa094d2bc4dd9802c53ac72a965a7f3e46e0ab3df606af8b61bfb46c9bc573b0ec8bcce8d331cbb6b9155659068ba958a517dbdc3ea295cf83409e7efc726cb35eafba5298eaeb4ae8ebd6fe7c6dc97f9c34813285b1d524de9c3b22a6db9ab595aef231437481f46acbbf0148ec7ac7be3347017ca2bec7bcacea9cb7c385e44a2a0ac6f625553777972042c7cb6f27f60a059a3c048727ec95b7b942d02a280f1a631777063111273ca51077bd53dcd6ff9ab215f7b6961e571c45e30ea1ab3e505636440b75391b2149d39400d2ae8b9562a43e5e2b65dd8c9dcdfdcff6cf003a35fdae02c8858d9229911d8576610c6e191f5315a4f11b528bf83d1443e219ae44c94abdadd088c34b67bfd6f72eded239acdd00202b396adc6bab073868f78e0177bdfbf849ad9a056e42494798b48292abb4c3fbd598ad1bb214f622958419c7d741caef0aa4dfdf10e871940e749fff63b648d782d2d61e57e8bd6d0cf9d63ed70d729764ad6555f4b09dcebaf24a9be8416cb483610bfb461c9c48d2</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="无" scheme="https://unit-serow.github.io/tags/%E6%97%A0/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-9.1</title>
    <link href="https://unit-serow.github.io/2020/03/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-9-1/"/>
    <id>https://unit-serow.github.io/2020/03/19/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-9-1/</id>
    <published>2020-03-19T13:15:38.000Z</published>
    <updated>2020-03-19T13:16:33.388Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 21:18:32 GMT+0800 (中国标准时间) --><center><strong>数据类型-函数-1</strong></center><a id="more"></a><h3 id="数据类型-9-1"><a href="#数据类型-9-1" class="headerlink" title="数据类型-9.1"></a>数据类型-9.1</h3><ul><li>函数-基本概念</li></ul><hr><h3 id="函数-基本概念"><a href="#函数-基本概念" class="headerlink" title="函数-基本概念"></a>函数-基本概念</h3><p><strong>涉及概念:</strong></p><ul><li>return关键字</li><li>一元运算符</li><li>方法的类型，定义，参数，及其返回值</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>函数参数内对指针类型变量的调用</li><li>ANSI C 原型</li><li>递归</li></ul><hr><p><strong>结构化组织程序:</strong></p><ul><li>C 的设计思想<blockquote><p>在 C 内，函数用作构件块，而所谓的程序即为由代码块拼接而成<br>至今为止所涉及的C 标准库的函数有如: printf()，scanf()，getchar()，putchar()和strlen()<br>C 内还允许创建函数</p></blockquote></li></ul><hr><p><strong>关于函数:</strong></p><ul><li><p>函数(function)是完成特定任务的独立程序代码单元</p><blockquote><p>语法规则定义了函数的结构和使用方式<br>虽然C中的函数和其他语言中的函数，子程序，过程作用相同，但是细节上略有不同<br>一些函数执行某些动作，如printf()把数据打印到屏幕上<br>一些函数找出一个值供程序使用， 如strlen()把指定字符串的长度返回给程序<br>一般而言，函数可以同时具备以上两种功能</p></blockquote></li><li><p>关于使用函数:</p><blockquote><p>使用函数可以省去编写重复代码的苦差<br>如果程序要多次完成某项任务，那么只需编写一个合适的函数<br>就可以在需要时使用这个函数，或者在不同的程序中使用该函数<br>就像许多程序中使用putchar()一样<br>其次，即使程序只完成某项任务一次，也值得使用函数<br>因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改并完善</p></blockquote></li><li><p>这里假设已经定义了若干个函数声明，并于主函数mian()内进行了符合逻辑的功能性调用</p><blockquote><p>接下来要做事就是将这若干个函数声明进行定义补充，还称其为为其进行细节描述<br>描述性的函数名能清楚地表达函数的用途和组织结构<br>然后，单独设计和测试每个函数，直到函数都能正常完成任务<br>如果这些函数够通用，还可以用于其他程序</p></blockquote></li></ul><p><strong>其它内容:</strong></p><ul><li><p>许多程序员喜欢把函数看作是根据传入信息(输入)及其生成的值或响应的动作(输出)来定义的”黑盒”</p><blockquote><p>如果不是自己编写函数，根本不用关心黑盒的内部行为<br>例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及printf()生成的输出<br>无需了解 printf()的内部代码<br>以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上<br>因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务， 以及函数和程序整体的关系</p></blockquote></li><li><p>为了解函数而需要做到的基本理解: 正确地定义函数，如何调用函数和如何建立函数间的通信</p></li></ul><hr><h3 id="函数-基本使用"><a href="#函数-基本使用" class="headerlink" title="函数-基本使用"></a>函数-基本使用</h3><ul><li><p>以下的说明都基于该程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME <span class="meta-string">"GIGATHINK, INC."</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADDRESS <span class="meta-string">"101 Megabuck Plaza"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PLACE <span class="meta-string">"Megapolis, CA 94904"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WIDTH 40</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">starbar();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, NAME);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, ADDRESS);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, PLACE);</span><br><span class="line">starbar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">starbar</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">for</span> (count = <span class="number">1</span>; count &lt;= WIDTH; count++)</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>其输出结果为:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br><span class="line">GIGATHINK, INC.</span><br><span class="line">101 Megabuck Plaza</span><br><span class="line">Megapolis, CA 94904</span><br><span class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span></span><br></pre></td></tr></table></figure></li></ul><hr><p><strong>程序分析:</strong></p><ul><li><p>程序在三处使用了starbar标识符: 函数原型(function prototype)告诉编译器函数starbar()的类型</p><blockquote><p>函数调用(function call)表明在此处执行函数<br>函数定义(function definition)明确地指定了函数要做什么</p></blockquote></li><li><p>函数和变量一样，有多种类型</p><blockquote><p>任何程序在使用函数之前都要声明该函数的类型<br>因此，在main()函数定义的前面出现了下面的ANSI C风格的函数</p></blockquote></li><li><p>原型：</p><blockquote><p><code>void starbar(void);</code><br>圆括号表明starbar是一个函数名<br>第1个void是函数类型，void类型表明函数没有返回值<br>第2个void(在圆括号中)表明该函数不带参数<br>分号表明这是在声明函数，不是定义函数<br>也就是说，这行声明了程序将使用一个名为starbar()，没有返回值，没有参数的函数，并告诉编译器在别处查找该函数的定义</p></blockquote></li><li><p>对于不识别ANSI C风格原型的编译器，只需声明函数的类 型，如下所示：</p><blockquote><p><code>void starbar();</code><br>注意，一些老版本的编译器甚至连void都识别不了<br>如果使用这种编译器，就要把没有返回值的函数声明为int类型<br>当然，最好还是换一个新的编译器</p></blockquote></li><li><p>一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型</p><blockquote><p>这些信息称为该函数的签名(signature)<br>对于starbar()函数而言，其签名是该函数没有返回值，没有参数<br>程序把 starbar()原型置于 main()的前面<br>当然，也可以放在main()里面的声明变量处，放在哪个位置都可以</p></blockquote></li><li><p>在main()中，执行到下面的语句时调用了starbar()函数：</p><blockquote><p><code>starbar();</code><br>这是调用void类型函数的一种形式<br>当计算机执行到starbar();语句时， 会找到该函数的定义并执行其中的内容<br>执行完starbar()中的代码后，计算机返回主调函数(calling function)继续执行下一行(本例中，主调函数是main())<br>更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码</p></blockquote></li><li><p>程序中strarbar()和main()的定义形式相同</p><blockquote><p>首先函数头包括函数类型，函数名和圆括号，接着是左花括号，变量声明，函数表达式语句，最后以右花括号结束<br>注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()<br>而不是调用函数或声明函数原型</p></blockquote></li><li><p>程序把starbar()和main()放在一个文件中</p><blockquote><p>当然，也可以把它们分别放在两个文件中<br>把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数<br>如果把函数放在一个单独的文件中，要把#define和#include指令也放入该文件<br>稍后会讨论使用多个文件的情况<br>现在，先把所有的函数都放在一个文件中<br>main()的右花括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器starbar()是一个函数</p></blockquote></li></ul><hr><p><strong>图解说明:</strong></p><ul><li>以上程序所属的程序流:</li></ul><img src="/images/数据类型-9/函数-基本流程-1.png" width="40%" height="40%"><ul><li>一个简单函数的结构:</li></ul><img src="/images/数据类型-9/一个简单函数的结构-1.png" width="40%" height="40%"><ul><li><p>starbar()函数中的变量count是局部变量(local variable)</p><blockquote><p>意思是该变量只属于starbar()函数<br>可以在程序中的其他地方(包括main()中)使用 count，这不会引起名称冲突，它们是同名的不同变量<br>如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号<br>不用给该函数提供任何输入，因为调用它不需要其他信息<br>而且，它没有返回值，所以也不给 main()提供(或返回)任何信息<br>简而言之，starbar()不需要与主调函数通信</p></blockquote></li><li><p>关于函数间的通信稍后进行阐述</p></li></ul><hr><p><strong>待补充</strong></p><hr><p>561~640/79</p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 21:18:32 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-函数-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-19</title>
    <link href="https://unit-serow.github.io/2020/03/19/%E9%9A%8F%E7%AC%94-2020-03-19/"/>
    <id>https://unit-serow.github.io/2020/03/19/%E9%9A%8F%E7%AC%94-2020-03-19/</id>
    <published>2020-03-19T06:17:55.000Z</published>
    <updated>2020-03-20T08:48:19.372Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="418f0297e0011794e7f54ade7d2909d9de9b9fa5fcc77f9a2be0f9d6cfbdf465">0267ec72f19b8c198697a4f72870a3a8076f26d3dae1e3b600bc2b0ef7b9973f2ce977d4ada5f2280a8c63f96e586fc30c6085492f6cc4e886afa21e499aef57cc629ff3ac5ee227d01d3848925f26505443b70b77b913d568225c84e637cfd87251c533c3a987929a9161f935080aef52b25b052db597d93e3f162d83f162538bcdc1b4cf96cb4a6b7f0dbe142552de20c0ef2f989ec53a13cd0f984d9b23a3859210b2c013da054f6dd3aba7d8201f2dc26eefc55ca18a92e2005788b3fc8258ef82812a434b51c701cf3a4668eb159d2634f60b11671a2810a74b78406b3708dd3145ebf4657cd34f9122d0903c60c9fb2801eaf201971fe8afad5c9a9fd9ebced4c1352f35d6e5f07ba4ffa5794f9fb547fa12b2c79436fd12484485b4964597e5ef78713b222131968f4708653193ce07243c012417416cfba73e4c94d0c9c593d894af187427ec593868adb10dd472d32ec1d2434b25d69b82a0726640de955f3f671fff392cd948d4d8abe9a52583cb4ad1e37b46b785bf8c818350ef4180c5db834ad55ef2c40632e66ac0dacc76eba4ca42a7b0eca1744b668eb60ca4e03f949b484fc4e0626eb0d3d8d11f4e33d44e10a75ed82315eae49bfbe0f87a533fe5783eb69a30e9c3699d36fd087b019eac32f3f5e7344b460749e360dc4ee079fb1cd43c347b31fb83231dab101a51a4064647f8bfb74c3aa4f3d50430550fc43a1fe256af1b050437fa59f426259bd22e7a5ed817093139fdec45cab70dfec28d5bec1acd087ccddd33d6d14a1c428c0d837a3b921e228a70a4c18fc5a9fd71e9979e6cbaf185962628e65d4edeef9b66e0eb3c0201081a62ef48e03e069d0ff12415390852f8edc5889ee92a5d7bbad32547f2e8f95de01386782c07bf02455ee10f52163f05f9bbe6c1e64d00c5f5f5a53d8d525aa174da67b4ac5afb481cbd78293d3d9e1cb0a30df812371d254ca2bbe7bb764e86bc2c58ced41c4f255d3cbde24942a1a109886091d5958f630e6487ad673b13cabe5bcbb4331e719260704f7a3569952b25606a33cb7b56bfe01827f28ffd7b59942030ae5afd74a395572993cd47a62f3ac88af7a9ed7ffdcf5540450ef6fc09021c1fd416d9521fbfd1efd6b95143f2942c172223bfe04aa4897b428f126366023be0ff80401b81e4808899e93bed9662ba0b0608458370e3952df8bedc01448f97af409573629f69a256895dd83ccf752be287f16a9d9033ebe56a36fab7473d2252fbc1754999eb0e8a8c318ee11966acd0241fa816c6373c4629091e13dae4fa5952fbb23d3f1b0bc200e535c0bdee799713b36a08b871cbc4bc6b9c37bb96e83bf8f3e04c052abfd3d75ab480ff4f4c6fe489ec7caf69741d64b1ce2c48e00ec6257589c6df9111dde8d9bd5214255a41ffa964beaa0c285e4b3c15e2073b3f4eebe4a070cde825018c6658e7ac33354b34ac5c1e0b2f8f19a910dbf3caafb332c7d03b40ab48e695a0a176506ce0b466ce39e36da446965f6fae9d292bf0f5c3420ec10395705b25fc7b28e049fc5586cfdc14b906a38069cdfa4fd0445b461195accdacc15f24e384a2233850d686fac2b81e48bb19c65183e49dae4fad9bb65d72882e438cb45f63e120e602613cc5ad50ef3acd594334ac2b584325a6ceb43ddcd84c9c115fae597789852ba73e665f55528e30b0d5ea37e05532300bf4af09825e9c85ce5f72dd96d29d8e9f0915553b09c6935594cf359c9676f421bbf2396917fecea9088c388729c711f11e37a724d86e02f0257fcd8d455b693d05285590ae810b4368ec756564da4288c4c964ffc00b0b7fa2ec5be260d3f7871fdd66d05a60cacf403954a5830aa1523f50a9f759a9e9585f6df9f7b9ac414f5c75d746a493796b8c420cf8783846bfd71cb232eac33c702176b032c5c554e0a7662a9fb1b362d8a17645de725a36d3a451eaee07df725329b3a25a7f01877f2bfedd5dea5f75405ec5bbfd42f0aadcb435828f6a93b1450c4561832d529d1120a2adc2a18418f5e1cf582407539ddf6cdc6d5d2c5ac9e1dab973aed9992831e1e4b54ec56898e8e8a52dd696be0dc8169610beabe2f3def435063a19f3dee8b6edb76adb094721b7a1926c11f6d79aee5a82e8084842da3e5953ee19e3e3533a6c82c2620d24d2d074d2f4aa709ddff4ea2d55b64d839a67006577dcba332f19192edaf7121b5f51996b31f7ba09b05439e0ffc4f431b4cb40ff95e948b850f70b90d54e2590c27668ce75e36e2835726abb0c143ca4abbd5ce3819da5c93187c768ac40fa9c7af7aa5a84af0dff06baa8b64da7a407bd304f52626b79d46d794c0c6b1e47274b47893c9492e46c03a9ab1a896da13a9c25581f7b2d7848ef7b09a5da7322c6ab60e9a1fb2122656479e43e4fa81bacf158edd5e9d0224465fb754e91a175aa4e05ec9aa236695e483f5f433bf7f39a51828eb8b2c26b0280ecb786800c0d86032f49d92ca21a64f17b9a1786191af7273d0705fa38a44f5baf7176f02bad5c51724020686e2037ccfa2742ab644b88d5b5337f5f70394bbdef1530b1dca1eb2c1949a936508786081e1312a8fdb85d95929b6a4af9c20a7d805f94641cf474476be9315ddd317420dbc0ff0cb8b0697b236bc8adea06664e2b119ffb3dc752a831ec34e8ac607deefeeb0500475dc600c99150d216f2dbe2932e499e9fd085a4a2208e841387ff0cc6f0002663b5a89e567dbcfbc5ee5741f8124cb8c8d3dbb6ac97e57ad83b1ee006a98716fdb8f9c6309a59a4662b18da19e7fbdcb0d0ac410b8eb2f4055d461004d55d09febae38eb6195069c179b450752ea2a83edb51661d3c9cb120a8badebd05fcac37931edcd7f66b3de5e6ed23339960e5cb53dfe248faabd941843a2abf0c42ec0b127cb6e0e47bd0a782dc4c9748de59ef5316c5c91efddfa9ccc9073e7d23118f52244d6d63dc2b88634fa11646d2dd993d1366e635b4638ddb3ea3e571c30a71277d0a23813e72b27fd3c4f9cf98e68dcf027015e9ff4f55e93bc53427f22777c9f5fa62911c026728e1c1b2f9f927e570344c1849f47913fc2d314822d8927a2a21db0c221580365fb23bc63de54daa99ada81c62e5b6b306b75ec9df52a2da36e6ae1f046a7a7f0b5a267309b5b4245e72c193a4fb3ff00a2474b4cf1534757fa1839fea7aff1ee61a7c8a6c0bb6bb450e4d7e528d755d981a64f3e4262e99e27328467cf8c91728e110d81e08559d9f599c2ed35faf4a9d7093382ca93f59083ae69012420c165efebc11928fea15b2970d105d25ac38ff80d8ccec10769c1316b86109afd4463d36a821479c0008ac0db1bfe1acbbb7b452f7af5806fc06c0cf4a95c7291f03f2039b658aadb900fd0ff9a928dbe3208d32477c7f91f4909f825187de94b0ee3d57c4d464fd03e9d8f297a92022cafc5c03edb1d728ecaddd06b863e8b1b3f1d801d0cc41c99a0cd770d9725b6e6d7eb5d6a3829a459cd6417888b4708024f3cbfc10c6559e7ad958956be0d8424151fc3e13af41ce6470763ed79538e8cad02ed01512aace25ca397649defb1c1d4d1d78de8dc4f14067f55ebbae4ccbac197bcf546278cf21399af5c694c5e54be717efad41ab4fa4ead29a5e838b852468d4fde17b05a4be3069641d64045da02ce47f7e62293c0f034d1089d13723cff634b3594f2283ce768c84b36047838b25bf729c0700a00a303e04144f87565b53af34789f9bc3ff868c36d2cfbc3f1b690eaa1d8785c0870b96177a8c340d7a8058790814ccbc30a5c8ab588726735310f9c72f4a97ee92a79481c4cd3c35eb54b5ee37097678fb13068ded7d276e39af404645b37741e0064cb7f6a7015049e6252fc9a89a8d081df2c3a1b7515fe55ffd97c67059207fe1395fd0515bac81e2200759527cdf43b2ea571528a5e1fb6f721924a27f02126de8b463201f6104b37e83bb32e5d60ba7bc5f5a507b17f8448f4b1ffa9f052a48d895940f27f526deccf2cbeeb6f456a0c241495ee4bbec98b9663a26e776393a6a11d7d7f3fe1368c1e31abf15ad1c83c8d7ce743dd4bc5db22d724cecd343f3a64aa4c40aebadb5bc7e09c9536177f0be863be6720660282d7a0ee7e34f4ce4caef6e90044ec5fcf40feb61644978eaaa009da69ad3a4ef3bc5189f0db8ebb7adc5c9d0512cc76ee790bacd684e47a9b8a67233306bdd3fd5adbf398a4a20846b026021ee5eac6067e53d0aa4b8a426ba137df8c28ab38cdec2cc7abd415e66b3683035188cc87ebfbd78ff0a4aea64dcd604a180004a85ee8a231c65524e5acc31e449c0d22354238a94e31bb33d9f4b133623e46ddd4a3e49b74fd12346bb4ebc8a1928496ae7d6797b6fa5e77b1f583158436f29b5a9dfb82c670a6c0af5ba97a62d245c7f10b7432258f3fefdf87fda7c3126763eaa22313df8a5cce530246ab7d23616ff21440da2dbfc4d0293d7009d4795e6067fc403993ff66521cea69088d6cf2e36896d31fd65918c8cbfe7b84c57e101e967a833fa7e775928df9b864ffcce4400ca3ce6709c2c08087726bf4af855a91c3dfe713c3cebc301cfa76405eeb830b7b16c5df607a3d7ada487645e6d34352174ddd034f858489dd7d8f476f219e162b809ff4d73768b40f5c385d7f99b7192d086a9026bed1cdad71985065ad36751bf602d36d37d3720b94343df01d40a3cae06702020c7f05b8be30f49b34e158b56bb84c8e640c2fc0b2c246a8be21894b153d514c71e48e7e3c412c632dae7ecfeed54131a16079d85128f17750a4b3667bdb02441d8e960e69d520a129f6e3d3e617933aea5b3323925180ddd68bb5ef60bf597b1ca2b48fa73d645ea0d25f1c54d5db08f908ecc9e3f416094a6c1318f49cfb2d1795e2eee99e061be258e424a73597bf8f8c1de882d8db0d4529e79ecbe1bcd09dd58356a65c902d4ce7b518829834f1cfac2296343458af4a9a5620c89e9d3896bedc9ab17472f20f336df30e84007a7f2ebe5d8270e98253f4480ac3e78b64599f9c7d69a085ad82d579ad860722654d3dc30f1d85622f40e6cba7fc6bd387d83c2999626e6f5f2311cde51a33a5afbd76b95a2b7467977d84bb10810a6d863882d297fcdfd4e629af27dd2c384d042f12a8477ac5ad293caac8d7caaafda586194e00ad933dfa9a482fbd934f332d7e24bf2c44ed13ba2c35843da0c7d8937cf59d6747c8eb4aadff348129720a1f3bb2d9dc4decf35715933e3ac7df19f4815d2dfaf2d16b4625fee41aa62fde8598304e008e0878f1fd10eb1a357ed4bcc3451897e15b5861ef060aac006f986938cfc86be468776510fd7331b478cee3d444046829c077d42270165a8dd3dd065f33b9cc37b74327dd52358e0f42d4c22636dd3a4754477e7c5c134c45db791a4ded1ad75ba58cd08a0b4969e544aabae1c65ade1210ee1f19752e7de59a9999fd41ce90b80cb8a423cfb3acbb63747dcca4f73572e1c8eadfdb3fdcc96415bd1c93b7aa76b3dadf1f81d86a39a22dc4c7b726a7dea8b08e68e72a7719435718ed8792111adc28b85dc5ef422b69367ca53253638b99f8e7815b400d1769c96572f70e357509a7d9e77ad2e931223e68083b19dfef2edadcf735688b6f72930659574c9d13bd00429f63061a19539daa1dd172bcccb3f684d24c81c86091266381d0b16b6f436cc42c00388c46eb6c9b189fe1cf8f8f3db9745f5590e265408682ee44e67d0dae7c815af1f5a383574ec2042ea00de202e3f6858c63d75c0e03e7d582fda4702e6f642c4a8687ba3bf66a744fcddfd212bd5c5107ba115dcf19c8c3a4e53454a45766011f7267c36a5682a4a827ee15d486bfadce87278d8e2454a25214eb37cb489d84a0f398cafe848fea1407b3b2b8b4c953f8233644aedaebcce01bdd3b5c52bbfdd543e09bb9badb79b5b7af96d7d0561c1678b0fc3a22e8b57a78dadd8fe688f1f03d34edb30832e4dcd692d10466a480ea845d34a98341d35812150727426b13b025a85d73f1022cf47e3125659f9e1b0269cc0fcf6aec25eff4343d28f784798f8eca25ffcdb4cd509f0f533c10e208257087315cf32a45de40b5bf78d3f201febb55a828361b4551eddbffa763091bebbad39bdcfda0eb9a93100f3faddbe36d097263378c6e327d0bf68de2a66acc25ca5ee7e0818da6248cb3bd62342cf14c8cd887118b92b3b268abf6c6a4b2706e87d757c555a5bb353e845cfbf6917ecdd16e22e41fc4278ce2818fe31d8746163fb8bbb55e707a920a67ff8320eb07c8fc057701898bccd9892aeef2cae07f78c7da8a43583bd6d97369822bc5a742696d460a0144546ce6914d4f14af806d73a65587de41fac39a097e6bea8ffc2f995a0dca388aad1468ada0b9c61695d5f65a86eb372c7b8c4dd52f57df10ef6ac3e802074dad806e0bc681fb28d1ef242c56f02bb0a772ebb381779ad8afbbeaa0cb0e52519c46f5a0328051e9f443feb673fb4a232fc62ee83704d311a3e397851c6d327d09dac411b631295325d14a6253ee2702c8988b814eb7b10d77b1745e47471d1d8c41fc08953e7a04816cfcde6820c023d4a3e42f764356282156f43a95451e28dc16114386d62519c1d5adedd634cad2488a03c8ee3b488fb399f28e622ce77ef39c1e661e6ea12aec37cf94a8019f19a071478a025c51e8e6684a2d937eb7c07a942ce7c93dcb7f6ddc16e71eb5f37da68ae1e86a79e0c11e40b42a8f20c80fb87c9c7b7fb6e20c79a083421f0a3d31a90557be1b5ae2622f3c4fa193b50d548988f0d62863b2de3cd6c33d6e2af00b171867ca6a9f279ea764fb1669545512133c24406cf6fe73be2c06e85fade9d26099de71feb8ee3149dadc74dcdba0e630ad5cce8f98c648c919ccdce8e2ceb8dabf744d8354d12c19947fe85ee385a14c09899219ffb56e3dad0279c8c9215d1b51970fd7e9ec151c75c8eb45ce3d35d29bd1e0f075c18d9e853c6dac0dbbe6a3ffafcfc5ace3a173699579d42a6b8b2194d39e5bd113214cdc0d880cab20edccf6e859d28077a35b1e8acc6d63a013528176604be4e05ad0cacb3bb94158c121065e3cfba8c6cdbbd2d1b26946241f885a50c2d06607de5e593d2976f93540e50bcf9b8b5f8734943c8852208b4d893aa2f9f0de022621c7ee9b07bf0e432e2f789d72d11fd17408ad2ffe47900a96a16c9e98bb2952b895c849dfd766d032d21f6396843d962303743bf311f29018375de65f41765836e79aad0d7ba33e3bce350abe631e542a000baba7c42648a0a6dc1c19f68b0627d251ea346587108230cb345a4eb03aecceec4442f17231b2539bfeb7338b5e2ffa148310923f3749034de4f791b97636e386233e48b61bfe4e88cb4e32c14ff22b4263658e629ff5910204ce6b7f7f525ae7dca554c63902c6255e7f9c8c78b34d1338a62614bb35931a0bfffbf99baddf71f58c490dd6a5d41ef04fddce49ca27785b25ec5d43445083e485b786cf525094df8742d3924fc122781952f5153b5f07ddc3ca3e821be348654c4fa2607ba118b91ac38005254f07927cae305969b6b869db3ce0f32cf9755e334d18796cbade000dfcb066e7a9dab6f8d9a603dfb005a6eb8728018256ac3904e747699b702e22abd82ce8b9dde668c73d8e461049fcb245bda19e9868e253dc8780ef2b3c0a7a148f5a3b5dd7675cfcf0d7a8a64f7eba79091f7687dd92314d47c5c8682098d9d04cfc0214297b7a90ffc637282a89c0aac514a4e309f23e425dffed5f48b29c8c14686a027ef972c9cdaae9e46f5f277cb26f5c06955ab02f108a4bfd79e1e8723ae6bfa6919ca03c55b1f55e8681310ff3d70877af0a5f15a5e9524d83d117243ca49d39e5c8ae6d48ab4887a01556cd93bba50c8c0bdee76b2c5abd5be72addf16179da7fa3c5e0484142c03207ad6dd71b350f9f27b70ae23def08536384141dc7a16977fd14b431feb1535a0b99c59e81c4a0fe37abda422e4add11544836cb1e41d9d52574469e1e8b562528a2f300cf52744b356682b33d6e1e2518e68be0853f030a31c97c094e011d37b6c54f99e2954f34f0bbfe76fb90223b63ef55ee3392bf8609ddbaa66998977c84d56b6219589386d77ce4eb7d679f3b368921772388971e1594b4f0d8fe17dd6568fb2f5bfe7b6da20da49afb370584d543da92844facfe77c587e8ce948b266ef875259bb81d427d901d3347bab2e2499000628b96cd18043ca670311a31e0a3c76db4755b3bfaf4937bd653a792a4de45c9a9f47c3f9d83f3ecfd18afc147a85dea2561ba4ece65e4b8c24ea0739f2f889665a7dc1f9fb52717c18e312f575f2abe5655826e1d1cbfaeb7d6768880aa04058e48654e344ffb752e03df87a8778ba3b9a1af6425fabf61e44bd29a5db8d2508c66bdebf85c99ea4b22663caf8924a016f97cf3225126e830d96fb68de785da32607672707d2da104460a38f43053bdc71a9b71de1a0c56145e7e04eebe48a3a4632f107ec043f5aa5247db93e66709df3f3138fcdae5d430c0503de36d47557f8dc1222558ae8e06ab167bb087cea88a801d5c7a89a9f98904bf7c455fea766db2327bbe8cbf93b307cfdec98f6bfd32a3f8b7d80fc423f74b1daed1ab7fd21ba9cd44c5276c413ceba413a33d0d5b4107afec9bc99670dee6480d5f2e31f49568e150d9699cab2f42b374e95d4494459f111ca5bc1b2c5b28d5f6489f350bdeff0800be6c5bb6fa4a4f50a7b9df0fbfa91d4c5a04f6197a589b2f6b881f0f4e2c12a7c9dd78407ac0be9343460a2590e93e6f6ab663dc510973afbcbc893c91617dfbf8f2cf385cd9c22581cbfeabe7659eff853792924f1da69d5e79d29e49c07365269df115514f1e8a69dd3f08a4f2e4e2869c6a9423c4c7e18903fb25f5e1452f5f2ce0940bb0bf20560d82db7001a7e3674eab19a162e6bc94e985cc2f4497f18b1f004de352b3e846e3fd0617b4144c0be69b5812aa3179b93f537c672afcdda8243bbfa1ced5d3608251014edc92b07980f2eee642aacbe790700b01940961b3cb12b70be9a1f3d6eb28c16d30499f9dcbb04fc4f747030ffac7d38a1325069989edcbfeb8518d138114b9d219f4e3fa01e34c59d3aa2cb608060caaef7aefbc155a104de0840f4fa22e14bd43d19f00069aeb89025307041c866eca345aa7426e79fdc1c9cc3181f22146cc5baa63abcc5fc2148cec7be59c700d373365744e16bbf9c7aea25d8faba6e2e0c612b96b8c78ecf6e3e04ac65d3d5b1080a49a13c49a5f6754645264bc2ba12e019bceb4f09958f8e3d00655c03cd7ca51516fa1efe494dd69819235ae556c803da7acfbf3ae4fe32a7b7bd0e5e657884b6edfc37b8d8285622060ccf03b8bfdfce140db9de4565046314de83afa3d6f4ca8659f5b1a41b148a2c84e09786559a336d3a6e3972bf5e7033003413b07772c719b7c9c989f2833b6f92939c78fbfdfb54cbbc5c48ed5ec97833d666b35ad1f35781427a412545f508cd9e488e5d67799538a343c5bd84ebd9feaf11b841d79d6e581c16bf2159e43edcfffdf2b0d3212411abf17926f58a41559610cc0e129a9ae2b705046d1cbaf03004cd91b59e1095e9c09a0952d783a67ad50487ff29431cb85c86af77bfe49252fa77c5fe76261caf8cfb90532d37aefa917747138b17f69aade7896a9885daa60d4f3cebef783a10d35cb0abbb259f8c59af3281b9bf210a43d616bfb0ca201c11cd5e5001e4441891443f1a81b617fad91b19e8123b0b89269fbefe63e8397ba502454c5b6e5578ce90b379c6bd44731fdd37826f378bc761ae3951c79e477bb0401caecab2d3b80f5ce89d2c6fb18e3310dfdf659490c400480453f77159c1c77a5e574df1c3471e9e873346b42141e941905c49e82153685cf83b8da7dc2594b63ec3b7743ca13f165f5131e1791202c1e412eeb857de46d74436e37b58f6b4e9185b186a456d9542cd0439a7c10c12bc929afd25358669371cde79c2935155c03035ee54fa0416f56302ed4094eab8774aabfac79f7164d751e59c83cc058201f84c71ba4023ed86c42cb01322da6101a2f42df35d1fa6a45ccb2104f91477b91ada546191057694f0ec5dca138b1bc616ba23eb831fddacdbf5be5c39485d1f25884bd56a30d76f6cd20e9d36a727ffb7c90062d0c72c9db89d8baac2dc4ef3731f8e0d1f0d7b7650655f1c15b3af5d29a27387080886e00859de003bcfcdc6f4c6a760579d31f27213e37e74789ebf9481e3da8d5d98450e4e293965e74afc3c67a441be331b3e5ec95c299fc8a389752452f1c1481b58b26e1a5ebcd34558977be377f2ba9d27ea5d6a464beb1ae201931f3d455e4b27385ff0490e7a00f633499a76113c629f777305a532d71b1ac834d9b6229930989fb85aac05562f2b55db71b462c22c7459aec75cd45c9788f15e309c622bee2ee2e10147d71db5f07ba6c5365da920fa96f526ef9c6fa815dd99d14e0576e9b18a11e87f20796931c1de5a875b2f9c14a4c4055b87045a7c99c638a0c0946631d1d86c7855f855f80e17ba979b41d4f7dfdcf79a853d3d426666dd20bc290108774decf73aeabaf99e4153863aa8bdc3c76395e18f9b16eb9ebcab2bbc8a54ab56c2f23a8d9b2336671264eaa2d61ec66fde5e6193ebff41135a61f25153a2cd3026a15a502abf5af44b6e137c95a0a0b17aadd560205e13e43f15b3d32c6329d5e30736303cf78599cd2da007dab7219a5db281d057d7cb87e713363ca1dda1d2e0bfd711ac3bffd3fe6d4ef3bc8fc5954a3d6cefe6f0577b7157a9dd6cf9f8a12d196ec217c025e3e8ba1fce3fc900c048671bb4fb9ddfb7c6b6daff073c9a5170ebccafb5183e3de948f3c0f40b823eca232ca0b1cd46dd50421f0096fdf1dfbe4beb0b63e1af43894972517c47811e96d55e3e03cdc9fe496a58c36dee050522ba529cef454956d2916dec59f862234ac9471c2d452146222e92a1ce2672385eaaf23194da6f1db1b562915ef45e19d89882fd20d9c6889d1cfd9ceddbd8bb67f1ee700faf8f0b2309c4f64209fcc3090d216d49a2b3dc500083cba46de9678f7a45265a73eef5c7b1bf21ef3cb6a8c24a7d2af45ff39f70d54d90e408613984b29c6c168c29fdfa35b86bd32ea5a5f5911e80b1cd7967948c181215344750e1482409d9e09a9d3a76eb939cd3edbf8a54765b801add048b0ddb9369acb6490824f09a5f959c6605c3d6feb33d2eecedf113d95a1e9cdb1ab96ac4a0b85d79d5089fa2cd58cde2cae1e6db4dd85c44fca44291de0b9f903194303b342a5073be3a4b65d94a684031ac965b2877d1ca2f308ce729402f31050a0d01c1b1f1a38a98876d7587b0f14922bc93d842aebf83f95ac280f1fc0f268b1bf5b9fd525031340bd0ec2b0b1eea649a80ee301ec6e1b97d81a5f79f67633bc01cfb433958c60ed5a89a1a12edb9bfa552d52ef137260ffe155d04c5acd9747d88e48c7d1e1cf7dc00b670cd93da741d9d95c9f03883733c4cf2c66863c93c429189d7c770ce7d4f891df160cae57691f372b701460fb44ddd7702560993b89d4a6a10fcaecbce64e0ab479db3ff4ca6309ab16e18777db44311ad5f87a7d8e7db658c2fae587857611c7f53c764918427e6ac0d2ea72ed78d0d5bf4610f456e0919363b723672f7398e7abdf8954e3e378c61a6346c5c23d8416150458f392daa998fba857c3f151b77bb0af204fb3dbb73efe2b3378b54e804de3f73cee84e2dc38e4e27ad8fe2521a1b271d7cbe48536f6dfb1286ebe30fd8e1004a0f9808fbd7d8d66819552e6a3c6efa660d4f0e436491003a8c035ff4e7dd99a48d248e3c75d4547bb254da4b60de5c918be54cd24cbcbaa4e4ff350e0c1f8470348879b2519d6d09f5e3f09bbcb5517442d32776e630c255a0f4136493b40bf0fde4a25dea0a090afabe3a2f4726705a58ad2c63dec7c1e10627be0abd404d5b044e7a473cae077690715f30d4a60b2426131227ce6da6bf381bac089088b06e3aea99f4ee2b4e7e98113e5efe759380aac150a6677965d176e41b776936312412df4d42c588b719844a5c695e606140fa3aab9f51096ccd1fe82d838536641fffcc7c44bb8fdace30da2f6dcea7e6502c173f78846d715a20be857a8065f6232fac2f57944028d54822b8259bcfaee52c443cbe554f963b79d98d49f7833a1e2f463d7dbff356f28dbe370b9379ec3da866865a83b54e98cc924f7c0aa75775ce985a46593767d932dc8cc17feec5b49e4ade067d073be09c932442f541d1dd4072b600f62302c91081ad618702ecd0ac3a978e21ab0812e3ac18b5e59b71026da3308d6ec92bf8ba415a0f95ee341e5d227a46329e0ede74ef266640d370ae63a7f99a35ea0d9c8eeba04d825eafd7cfef564de4ccab299558406f87c50931ccf05c299449373947db2f48b503022a08c5f59dfc5b5f5490210a644b92ca517c0c526c3002fda22c6b9f51341cd6939917b633bb8fce20a600035de6c84a64d206b8070d14d942292c3bbeeff233a79bee08c5dfc1556bc9cc9204bccb5af492e08b467457f631e7eca99de9fc416e7ba9ed7850531708b7d1c0c3735b44cebddaf0c3ac0f8de4adaaccf8870eb6b3303e224c1a1a78cbd330e9b478d7d4ff9860929468aae9f2cb4c7cae5ec172939a360a426fbbde4ecf16c3d31f761b14c6ae62f74498a396f64496ff402925981103cd67aa8158dd56ab14f5eabeb99418f5954fb4ed2946e7694a35830085027a2bc9d344e7d269725f077bd59fffa9ef3d57a43167f58039ce1b7e67dffa3c825c02ab5356481179528242ab402e7bcb6249bed975dddadb8f4b9e1f5f6f94ba6a5d9ab60d210b73902e0b92db9516b752bb0107539e861e9f9e1c0f5d08fefc5453d2d8c48a937574c2d1d379c9c1ab7521c25081cf144811f9936a2ab69ba4bea5dafc25e58042f10aaaa0f7959becab4b9389d5fdc827d858964435814ce1fd785341e91bdea3db8baf7ed1cf207dc9241881369bc410ec9222e1e8c8f5ad1f82c31382366d1625dacfd701ddb784776cdcccf188ec58b42ee175885edf189ad5be6e1e6ab31a8b9c5ba28419f3f7eea14bf9aaf1d9ced8cc9ac5f3fc3d34c5de9fb4181652a1c9c6390f4110ac085e2a53dda8e2cadeab403e99a3d5ae1f25a0c7ea738377e548f696c7e6c8114daf8029e7bdd778267560c21154ca2523b3075227b90738ab21f3a64c2221a686c1bfb1687d24f36424519f910dcd00c0469b7eab7d749e17acbdcb5a86751f2bb3726f13d0656cab37e453c8bd5ccdc5bbf2a9812e37a789a0e5ce28082e2ebbc946774997e3a54b99ebeb096c8308aff4db03d0eb9f1d88d489517775621d647d017853ef8bee80c5884c5fbfd32751808b635c93fb131fe8cdda09f92c14236674c0651e8c71dac680a9019e97d0c8361bc9a4cf9c861774897cc9732b97b8d624b59cf2e14ca9f307a82e3a349ed79a442ceb1ff15f5a89576f7c9e1c3cf9645f610f9c97b984544124c38c3df4fa876e6ed51cc89f918823056a302acc0f642a3a8e3f92f3606f1b65fe60473c24539625807ed32456bb3169628c7519c2a3be7163005e5ab3b5a9dd406491184dcba8e6912d91eefb9e</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-16</title>
    <link href="https://unit-serow.github.io/2020/03/17/%E9%9A%8F%E7%AC%94-2020-03-16/"/>
    <id>https://unit-serow.github.io/2020/03/17/%E9%9A%8F%E7%AC%94-2020-03-16/</id>
    <published>2020-03-17T10:45:31.000Z</published>
    <updated>2020-03-18T16:17:04.739Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="8116ac38fab485852be3541712d96fb071694491cde8fb6671ff5b03488be843">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e5bfc96044c62cf099706e61fd2bb0de2b982aeaa6c1addf26bccbf89281d3e351d52c977096fa17fee498a72ba24e0be01a31b030642292984296ef84aab71f8bac934e9a0daf69751f6902a5a21cec00187c54153ec988ea220a53a52e9118eaa1942200abbc64c18f8c99fd3a35c59cb7ff48f6372a22b933802dd98674a37855039e56238b0ebdfc40e5c698735cf529835538443eff6b3996440ceb726308da3fb383d7ab4cbef54e79c6ef2be1fdcebc890109a8e637b5ffa693f26154cbd348a6d2476ec7ca186a99a39dc28378f8da0459b7247c06adabf1dd8c6aca8929f5ef644715104cf60d2c7ff1178430de8561f830e7233b628b98fda9bf06cc4603bf6ab5768a18036df6bbe72cb5357d4dbe8a8cf7951901e910d1321af69776eef93d88d10d575aaa38296d1622fcc2620efc9b2b0f719e3dd0f940ac4d9777b1842ed886aaad91af685c89e11b7f4d8048c43d23bf69a15c30ad03e38b0bc995813f7772a24b61e6bae96a3a13d3237004de98067d849db58417e2dbe64e2aae62caec2eacf579d3e62173dbbc84b7bb179a2bd8ceb095a396bafecd19831c09ee7159ce60d20f59c54596271a650bf0a790e42f3e698b6afbf25ca4711915046796ef297ca8d0dddb3d9ba3fb6883ac9a6ad5150d93a6f7aa9c8e458f461f4e6d7edbe305cf4a0ea86ff5853bde6d298188077929c9041df84c68a206e1c794df2fb0ce1392d5d29cf3ae33ec7f1eeb08fd2e6c6756c508369e78ef97f90dbdab38cc2f2d02e19ccf7ec05759c672c0f6cc22bc6da45592f9a739649635aab55b39f6e8677fc6dd03b1996c1be41adc7fa8bd18fdb75b7ffdf58a3162e293dba7d71a922886bdd7d64cf83c16fc0544cf613a43c3ff9f635e4b14c2852068443af955229402d163ca7090512ecf5567ee96b9c4d3084154f2997937046a634de6a27d362a572d2d448fb11f7859df7ee3181448049a825cf38e647a0e8be7e51e64d226eba59e0a77638ce7d9e69266fad3a52fa7351ac1096f4d2a59644ee233429173a3bf51940151eb7799c790d83976ae41e05bcfeec5ad50a9f26726306c9a435be85ffff5c446ef0ca5d1c02aee74d1a167a757ead55b213fcf00df86379453419c145bbdc4152bb13ad9c45ad3d2cbd5c412ca37aafd8915bf084b59b99c449ba4339bc6a55b7d464b0ac5f583b62ad5d7196ab12459071c4fd19e75dde1f4077b2fa8eccdbf73433515587ca030a7082f66ef2d3b27a7a9e79fd93d3135858aca7b7f4468b8db37a1427f03ea492fecaf4f3916491347a5d53c0c5ffd0c18ad546de46ebe75cd93eb88c56b50ec04a95f83053fde26444b8efddfa4f5c8bcce6c24cbc7c2dfc052e0ee2e9e66f4ee29f3f1c50832f333fdd836e6413e42c7e434ecd8923332dc378d744a91d02020781d398a0ccfb525d2da04f79990c174c4509b5d200d03f674d7a156d9f6caf93d3644672f82805adbb42be38f49ebc4790a5d46ff0a32b56f32f72f852be6bb3463bcd141d0504ff4c431e1b30e932449ad5612bd9e2e6889c8ffbf2618ca46cfa7d886e24278acbbc3f56ee34fccf746df4dd3ac8132f0d8a3a0738800d5cc9dcdb01c46ae966359decf04da1d9d6bab874e568bcdf285d2961cd7d88ed548cd05b78673299dc590a73969fbaa61b13b31fc5be218d01eb7366cb51868b7c3e2d366b897c661e55def3d48c0247385c3eddbdd18e7c45b87a1570187d2da7514b0c81c3c44dbfc7675f920f5d5f0cca3242641cab7bc72c352850133c7bf87677d8fd00e65b560a9002939576532eefbea69ba2ce5c734ff93ab85679645e5a3287f10cffc0f853e0c347f38fcd2258f563822af89e8825507531d1acd62d5829d23a1a37cd7bba0c74b7e8fa2bd622a3a7540f6c4cf203fdba7f17cab641c6b5a2b34d1fc1511288d6bf30ca328e6d50db66c1c614ab1d801ab8116329ae2e4a377d73e2d65b6b63ec11f9d72f720dc7ec111048f300d398cbebd700de996abffb899214d2a2a4b45c529ca77262b26c15882b8e6098a12e794fdf7d6d01d3c4a1464b48213a10cc3be2d53524f8ab91e7176e70c94c79f82bb1af883784a8eb1724c779b822c9d73a94a5aae5cc6c6c7fd5d289ae1dfd9a6aa7c403267b2d6acb1eab8799a91a6073462b51d71bdd7cfce278445857584a75e197415467f89be59462d256f30d89c82755d79f349b1c792d2532f2b1ae727ff644286836825b8dd815a904c862ef3b82b3fa564c525c5168d89859903c299acdc78c757ca06be161ecb1ed03a04b13b714c58900932354c645e3bf1926381909003bc8469373e1f252bceedd93e289a571e3c81bad99663af1700a0a21a948f670798b1f5e8723430c6d37b48227cddeef79d4d7e5c4863acf84ecbbf6063b4f943a9b2a34d64116469bda91007288cdeb8dff16927748fa2e44ca8cece21dfe71ebf2f577f3363ff72f2122bbdf9a9a1ac1b8eea4740b19d7980f6b33b934e9823191b75e36a208ad850de8b95aa5e8fb2ffa9a6ef004737ffc26e5381053b4168280a039991277f79b411b4d960c474b2acebfd952f2784cf3052d0e7b43279732cb94f00f75111bf59dd4beda0f47da6eb29e8dd53733420bd15011fd5ef01753b4f9c2449be37a5a543379dbee6644f415450411ced99072b2330f0b1a9b2316d27df0d959c29536c40e909786a22ca7bc1b148c5745e83ac1a9e99eb71f53307c709a755d0b1c809113f23c6362f77cef6c7ce06b77b1d7bb99367221e061f7807c219b2d3b025f921cb42573284b72f0afc55dd79dd5aa10d064f2d7f8939f90c236244a73f79dc1f77c6c0f811c956e38ea33a7e2ecd3a6cd4478312375b10f27764d08f6903dbe9cad4fd91482bb3361c2443aca87dea4c1b3b4afa0ae9babdc1795f42b473b0726c8408bccf35fcee36d7f94e06f71a4205fbb5bee8f1393b88e1a71ff47c31e7685b7a145f2ddb09d54bb8770dafa4814611899ea9e923e1e6d30bb58befa17cce9220c853b43ebd019f468d2150cefd8cc4bc055f953e1312a3793042be5a4663a65019e6ee111b067b3871fc87a43e8a2c83b36d6263d430c0b75e293bd2eb99e48245b1368b6716df2c3ad650c9aa613a767f8fd6f43c2a073f45f20bed7cabff1639273ebf107a233c76177f60d3e714b05d6e0817d4c5ba00e192bdac3585979b226f21be6e3a63e6549ed9259f1ab38125025936ae5fa7b3af9975ba6137162f0b46dee92f337c89a33968b90fcfb6d47363f222e56a1af9dfa2c2cda604f77f624bf1851e3810215336cbe10d5807f0c9f60ddea69db7cbf27744d179a69445f1e00bbd24c8a5432bfe5d172a0eafeab45b99b1f232b9764ea564a102d50833dc3923ece25c930ce61a78204b24c7b367a1d2db63624d04fad7f81ef0ded59eece6345da2610013c7a118407f2fa28c4db3e357bcd9346cab6b8c9e7499fb312714d278c089f352c4ced492eaa501127f381b214dc9ae061ae87d811fcc5b1f59060d2b87db95ca51d3b311906daf9aadee3d68b0db6f3485503ba0448d2cb07167d72da46005469c32de88fdd570e4e08bf618e52af07eccd52dad20e9ba30338dba15b4001182d00906b4c05ab038b357623b2583c32883e64448e0e0c95c8155baaeb6235d295588c1af7adb710d0e48f28621873424d26f4f529f36511781549d6669d2283b1bedb4b90cb5d9f8a19d4dc63e269ce225763f3b08a07e4cf44e714ec354a5640fa79197468101e1690b976db61da459ac42df68f33f45a35b50ba54038d7168096574004e95257f36781a663dbcaf6cacc07c941e66dc2380a6f5b3cc5fa000029745a6225176d6f6eb5e4f2104f260e640af8a7fb888462e3693ef198e2fd84e66cde5ae9adff5e7273f8407d1b42faf12c2feaf8e33c1b0d5bec23ee79abc8dfc8e1e3ebae1743cf2da990542410c448c062537acaa965c08511306c2bb3845a821076a93fbee14fa51d7f542a3d960d0b405144d5ac962efa4f367a07e97f384198afafe7931253e2221048330da4902a040c6a74136de037ab9376a68f5ab51a57e22d57f423a1c3fe12dddfc43b5866608b7aaae9ad0aede8068574cbe584f55d1761c7c4bcbe1520b0070bb816cb4470faf80ba3b8fd5a1e38bc32bf1d21cf0687a9586a1b90bc16689d49534c8cd6c7bb59cb65f5d8ba12524459f5c8bc92791750fef4aaef955bd7f04f84762e32c28cdad25f14716bdc5567be350420f31449aa692dfc196a65ef2aa7e780c6e0ddc14bf01f629d9bad66dd1cab2f39b17bc7d1301eae625fc696cfd7baf968504f7d209b31e763f61e927ea5e0e7b1e56296b5a0f7865e08c05e4e32aa8cc72e313324ec2acca7a5d167a9d9396048bf280e5f3aec5a91d212b9b6acfef5a41f0f0a3feeaa41fbb23c7f84cef838efdfb153c226ebf489eb5ad779b7b0f6ee8298db560f4d4e9bcfe903a7680319bc5631f71b30ed1f722d200a8837e81bc424ebf62d7d80aa6e868b08c5ef062ddd214607a0932234792afeb8e4aa7eb83c32c9b757d731542ba93d1f4771ce20652eb79810563a6409822f3f748e1282551649d1593589ac63e4669de6812f6a0ac9a63eb7fc00a094bbd8b8e878150813ee86c2f3711be8b31d4e923d03cb85daf338a78b2be80a6810de7513ce0ffa9450851ad93c086ddcf035118894709c75c3a5eea868a7c3d5ec20b934cb79309b5fc886ca76518365491a91e93b1e9d3f3bbe614fb74d55a1c4929eecc6284ab8ecf3b3afa9b8df6b589068fa2d4d4a499b122978ffe7fadfd87e6847afaba65528d5831c4d67064cfd17c4600e2112227a0b8591eb14da3feb67900d2d9f436f1ade8d5562b677a6a6849d3381a6496baadf3460f51bd58d572db226236d88ea841ec3a3edad8856f4634db97e538c1ba4c47a5af2f5df94bc2343a1566d8044ebe392dcad144b1dfe8e9e9c3f416e74b15eb35b7c1b5ff6a30a87fcfb64a2d5bc25ee8c60cb2af07b882ffdd20e703dc909c72ab24bb0545f50aa597a5687795da2b727ce4d866fe302270203b141aea2acf79a71a067d0864e225b6c1342a58fcd8d44277e794f0814ecd54f0c409440d6a83188cf39875e61b761b60d7c436030f75a82012c377d89b016d22d8ac6c750ff001c4d645936c0cfef3b1c5bc2be465a8321c67b9eb337688c471e4b3d476fc3d0c7ecefb0f00b7c8b9993561bc2a71f8f290f8fb7e21a0f500994d961a52ebc24e4d2c09049c7f7237c811b5bfbceae553e624ce17de5278a35b66ba805b9e26b1c70940725cec2532dda387d52d0eec699b8d84734646cf40086eed0fd14124f336191068b044e31c5862927e58e8593cdce0d64693f725cdd4bf8890d17ec04dcc1fe06afafbab639e0839ef3c2ddba0abf1a7f474be4860e99a008dc73137484a95158bdc95c0a160fb8452e20f3d5b928b482f29f154058a0b85b8a71bf2c6bf803c23e53a83faa22ccc39ca8ba8a2eaea2d41636e9cbe55173a1362f8c491a936928d2e57c58dbf6db5ea46681dbfffab5656d6ad9f88cc96846be19f595754c0aa4e71359d1e1b41f23c515d5b9cf5f7e66367e06e21cbc39778c2b149227f0939c91cf7161c46a176cc9213d0315d014e137d77ca16812f1fc382e3b7a5bf19ba39602cf40c6a457a03a8356f4f164a3001f825774b4852d4b59b775ac1d11456f76c7561662b74ea328d5a543b5d376a59d1c6c541031ad8adabda8ce12fd6259cad61614441b15262a0dcb22878ec50970324eacc41bc7d16887e01ff133d41dd4190ef625d98d88cf11f7f3072738544d6e0d3127e6dbe1fe6657a079fedbeb0958bafb3f189f8906637238f0007cb84d772ca6bba5b72ada30c686fe865c043a97ca0e3dccaf89e98200b6b9805499a14e4649b7dcd7ea56c24ee757e516a4e45305ac85e6115bc9e81485226be2a808ae616f4ad91bfd719bc86967ce56e1c812edbab6e375ee80a478c68a5c035c9013094f7857113cdc0d68e7e7dc56bc0ddc007f5a89f8257d3e078f34bad8eadb71a60b4a892ff1e02804fae0562b7dcff1159f294a07b5986ff63ae1c473ca58d60f5826df209a9dfbde253484ed11a73776c4dc0c330be34fe681ba3919d83dcbc9ea177edc20457900bc9407184d5f4789cafb4b3c11399d4ec6ff533a2322c4b5cfdb3bb137fbe7c58375f5fae959ed450c86a87f89b4b0f25e72285b6f94f1089e1ef3fb6f3bd0f1b2a2efb9a9d298337badf7adc3f704f1435b9e9f9f090bc3c086c24c314a34648431d00e5e32bfcc59c922ea04f3b9c9504c08917301ba1a2987841a1d1ff82b2f5d6ffc6111bca2c8daae5d76c370329840d2a7093693be3ee367e886d132b1b9c4f55ffd247ab746954f593c22898a772618965e7cef8f20b3972d903e237828d885a87e7c99bd28849816634f4890ba07f6851567d080acbc5935f45421348d8f370a9f332e8bdc9c43dcc906b981ce6a3e39b3774e380bd28f328aac7e5017722c1c1332b6d70040c529a46ad2c5089ff0a74ac73376d8685d4cc0a307bfc6cdb235e4ab2734d73f0bf802f7c0cb39e4e3fc467ebdfcaa0bde8605d06bf471e717fcee3ff0fd201c5667e836960361725226dc425159c1b44ae1ac8d22ee6560c9a79052ff23ee62738cde361ecae61e2d84875e0ccd7cedd734b501c3cbc6e7a2de7d70d68a0451bb35c0a9d7aadb89012eac860edfe2a69b31b3279a669138a73a9309b1869370dc2dedf162838433e00e16a9153636a1440e2262626dc3f0746e4c24b6809f76d6f726070e5a0f511c7ba4bc6c6632edcf5c7acd1367006a356933547a95dac2a1d48d3229885a3906ec453e84c00e86cee24adef55a29af33b9c48f7d5a34bfd7892b7775db85bc03202d2a561640c5afbd2505dd9ce8babca2170b0414aac08463c0cd67aed4a4a904cd045bb2a16a5d5f94987c1c6b97053403cbc64e52ed4f535399926e3324eaf42692fb849dd47603f74c595bd351167079e2a0b1f644426f63c76f288816cb14a7ad6451e768eddd0a700a412ed40be2653f658882a0b92b7fd33bfb689fdd2ab881fdaaf4712486d4e6c70695266b87f5e2807cad1d4e4fe166ce2eebf9005dd471f9aad276bc69af8a5b66bbf00f23b7d67a3f11d0caae019aaa1b21bbca2128d35648b698adb1badd968c7a2d6c2dbf1faa0492b691eec6ef2fbe6087813b6f5429d2e83511a16e8a1e1e4d46bd07c09fe37299f139362e57051fbfd55454ed6b3be8f258d442465e5afa230857fd6d470833b7a2ac27def375fc754164aeb5dd03f3971ed2f37e09f76474daf7bb739ab5b1b06cbc55374de05340502a9769865f6314267d3f95fcc00536a89853f2759865b426b633057ce185ebd01206433ff293434889e95289efa72999ef2ac3ba4d2c4b53071a34604fb0d56b13dbadf07d1f5f357d9c07056628f990c5ae95cf1f2369742c00afd11e44fc1eea8160934bbfeab9ab40de71c038a1aadb45ba39ef0fa61b97a37b33e083c6de5e25c4e18f900377db5d9cb52aee997c6804f6d2430dda69db53bbabd58479c3cfbd96cd5fce0521ef631971324ef5d29a35fa72738ed9d108208a82d474dfeef540fa76ec7a462fa4c6905b4bc2f846644473372cb6ac925dba750d0e9a041347ee70cda23808aa8922fcb003156a43533fcbfe7a7d4be6437a8a759b1eef1aeb033d746f565bd8a2af38d8f4c52d296df2e6aa1ad45d252afe4f4b4bdf3e1d8c63fbc54a86a4e8582581743f96c74eea6a9a1d3b74ea62bfdf07d73e029f56f7776beff8df09f97a2ddb7c302de0b4915f4fa27e9e4dffad3af961533a27df2d0bf36b0cf3d4f1b11c3c2895ef0ce84b17fd446c11d8165e1fd27d70eb678f38ee2132fae852bbe70de4b4dbddb65a273b5cd1a8b23bfcd265a809f2e3fc700dcfa415446a952974a6729fe3ee7ce11a487123b7622939521fd63eb5596bdb352ce8298ede76c7762d7925a3c3c41875d6e74cad5030702c1a92194fc359f15dc30013290d93149a8733d222a333598d082a04b406b535883c5caf65a39decf52b381afe43db342127021ebde09908d7ee6c0b08344a1c04c596b78c52865ac34ba4f6d9fe4585e79c3612b8e8fbb4c3e31827458dd7c3c8ce3c52a4044809ac4a73b8a8eb6a4c9fe040be5910fa709f7f8007b88372fdc756f5a4998fe7f7df3e2cd602be2fecb49d1e6efbd31d6322701fd8703bbb075200fd4887d9728693dd5434ebc423b2d8222fb8710dfc7662661cec791edd63ad56207372ad046c5683c2b4ee45b6689087293152f92326551cae944450bd8cce98a958985fe133d311f3e87b7f319320fb0f3afd800223279dd936906112dd395f4a13b66e54d8cb599eb4b403313f7952f53544163a703886d19cbee4a0051f84d4baba8c7360dd52270b68df2463e064bb96e21fa9d0fa0afa4d4a2ae8733a38df359f946df9ce6daefd5a9892483250cd981b5e77b0e6559d2317a571df6fcfcbbd43e2a84602b121cb13968f935b2888f2cf137f822d69544fd31f93af081778a8b1bbb6c3120ccec13bb66adbc484053991a4441ea73704e226c15093fe427944d3c70e94f83abe6e0755a157572a42618cf4b9c431379b52639708f1bf034cd69f78ce67fdec9e9146bc1ee514c9cce427c6e58032ca7dce411f781c4b6b3d111eea9ff18d32395bf6dcad26a0cfc5a5a10ac73cfdcef0c1edfe739dfc440999c98f5c6be84bf2d31268f1f5b370adfcb81350ec9c214ce9f2f196c42a7834a298c362e5ff52fcd94bf9aee62419dea906da6f4b4a5dd2e17fc60eadef3f9d5ae13514a8ff1d664fe22dc61a668aa55d1d75c4771027aba203795230bc31d1ca1b3690a75da2db046336bade5782764f8d0c0956a07f975ca2ecd513dc44556fd421adb651db9fc29486896d1b78364834bf054f0c012c24ad8ffe578f32a06795c134d262de549d284f75bbea3590946a8dd7ffc205d9c2ae0c42ecab0191ae3ac6c3a2bd6d4a6ad1397878a8ceeb5c5b3d7eb1de1b08af6edabfdb885f20d063b59bc828b5815cee27bc919076615068e2b609e49a55ca02a6c5c6185b72131a3d2260af77c0bf23bf447ab77d8ba8690c71e5864c3be35ba874ee2972f9ef76a8572cd98ed8dc6413caf73de283fca430ef656b61bba821d88e35332447a04bb344dcd2b0e0e555f1fb5e7653ed077798fbbe1232434e881006189223fb0e3089f6a4ed4a50f7f8b347bffceb7773b4c75231d89f9e2f6b95a72ff8b0610c674855e114794ad16ba212e6da2aece95bdc3a654b60e9a0fce920998b725cbe01a2c0e102f9b267eedbc03d91e974fbdd21645e751c78aa72b0972cca113e2496e1f06fd8a8fa98a7c1bf4093106196902c8efe841a7b88b0361497839bd13ba1c63d84c1dd471d89038e56a4b48777bd93f007000e</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-8</title>
    <link href="https://unit-serow.github.io/2020/03/17/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8/"/>
    <id>https://unit-serow.github.io/2020/03/17/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-8/</id>
    <published>2020-03-17T03:41:51.000Z</published>
    <updated>2020-03-19T09:01:00.042Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 17:01:07 GMT+0800 (中国标准时间) --><center><strong>数据类型-I/O-1</strong></center><a id="more"></a><h3 id="数据类型-8"><a href="#数据类型-8" class="headerlink" title="数据类型-8"></a>数据类型-8</h3><ul><li>C I/O 原理解析-1</li></ul><hr><h3 id="字符输入-输出与输入验证"><a href="#字符输入-输出与输入验证" class="headerlink" title="字符输入/输出与输入验证"></a>字符输入/输出与输入验证</h3><hr><p><strong>相关内容:</strong></p><ul><li>输入，输出以及缓冲输入和无缓冲输入的区别</li><li>通过键盘模拟文件结尾条件</li><li>使用重定向将程序与文件相连接</li><li>创建更完善的用户界面</li></ul><hr><p><strong>相关概念:</strong></p><ul><li>输入(input)&amp;输出(output)</li><li>常见的输入和输出设备<blockquote><p>包括如键盘，U盘，扫描仪和激光打印机等</p></blockquote></li><li>如何处理输入数据和输出数据</li><li>执行输入和输出任务的函数<blockquote><p>即用于输入和输出的函数(简称I/O函数)</p></blockquote></li><li>I/O函数(如printf()，scanf()，getchar()，putchar()等)<blockquote><p>其负责将信息传送到程序中<br>I/O函数的基本概念解析</p></blockquote></li><li>关于设计与用户交互的界面</li></ul><hr><p><strong>关于C 的 I/O 函数</strong></p><ul><li>最初，输入/输出函数不是C定义的一部分<blockquote><p>C把开发这些函数的任务留给编译器的实现者来完成<br>在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型<br>ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些极为常用的<br>由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性<br>因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数<br>其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面<br>这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序<br>这里所提及的 I/O函数 是所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统<br>处理文件输入/输出 的程序也可以使用这些函数<br>许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配，此时则需要输入验证相关的问题和解决方案</p></blockquote></li></ul><hr><h3 id="单字符I-O"><a href="#单字符I-O" class="headerlink" title="单字符I/O"></a>单字符I/O</h3><ul><li><p>即为getchar()和putchar()</p><blockquote><p>getchar()和putchar()每次只处理一个字符<br>虽然效率对于人为编写与阅读的不佳，但这种方法很适合计算机<br>并且这是绝大多数文本(即，普通文字)处理程序所用的核心方法<br>这里会提到有关这些函数的工作方式</p></blockquote></li><li><p>自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联</p><blockquote><p>这就是为什么程序中要包含这个头文件的原因<br>实际上getchar()和putchar()都不是真正的函数，它们被定义为供预处理器使用的宏</p></blockquote></li><li><p>如果在程序中同时使用了getchar()和putchar()函数</p><blockquote><p>在运行程序后，getchar()函数会将用户以键盘输入的值传递至程序中的putchar()函数<br>然后putchar()函数会将值直接显示/输出在/至屏幕上<br>其涉及概念即为关于C的键盘输入处理，缓冲和标准输入文件</p></blockquote></li></ul><hr><h3 id="C-缓冲区"><a href="#C-缓冲区" class="headerlink" title="C 缓冲区"></a>C 缓冲区</h3><ul><li><p>在老式操作系统中运行getchar()函数的输入循环并以putchar()进行输出</p><blockquote><p>其系统在回显用户输入的字符后立即重复打印该字符是属于无缓冲(或直接)输入<br>即正在等待的程序可立即使用输入的字符<br>而现在的大部分系统在用户按下Enter键之前不会重复打印刚输入的字符<br>这种输入形式属于缓冲输入</p></blockquote></li><li><p>此时用户输入的字符被收集并储存在一个被称为缓冲区(buffer)的临时存储区</p><blockquote><p>按下Enter键后，程序才可使用用户输入的字符</p></blockquote></li><li><p>以下图片比较了这两种输入:</p></li><li><p>缓冲输入和无缓冲输入:</p></li></ul><img src="/images/数据类型-8/缓冲输入和无缓冲输入-1.png" width="40%" height="40%"><hr><p><strong>关于缓冲区的存在意义:</strong></p><ul><li><p>首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间</p><blockquote><p>其次，如果用户打错字符，可以直接通过键盘修正错误<br>即当最后按下Enter键时，传输的是正确的输入</p></blockquote></li><li><p>虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入</p><blockquote><p>例如在游戏中，玩家通常希望按下一个键就执行相应的指令<br>因此，缓冲输入和无缓冲输入都有用武之地</p></blockquote></li><li><p>缓冲分为两类: 完全缓冲I/O和行缓冲I/O</p></li><li><p>完全缓冲 I/O</p><blockquote><p>完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区(内容被发送至目的地)<br>其通常出现在文件输入中<br>缓冲区的大小取决于系统，常见的大小是512字节和4096字节</p></blockquote></li><li><p>行缓冲 I/O</p><blockquote><p>行缓冲I/O指的是在出现换行符时刷新缓冲区<br>键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区</p></blockquote></li></ul><p><strong>关于使用缓冲输入还是无缓冲输入</strong></p><ul><li>ANSI C和后续的C标准都规定输入是缓冲的<blockquote><p>不过最初K&amp;R把这个决定权交给了编译器的编写者<br>ANSI C决定把缓冲输入作为标准的原因是: 一些计算机不允许无缓冲输入<br>如果当前使用的计算机允许无缓冲输入，那么当前所用的C编译器很可能会提供一个无缓冲输入的选项<br>例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数<br>其原型都在conio.h头文件中<br>这些函数包 括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数(回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击 键后对应的字符不显示)<br>UNIX系统使用另一种不同的方式控制缓冲<br>在UNIX系统中，可以使用ioctl()函数(该函数属于UNIX库，但是不属于C标准)指定待输入的类型，然后用getchar()执行相应的操作<br>在ANSI C中，用setbuf()和setvbuf()函数控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用<br>总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统<br>这里假设所有的输入都是缓冲输入，即不会涉及无缓冲输入</p></blockquote></li></ul><hr><p><strong>有关结束键盘输入</strong></p><ul><li>在某些程序中，只要输入的字符中不含#，那么程序在读到#时才会结束<blockquote><p>同时#也是一个普通的字符，有时在程序中不免会用到<br>所以应该用一个文本中用不到的字符来标记输入完成<br>此时就实现了让这样的字符不会无意间出现在输入中，即在不希望结束程序的时候终止程序时</p></blockquote></li></ul><hr><h3 id="文件-amp-流-amp-键盘-输入"><a href="#文件-amp-流-amp-键盘-输入" class="headerlink" title="文件&amp;流&amp;键盘-输入"></a>文件&amp;流&amp;键盘-输入</h3><p><strong>文件输入:</strong></p><ul><li><p>文件(file)是存储器中储存信息的区域</p><blockquote><p>通常，文件都保存在某种永久存储器中(如，硬盘，U盘或DVD等)<br>毫无疑问，文件对于计算机系统 相当重要<br>例如编写的C程序就保存在文件中，同时用来编译C程序的程序也保存在文件中<br>后者说明，某些程序需要访问指定的文件<br>当编译储存在名为echo.c文件中的程序时，编译器打开echo.c文件并读取其中的内容<br>当编译器处理完后，会关闭该文件<br>其他程序，例如文字处理器，不仅要打开，读取和关闭文件，还要把数据写入文件</p></blockquote></li><li><p>C 是一门强大且灵活的语言，有许多用于打开，读取，写入和关闭文件的库函数</p><blockquote><p>从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件<br>这些直接调用操作系统的函数被称为底层 I/O (low-level I/O)<br>由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库， ANSI C也不打算这样做<br>然而从较高层面上，C还可以通过标准I/O包(standard I/O package)来处理文件<br>这涉及创建用于处理文件的标准模型和一套标准I/O函数<br>在这一层面上，具体的C实现负责处理不同系统的差 异，以便用户使用统一的界面</p></blockquote></li></ul><p><strong>有关 I/O 的差异问题:</strong></p><ul><li><p>例如，不同的系统储存文件的方式不同</p><blockquote><p>有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处<br>而有些系统在文件中创建一份文件描述</p></blockquote></li><li><p>在处理文件方面</p><blockquote><p>有些系统使用单个换行符标记行末尾<br>而其他系统可能使用回车符和换行符的组合来表示行末尾</p></blockquote></li><li><p>文件大小方面</p><blockquote><p>有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量</p></blockquote></li><li><p>如果使用标准I/O包，就不用考虑这些差异</p><blockquote><p>此时可以使用<code>if(ch == &#39;\n&#39;)</code>来检查换行符<br>即使用系统实际用的是回车符和换行符的组合来标记行末尾<br>I/O函数会在两种表达式法之间相互转换</p></blockquote></li><li><p>从概念上看，C程序处理的是流而不是直接处理文件</p><blockquote><p>流(stream)是一个实际输入或输出映射的理想化数据流<br>这意味着不同属性和不同种类的输入，由属性更统一的流来表示<br>于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成</p></blockquote></li><li><p>这里着重理解 C 把输入和输出设备视为存储设备上的普通文件</p><blockquote><p>尤其是把键盘和显示设备视为每个C程序自动打开的文件<br>有关对于文件的深入讨论这里不做多余赘述</p></blockquote></li><li><p>stdin流表示键盘输入，stdout流表示屏幕输出</p><blockquote><p>getchar()，putchar()，printf()和scanf()函数都是标准I/O包的成员，负责处理这两个流<br>以上的内容则说明了可以用处理文件的方式来处理键盘输入<br>例如， 程序读文件时要能检测文件的末尾才知道应在何处停止<br>因此，C 的输入函数内置了文件结尾检测器<br>既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入<br>下面会从文件开始讨论如何结束文件</p></blockquote></li></ul><hr><h3 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h3><ul><li><p>计算机操作系统要以某种方式判断文件的开始和结束</p><blockquote><p>检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾<br>CP/M，IBMDOS和MS-DOS的文本文件曾经用过这种方法<br>如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾<br>这曾经是操作系统使用的唯一标记， 不过现在有一些其他的选择，例如记录文件的大小<br>所以现代的文本文件不 一定有嵌入的Ctrl+Z<br>但是如果有，该操作系统会将其视为一个文件结尾标记</p></blockquote></li><li><p>以下图片演示了这种方法:</p></li><li><p>带文件结尾标记的文件:</p></li></ul><img src="/images/数据类型-8/带文件结尾标记的文件-1.png" width="40%" height="40%"><hr><ul><li><p>操作系统使用的另一种方法是储存文件大小的信息</p><blockquote><p>如果文件有3000字节，程序在读到3000字节时便达到文件的末尾<br>MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符， 包括Ctrl+Z<br>新版的DOS也使用这种方法处理文本文件<br>UNIX使用这种方法处理所有的文件<br>无论操作系统实际使用何种方法检测文件结尾<br>在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值<br>即EOF(end of file的缩写)<br>scanf()函数检测到文件结尾时也返回EOF<br>通常， EOF定义在stdio.h文件中:<br><code>#define EOF (-1)</code></p></blockquote></li><li><p>为什么是-1?</p><blockquote><p>因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集<br>但是，如果系统能识别扩展字符集，该函数的返回值可能在 0～255之间<br>无论哪种情况，-1都不对应任何字符，所以，该值可用于标记 文件结尾<br>某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同<br>如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题<br>这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号</p></blockquote></li></ul><p><strong>关于如何在程序中使用EOF</strong></p><ul><li><p>把getchar()的返回值和EOF作比较</p><blockquote><p>如果两值不同，就说明没有到达文件结尾<br>也就是说，可以使用下面这样的表达式:<br><code>while ((ch = getchar()) != EOF)</code><br>如果正在读取的是键盘输入不是文件的情况:<br>绝大部分系统(不是全部)都有办法通过键盘模拟文件结尾条件</p></blockquote></li><li><p>这里以该程序举例(echo_eof.c):</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ch;</span><br><span class="line"><span class="keyword">while</span> ((ch = getchar()) != EOF)</span><br><span class="line"><span class="built_in">putchar</span>(ch);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在使用EOF时需要注意下面几点:</li></ul><ol><li>不用定义EOF，因为stdio.h中已经定义过了</li><li>不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值</li><li>变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数<blockquote><p>但是EOF的值是-1<br>还好，getchar()函数实际返回值的类型是 int，所以它可以读取EOF字符<br>如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式</p></blockquote></li><li>由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据<blockquote><p>ch是整数不会影响putchar()，该函数仍然会打印等价的字符<br>使用该程序进行键盘输入，要设法输入EOF字符<br>不能只输入字符 EOF，也不能只输入-1(输入-1会传送两个字符: 一个连字符和一个数字 1)</p></blockquote></li><li>正确的方法是，必须找出当前系统的要求<blockquote><p>例如，在大多数UNIX和 Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号<br>许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号<br>一些系统把任意位置 的Ctrl+Z解释成文件结尾信号</p></blockquote></li></ol><ul><li><p>下面是在UNIX系统下运行echo_eof.c程序的缓冲示例:</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line"><span class="keyword">She　</span>walks　in　<span class="keyword">beauty,　</span>like　the　night</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Of　<span class="keyword">cloudless　</span>climes　<span class="keyword">and　</span>starry　skies...</span><br><span class="line">Lord　<span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">Lord　</span><span class="keyword">Byron</span></span><br><span class="line"><span class="keyword">[Ctrl+D]</span></span><br></pre></td></tr></table></figure></li><li><p>每次按下Enter键，系统便会处理缓冲区中储存的字符</p><blockquote><p>并在下一行打印该输入行的副本<br>这个过程一直持续到以UNIX风格模拟文件结尾(按下Ctrl+D)<br>在PC中，要按下Ctrl+Z</p></blockquote></li><li><p>既然<code>echo_eof.c</code>程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么</p><blockquote><p>假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止<br>或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据<br>用<code>echo_eof.c</code>来储存在文件中输入的内容<br>假设同时使用这两种方法: 把输入从一个文件定向到<code>echo_eof.c</code>中，并把输出发送至另一个文件<br>然后便可以使用<code>echo_eof.c</code>来拷贝文件<br>这个小程序有查看文件内容，创建一个新文件，拷贝文件的潜力<br>关键是要控制输入流和输出流</p></blockquote></li><li><p>注意模拟EOF和图形界面</p><blockquote><p>模拟EOF的概念是在使用文本界面的命令行环境中产生的<br>在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号<br>但是在一些实际应用中，却不能很好地转换成图形界面(如Windows和Macintosh)<br>这些用户界面包含更复杂的鼠标移动和按钮点击<br>程序要模拟EOF的行为依赖于编译器和项目类型<br>例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的 设置</p></blockquote></li></ul><hr><p><strong>待补充</strong></p><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><hr><h3 id="重定向和文件"><a href="#重定向和文件" class="headerlink" title="重定向和文件"></a>重定向和文件</h3><ul><li><p>输入和输出涉及函数，数据和设备</p><blockquote><p>例如，假设某一个程序内使用输入函数getchar()用作被设定内容的输出方法<br>输出设备这里将其假设为键盘，输入数据流由字符组成</p></blockquote></li><li><p>假设此时希望输入函数和数据类型不变，仅改变程序查找数据的位置</p></li><li><p>程序判断查找输入的位置的方法与逻辑:</p><blockquote><p>在默认情况下，C程序使用标准I/O包查找标准输入作为输入源<br>即为stdin流，它是把数据读入计算机的常用方式<br>它可以是一个过时的设备，如磁带，穿孔卡或电传打印机<br>或者(假设)是键盘，甚至是一 些先进技术，如语音输入<br>然而，现代计算机非常灵活，可以让它到别处查找输入<br>尤其是，可以让一个程序从文件中查找输入，而不是从键盘</p></blockquote></li><li><p>程序可以通过两种方式使用文件</p><blockquote><p>第一种方法:<br>显式使用特定的函数打开文件，关闭文件，读取文件，写入文件，诸如此类，这里不对此种方法进行过多赘述<br>第二种方法:<br>设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出<br>换言之，把stdin流重新赋给文件<br>继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么 位置获取数据<br>虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，一般会用于普通的文件处理技术<br>重定向的一个主要问题与操作系统有关，与C无关<br>尽管如此，许多C 环境中(包括UNIX，Linux和Windows命令提示模式)都有重定向特性<br>而且一些C实现还在某些缺乏重定向特性的系统中模拟它<br>在UNIX上运行苹果 OS X，可以用UNIX命令行模式启动Terminal应用程序</p></blockquote></li></ul><hr><h3 id="UNIX-amp-Linux-amp-Windows-重定向"><a href="#UNIX-amp-Linux-amp-Windows-重定向" class="headerlink" title="UNIX&amp;Linux&amp;Windows-重定向"></a>UNIX&amp;Linux&amp;Windows-重定向</h3><p><strong>UNIX</strong></p><ul><li>UNIX(运行命令行模式时)，Linux(ditto)和Window命令行提示(模仿旧式DOS命令行环境)都能重定向输入，输出<blockquote><p>重定向输入让程序使用文件而不是键盘来输入<br>重定向输出让程序输出至文件而不是屏幕</p></blockquote></li></ul><ol><li>重定向输入</li></ol><ul><li><p>假设已经编译了<code>echo_eof.c</code>程序，并把可执行版本放入一个名为<code>echo_eof</code>(或者在Windows系统中名为<code>echo_eof.exe</code>)的文件中</p><blockquote><p>运行该程序，输入可执行文件名: <code>echo_eof</code><br>该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入<br>现在，假设要用该程序处理名为words的文本文件<br>文本文件(text file)是内含文本的文件，其中储存的数据是人类可识别的字符<br>文件的内容可以是 一篇散文或者C程序<br>内含机器语言指令的文件(如储存可执行程序的文 件)不是文本文件<br>由于该程序的操作对象是字符，所以要使用文本文件<br>只需用此命令代替上面的命令即可: <code>echo_eof &lt; words</code><br>符号是UNIX和DOS/Windows的重定向运算符<br>该运算符使words文件与stdin流相关联，把文件中的内容导入<code>echo_eof</code>程序<br><code>echo_eof</code>程序本身并不知道(或不关心)输入的内容是来自文件还是键盘<br>它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾<br>因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备</p></blockquote></li><li><p>重定向需要注意的几点</p><blockquote><p>对于UNIX，Linux和Windows命令提示，&lt;两侧的空格是可选的<br>一些系统，如AmigaDOS(那些喜欢怀旧的人使用的系统)，支持重定向<br>但是在重定向符号和文件名之间不允许有空格</p></blockquote></li><li><p>下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示符</p><blockquote><p>在Windows/DOS系统中见到的DOS提示可能是A&gt;或C&gt;</p></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ echo_eof &lt; <span class="built_in">words</span></span><br><span class="line">The world <span class="keyword">is</span> too much <span class="keyword">with</span> us: late <span class="keyword">and</span> soon,</span><br><span class="line">Getting <span class="keyword">and</span> spending, we lay waste our powers:</span><br><span class="line">Little we see <span class="keyword">in</span> Nature <span class="keyword">that</span> <span class="keyword">is</span> ours;</span><br><span class="line">We have <span class="keyword">given</span> our hearts away, a sordid boon!</span><br><span class="line">$</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li>重定向输出</li></ol><ul><li>现在假设要用<code>echo_eof</code>把键盘输入的内容发送到名为mywords的文件中<blockquote><p>然后，输入以下命令并开始输入:<br><code>echo_eof &gt; mywords</code></p><blockquote><p>符号是第2个重定向运算符<br>? 它创建了一个名为mywords的新文件，然后把<code>echo_eof</code>的输出(即为人为去输入字符的副本)重定向至该文件中<br>重定向把stdout从显示设备(即为显示器)赋给mywords文件<br>如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容(但是，许多操作系统有保护现有文件的选项，使其成为只读文件)<br>所有出现在屏幕的字母都是人为进行输入的，其副本储存在文件中<br>在下一行的开始处按下Ctrl+D(UNIX)或Ctrl+Z(DOS)即可结束该程序<br>还有一点就是必须在每行的末尾单击Enter键才能把缓冲区的内容发送给程序</p></blockquote></blockquote></li></ul><hr><ol start="3"><li>组合重定向</li></ol><ul><li><p>现在假设希望制作一份mywords文件的副本，并命名为savewords</p><blockquote><p>只需输入以下命令即可:<br><code>echo_eof &lt; mywords &gt; savewords</code><br>下面的命令也起作用，因为命令与重定向运算符的顺序无关:<br><code>echo_eof &gt; savewords &lt; mywords</code><br>注意: 在一条命令中，输入文件名和输出文件名不能相同<br><code>echo_eof &lt; mywords &gt; mywords....&lt;--错误</code><br>原因是&gt; mywords在输入之前已导致原mywords的长度被截断为0</p></blockquote></li><li><p>总之，在UNIX，Linux或Windows/DOS系统中使用两个重定向运算符(&lt;和&gt;)时，要遵循以下原则:</p><blockquote><p>重定向运算符连接一个可执行程序(包括标准操作系统命令)和一个数据文件<br>不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序<br>使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件<br>通常，文件名和运算符之间的空格不是必须的<br>除非是偶尔在UNIX shell，Linux shell或Windows命令行提示模式中使用的有特殊含义的字符<br>例如刚才的<code>echo_eof&lt;words</code></p></blockquote></li><li><p>以上介绍的都是正确的例子，下面来看一下错误的例子:</p><blockquote><p>addup和count 是两个可执行程序，fish和beets是两个文本文件:</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fish &gt; <span class="keyword">beets</span>←违反第<span class="number">1</span>条规则</span><br><span class="line"><span class="keyword">addup </span>&lt; <span class="built_in">count</span>←违反第<span class="number">1</span>条规则</span><br><span class="line"><span class="keyword">addup </span>&lt; fish &lt; <span class="keyword">beets</span>←违反第<span class="number">2</span>条规则</span><br><span class="line"><span class="built_in">count</span> &gt; <span class="keyword">beets </span>fish←违反第<span class="number">2</span>条规则</span><br></pre></td></tr></table></figure></li><li><p>UNIX，Linux或Windows/DOS还有&gt;&gt;运算符，该运算符可以把数据添加到现有文件的末尾</p><blockquote><p>而 | 运算符能把一个文件的输出连接到另一个文件的输入<br>其它更加深入的内容可参考书籍: UNIX Primer Plus，Third Edition(Wilson，Pierce和Wessler合著)</p></blockquote></li></ul><p><strong>其它内容:</strong></p><ul><li><p>绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序</p><blockquote><p>或只在C编译器允许的情况下重定向C程序<br>假设prog是可执行程序名，file1和file2是文件名</p></blockquote></li><li><p>把输出重定向至文件: &gt;</p><blockquote><p><code>prog &gt;file1</code></p></blockquote></li><li><p>把输入重定向至文件: &lt;</p><blockquote><p><code>prog &lt;file2</code></p></blockquote></li><li><p>组合重定向:</p><blockquote><p><code>prog　&lt;file2　&gt;file1</code><br><code>prog　&gt;file1　&lt;file2</code></p></blockquote></li><li><p>这两种形式都是把file2作为输入，file1作为输出</p></li><li><p>一些系统要求重定向运算符左侧有一个空格，右侧没有空格</p><blockquote><p>而其他系 统(如UNIX)允许在重定位运算符两侧有空格或没有空格</p></blockquote></li></ul><hr><p><strong>关于创建更友好的用户界面:</strong></p><ul><li>大部分人偶尔会写一些中看不中用的程序<blockquote><p>还好，C提供了大量工具让输入更顺畅，处理过程更顺利<br>不过，学习这些工具会导致新的问题<br>最基本的要求是让交互数据输 入更方便<br>并且减少错误输入的影响</p></blockquote></li></ul><hr><p><strong>关于使用缓冲输入:</strong></p><ul><li>缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入<blockquote><p>但是，在使用输入的字符时，它也会给程序员带来麻烦<br>一般的缓冲输入会要求用户按下Enter键发送输入<br>但同时这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符</p></blockquote></li></ul><hr><p><strong>关于混合数值和字符输入:</strong></p><ul><li><p>假设程序要求用getchar()处理字符输入，用scanf()处理数值输入</p><blockquote><p>这两个函数都能很好地完成任务，但是不能把它们混用<br>因为getchar()读取每个字符，包括空格，制表符和换行符<br>而scanf()在读取数字时则会跳过空格，制表符和换行符</p></blockquote></li><li><p>要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格</p><blockquote><p>另外，如果该程序不在getchar()测试时<br>而在scanf()阶段终止程序会更好</p></blockquote></li></ul><hr><p><strong>关于输入验证:</strong></p><ul><li>在实际应用中，用户不一定会按照程序的指令行事<blockquote><p>用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败<br>作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误<br>这样才能编写出能检测并处理这些问题的程序</p></blockquote></li></ul><hr><h3 id="输入流和数字"><a href="#输入流和数字" class="headerlink" title="输入流和数字"></a>输入流和数字</h3><ul><li><p>在编写处理错误输入的代码时应该很清楚C是如何处理输入的</p></li><li><p>考虑下面的输入:</p><blockquote><p><code>is 28 12.4</code><br>在人类的眼中，它就像是一个由字符，整数和浮点数组成的字符串<br>但是对 C 程序而言，这是一个字节流<br>第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等<br>所以，如果<code>get_long()</code>函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字<br>因为这些数字只是该输入行中的其他字符:</p></blockquote><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while ((<span class="name">ch</span> = getchar()) != '\n')</span><br><span class="line">putchar(<span class="name">ch</span>)<span class="comment">; // 处理错误的输入</span></span><br></pre></td></tr></table></figure><blockquote><p>虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值</p></blockquote></li><li><p>例如，考虑下面的输入:</p><blockquote><p><code>42</code><br>如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中<br>如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中<br>如果使用%d转换说明，scanf()同样会读取两个字符<br>但是随后会计算出它们对应的整数值: 4×10+2，即42，然后将 表示该整数的二进制数储存在int类型的变量中<br>如果使用%f转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0<br>用内部的浮点表示法表示该值，并将结果储存在float类型的变量中</p></blockquote></li><li><p>简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值</p><blockquote><p>使用转换说明(如%d或%f)限制了可接受输入的字符类型<br>而getchar()和使用%c的scanf()接受所有的字符</p></blockquote></li></ul><hr><p><strong>关于菜单浏览:</strong></p><ul><li><p>许多计算机程序都把菜单作为用户界面的一部分</p><blockquote><p>菜单给用户提供方便的同时，却给程序员带来了一些麻烦</p></blockquote></li><li><p>将会涉及的问题:</p></li><li><p>菜单给用户提供了一份响应程序的选项</p><blockquote><p>假设有下面一个例子:</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter the letter of your choice:</span><br><span class="line">a. advice <span class="keyword">b. </span><span class="keyword">bell</span></span><br><span class="line"><span class="keyword">c. </span><span class="built_in">count</span> q. quit</span><br></pre></td></tr></table></figure></li><li><p>理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务</p><blockquote><p>作为一名程序员，自然希望这一过程能顺利进行<br>因此，第1个目标是: 当用户遵循指令时程序顺利运行<br>第2个目标是: 当用户没有遵循指令时，程序也能顺利运行<br>显而易见，要实现第2个目标难度较大，因为很难预料用户在使用程序时的所有错误情况<br>现在的应用程序通常使用图形界面，可以点击按钮，查看对话框，触摸图标<br>而不是示例中的命令行模式<br>但是，两者的处理过程大致相同: 给用户提供选项，检查并执行用户的响应，保护程序不受误操作的影响<br>除了界面不同，它们底层的程序结构也几乎相同<br>但是，使用图形界面更容易通过限制选项控制输入</p></blockquote></li></ul><hr><p><strong>关于任务</strong></p><ul><li>这里将更具体地分析一个菜单程序需要执行哪些任务</li><li>它要获取用户的响应，根据响应选择要执行的动作<blockquote><p>另外，程序应该提供返回菜单的选项</p></blockquote></li><li>C 的switch语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签<blockquote><p>使用while语句可以实现重复访问菜单的功能<br>因此写出以下伪代码:<br>获取选项<br>当选项不是’q’时<br>转至相应的选项并执行<br>获取下一个选项</p></blockquote></li></ul><hr><p><strong>关于让使执行更顺利</strong></p><ul><li><p>当决定实现某个程序时</p><blockquote><p>就要开始考虑如何让程序顺利运行(顺利运 行指的是，处理正确输入和错误输入时都能顺利运行)<br>例如，能做的是让”获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch<br>这表明需要为输入过程提供一个只返回正确响应的函数</p></blockquote></li><li><p>混合字符和数值输入会产生一些问题，创建菜单也有这样的问题</p></li><li><p>还要注意在处理较复杂的任务时，如何让函数把任务委派给另一个函数</p><blockquote><p>这样让程序更模块化</p></blockquote></li></ul><hr><p><strong>关键概念:</strong></p><ul><li><p>C程序把输入作为传入的字节流</p><blockquote><p>getchar()函数把每个字符解释成一个字符编码<br>scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值<br>许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出</p></blockquote></li><li><p>程序通常接受特殊形式的输入</p><blockquote><p>可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况<br>让程序更强健更友好</p></blockquote></li><li><p>对于一个小型程序，输入验证可能是代码中最复杂的部分</p><blockquote><p>处理这类问题有多种方案<br>例如，如果用户输入错误类型的信息，可以终止程序<br>也可以给用户提供有限次或无限次机会重新输入</p></blockquote></li></ul><hr><p><strong>本章小结:</strong></p><ul><li><p>许多程序使用 getchar()逐字符读取输入</p><blockquote><p>通常，系统使用行缓冲输入， 即当用户按下Enter键后输入才被传送给程序<br>按下Enter键也传送了一个换行符，编程时要注意处理这个换行符<br>ANSI C把缓冲输入作为标准</p></blockquote></li><li><p>通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同文件形式，是C语言的特性之一</p><blockquote><p>getchar()和scanf()函数也属于这一系列<br>当检测到文件结尾时，这两个函数都返回EOF(被定义在stdio.h头文件中)<br>在不同系统中模拟文件结尾条件的方式稍有不同<br>在UNIX系统中，在一行开始处按下Ctrl+D可以模拟文件结尾条件<br>而在DOS系统中则使用Ctrl+Z</p></blockquote></li><li><p>许多操作系统(包括UNIX和DOS)都有重定向的特性，因此可以用文件代替键盘和屏幕进行输入和输出</p><blockquote><p>读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号，或者用于重定向文件<br>混合使用getchar()和scanf()时，如果在调用getchar()之前，scanf()在输 入行留下一个换行符会导致一些问题<br>不过，意识到这个问题就可以在程序中妥善处理</p></blockquote></li><li><p>编写程序时，要认真设计用户界面</p><blockquote><p>事先预料一些用户可能会犯的错误<br>然后设计程序妥善处理这些错误情况</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 17:01:07 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-I/O-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>时间-1</title>
    <link href="https://unit-serow.github.io/2020/03/15/%E6%97%B6%E9%97%B4-1/"/>
    <id>https://unit-serow.github.io/2020/03/15/%E6%97%B6%E9%97%B4-1/</id>
    <published>2020-03-15T15:46:16.000Z</published>
    <updated>2020-03-15T15:53:03.583Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="1e21f81d830478451ab63f438cd662ef35255d39e958191606f76d01fb97b0ea">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e51d13b5d85b769fb3718aa98bc0cd98a62b73e77af59b9cd3454122c1346448074168c988fe0e33b625d06400df3f78fc4a87f846afa70aefd1c403d0e13605c4bce5de651a0842f943d7167d9920047b4de52c3b7581d3d85a379edd6972074d02a2db031f367601791f4a6f0aff711c83caa86aa5b637945d3df6a6b317e392d0db246bbacb41987b5b1741c9c37a26ce7bb04077c07d1fa590e516919d0c06582b3c087b57819f8324be3ebdd5fb6e6b3508685652df38c4c9522ecdf2638a622fc55920b7fb0d843ba6591b627ea878b1200a6ff3e981e96416b4d8b1a283b9172e1bfb6d102aec191174f884fe13baa17de3c1d3201dea6daee52744e83ee0c518aeaaba3bab81213e65f37121130908d356a7dddf857467b315e90609472cb6d6d2493bf110ed74f1feacba2131a35282dabb80a4d3f159b84c84eaf63336736c8cab3e8fa2995590ca481c16e2178530e751ca08c3018645328317c2d03237c5f4b577cb5941d691363e7dcaaf8597ef2a29560b515e8e18aa8be404ba96ae3a1c12017fb4cdca58f27c751032033d4ec14886ad25ffce845cdc8fd726c9230b3b54a8f0aece6fb8da3d8190a605acdf2feb3846882425d1c2126f8bcaea1c2743afbdc2e30a182ffcc5552ee9afbd354ca05fc38bb79beb51ffa5b9d27f42ae7f47dad62631f84bc72fdd9bf6947f80506599265e47ae180b01196d470230bb207c1db4f0702827b1d8009367689418b9fcff526b30a25ce3e434cd92e3ee2267e27585130bd51542e7acaad36f95087be2a85fefac1be66e087028565cb322d7086ac7bd6da0a62c600933324f1a336103ef0b25eefbf3904c79ace1ec1c471527c86db545e288db84639f321a3008621f37500488bf7651353536cd420512862f75a4703ddd2120b452658a7b05a22f499ba084e916cdd3a3919c6eea5e5d9f77db126aeca194ee5f1d635cf0aa790c3872863e0e10a06dc29d5b45295c70e2a6b42ff246de3bdec7016881851d3b2c6255eb4c3516f8aeade02abca9917eea16e791f78540adcebd874bb6f3d2d869aa6fc4199202acee7f4a90352b5567334824aae1a350b5659cbb0b33807419e5b493d6b903f4d7460fe305f8dbb1e9431df9cb8976064af6866696411d151f809ac84fef89afdbbca3d2456f950d82a2b8455e401e1a0b0b9d9f6f864b750c56e0453719f23cc6fd6e7e74883e8b23c164058417fd3ad2cf8e8f18379ed70cfd0dfcc40670fa268d67d5b98bf427259983610c2df8a61bad29fa51e62899a249752bddf7ecfb577980cc684a7fad0ffc7bd186835aa078375fac0f12024abdf3103943227c4bc33d1d39d02dd27f2d0a09da4eb9e16283741f522fb5a79ecc1c05f99d188e7152d20cd8dbd0c431f42d2768dc4b38861d3826116b8dbb31bb62d8cf7518a8836e6adf23935cacac4c17f1062cfaf1f3183d1c5aa49ae96f5fb5c43e87ddb25e0bb816b5a57d0713c5a7d6aea43796d317f4cfa8c06418ad8f2b3a953186b0a491572f1bffc1e03ad2378f5116d5c9ce8e56777e719e4502230eff0b495c97c0a6cf7b0452be3107566d480edd8ca2131cb3ce24d654d4cf460d175ca0afaac313aab64d179e709a9ea75e52fa35f6d3631f7312cccc9f33299288e7de015737f57288c089cf1ccf721f7f41f1aaa88acbd5fe4ca658f44ae61e8698cbb3794bf34b8a3ee88f39bd935a5ee5caf724878588d1e77ae1ae49250295cd5ce2fdabcd39aec45f01442a72a4d55f8ed956c534a117bc32a47702523fc0320c90159ea6433d6a8ecf22a77355fe32a2bb46c83864cd4825551bf2cf86202484e20bba6b927e94b9bd74a25d011b15491f45c98880a5f99ce26fcf1bf9297c54595159c824f6825b7e9de0c53477b2232b32a4e5daecd8021aa40dc345f9a8cb5b104bcdbfed98db6d032f4d0e797a01ab068cfe535f7bacc1f8d1e874f69d51e3e787f10344834cc927cfa6b71002baf7d584bfc7d2d2d6463255af4ce2e10331e8fb2a91efa83569e528b80ce51063e5a7961dd4218dbe0a5dd22a73e8186f0d905ae90e5743bf16066ebd89e1488782d3a445457dd2b01cdede2d6167c21ed678faf35d63af7a271cc1f463203aee772e0d758a954859c8f7640e25f2cd072444ff2c340f5b637b16178580f3288ddcce18c3c6b86ad50ad7aa9903a3e1298769665b3fbf35832632198b49a3f5ed3ed779ce21a211731f6360531bfed46cab66052c43d4bd2964aa23bcfe4a639a6e097a1b1d25b7bea177e20590a0fc161fbb232b2f9fb7fe85bb00aa8266e3b566030ea564dc306757853ad2a54fbae5b99ae05248ca8c374c228a9e33f0b2fd221d49b6fd4b81db238c95dc62c272fe822d30fbe596b1ae12b7c07f3f79cfad05f41dd9ff08aa22549b469ed355be74e421e20bf850797544e19a93c2d8f69e2e644079758977f4f9a6bd428c0cda664351e455e03dab299b03717bb718d3db985feac86eba29bc908cb7fc788ab2c1aa80506ffd616d302e7a5eb3e60f3e472802abe96ac1f3fab556ec796628c75893de11239055f929e01e789b2cf6e4e5314ff13c045be12c3ca8ebf0fc6684873bb4697bfc9424f911f035ea4eebe49369c514dc11e363151cba68e08a9616caef0821146e4bc04cbc634976e6809374478601f8c10d206dc45300f494bd2037a93e2d31b8476792a29ee3e9d7cbda8c8cb5bd71d32475b97c9c0ada122f4f88826e4614a21fd35f19c059b3c2c75b73ad9bfe137471a64fa2422216e080aa466352b269ca08d02e20052ab66fcd34ce8b5f162755a228dffc13126a0a39fabd56d93a72952d80eda1ea0b055034eb769f5f3d73cd67154dcbfbe8a20dd63ada28dd958d07e07ffa59c1009b26afe841f4370d4fa0b31bdc68b0927976fadd68f894dd04361bb7784a958458f09b66cb356eb8c4587a1de4b30e6fc3a6ef16d71e2df8bcd26ec0c7224cae2caecc8262a0a313fdecd785ab73e382c69105bd582a24631b9c55b4b753897b1a639aba323b7ced8a59d1bb708dda908b442226dca9ed8fa40bd6fbd840a80b75962d95b54b995ff5319da730675ba3f92431a7c0641684f188c1ba04f94b29f27cf0f824538e534fcea62efb459af42c29030c7429fef17b719a5ed97bb3edfd70f090069ddd2eccfa38644dd4fafb2d008d72b93f39386812383494b1d68de06647ccac4388bb72c50f0ac36d852b413a621c36b306203087c0073b012ea4e2bda3b8beace60282f10af11164172ef204eb1a95136e1092c74b5466ef08063cac36478183b6a991cbcd30cd6ca572598f8db2488909cabe77cd21c6adb87f0385c221ba5a4e09662facd5af79050dd93c86fb6d7ed49b24152f4f03ee669540c52b714fd95905135639b9dc8c9353c02b2cf75d6c6e0a789641c26c4d9b0e00713c0669049c3886b95b26bfbfdc84ce253368f48d0e88ba27188f5096da3d919db51e906069bc4b1cb800ca534a2396f245ff1877500e3201a0d6b0bca76104a3298961a57f22c27d690ccaa56e8a1aee1fbd3a705218dc0159d5cf755010077aa5be7c87957632b2fbf1c8a5080985ef02ba89a0703f8ee4b2da5f986e78d30be0e348e0690118e8151e44e41700b6bb2cf178099ccba10cfd40ef90dd9bda9e4ea9256ae559447e2a09111e06a83970e08df7fdc0f4cabc1b83efc742eb38d789281afd290d372518127055c256696b901326e58f2fc48b3c2c85d83061ee10199087d2e9458a954b3cb126156a2ad562ef52cba8a3e02f8e4ceb38c62f73f287b149f86957eaf56eb3c6b81c7d560b89d9f72bfbae15db3ac0f326876543e20658f40f1a80acac9d8185a0f6791ebbbe2b4be599a34aa61c831c4f0749097c0e54c1e6aca28849cf274e3937ee5bb8cd12a923e518a03188d32ce895ea8821adcba9abcc1390d3f519ff912dfe1ab7b01ac18457cad6d7cd4bbe2afe91450f6675db19e67b08537be530febd23f046ed35aeb1c09059ab186bd293671d6e333ac6429a2f7472e388c535b03917156073d25280e729b9945067f0798c3137ad7197df179670f6be5f1146e906b10cc0708dffd633b31b1e9e5456f6112551ce7b0668fb290e91b8979d680551f9414332f46c4d77ce122a12be465c612d5926f7e06386516921fbf22b5619505b38cf3e75218049e136980fd51fa0a74c1978a735dda2abb868c73686ac5</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-永驻</title>
    <link href="https://unit-serow.github.io/2020/03/15/%E9%9A%8F%E7%AC%94-%E6%B0%B8%E9%A9%BB/"/>
    <id>https://unit-serow.github.io/2020/03/15/%E9%9A%8F%E7%AC%94-%E6%B0%B8%E9%A9%BB/</id>
    <published>2020-03-15T10:01:20.000Z</published>
    <updated>2020-03-15T10:07:09.524Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="e1e9d050c57dc6aed9cb50b87a6af810eeb46ece5014e353c9866f4059545448">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e4b111f26008856c0c71c2ee88709c9d3fca2aa2ef07e8647af39698611e12a42d264395d4770391c21c34c0a0db83d500093e747a2396d36a455924b65eea808fef3e1845a1d53ecc278a5af52b7de8f30a783f6fb2b1a670a2e367d804075451f848830bd63fccd36e7f238aa298cc8438b2feb96270df88f9e038a3ca63f240ade0670624cb0dddb8639d87ac0e1dc526ed9db7472e8581a5656d088db7511a8248f2443b6403699af9a699b7947a35ccc2ca4df8a41a2bb7d3b8609dc069d7710ed11c25c526add731c1dce2a0b481c65a317b791f0cf8984ffa072a41e8da1a97455d9a3238b343a0d89e114e88bb8c8ba976cebe32602453685993472d64a3efc51132f77e51b1120d50541854eee2861c5a7b88e6cdf1fdeeee5844ffe52e7aba36e36bfb84e63ed8fc1cf0053b8579859a29fdf93bb7de80d9dac5bd41d4955605bf1f386426a2141b52219655503f1f199284081e551b0d1f1bc3304429b5e339a3e7790043c36e97aefc640021935f364ee237c7310bde415fe4f8a5bba43fb17537ce3dc83d2806be5bce554486e02d5e1a54807d2da36273877eb081b8ab2d1e0df267042555a365c16b9335dccceaea1d333597ad41bdbceb908c72540f9abad51342d398e84b512a45d2155fffeaf568da892e8f857f536cd87a3af6ea3b21bb5b40371f48b9f0abad76a5632eb2601f7de16c9d6b95699ee444a2eb2b5bf397d33f0349427a4be52fcf37c598a5305720cf3e5031eabe2c10f99b75ee51c7902d1bfc89871e3c52ebed6ddb0a5a3d84028835b00d30a290ec893f0e55ea1ed9d92b2daa353a28865fb24e49d091e4a53093989127a6cf12175de6f9da26e40d82a460dd501831e5466023434fbb6f888fd24b91f40fdd0b08d7c403d8d25fe76c6842422dda27c9abfeb7f1b7724fb6d238d248a3d964dd93da7f69a77bd518b99f58ddc30fbaa68be55111fdc90f171258d4793da1b6422074d2a52bb03ec506df54aad9b99326816ada7431b2f44879cb41397fbf89cabb63cd9e0db420c249d3713e3cdaf117cbe5b87c95e1fa1734fd1e00c04b617e38044e302531905ff3c286678399eb7031a9a27cbc6a23f90ee7a07bdd87e67b17f3edfbdd611222997c54c0979b205b8850ff4764ecbe9102d041d8547fbb726534e66a3a7a2f8ca09e65bb307871450a7b15c9448852a41dec6fbbb09e926bdd63ec32bcc6f0fb12baa9d30000166ba2d2afd67c69dc3c49c1b67f2c00a15cb03f07a59aaf4d9a67620897603705d634de329a95ebabdc687fb5d41621f11d201ae70fba0af13ef8fad52a45dcc382208478642c3612198e4013f89f419822c1686a09c6a17dddbc35e6b5f420a029a92988bae4792d5798a7aba727b1251852ebc7e48883a5d6170bc6c6d76878b3be1ab6d8c630a4ab7a48016df086a56e3b5fb1c72e366380cd6d831dbfbfe69a470578e77c9e47946fa1e5eebbb2470d686d44d2493c3cbad54b3d478b6bf6a4f6e4920d117f13b621f0436018d727dd5c195abb5343c2030c13606c68bc55ad6c6d981c0ffc526858e9239e3080f11013c3b2c785b433857ff1030041ad02d5ece7793d06d9149536474dde8a4370479fe3d0cc62e1d20f1e1165715d77abba2463483648e0dc04f7a4cda3cc021b8fde2088bd5a80d68b504de94e02ac26a74d431890e7afcc1683a1651beb82af5edf387362300cac61a3a1202e8da019daaf10356dc760bd7be59209d6e8dca6da7e34d72327bff05e8b3fca73bb2da86d98d9fda452caf7d8bfbb8bd0c41d3673e5f51e3de13f1e00fb7ca0c4c07f9f16099dd31e5876bcda0dca3400846508e03e75b50676b8cd0adee37f70c6bd5d1b2fc9a08fc868a12a8571a2eb96f5014f8d55a331bb110a74e98ef9b055015e3203b24a5cf9eff64d46395b7112e46a614eee5db4092560328040c2bda6aecb48bebad830e500e6e3c8cdb56a3a337fac42d4e477a168a4e5da642dd7d86d1f2d64e63e9a5bcf21ae25cfc6bd6c0edeeb6769ab093e26a77df6c40980cebfd67d9b59514f8ccd4714dff7769e92a5e302b3c9ea01b0b1bc4b1f5529327599509e119c421184dde32fbda898bd8eaf0dda8952821a2171518b9e97dfddd652889e9063d99b87a7be00e24e8cbe934ba7c80dd47d8ef4f2a0ea095dc5442f45df0d6d14924a667131203f55cd4c4338ada69a43af9924d34185d8c2e46493ef9187b60c00fc9bfd135dfe902bab31c495b46f23a77f80f3234ef4a9be073b1a9a4b549c7aad37b908be7c9ee9b3de0239274ff67a11de70378d1cede10b8239203f87e85a59d9cfd4d3c9c200db1f22d8178e5595d03b5d92aa39945e2f032687b7852b720abc9a81c02a6fadaa16ce0c6153ac3295d842bbd75dad08affd10511f30044044505ed20704df8f3268e33dff8015a46755a3be119d6162f7d25236a7130bc58aa5d4f8d4c886e1763e795c3378756a1aeeda4656053b862781eeef56854caa35b0f46a7e7d63f3a0775d2d353348b13585fb7abed8a2d58726f011ad5e05fc96c3c9e3c05db482d26a0b87469e062ec72394c7190e0e6ee67a124dee888</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Coding-1</title>
    <link href="https://unit-serow.github.io/2020/03/15/coding-1/"/>
    <id>https://unit-serow.github.io/2020/03/15/coding-1/</id>
    <published>2020-03-15T08:43:22.000Z</published>
    <updated>2020-03-15T08:44:56.956Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>ASCII-1</strong></center><a id="more"></a><h3 id="编码-coding-1"><a href="#编码-coding-1" class="headerlink" title="编码(coding)-1"></a>编码(coding)-1</h3><ul><li>ASCII (American Standard Code for Information Interchange)</li><li>美国信息交换标准代码</li><li>美国标准信息交换代码是由美国国家标准学会 (American National Standard Institute/可简称为ANSI)所制定的标准</li><li>是一种标准的单字节字符编码方案，用于基于文本的数据</li><li>后来它被国际标准化组织 (International Organization for Standardization)，可简称为ISO，定为国际标准，称为ISO 646标准</li><li>适用于所有拉丁文字字母</li><li>ASCII标准表可参考下方文献</li><li>其存在的目的是为统一计算机领域的所有编码规则</li></ul><p><strong>编码</strong></p><ul><li>在计算机中，所有的数据在存储和运算时都要使用二进制数表示(因为计算机用高电平和低电平分别表示1和0)</li><li>例如，像a，b，c，d这样的52个字母(包括大写)以及0，1等数字还有一些常用的符号(例如<code>*</code>，<code>#</code>，<code>@</code>等)在计算机中存储时也要使用二进制数来表示</li><li>而具体用哪些二进制数字表示哪个符号，当然每个人都可以约定自己的一套，即为编码</li></ul><hr><ul><li>ASCII码使用指定的7位或8位的二进制组合来表示128或256种可能的字符</li><li>标准ASCII码也叫基础ASCII码，使用7位二进制数(剩下的1位二进制为0)来表示所有的大写和小写字母，数字0到9，标点符号，以及在美式英语中使用的特殊控制字符</li><li>按照指定的格式与规则给输入输出的信息进行指定的编码，本质就是将计算机内一切的数据和信息转换为二进制代码的不同组合，以便给予机器并让机器执行相应的指令</li></ul><hr><p><strong>ASCII码的基本规律:</strong></p><ul><li><p>0～31及127(共33个)是控制字符或通信专用字符(其余为可显示字符)，如控制符: LF(换行),CR(回车),FF(换页),DEL(删除),BS(退格),BEL(响铃)等</p><blockquote><p>通信专用字符: SOH(文头),EOT(文尾),ACK(确认)等<br>ASCII值为8,9,10和13分别转换为退格，制表，换行和回车字符<br>它们并没有特定的图形显示，但会依不同的应用程序，而对文本显示有不同的影响</p></blockquote></li><li><p>32～126(共95个)是字符(32是空格），其中48～57为0到9十个阿拉伯数字</p></li><li><p>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号，运算符号等</p></li><li><p>同时还要注意，在标准ASCII中，其最高位(b7)用作奇偶校验位</p><blockquote><p>所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分奇校验和偶校验两种<br>奇校验规定: 正确的代码一个字节中1的个数必须是奇数，若非奇数，则在最高位b7添1<br>偶校验规定: 正确的代码一个字节中1的个数必须是偶数，若非偶数，则在最高位b7添1</p></blockquote></li><li><p>后128个称为扩展ASCII码</p><blockquote><p>许多基于x86的系统都支持使用扩展(或”高”)ASCII<br>扩展ASCII码允许将每个字符的第8位用于确定附加的128个特殊符号字符，外来语字母和图形符号</p></blockquote></li></ul><hr><p><strong>涉及概念:</strong></p><ul><li>点阵</li><li>字库</li><li>点阵字库/字模(数据)</li><li>格式问题(UCS-2等)</li><li>码点</li><li>编码</li><li>Little endian/Big endian</li></ul><hr><p><strong>其它的编码系统</strong></p><ul><li>非ASCII编码</li><li>Unicode</li><li>UTF-8</li><li>中文编码</li></ul><hr><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><strong>中文维基</strong></p><ul><li>ASCII<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/ASCII</code></p></blockquote></li><li>分类:字符集<a href="https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/Category:%E5%AD%97%E7%AC%A6%E9%9B%86</code></p></blockquote></li><li>分类: 编码<a href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>字符编码<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81</code></p></blockquote></li><li>晶体结构<a href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">跳转</a><blockquote><p><code>https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%BB%93%E6%9E%84</code></p></blockquote></li></ul><p><strong>百度百科</strong></p><blockquote><p><a href="https://baike.baidu.com/item/ASCII/309296?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/ASCII/309296?fr=aladdin</code><br><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin</code></p></blockquote><p><strong>CSDN</strong></p><blockquote><p><a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E5%8E%9F%E7%90%86/20837166?fr=aladdin" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/exbob/article/details/6532772?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</code><br><a href="https://blog.csdn.net/yuanwofei/article/details/12846331" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/yuanwofei/article/details/12846331</code><br><a href="https://blog.csdn.net/Deft_MKJing/article/details/79460485" target="_blank" rel="noopener">跳转</a>-<code>https://blog.csdn.net/Deft_MKJing/article/details/79460485</code></p></blockquote><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;ASCII-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Coding" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Coding/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>学习</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E5%AD%A6%E4%B9%A0/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-03-14T14:41:41.000Z</published>
    <updated>2020-03-14T14:46:48.594Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>主观-学习</strong></center><a id="more"></a><h3 id="开放性随笔"><a href="#开放性随笔" class="headerlink" title="开放性随笔"></a>开放性随笔</h3><ul><li>所谓的智商来源于学识</li><li>而智慧来源于环境，世界，精力/经验其次是学识</li><li>然而所谓的智商，只不过是给予懒惰者的万千个借口之一而已</li><li>只是强者给予弱者的某一个心里安慰或者是弱者自己寻求的理由而已</li><li>学习不仅要勤奋，还要明志，指向明确，方向稳定</li><li>明确自己的定位，明确自己所能接受的范围，明确自己当前的能力限制</li><li>在步步为营的前提下，去进行逻辑性的累积</li><li>利用绝对的理智去找对方向与指明道路，珍惜时间，时刻行动</li></ul><hr><ul><li>学习的本质只不过就是机械化的练习，记忆，理解与实践</li><li>伴随机械化记忆而形成的是对所学概念或知识的通透性理解</li><li>而学习和练习即为行动</li></ul><hr><ul><li>哲学不是存在于现实的，或称不是存在于现代的<blockquote><p>或称存在于现实间的哲学，对于现代人类最基本的生存，生命与现实存在的保证而言(生存的本能)，没有任何意义和相关性</p></blockquote></li><li>纯粹的哲学家可能早就被饿死了</li><li>任何学识和智慧都要提现和实现在现实层面之上</li><li>最基本的条件是需要保证自己于现实间的实际存在</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;主观-学习&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-14</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E9%9A%8F%E7%AC%94-2020-03-14/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E9%9A%8F%E7%AC%94-2020-03-14/</id>
    <published>2020-03-14T08:01:16.000Z</published>
    <updated>2020-03-16T12:20:59.824Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="d6d6a2999ed2b5806014791837ffd7465230f852ec5d4ebaab6339cf199c34d1">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e7c1bd18033e860c02eae01ececb3cd90765749322ebace55430fcdf86104656899641018d61d7c738eee3315f3be6f5bcda46abf4f67eed4014492852823871d04c14858b500be819800797f0ffd35f33e86e9a02faf22bf82cfa4998da57edc9abd6547de34d4889ce4dffe79deca01b8e7d19961098027ebce9fa9f30321922b5de21615aa2ae48b2b354ff85dcfac34a467874dc0c77e076023051c964ed04e0a28417e0eeebb4d8b2c6ff45a140ac241e61f66bc7f88fc899f01991974a321b5a718e1cc83fd8b3bc746de619290652a9becf6f6a15dee17bb9009cc44155f90959279d4e8418d95e07232a5f76d9cbff17b3a0eb812055cde658353ae85cf192921c5066144493f5aedbee028d67efa32d109bb36b661e059e669b82d4cb2f7e7609ea1eaff6d1650da272b20e31150365be5aebc6a91444d237496da72b14c9b3a74d039ed982fba1564e4b9151451cf28c329939298e79f0fcb976306c0421f65e1ade0aa0fc32a79057f4fbdf78795c4cb9cda5de6d515d630f89c0500c38d84aa0c0bb4f20c9a9f09640ef6bdd1f99c49846b5c2b6dd82e0b23ad34ac68cbad3d40824b61a14c0a73d7b1d45afb5218cd3366217ca4479eb16586f7a547a059d2fa3e571cb8bd7f9285d2198886106e1893a25bf7b40a9ccaa00cf82a9fbcbbcc494f5ac4a8ec66de44f9dd54a2fdf3dbad0975bf90f6ebd9aa72458c80c362ded2941b429ca5c9886b3680169ee73513610e37ded3c07f5090bc6c8d5c89d8bea22382dbadbf7bdb2cdc6f7bdbec4d29243433a12f450d3bd3dc4b8caf3ce76b6249b9b063953add3808846786103b8b46d36ff52e13b15820ed164204b9fff3d2f17d1f696c6d5f6bbe2ed194f3fa6bc5b4ca84409f17b8355829a3e8a3a810aa5a7bf3c98a566f13c152ed4fb254e8d554ec5f0f360946555c306966b7255a00a76044cf602a664ab3853560547c6aeaeeacf2694fab24b796f2575feb56808366fe64894f1f87d5222aca955f97f962d69a237d129769621e059bfe4344b8a916f02978a93d456073f11753ebd0d1945408b8c1858288bf4aafab7a401ed3db9eefca5bd5b15b777050d4783846199934e03ec6720517db4bef0ecb1f802ec95c6a7b6a18acb79a90e62b2bbc3976a8abaccb5d74f93c3b786c5c00fe30aefb0d068ef7e2927ecb1eff7e0aefffd9a186a71c4a059d903965188a260d43c126fd3dc216a3a43db44caed7ab7594042605801c137c7092607eb0e06483a8ebf4c289de5ad3aca59a65e1e017d142f2ac16fedce88c338be7eb8386dae658097a758462d79c12e70d6efdf0ee7095769694fe46a90468cec81bbb9192ab37edd8361311eedecc140b87ccabe5d3ce4809b480776026a4d01d1220ea5a3ac34c9ad8eb3d035e9b08fc21ec98254647fed9c1e375af4d3def8d2d4a12cefea87dc469b1bdb1902f24dbf496e0e4c849ab2960a5c752f4d8a73ee6d74793d4a220716a3c28ada255e652468f3d1801fb0d3ac3ea869748790fa0581e2c784d6a0b24a23487ec4a007516360acf3a28daa251de513786b563b3359d20f1ec6126fa273876eaa235b0b2ae29472ec1448bf779e2418e8fd2128ecfbcc1371308ef32189d843cbd1be887772535790857da9e4ebc1a3dce9ed15d98f5d7247b7529ebdae751ec78e14ecd3a212954c26a8d61f8aca239dd007a2be2db8ac0cdc80a9be8e91c6560045aa2d8435e35fe1b414d26488e18eb3e6b5b4395fff563a265829bc9e1211d10810222c72f543092641455d704f2acf720c84092f98268c0beef25e240addece76a3d71691adef5201104a797b56993251baee23e158521545d2faf5f417b44125e19b8b3d46accca96e100650bd87a7223115b49b01c79a0e15db0d14b2f141d4b728cf5708fbdc4394ea42808d9ebf1ec1c7066a58acffe051e5b3c29a95891fc2aff9ede45d1a6139cf73c2cc9a68db8893122044eb494dfe3514b9ee11efa4f4e11013a66c16f6697961adebeb40648bdf5a4fdec417bf9163a75234e5bf8a9b42a3c02babefea5db0ba5b2f191466d32e7e4ab5e27937799217a78cc448ac541ac0d749532deffc3ef1056537388385ef9f6ae990a676b90347f5cfd1a34563057cb5f6589d0831ae25b7dace6b0b430b036a9f3a232f22615fcfa4c551be41e74b669b673230c93f334367494e28e65fbb640c62c0ab7e397fb635bd79a3c01de83edbad58f97b1e59cccec2d751aac2636004bf17411567a281a4fc8e09ccd9b3ceecd83b6b9273d01fe726c09f6f0487d56f9348fc1d819031c30eb2934f63b515e26164ef8a12513941c8ad9c836b52af580595bdd2c9957185aa32ab8aac9bf9a6fd19d2ac93e68cc66acfa5178fc86db07c9647c50c249b251d01cf8bcc150dd3a4a34940ef8928ab7bd528e687fc0e0354d126d168b6856f0ed2b592d662ff6bf140b778589ad9be5a81f762125ed29c09b62e863648234ec8f7ff30e9c366a40092db26aba448f8a479a198d472710740f1b4b1df3a2ab6c493275d399c4741a1d31eade77e65c2b0728472affcd5e0618ad6477db6cd1f15062c5ce1a4c2aa4ca904ead3b860738c1e2b29f763aeb2b6578b7421b2e68130f54e832f9e96b0b6204d49866730eed03b719883b909fbe0f06a874a90d9613448663039cd193dbe350f50de5a90ace20943b9afcd22ce342bf4c67844ff1f7a7a6cd8553cc1fffe44644fa920c030c3ad2f5e22c86739ae1342702da1c320d9b47bd71af4ca2774f9b015f5fcb632c08f0307892064bd1ee4c3534ae54f6fbb92fb37bb72d732fcec27b65abb6aa46cc83daf689f29ea01523fca6c902ef24af7d1a76c2a15bbc69c6b1d7ff1ae2bd32d79194c07bbeb7db5fff99131e3d876a5fc4cfdd8df35473decd070daac2407a93b8d3b4506871ec47cf8f7a58258f46300104daae5e0f0cf920cd65f5f10f263f64c0f5093c1159ef15b9b25740c82fd1543289eed0c20365a5ce91033d38cbcb9b9211f3e1d0b62a5200f7b743526c798aef1cc80e76e85ff1dce92b2d8f5291d13a97980afb60181a2f4cb8216dad717033d36eee33a0a4ce7147db670895dc5bce0ec2a2bc841764cdc42346b57f4d9c18736af69b9dc132302839a22d860c32850e747845b69606863c648636bc878587009937d8e5ace14fc8bfe6f4401236aaade9e33a83ecb30aa8ee9e9271cbc45f67f632069c94bb947c067fddd9389b06bcfe004bec45e9207b2d3c359749f9cf1ce68de5805bc2abae97e88b364868e94a9a6186404aa9f7cc87f22d0d814b48fb953ad4bacac43f83fb9add41df57406931b89dd6f28b381ee1de31e57d7ecbe06b15abbf1c3bdea008d9b1aaeeb7e89618004025bef857938d877cfe3c1294291c1b586b319bbb9ab302cee0a1e292e104674074a5e700ed5d4fb378c095a08dd346f57b12c73e61ac5ba30cae5d0cc3a60654162f6a1cdb4d39f9b8cadae9b6031a4f8c364a448375fb9a7ed5fda8570d9053c0b1c3fb8574011ce08837a4b92e0fada1093528e3fe1029606f64bb81c0ad321995cf6578cf4776889bc3d9821ca728fbe3ebe4f8fe0c98fa9f6c8587b14636a964b708ffec2b4e13e0cbf79fd08a53128f188a096c5b3a0a7587f6e0cf6985e819e3a5d2f636b0e24e3ba9d031bcc128e8ee4470d7e47093597656fd6037ffd17e857a91b9eae408e330f65c6e02d0b97696a4e1c35b524c823124f2d6e3e03eb6cb35947c33466f2a9b6997f2e879347a2a00032059d1774158cbbc5a31ad87884796369837ead4aa71e27104db350d2f17d2de3ba597b98a174d3b2097ea4d87ed9f9330c170b4409bf53dc3daaf9e0561629c9f4ce674eff08651240d64c310662d29ea4be0c8130a5165361a5e83cc1e6c40743faa53a14f6bc3dd160b1c01be385b8031efe5dfb2bd155be1883cb57ff1574a48d9c162861381e48164529af8dbd76f2677d4fbf578fc83d46e89d402bb2965a8bcd17f48dcfbe5e442134c5617c342de0bcabdd96cf3f0fc1cd401beeb0312912d151469d4bc2362d77806aa2188092fccf965b36fe9f6723e361be063d00370ed72aa675be221c817d89e1f6ef41526e4c79a90f5991bbeaaf04155ab545838d36f7f67ec4bac0400569610cb07019768e67684f8493d2bc82aa1c91f019c534440136345a4961caffb68915036ba49b124bfde72a159f1b72ace04456009f3a19f0b0d6ffb8459f303e5080888ecfb9a687d41b7468c8ce4e4d49826742e44132a18d7d22841d49fc20e69639268af08e082cc4c3d35e2b04fce958465da2a6ad1aa69fd3c700d2de53718483479ddf72e07e0f737ec76b32dcf8835825a9b17bb0e69e9334ce95990e0eac7199c0968dcd497f71a613f7f06caada3b7ee924f315721eb4d49caed338c17ff91938a55eb9462f03030f132981b88bfa811763077d79da52d37098aa740a1e4bd4850231f11b2ffa6553ca3e17f6f5c293d174ffa2cf5ac283c7ea3014df95589fd12a87b325f96d11a450dcbad52a5d5ab2c1d3003212c08dc68a08fff9eabc6cfd9c6add9c24a07253334b58f904670fbb1a09129a51b8337ab6e3c23201aef303ca1d38e211aa2e0058987f55b4d8e6fcf9691265ffe6eaa52ddcbf2402e2b673a1fcdd0c4b4bef0f6d30fb3a797142521c522de1a2ce415e091c05f85f4e98ba7b315a9e49ec5c51627d0967f924ed6d799872465e1b0b4a9d0031d0345c7a637c28e0c385138344e30ea23b5b0cc071dcd167e49f325b35e6a0448e0d9bc0031a7a9693954a6112c2b5b3f8e56625c0de9da2dc4b728024f3708b8402fbf8c2cca16ac636d654abf1119b12e92f32c5b4de307b2f564cfd6105c8a7c5cc7e24a065e64edf0f489b227ca3f1ffaf6696a59fbbcb6cc576973e3972f6d6e902d3b5262dd557f21a71d1867ac428fc3fd4c741be3b5865287b458ddbae5d7e3899ac0735a36410c2205b93acb59c611628dc9833dc06800cece57367e2dbffafd5c8de7382cf8a3c063f0b02867597db5084aa6ec0033b5153b9b3e2402f2740e9f9157392c3cc0061ad06384602e5c52719bdbf09f9cc679040f155517001ac652f46fc6490b5397305b3e5362427b09ff90bae761f93b0900b20f863b1834dc651096890059c529c89526d8e69362e131d73ee26357ce41552e6b0fd15af0927573d696d5c3ab5f7166da04f732473c1cfe7302e704c976c371a0ec32485deb236605852484d07102412ff9ee499b00a9e151748c7026fe60313129df71c2949b76ec903e99baaadbceb25674d57a7308bee0082322ff75815d4fb465af930584df2546d6157bae11e03d32d5a1a5ed9c7a82373dcc5b69368dc6fb2da8f4cf8c6fb78b21b6d770bfb0650eefdfa1b23d7e1f1c0e6592de9694219735c259a7ae7a6578fe6707df768fb43f4e534fb03919637ce49d98371a0f3ae0addfb4edbe0b28960c4034e10ae6b1b9982636d4b527b86c0c48779fecc7e4f3a5816b7df129305bd796d3964fd0458ff722209bc25a6308a7f04d8a62a104dd1b1cc85337916fea7443640291a047f3c5a98266ace00da5cdc968fb9cfecf7824f1e5efcd719e21a8f8b83eb29d363d92f31d9f1f39449f83b52764d5ebe436f3c225bb757363f5d6f45da1022b43e37f23b7a3103d38feb4ed0f4ed7a9fecc8d16214a9418772797b6b1c180ff4e075a8169ae55654aaf8041e3fa8dd46da750d1d7ba62b84ed59612f87e2346aa92200314ae6b978ee235b26a142326c2281dff214e4a69c6e7a5473270e5acff21409fafc16881fd4885dac12cb46c121bae6beb0dece6c2b7b48f18576dd2b08c1a4ea48569fd4aabf64e30e60292c71c671c63693e461d9f4267d507c2cee92768b854b00db18cbd3f42cc3d4d884837313a1e4335c1c4485614d1faf3912a6a27787a21ed9b26bcfab03c4311473116374f8f45892c4820a3711f2ef28b68ea0e5c68d981fc280eb099ff112b71e3bb41a4107755bbfa577a8edec3d4f4cbcc1363aaa41bfb8f9d6534badfb61862f6608a12f68530e79b042926558459a892b8b7ecc29b9cbe993f94b70a806cb2fa4f4f22976aa39ca1cf52f19e0a317017a22607063ae372f989a699cdb547aea5df6918969187cb7d78c479142f6bcf9f757ed8b329b10754cda69406a9a0e4f6b15d2c64446ebafc88323cfd92f95b7296613189a63dbe64be88675a7d58b2aa009c193a898ebf7e73be922201ea18ba9a64a7de959e05efcd01724c1ca745deead261094d40be899eba86bf7000422a350dc63f37f3d9cf8f4447502654852c01dfca5e4dd1da56a604cfc54f739b76870ad6c5a4fc699f7d9edc205ee0e416a7bee69f8827aa75c6900bb77d34e3e607ab363ddc7bb51f20a0c10569f7ad7f8d5c9c1ffb36578b75adb072603846e76e706b951a8d4d0eb6d1dfd57ec4703bef88d8cf635aa3b91f057a2302b9c86f35f3844568bea69ce84aa3497c9d72319583de3b8b2ed7b9058ffd88ac77a8b3c0b48dd326b0a686cafdb13aab124124452fcf2a2f476033c0a782691befd9023e8b3f714f9f379845cbb11636c4bd019ef53a4bc0305947a9964687d309d859c01116719fadfbed62a500ce041a68e5f20d1d61e751772e70ef6ad489000798e43db3b2cc60392f49fa4352ad54fb908dad7e4f22aea69bf64d66cac629605503f95a2804601f3e5ab7e5b817152b7f4c642707f00a9bbe65efa360312b262aab7d7c2ec908db32e4e61155eb84b962b9c8b6ce9d42704e86456137891a1776889bd51a55a1dfbb28fa4b46ee529bd211ee938a0fd77c98769428767bbfb1ecac2958fbd463cbff122a95bc2a6d37e47b733bf32cb66d9b3b84a2a818fcdee7b6ce7c6a9f018ec548baf688c37fd9594b0ac91a1e50d43c8531ee580c46642ddfb1be8bb275f38c4e7b65eee63fe9787320186ce326e21c7442ca86e3e67b3bc1b33bc0688d68fdc85a5ade9939df24f61491c6dbe27c15e3c145f127848ea746a21cf5e0ea99f6a6b8b0c3ff52c1f378b28cb49a4ff6e6c99b5f00acc457441cb364fae88cbd419fea3c9ef67df9926621abaa54fd20af094c354f1aa32728dc5bc9f97833e9e46079f8c80861ab4791d8e711400a6989fd748a961362db091caf2788e68d41e9a9836a79909b8b42dd3456eeb91456edd731769c7d80c6dc28f8dee02166bb7041aac8660131319d266b2a91a2a2bbab5585b39ffd0402dfda0f8d6efe8f4440b7ad1455a3487c2759322ca8d3220b48be770d89193111865562d31ad164f8c25202474e0a67270dd45ae97bd4a24730779bfeed07d6147d3d13cec84061f8357a5d606acffa7002512938408eaf33e139fae011546c465fc657d39174add1da4152e74b44bf48548701e8c86b9e16145a2915e802402db5def51b45888eba32d5337a256269c4c388ae5fc6af68226ffa96f06807a52191c7247a6abe7757c0d6339abb6e479f5bdca1e70973fcdd4c2b344e15eadb6766b93cab35afefa31fa2be9b0a59a804c01c4423b1f5c704d676b513292ba3f9f6e4f87a205590114119c7d3f9ab720c65d7ad49dda7d0d4b9bf62ef76935f93debb63a8ddcddfd91ac3476b388ffe5900610ce78b06a54b006bc3c6689445b8b4fc3b647be5cffcb54db672705aab637b3a979b75aa701e37266cdb8980c2b09d54d4b89a9ab37e0d477f13a7ded50f36e34ceb46c51af6f5a185c48fba822e8d6a6a0f77b38687b51e54220505bd708a80558a588fa2fd76a3041b206fa0808fddaf351735a983b587501cfe51800d001b6a21f27ec2d642a4183090b4409d1dc27b1c8ba07607341a63438247f624b833bb6822cc5cfd6db4e18299ae3cd4516b9fee0beec10b9937d49d0877158bfb009acdfeb4498859029757a04bde37b7c9491f6d5cff66c3b2ff11f26dabebab62607ca127b0c66cedf439d1cb38ae3b0c2551dd732fe2ce7eb57ce59dc116bdc55aa083bb14b38cedff78bb0b9b1f20920a23db1f7a5aa0a8f084cc4d4e4941b47e6e71518f176087e02fd019d7e29bf035007775b207d2fc0833ccd533cdb214109b0f8bbc36d7b38f02ac087cb98d7ae9e51058f5468f136257c199001402ac44cf684884b6aec6d76ed5fc8d99a8f2de6e5450bd305a4ade1079f4f7e0686190629a559dc9ccb034b8e42c2947d9e8332e55a21167a8d56ddb476ab20be3a9d52787e609377c558950c30590f24b597d88a5daf80ff634fafa093fc5b90e045aac8a2f96027468eb384c721155c48e9e671ae6f0e26189ea3c59d6a88935e5e5200a4dab33afb41c5894b912481fc64e749a97dba0134eb3917078b440240772e0ecad9ced634476ea62b7adc3fdd8e36b3596f4e28daacc0f9d1499cb4338a263ccabb6aa78d6e1d9862a6ac31b34c10db3f02fbedfb3ec24907f8742b7efa826a3ef2fe9ffa7c9e790633d89609be3e43c07e61cc6333ecb8f16740714e4406bc49945489adcff2fc650a32cef271e938d417c7944c1a60fdf5890b7f9b6bb1ffdd29d9dcbd2efd9a206482002fcf7ecb27f8a140be3fb98dd3cd218b0d9eb9bc3d6bcb76f56d55b463b4b96669a7fdb0e7f707381a2e8f3e8106499bbdea8d6979cce9ba9a4fda0779ffbb17cb2074d8804b121bdb5681b9fce23d82afbc17d30a04faba584e8aa3dc64b96d2eb47a7e4e687e68e3a5de81504e5b07def923b63d38ed1fd537bfba17d0c99225085c66a79996695b0e28d94a40437f72fa18b1b796ed9b6cb9967464a57070ec48f75c939688fe2e88a38a80e423fc983915710db19f4f76adaadbc185a9cedb89f734c3d7fabd30db37ec51da9912ac0b60c1676bd650e4bacb28d08c1bf95a096acb64f71b05701270f22fe1377b8e1614648e507128bc8b4d0e812a46d6d35ae8cb8dcc10c53b80fc8ede09473fe62be9723bd5eb61d09f9cb944c0346edf31ef743c7b3da53c3e34ad217a1430fcdbd3ca85843ab92a06c1cce9a5d95ed2eb09f79994dadd5dc52ace2e894b761f09e5b7e2feba75bfefd82deee1ca69838ffc6cb217c73b6e6b14b91d9c4cb373a67191b3935645c5953783af1027789686d0b48842a773a24c4c8fe590118e626157be3214ed211e47271785132dc9de500860f8b6008f087fbe75647000c2bef330516ba6dc9ac50f535266b012ba863b4325fb6f575c0da8640e69c35f9c3a038e50eafbd04d7c91456626c9d727899fdeb85ce2fb40f2c8673576722c37709d4abedb9e7e28b6cc6cd3beae9d42a382483c7e1a8b009acc5d99fcbf804413859ec535f80792d76e515c01996acd1af1c829276ec8270f2bde5cec8a272d704e3ef0b6f46be3a93a60169d8bf07bf53c06699a58cb38221c59cf460535435560c2148be12a2aeca8071bfa1457d563e913a41ea28e5a7ceab2330b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-7</title>
    <link href="https://unit-serow.github.io/2020/03/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7/"/>
    <id>https://unit-serow.github.io/2020/03/14/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-7/</id>
    <published>2020-03-14T03:55:04.000Z</published>
    <updated>2020-03-16T17:21:04.634Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-3</strong></center><a id="more"></a><h3 id="数据类型-7"><a href="#数据类型-7" class="headerlink" title="数据类型-7"></a>数据类型-7</h3><ul><li><p>条件选择语句(控制语句)</p><blockquote><p>if，if…else，else…if，switch，switch…break，switch…if…else语句<br>continue…break<br>goto</p></blockquote></li><li><p>头文件及函数</p><blockquote><p>ctype.h，iso646.h<br>getchar()，putchar()</p></blockquote></li><li><p>其它概念</p></li></ul><hr><p><strong>涉及内容:</strong></p><ul><li>条件选择语句-if/if…else</li><li>getchar()与putchar()方法</li><li>ctype.h头文件/iso646.h头文件</li><li>多重选择语句-else…if</li><li>选择语句配对规则</li><li>逻辑运算符及其优先级，求值顺序与范围</li><li>条件运算符-?:</li><li>循环辅助: continue语句和break语句</li><li>多重选择: switch语句和break语句</li><li>多重标签: switch语句和if…else语句</li><li>跳转标识符: goto</li><li>其它内容(补充内容/关键概念梳理/文章内涉及概念总结)</li><li>有可能会在数据结构-8内进行补充</li></ul><hr><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><ul><li><p>IF语句</p></li><li><p>if语句被称为分支语句(branching statement)或选择语句(selection statement)</p><blockquote><p>因为它相当于一个交叉点，程序要在两条分支中选择一条执行</p></blockquote></li><li><p>if语句的通用形式如下:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if ( <span class="name">expression</span> )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>如果对expression求值为真(非0)，则执行statement</p><blockquote><p>否则，跳过statement</p></blockquote></li><li><p>与while循环一样，statement可以是一条简单语句或复合语句</p></li><li><p>if语句的结构和while语句很相似</p><blockquote><p>它们的主要区别是: 如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次</p></blockquote></li><li><p>通常，expression是关系表达式</p><blockquote><p>即比较两个量的大小(如，表达式 x &gt; y 或 c == 6)<br>如果expression为真(即x大于y，或c == 6)，则执行statement<br>否则，忽略statement</p></blockquote></li><li><p>概括地说，可以使用任意表达式，表达式的值为0则为假</p></li><li><p>statement部分可以是一条简单语句或者是一条用花括号括起来的复合语句(或块)</p></li></ul><hr><h3 id="IF…ELSE"><a href="#IF…ELSE" class="headerlink" title="IF…ELSE"></a>IF…ELSE</h3><ul><li><p>简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句</p></li><li><p>C 还提供了if else形式，可以在两条语句之间作选择</p></li><li><p>if else语句的通用形式是：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">( expression )</span></span><br><span class="line">   stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">   stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure></li><li><p>如果expression为真(非0)，则执行statement1</p><blockquote><p>如果expression为假或 0，则执行else后面的statement2<br>statement1和statement2可以是一条简单语句或复合语句<br>C并不要求一定要缩进，但这是标准风格<br>缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然</p></blockquote></li><li><p>如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块</p><blockquote><p>下面的代码结构违反了C语法，因为在if和else之间只允许有一 条语句(简单语句或复合语句):</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line"><span class="keyword">else</span>　　　<span class="comment">// 将产生一个错误</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句</p><blockquote><p>它不是if语句的一部分<br>然后，编译器发现else并没有所属的if，这是错误的</p></blockquote></li><li><p>上面的代码应该这样写:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Incrementing x:\n"</span>);</span><br><span class="line">   x++;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"x &lt;= 0 \n"</span>);</span><br></pre></td></tr></table></figure></li><li><p>if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择</p></li><li><p>if语句和if else语句的执行逻辑示意图</p></li></ul><img src="/images/数据类型-7/IF语句1.png" width="30%" height="30%"> <img src="/images/数据类型-7/IF...ELSE语句-1.png" width="30%" height="30%"><hr><p><strong>未完成</strong></p><hr><h3 id="getchar-putchar"><a href="#getchar-putchar" class="headerlink" title="getchar()/putchar()"></a>getchar()/putchar()</h3><ul><li>字符输入/输出函数getchar()和putchar()<blockquote><p>同样可用作输入/输出的函数还有scanf()和printf()根据%c转换说明来进行对字符的读写</p></blockquote></li></ul><p><strong>getchar()</strong></p><ul><li><p>getchar()函数不带任何参数，它从输入队列中返回下一个字符</p><blockquote><p>例如: ch=getchar();，它与scanf(“%c”, &amp;ch);的作用相同</p></blockquote></li><li><p>putchar()函数用于打印它的参数</p><blockquote><p>例如: putchar(ch);，该语句用于将之前赋给ch的值作为字符打印出来<br>该语句与printf(“%c”, ch);相同</p></blockquote></li><li><p>由于这些函数只用于处理字符，所以它们比通用的scanf()和printf()函数更快，更简介</p><blockquote><p>而且还有一点，getchar()和putchar()函数不需要进行转换说明，因为它们只处理字符<br>这两个函数通常定义在stdio.h头文件中(而且它们通常是预处理宏，而不是真正在宏观意义上的函数，这里先不对类似于宏的函数进行深入赘述)</p></blockquote></li><li><p>语句putchar(ch + 1);</p><blockquote><p>表示了字符实际上是作为整数而存储于内存之中的<br>为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()<br>该函数只根据最后一个字节确定显示哪个字符</p></blockquote></li></ul><hr><h3 id="ctype-h系列的字符函数"><a href="#ctype-h系列的字符函数" class="headerlink" title="ctype.h系列的字符函数"></a>ctype.h系列的字符函数</h3><ul><li><p>斜杠字符对应的ASCII码比点号的ASCII码多1</p><blockquote><p>如果程序 只转换字母，保留所有的非字母字符(不只是空格)会更好</p></blockquote></li><li><p>C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型</p><blockquote><p>这些函数接受一个字符作为参数，如果该字符属于某特殊的类 别，就返回一个非零值(真)<br>否则，返回0(假)<br>例如，如果isalpha()函数的参数是一个字母，则返回一个非零值</p></blockquote></li><li><p>有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具(例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为 123,45)</p><blockquote><p>注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值</p></blockquote></li><li><p>ctype.h头文件中的字符测试函数列表和头文件中的字符映射函数这里不做赘述</p></li></ul><hr><p><strong>多重选择else…if</strong></p><ul><li>else if 是 if else 语句的变式</li><li>else部分包含另一个if else语 句，该if else语句的else部分又包含另一个if else语句<blockquote><p>第2个if else语句嵌套 在第 1个if else语句中<br>第3个if else语句嵌套在第2个if else语句中</p></blockquote></li><li>对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌</li></ul><hr><p><strong>else…if的配对机制</strong></p><ul><li>规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来</li></ul><p><strong>图片说明:</strong></p><ul><li>if else匹配的规则:</li></ul><img src="/images/数据类型-7/if else匹配的规则-1.png" width="40%" height="40%"> <img src="/images/数据类型-7/if else匹配的规则-2.png" width="40%" height="40%"><ul><li>注意: 要缩进”语句”，”语句”可以是一条简单语句或复合语句</li></ul><hr><p><strong>多层嵌套的if语句</strong></p><ul><li>if…else if…else序列是嵌套if的一种形式，从一系列选项中选 择一个执行<blockquote><p>有时，选择一个特定选项后又引出其他选择，这种情况可以使 用另一种嵌套if</p></blockquote></li></ul><hr><ul><li><p>小结：用if语句进行选择</p><blockquote><p>关键字：if，else</p></blockquote></li><li><p>一般注解:</p><blockquote><p>下面各形式中，statement可以是一条简单语句或复合语句<br>表达式为真说明其值是非零值</p></blockquote></li><li><p>形式1:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，则执行statement部分</p></blockquote></li><li><p>形式2：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure><blockquote><p>如果expression为真，执行statement1部分<br>否则，执行statement2部分</p></blockquote></li><li><p>形式3:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(expression1)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else <span class="keyword">if</span> <span class="comment">(expression2)</span></span><br><span class="line">stateme<span class="symbol">nt2</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt3</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>如果expression1为真，执行statement1部分<br>如果expression2为真，执行 statement2部分<br>否则，执行statement3部分</p></blockquote><ul><li>示例:</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (legs == <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It might be a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (legs &gt; <span class="number">4</span>)</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"It is not a horse.\n"</span>);</span><br><span class="line"><span class="keyword">else</span>　　 <span class="comment">// 如果legs &lt; 4 </span></span><br><span class="line">&#123;</span><br><span class="line">   legs++;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"Now it has one more leg.\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><p>if语句和while语句通常使用关系表达式作为测试条件</p><blockquote><p>有时则需要将多个关系表示组合起来用，此时则需要使用逻辑运算符，并使用点符号<code>&#39;.&#39;</code>来标识句子的末尾</p></blockquote></li><li><p>逻辑运算符两侧的条件必须都为真，整个表达式才为真</p><blockquote><p>逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号</p></blockquote></li><li><p>C 内有三种逻辑运算符，如下表图片:</p></li><li><p>三种逻辑运算符:</p></li></ul><img src="/images/数据类型-7补充图片/三种逻辑运算符-1.png" width="40%" height="40%"><hr><ul><li>举例说明:</li><li>假设exp1和exp2是两个简单的关系表达式(如car &gt; rat或debt == 1000)<blockquote><p>那么:<br>当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真<br>如果exp1或exp2为真，则exp1 || exp2为真<br>如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假</p></blockquote></li></ul><hr><p><strong>iso646.h头文件</strong></p><ul><li><p>C 是在美国用标准美式键盘开发的语言，但在世界各地，并非所有键盘都有和美式键盘一样的符号</p><blockquote><p>因此，C99标准增加了可代替逻辑运算符的拼写，并且将其定义于iso646.h头文件中<br>如果在程序中包含该头文件，便 可用and代替&amp;&amp;、or代替||、not代替!</p></blockquote></li><li><p>逻辑运算符对应的拼写如下表图片:</p></li><li><p>逻辑运算符的备选拼写:</p></li></ul><img src="/images/数据类型-7补充图片/逻辑运算符的备选拼写-1.png" width="40%" height="40%"><ul><li><p>在新增的C99和C11的标准ANSI C库内列出了一些其它运算符的备选拼写</p></li><li><p>!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低</p></li><li><p>&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高</p><blockquote><p>因此，表达式a &gt; b &amp;&amp; b &gt; c || b &gt; d相当于((a &gt; b) &amp;&amp; (b &gt; c)) || (b &gt; d)<br>也就是说，b介于a和c之间，或者b大于d<br>尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第2种写法<br>这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚</p></blockquote></li></ul><hr><p><strong>有关求值顺序</strong></p><ul><li><p>除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值</p></li><li><p>例如下面的语句，可能先对表达式5+3求值，也可能先对表达式9+6求值:</p><blockquote><p><code>apples = (5 + 3) * (9 + 6);</code></p></blockquote></li><li><p>C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计</p><blockquote><p>但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右<br>&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效<br>而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值<br>正是由于有这些规定，才能写出这样结构的代码:<br><code>while ((c = getchar()) != &#39; &#39; &amp;&amp; c != &#39;\n&#39;)</code><br>如上代码所示，读取字符直至遇到第1个空格或换行符<br>第1 个子表达 式把读取的值赋给c，后面的子表达式会用到c的值<br>如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值</p></blockquote></li><li><p>这里还有一个例子:</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">number</span> != <span class="number">0</span> <span class="symbol">&amp;&amp;</span> <span class="number">12</span>/number == <span class="number">2</span>)</span><br><span class="line">printf(<span class="string">"The number is 5 or 6.\n"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值<br>这样避免了把0作为除数<br>许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件</p></blockquote></li><li><p>最后，考虑这个例子：</p><blockquote><p><code>while ( x++ &lt; 10 &amp;&amp; x + y &lt; 20)</code><br>实际上，&amp;&amp;是一个序列点，这保证了在对&amp;&amp;右侧的表达式求值之前已经递增了x</p></blockquote></li></ul><hr><p><strong>内容简述:</strong></p><ul><li><p>逻辑表达式:</p><blockquote><p>当且仅当expression1和expression2都为真，expression1 &amp;&amp; expression2才为真<br>如果 expression1 或 expression2 为真，expression1 || expression2 为 真<br>如果expression为假，!expression则为真，反之亦然</p></blockquote></li><li><p>求值顺序:</p></li><li><p>逻辑表达式的求值顺序是从左往右</p><blockquote><p>一旦发现有使整个表达式为假的因 素，立即停止求值</p></blockquote></li><li><p>示例：</p><blockquote><p><code>6 &gt; 2 &amp;&amp; 3 == 3</code> 真<br><code>!(6 &gt; 2 &amp;&amp; 3 == 3)</code> 假<br><code>x != 0 &amp;&amp; (20 / x) &lt; 5</code> 只有当x不等于0时，才会对第2个表达式求值</p></blockquote></li><li><p>有关范围问题:</p><blockquote><p>&amp;&amp;运算符与islower()函数可用于测试范围</p></blockquote></li></ul><hr><h3 id="条件运算符-三元运算符"><a href="#条件运算符-三元运算符" class="headerlink" title="条件运算符/三元运算符"></a>条件运算符/三元运算符</h3><ul><li><p>C 提供条件表达式(conditional expression)作为表达if else语句的一种便捷方式</p></li><li><p>该表达式使用<code>? :</code>条件运算符</p><blockquote><p>该运算符分为两部分，需要三个运算对象<br>带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符<br>以此类推，带三个运算对象的运算符称为三元运算符<br>条件运算符是 C 中唯一的三元运算符</p></blockquote></li><li><p>条件表达式的通用形式如下:</p><blockquote><p><code>expression1 ? expression2 : expression3</code><br>如果 expression1 为真(非 0)，那么整个条件表达式的值与 expression2 的值相同<br>如果expression1为假(0)，那么整个条件表达式的值与 expression3的值相同</p></blockquote></li><li><p>需要把两个值中的一个赋给变量时，就可以用条件表达式</p><blockquote><p>典型的例子是，把两个值中的最大值赋给变量:<br><code>max = (a &gt; b) ? a : b;</code><br>如果a大于b，那么将max设置为a<br>否则，设置为b<br>通常，条件运算符完成的任务用 if else 语句也可以完成<br>但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码</p></blockquote></li></ul><hr><h3 id="循环辅助-continue-amp-break"><a href="#循环辅助-continue-amp-break" class="headerlink" title="循环辅助-continue&amp;break"></a>循环辅助-continue&amp;break</h3><ul><li>一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句</li><li>而continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环</li></ul><p><strong>continue语句</strong></p><ul><li><p>3种循环都可以使用continue语句</p><blockquote><p>执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代<br>如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环</p></blockquote></li><li><p>有两种方法可以避免使用continue</p><blockquote><p>一是省略continue，即为把剩余部分放在一个else块中<br>这种情况下，使用continue的好处是减少主语句组中的一级缩进<br>当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性<br>另一种方式是把if的测试条件的关系反过来便可避免使用continue<br>需要根据程序的实际情况而定</p></blockquote></li><li><p>continue还可用作占位符</p><blockquote><p>例如将循环读取并丢弃输入的数据， 直至读到行末尾<br>当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便<br>问题是，一般很难注意到一个单独的分号<br>如果使用continue，可读性会更高<br>如果用了continue没有简化代码反而让代码更复杂，就不要使用continue</p></blockquote></li><li><p>从何处开始继续循环:</p><blockquote><p>以上介绍了continue语句让程序跳过循环体的余下部分<br>对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值</p></blockquote></li></ul><p><strong>break语句</strong></p><ul><li><p>程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段</p><blockquote><p>但如果break语句位于嵌套循环内，它只会影响包含它的当前循环</p></blockquote></li><li><p>以下两张图片比较了break和continue</p></li></ul><img src="/images/数据类型-7补充图片/break和continue-1.png" width="40%" height="40%"> <img src="/images/数据类型-7补充图片/break和continue-2.png" width="40%" height="40%"><ul><li>break还可用于因其他原因退出循环的情况</li><li>和continue一样，如果用了break代码反而更复杂，就不要使用break</li><li>break语句对于稍后讨论的switch语句而言至关重要<blockquote><p>在for循环中的break和continue的情况不同<br>执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过<br>嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break</p></blockquote></li></ul><hr><h3 id="多重选择"><a href="#多重选择" class="headerlink" title="多重选择"></a>多重选择</h3><ul><li>使用条件运算符和 if else 语句很容易编写二选一的程序<blockquote><p>然而，有时程序需要在多个选项中进行选择<br>可以用if else if…else来完成<br>但是大多数情况下使用switch语句更方便</p></blockquote></li></ul><p><strong>switch的工作原理分析</strong></p><ul><li><p>要对紧跟在关键字 switch 后圆括号中的表达式求值</p><blockquote><p>break语句让程序离开switch语句，跳至switch语 句后面的下一条语句<br>如果没有break语句，就会从匹配标签开始执行到switch末尾</p></blockquote></li><li><p>break语句可用于循环和switch语句中，但是continue只能用于循环中</p><blockquote><p>尽管如此，如果switch语句在一个循环中，continue便可作为 switch语句的一部分<br>这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分</p></blockquote></li><li><p>switch语句和Pascal的case语句类似</p><blockquote><p>它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句<br>另外，C 的case一般都指定一个值，不能使用一个范围</p></blockquote></li><li><p>switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)</p></li><li><p>case标签必须是整数类型(包括char类型)的常量或整型常量表达式(即表达式中只包含整型常量)</p><blockquote><p>不能用变量作为case标签</p></blockquote></li><li><p>switch的构造如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch ( 整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句&lt;--可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句&lt;--可选</span><br><span class="line">default :&lt;--可选</span><br><span class="line">语句&lt;--可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于程序只读每行的首字符的情况这里不做多余赘述</p></li></ul><hr><p><strong>有关多重标签</strong></p><ul><li>可以在switch语句中使用多重case标签</li><li>如果使用ctype.h系列的toupper()函数可以避免 使用多重标签</li></ul><hr><p><strong>有关switch和if else</strong></p><ul><li>关于何时使用switch与何时使用if else<blockquote><p>如果是根据浮 点类型的变量或表达式来选择，就无法使用 switch<br>如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦<br>这种情况用if就很方便:<br><code>if (integer &lt; 1000 &amp;&amp; integer &gt; 2)</code></p></blockquote></li><li>使用switch要涵盖以上范围，需要为每个整数(3～999)设置case标签<blockquote><p>但是，如果使用switch，程序通常运行快一些，生成的代码少一些</p></blockquote></li></ul><hr><h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><ul><li><p>早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用</p><blockquote><p>但 是C和其他两种语言不同，没有goto语句C程序也能运行良好<br>Kernighan和 Ritchie提到goto语句”易被滥用”，并建议”谨慎使用，或者根本不用”</p></blockquote></li><li><p>goto语句有两部分: goto和标签名</p></li><li><p>标签的命名遵循变量命名规则如下所示:</p><blockquote><p><code>goto part2;</code></p></blockquote></li><li><p>要让这条语句正常工作，函数还必须包含另一条标为part2的语句</p><blockquote><p>该语句以标签名后紧跟一个冒号开始:<br><code>part2: printf(&quot;Refined analysis:\n&quot;);</code></p></blockquote></li></ul><p><strong>避免使用goto</strong></p><ul><li><p>原则上，根本不用在C程序中使用goto语句</p><blockquote><p>但在FORTRAN或BASIC内，goto对这两种语言而言都必不可少，而且还会依赖用goto来编程<br>对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if<br>不能使用块或复合语句</p></blockquote></li><li><p>跳转至循环末尾，并开始下一轮迭代</p><blockquote><p>C使用continue语句代替跳出循环</p></blockquote></li><li><p>C使用break语句</p><blockquote><p>实际上，break和continue是goto的特殊形式<br>使用break和continue的好处是: 其名称已经表明它们的用法，而且这些语句不使用标签<br>所以不用担心把标签放错位置导致的危险<br>胡乱跳转至程序的不同部分</p></blockquote></li><li><p>但是，C程序员可以接受一种goto的用法: 出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)</p></li><li><p>不去使用goto的多个理由:</p><blockquote><p>程序中使用其他形式比使用goto的条理更清晰<br>当多种情况混在一起时，这种差异更加明显<br>哪些goto语句可以帮助if 语句? 哪些可以模仿if else? 哪些控制循环?<br>哪些是因为程序无路可走才不得已放在那里?<br>过度地使用goto语句，会让程序错综复杂<br>如果不熟悉goto语句，就不要使用它<br>如果已经习惯使用goto语句，试着改掉这个毛病<br>讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用<br>因为 C允许在标签中使用描述性的单词而不是数字</p></blockquote></li></ul><hr><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><ul><li><p>CN/PDF-C Primer Plus【第6版】</p><blockquote><p>[美] Stephen Prata | 著/姜佑 | 译<br>截止至原书第七章末尾-496页(一共1635页)<br>C 控制语句: 分支和跳转-7.10/7.12</p></blockquote></li><li><p>数据类型-1~数据类型-7</p><blockquote><p>C11/ANSI C/ISO C</p></blockquote></li></ul><hr><ul><li>接下来的内容会以 C 冠名</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-3&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-6</title>
    <link href="https://unit-serow.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6/"/>
    <id>https://unit-serow.github.io/2020/03/13/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-6/</id>
    <published>2020-03-13T05:13:26.000Z</published>
    <updated>2020-03-13T05:15:52.575Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-2</strong></center><a id="more"></a><h2 id="数据类型-6"><a href="#数据类型-6" class="headerlink" title="数据类型-6"></a>数据类型-6</h2><ul><li>循环结构内容补充(控制结构)<blockquote><p>for循环<br>do while循环<br>数组与循环<br>函数与循环<br>其它赋值运算符</p></blockquote></li></ul><hr><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ul><li><p>for循环将循环语句最基本的三种行为(初始化，测试和更新)组合在一处</p><blockquote><p>其基本的语法格式为: <code>for (xxx;xxx;xxx){}</code></p></blockquote></li><li><p>关键字for后面的圆括号中的若干个表达式用分号相隔，一般在圆括号中会有至少三个表达式</p></li><li><p>即为初始化表达式，测试条件表达式，更新执行表达式</p><blockquote><p>还可将其称之为包含了循环所需的所有信息: 所选变量的初值，所选变量的终值，所选变量的循环条件(条件表达式或为自增或自减)</p></blockquote></li><li><p>在花括号内可以添加简单语句和复合语句</p></li><li><p>测试表达式的值为真时则继续循环，为假时则停止循环，其它关于的循环基本概念在<a href="http://unit-serow.com/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/#more" target="_blank" rel="noopener">数据类型-5</a>内有详细介绍</p></li><li><p>还可以将for语句圆括号内的表达式称之为控制表达式，它们都是完整的表达式，所以每个表达式的副作用(例如递增变量之类的)都发生在对下一个表达式求值之前</p></li></ul><p><strong>for循环的结构图示</strong></p><ul><li>for循环的结构:</li></ul><img src="/images/数据结构-6/for循环的结构-1.png" width="40%" height="40%"><hr><p><strong>利用C 内 for的灵活性</strong></p><ul><li><p>虽然for循环看上去和FORTRAN的DO循环，Pascal的FOR循环，ASIC 的FOR…NEXT循环类似</p><blockquote><p>但是for循环比这些循环灵活<br>这些灵活性源于如何使用for循环中的3个表达式<br>即为: 1-初始值(变量经由初始化得到的值)，2-条件表达式，3-返回类型所需要执行的某种方法(或称其为每次迭代需要执行的条件)<br>第3个表达式可以使用任意合法的表达式<br>无论是什么表达式，每次迭代都会更新该表达式的值<br>for循环中的3个表达式可以是不同的变量(注意，虽然该例可以正常运行，但是编程风格不太好，如果不在更新部分加入代数计算，程序会更加清楚)<br>可以省略一个或多个表达式(但是不能省略分号)，只要在循环中包含能结束循环的语句即可<br>这句话的意思就是，可以不在圆括号内写条件的表达式，而在for()代码行下对for语句进行说明，此时被进行说明的语句必须带有结束表示分号<br>有没有花括号无所谓，添加花括号的理由是为了让代码更整洁且直观<br>这样使用for循环确实很像其他语言的循环<br>除此之外，C 的for循环还有其他9种用法</p></blockquote></li><li><p>需要注意的要点-1: 在执行循环的其他部分之前，只对第一个表达式求值一次或执行一次</p></li><li><p>同时对于循环体中的行为可以改变循环头中的表达式，此时需要用到if语句与选择语句的概念，即为在for语句中添加复合语句，该复合语句用于执行if等条件选择语句，也可称该复合语句为代码块</p></li><li><p>for语句的一般形式</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( initialize; test; <span class="keyword">update</span> )</span><br><span class="line"><span class="keyword">statement</span></span><br></pre></td></tr></table></figure><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例语句:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (<span class="built_in">n</span> = <span class="number">0</span>; <span class="built_in">n</span> &lt; <span class="number">10</span> ; <span class="built_in">n</span>++)</span><br><span class="line">printf(<span class="string">" %d %d\n"</span>, <span class="built_in">n</span>, <span class="number">2</span> * <span class="built_in">n</span> + <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="其它赋值运算符"><a href="#其它赋值运算符" class="headerlink" title="其它赋值运算符"></a>其它赋值运算符</h2><ul><li><p>包括<code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>%=</code></p></li><li><p>C有许多赋值运算符</p><blockquote><p>最基本，最常用的是=，它把右侧表达式的值赋给左侧的变量<br>其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式<br>赋给变量的新值是根据右侧表达式的值调整后的值<br>而确切的调整方案取决于具体的运算符</p></blockquote></li><li><p>例如:</p><blockquote><p><code>scores += 20</code> 与 <code>scores = scores + 20</code> 相同<br><code>dimes -= 2</code> 与 <code>dimes = dimes - 2</code> 相同<br><code>bunnies *= 2</code> 与 <code>bunnies = bunnies * 2</code> 相同<br><code>time /= 2.73</code> 与 <code>time = time / 2.73</code> 相同<br><code>reduce %= 3</code> 与 <code>reduce = reduce % 3</code> 相同</p></blockquote></li><li><p>上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式</p></li><li><p>例如：</p><blockquote><p><code>x *= 3 * y + 12 与 x = x * (3 * y + 12)</code> 相同</p></blockquote></li><li><p>以上提到的赋值运算符与<code>=</code>的优先级相同，即比<code>+</code>或<code>*</code>优先级低</p><blockquote><p>上面最后一个例子也反映了赋值运算符的优先级，<code>3 * y</code>先与<code>12</code>相加，再把计算结果与<code>x</code>相乘，最后再把乘积赋给x<br>并非一定要使用这些组合形式的赋值运算符<br>但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效<br>当需要在<code>for</code>循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用</p></blockquote></li><li><p>通常在for的循环头内就能完成大量的工作</p></li></ul><hr><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><ul><li><p>逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式</p></li><li><p>基本使用语法:</p><blockquote><p><code>for (ounces = 1, cost = FIRST_OZ; ounces &lt;= 16; counces++,cost += NEXT_OZ)</code><br>这里的<code>FIRST_OZ</code>和<code>NEXT_OZ</code>是常量数据类型，<code>NEXT_O</code>的值是20<br>在初始化表达式中使用了逗号来对ounces和cost都进行了初始化<br>同时也在更新表达式中使用逗号来表示每次执行迭代时ounces递增1与cost递增20(因为<code>NEXT_Z</code>的值是20)</p></blockquote></li><li><p>逗号运算符的作用就是在同一个表达式区块内进行多组条件的声明</p><blockquote><p>比如在初始化表达式区块中，同时对两个变量进行初始化，或者在更新表达式中声明两个不同的变量在迭代时使用的规则与条件</p></blockquote></li><li><p>逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方</p><blockquote><p>逗号运算符有两个其他性质<br>首先，它保证了被它分隔的表达式从左往右求值(换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生)<br>因此，ounces在cost之前被初始化<br>在该例中， 顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要<br>例如，假设有下面的表达式:<br><code>ounces++, cost = ounces * FIRST_OZ</code><br>在该表达式中，先递增ounce，然后在第2个子表达式中使用ounce的新值<br>作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生</p></blockquote></li><li><p>其次，整个逗号表达式的值是右侧项的值</p></li></ul><p><strong>图解说明逗号表达式的执行逻辑</strong></p><ul><li>逗号运算符和for循环:</li></ul><img src="/images/数据结构-6/逗号运算符和for循环-1.png" width="40%" height="40%"><ul><li>在进行复杂的计算之前，可以先看看数学上是否有简单的方法可用</li></ul><hr><h3 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h3><ul><li><p>出口条件循环</p></li><li><p>while循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所有有可能根本不执行循环体中的内容</p></li><li><p>C 中的出口条件循环(exit-condition loop)的作用是在循环的每次迭代后检查测试条件，以保证至少执行循环体中的内容以此，这种循环被称为do while循环</p></li><li><p>do while循环的通用形式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">statement</span></span><br><span class="line"><span class="keyword">while</span> ( expression );</span><br></pre></td></tr></table></figure></li><li><p>在test为假或0之前，重复执行statement部分</p></li><li><p>示例程序:</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">scanf(<span class="string">"%d"</span>,　&amp;<span class="built_in">number</span>)<span class="comment">;</span></span><br><span class="line"><span class="keyword">while</span>　(<span class="built_in">number</span>　!=　<span class="number">20</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>statement可以是一条简单语句或复合语句</p><blockquote><p>注意，do while循环以分号结尾<br>do while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次<br>而for循环或while循环都是在执行循环体之前先执行测试条件<br>dowhile循环适用于那些至少要迭代一次的循环<br>例如，对用户输入的密码进行测试的程序</p></blockquote></li><li><p>do while循环的结构示意图:</p></li></ul><img src="/images/数据类型-6/do while循环结构-1.png" width="40%" height="40%"><ul><li>其它注解:</li><li>do while语句创建一个循环，在expression为假或0之前重复执行循环体中的内容<blockquote><p>do while语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环<br>因此，该循环至少必须执行一次<br>statement部分可是一条简单语句或复合语句</p></blockquote></li></ul><hr><h3 id="关于对循环的选择"><a href="#关于对循环的选择" class="headerlink" title="关于对循环的选择"></a>关于对循环的选择</h3><ul><li><p>首选需要确定是需要入口条件循环还是出口条件循环</p></li><li><p>通常，入口条件循环用的比较多</p></li><li><p>有几个原因:</p><blockquote><p>其一，一般原则是在执行循环之前测试条件比较好<br>其二，测试放在循环的开头，程序的可读性更高<br>另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环<br>那么，假设需要一个入口条件循环，用for循环还是while循环取决于个人喜好，因为二者皆可</p></blockquote></li><li><p>要让for循环看起来像while循环，可以省略第1个和第3个表达式</p><blockquote><p><code>for ( ; test ; )</code>与此的while效果相同: <code>while ( test )</code></p></blockquote></li><li><p>要让while循环看起来像for循环，可以在while循环的前面初始化变量， 并在while循环体中包含更新语句</p></li><li><p>例如:</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化;</span><br><span class="line"><span class="keyword">while</span> ( 测试 )</span><br><span class="line">&#123;</span><br><span class="line">其他语句</span><br><span class="line">更新语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与下面的for循环效果相同:</p><blockquote><p><code>for ( 初始化 ;测试 ; 更新 )</code></p></blockquote></li></ul><p><strong>其他语句:</strong></p><ul><li>一般而言，当循环涉及初始化和更新变量时，用for循环比较合适<blockquote><p>而在其他情况下用while循环更好</p></blockquote></li><li>对于下面这种条件，用while循环就很合 适：<blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1)</code></p></blockquote></li><li>对于涉及索引计数的循环，用for循环更适合</li><li>例如:<blockquote><p><code>for (count = 1; count &lt;= 100; count++)</code></p></blockquote></li></ul><hr><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><ul><li><p>嵌套循环(nested loop)指在一个循环内包含另一个循环</p><blockquote><p>嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行</p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROWS 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHARS 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> row;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="keyword">for</span> (row=<span class="number">0</span>;row&lt;ROWS;row++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (ch=<span class="string">'A'</span>;ch&lt;(<span class="string">'A'</span>+CHARS);ch++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, ch);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br><span class="line"><span class="attribute">ABCDEFGHIJ</span></span><br></pre></td></tr></table></figure></li><li><p>程序分析:</p><blockquote><p>第10行开始的for循环被称为外层循环(outer loop)<br>第12行开始的for循环被称为内层循环(inner loop)<br>外层循环从row为0开始循环，到row为6时结束<br>因此，外层循环要执行6次，row的值从0变为5<br>每次迭代要执行的第1条语句是内层的for循环，该循环要执行10次，在同一行打印字符A～J<br>第2条语句是外层循环的printf(“\n”);<br>该语句的效果是另起一行，这样在 下一次运行内层循环时，将在下一行打印的字符<br>注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环<br>在程序中，内层循环一行打印10个字符，外层循环创建6行</p></blockquote></li><li><p>此实例中，内层循环和外层循环所做的事情相同</p></li><li><p>可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务</p><blockquote><p>比如可以根据上面的程序来修改内层循环条件<br>比如让row和A相加，而因为ch是char类型的，所以每次迭代所带来的结果就是将其初始化为不同的字符，所以程序每次对字符的打印数量都会比上一行少一个，如果没有改变测试条件，每行依旧会以F结尾<br>还可称其为依赖外部循环的嵌套循环，只不过不应该存在这种说法，因为这只是最基本的线性逻辑</p></blockquote></li></ul><hr><h3 id="关于在循环中使用数组"><a href="#关于在循环中使用数组" class="headerlink" title="关于在循环中使用数组"></a>关于在循环中使用数组</h3><ul><li><p>因为循环内经常需要用到数组，这里先对数组进行简单的说明</p><blockquote><p>数组可以作为一种存储多个相关项的便利方式</p></blockquote></li><li><p>数组(array)是按顺序存储一系列类型相同的值，如10个char类型的字符或15个int类型的值</p><blockquote><p>整个数组有一个数组明，通过整数下标来访问数组中单独的项或元素(element)</p></blockquote></li><li><p>以下是对数组进行声明的基本语法格式:</p><blockquote><p>float debts[20];</p></blockquote></li><li><p>声明debts是一个内含20个元素的数组，每个元素都可以存储float类型的值</p><blockquote><p>数组的第一个元素是debts[0]，第二个元素是debts[1]，以此类推，直到debts[19]<br>这里需要进行注意的一点就是，数组元素的编号从0开始，而非1<br>此时可以给每个元素赋float类型的值</p></blockquote></li><li><p>赋值的基本语法格式:</p><blockquote><p>debt[6] = 32.49;<br>debt[7] = 1.2e+21;</p></blockquote></li><li><p>实际上，使用数组元素和使用同类型的变量意义</p><blockquote><p>例如，可以这样把值读入指定的元素之中:<br>scanf(“%f”, &amp;debts[4]);</p></blockquote></li><li><p>这里要注意个潜在的陷阱，考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确</p><blockquote><p>所以千万不要书写和使用数组中不存在的元素，因为编译器不会查找这样的错误<br>当运行程序时，这种情况会导致数据被放在在已被其它数据占用的地方，可能会破坏程序的结果甚至导致程序因异常而中断</p></blockquote></li><li><p>数组的类型可以是任意的数据类型</p><blockquote><p>int nannies[22];<br>char actors[26];<br>long big[500];</p></blockquote></li><li><p>可以把字符串存储在char类型的数组中(一般而言，char类型数组的所有元素都存储char类型的值)</p><blockquote><p>如果char类型的数组末尾包含了一个表示字符串末尾的空字符\0，则该数组的内容就构成了一个字符串</p></blockquote></li><li><p>图解字符串数组和字符串:</p></li></ul><img src="/images/数据类型-6/字符串和字符串数组.png" width="40%" height="40%"><ul><li><p>用于识别数组元素的数字被称为下标(subscript)，索引(indice)或偏移量(offset)</p><blockquote><p>下标必须是整数，而且要从0开始计数<br>数组内的元素依次被存储在内存中相邻的为止</p></blockquote></li><li><p>图解内存中的char和int类型的数组:</p></li></ul><img src="/images/数据类型-6/内存中的char和int类型的数组.png" width="40%" height="40%"><ul><li><p>在for循环中可以使用数组，也就是使用循环来处理数组</p></li><li><p>在调整循环语句的逻辑描述时，要时刻遵守模块化(modularity)原则</p><blockquote><p>模块化原则的思想就是: 应把程序划分为一些独立的单元，每个单元执行一个任务<br>这样做能够提升程序的可读性<br>最重要的是，模块化使程序的不同部分彼此独立，方便以后更新或修改程序<br>还可以将每个执行任务的单元放进函数中，提高程序的模块化</p></blockquote></li></ul><hr><ul><li>在循环内使用函数的返回值</li><li>使用带返回值的函数</li><li>此部分可能会被补充</li></ul><hr><h3 id="概念归纳"><a href="#概念归纳" class="headerlink" title="概念归纳"></a>概念归纳</h3><ul><li>循环是一个强大的编程工具<blockquote><p>在创建循环时，要特别注意以下3个方面:</p></blockquote></li></ul><ol><li>注意循环的测试条件要能使循环结束</li><li>确保循环测试中的值在首次使用之前已初始化</li><li>确保循环在每次迭代都更新测试的值</li></ol><ul><li><p>C通过求值来处理测试条件，结果为0表示假，非0表示真</p><blockquote><p>带关系运算符的表达式常用于循环测试，它们有些特殊<br>如果关系表达式为真，其值为 1<br>如果为假，其值为0<br>这与新类型<code>_Bool</code>的值保持一致</p></blockquote></li><li><p>数组由相邻的内存位置组成，只储存相同类型的数据</p><blockquote><p>记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少1<br>C编 译器不会检查数组下标值是否有效，自己要多留心</p></blockquote></li><li><p>使用函数涉及3个步骤:</p></li></ul><ol><li>通过函数原型声明函数</li><li>在程序中通过函数调用使用函数</li><li>定义函数</li></ol><ul><li>函数原型是为了方便编译器查看程序中使用的函数是否正确<blockquote><p>函数定义描述了函数如何工作<br>现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义<br>接口部分描述了如何使用一个特性，也就是函数原型所做的<br>实现部分描述了具体的行为，这正是函数定义所做的</p></blockquote></li></ul><hr><ul><li>在便于理解的前提下，对代码的总体大小进行优化<blockquote><p>易于理解和维护的代码才是好代码<br>没必要去理解或书写一些逻辑严谨到夸张的地步和使用一大片符号类型的代码<br>可以将一句逻辑严谨的代码写成两句或三句便于理解的代码，当然是在保持美观的前提下<br>即模块化原则</p></blockquote></li></ul><hr><p><strong>内容来自原书第六章节</strong></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-2&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C-资源整合目录</title>
    <link href="https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/"/>
    <id>https://unit-serow.github.io/2020/03/12/C-%E8%B5%84%E6%BA%90%E6%95%B4%E5%90%88%E7%9B%AE%E5%BD%95/</id>
    <published>2020-03-12T15:55:11.000Z</published>
    <updated>2020-03-13T10:03:35.204Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>C-资源整合目录</strong></center><a id="more"></a><h3 id="C-资源整合目录"><a href="#C-资源整合目录" class="headerlink" title="C 资源整合目录"></a>C 资源整合目录</h3><ul><li>电子书籍</li><li>URL地址</li><li>参考资料</li></ul><hr><h3 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h3><ul><li>EN-C Primer Plus</li><li>CN-C 程序设计语言</li><li>CN-数据结构与算法分析-C 语言实现</li><li>CN-C Primer Plus (第六版)<blockquote><p>C11标准<br>作者: Stephen Prata<br>译者: 姜佑</p></blockquote></li></ul><hr><p><strong>书籍目录:</strong></p><ul><li>第一章/第二章-基本概念与书籍介绍</li><li>第三章-数据和C</li><li>第四章-字符串和格式化输入/输出</li><li>第五章-运算符，表达式和语句</li><li>第六章-C控制语句：循环</li><li>第七章-C控制语句：分支和跳转</li><li>第八章-字符输入/输出和输入验证</li><li>第九章-函数</li><li>第十章-数组和指针</li><li>第十一章-字符串和字符串函数</li><li>第十二章-存储类别，链接和内存管理</li><li>第十三章-文件输入/输出</li><li>第十四章-结构和其它数据形式</li><li>第十五章-位操作</li><li>第十六章-C预处理器和C库</li><li>第十七章-高级数据表示</li></ul><p><strong>笔记归纳:</strong></p><ul><li>第一/二/三章被归纳于数据类型-1/2内</li><li>第四章被归纳于数据类型-3/4内</li><li>第五章被归纳于数据类型-5内</li><li>第六章被归纳于数据类型-6内</li><li></li></ul><hr><ul><li>本书一共十七个章节，预计使用最多50个笔记文本进行刨析归纳<blockquote><p><code>17*2+16=50</code></p></blockquote></li></ul><hr><ul><li><p>相关资源整合包</p></li><li><p><a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">百度网盘地址</a>:</p><blockquote><p>链接: <a href="https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA" target="_blank" rel="noopener">https://pan.baidu.com/s/1enDrHVuTM7i7mrBXMu8aLA</a><br>提取码: 0ez0</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;C-资源整合目录&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-5</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-5/</id>
    <published>2020-03-12T11:14:12.000Z</published>
    <updated>2020-03-12T11:16:20.592Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-语句/控制语句-1</strong></center><a id="more"></a><h2 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型-5"></a>数据类型-5</h2><ul><li>语句与表达式-1<blockquote><p>C-控制语句/循环-While<br>C-控制语句/选择<br>关系运算及其关系运算符<br>条件表达式<br>真与假的概念<br>循环逻辑概念与原理</p></blockquote></li></ul><hr><ul><li>通常一门语言应该提供以下三种形式的程序流<blockquote><p>执行语句序列(即为线性的执行逻辑)<br>如果满足某些条件就进行重复执行的语句序列(循环)<br>通过测试选择执行哪一个语句序列(分支/控制)</p></blockquote></li></ul><hr><h2 id="C-控制语句-循环"><a href="#C-控制语句-循环" class="headerlink" title="C 控制语句-循环"></a>C 控制语句-循环</h2><h3 id="While循环"><a href="#While循环" class="headerlink" title="While循环"></a>While循环</h3><ul><li><p>while循环是入口条件循环</p><blockquote><p>或称其为while循环是使用入口条件的有条件循环<br>所谓的有条件指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)<br>该表达式是一个入口条件(entry condition)，因为必须满足条件才能进入循环体<br>如果条件一开始就为假，则绝对不会进入循环体，则跳过循环体代码块</p></blockquote></li><li><p>可以把下面的伪代码作为while循环的标准格式:</p></li></ul><p>1.利用循环外的语句对循环内的变量进行值传递<br>2. 获得第1个用于测试的值 (while (循环条件))<br>3. 当测试为真时<br>4. 处理值 (根据循环条件)<br>5. 获取下一个值 scanf()</p><ul><li><p>当被输入的值传递进循环并可以保证条件为真时，开始第一轮循环</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>); <span class="comment">/* 定义被输入值的变量 */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">status</span> == <span class="number">1</span>) <span class="comment">/* 定义循环条件 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">status</span> = scanf(<span class="string">"%ld"</span>, &amp;<span class="built_in">num</span>);  <span class="comment">/* 定义循环行为，即接受被输入的值，当接受的值可以满足循环条件时则为真，开始迭代 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>还可以写为</p><blockquote><p><code>while (scanf(&quot;%ld&quot;, &amp;num) == 1){/* 循环行为 */}</code></p></blockquote></li><li><p>while循环的通用形式如下：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( expression )</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></li><li><p>其中statement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句</p></li><li><p>在大部分的程序内，expression部分都使用关系表达式</p><blockquote><p>也就是说，expression是值之间的比较，可以使用任何表达式<br>如果expression为真(或者更一般地说，非零)，则执行statement部分一次，然后再次判断expression<br>在expression为假(0)之前，循环的判断和执行一直重复进行<br>每次循环都被称为一次迭代/循环一轮(iteration)</p></blockquote></li><li><p>while循环结构示意图:</p></li></ul><img src="/images/数据类型-5/C-循环语句-1.png" width="30%" height="30%"><ul><li><p>while循环有一点非常重要: 在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假</p><blockquote><p>否则，循环就不会终止(可以使用 break和if语句来终止循环)</p></blockquote></li><li><p>最大正值加一一般 会得到一个负值，类似地，最小负值减一一般会得到最大正值</p></li></ul><hr><h3 id="while的语法要点"><a href="#while的语法要点" class="headerlink" title="while的语法要点"></a>while的语法要点</h3><ul><li><p>使用while时，要牢记一点: 只有在测试条件后面的单独语句(简单语句或符合语句)才是循环部分</p><blockquote><p>while循环语句的格式应为while(){}，而绝非{while()}，陷入无限循环(infinite loop)是最常见的情况</p></blockquote></li><li><p>还有一点就是，即便while语句本身使用符合语句，while的本质依旧是一条单独的语句(或称为在语句构成上)</p><blockquote><p>该语句从while开始执行，到第一个分号结束，在使用复合语句的情况下，到右花括号结束，还需要注意分号的为止，一定要在语句结束时再写分号</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li><li><p>在使用while语句时，可以直接将分号写在条件表达式后面，即可以让程序直接进入下一个迭代，因为一个单独的分号被视为一条语句</p></li><li><p>如果在测试条件(条件表达式)的代码后面直接添加单独的分号</p><blockquote><p>此分号则代表为一个空语句(null statement)，它什么也不做<br>在 C 中，单独的分号表示空语句，而处理空语句最好的方法是使用continue语句</p></blockquote></li></ul><hr><h3 id="关系运算符与表达式"><a href="#关系运算符与表达式" class="headerlink" title="关系运算符与表达式"></a>关系运算符与表达式</h3><ul><li><p>用关系运算符和表达式来比较大小</p></li><li><p>以下关于关系表达式与关系运算符的概念在所有的循环类语句概念中都通用，这里的通用泛指计算机上所有的程序语言</p></li><li><p>while循环经常依赖测试表达式来作比较，这样的表达式被称之为关系表达式(relational expression)</p></li><li><p>而出现在关系表达式中间的运算符叫做关系运算符(relational operator)</p></li><li><p>以下表图片内列出了 C 的所有关系运算符，同时该表也涵盖了所有的数值关系</p></li><li><p>关系运算符:</p></li></ul><img src="/images/数据类型-5/关系运算符-1.png" width="30%" height="30%"><ul><li><p>PS: 数字之间的关系再复杂也没有人与人之间的关系复杂-来自原书</p></li><li><p>关系运算符常用于构造while语句和其他C语句中用到的关系表达式</p><blockquote><p>这些语句都会检查关系表达式为真还是为假</p></blockquote></li><li><p>所谓关系运算符，存在的意义就是对人为所描述的表达式的值进行确定，确定的结果只有0和1，即真与假</p></li><li><p>而在确定的过程中，最常见的确定方法就是与人为所规定的值进行字符的比较</p></li><li><p>如果要对浮点数进行比较，尽量要去只是用&lt;和&gt;，因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等</p></li><li><p>为了避免此类型错误的发生，C 内拥有fabs()函数，该函数声明在math.h头文件中</p><blockquote><p>使用该函数可以较为方便的比较浮点数，该函数返回一个浮点的绝对值(即为没有代数符号的值)</p></blockquote></li></ul><hr><p><strong>fabs()函数使用示范:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> ANSWER = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">double</span> response;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"What is the value of pi?\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"lf"</span>, &amp;response);</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(response - ANSWER) &gt; <span class="number">0.0001</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Try again!\n"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Close enough!\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差 0.0001：</p></li><li><p>输出结果:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What <span class="keyword">is</span> the value of pi?</span><br><span class="line"><span class="number">3.14</span></span><br><span class="line">Try again!</span><br><span class="line"><span class="number">3.1416</span></span><br><span class="line">Close enough!</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="何为真"><a href="#何为真" class="headerlink" title="何为真"></a>何为真</h3><ul><li><p>这是一个古老的问题，但是对C而言还不算难、</p></li><li><p>在C中，表达式一定有 一个值，关系表达式也不例外</p></li><li><p>可以使用并输出两条简单的比较语句，比如说 <code>true_val=(10&gt;2);</code>和<code>false_val(10==2);</code>，前者为真，后者为假</p><blockquote><p>则输出的结果必定是true=1，而false=0</p></blockquote></li><li><p>所以说，对 C 而言，表达式为真的值为1，表达式为假的值为0</p></li><li><p>当 C 程序的循环结构的判断结果一直为真(即为1)时，则反复且永远进行条件及语句的迭代</p></li><li><p>所以一些C程序使用下面的结构，由于1为真，所以该循环会一直进行</p><blockquote><p><code>while (1){...}</code></p></blockquote></li></ul><p><strong>关于其它的真值:</strong></p><ul><li><p>在 C 中，所有的非零值都被视为真，只有0被视为假</p><blockquote><p>也就是说，只要测试条件的值为非零，就会执行while循环</p></blockquote></li><li><p>这是从数值方面而不是从真/假方面来看测试条件</p><blockquote><p>还有需要进行牢记的一点就是，关系表达式为真，求值得一，关系表达式为假，求值得零<br>因此，这些表达式实际上相当于数值，所以必须要去充分利用测试条件的这一特性<br>比如，用while(goats)替换while(goats !=0)，因为表达式goats !=0和goats都只有在goats的值为0时才为0或假，所以再增加一个不等于(!=)的比较运算符的毫无意义的<br>这里利用了 C 内自动判断真值与假值的性质，或称其为默认值与自然选择</p></blockquote></li><li><p>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编译代码，从而使代码更加整洁与美观</p></li><li><p>这个特点既为好处，也为坏处，C 由于对真的约束太少，会带来一些麻烦</p><blockquote><p>当循环的条件表达式中没有定义==1，而定义了=1时，此时的条件表达式中的变量的值为一<br>而且，整个赋值表达式的值就是赋值运算符左侧的值，所以变量=1的值也是1，既while(变量=1)实际上就相当于while(1)<br>也就是说，循环不会退出，此时如果人为的输入其它的符号，从而让变量的值归于0，但是循环的测试条件又把改变量重置为1，从而又进入了下一次迭代<br>此时程序中的循环一直运行着，用户在输如符号后完全没有机会输入，如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，以供下一次读取<br>当scanf()把输入的符号(这里的符号可以为任何不属于数字的数据类型)作为整数读取失败了，他将会把字符留下<br>在下一次循环时，scanf()从上次读取失败的地方(被输入字符)开始读取，scanf()把该输入的字符再次作为整数读取，然后又失败了<br>以此，就造成了一个无限的循环，而且还是失败的</p></blockquote></li><li><p>所以这里千万需要注意的一点就是，千万别把关系相等运算符==和赋值运算符=给弄错了</p></li><li><p>因为 C 不允许给常量赋值</p><blockquote><p>而且编译器会把赋值运算符的这种用法作为语法错误标记出来<br>可以在构建比较是否相等的表达式时，把常量放在左侧，比如<code>6 = canoes;</code></p></blockquote></li><li><p>好在计算机察觉不出来，因为对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样-来自原文</p></li><li><p>总之，关系运算符用于构成关系表达式</p><blockquote><p>关系表达式为真时值为1，为假时值为0<br>通常用关系表达式作为测试条件的语句(如while和if)可以使用任何表达式作为测试条件<br>即非零为真，零为假</p></blockquote></li><li><p>以类似于<code>while (条件表达式)</code>这样的格式为变量进行命名可以让while循环的测试变得简单易懂</p></li></ul><hr><h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="_Bool类型"></a><code>_Bool</code>类型</h3><ul><li><p>在 C 中，一直用int类型的变量表示真/假值</p></li><li><p>C99专门针对这种类型 的变量新增了<code>_Bool</code>类型</p><blockquote><p>该类型是以英国数学家George Boole的名字命名 的，他开发了用代数表示逻辑和解决逻辑问题<br>在编程中，表示真或假的变量被称为布尔变量(Boolean variable)，所以<code>_Bool</code>是 C 中布尔变量的类型名<br>其中<code>_Bool</code>类型的变量只能储存1(真)或0(假)<br>如果把其他非零数值赋给<code>_Bool</code>类型的变量，该变量会被设置为1<br>这反映了C把所有的非零值都视为真<br>给布尔变量取一个能表示真或假值的变量名是一种常见的做法</p></blockquote></li><li><p>C99提供了<code>stdbool.h</code>头文件，该头文件让<code>bool</code>成为<code>_Bool</code>的别名</p><blockquote><p>而且还把true和false分别定义为1和0的符号常量<br>包含该头文件后，写出的代码可以与C++兼容<br>因为C++把bool，true和false定义为关键字<br>如果系统不支持<code>_Bool</code>类型，导致无法运行该程序<br>可以把<code>_Bool</code>替换成 int即可</p></blockquote></li></ul><hr><h3 id="优先级和关系运算符"><a href="#优先级和关系运算符" class="headerlink" title="优先级和关系运算符"></a>优先级和关系运算符</h3><ul><li><p>关系运算符的优先级比算术运算符(包括+和-)要更低，而比赋值运算符要高</p></li><li><p>关系运算符之间有两种不同的优先级。</p><blockquote><p>高优先级组: &lt;&lt;= &gt;&gt;=<br>低优先级组: == !=</p></blockquote></li><li><p>与其他大多数运算符一样，关系运算符的结合律也是从左往右</p></li><li><p>以下图片列表列出了常用的关系运算符优先级关系，具体可以参考-[C 运算符]，其中列出了全部运算符的完整优先级列表</p></li><li><p>运算符优先级:</p></li></ul><img src="/images/数据类型-5/C-关系运算符优先级-1.png" width="30%" height="30%"><hr><h3 id="关于不确定循环和计数循环"><a href="#关于不确定循环和计数循环" class="headerlink" title="关于不确定循环和计数循环"></a>关于不确定循环和计数循环</h3><ul><li><p>一些while循环是不确定循环(indefinite loop)</p><blockquote><p>所谓不确定循环，指 在测试表达式为假之前，预先不知道要执行多少次循环</p></blockquote></li><li><p>还有一类是计数循环(counting loop)</p><blockquote><p>这类循环在执行循环之前就知道要重复执行多少次</p></blockquote></li><li><p>在创建一个重复执行固定次数的循环中涉及了3个行为:</p></li></ul><p>1.必须初始化计数器<br>2.计数器与有限的值作比较<br>3.每次循环时递增计数器</p><ul><li>while循环的测试条件执行比较，递增运算符执行递增<blockquote><p>如果递增发生在循环的末尾，即可以防止不小心漏掉递增<br>因此，这样做比将测试和更新组合放在一起要好，但是计数器的初始化放在循环外，就有可能忘记初始化<br>此时可以用for循环来避免这种情况的发生</p></blockquote></li></ul><hr><p><strong>其它内容:</strong></p><ul><li>赋值运算符 用于将右值赋给左值，而左值通常为变量</li><li>赋值表达式</li><li>关系运算符 用于对左值和右值进行比较</li><li>条件运算符</li></ul><hr><h3 id="伪代码-pseudocode"><a href="#伪代码-pseudocode" class="headerlink" title="伪代码(pseudocode)"></a>伪代码(pseudocode)</h3><ul><li>是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应</li><li>伪代码有助于涉及程序的逻辑</li><li>确定程序的逻辑无误后，再把伪代码翻译成实际的代码</li><li>使用为伪代码的好处之一是，可以把注意力集中再程序的组织和逻辑上，不用在设计程序时还要分心去想如何用编程语言来表达自己的想法</li><li>例如可以用缩进来代表一块代码，不用考虑 C 的语法要用花括号把部分代码括起来</li></ul><hr><h3 id="其它理解"><a href="#其它理解" class="headerlink" title="其它理解"></a>其它理解</h3><hr><ul><li><p>程序按照序列逻辑进行线性执行</p></li><li><p>由主函数mian()开始</p><blockquote><p>然后线性执行主函数内所调用的函数和语句<br>而其它的函数也是相同的原理，函数内的任何语句都是根据线性逻辑来逐一执行<br>至于循环语句与控制语句也是由线性逻辑来执行的，即执行完该语句上面的所有语句，再进行对循环或控制语句的执行<br>各种基本数据对象根据逻辑构成语句(数据对象可以包括变量，数组，指针，运算符，关键字或对于其它函数的调用等等)</p></blockquote></li><li><p>语句构成函数</p></li><li><p>函数构成程序</p></li><li><p>在计算机内，构成任何数据对象的逻辑都是线性的，即逐一执行</p></li></ul><hr><ul><li>预处理器(对于头文件的处理方法，通常是在程序编译之前就已经将头文件中的内容处理完毕，处理的对象即为对于所指头文件内函数的对应调用)</li><li>头文件(给当前的程序本身提供外部函数的支持，即对于当前语言标准库的支持)</li></ul><ol><li>定义常量</li><li>定义全局变量</li><li>函数声明</li></ol><ul><li>主函数<code>main(){包括了对于其它函数的调用以及线性逻辑执行}</code><blockquote><p>对于其它函数的补充</p></blockquote></li></ul><hr><ul><li><p>声明函数的基本格式为: <code>void funtion_name (void) {函数内容}</code></p><blockquote><p>圆括号内所声明的参数可称其为形式参数，即为没有值，但有数据类型的变量数据类型<br>前者的void为函数本身的数据类型，最常用的是整形类型或长整型类型<br>函数的类型用于声明让函数实现的功能模块</p></blockquote></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li><p>每个函数或每个花括号都可以被称为是代码块</p></li><li><p>写程序的大体逻辑</p></li></ul><ol><li>先将常量和全局变量声明完毕</li><li>进行函数声明</li><li>然后先写上主函数</li><li>再对函数进行补充，以实现其对应功能</li><li>最后再主函数中的内容进行补充(通常就是对已存在的函数进行进行逐一调用)</li><li>编译源代码并执行程序</li></ol><ul><li>在计算机内，一切的执行逻辑都是线性的</li></ul><hr><ul><li><p>条件表达式与条件语句的本质就是判断值的真假或称其为0或1，用更大的范围去描述则是0与任何实数，即0就是假，或称其为无，其它的任何数都是真，或称其为有</p></li><li><p>无论是循环语句，选择语句还是任何的控制语句(流程控制语句)，它们存在(或称其为存在)的意义都是为了对所选条件表达式的值进行判断，而判断的结果只有两个，即为0与1</p></li><li><p>构成函数的概念只有语句和表达式，一切语句都已分号宣布独立(结束)</p><blockquote><p>即便在语句内使用了复合语句，复合语句则皆以右花括号结束</p></blockquote></li></ul><hr><ul><li>在 C 或其它任何一种编程语言内，要尽量的去使用自然选择与缺省值来编写代码，从而使代码更加整洁与美观</li><li>千万不要忘了伪代码的概念，一般的思路梳理就是对所谓伪代码的实现</li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-语句/控制语句-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-4</title>
    <link href="https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/"/>
    <id>https://unit-serow.github.io/2020/03/12/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-4/</id>
    <published>2020-03-12T01:55:21.000Z</published>
    <updated>2020-03-12T11:17:45.381Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-运算符与表达式-1</strong></center><a id="more"></a><h2 id="数据类型-4"><a href="#数据类型-4" class="headerlink" title="数据类型-4"></a>数据类型-4</h2><ul><li>重点为运算符与表达式</li></ul><hr><h3 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h3><p><strong>涉及概念:</strong></p><ul><li>一元运算符</li><li>二元运算符</li><li>左值与右值</li><li>表达式和语句</li><li>基本循环及其符合语句</li><li>副作用与序列点</li></ul><hr><h3 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h3><p><strong>右值</strong></p><ul><li><p>右值(rvale)，通常只能是字面常量</p><blockquote><p>而字面常量不能常量赋值，因为常量本身就是它的值<br>因此，在使用赋值运算符=时，左侧的项必须是一个变量名<br>实际上，赋值运算符左侧必须引用一个存储位置，而最简单方法就是使用变量名<br>不过指针也可用于指向一个存储位置<br>概括地说，C 使用可修改的左值(modifiable lvalue)标记那些可赋值的实体(物理内存)</p></blockquote></li><li><p>术语概览: 数值对象，左值，右值和运算符</p></li><li><p>赋值表达式语句的目的是把值存储到内存位置上</p></li><li><p>用于存储值的数据存储区域被称之为对象(data object)</p></li><li><p>C 标准中只有提到赋值的概念时，才有可能涉及到对象这个术语</p></li><li><p>使用变量名是表示对象的唯一方法，除此之外还有其它的方法，例如指定数组的元素，结构的成员，或者使用指针表达式(指针中存储的是它所指对象的地址)</p></li><li><p>相关的具体细节这里不做过多阐述</p></li></ul><p><strong>左值</strong></p><ul><li><p>左值(lvalue)是C的术语，用于表示特定数据对象的名称或表达式</p><blockquote><p>因此，对象指的是实际的数据存储，而左值是用于表示或定位存储位置的标签</p></blockquote></li><li><p>对于早期的C，左值所涉及的意义:</p></li></ul><ol><li>它指定一个对象，所以引用内存中的地址</li><li>它可以在赋值运算符的左侧，左值(lvalue)中的l源自left</li></ol><ul><li>但后来的C标准中新增了const限定符，用const创建的变量为只读变量，即为不可修改<blockquote><p>因此，const标识符可以满足上面的第一项，而无法满足第二项<br>一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧<br>有些左值不能用于赋值运算符的左侧，因此，标准对左值的定义已经不能满足当前的状况<br>为此，C标准新定义了一个术语: 可修改的左值(modifable lvalue)，此方法用于标识可修改的对象<br>所以，赋值运算符的左侧应该是可修改的值，当前标准建议，使用术语对象定位值(object locator value)更好</p></blockquote></li></ul><hr><p><strong>右值</strong></p><ul><li><p>右值(rvalue)指的是能赋值给可修改左值的量，且本身不是左值</p><blockquote><p>右值中的r源自right</p></blockquote></li><li><p>右值可以是常量，变量或其它可求值的表达式(如，函数调用)</p><blockquote><p>实际上，当前标准在描述这一概念时使用的是表达式的值(value of an expression)，而非右值<br>右值示例: bmw = 2002;，此时的2002则为右值</p></blockquote></li><li><p>左值就是用于引用某指定内存位置的标识符，而右值即为存储于该内存位置的值</p></li><li><p>在名称学习时，被称为”项”(如，赋值运算符左侧的项)的就是运算符对象(operand)</p><blockquote><p>运算对象指的就是运算符操作的对象<br>还可以类似的将”=运算符的左侧对象”称之为是”应该是可修改的左值”</p></blockquote></li></ul><hr><h2 id="基本的算术运算符-一元-二元运算符"><a href="#基本的算术运算符-一元-二元运算符" class="headerlink" title="基本的算术运算符-一元/二元运算符"></a>基本的算术运算符-一元/二元运算符</h2><h3 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h3><ul><li>二元运算符最基本的定义是运算对象至少是两个值</li><li>最基本的二元运算符是四则运算标识符</li></ul><p><strong>加法运算符</strong></p><ul><li>加法运算符(addition operator)用于加法运算，使其两侧的值相加<blockquote><p>而相加的值(运算对象)可以是对象，也可以是常量<br>比如 icome = salary + bribes;，计算机会查看加法运算符右侧的两个变量，即为右值，将其相加，然后将相加的和(返回的结果)赋值给变量income<br>这里需要注意的一点是，income，salary，bribes都是可修改的左值，因为每个变量都标识了一个可被赋值的数据对象<br>但是，表达式salary + brives是一个右值</p></blockquote></li></ul><p><strong>减法运算符</strong></p><ul><li>减法运算符(subtraction operator)用于减法运算，使其左侧的数减去右侧的数<blockquote><p>例如，下面的语句把200.0赋给takehome：<br>takehome = 224.00 – 24.00;<br>+和-运算符都被称为二元运算符(binary operator)，即这些运算符需要两个运算对象才能完成操作</p></blockquote></li></ul><hr><h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h3><ul><li>一元运算符(unary operator)</li><li>一元运算符就是符号运算符，即仅需要运算一个运算对象的运算符<blockquote><p>类似于赋值运算符=，数值标识符-，+(正值与负值)，指针标识符&amp;和*等等</p></blockquote></li></ul><p><strong>符号运算符:-和+</strong></p><ul><li><p>减号还可用于标明或改变一个值的代数符号</p><blockquote><p>rocky = -12;，以这种方式使用的负号被称之为一元运算符</p></blockquote></li><li><p>在C90标准中新增了一元+运算符，它不会改变运算对象的值或符号</p><blockquote><p>只能这样使用: dozen = +12;<br>此时编译器不会报错，但是在以前，这样做是不被允许的</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>二元运算符和一元运算符:</li></ul><img src="/images/数据类型-4/运算符-1.png" width="30%" height="30%"><hr><p><strong>乘法运算符</strong></p><ul><li>符号*表示乘法<blockquote><p><code>cm = 2.56 * inch;</code>，该语句就是用2.56乘以inch，并将结果赋值给cm<br>因为C 内没有平方函数与指数函数，所以只能用循环语句来实现平方与其它指数级增长</p></blockquote></li></ul><p><strong>除法运算符</strong></p><ul><li><p>C使用符号/来表示除法</p></li><li><p>符号/左侧的值是被除数，右侧的值是除数</p><blockquote><p>例如，此表达式中four的值是<code>4.0: four = 12.0/3.0;</code></p></blockquote></li><li><p>整数除法和浮点数除法不同</p><blockquote><p>浮点数除法的结果是浮点数，而整数除法的结果是整数<br>整数是没有小数部分的数<br>这使得5除以3很让人头痛，因为实际结果有小数部分</p></blockquote></li><li><p>在C语言中，整数除法结果的小数部分被丢弃</p><blockquote><p>这一过程被称为截断(truncation)</p></blockquote></li><li><p>一般情况下最好避免混合类型的出现，即同一个除法表达式内同时出现整数与浮点数</p><blockquote><p>因为计算机不能真正的使用浮点数去除以整数，所以编译器会把两个运算对象转换成相同的类型<br>即在进行出发运算之前，将整数转换为浮点数，或将浮点数转换为整数</p></blockquote></li><li><p>在C99标准以前，C语言给语言的实现者留有一些空间</p><blockquote><p>让他们来决定如何进行负数的整数除法<br>一种方法是，舍入过程采用小于或等于浮点数的最大整数<br>当然，对于<code>3.8</code>而言，处理后的3符合这一描述<br>但是当需要处理<code>-3.8</code>时，该方法建议四舍五入为<code>-4</code><br>因为<code>-4</code> 小于<code>-3.8</code><br>但是，另一种舍入方法是直接丢弃小数部分<br>这种方法被称为”趋零截断”，即把<code>-3.8</code>转换成<code>-3</code><br>在C99以前， 不同的实现采用不同的方法<br>但是C99规定使用趋零截断<br>所以，应把-<code>3.8</code>转换成<code>-3</code></p></blockquote></li></ul><hr><ul><li>当同一个表达式内出现了多种不同种类的运算符时，运算符会出现优先级限制</li></ul><p><strong>图片说明:</strong></p><ul><li>目前为止文章内涉及的运算符优先级(从低至高):</li></ul><img src="/images/数据类型-4/运算符优先级-1.png" width="30%" height="30%"><ul><li>优先级和求值顺序<blockquote><p>运算符的优先级为表达式中的求值顺序提供了重要的依据，但是并没有规定所有的顺序<br>所以 C 给实现者留出了选择的余地</p></blockquote></li></ul><hr><h3 id="其它运算符"><a href="#其它运算符" class="headerlink" title="其它运算符"></a>其它运算符</h3><ul><li>C 中有大约40个运算符，有些运算符比其它运算符常用的多<blockquote><p>这里只对最常用的运算符进行讨论</p></blockquote></li></ul><p><strong>sizefo运算符与其相关类型</strong></p><ol><li>sizeof运算符和<code>size_t</code>类型<blockquote><p>sizeof运算符以字节为单位返回运算对象的大小(在C中，1字节定义为char类型占用的空间大小)<br>过去，1字节通常是8位，但是一些字符集可能使用更大的字节<br>运算对象可以是具体的数据对象(如，变量名)或类型<br>如果运算对象是类型(如， float)，则必须用圆括号将其括起来</p></blockquote></li></ol><ul><li>C 规定，sizeof返回<code>size_t</code>类型的值<blockquote><p>这是一个无符号整数类型， 但它不是新类型</p></blockquote></li><li><code>size_t</code>是语言定义的标准类型<blockquote><p>C 有一个typedef机制<br>允许程序员为现有类型创建别名<br>例如:<br><code>typedef double real;</code><br>这样，real就是double的别名</p></blockquote></li><li>现在，可以声明一个real类型的变量:<blockquote><p><code>real deal; // 使用typedef</code><br>编译器查看real时会发现，在typedef声明中real已成为double的别名<br>于是把deal创建为double 类型的变量<br>类似地，C 头文件系统可以使用typedef把<code>size_t</code>作为<code>unsigned int</code>或<code>unsigned long</code>的别名<br>这样，在使用<code>size_t</code>类型时，编译器会根据不同的系统替换标准类型</p></blockquote></li><li>C99 做了进一步调整，新增了<code>%zd</code>转换说明用于<code>printf()</code>显示<code>size_t</code>类型的值<blockquote><p>如果系统不支持<code>%zd</code>，可使用<code>%u</code>或<code>%lu</code>代替<code>%zd</code></p></blockquote></li></ul><hr><p><strong>求模运算符</strong></p><ol start="2"><li>求模运算符(modulus operator): <code>%</code></li></ol><ul><li><p>用于整数运算</p></li><li><p>求模运算符给出其左侧整数除以右侧整数的余数(remainder)</p><blockquote><p>例如，<code>13 % 5</code>(读作”13求模5”)得3，因为13比5的两倍多3，即13除以5的余数是3<br>求模运算符只能用于整数，不能用于浮点数</p></blockquote></li><li><p>求模运算符常用于控制程序流</p><blockquote><p>例如，假设此时正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用<br>这种情况可以在程序中对月份求 模3(即，month % 3)，并检查结果是否为0<br>如果为0，便加进额外的费用</p></blockquote></li><li><p>求模运算符作得出的结果就是所谓的取余运算所得出的结果</p></li><li><p>负数也可以进行求模运算，于C99开始支持了趋零截断</p></li></ul><hr><p><strong>递增运算符</strong></p><ul><li><p>递增运算符(increment operator)-即为’++’</p></li><li><p>用于执行简单的任务，将其运算对象递增1</p><blockquote><p>该运算符以两种方式出现<br>第1种方式，++出现在其作用的变量前面， 这是前缀模式<br>第2种方式，++出现在其作用的变量后面，这是后缀模式<br>两种模式的区别在于递增行为发生的时间不同</p></blockquote></li></ul><hr><p><strong>while循环的执行逻辑</strong></p><ul><li>根据所规定条件，对条件进行循环执行</li><li>例如规定了一个条件为<code>shoe &lt; 18</code>，并且每执行一次就进行一次递加(++)的表达式<blockquote><p>执行的逻辑是shoe的值递增1，然后和18进行比较，如果递增后的值小于18，则再次执行所规定的循环条件(即为所在花括号内的所有语句)<br>然后，shoe的值再递增1，以此重复刚才的不做，知道shoe的值不小于18为止</p></blockquote></li></ul><p><strong>图解示意:</strong></p><ul><li>执行一次循环:</li></ul><img src="/images/数据类型-4//images/while循环-1.png" width="30%" height="30%"><hr><p><strong>关于前缀递增和后缀递增</strong></p><ul><li><p>这里举一个例子:</p><blockquote><p><code>q = 2*++a;</code>，此语句为前缀形式递增，首先，a递增1，然后，2乘以a，并将结果赋给q<br><code>q =2*a++;</code>，此语句为后缀形式递增，首先，2乘以a，并将结果赋给q，然后，a递增1</p></blockquote></li><li><p>单独使用递增运算符时(如，ego++;)，使用哪种形式都没关系</p><blockquote><p>但是，当运算符和运算对象是更复杂表达式的一部分时(如上面的示例)<br>使用前缀或后缀的效果不同</p></blockquote></li></ul><hr><p><strong>递减运算符</strong></p><ul><li><p>每种形式的递增运算符都有一个递减运算符(decrement operator)与之对应</p></li><li><p>用–代替++即可:</p><blockquote><p><code>--count; // 前缀形式的递减运算符</code><br><code>count--; // 后缀形式的递减运算符</code></p></blockquote></li><li><p><code>&gt;</code>运算符表示”大于”，<code>&lt;</code>运算符表示”小于”，它们都是关系运算符(relational operator)</p></li></ul><hr><p><strong>递增运算符的优先级问题</strong></p><ul><li>递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高<blockquote><p>因此，<code>x*y++</code>表示的是<code>(x)*(y++)</code>，而不是<code>(x+y)++</code><br>不过后者无效，因为递增和递减运算符只能影响一个变量(或者更普遍地说，只能影响一个可修改的左值)<br>而组合<code>x*y</code>本身不是可修改的左值</p></blockquote></li></ul><hr><p><strong>不要自作聪明</strong></p><ul><li>如果一次用太多递增运算符，自己都会糊涂-CN-C Primer Plus-第5.3.6章节</li></ul><hr><h3 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h3><ul><li>术语: 表达式(expression)和语句(statement)</li><li>C 的基本程序步骤由语句组成，而大多数语句都由表达式构成</li></ul><p><strong>表达式:</strong></p><ul><li><p>表达式(expression)由运算符和运算对象组成(运算对象是运算符操作的对象)</p><blockquote><p>最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式</p></blockquote></li><li><p>运算对象可以是常量，变量或二者的组合</p><blockquote><p>一些表达式由子表达式(subexpression)组成(子表达式即较小的表达式)</p></blockquote></li><li><p>每个表达式都有一个值</p><blockquote><p>C 表达式的一个最重要的特性是，每个表达式都有一个值<br>要获得这个值，必须根据运算符优先级规定的顺序来执行操作<br>关于表达式的值的具体描述这里不做赘述，因为它是一个范围极大的纯粹性概念<br>计算机中表达式的概念与数学中的表达式相同，值即为表达式的结果</p></blockquote></li></ul><hr><p><strong>语句</strong></p><ul><li><p>语句(statement)是C程序的基本构建块</p><blockquote><p>一条语句相当于一条完整的计算机指令<br>在C中，大部分语句都以分号<code>&#39;;&#39;</code>结尾</p></blockquote></li><li><p>声明创建了名称和类型，并为其分配内存位置</p><blockquote><p>注意，声明不是表达式语句<br>也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值:<br><code>int port /* 不是表达式，没有值 */</code></p></blockquote></li><li><p>赋值表达式语句在程序中很常用: 它为变量分配一个值</p><blockquote><p>赋值表达式语句的结构是: 一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾<br>注意，在while循环中有一个赋值表达式语句<br>赋值表达式 语句是表达式语句的一个示例</p></blockquote></li><li><p>函数表达式语句会引起函数调用</p><blockquote><p>在该例中，调用printf()函数打印结果<br>while语句有3个不同的部分: 首先是关键字while，然后圆括号中是待测试的条件，最后如果测试条件为真，则执行while循环体中的语句<br>多条语句需要用花括号括起来</p></blockquote></li><li><p>图片-简单的while循环结构:</p></li></ul><img src="/images/数据类型-4/while循环-2.png" width="30%" height="30%"><ul><li>这种语句是复合语句<blockquote><p>该例的while循环中只有一条语句<br>可以是本例那样的一条语句， 不需要用花括号括起来，也可以像其他例子中那样包含多条语句<br>while语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂</p></blockquote></li></ul><hr><p><strong>关于副作用与序列点:</strong></p><ul><li>类似于while之类的迭代循环语句通常还会有副作用(side effect)和序列点(sequence point)等概念，这里不做过多赘述<blockquote><p>所谓的副作用，就是对于变量的赋值结果(此间的赋值结果由右值的表达式决定)<br>或称其为经由人工定义所得出的等式结果<br>所谓的序列点，就是程序执行的点，再该点上，所有的副作用都在进入下一步之前发生<br>C 中的语句用分号<code>&#39;;&#39;</code>来标记若干个序列点<br>其寓意就是在一个语句中，赋值运算符，递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成<br>还有一点就是，任何一个完整表达式的结束也是一个序列点</p></blockquote></li></ul><p><strong>关于完型表达式:</strong></p><ul><li>完整表达式(full expression)<blockquote><p>就是指这个表 达式不是另一个更大表达式的子表达式<br>例如，表达式语句中的表达式和while循环中的作为测试条件的表达式<br>都是完整表达式<br>序列点有助于分析后缀递增何时发生<br>千万要避免写出带有模棱两可逻辑的语句</p></blockquote></li></ul><p><strong>关于复合语句(块)</strong></p><ul><li><p>复合语句(compound statement)是用花括号括起来的一条或多条语句</p><blockquote><p>或称之为复合语句(或块)由花括号括起来的一条或多条语句组成<br>复合语句也称为块(block)<br>任何的程序都可以使用块以让while语句包含多条语句<br>在声明与描述复合语句的构成时，需要注意书写风格，其中最重要的是对于代码缩进的掌控</p></blockquote></li><li><p>图片-带有符合语句的while循环</p></li></ul><img src="/images/数据类型-4/while循环-3.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>一般函数的形式: void xxx(void)<br>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参<br>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)<br>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p><p>关于实参和形参的其它说明:</p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p>关于函数的调用:</p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-1-1"><a href="#补充内容-1-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><p>通常，在语句和表达式中应使用类型相同的变量和常量</p><blockquote><p>但是，如果使用混合类型，C 不会像Pascal那样停在那里死掉<br>而是采用一套规则进行自动类型转换<br>虽然这很便利，但是有一定的危险性，尤其是在无意间混合使 用类型的情况下<br>许多UNIX系统都使用lint程序检查类型”冲突”<br>如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题<br>最好先了解 一些基本的类型转换规则</p></blockquote></li><li><p>对于类型的转换大体可以分为两种类型: 分别为升级(promotion)和降级(demotion)</p><blockquote><p>即将选中类型分别转化为被转换类型的更高界别和更低级别的类型</p></blockquote></li><li><p>类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int</p><blockquote><p>例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高<br>之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int</p></blockquote></li></ul><p><strong>规则明细:</strong></p><ol><li><p>当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int</p><blockquote><p>如有必要会被转换成unsigned int(如果short与int的大小相同，unsigned short就比int大，这种情况下，unsigned short会被转换成 unsigned int)<br>在K&amp;R那时的C中，float会被自动转换成double(目前的C不是这样)<br>由于都是从较小类型转换为较大类型，所以这些转换被称为升级(promotion)</p></blockquote></li><li><p>涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别</p></li><li><p>在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型</p><blockquote><p>这个过程可能导致类型升级或降级(demotion)<br>所谓降级，是指把一 种类型转换成更低级别的类型</p></blockquote></li><li><p>当作为函数参数传递时，char和short被转换成int，float被转换成 double</p><blockquote><p>而函数原型会覆盖自动升级</p></blockquote></li></ol><ul><li><p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦</p><blockquote><p>原因很简单: 较低类型可能放不下整个数字<br>例如，一个8位的char类型变量 储存整数101没问题，但是存不下22334</p></blockquote></li><li><p>如果待转换的值与目标类型不匹配怎么办?</p><blockquote><p>这取决于转换涉及的类型<br>待赋值的值与目标类型不匹配时，规则如下:</p></blockquote></li></ul><p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略</p><blockquote><p>例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256</p></blockquote><p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异</p><p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的</p><ul><li><p>如果把一个浮点值转换成整数类型会怎样?</p><blockquote><p>当浮点类型被降级为整数类型时，原来的浮点值会被截断<br>例如，23.12和23.99都会被截断为23，而<code>-23.5</code>会被截断为<code>-23</code></p></blockquote></li><li><p>一般而言不应该混合使用类型(因此有些语言直接不允许这样做)</p><blockquote><p>但是偶尔这样做也是有用的<br>C语言的原则是避免给程序员设置障碍<br>但是程序员必须承担使用的风险和责任</p></blockquote></li></ul><hr><h3 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h3><ul><li><p>一般函数的形式: void xxx(void)</p><blockquote><p>前者的void为函数的关键字，后者括号内的void为函数添加初始变量及其变量的数据类型<br>比如 void pound(int n)，参数名必须遵循C的命名规则</p></blockquote></li><li><p>声明参数时就被创建的变量被称之为形式参数(formal argument或formal parameter)，简称为形参</p><blockquote><p>该例中，形式参数是int类型的变量n，像pound(10)这样的函数调用就会把10赋给n<br>如果此时在主函数main()或其它函数调用了函数pound(times)，就先当于将times的值(5)赋给n<br>此时经由函数调用而传递的值，将被称之为实际参数(actual argument或actual parameter)，简称为实参</p></blockquote></li><li><p>所以，如果执行了函数调用pound(10)，就相当于把参数10传递给函数，然后该函数再把10赋给形式参数(变量n)</p><blockquote><p>也就是说，调用了该函数(pound)的函数中的变量times的值被拷贝给了函数pound()中的新变量n</p></blockquote></li></ul><p><strong>关于实参和形参的其它说明:</strong></p><ul><li><p>在英文中，argument和parameter经常可以互换使用</p></li><li><p>但是C99标准规定了:</p><blockquote><p>对于actual argument或actual parameter使用术语argument(译为实参)<br>对于formal argument或formal parameter使用术语parameter(译为形参)<br>为遵循这一规定，则可以说形参是变量<br>实参是函数调用提供的值，实参被赋给相应的形参</p></blockquote></li><li><p>根据上例，某函数中的times变量则为函数pound()的实参，n则为函数pound()的形参</p><blockquote><p>类似的，在函数pound()函数调用pound(times + 4)中，表达式times + 4的值则为该函数pound()的实参</p></blockquote></li></ul><hr><ul><li>变量名是私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突<blockquote><p>如果在函数pound()中用times代替n，那么这个times与某函数中的times不同<br>也就是说，如果程序中出现了连哥哥同名的变量时，程序是可以自动区分它们的</p></blockquote></li></ul><hr><p><strong>关于函数的调用:</strong></p><ul><li>pound()函数的全称为void pound(int n);</li><li>假如在某程序的某函数中调用了函数pound(int n)，并将某函数中的变量times的值(5)传递给了n<blockquote><p>因此，如果要对该函数调用结果进行输出，必然是五个字符</p></blockquote></li></ul><p><strong>关于函数原型(定义):</strong></p><ul><li><p>程序开头的函数原型</p><blockquote><p>原型(prototype)即是函数的声明，描述了函数的返回值和参数<br>pound()函数的原型说明了两点:<br>该函数没有返回值(函数名前面有void关键字)<br>该函数有一个int类型的参数<br>该例中，函数原型告诉编译器pound()需要一个int类型的参数<br>假如一个被传递的变量值为字符类型或浮点类型，函数pound()中的变量n，会自动改变其自身所属的数据类型<br>即，传递的值为浮点时，就改变为float等等</p></blockquote></li><li><p>在 ANSI C 之前，C 使用的是函数声明，而不是函数原型</p><blockquote><p>函数声明只指明了函数名和返回类型，而并没有指明参数类型<br>为了向下兼容，C 现在仍然允许这样的形式: <code>void pound(); /* ANSI C 之前的函数声明 */</code></p></blockquote></li><li><p>如果在上例中某函数的内部使用了该条声明来代替了<code>pound(int n);</code></p><blockquote><p>由于缺少函数原型，在调用单精度浮点类型float时，会将其自动升级为双精度浮点类型，double类型<br>此时虽然不会发生什么编译上的错误，但是会发生不同程度上的警告<br>此时在函数调用中现实的使用强制类型转换，可以修复此问题: <code>pound ((int)f)</code> // 把f强制类型转换为正确的类型<br>注意，如果f的值太大，超过了int类型表示的范围，这样做也不行<br>强制类型转换强 调了转换类型的意图，对编译器而言也是如此</p></blockquote></li></ul><hr><ul><li>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型</li><li>因此，C会进行自动类型转换<blockquote><p>尽管如此，也不要养成依赖自动类型转换的习惯<br>应该显式选择合适的类型或使用强制类型转换<br>这样就不用担心出现不必要的自动类型转换了</p></blockquote></li></ul><hr><h3 id="补充内容-2"><a href="#补充内容-2" class="headerlink" title="补充内容-2"></a>补充内容-2</h3><ul><li>C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符<blockquote><p>一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值<br>只需要一个 运算对象的运算符(如负号和sizeof)称为一元运算符，需要两个运算对象的运算符(如加法运算符和乘法运算符)称为二元运算符</p></blockquote></li><li>表达式由运算符和运算对象组成<blockquote><p>在C语言中，每个表达式都有一个 值，包括赋值表达式和比较表达式<br>运算符优先级规则决定了表达式中各项 的求值顺序<br>当两个运算符共享一个运算对象时，先进行优先级高的运算<br>如果运算符的优先级相等，由结合律(从左往右或从右往左)决定求值顺序</p></blockquote></li><li>大部分语句都以分号结尾<blockquote><p>最常用的语句是表达式语句</p></blockquote></li><li>用花括号括起 来的一条或多条语句构成了复合语句(或称为块)</li><li>while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句</li><li>在C语言中，许多类型转换都是自动进行的<blockquote><p>当char和short类型出现在 表达式里或作为函数的参数(函数原型除外)时，都会被升级为int类型<br>float类型在函数参数中时，会被升级为double类型<br>在K&amp;R C(不是ANSI C)下，表达式中的float也会被升级为double类型<br>当把一种类型的值赋给 另一种类型的变量时，值将被转换成与变量的类型相同<br>当把较大类型转换 成较小类型时(如，long转换成short，或 double 转换成 float)，可能会丢失数据<br>根据之前介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型</p></blockquote></li><li>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数<blockquote><p>然后，在函数调用中传入的值会被赋给这个变量<br>这样，在函数中 就可以使用该值了</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-运算符与表达式-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-3</title>
    <link href="https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3/"/>
    <id>https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-3/</id>
    <published>2020-03-11T12:31:21.000Z</published>
    <updated>2020-03-11T22:52:25.056Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型-数组/字符串类型-1</strong></center><a id="more"></a><h3 id="数据类型-3"><a href="#数据类型-3" class="headerlink" title="数据类型-3"></a>数据类型-3</h3><ul><li>数据类型/派生类型/数组/字符串</li><li>字符串存储原理</li><li>数组存储原理</li></ul><hr><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>概述:</strong></p><ul><li>字符串(character string)</li><li>本质上是一个或多个字符的序列，即为字符数据类型的数组，可表示为”xxx yyy”</li><li>双引号不是字符串的一部分，双引号只是用于告知编译器括起来的是字符串，正如单引号用于标识单个字符</li></ul><p><strong>char类型数组和null字符</strong></p><ul><li>因为 C 中没有专门用于存储字符串的变量类型，所以字符串都被存储在char类型的数组当中</li><li>数组由连续的存储单元构成，所以字符串中的字符类型都被存储在相邻的存储单元中，即每个单元存储一个字符</li></ul><p><strong>具体图示</strong></p><ul><li>数组中的字符串:</li></ul><img src="/images/字符串-1.png" width="30%" height="30%"><ul><li>这里需要注意的是图片中数组末尾的字符<code>\0</code><blockquote><p>这是空字符(null character)，C内用它来标记字符串的结束<br>空字符并非数字0，它是非打印字符，其ASCII码值是(或称其为等价于)0<br>所以C中的字符串一定以空字符结束，即意味着数组的容量必须比至少比带存储字符串中的字符数多1<br>因此，在一个有若干个存储单元的字符串中，只能存储若干字符串数量减一个字符，剩下一个字节留给空字符</p></blockquote></li></ul><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>概述:</strong></p><ul><li>可以将数组看作是一行连续的多个存储单元</li><li>或称为数组是同类型数据元素的有序序列</li><li>这里用一个包含着40个存储单元(每个单元存储一个char类型的值)且已被创建(已存在)的数组来举例<blockquote><p><code>char name[40];</code><br>name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量，char用于表示每个元素的类型</p></blockquote></li></ul><p><strong>具体图解</strong></p><ul><li>声明一个变量和声明一个数组:</li></ul><img src="/images/字符串声明-1.png" width="30%" height="30%"><ul><li>字符串就是在拥有一个数组的前提下，把字符串中的字符逐个放入数组，同时还要记得在末尾加上一个<code>\0</code><blockquote><p>好在计算机可以自己去处理这些细节问题</p></blockquote></li></ul><hr><ul><li>用格式化输出标识符<code>%s</code>来格式化输出字符串类型，但scanf()函数只会读取字符串中的一个单词，而非整个句子<blockquote><p>此时需要用到其它的输入函数，如<code>fgets()</code>，以用于读取一般的字符串<br>因为本质是由基本字符类型构成的数组，所以字符串的打印顺序与所存储的内存地址也是与字符类型相同的<br>即为完全线性</p></blockquote></li></ul><hr><h3 id="字符串和字符的区别"><a href="#字符串和字符的区别" class="headerlink" title="字符串和字符的区别"></a>字符串和字符的区别</h3><ul><li>字符串常量”x”和字符常量’x’完全不同</li><li>区别之一是在于’x’是基本类型char<blockquote><p>而”x”是派生类型char 数组</p></blockquote></li><li>区别之二是”x”实际上是由两个字符组成的，即为’x’和空字符<code>\0</code></li></ul><p><strong>图片描述:</strong></p><ul><li>字符’x’和字符串”x”:</li></ul><img src="/images/字符和字符串的区别-1.png" width="30%" height="30%"><hr><h3 id="strlen-方法-函数"><a href="#strlen-方法-函数" class="headerlink" title="strlen()方法(函数)"></a>strlen()方法(函数)</h3><ul><li><p>用于输出给出字符串中的字符长度</p></li><li><p>因为1字节存储一个字符，所以给人最直观的感受就是与sizeof运算符(以字节为单位给出对象的大小)的输出相同，但事实绝非如此</p></li><li><p>使用<code>strlen()</code>方法(函数)时需要先对头文件<code>string.h</code>进行预处理<code>#include</code>，以对其进行支持</p></li><li><p>当被定义数组内有40个存储单元，但是只用了不到40个单元用于存储被输入字符串</p><blockquote><p>此时<code>strlen()</code>方法得出的结果是被存储字符串的字符长度，当为11时，即为11个<br>但数组内还需要多出来一个单元用于存储空字符，但<code>strlen()</code>方法并不会将其计入</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>strlen()函数知道在何处停止:</li></ul><img src="/images/strlen机制说明-1.png" width="30%" height="30%"><p><strong>strlen()与sizeof运算符方法的区别</strong></p><ul><li><p>假如让<code>strlen()</code>方法去存储一个常量字符串，<code>strlen()</code>方法将会只返回字符串中的字符(包括空格和标点符号)</p></li><li><p>但是<code>sizeof</code>运算符将会把字符串末尾不可见的空字符也算在内</p></li><li><p><code>sizeof</code>运算符和<code>strlen()</code>方法的格式化输出标识符是通用的，即为<code>%zd</code>转换说明</p><blockquote><p>并且<code>sizeof</code>和<code>strlen()</code>返回的实际类型通常是<code>unsigned</code>或<code>unsigned long</code></p></blockquote></li><li><p><code>sizefo</code>后加不加圆括号取决于运算对象是类型还是特定量</p><blockquote><p>对于类型需要写为类似于<code>sizeof(char)</code>的形式<br>而对于特定量，则可以写成<code>sizeof name</code>的形式<br>只不过每种形式都可以加上圆括号，可以为了增加可读性而去这么做</p></blockquote></li></ul><hr><h3 id="define"><a href="#define" class="headerlink" title="[#define]"></a>[#define]</h3><p><strong>常量和 C 预处理器</strong></p><ul><li><p>如果将全局变量当成常量，程序可能会在无意之间修改它的值</p></li><li><p>所以 C 中为此提供了C 预处理器，预处理器可以用来定义常量</p></li><li><p>基本语法与使用:</p><blockquote><p><code>#define NAME value</code><br><code>#define XXX 0.001</code><br>此时程序中的所有XXX都会被替换称0.001，这一过程被称之为编译时替换(compile-time substitution)<br>通常在运行程序时，程序中所有的替换就均已完成，这样定义常量可将其称之为明示常量(manifest constant)<br>因为预处理器处理的替换机制，所以末尾不用加分号</p></blockquote></li><li><p>在 C 中还有一个约定成俗的规定，常量的命名最好是大写，以便区分程序中其它的变量</p><blockquote><p>另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量(如，<code>c_level</code>或<code>k_line</code>)</p></blockquote></li><li><p>符号常量的命名规则与变量相同，即可以使用大小写的字母，数字，下划线和首位字符不能为数字</p></li><li><p><code>#define</code>指令还可用于定义字符和字符串常量，前者用单引号，后者用双引号</p><blockquote><p>即为<code>#define BEEP &#39;\a&#39;</code>或<code>#define TEE &#39;T&#39;</code><br>需要注意的就是符号常量后面的内容用来代替符号常量</p></blockquote></li></ul><hr><p><strong>const限定符</strong></p><ul><li><p>const关键字于C90标准添加，用于限定一个变量为只读</p></li><li><p>作用与<code>#define</code>相同，并且比其更灵活</p></li><li><p>基本语法:</p><blockquote><p><code>const int XXX = 10</code><br>此时XXX在程序中不可更改，其值为10</p></blockquote></li></ul><hr><p><strong>明示常量:</strong></p><h3 id="limits-h"><a href="#limits-h" class="headerlink" title="limits.h"></a>limits.h</h3><ul><li><p>C内的每个头文件都定义了一系列供实现使用的明示常量</p><blockquote><p>比如C的头文件<code>limits.h</code>和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息</p></blockquote></li><li><p>而<code>limits.h</code>头文件包含了以下类似的代码</p><blockquote><p><code>#define INT_MAX +32767</code><br><code>#define INT_MIN -32768</code><br>这些明示常量代表<code>int类型</code>可表示的最大值和最小值<br>如果系统使用32位的int，该头文件会为这些明示常量提供不同的值</p></blockquote></li><li><p>如果在程序中包含<code>limits.h</code>头文件，就可编写下面的代码:</p><blockquote><p><code>printf(&quot;Maximum int value on this system = %d\n&quot;, INT_MAX);</code><br>如果系统使用4字节的int，<code>limits.h</code>头文件会提供符合4字节int的<code>INT_MAX和INT_MIN</code><br>以下表图片内列出了<code>limits.h</code>中能找到的一些明示常量<br>文章内会对每个头文件的内部构成与使用方法进行刨析<br>每种类型的头文件在系统内的C标准库内都有明确的说明</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li><code>limits.h</code>中的一些明示常量</li></ul><img src="/images/C-头文件/C-limits.h头文件-1.png" width="30%" height="30%"><hr><h3 id="float-h"><a href="#float-h" class="headerlink" title="float.h"></a>float.h</h3><ul><li>类似地，<code>float.h</code>头文件中也定义一些明示常量<blockquote><p>如<code>FLT_DIG和 DBL_DIG</code>，分别表示<code>float类型</code>和<code>double类型</code>的有效数字位数<br>以下表图片内列出了<code>float.h</code>中的一些明示常量(可以使用文本编辑器打开并查看系统使用的float.h头文件)<br>表中所列都与float类型相关<br>把明示常量名中的FLT分别替换成DBL和LDBL<br>即可分别表示double和long double类型对应的明示常量(表中假设系统使用2的幂来表示浮点数)</p></blockquote></li></ul><p><strong>图示说明:</strong></p><ul><li>float.h中的一些明示常量:</li></ul><img src="/images/C-头文件/C-float.h头文件-1.png" width="30%" height="30%"><ul><li>编译器要完全支持C99标准才能识别<code>LLONG_MIN</code>标识符</li></ul><hr><h3 id="printf-方法与scanf-方法"><a href="#printf-方法与scanf-方法" class="headerlink" title="printf()方法与scanf()方法"></a>printf()方法与scanf()方法</h3><p><strong>概述:</strong></p><ul><li><code>printf()</code>函数和<code>scanf()</code>函数能让用户可以与程序实现交互<blockquote><p>它们是基本/标准的输入/输出函数，或简称为I/O函数<br>其除了I/O功能，还有很多其它的功能<br>因为考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()，尽管如此，各版本之间偶尔有一些差异<br>而C90 和C99 标准规定了这些函数的标准版本<br>虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同<br>两个函数都使用格式字符串和参数列表</p></blockquote></li></ul><hr><p><strong>printf()</strong></p><ul><li><p>请求<code>printf()</code>函数打印数据的指令要与待打印数据的类型相匹配</p><blockquote><p>例如， 打印整数时使用<code>%d</code>，打印字符时使用<code>%c</code><br>这些符号被称为转换说明(conversion specification)，即为格式化输出标识符<br>它们指定了如何把数据转换成可显示的形式。</p></blockquote></li><li><p>以下列表图片为ANSI C标准为<code>printf()</code>提供的转换说明与搁置相对应的输出类型</p></li><li><p>转换说明及其打印的输出结果:</p></li></ul><img src="/images/C-标准库/C-printf函数-1.png" width="30%" height="30%"><hr><h3 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h3><ul><li>格式字符串包含两种形式不同的信息:<blockquote><p>实际要打印的字符<br>与转换说明</p></blockquote></li></ul><p><strong>图片说明:</strong></p><ul><li>printf()的参数</li></ul><img src="/images/printf格式-1.png" width="20%" height="20%"><ul><li>剖析格式字符串图片:</li></ul><img src="/images/字符串格式-1.png" width="20%" height="20%"><ul><li>格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果</li></ul><hr><p><strong>printf()的转换说明修饰符</strong></p><ul><li>在%和转换字符之间插入修饰符可修饰基本的转换说明</li><li>转换说明修饰符类型的可移植性需要特别注意</li><li>整数类型和浮点数类型使用不同类型的转换类型</li><li>关于转换说明修饰符的列表这里不做过多阐述</li><li>可参考[C Primer Plus 第6版-中文版]-第201页</li></ul><hr><p><strong>转换说明的意义:</strong></p><ul><li><p>转换说明把以二进制格式储存在计算机中的值转换成一系列字符(字符串)以便于显示</p><blockquote><p>例如，数字76在计算机内部的存储格式是二进制数01001100<br><code>%d</code>转换说明将其转换成字符7和6，并显示为76<br><code>%x</code>转换说明把相同的值(01001100)转换成十六进制记数法4c<br><code>%c</code>转换说明把01001100转换成字符L</p></blockquote></li><li><p>转换(conversion)可能会误导读者认为原始值被转替换成转换后的值</p><blockquote><p>实际上，转换说明是翻译说明<br><code>%d</code>的意思是”把给定的值翻译成十进制整数文本并打印出来”</p></blockquote></li></ul><hr><h3 id="scanf-方法简述"><a href="#scanf-方法简述" class="headerlink" title="scanf()方法简述"></a>scanf()方法简述</h3><ul><li><p>输入函数-scanf()</p><blockquote><p>scanf()是最通用的一个输入函数，因为其可以读取不同格式的数据</p></blockquote></li><li><p>如果要将其储 存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的</p></li><li><p>scanf()把输入的字符串转换成整数，浮点数，字符或字符串</p><blockquote><p>而printf()正好与它相反，把整数，浮点数，字符和字符串转换成显示在屏幕上的文本</p></blockquote></li><li><p>scanf()和printf()类似，也使用格式字符串和参数列表</p><blockquote><p>scanf()中的格式 字符串表明字符输入流的目标数据类型<br>两个函数主要的区别在参数列表中<br>printf()函数使用变量，常量和表达式，而scanf()函数使用指向变量的指针<br>关于指针的两条最简单的规则:<br>如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;<br>如果用scanf()把字符串读入字符数组中，不要使用&amp;</p></blockquote></li><li><p>scanf()函数使用空白(换行符，制表符和空格)把输入分成多个字段</p><blockquote><p>在依次把转换说明和字段匹配时跳过空白</p></blockquote></li><li><p>scanf()函数所用的转换说明与printf()函数几乎相同</p><blockquote><p>主要的区别是，对 于float类型和double类型<br>printf()都使用<code>%f</code>,<code>%e</code>,<code>%E</code>,<code>%g</code>和<code>%G</code>转换说明<br>而scanf()只把它们用于float类型，对于double类型时要使用l修饰符</p></blockquote></li><li><p>C99-ANSI C中scanf()的转换说明这里不做过多赘述，可参考书籍</p></li><li><p>scanf()进入输入的原理与对应的物理模式这里不做阐述，将来会对其进行补充</p><blockquote><p>转换符和I/O函数不需要学的特别细，具体的使用和记忆可以在实践中执行</p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型-数组/字符串类型-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="C/C++" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/C-C/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-2</title>
    <link href="https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/"/>
    <id>https://unit-serow.github.io/2020/03/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-2/</id>
    <published>2020-03-11T05:15:27.000Z</published>
    <updated>2020-03-11T12:36:44.806Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>存储原理-算术类型-1</strong></center><a id="more"></a><h2 id="基本数据类型存储原理"><a href="#基本数据类型存储原理" class="headerlink" title="基本数据类型存储原理"></a>基本数据类型存储原理</h2><ul><li>数据类型系统-基本类型</li><li>算术类型，其包含了整数类型与浮点类型</li><li>这里的数值大小以 C 的 C11 标准为例<blockquote><p>C 标准对基本数据类型只规定了允许的最小大小</p></blockquote></li></ul><hr><ul><li>常用基本数据类型占用空间(64位机器为例)</li></ul><ol><li>整数类型/char: 1个字节</li><li>整数类型/int: 4个字节</li><li>浮点类型/float: 4个字节</li><li>浮点类型/double: 8个字节</li></ol><ul><li>以 ISO C 标准为例<blockquote><p>此规定规定int的取值范围最小为<code>-32768～32767</code></p></blockquote></li></ul><hr><h2 id="整数存储原理"><a href="#整数存储原理" class="headerlink" title="整数存储原理"></a>整数存储原理</h2><ul><li>在计算机内的整数与数学一样，即为没有小数部分的实数</li><li>计算机以二进制数字的模式来存储整数</li><li>存储的位置即为变量标识符所对应的内存地址，与其指令集所指的CPU寄存器</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>同时还可将其称之为数据类型系统的基本类型部分</li><li>被归纳于算术类型，包括了整数类型与浮点类型</li><li>这里以C为例</li><li>C语言中的整数类型可表示不 同的取值范围和正负值，一般情况使用int类型即可，但是为满足特定任务和 机器的要求，还可以选择其他类型</li><li>int类型是有符号整型，即int类型的值必须是整数，可以是正整数，负整数或零</li><li>一般而言，储存一个int要占用一个 机器字长</li><li>声明之后便为被声明的若干个int大小的变量赋予名称并分配内存空间</li><li>可以赋值或初始化变量(initialize)</li><li>简而言之，声明为变量创建和标记存储空间，并为其指定初始值</li><li>C语言把大多数整型常量视为int类型，但是非 常大的整数除外</li><li>并且int类型拥有常量概念</li></ul><p><strong>声明执行逻辑图示:</strong></p><ul><li>定义并初始化变量:</li></ul><img src="/images/整数类型原理图片/数据类型声明-1.png" width="30%" height="30%"><p><strong>举例说明:</strong></p><ul><li>例如7则以对应的二进制111来存储<blockquote><p>因此，要在8位字节中储存 该数字，需要把前5位都设置成0，后3位设置成1</p></blockquote></li></ul><p><strong>图解说明:</strong></p><ul><li>使用二进制编码储存整数7</li></ul><img src="/images/整数类型原理图片/整数类型-1.png" width="30%" height="30%"><hr><h3 id="关于整数值的范围"><a href="#关于整数值的范围" class="headerlink" title="关于整数值的范围"></a>关于整数值的范围</h3><p><strong>整数类型</strong></p><ul><li>下表列出了关于标准整数类型的存储大小和值范围的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 字节</td><td align="left">-128 到 127 或 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">2 或 4 字节</td><td align="left">-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned int</td><td align="left">2 或 4 字节</td><td align="left">0 到 65,535 或 0 到 4,294,967,295</td></tr><tr><td align="left">short</td><td align="left">2 字节</td><td align="left">-32,768 到 32,767</td></tr><tr><td align="left">unsigned short</td><td align="left">2 字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">long</td><td align="left">4 字节</td><td align="left">-2,147,483,648 到 2,147,483,647</td></tr><tr><td align="left">unsigned long</td><td align="left">4 字节</td><td align="left">0 到 4,294,967,295</td></tr></tbody></table><ul><li>同时还可以使用sizeof运算符，即表达式sizeof(type)，以获取某个类型或某个变量对象或存储类型在特定硬件平台的准确存储字节大小</li></ul><p><strong>图解说明</strong></p><ul><li>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主<blockquote><p>以下列出了32位系统与64位系统的存储大小的差别(windows 相同):</p></blockquote></li></ul><img src="/images/整数类型原理图片/C-32-64.png" width="30%" height="30%"><hr><h2 id="浮点类型存储原理"><a href="#浮点类型存储原理" class="headerlink" title="浮点类型存储原理"></a>浮点类型存储原理</h2><ul><li><p>在计算机中，浮点数与数学中实数的概念差不多</p></li><li><p>比如<code>2.75</code>,<code>3.16E7</code>,<code>7.00</code>和<code>2e-8</code>都是浮点数，即在一个值后面加上一个小数点，该值就成为一个浮点值</p></li><li><p>所以7是整数，<code>7.00</code>是浮点数</p></li><li><p>e记数法简述: <code>3.16E7</code>表示<code>3.16×10^7</code>，其中E的作用就是10倍原数的对应指数级单位</p></li><li><p>浮点数和整数的储存方案不同</p></li><li><p>计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分</p></li><li><p>在十进制下，可以把7.0写成 0.7E1，但这里，0.7是小数部分，1是指数部分</p></li><li><p>当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂</p></li><li><p>整数没有小数部分，浮点数有小数部分</p></li><li><p>且浮点数可以表示的范围比整数大</p></li><li><p>对于一些算术运算(如，两个很大的数相减)，浮点数损失的精度更多</p></li></ul><p><strong>图示说明:</strong></p><ul><li>一个储存浮点数的例子，以浮点格式(十进制)储存π的值</li></ul><img src="/images/整数类型原理图片/浮点数类型.png" width="30%" height="30%"><ul><li>因为在任何区间内(如，1.0 到 2.0 之间)都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值</li><li>浮点数通常只是实际值的近似值</li><li>例如，7.0可能被储存为浮点值6.99999，稍后讨论精度</li><li>在过去，浮点运算比整数运算慢</li><li>不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距</li></ul><hr><h3 id="关于浮点值的范围"><a href="#关于浮点值的范围" class="headerlink" title="关于浮点值的范围"></a>关于浮点值的范围</h3><p><strong>浮点类型</strong></p><ul><li>下表列出了关于标准浮点类型的存储大小、值范围和精度的细节：</li></ul><table><thead><tr><th align="left">类型</th><th align="left">存储大小</th><th align="left">值范围</th><th align="left">精度</th></tr></thead><tbody><tr><td align="left">float</td><td align="left">4 字节</td><td align="left">1.2E-38 到 3.4E+38</td><td align="left">6 位小数</td></tr><tr><td align="left">double</td><td align="left">8 字节</td><td align="left">2.3E-308 到 1.7E+308</td><td align="left">15 位小数</td></tr><tr><td align="left">long double</td><td align="left">16 字节</td><td align="left">3.4E-4932 到 1.1E+4932</td><td align="left">19 位小数</td></tr></tbody></table><ul><li>头文件<code>float.h</code>定义了宏，在程序中可以使用这些值和其他有关实数二进制表示的细节</li></ul><hr><h2 id="C-数据类型转换"><a href="#C-数据类型转换" class="headerlink" title="C 数据类型转换"></a>C 数据类型转换</h2><ul><li>C 语言中如果一个表达式中含有不同类型的常量和变量，在计算时，会将它们自动转换为同一种类型</li><li>在 C 语言中也可以对数据类型进行强制转换</li></ul><p><strong>自动转换规则:</strong></p><ol><li>浮点数赋给整型，该浮点数小数被舍去；</li><li>整数赋给浮点型，数值不变，但是被存储到相应的浮点型变量中；</li></ol><ul><li>强制类型转换形式: [(类型说明符) (表达式)]</li></ul><hr><h3 id="关于不同进制的说明"><a href="#关于不同进制的说明" class="headerlink" title="关于不同进制的说明:"></a>关于不同进制的说明:</h3><ul><li><p>2进制，8进制和16进制</p></li><li><p>以0为前缀用于表示8进制</p><blockquote><p>比如十进制转换为8进制则为020</p></blockquote></li><li><p>以0x或0X为前缀用于表示16进制</p><blockquote><p>比如十进制数转为16进制则为0x10或0X10</p></blockquote></li><li><p>使用不同的进制是为了方便，其可以完全保证不会影响被存储的方式</p></li><li><p>可以使用标识符<code>%d</code>，<code>%o/%x</code>来分别显示(格式化输出)八进制与十六进制数字</p></li><li><p>而使用标识符<code>%#o</code>，<code>%#x</code>，<code>%#X</code>可以显示各进制的前缀(0，0x和0X)，也就是分别在转换(格式化输出)的说明中假如警号(#)</p></li></ul><hr><ul><li>整数类型还包括char-字符类型与其它的表示符类型，比如像long，short等等，这里先不做过多赘述</li><li>字符类型还包括了字符与字符串(String)的概念</li></ul><hr><p><strong>图片资料补充:</strong></p><ul><li>转义序列(转义标识符)图示:</li></ul><img src="/images/整数类型原理图片/转义标识符-1.png" width="30%" height="30%"><ul><li>int系列类型的常量写法示例:</li></ul><img src="/images/整数类型原理图片/int中的常量写法.png" width="30%" height="30%"><hr><h3 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h3><ul><li><p><code>scanf()</code>函数中的&amp;标识符用于把输入的字符赋值给所对应变量</p><blockquote><p>相当于创建了一个指向变量其它数据对象位置的指针</p></blockquote></li><li><p>而格式化输出标识符(转换符)</p><blockquote><p>类似于<code>%c</code>，<code>%o</code>，<code>%d</code>，<code>%f</code>之类的<br>作用是决定数据的显示方式，而不是存储方式</p></blockquote></li><li><p>数据显示和数据存储的示例图片:</p></li></ul><img src="/images/格式化输出标识符-1.png" width="40%" height="40%"><hr><ul><li>编译器对char的实现也有不同，有的将其实现为有符号类型，即代表char可表示的范围是-<code>128~127</code></li><li>而有些C编译器把char实现为无符号类型，即为表示-<code>0~255</code></li><li>至于想要准确的确定正在使用的编译器是如何实现<code>char类型</code>的，可以去查询相应的编译器手册与<code>limits.sh</code>头文件</li><li>但是根据C90标准，C内允许在char关键字钱使用<code>signed</code>与<code>unsigned</code>标识符，以此来消除编译器对char默认类型的影响</li><li><code>signed char</code>表示有符号类型，而<code>unsigned char</code>表示无符号类型</li></ul><hr><h3 id="类型归纳列表"><a href="#类型归纳列表" class="headerlink" title="类型归纳列表"></a>类型归纳列表</h3><p><strong>基本数据类型</strong></p><ul><li>关键字:</li><li>基本数据类型由11个关键字组成: <code>int</code>、<code>long</code>、<code>short</code>、<code>unsigned</code>、<code>char</code>、 <code>float</code>、<code>double</code>、<code>signed</code>、<code>_Bool</code>、<code>_Complex</code>和<code>_Imaginary</code></li></ul><p><strong>有符号整型:</strong></p><blockquote><p>有符号整型可用于表示正整数和负整数</p></blockquote><ul><li><code>int</code>——系统给定的基本整数类型<blockquote><p>C语言规定<code>int类型</code>不小于16位</p></blockquote></li><li><code>short</code>或<code>short int</code>——最大的<code>short类型</code>整数小于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>short类型</code>至少占16位</p></blockquote></li><li><code>long</code>或<code>long int</code>——该类型可表示的整数大于或等于最大的<code>int类型</code>整数<blockquote><p>C语言规定<code>long类型</code>至少占32位</p></blockquote></li><li><code>long long</code>或<code>long long int</code>——该类型可表示的整数大于或等于最大的<code>long类型</code>整数<blockquote><p>Long long类型至少占64位</p></blockquote></li></ul><hr><ul><li>一般而言，<code>long类型</code>占用的内存比<code>short类型</code>大<blockquote><p>int类型的宽度要么和<code>long类型</code>相同，要么和<code>short类型</code>相同<br>例如，旧DOS系统的PC提供16位的short和int，以及32位的long<br>Windows 95系统提供16位的short以及32位的int 和long</p></blockquote></li></ul><hr><p><strong>无符号整型：</strong></p><ul><li><p>无符号整型只能用于表示零和正整数</p><blockquote><p>因此无符号整型可表示的正整数 比有符号整型的大</p></blockquote></li><li><p>在整型类型前加上关键字<code>unsigned</code>表明该类型是无符号整型: <code>unsignedint</code>、<code>unsigned long</code>、<code>unsigned short</code></p><blockquote><p>单独的<code>unsigned</code>相当于<code>unsignedint</code></p></blockquote></li><li><p>字符类型:</p></li><li><p>可打印出来的符号(如A，&amp;和+)都是字符</p><blockquote><p>根据定义，<code>char类型</code>表示 一个字符要占用<code>1字节</code>内存<br>出于历史原因，<code>1字节</code>通常是8位，但是如果要表示基本字符集，也可以是<code>16位</code>或更大</p></blockquote></li><li><p>char——字符类型的关键字<br>》 有些编译器使用有符号的char，而有些则使用无符号的char<br>》 在需要时，可在char前面加上关键字<code>signed</code>或<code>unsigned</code>来指明具体使用哪一种类型</p></li><li><p>布尔类型:</p></li><li><p>布尔值表示<code>true</code>和<code>false</code></p><blockquote><p>C语言用1表示<code>true</code>，0表示<code>false</code></p></blockquote></li><li><p><code>_Bool</code>——布尔类型的关键字</p><blockquote><p>布尔类型是无符号<code>int类型</code>，所占用的空间只要能储存0或1即可</p></blockquote></li><li><p>实浮点类型:</p></li><li><p>实浮点类型可表示正浮点数和负浮点数</p></li><li><p>float——系统的基本浮点类型，可精确表示至少6位有效数字</p></li><li><p>double——储存浮点数的范围(可能)更大，能表示比<code>float类型</code>更多的有效数字(至少 10位，通常会更多)和更大的指数</p></li><li><p>long long——储存浮点数的范围(可能)比double更大，能表示比double更多的有效数字和更大的指数</p></li><li><p>复数和虚数浮点数:</p></li><li><p>虚数类型是可选的类型</p></li><li><p>复数的实部和虚部类型都基于实浮点类型来构成:</p><blockquote><p><code>float _Complex</code><br><code>double _Complex</code><br><code>long double _Complex</code><br><code>float _Imaginary</code><br><code>double _Imaginary</code><br><code>long long _Imaginary</code></p></blockquote></li></ul><hr><h3 id="打印出类型大小"><a href="#打印出类型大小" class="headerlink" title="打印出类型大小"></a>打印出类型大小</h3><ul><li><p><code>sizeof()</code>函数的使用</p></li><li><p>sizeof是 C 的内置运算符，用于以字节为单位给定指定的类型大小</p><blockquote><p>C99和C11提供<code>%zd</code>转换说明匹配sizeof的返回类型<br>而一些不支持C99和C11的编译器可以用<code>%u</code>或<code>%lu</code>来代替<code>%zd</code></p></blockquote></li><li><p>示例程序:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type int has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type char has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long long has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" Type long double has a size of %zd bytes.\n"</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">double</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输出结果:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Type int has a size of 4 bytes.</span><br><span class="line">Type char has a size of 1 bytes.</span><br><span class="line">Type long has a size of 8 bytes.</span><br><span class="line">Type long long has a size of 8 bytes.</span><br><span class="line">Type double has a size of 8 bytes.</span><br><span class="line">Type long double has a size of 16 bytes.</span><br></pre></td></tr></table></figure></li><li><p>该程序列出了6种类型的大小，也可以把程序中类型换成的其他类型</p><blockquote><p>注意，因为C语言定义了<code>char类型</code>是1字节，所以<code>char类型</code>的大 小一定是1字节<br>而在<code>char类型</code>为16位，<code>double类型</code>为<code>64位</code>的系统中，<code>sizeof</code>给出的<code>double</code>是4字节</p></blockquote></li><li><p>在<code>limits.h</code>和<code>float.h</code>头文件中有类型限制的相关信息</p><blockquote><p>顺带一提，注意该程序最后几行<code>printf()</code>语句都被分为两行<br>只要不在引号内部或一个单词中间断行，就可以这样写</p></blockquote></li></ul><hr><h3 id="printf-方法与scanf-方法补充内容"><a href="#printf-方法与scanf-方法补充内容" class="headerlink" title="printf()方法与scanf()方法补充内容"></a>printf()方法与scanf()方法补充内容</h3><ul><li><p><code>printf()</code>和<code>scanf()</code>函数用第1个参数表明后续有多少个参数</p><blockquote><p>即第1个字 符串中的转换说明与后面的参数一一对应<br><code>printf(&quot;A %d B %f&quot;, xxx, yyy)</code><br>即A对应于xxx，B对应于yyy</p></blockquote></li><li><p>程序员要负责确保转换说明的数量，类型与后面参数的数量，类型相匹配</p><blockquote><p>现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确<br>但是，该机制对<code>printf()</code>和<code>scanf()</code>不起作用，因为这两个函数的参数个数可变</p></blockquote></li></ul><hr><ul><li><p>C语言提供了大量的数值类型，目的是为程序员提供方便</p><blockquote><p>那以整数类型为例，C认为一种整型不够，提供了有符号，无符号，以及大小不同的整型，以满足不同程序的需求</p></blockquote></li><li><p>计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别</p><blockquote><p>即使两个32位存储单元储存的位组合完全相同，但是一个解释为<code>float类型</code>，另一个解释为<code>long类型</code><br>这两个相同的位组合表示的值也完全不同。<br>例如，在PC中，假设一个位组合表示<code>float类型</code>的数256.0<br>如果将其解释为<code>long类型</code>，得到的值是113246208<br>C语言允许编写混合数据类型的表达式， 但是会进行自动类型转换<br>以便在实际运算时统一使用一种类型</p></blockquote></li><li><p>计算机在内存中用数值编码来表示字符</p><blockquote><p>美国最常用的是<code>ASCII码</code>，除此之外C也支持其他编码<br>字符常量是计算机系统使用的数值编码的符号表示<br>它表示为单引号括起来的字符，如<code>&#39;A&#39;</code></p></blockquote></li><li><p>需要完全理解通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型</p></li><li><p>浮点数可以写成固定的小数点的形式或指数形式，C99和C11提供了第三章的表示方法，即用十六进制数和二的幂来表示(如，<code>0xa.1fp10</code>)</p></li><li><p>C语言中用单引号<code>&#39; &#39;</code>来表示字符常量，还有转义序列的概念(<code>&#39;\n&#39;</code>)，另外，还可以在八进制和十六进制数前面加上一个反斜杠(如: ‘\007’)，用以表示ASCII码中的一个字符</p></li><li><p>还可可移植数据类型等概念</p><blockquote><p>C99新增了两个头文件<code>stdint.h</code>和<code>inttypes.h</code></p></blockquote></li><li><p><code>printf()</code>函数根据转换说明打印各种类型的值</p><blockquote><p>转换说明最简单的形式由一个百分号(%)和一个转换字符组成，如<code>%d</code>或<code>%f</code></p></blockquote></li></ul><hr><p><strong>转义序列(格式化输出标识符)-URL参考列表:</strong></p><ul><li><p>CN-CSDN-C语言中字符串的格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/hudashi/article/details/7080078</code></p></blockquote></li><li><p>CN-CSDN-C字符串格式化<a href="https://blog.csdn.net/hudashi/article/details/7080078" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/mcxfate/p/10618114.html</code></p></blockquote></li><li><p>CN-CSDN-C 和 C++ 字符串格式化<a href="https://blog.csdn.net/freeking101/article/details/78935559" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://blog.csdn.net/freeking101/article/details/78935559</code></p></blockquote></li><li><p>c/c++的字符串格式化汇总<a href="https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html" target="_blank" rel="noopener">跳转</a></p><blockquote><p><code>https://www.cnblogs.com/zouhao/archive/2013/05/07/3064565.html</code></p></blockquote></li></ul><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;存储原理-算术类型-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-10</title>
    <link href="https://unit-serow.github.io/2020/03/10/%E9%9A%8F%E7%AC%94-2020-03-10/"/>
    <id>https://unit-serow.github.io/2020/03/10/%E9%9A%8F%E7%AC%94-2020-03-10/</id>
    <published>2020-03-10T15:28:28.000Z</published>
    <updated>2020-03-14T03:57:21.061Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b8fa5e3a7370ceafdd683447a837b843d5c40e9697d8f58957433ca20701db48">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546eb57a7aedb992ebf8d61f9bf4179540a67b24eba202d8da36defce2e3c83376cd737a38d8e3cd8ef21820898fa3d9a87c0311e97bf2c1cb7b1b4bd5a06e8854adc40112e0336489dba20e16c4eb8a4a441f9b31f3937722d4812c6cb85497679b3b5f648f7251f747c00428a3851dff6ee04e8d7ccb2dbdfb864c97ba18256586ca76d9bca2e8ba622869b0f5859703fd39f4e18010de815d068bcf3e458f6d2237a46740ce3720a9bddd97861f21605b9112ebfe1e2a2e1334478af69065b12c0351a3637a85861f2b44290292c70889cc1a560b6e34094c2ca0c21b15743a113ef56333cc2878a9cc1821c14784ba54929b165106109eee060ed163bd64c84a1df5497c9998ba233c2796018ef26d49092e780522e0b6b20bd20c5235340c466c6f97b9a8f9afb0b43966112385f49aae5b89c897342b9d21b66a5f6a2f96a6fbfc4396e37adbe66e8cfbdf89e8c26867f7c4b7660b839945038ea743b969bc01e9af277d02e7071e71c646bbe72da2890e1a64c71b843d6322431d27262787a322a0b2142bba220125fbd16e89fd9e55df8637c867b1e2eae48e76351e9b81b7d56186585f5fea079e7b7adf940409561ed15c7d9b350cc833a3c11e9d95e2fc202553278b6463aa100ac40b916253cc62761f012fbb2506964e4568c355e5bfd23bc77cbca28c8364d8fc2c4731c29ffe60b918f3d2585a25183330e519d02eee3529795de16c896a2ecfd7edcbd16e476c7a32a0f7fa76097e8c68a69769791f36f33f080f48b66814bc6209b12e06b2dae5a21a010a6194025c91e6740d342c35c35ae465e33c00ff93684370737e70cc578fc1fee457eeb0318471f8ad8ba5ec793000ce4849a686e454c7026cf8bc3599e5b2454d6d0238f1cda8becea4f3bb9dc5aacde48f0ca9400cfd146036c578c64bc83a39276ddc58b190ac060e47a5b44c9c15d9aed1b1cbc65b0d7b1203aea29f7185c3969fe2ea79dd8000d6340390b6a77a932688b8866dce1e4b66597d8ed281777b2f735886ffb3c93c044341e8abf681df5117bbd9a91426066dc462db58f8018797387f86681083678a258ff7d72d65ea8989444e1f4e1daf71675bd4f55e724689d82deb9a700f3600bf3c78eb963aba145a68c264ece55766ce007d79965eec772d3db9d157ce5f1ade849a7bfbbb40e52a9824c178aac93adaa95b471f84917530bf1e61479cfff579dcabf3b01c6430d6ef6ead8053d4566c341a02a621e3f1ea7ad7968781f4127572fa8fe7d25abf9c1c2050326f880f69bf4fb01eebc356bccaeb1721dea753b406dae4edbccb2702851751efc64ed7c03658064dfdedf83ad42407c2b1cfba5d4e1fc95a9610261ccc4f9845cf7abf47b57094a7c3aac374f10a2b834a4fde2d8915f5531d8c8d57abd8d5771f12c9288736a5751685a037efb1df1527d7a47700fde583543effb83e1f6c5241349aeb1eddb67ce3e0a5ae6675a4fa78942a9afb2852fe497aca91e9c6f4be069ab1a70e1924e67aaa3e998ac50c493787753b3307e53337525370aa36ea520174d21297da2d2c2680908dd514a06c18392501f7bf797da2bbcedf4b4f5d9e21bb8bd7c1afb1271fbefec6701108a034235251d46893c4cd8b1553166ad80db8a0c0db09a88adf584889bcc1dff424761b14c5f46541cce44017def2ab37835bcf11aadcc7efb555fcc5f45be5af6b691c40dfd1f6f71885c60997caf51c1ccdc5b31d1d01502aed037cb3e7c1030524d90194c470aac79c3bcc1706f52ecd6d6f811dd08648b225893f7941c7337b0a08657165da7fc3748fc88ecec4de7ac1c5cb55424f68c3827add4f1f7f1784fd4cdd8a4fc6d29f27bf9f9f4cb1abb1aa1e07394e35a717e4c6f2deb2b356608ea8d5fa3cb7beb71cd0d1124aaeb3af2f570b0d56cb0093abe558dab4fb018afa4164fe473cca7a0eeb83ee77d80049af82717ab697d4f33dff7da96b2f66b10b4483abe07f9149b20eb75ecfb1136173bf65d7e2b5b657706ffde63d01111430eeb25c4aa1b4114fa9da830993320720d272500e22ac3d100dbf53cc812c5b42a7684f87f70cea6628b57d5ada20b3c603f4fda3639689f852e76496299ca69d90a4f1cc5d84b9dc091e5f9b55d9ab29fc1ec67a369a2d484c32a47ed8794bfff7b5a87eeddfce0379c7319b34bbdc59e9546cc8fab104b27fab4fd0d58617a2692e0e6394981187f45f15ed15e186307f3b746a94e212f722f51df6e88b488fcad0a30d3a272e68bc923d28766ab0a3a65d4008aac97dec2f44eda9af6a3880cd9902beb7b2cce6b770c19fff7b3c6f32d0d72e674df5b17621483edbf061d7e7caf4153bb622363a5a79ab3df5b227f7bf0bec75981e558e19c9f84228724e6097630e52233738a47bd851603b26e1774faff6ac2e6048df55dc92fdf2d1ec996b9787c4a59179c93049571dca848f8f24730b842774c227bd74fa02b3c8017e682e5bf4880f8e93fe50cc3a64865b068ae47919d4acf09ed768d1e2a260a12e552e7464c154052d7ac80025115414f6fda8f3e96d082720912499a42f8e5cd9ced4c65b43340cbd032aa834b5f89b23eb5f0717123299a95d2b50809b89c1e255602429fd22b9990c7ba48fab07b1fd5d1953ee0bd67e0646e5c454cac402085063a3350f5ce161fe05bd7af62f0f2a2021c9a1a11195dda1d64a7d60c414fff7d83fea6405ef4288fdcee5a71a1dfc10f19bbd8e2dd062ff65f7b7a292c62a0646ac6a6ff8e65dd04e22a4ca18aaa8d13b8d7e64576c0b375e057228d2f933b588683aa1026a12e8eb960ed2f4068d3902cc83d7d75d9e65460a529be569b69a8483d0d26886cb65cea455c02c439dd446f157343564f71c92d0d004d40e09c158d8c94b511ddc925e1b364501796e876252648b03ec85589060d27128f603f83f0ae58fb2d6b461cc4cb7562cc3cf7324858e707ec6399e03ab4eac58b16c926b2422299c79b6869c2cc52300e6d51b9c0c09febef2e583c596a097af44cd57d25e847eb2fd2c9140e467e590c23a60e28510a672477a459dfa3de59f070f8533a9d5f997cb326b86cfc4c93f7a3af6cc6e67fe2bdc45d9cbf0c22772a6df3b139ee028d95724b41eb5625ac30ad3c4bf575ba493055736feb1446670f8fb824150c177459b6383570bf1f7ffe96f8e5854136e630b3eaa09f853a596ae17685cd9a4867d6acd2588c9b087ed6365a1cf4607fb92124b62cb54e4f495c3e4361771d07b61e4c5fb748dbae023d281e389b8cd794a4363561ca9102c884319f56b3fff58145c27286e976dff176d89d547b2fe2f9d10b5e1ccbb8e92e687012aa55ff66faf6194eee020ea4d8480a02e7109e52ea6f8f0f26730c21eeac9f59891612900d2f59772322b8a041f6eb207f2ec062c06d052c4e65aaffc89cf45ee7387016776801bf7959370a8aa8562bed00c9b9d7150acef7988dad3860f3e9b958df39eb24c90e702a46fe93fe236ee84d48e8083cb51a0d86b1dcd1bbd41310d53b8ba929d8187381df3c8ac1e3805a0295b2e7e9b5dbebcfc71471a6ffd4e2c0aff37bda62d70afd374248625bb95297bc88bfb6dc3ed6a88e374a7eb882868f0fa9a1bae6e8a085d8394b8cf2b5b1574b37da60046ca552eaee292021b8eb5eb9b4173e91ec6a499e86f153680f93934c60423cd7e3b681600ce0f127b1de6c79433fd6d7b32986a9f616f39265077a23bf4d42d405145a160e91b7215393003f649ca1aaa5f2ac671ddf708ca4a49c7b715f1cc1e771bf828a50259b86af7570cc29df90b4123385eeddd862c11f4047ae8fd64d6f5fb0afdc5cec0210c4e4b44576962e0124b45d6f9c94be0bd42fdf49984c62e1d120b445698a58b088b99b72c09267568fbf5d997741a44ec5c45df0f3803386069295255538823c70c3977f54c68505cbb6998a0d7c383e1d16cdcc199bddfb2df6861e3f204d1e68aba78884cfb2357cbb94caa74bf5afccd8773f81d7c77c948c785b0c842fa2b31a271b80929685ced7072a388f13547889fd8d3336ea8466fa8060afd4f27409b3ed1f9ee3dff83656a43f81c387f42009f661bcd7cb374eeb8320d797e7797720b9a325069dc2a861ee2c69b8020e84ba9dbda6aa05204e29adaab9f7e718d3ecca9189cd87fbe68a7d5059c416bbf123ac8daed5069be624f93d662a17007d8bacceeea490d26958ab336e9aa1b34a4a12ba321323e399eddf837ab6d04d002be7b31a6c8824b2ebf5aff02e36fc456dae631923ae03eb38b90a4f7f2b75cfe74cc7784b7773daee9d07f77391ceecddee3700db79a1fb9a17dc3cf17604d0906b3a96cac9e7dbc690ef61627d73f13e21cb4a1055b9acb20b7864fa120f28c74aee261e4635b43e2fbe509d0b601be38ba67f28644d55f8d09b964013ffc21e76cbffd6b6047efa2f138fbaf027c65dd11316c54631ef60159214b8e949c9bd3c4fab5e23b65360d6b0d7dd733a21ff9fb2e1bc73d06c75de0fa746b79efca6667d5f77c6bba77cc125d380934fe846d684f4d1363bbf8aef3abac4b4fb8ccef9a32606250b002fa023447a1a8d190652f931e8f39c2f774b3a8f831bb6130e33fabc49e0976f26222ac535b3ec4d9eb0ee82418e0f6239643bf443cbe34be7228084faaf3e311e0058d06938dacab9a6ee47f1f67988db5ccc260ca1114b784a1fbe24b38cca1fa05ab37660ce05c86be31ebff0129e194c9d5c1fe8ed0ca0e13c8629bca640bfa9ff20e1103e892a058a1961e44e0bce4bc8f012300d71dfaf78a0b4ecda2f5665e76c0b08467f5e3b6843d1dd25a9f46912874d18af90f6047451069e22934a416150c4ebb318833b233478ae9aa5d8c9981d6a7328b9851780c5ad158503848b52c374974a474bf37f0293ca2e5ddcf714e6bb1fabbc62a3866bfa89a1e7dee7ae78688c9add84cc0d0469bb3d787364f9cdd27435335d4ad1c421e037ccde04a88179c682e56ba404b4fbc23981a1ccb3c4e86fc27f79209bf1767e5ebfe4e376058134066b8499178f15638fb21e13dcd7feb4dfbb9b5182b326f82b9a6c2002abdef0dc4dd8bd1da6664d412814e027e2f8c1c5e05d836fac793dbf79f6e3b1b19cd8a100914183ff84e2aca70d12972ba0e675fa643337c09aee2600609a6692b0843fba28fbba82bb0c7a95afe211d39e3a1df24ecc3fe71d3bd3b6dde226eb2731f500e6fe677bdd192dcc43056d0f03420f50296cd39d752b534395d3afdf797908def50fb40fface30cd9cfbf563fb9c8e58ed900d9325b3074c64fb4da8a56e8e87b9b09aa9633dcedb7bca73105453ccbe431ce2545c01b9558273eea5f0faf0b2799393d57f50c719e106017d9f385de4bd77bda15c28a00b6ece1b98ffc09ab75c6a694e447987a6fbf64af51224f576b891efcdd59c91cd6dcde0bc803c05c96a38e0799728a1c05a97681d1914b409ca195bcec4b4f49ae11b05bc3d17475eafb16cfb3657b9c1606be864dee817a2177ff749ab85c063e97da45942a4661954b52a369c2a39921f9591243dfd5fff0de0a7fc6e12e4ce393ea88d1816f675c347793ed5f2e35ae131851502f7894267aaf0db05e6174139af02856ec30e1d1664a4c37e270b7ca0db15e00f77b435fbc485ade4cca2a6b3c0cc841e49a5ae333b17f55cc0cbf40eeec59695578e6d1e27a506ccd516ad014c49e85311a069e7567fe5b188fc299ffa8f38425bdb06634840b19d6f828b27702d77e28f0995ac65247ddd2819b89dd1914da9b5f5ccdac11f9dc8603cc84105c4774a662bf85641cef1e2a0e1dca33e9a79436abe4a6e10e447d34e4750f33d180d97bb54ead07745b5af805946a7d712b288f39f74cc93ba7643ca488c5677b230b2f3b3c2e098e206f6125a0b746b3f06f6a73f0aa1f13db5d45a0a54cc6241e1b5b78448b7311d9b67f56ff6475281a78a2cefd3dba3c253aa9f9956a38a2616364d68304f9d2f51333c8041fb36a83b62d117d79006f1458a6c75f2d4c36c973037ff324253da00c5792aec7e81b0d707c5d9a24c6ab47523b659055cd94000b7120c266da4d5100d377ce27510894f72af0edb011a04769a760c2d891a839313a5b99cec46d411fa567e8f559a48fe17cf1d94c264e2dbb269751a726361f674a2da799e203ba07c69a53e329060f3d4fde857328dcca1f3d0b49fd5118b1f0e8848929c06ea5c34c16aa220aac0231cfef415696abb3a40d6d76f2e5e67beb96d9de08d707a13928926c7c077ab0eea6cfe5e2f0dc9d45de9da4a1edd76d39c1687a37fe3da73785b0e28d527d1d0415007018199eecfbceaed98e283ee26c9171fccc7221f69093f877a8149f50c199ccc304d1a7c6218558127339cfc032045cb729c1cb0c0668923aaeab3bc10ec5a37d13b878264f3b21f30802a70caec3e4de45c74aea62c212eedb263cba4bff30973dfc698bab07ef24278bb7015b5d4c6a9b6b6c8a8f6903f17891d0ef21130e964e1708364ccc5e18b9490f50d1029096c986f810761bdea485af0dcf65e79ef2161426d83a7dfa279754d9da07a480ad2f8113dff62416d4e419aa01179e5dcaefcdfa45590aa814266c50a6a5f6a46910e774d1db054f319287d2b29c3e48aad16b3fb89f220cb1fe0d604c76d0c9e1b190f9e59d28a910ed95c2e236c2521103921c75ae7397ad1393a3299c5cf3c38285d805aafc8c7d9d3a11399be8e1a7c288d12944f8db85f5e5a2183843fa86c60c7e98b9444aaab2e0b1fa05ac81caaae7bbde891fdc69936fa7317c33b05c332aa6cfd7ce408a4cb05b31372cef1f4a253b3549d503eec56a1a7873d8c855678d8e061b2b6b58906b47d1a6fba648f852be888dc11fdfda8a030efbb5f034c19d41b6f33b473bb47c5473a215c3c0edd59df2fdae4a766a5d52c7e1856b14c50f8c5a79561229ec1aee7e658460a7f78c66a69a0c7da291ea0ace35369485bbf369f956ea787c68be043efbc119ca157ae92993882e6a8dfe978d59c4b59dbcdbcc941fba7a011e1a40cf88ecf00aec5a54327ca2f72b7d66b6fbd22e116d9b8ac691cff14b630356d257beb65399d0fcb368cb8beee604143899dfdcf8f9ace7af8430808b16dfde6fea4e49b4bdda0588c4673ed0cc8c8341b0dc8d06239c94739b9bd30751f443d61febfa15e69f2fec268956dbea56b805dad4cf5f90bea7540b86b52b9c264539a67170d018b5027efa39c998ff5978c07aaa516c6d204686801c918d472bd87466a5de5838ac4609c8e68dd73b0d458c70f5102523e8a117db3bc1092be94dd6cb0dc0ef7f8c099528007f7bcdea4a83a112d47cc5db0be31931384e5dbda07788d75c0db2e1442958241a85ec9c34a6488f2d984eadb3f3908142d2c1d080f52cdfa4adc0e6be6879e392fece501ff1b280e194b9a49e87f21839f7d3f973aa04c95b08ced52c059e1e05598c4c43a376f851356d31501155937e7dc425df92fda7554ec8cc919fb288240b057e34de7ceea87269607318a580188e7bf33a74a643522645bd7e648f1a74be4724457bf6e0c15aeae1340e7cf1265d9163329759fe4c6c1d33a55911ca2e7a29c1f0985c1f22344072bde5acbc6a10f7010e5111c25897dd1c94c0410d0850cf3723cc62c5f68433d22e4c179363683a58a4265fed6bbbe03ef78c9d2accdaf454aff28056777a7396a4955efac9f71932fce9fcef5c31f2b3688bbc49a9ccc6423bfdb9e686657965ed9b6315a52050d3648bc97a21d1dac749068f7d5ba881192950112eeeab2a1a9b7d1fd29b323f3eec8deda620d1e1f5df4609e35ce7a4db5f3236ccecb136f010027e4d7e7ba8e5331e92c31d9d341aeb9513ca88b6abc6cc994219c0cf17182b86a0640e0e42fb023205e0071b807ad21d76eba947ea044ddd4de467e30088febaa234f923710a2398014f6d31b5d200e75e748b51ed74a2c1d68bc76796c5162978daeedb1b6ed3885726d89ecda6f990cff680df36509bb8e98bb330508ed22e30e79dffc05d05539b725d6b0c4ddf924a1143437d9b7f9d6c237415693a18c01854916b467897ca309f5876a80617521e290559137f0bc20a0a5bbcc397a866361bd797d9f17a3cdd637725c62b46a85242087a85f645ce9c31d749e7cb97165e4425fae59655693afaeea81238831a6899c77b0863b45cdb834e2e625b05e3ca44d1ff9ab4304a92231a91275098c1a26efa0d371ac412f77deca735e0d6330a98721f7114f3cc76dc464c6ceae096bd3231d9cad7f0aea96fb5ddbd3b9036d0ca90d0f483cad9174e8f5ff653989547aadb27053a5b8249750cf3c32544000c2975f5c04f4e9482ecfcb1e6ac3402f51acd1923ca3aa795c9041763dc3c1fdcc2e3f9a1f77d4564eb75cce1da13360c2fb96d370052b12cbb025f55691b5af947472eee7cf8d195635dfd433f277e657753f4b1fa2758767ddb94651dbea2d4131ad51fad1ea4a326d8e7b9a3e1b82686c386da9f89149f6d5a6d9fb58dd7e73c3951b4ebcd376619877fb3104f4bbdb55d84cad8fa449a6bbc3a55e7b362cbea133aca47b3d9b02ee367bb756687c71d2813731098290ceb96a8e09b922685e7723b179eaa162a8ab6a57d857243b57dc2f2275be7626a917318e10f3885195233890f4e2a9e0c185716127ad074173978e6b13aac2c5ea5281010fd0168921e9fe395e5fb9d77358b76dbfa7a2f71bf140b140a2d69a02fffbe6940914510e5149a65c92505f9c5d3f66980193edaa52d7f9b51d9f85b33051492d0c4eca66033f9b795fb37405de95df04bd6856ff6280bc56d48cdf5cbdceb2341b0d1237b3aee9e33c37fad07c460bc46b9285482cfd461bcba14a9e083424bd3c6bd0ecfc4333b567153af7dc8bf6cc7502f847fd90fe0a778cc0bf1c4daf26df6b8f9791d2dfb868348fab9c59b8a77d86b15d956dfbfc7b46c40526cfe24f9b4e625d62083fb883f478f657705acfb881ff400e9519f5d7c97c267344b019e4bbc3acd4563d9ff00651ec93da23c6b1048445a87896f3f0bc506e812e4a3896431dadffa6c4197621807a69197fa9cd50d742e9d7f8e49927eccaf7f1343023a2815970c8e3d0e3dc2ba10dcb51df50d03de37f13db27494dc85df8fb8ece5de7544a6501fb8b32f97f031394e69a63822d2b23941df7b9e4377f5befc8fef3f7cf304cfc3922f82b6fa1829eb79d6d54bb3e82b0f9cb7561ea9c93c19ebfc4a66d512083f63db9d772f0369dc5d6fbf58fa745d9c7f7f17ccd6da86f5692f01c0d8ec9fe631ed571cb9027d460697ba650adfc155dcea6c1a2107c78c8915ed327a040892e2e2778535e92da45e2a4c60140203f06ca7a9ef8be7163bfeead90280283192aa8295dedba9c38b7c221dde6c10f7aa1266ae3f16f9e7f9bbdab870a64724f1997969e9d93e95a071425dcd61b5fa59201c01af31ef405dfbbf3969bca26c7f4e7cdd2914ec9bba3adc626342afa4a4a806f13d446b443702ae9a9b195c82efd34338edd563b25d2ddfbf8ec4b6475b104f33c9456b4dbc40ec6441188976a8add75047c50355bfe1f3da91173b1e550a33833009624b588696aecb984859ba0913f53b6f947e5d3830f8c57916d134fe42826d113a353da17ec12bdf83a1517252a7aeb00d7a37988b02908d06f31f36ed16d3be001c606f542b05adaadd0d3d440cd29b457bc65cc5bb927bfec237ba3e7a7e6dc4a7b8149c30fe91d76c038485f33c31f38136f8aed4215216d5abb95cbbfcd72ce6d358d251819668dc15892a3be514924f880e8c882d18710bb5e2b56bb348eec40b7391c35304d09e508879d972d43f7ba88087e38ea7338ede4e9b1fe4ea953995b9a2ac5b215212fd784a5ad4736a8c28745430109921390efcb6386cf947526e8be0e41081aefbcd8f0ba092db0a5655054c4484b350cd08382ff2ce1bffbaf8b9281743e66fca736fcadf6c28f5ae45ab76fb0209013a0d36c35bac87058552eb81f1e49ccd97705d962f13399cb3c42ffbe2e23a0c1bfe1d5cf099661213a971bb94895a76ca6055c2f416b69095c2a6a9ac8ade1057c81bbf90ec162b0c09da4fb86fecc16ddc438629720ebf48ec723124f6a58b5f078c439355a9299f59ad92dde14f7b40df22070d91dc6394b7b847ae2ed04ef5e30b65bf06bc6efad0ee2b1a3e18a99da19ff6a76822d7cd9a41f6285c78a71dbf856bea0bca4ea6c772d541aa23d1e2ffcb61fdddde54f541084d81d94a36b389ff6023ab20d24a6b54ac60ff6ce1b304706b661438fa38de3a5548d2d4ac1b103d94e27ee0e2e6ff0ab53223b5b75c099864c8fdd4a4e8b9fe18adf3711f9727baf11ef830c5952881724aeba642475ea45e3938a70382f5c11b8ff79d3d7d5c340ae693725be8609ef37e9d57223cdf7d64163d4920d58a024c7eb88316a22a3bffbf6685a763f0ed74e1d7e3a80d4dfd91ce6c41b2ace9ec89b0c401e8b9427ebfd2a55d5a3707f8dfb735d1ad19e46620daf4d83d4b32b7a98e779fdacfce7d3c91b026987018e47bd6b3b19155a93381ff1a0c17b5925380b834397882f1f3660d88d229114addc3151122f176d8ab5704cb78ac42a96c888a9386cf348373055368f98325f01d4f3be8c8a8dff13d79cf79dc6364794d4629662a5468aab9cf6a9c71be0735772548d69b4236be8e090d5086c1c945bbbad0062d75ebc03771dfd8b7b5985517e98d31959d7bfb837ab185c3c79f24d220593d936507425425852619ea0a3c05898f8edd6d8ab23ebba0ded64a9f1675c310d0ceb389f89f4736ef0138d53ce0ba47dbbbbeff367f39016624909bee3b4537b2d89060263e0351c441009dc2a89ed014d8a08deabea50632782e8f1bf627265ffd8c3094eca01ffbabd2c4f512b825c56c035d3a066d1891f214260352b6c08faa5ea29a1e598af7441767c211f6eb6fb8e829509b5bd3ca32291e7eb001a96325c29fc6e984ac82b38976454be53402dc821e5b7c7785b5ad87bb3f879c7b204bfc432c2bad3c8af55c7090b13deeeaa7b36606814533d19c772cbbe79770dc9780a5f5418c1a628a363836b165aacd5363105d462bcb34e7989530464740df6192ac9306f65d9284eb7be0989c2291dd2b9200a1d484c5080b8cb99e2271005dcc701e98229394e77eaafc42f8aa8aab997c9948301448d043ed2f931cf4d17eec572e177b38aa17cb4375b49717c61dcaa473bb39db464d9b2252608c04f6a1c47a18c61b58c3f2eb6824349fc78f9044bce454a65c72d8bd07a354b46319ffe3078cb0d6b6ee96e869febfe00f39c65c43b4306f6c91a6df96e2b47b5ca4b2689541a9f208c7dd3543a2112fd4217b67b8929b33766f9e11a8b72e5e1726bb6f6e93a2661e816844cae2d48eb81283e9dced57f20c296b4ea6d3917474dbb3e7fc8db4453678532c134b0a78ce8127e47c84987771acf8d2217eb362a816474e1eb22eeeffc8bd6b935fbf6da00919409f9c4dfc5f1b2f0af131c15aa32860a3e9d9a0a9485fc7a5dd34bfa11409aa373a1a2376115d2277dbd7c81abd44466c2b2c5a9ad3ccf5fb1b62cd9330acca3856b72ecc244fd14cb1952f18a02de1e518158a5865b03001de317196d675d2f4de1c3570df89d3725cf126ba3a91219d361317003bef3d505d603530ea4d9af20d8bce070573cd09e7645e3fa55fa89fdcb77eaa9cbd9dae40676f4efdcea8c9bbaa61cc06c513976ed107b2d598be5f72e5c6d8b9e0ea867183457781dbddbd4229e8c8951f91f507319ac0a142aa8617a6933205efaa77807540d11131e03f94c0cce92d7655704db9f66f2f9f270050fb96af14836495716a7e93e4d02f53ef959a4ce07a74c32cb36a41560bab48189c2faf80c06827fe8377f0d18ba812fc43839ed40df461c4f47c9d2a019418b892018efae2943884724ef57d6f751bc819780f3cdcbdec0aa8d79cb8dfb7740d6d33445deb10b19fa9763a6d6af88f8a1efee1b88817b2ad587fa3f45a5e04271401db31a3de3a76a91057f5bdb152ba4b6ee9700687c0b9ba9605ee9a4ff548d6467028d7095fc6d21081649c69c2841d3397e0e81478c4135ac0de728c18dd8e9b5cc7d7d6959cc2a1d53c9124c4ecb1a4cf0ca8b016541858258b2279a7034875d131297a69479f80af5f8ec275a5393423ac377bd3966c29bc85a017ca0855578fca484814e6983bef2a1a52ea0e65dc7fedf13e3c34b9550fe7f4492630dde4210ad75e539fc303988dbd9d9b8df3fd8aa31abbdd5ec8737a0447bb1a0301c89607a5d3788654d0d479c6853b534797a81c5d974d3509cadd124554b89d8e4d28b641c807d42b6d21fda65ce63a1461cf52b8e09e9d881b87b0c55ddf7b5213a163376feff90d6f514b7af8e3330952dd3b3140ca9e4d7177309f921b14ac76483bca3cf68d121f28e72e89154d3ab599df860cda413476654786d472ca9db317ff44b1f966497f2ce1f928374e2c47b015446aedba3c4401f34bb54d3bd45ced4d5b799293b68c33188025d4f5341b7e6dfc10e1a1ba95d75703cf7fafc960ae4ed527314bd39aa3635f926879dbf709c5ed09ab6f23bc21e3f6940668ca1eafa0869b58d58b8fb47808be3fe59f9fd4be0a61f4642400aa874c974f03975986dfb231dcc45395bf13d747d544212c90d1473d576efbc1d7535837e279012fe8bd31db9dc2508df30b3f5a6f06616d241e1b8760b893ce05c4ec742c36262532a8b88bd0fddcedf0501e3591835830b384206034d9da1ccb55820e48cf96372347302b0da008fbf98218205c0516a3dfa3235e297e17989476ec6c7b126b18ebf356ad1856a77848f16c3880d2756e56487674a56c0fd569f4cde9eda9f6c843ba89bd6a9bb3d11dae9977a03029960e7a8a73e2e2d3a7104acdc830a68c53fa35e37e61b6f25dccbf31300195f0cd4392bb744c6fc4035f7f8ae89963e29db93217e7e9f985709aa63079a787404332be89538015b318fc76f26b7816b8432532e17d598e3aef0d3160d573413655517f23684705a164ebfc8a1ddfc589493bec8da0f748cd53b62712ee83195106f6b1343d69e0ad523a210784332fc28ad40c857058e38ae61fa70a526e8e79fb06df74e8f4894088be133e48a61df2eecd77b7fefc3a719ba8b2c345c722c23c28c07c312d3828331d8db96dc091b94ff5c93b0a45892ef865b46728a3ee8024362eb10b3c1116c67c1abbb7639c9e04f7326a2b0cf23db6b29b739753e82f0bef9615feb27e7838804dec683a74d16e13e883498715baac30825db9fc4001070cb6acde65de78e2300d258c89493d4b8cbe3255f8c801760f9fa1f96db6ac189996f0d08d0c4075c061d9e14de65561ee364d1f7e89e619fc5187bd07bda78a19d39b5c0f528cce851ded690fb277f26c26a5359d61787a25e3b52542a07c3f29baedb8f08c4d092927ea1d85067e6e742bc90da2d0c57159c05c4365619b0a7eac010b7bbe49122fe926acd88b0585c3dd3704b79a459cbff645ffb4dc3d004bbf9eefaba779186b7b5f095c172540c8ce25ed781a22ab61b63924a0fb66f38c7fe3b1c554f674dbd03956fed72105c1de2b2ced5c304a9eb99e49c71e56bfa9162b4522755a547e93ab864d327b94e7b5b7052bce901b64b4c3b272df5108aab048bfa4f288c537201fb4b3a265085decf5ff996573710d0e68758c9facc62fc7f4507ec1a1b3c055a4afb6a2efecde1f674d387faf4fe23bc0d09eb8f7f37490e5764565dc0c82f25485c792a6ce3d1cc49c5e22bdfa125ae7320d8025d6cbf0c251e907febab4a14459962f1131601d54239435b51ecc627fd00b05ca795dae72f5281c77a1dac940eab3d0c51c4767347245be542082a17bdfd8b69bfa1b3cd707d48a875d9f66306608b3dc0d17cdc9cceda02f37e21cfc34cd6719a5f1ef3e23127c32fe01081c3fd59fe9ed42262583e74660b08e0c674c64a0d32131693af9c6c96808b90ce0cf6ee1e309b4ae26ebf4dbf78888f86d58ea7291aea78cd974c33f53ee5169fc6afe69d315ee325c6deae4494a8d8f090e0de415a34c746059ff56d3b64c1b8f02563ab8c14c458b1a3d18a852aa1df9d708a0b26e51d7f00a261b06152a05f6f87fe71a8f4bc3b4b2816c648e8e1eb8bc5c5b676aec98975df06b338c7c7b745e29ef70b14d89e1164800d55efd06bc9bc4abc24545ee76c1bec98b65d273d51ac84b5f832b5b5ec5ab9eaf61ce49d6c0c9cf324f54b70013caf54b148c7a4e8ce811d64e8486a05ce254951be25f43ab8487dffae6edf48127f9bb39ac776584b595a7bb9b2e1e522da30dba79f157c18af96f935fefdb95edf8490ab41fca3ff3df6686c81aa5dbf0a38f450cf9e819d52807b98ed7ddc86ae190b155fad2d0317fb4109f2347855bf10bf0fab7ed433f0ed12210589988a7089eb0644e2d46f51ae734c25aee3afe566070ab4e2bb9742a3291a0880ca4f1d5c51d68626904429b415a5a134a56d1f36dc98e7bcd56414d775666bcbfd378be4cc29973ca09175594f805c1f00d22e5a6f565d1bce24475cad508fd29dd32c18b5f54c55ab727ff424aec649192c4bc7a32c67fb774cd285cbe158646415028c40a8da652c863841dd7350733cebcf24d8cd5928fb23300126e23fe42f531e9058a0bf6bef9ed2483a0c942388738eb77dee32c547e6eaba45241f72cc3f0587f2d9a4341e3af5c50f2cd8f3f2c68358b8e5d35abdde0ff2a2ff78f844dbd015be4cce1cd9056a8e098c8a6681adef37d303f04f97de4b43228b5385e2806e3fb7004c643876323ae9ec7a42048b044e1b822f46b12ca4d2115fc9f93cfc06a1f8581c9264186339637cdcef9a0de53c094f74e4ced21c7848c13c8b9f5e133fbc80b771da03f50b6bd801452bec8496cb28ba29f6acbf6c67f266231c6c05d6db0d771f957e1c971379bcd0d937708ea42b935fec17132eaa147c9f1214f6f19a8b82bdf31179020ce07093a33cd4f0fc6c998c5e953bc6527c95028337a3e69dbd99c231ebf6c603bdab83ff640e25d562c283366cdb47f74689e1cfc7007163c4169ba0b2416c2f9af0a9170c94fb187a49424d534858c1f28fe22fbee75e70468cf431512296ea397676ae1b38d96b61b836481aa5bfdb175b490e22db7bb39f50f3438e9a47ba27f268961ba6bed00339a84a4eafd57575c253ded3b22da660e958ae3d9c78e0c615ea5fc25c235de2ebe0c43f5972ed8255e69d7dd4589b14155a09f1ef30b6d0eb0e373bf055eabde2a7963a31602a38bc48054fbd7422ec7b206f6a6480f1d76332d32b4995b2b24c8235281abbd30ba028ffdf83f5a273fad25186c8bc3c0e5af528cd25c78df60d2650a082e0566a12e05d35d718e80e5a0527c47ecac10ebb772382aaa6ba17050711cc2a3d8dc8ed9723ed0fc7717ae7b414e32600003556c75987da5dcea04b431087012d285baab60128059d7c4b96f163809c77dea3744f7ff7264643d74cc73967ed44a1314982d5ac3aa3fda65cfe0d25c7096bd0b23d780c658a98bc4ed5cdb1391bca532f492d73dcd4021a437dbeeaf922f5ab20dcb3ab85a1468a3f193fbd3ce63ff7bcddf924bca1f0235c168f4807775f146327e9c3b8ada08134d901798916b329fe314836b6d936ed656fd9a637d2cbba63f22b55c4ffc552a4e600949e9ace97b8899c22ad48bbecc940c92f342dc8828c3aba97419c3f78d5ea0c6a973c56884214069d93fc4e08dfac6203ec5158cfbf6f2d04afa10c4a655182bdee10664bfde2cd322f34f8873a9b25136454d07e19edfdcb0000f528877f697fa49dcba7c2f3a08fdae60e26f599fafb2778e115ec55dc0ca96d5daeba5dda4bc0826a03f4529cdc28c422ce75228371fa77aa0c95ddc4753ca7bcef92a173e0bad1e2c467c98389653b79f79388390661b407e497c35013d3707b1ccc2ffb66ec1534ceabf69ee36c0dcc57b3def25cf5405ad4ef097105ef37393e6314794088398a4aa5a1d16958ca017b954979fb514886b76a33b37e1d0ffbbe4bbbf6379a23eb7d293856050fc55e10994c8e4e03520a6e602827fb8c4c462a9b6d1b29e46a48b0b6ddfee0725f09dbfad76709fcdde13f8eb6eb4356d5e589fccadd2eeba5fe6d5f282c1537ddd5f64f36fbf971ef4499fa27c44f3bb15dfa78ed2c012d340ad2adeba560a03110e062e5ecee72b97aef28479776629c1a85de3475183d04c8a23128d1e8c6204a2955ca7dad54bc6d3adcd49418d8e14fdab126eef0f07dad24d6de8b5d221ec548bdbbfcff5328ad91f83341c80772c0543c592046519aa117486bc8f5229be7e0bfc6cce89085859d08e60fe00ad970228276c4dd09f17e7cb009c9fbdf1bdb641438e8d096ad87833e3c49499833f6f219edc15881a8cbf03193bb4ca3fcd3327e37cf3a8af62c8422f42dc0091c9b34f1cb3cc41268c8a17567af0f279c12359201ebf6943be90342ed718900ea0d6792852f141e85a0649f9201879ce5cce8a7dc5074917c469f93170b3d78bd5b97a62659265a8e120f5aaf361f6be3568790285ba718e4b72d23393cc40cab9041e0ff12bb6a132e0751cd86733d2b13c300d3912cb683c561652fd52ac0d117c6a60447ffd1413198ac5727a4345bb64b4114e8e96633f5bd0c2a9c48372c86b6f4282fe89b492763db0993b750039dbc07b7841809fe59ba95ba17b2c1b2a047c8d26007704deaa94aa3a0c47e5dc261a55705f4366ac89b919f756411e8338e1d50f83c5a8e89a63a4a7f8d0bdd38f420f622c9a8fd37eaf55a08d3de0d2bebc0dab72bc1ff84f23f9d2b921e1435c6f57f69454ab9f80ba8d9da93707dd2f862d63993b1cfbbed223295294ba99b6e8c49f0320b64dd4cd5ccd7522ffbdef71f6ddce5a52d55d58ec3b29dd85f5c8f52d436241bf95d31f0a84f712119b318cfcba8b2c38812b79ec57535a58d187c822b2d35ab5942395921dae8358bd8a48f04e988b7b92c8bbb0bf186895093064113b7fd95fc7dafa788fa87f196e7b96f06865008c63107daa39109c9bf3e43167eadcbaf562f03050fab94b421eac9405487a90e45b5e2c9e380c677421de6672c8d7c966647777cb198429a50cbf204977074979dddb9d1f870ac2ab0f50cc8e43d52775ab4000399f76f6fc8fb41bcecf5adf08f61b22ebc864ad35d883b923708758d6265dc47a74890436b5ee9be92567faee95e8405af9cc086bbe2f51d5c83be5a94707992a40f5c81c0490f3350778a19d29e378ea2d78a61588645bcc87be7041edda14b298abcedd9671ebddb39de2c7fb77da20612f8722a8d2f42d5d33d679c467c2d987d64b2d3cb2971756a34bb1788093ec2a25e74e073daf8ad838e5650d431b617af9d2a63042e275f077c4123235c7451db0b813890b8e57564330c04d4a2dfdbfbc95cd2d6ef26fb785217b8f20b41a55448f2ecf51844f43d3d8261c48dfcd4101912fc2424815e3cabc6de0d4e4b7ca44c3eb4aa75342d41d0e53db7cebe1668ab9ea7dff7fab8ce2af979a0493eddd5836a2b22d65d7a47b543d1a8ed8053b8721254a8db690eaf8bbfe1e6467bd30190c67353b9213631541da1e4ed9d59211f1716756882d12a5265297112706bc11bda6220b4ff2c6f2c674ed14ed85f99fbbd4e3e9a2c3d3c68e67d23dbe7236bfab3df1e57e0ea91c45fa063a34b83d33372ed9edb21e12f5247f54027f82110ac376f28bb8f07caab35a515488472b09eaab66eed553facd996cdb0671eed58585d43a922a22b09ef0423e8d10eeb30085270ce3e5123b2e3c08b1c6f25bd45ffb699743405310c9808f7cb118231a92ef1f8cb9fe9ce7394d99aef199de563e52445cfcb8e8827d246f02cde8c71e63a9e92ec18ff23533aac30a906f6df765587174df0c860f07b30301d3127d226369c8ce0f3b5fc461418c89e2e19aa836ea8ebfea711464ddd93e7f4604c863227f6624291b52a045e040c8349771a9bc747766f7d9b810e771d112c4688503b99abf4c4df04f4e09e611a1f768a15f418371855ad42dcfac0d2bc7852c5d83a396325d45add5d2c4f5acd05b22d96794c098845206ab6c13fddd771e5edb5f06fd1c109455b584ef1cd7e21f7febcbbc3dc5897e588cc1bb7504252c3a24a4d2236ccc1854b8bdea73bf61bb555ee395165029149c9426635b9229d3e4c6a4b7cb1d0b19f427c9bfb98b19ac85de17fb877f0f79578fd2c7c825553bd80381da3b323b695f18744243ccffea05370045efecaa4a5627cf7eff82ca4c185695c197235b7a6d6a357deabfc492f155572e8292013447769b03068b1831dda2769e8d5d0a35f4769dd7b5d6de903522006859d1e52b2f5499b8117ad8b47a9f81d173cf4f0fc8f722a43822799c4899204994a0cb6fdc187af362c519de59a2a160b25893ad0c63865a2b05eef191b95ad6198a8ff91f80a11d910b0903e19026c05511150cf4bb6eaa421dc38b44ed1084b28d675ed8781337b599d56b0575f6cfbb0e3fb64b70beef5befdc2b71aa12446465fb63899c2b0cac26172503ca7bac9edfe18f23121a60f15d67ef382e58af7955ed20c1456eeb9543389e6b8701b356985938d40967e5017d872c881a0d5056d1e7997fbfd9205b81674f931b42069a9d28028cc83bed8981a5577564b0b03c4edab33d4c9431ecfe3b0bafb3e7a27902d54be2ee7d5b3a62d137089a52cb770fadb1c55f7f4dfd95587a6d65070787b624c87bddf48093689b21bf317f1f1c6e14a21499257524e760d0e0b5da29d66c23b1a1cc0686fb14df81b1167007df43c4a9b012bf09b70643c2ccf619a2e55368f540c98d0ee93d6f97d7f1bfa38a4770284a75f6a54af97e7b2e10589ee6b8802e81adc1d1f493338b498ef2dbcc3561720b120f9d2f264146416f600ca6786fc78396e78cce605d191e64db87e3fbd19b98b8485a2f5a2ab4de20dc86293528a6c5ba719113dd7569800eeca05e0cb7182f14df79de84352b6ddbad96762d745e4e43ef0c1c29fa70fb67de11213f85d2d1338f1e502a74a50a20c3e4d4b2ea4a00c429413ea6047ceeebfadb6d9c5c7bab843069cd34f4ad7592c44d25aa8be8f405422aad40ef08a74132c8c4506098955e18c475d0724923d429e0b225a84628887f15c70d8fa4dd442c8507bf71bc1212943cd322e6c7787e924d57950bae3a3fde4bd0696aa0b92ed42a0c90bea6b313a7105e1b077873a6d6248caacb07721d0cae8b761d417ceae292c2a7e64bd9500e388b3f3ac02e8a34f0c1efe14cf58d14f7bdd587e6ac78fd5a54df98e92ecae26d682e2657427e3db848b531fd466889ee25d8345085a1ec98c419a4d791bc605df8d53b025adcca806d00d29fb8f82c5a9042a32fc0481e6bca1a8eb3fb47397cffc612062208543e13ac6d52c60507bf39b96309d9ed7a2473e8aa12c2bad3dbcffcb1d2a3ae2a2e2158122433619253a91690519fd988df027cb16f6e84b33203997d7b6990d8e738cb0c759e343b3e9d632a189990d137d7a4bbd34809cb7fb3472122e610ec6e6a49a8c134f42edec31362df82439f1e243a9a</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>随笔-2020-03-09</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E9%9A%8F%E7%AC%94-2020-03-09/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E9%9A%8F%E7%AC%94-2020-03-09/</id>
    <published>2020-03-09T13:43:27.000Z</published>
    <updated>2020-03-11T22:54:03.465Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="45b94595aedb133be9df70351db2286987a71cc1255d75222ba488c1695ea29b">0267ec72f19b8c198697a4f72870a3a87f07bc927355167c7e6d9f510818f08762be6b3ff9f679fb0a5cf0653d49664c7618404f42f0b619f49076adb2bf546e23a64b67f9a7173f52e7b9ca149393ef9ed370bcf0c12b31034856b457ce1a8f41edd22acc4c6846e27aaf44940bfc4c6450e637a1691621156c34375099534177bbba385513d9d74a7bea136d8a902afde47214321a4f9cbe40b3426b9084205a00d92b4ba75044f3477770c1042a6db3cd5d1491bc7df474fecd39511a6007717bea296421a6a9bd321159e2a83232dd0ec34e14d3852b0acb1c18a8379cc9b224fc19471f325994e0c3e2dbf3c8f9d26f7ad0a0f1697cee40aba4cc7fcfc765016ac3e8da5edc10c02b51248a9581d4240ef94abd445c90045eb11312be4fb7c410088035bd3ddaf0b6afc5eb00b6aa86c9971d8babc484603ed9315d5b0e55176f793fa32ada5b1552384752c23e13942c5e055a5ea384990acd4cfb8425d1d20c97cd3651e1817b2caa9b81fefb6951083ab4229806a25416d06e3f2854e2871276f89ea4275190dc034097308b02683b605da644c9cbc8277d110e27248396588e1e6fa1fcb611e76d17c50c0eee5ce0e94443c6ad1ed3f04c21d6ce476bbb4af929bff77ab97cc3c6a103d29901e904bbc9b5faa8ff4ee52ea362fe8d0d5e96548fc6cc87bbb305aba7a8103d18dc2fe1024e0e20e0ecc52ae7374baf2eae8bb449c7828ca69bbddebf6e79050eb19c897c1f926530481ed6a94c5f69b124248b3660ac27bdb41208aa4ba1cd3c03549d907dbc598bd0755deae486f6e41175c3d7a81b018f0320c9554edb93ee228974b063c483fbcff13aaee35742c3a6532a9e5fe5098bd954c8964dd11554ccb6288a69491ecd67af37067b059ce91acaa481deec0e81fb306e6f4f5891c7becf315b03d56e140548ce7a3eb3467377cf2ae280325b90fc605eafa5b06352a27c7a2af55da0dde2c75d0db08970f7ea0b38db693d3d56e586c8ecfc050d018212de48b396c6541c42e30f7f0ef806e5c2bd5d2311328c716042aad48bf8d71e59fafdbab4bfde1bd86bfbe977a2d743ce1ebe09588d5c2bd413bcf94e587f5b093e39aecfa3475dd17031bbd53cc9e4c8daeb6b61890ee81d75f809e393a665b3dbcc7b866361714352ffb3f36b6f932ca78f4b22acfb55408dd592800d79e370689c732109b4e2a00a95d697f272562e5e4050bb0231f83d4214a3a6308801c67bf793d63160665214f073a4530574e8b8bddfacd16ff17398cfaf4c57863808361a4d861b703fa71593c4a42263747ed3e948df64c191a55be8f072fc7cd31ab45286ebad9f8eaf41a701376f3debf35e6ac2a4b8e8cf7b602b84b457b033b29a8b9f94bfbb05e95929dfff90b990f4298225bb8d3b35ddc77ecfead260ac821d1cef6b78be6f5ec8916bc79d7812ad5729ce071abe2115ff004f94771a16adc2d8ff718b93dec26b1f2f76fd3c864155e055b1e7edf75e6179b3fb0d585559e88e6094d5a31f4886c1ef89871d0e03f37db71dde3fa0c0f7eb714e0bb05c57e8add12ed20d2127dc0fdddf37b8cb9181f81a57a39e6aa3f7ea9512aac065c05ab52c91e3226afea831dc0ff113957e159bea4cd0a5087159f133ddecd59dc81e4b127369125320c9606d68abf32cfa7d64032ada1f7010d0478e5dfe9c1327c8ed8aad9495b3021facc6d03d0e480413fbe0942747c4600b4ec6cc208de587ca41e412d45f6c012b4b45373526b12b4ed157198a87db4edbe909572f90457480ee92a06c2901274bf09b9ea03bf2a8710ab4bd0842d737199ef84e27eeb497e9c3c01d3fc910e729620d7aaf4f1913925a12d6985341241183ee7f5d024dd51ee3729d3ec6966213f9330d7093276b21e6a96657e071a0bb119365b813eeba6cd6e568cd1a9921036b7d03c98a80fe88a1c84aa2168469c16c63dc683d322d61c895b38076a9244dc141620889e2ba65573ecea35377f69db637cf74db1578ce86914d746f1a9a877345e222cb927404e44626d10b0e6b2e0b4f246d2149898b673187f363c7a2844d8f7b6f26a1de60a98994380c9ce87f27cb938dfd8c917cda03f007e7e894f1e9689d186d786adfb70e179377fa1a5b1d595e726510e3fdf245d5912b5cf84ef4d548e6d823a8e6716a8cc4665b154dfc46c2f1640304a8dc37790e9956aa398ababfb89f247d4bc84593a76bae74d85efaed69f63eb957ca14a1906550c5105fee4c730d8e052e976c0fb52c16027907d373181b85d0bc3497e75170c56e5b8c8706dbfe99f51fdee210153941670b5f7ca93121256124bf494a3ed89b22f529bb99d5cccc2c9640349de5934bb7c0115eb07fb85036ffb99c1accbcb3572464e646eadf8ced77667704198ff4fa25a93d4824b34e67ebf7c6f3a002d678a610d2e647d5c433052d964aad6480ec2c7a5e133d4fcc89b923fce26988a1652d447c74e82e909289e8772a3b7f3c4bb59960e5d66542e338f137ac2feed89b5477f94e4cac6fdd6a6dfe91cb4abb40cd6d7b84aa87c859c5abfe5c86b5442574c54fa74661a98c1d2ca14118b0aac2027e26f714c435652361ac76f6cf3eb7c945e923d0999d217253aa19c46351dc029aebec0b5633e51b122a43b82554818ffa20fba4ec934f913192ebaa18fb366c5359da14533e43ef2a61270e0c46eb0b8687fc4de1529b46555e28d2f555b40fdc3614999d1bd064b09b783084c1be01eba4253508fb1ad82bb3e99320932ce078cbb69edb6b4a1bececa92d836729a68e4e208df5ff52e45ed6587db54287538a5918892d0f78536998a4d4f1d03aca0efa31f1c8722197a559d2e6af14f29dfecfc4ac27a591d00cea1867349e046524cdd81ae54cc283332492489236bdab8b0b8c757617cf944d2f7b9aa999cc9d7ccd68eff647e25fee0bd9953e584ae08636e0c205011688381143df9863e329ed6a6c80e1524c5e4ba82ee3c998706d1010b84b94defde7a565aa587f9912622038048ab8f906cac1521ea1812fb72828252a8790d4453081b95497f8dc5dd405d555cee609445ee1f2db805ddc80e3d7ab5d67360dd46c3f9ed36965d4bdab2164d1df9dd57c5677612b8ce7623a3afe46d81a5ae42c90538d8012b25ec59164c00cf00b430718670b6e3de4bc0442b66ad4bfa624c1d3217c58da41b6a26e846d9ab0be4de2f002285b298a4296b2f84abe90ab1f0ec413d57e8e73907b361370fc8eeaaf7fe67bde5c386c95c4d4425d5e1cc97c134ed44394d59abe098077b8f150b5371920cbd31761ac735633906d50f8cdfb04554813184f36df157328fc338f9d7ec9d2701f47ecdf23daeefe1b0ea27f3300186892eab59d8497684ba501cb47bd81cd87925d857eb106ff6aade8a50c59a9a426eb4053306c1d961c0221ae370effa1950920f1c4d0a148148ba17f7de87c006d17f264278593cd692f971304adecd224617843ef297ad261afa38753e62b31c6555c9e503b5877e0f69cf93a67e1dc5c6ed515be9669c3f1b5bf1a9d7cfa36bc615739bfaa5930e04aea0a29f62800f43bed018d1fd57dc12ce8349361c72a46f77d144fd51f2b1577d070ca47d53f91aaba7d6f7a781ce5c3f9282239c8ebd72f3d068c118dad039d61f8ad4d05c41ff4bfd42c7dbaa19fa885891ee56e81212736a05329a4e58e96df78623bdac9101718c02eaa7841b2f2449fdf07c12568525ae3b52ef1b52bf3a99a76c5a3b1006d4a47d02b08ee7ac8a9edb051eda1f2898b654ab33dd6bb90daecd69bad2743a713db2353d8fdc7559ebd6d939b1d3ed94af22ea6daabf479c0f0470e5862733a5aa2e312d60b0c407228bb4de8046159ed60b8c048512a9cfdb74375d458edb708a0194fe96b4f8c14e17af2a9000f3cde29ca7457838bc6abcc056eaac0465b29c85c91981a86b09bb1e867f469906c9881cd3f6a7409d5fd12ef6c9e6d6ceb982db890fb8f0559f83df75f57c3ff2b016eb8daeaf26b0a2c13a54de8b0cd7e149782c3af97b14c0b8f1827412d3965037f8cf0b25cea5935afcf59c190758ebb90ae18b41e487b96b8131f7e451b296d94e41210628a81e04fae4091bb0d5e442a674a7b6371fb90c2a01e75a3dc8f5ccde0bee7bf3b0d5d72ab6a79935d4d5e89499faa6e12fa6f241be130b6160e33dd73d680153f27f50f322828b96d7184dbf52546c360311f93092ccb7031e3a55103b619e247496dd14054997c707c43f87709f2521d1256abddf3e773f5a1392f76b5946159725c17412d548aa8b4155d4ecfe1ebde997bef628e88104d2817f831832d0d6edea798bbc341ccaf9e315dcb8b833357236e30c1f4492a220acea96be685dc7c98fa82cf700724494eadb42f48c0b988fb11e83437efd472d232f274aae2824b6e4c75507fe8f2d7b9c93d634b41beef65c5815df09ada39638d2b688da4c5862ca79df0a6794bb87ba3345dee3f673428c03ac5f8b8b9a05924f4b1349ca125978966e3aa83710a46396cb2a600e639338219dc45e141530545f43ad05c4de665cb145d19f021c6bf7cad8786b4e461445c158487722ad55ed350db8d8f95077cab89ffb5f8f8b028c7ab57542b75f19853b6295f0a09808e628cdff3d1884fda121044235649a0eec4e313e0fbb1f5b8207e7c7dbaa60801f3cc3760c68994b3195d38f82820c1994d4fd90ef24b54477c222ea3f8c533328f5592fbab0be34273f481c4662c1a806e114a2534b11239f77e8c14d0013755c56de05f117431d7835954b0c86fe427392dee4ee251944c3abf89632d3d214914adb6f3892def79a0a7f430696a11cacd2cecd49dc157aaaf0cb610b65c2870a5b63fd63b2cedfe31cc96a6241cf7b5bd8153a2c236d02def712e1723062bd63e2f63decdd53bab4f66aeb9419654bcbac5f8c38cd445f487a82067b6788424ffd76c60a6bd867d8920a5d099c6bbd3ba586828e41dc2a68b6fbce745179ac4b9a9b6d245d604333290dd51fe3d0fb3f3d757938f9970aa06df54541eea296697b761fe3df7b87b526b7fb2d7fd3bb38faa9e0bdce0e79e68a10f3c742c405c727b03944d1bfe78870bf3d64bc971575377b67e298cddac7714d5272067ffbba02ec8cadad3914b750af752f21f3a619281feea4c2e7087fc60c1fd135c7506af629a091d74a7feaebc4b89d16c573c285f7dd6f081a5f4f749d71b8958e3e5b4f87bba8fe4057cd6e1ec0efbdadd8e762210094b2cc3ad3b9cec2dffd5d38fc27dcde7818170a56f14f7e7b2669274a6ec5079b26e23ed44c9236b3e0e133c340b04b087ad452e814837ff90bb34f26cf624891670b3472b50a7527dcae09f35d1a79fa26238c3b9cbe1a67c6f99fb3bb753e95c0f67b4968805715b86c042bc2ee511f23bdbf80c50971ff5bc31c6aa2c42612c45b7d541c62f2d6ee42b337093b4e1bb459446a57544c00f9631a377d5795dadb8cb78f06edf18489de8be8d8333ce1e2f991b402dbe642788ea933e6d085d9b5ced6cc257c71822185a6be58aa537348c4898a14e55a533e9c700612b15db63ac27cfb9ad0377b75f9358e911613b403384babb1797762950677cd7d3ba3457c1f366a571c52290e63880d09f8574c6fb066396eedb47f2cdc19ca5c5ac8e4091e3676734eb61251e058c21423ac463061f678ba796c877635b8fead5d2c874a56acc39312d1389ee9c1ac81d7934adbea9c714468cbfecf5a53cb3ae759daf14b09b159c6adca3b3d4805ccc7afbeffd247e92b0</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      加密文案
    
    </summary>
    
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>数据类型-1</title>
    <link href="https://unit-serow.github.io/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/"/>
    <id>https://unit-serow.github.io/2020/03/09/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-1/</id>
    <published>2020-03-09T10:23:24.000Z</published>
    <updated>2020-03-09T13:46:42.334Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --><center><strong>数据类型概念理解-1</strong></center><a id="more"></a><h2 id="计算机科学-数据类型"><a href="#计算机科学-数据类型" class="headerlink" title="计算机科学-数据类型"></a>计算机科学-数据类型</h2><ul><li>数据类型-1</li></ul><hr><p><strong>涉及概念整合列表:</strong></p><ul><li>数据类型</li><li>数据类型-变量</li><li>数据类型-函数</li><li>参数传递</li><li>形参与实参</li><li>内存</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><hr><ul><li>数据类型-变量</li><li>数据类型-存储类</li><li>数据类型-常量</li><li>数据类型-函数</li><li>数据类型-数组</li><li>数据类型-指针</li><li>数据类型-结构体</li><li>数据类型-共用体</li></ul><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>概念简述:</strong></p><ul><li>在计算机科学内，任何存在于客观概念与主观概念的现实或抽象世界内的一切概念，都可称为之为数据</li><li>在计算机内，一切皆为数据，数据即为数字与数理逻辑所构成的任何概念</li><li>这里所谈论的一切概念，都是基于 C 程序语言内的</li><li>在 C 语言中，数据类型指的是用于声明不同类型的变量或函数的一个广泛的系统</li><li>变量的类型决定了变量存储占用的空间，以及如何解释存储的位模式</li><li>数据类型的概念即为系统化的将任何存在于程序语言内数据进行准确的/系统化类型划分</li><li>还可以更直观的将其称为数据类型系统(相对于程序语言)</li></ul><p><strong>类别明细:</strong></p><ul><li>数据类型系统内包含于的数据类型可划分位四种类别，分别为:</li></ul><ol><li><p>基本类型</p><blockquote><p>被划分为算术类型，包含于两种类型: 整数类型与浮点类型<br>在整数类型内: 各种类型的存储大小与系统的位数和系统的类别有关，但目前通用的以64位为主<br>在浮点类型内: 可将浮点类型分为float-单精度浮点类型，double/long double-双精度浮点类型</p><blockquote><p>后续进行详细介绍</p></blockquote></blockquote></li><li><p>枚举类型</p><blockquote><p>被划分为算术类型，被用于定义在程序种只能赋予其一定的离散整数的变量<br>后续进行详细介绍</p></blockquote></li><li><p>void类型</p><blockquote><p>被划分为类型说明符，类型说明符void用于表明没有可用的值</p></blockquote></li></ol><p><strong>一般用于以下三种情况:</strong></p><ol><li>函数的返回值为空<blockquote><p>C 中有各种函数都不返回值，或者可以说它们返回空<br>不返回值的函数的返回类型为空<br>例如<code>void exit (int status);</code></p></blockquote></li><li>函数参数为空<blockquote><p>C 中有各种函数不接受任何参数<br>不带参数的函数可以接受一个 void<br>例如<code>int rand(void);</code></p></blockquote></li><li>指针指向void<blockquote><p>类型为<code>void *</code>的指针代表对象的地址，而不是类型<br>例如，内存分配函数<code>void *malloc( size_t size );</code><br>返回指向 void 的指针，可以转换为任何数据类型<br>后续进行详细介绍</p></blockquote></li></ol><hr><ol start="4"><li>派生类型<br>包含于: 指针类型，数组类型，结构类型，公用体类型和函数类型<blockquote><p>后续进行详细介绍</p></blockquote></li></ol><ul><li><p>关于聚合类型</p><blockquote><p>数组类型和结构类型被统称为聚合类型<br>函数的类型指的是函数返回值的类型</p></blockquote></li><li><p>在 C 程序语言内可以对数据类型进行转换或强制转换操作</p></li></ul><hr><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul><li>文章先进行正文归纳，再进行笔记归纳</li></ul><h3 id="C-变量"><a href="#C-变量" class="headerlink" title="C 变量"></a>C 变量</h3><p><strong>对于涉及概念的系统化整理和解析</strong></p><ul><li><p>变量其实只不过是程序可操作的存储区的名称</p></li><li><p>C 中每个变量都有特定的类型，类型决定了变量存储的大小和布局</p><blockquote><p>该范围内的值都可以存储在内存中，运算符可应用于变量上</p></blockquote></li><li><p>基于数据基本类型，有以下几种基本的变量类型:</p></li><li><p>C 语言也允许定义各种其他类型的变量，比如枚举、指针、数组、结构、共用体等等</p></li></ul><hr><ul><li><p>对于变量的概念，无非就是定义，声明，赋值，以及调用</p></li><li><p>其中声明和定义对于程序员来说是同时进行的，即在声明时就将其定义或不进行定义，只进行声明</p></li><li><p>定义即为为所定义变量分配内存空间</p></li><li><p>定义一个变量，就是告诉编译器在内存的何处创建属于当前被定义变量的存储区域</p><blockquote><p>变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表<br>并且定义变量时所指定的数据类型必须是有效的数据类型<br>在不带初始化的定义中，带有静态存储持续时间的变量会被隐式初始化NULL(所有字节的值皆为0)，其它所有变量的初始值是未定义的</p></blockquote></li><li><p>声明一个变量，变量声明的作用是向编译器保证变量以指定的类型和名称而存在，也可将其称之为专属于该变量的标识符，或变量标识符</p><blockquote><p>所以编译器在不需要知道变量完整细节的情况下也能进行进一步的编译<br>对于变量的声明，或称为将变量赋予专属的标识符，只在编译时有它的意义，在程序链接时编译器需要实际的变量声明</p></blockquote></li><li><p>对于变量声明有两种情况:</p></li></ul><ol><li>需要建立存储空间，例如 <code>int a</code>在声明的同时就建立了存储控件</li><li>不需要建立存储空间，通过使用extern关键字声明变量而不定义它，例如 <code>extern int a</code>其中变量a是可以在别的文件种定义的<blockquote><p>所以除非有extern关键字，否则都是对变量的定义</p></blockquote></li></ol><p><strong>关于 C 的左值(Lvalues)和右值(Rvalues)</strong></p><ul><li>C 中有两种类型的表达式:</li></ul><ol><li><p>左值(Lvalue):</p><blockquote><p>指向内存位置的表达式被称为左值(lvalue)表达式<br>左值可以出现在赋值号的左边或右边</p></blockquote></li><li><p>右值(Rvalue):</p><blockquote><p>术语右值(rvalue)指的是存储在内存中某些地址的数值<br>右值是不能对其进行赋值的表达式<br>也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边</p></blockquote></li></ol><p><strong>用途总结:</strong></p><ol><li>当需要保存数据的时候，需要lvalues</li><li>当需要读取数据的时候，需要rvalues</li></ol><ul><li>lvalues 和 rvalues 角色的相互转换<blockquote><p>根据表达式的上下文情况，lvalues在需要rvalues的地方会自动转换为 rvalues<br>rvalues 永远不能转换为 lvalues</p></blockquote></li></ul><hr><p><strong>变量的全局变量与局部变量的概念简述:</strong></p><ul><li><p>全局变量就是在任何的函数外，整体的程序内所定义的变量，所以将会在整个程序内生效</p></li><li><p>而局部变量就是在函数内所声明的变量，所以只在函数内生效</p></li><li><p>在定义了全局变量后，在函数内调用该变量的方法:</p></li><li><p>为变量加上<code>extern</code>关键字即可跳过定义，直接使用:</p><blockquote><p><code>extern int a</code></p></blockquote></li></ul><hr><p><strong>全局变量和局部变量在内存中的区别</strong></p><ul><li><p>全局变量保存在内存的全局存储区中，占用静态的存储单元</p></li><li><p>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></li><li><p>C语言经过编译之后将内存分为以下几个区域：</p></li></ul><ol><li>栈(stack): 由编译器进行管理，自动分配和释放，存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址<blockquote><p>操作方式类似数据结构中的栈</p></blockquote></li><li>堆(heap): 用于程序动态申请分配和释放空间<blockquote><p>C语言中的<code>malloc</code>和<code>free</code>，C++中的<code>new</code>和<code>delete</code>均是在堆中进行的<br>正常情况下，程序员申请的空间在使用结束后应该释放<br>若程序员没有释放空间，则程序结束时系统自动回收<br>注意: 这里的”堆”并不是数据结构中的”堆”</p></blockquote></li><li>全局(静态)存储区: 分为DATA段和BSS段<blockquote><p>DATA段(全局初始化区)存放初始化的全局变量和静态变量<br>BSS段(全局未初始化区)存放未初始化的全局变量和静态变量<br>程序运行结束时自动释放<br>其中BBS段在程序执行之前会被系统自动清0<br>所以未初始化的全局变量和静态变量在程序执行之前已经为0</p></blockquote></li><li>文字常量区: 存放常量字符串<blockquote><p>程序结束后由系统释放</p></blockquote></li><li>程序代码区: 存放程序的二进制代码。</li></ol><ul><li><p>所以C语言中的全局变量和局部变量在内存中是有区别的</p></li><li><p>C语言中的全局变量包括外部变量和静态变量，均是保存在全局存储区中</p><blockquote><p>并且占用永久性的存储单元<br>局部变量，即自动变量，保存在栈中<br>只有在所在函数被调用时才由系统动态在栈中分配临时性的存储单元</p></blockquote></li><li><p>可以分析以下程序的运行结果，以便更直观的去了解其区别:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> k1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k2;</span><br><span class="line">static <span class="keyword">int</span> k3 = <span class="number">2</span>;</span><br><span class="line">static <span class="keyword">int</span> k4;</span><br><span class="line"><span class="keyword">int</span> main( )</span><br><span class="line">&#123;  staticint m1=<span class="number">2</span>, m2;</span><br><span class="line">    inti=<span class="number">1</span>;</span><br><span class="line">    char*p;</span><br><span class="line">    charstr[<span class="number">10</span>] = <span class="string">"hello"</span>;</span><br><span class="line">    char*<span class="keyword">q</span> = <span class="string">"hello"</span>;</span><br><span class="line">    p= (char *)malloc( <span class="number">100</span> );</span><br><span class="line">    free(p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"栈区-变量地址  i：%p\n"</span>, &amp;i);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                p：%p\n"</span>, &amp;p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"              str：%p\n"</span>, str);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"                q：%p\n"</span>, &amp;<span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"堆区地址-动态申请：%p\n"</span>, p);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"全局外部有初值 k1：%p\n"</span>, &amp;k1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外部无初值 k2：%p\n"</span>, &amp;k2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"静态外部有初值 k3：%p\n"</span>, &amp;k3);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"    外静无初值 k4：%p\n"</span>, &amp;k4);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态有初值 m1：%p\n"</span>, &amp;m1);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"  内静态无初值 m2：%p\n"</span>, &amp;m2);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"文字常量地址    ：%p, %s\n"</span>,<span class="keyword">q</span>, <span class="keyword">q</span>);</span><br><span class="line">    <span class="keyword">printf</span>(<span class="string">"程序区地址      ：%p\n"</span>,&amp;main);</span><br><span class="line">    <span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="C-存储类"><a href="#C-存储类" class="headerlink" title="C 存储类"></a>C 存储类</h3><ul><li><p>这里对于存储类的说明只针对于变量</p></li><li><p>存储类定义 C 程序中变量或函数的范围(可见性)和生命周期</p><blockquote><p>所谓的声明周期与可见性(范围)就是指定变量在程序或函数内所生效的时间，或将其称之为在内存内所产生存在意义的阶段</p></blockquote></li><li><p>这些说明符放置在它们所修饰的类型之前</p><blockquote><p>例如 <code>auto int mouth</code></p></blockquote></li><li><p>C 程序中可用的存储类:</p><blockquote><p>auto<br>register<br>static<br>extern</p></blockquote></li></ul><p><strong>C内各存储类明细:</strong></p><p><strong>auto 存储类</strong></p><ul><li>auto 存储类是所有局部变量默认的存储类</li><li>auto 只能用在函数内，即 auto 只能修饰局部变量</li></ul><p><strong>register 存储类</strong></p><ul><li><p>register 存储类用于定义存储在寄存器中而不是RAM中的局部变量</p><blockquote><p>这意味着变量的最大尺寸等于寄存器的大小(通常是一个词)，且不能对它应用一元的<code>&#39;&amp;&#39;</code>运算符(因为它没有内存位置)</p></blockquote></li><li><p>存在意义</p><blockquote><p>在寄存器只用于需要快速访问的变量时进行使用，比如计数器<br>还应注意的是，定义<code>&#39;register&#39;</code>并不意味着变量将被存储在寄存器中<br>它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制</p></blockquote></li></ul><hr><p><strong>static 存储类</strong></p><ul><li>static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁<blockquote><p>因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值</p></blockquote></li></ul><ul><li><p>static 修饰符也可以应用于全局变量</p><blockquote><p>当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内</p></blockquote></li><li><p>全局声明的一个 static 变量或方法可以被任何函数或方法调用</p><blockquote><p>只要这些方法出现在跟 static 变量或方法同一个文件中</p></blockquote></li><li><p>即在程序内的任何函数内对任何经由此声明的变量，不会在任何此调用时时进行重置</p></li></ul><p><strong>extern 存储类</strong></p><ul><li>extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的</li><li>即为当使用 extern 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置</li><li>当有多个文件且定义了一个可以在其它文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用</li><li>可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数</li><li>extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候</li></ul><hr><p><strong>存储类整合说明:</strong></p><ul><li>auto 是局部变量的默认存储类, 限定变量只能在函数内部使用</li><li>register 代表了寄存器变量，不在内存中使用</li><li>static是全局变量的默认存储类,表示变量在程序生命周期内可见</li><li>extern 表示全局变量，即对程序内所有文件可见，类似于Java中的public关键字</li></ul><hr><p><strong>C 语言中全局变量，局部变量，静态全局变量，静态局部变量的区别</strong></p><p><strong>从作用域进行区分:</strong></p><ol><li><p>全局变量具有全局作用域</p><blockquote><p>全局变量只需在一个源文件中定义，就可以作用于所有的源文件<br>当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量</p></blockquote></li><li><p>静态局部变量具有局部作用域</p><blockquote><p>它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在<br>它和全局变量的区别在于全局变量对所有的函数都是可见的<br>而静态局部变量只对定义自己的函数体始终可见</p></blockquote></li><li><p>局部变量也只有局部作用域</p><blockquote><p>它是自动对象(auto)<br>它在程序运行期间不是一直存在，而是只在函数执行期间存在<br>函数的一次调用执行结束后，变量被撤销<br>其所占用的内存也被收回</p></blockquote></li><li><p>静态全局变量也具有全局作用域</p><blockquote><p>它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里<br>不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域<br>这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量</p></blockquote></li></ol><p><strong>从分配内存空间来区分</strong></p><ol><li><p>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间</p><blockquote><p>而局部变量在栈里分配空间</p></blockquote></li><li><p>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式</p><blockquote><p>这两者在存储方式上并无不同<br>这两者的区别虽在于，非静态全局变量的作用域是整个源程序<br>当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的<br>而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效<br>在同一源程序的其它源文件中不能使用它<br>由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用<br>因此可以避免在其它源文件中引起错误</p></blockquote></li></ol><ul><li><p>静态变量会被放在程序的静态数据存储区(全局可见)中</p><blockquote><p>这样可以在下一次调用的时候还可以保持原来的赋值<br>这一点是它与堆栈变量和堆变量的区别</p></blockquote></li><li><p>变量用static告知编译器，自己仅仅在变量的作用范围内可见</p><blockquote><p>这一点是它与全局变量的区别</p></blockquote></li><li><p>从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期</p><blockquote><p>把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围<br>因此static 这个说明符在不同的地方所起的作用是不同的，应予以注意</p></blockquote></li></ul><p><strong>其它说明:</strong></p><ul><li>A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度</li><li>B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度</li><li>C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见</li><li>D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为: 带”内部存储器”功能的的函数)</li><li>E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针</li></ul><hr><ul><li><p>其它的相关概念与具体的使用在以后实践时会进行相应的补充</p></li><li><p>C语言最大的优势是对于底层硬件结构的管理，其指针和其它缺省变量是最接近于内存的</p></li></ul><hr><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><strong>涉及概念</strong></p><ul><li>数据结构</li><li>堆</li><li>栈</li><li>变量 (局部/全局)</li><li>修饰符</li><li>数据类型</li><li>存储类</li></ul><p><strong>未涉及概念</strong></p><ul><li>常量</li><li>运算符</li><li>判断</li><li>循环</li></ul><hr><h2 id="补充内容"><a href="#补充内容" class="headerlink" title="补充内容"></a>补充内容</h2><hr><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p><strong>C 作用域规则及其概念</strong></p><ul><li><p>所谓的变量作用域，就是变量所能够产生作用的代码块所属区域</p></li><li><p>任何一种编程中，作用域是程序中定义的变量所存在的区域，超过该区域变量就不能被访问</p></li><li><p>C 语言中有三个地方可以声明变量:</p></li></ul><ol><li>在函数或块内部的局部变量</li><li>在所有函数外部的全局变量</li><li>在形式参数的函数参数定义中</li></ol><ul><li>相关概念: 局部变量，全局变量和形式参数</li></ul><p><strong>局部变量</strong></p><ul><li>在某个函数或块的内部声明的变量称为局部变量<blockquote><p>它们只能被该函数或该代码块内部的语句使用<br>局部变量在函数外部是不可知的</p></blockquote></li></ul><p><strong>全局变量</strong></p><ul><li><p>全局变量是定义在函数外部，通常是在程序的顶部</p><blockquote><p>全局变量在整个程序生命周期内都是有效的<br>在任意的函数内部能访问全局变量</p></blockquote></li><li><p>全局变量可以被任何函数访问</p><blockquote><p>也就是说，全局变量在声明后整个程序中都是可用的</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li><p>函数的参数，形式参数，被当作该函数内的局部变量</p><blockquote><p>如果与全局变量同名它们会优先使用</p></blockquote></li><li><p>全局变量与局部变量在内存中的区别：</p><blockquote><p>全局变量保存在内存的全局存储区中，占用静态的存储单元<br>局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元</p></blockquote></li><li><p>通常使用static修饰符/关键字来定义全局/局部变量</p></li></ul><p><strong>初始化局部/全局变量</strong></p><ul><li>在定义全局或局部变量时需要先对其进行初始化<blockquote><p>初始化局部变量和全局变量<br>当局部变量被定义时，系统不会对其初始化，必须人为/自行的对其初始化<br>定义全局变量时，系统会自动对其初始化<br>初始化即为对其变量进行赋值</p></blockquote></li></ul><p><strong>全局变量自动初始化的值如下所示:</strong></p><table><thead><tr><th align="left">数据类型</th><th align="left">初始化默认值</th></tr></thead><tbody><tr><td align="left">int</td><td align="left">0</td></tr><tr><td align="left">char</td><td align="left">‘\0’</td></tr><tr><td align="left">float</td><td align="left">0</td></tr><tr><td align="left">double</td><td align="left">0</td></tr><tr><td align="left">pointer</td><td align="left">NULL</td></tr></tbody></table><ul><li>正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果<blockquote><p>比如因为未初始化的变量会导致一些在内存位置中已经可用的垃圾值</p></blockquote></li></ul><hr><h3 id="数据类型-派生类型-函数类型"><a href="#数据类型-派生类型-函数类型" class="headerlink" title="数据类型-派生类型/函数类型"></a>数据类型-派生类型/函数类型</h3><ul><li><p>函数的本质是存储结构化语句的数据类型</p></li><li><p>语句可以由变量或其它任何的数据类型构成</p></li><li><p>还可以说，任何的C程序都是由函数数据类型构成的</p></li><li><p>函数是一组一起执行一个任务的语句</p><blockquote><p>每个C程序都至少有一个函数，即主函数<code>main()</code><br>所有简单的程序都可以定义其他额外的函数<br>还可以把代码划分到不同的函数中<br>如何划分代码到不同的函数中是由人为所的<br>但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的</p></blockquote></li><li><p>函数声明告诉编译器函数的名称，返回类型和参数</p><blockquote><p>函数定义提供了函数的实际主体</p></blockquote></li><li><p>C 标准库提供了大量的程序可以调用的内置函数</p><blockquote><p>例如，函数<code>strcat()</code>用来连接两个字符串，函数<code>memcpy()</code>用来复制内存到另一个位置</p></blockquote></li><li><p>函数还有很多叫法，比如方法，子例程或程序，等等</p></li></ul><p><strong>定义函数的基本语法-C:</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="keyword">function</span><span class="constructor">_name( <span class="params">parameter</span> <span class="params">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body <span class="keyword">of</span> the <span class="keyword">function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数说明:</strong></p><ul><li>在 C 语言中，函数由一个函数头和一个函数主体组成<blockquote><p>下面列出一个函数的所有组成部分:</p></blockquote></li></ul><ol><li>返回类型: 一个函数可以返回一个值<blockquote><p><code>return_type</code>是函数返回的值的数据类型<br>有些函数执行所需的操作而不返回值<br>在这种情况下，<code>return_type</code>是关键字<code>void</code></p></blockquote></li><li>函数名称: 这是函数的实际名称<blockquote><p>函数名和参数列表一起构成了函数签名</p></blockquote></li><li>参数: 参数就像是占位符<blockquote><p>当函数被调用时，您向参数传递一个值，这个值被称为实际参数<br>参数列表包括函数参数的类型，顺序，数量<br>参数是可选的，也就是说，函数可能不包含参数</p></blockquote></li><li>函数主体: 函数主体包含一组定义函数执行任务的语句</li></ol><hr><p><strong>函数声明</strong></p><ul><li><p>函数声明会告诉编译器函数名称及如何调用函数</p><blockquote><p>函数的实际主体可以单独定义</p></blockquote></li><li><p>函数声明包括以下几个部分：</p><blockquote><p><code>return_type function_name( parameter list );</code></p></blockquote></li><li><p>在函数声明中，参数的名称并不重要，只有参数的类型是必需的</p></li><li><p>在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的</p><blockquote><p>在这种情况下，您应该在调用函数的文件顶部声明函数</p></blockquote></li></ul><hr><p><strong>调用函数</strong></p><ul><li><p>创建 C 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务</p></li><li><p>当程序调用函数时，程序控制权会转移给被调用的函数</p><blockquote><p>被调用的函数执行已定义的任务，当函数的返回语句被执行时<br>或到达函数的结束括号时，会把程序控制权交还给主程序</p></blockquote></li><li><p>调用函数时，传递所需参数</p><blockquote><p>如果函数返回一个值，则可以存储返回值</p></blockquote></li></ul><hr><p><strong>函数参数</strong></p><ul><li><p>如果函数要使用参数，则必须声明接受参数值的变量</p><blockquote><p>这些变量称为函数的形式参数</p></blockquote></li><li><p>形式参数就像函数内的其他局部变量</p><blockquote><p>在进入函数时被创建，退出函数时被销毁</p></blockquote></li><li><p>当调用函数时，有两种向函数传递参数的方式：</p></li></ul><ol><li>传值调用: 该方法把参数的实际值复制给函数的形式参数<blockquote><p>在这种情况下，修改函数内的形式参数不会影响实际参数</p></blockquote></li><li>引用调用: 通过指针传递方式，形参为指向实参地址的指针<blockquote><p>当对形参的指向操作时，就相当于对实参本身进行的操作</p></blockquote></li></ol><ul><li>默认情况下，C 使用传值调用来传递参数<blockquote><p>一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数</p></blockquote></li></ul><hr><p><strong>内部函数与外部函数</strong></p><ul><li>根据函数能否被其他源文件调用，可以将函数区分为内部函数和外部函数</li></ul><p><strong>内部函数</strong></p><ul><li><p>如果一个函数只能被本文件中其他函数所调用，它称为内部函数</p><blockquote><p>在定义内部函数时，在函数名和函数类型的前面加 static，即<br><code>static 类型名 函数名 (形参表)</code><br>例如，函数的首行：<br><code>static int max(int a,int b)</code></p></blockquote></li><li><p>内部函数又称静态函数</p><blockquote><p>使用内部函数，可以使函数的作用域只局限于所在文件<br>即使在不同的文件中有同名的内部函数，也互不干扰<br>提高了程序的可靠性</p></blockquote></li></ul><p><strong>外部函数</strong></p><blockquote><p>如果在定义函数时，在函数的首部的最左端加关键字 extern<br>则此函数是外部函数，可供其它文件调用<br>如函数首部可以为<br><code>extern int max (int a,int b)</code><br>C 语言规定，如果在定义函数时省略 extern，则默认为外部函数</p></blockquote><ul><li>在需要调用此函数的其他文件中，需要对此函数作声明(即使在本文件中调用一个函数，也要用函数原型来声明)<blockquote><p>在对此函数作声明时，要加关键字 extern，表示该函数是在其他文件中定义的外部函数</p></blockquote></li></ul><hr><p><strong>内联函数</strong></p><ul><li><p>内联函数是指用inline关键字修饰的函数</p><blockquote><p>在类内定义的函数被默认成内联函数<br>内联函数从源代码层看，有函数的结构，而在编译后，却不具备函数的性质</p></blockquote></li><li><p>内联扩展是用来消除函数调用时的时间开销</p><blockquote><p>它通常用于频繁执行的函数，对于小内存空间的函数非常受益</p></blockquote></li><li><p>使用内联函数的时候要注意:</p><blockquote><p>递归函数不能定义为内联函数<br>内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数<br>内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数<br>对内联函数不能进行异常的接口声明</p></blockquote></li></ul><hr><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><ul><li><p>形参与实参出现在函数中</p></li><li><p>形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用</p></li><li><p>实参出现在主调函数中，进入被调函数后，实参变量也不能使用</p></li></ul><p><strong>关于调用:</strong></p><ul><li><p>形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元</p><blockquote><p>因此，形参只在函数内部有效<br>函数调用结束返回主调用函数后则不能再使用该形参变量</p></blockquote></li><li><p>实参可以是常量，变量，表达式，函数等</p><blockquote><p>无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参<br>因此应预先用赋值，输入等办法使参数获得确定值</p></blockquote></li></ul><p><strong>指针影响:</strong></p><ul><li>不是指针类型在内存中位置不同:</li><li>当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量<blockquote><p>它们在内存中位于不同的位置，形参将实参的内容复制一份<br>在该函数运行结束的时候形参被释放，而实参内容不会改变</p></blockquote></li></ul><p><strong>形式参数</strong></p><ul><li>形式参数即为只是作为某种形式而存在于程序种的参数<blockquote><p>此类参数即为未进行赋值或者使用的参数</p></blockquote></li></ul><p><strong>实际参数</strong></p><ul><li><p>实际参数即为已经对其赋值或已经进行使用的参数</p></li><li><p>从字面上理解，所谓形式参数即只只是声明了一个作为参数的变量，并未直接进行赋值使用，而实际参数则相反</p></li><li><p>关于C语言形参与实参的区别:</p><blockquote><p>实参可以是变量，变量与表达式，实参与形参<br>实参与形参类型相同或赋值兼容<br>在调用函数过程中发生的实参与形参之间的数据传递，常称为”虚实结合”</p></blockquote></li></ul><ol><li>在定义函数中制定的形参，在没有出现函数调用时不占用内存中的存储单元<blockquote><p>在函数调用时才分配内存</p></blockquote></li><li>将实参的值传递给形参</li><li>在执行函数时，由于形参已经有值<blockquote><p>可以用形参进行运算</p></blockquote></li><li>通过return语句将函数值返回，若无返回值，则无return</li><li>调用结束后，形参被释放掉，实参保留原值(单向传值)</li></ol><hr><ul><li>可能还需要对其进行大量的补充，实践时会进行说明</li></ul><hr><ul><li>数据类型-派生类型/数组</li><li>数据类型-派生类型/指针</li><li>数据类型-派生类型/结构体类型</li><li>数据类型-派生类型/共用体类型</li><li>数据类型-派生类型/函数类型</li></ul><hr><h2 id="补充内容-1"><a href="#补充内容-1" class="headerlink" title="补充内容-1"></a>补充内容-1</h2><h3 id="数据类型-派生类型-数组"><a href="#数据类型-派生类型-数组" class="headerlink" title="数据类型-派生类型/数组"></a>数据类型-派生类型/数组</h3><ul><li><p>C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合</p><blockquote><p>数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量</p></blockquote></li><li><p>数组用于存放相同类型的变量，还可以称其本质即为变量</p></li><li><p>声明一个数组，就相当于声明一个变量的集合，并且此集合内的变量通常为相同的类型</p><blockquote><p>比如声明一个number[100]，就相当于声明了100个名为number的变量<br>而这些变量用number[1],number[2],…,number[100]来进行标识，即数组中的特定元素可以通过索引来访问</p></blockquote></li><li><p>所有的数组都是由连续的内存位置组成的，其中最低的地址对应第一个元素，而最高的地址对应最后一个元素</p></li><li><p>数组于内存间的结构图片:</p></li></ul><hr><ul><li><p>声明数组的基本语法</p><blockquote><p>C 中要声明一个数组，需要指定数组内元素的类型和元素的数量<br><code>type arryName [ arraySize ];</code></p></blockquote></li><li><p>此语法所声明的数组被称之为一维数组，<code>arrySize</code>必须是一个大于零的整数常量</p><blockquote><p>而type可以是任何有效的C 数据类型<br>例如 <code>int serow[10];</code></p></blockquote></li><li><p>初始化数组(给数组进行赋值):</p><blockquote><p><code>type arryName [ arraySize ] = {进行线性赋值，用&#39;,&#39;分隔}</code><br><code>{}</code>之中值的数目不能超过<code>[]</code>间所定义的元素枢数目</p></blockquote></li><li><p>数组的赋值规则与物理内存地址的定义与赋值规则是完全线性的</p></li><li><p>访问数组内元素:</p></li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> serow = unit[<span class="number">9</span>]; <span class="comment">//将数组unit中的第10个元素的值赋给serow变量</span></span><br></pre></td></tr></table></figure><hr><p><strong>至此</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Thu Mar 19 2020 14:23:21 GMT+0800 (中国标准时间) --&gt;&lt;center&gt;&lt;strong&gt;数据类型概念理解-1&lt;/strong&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="无" scheme="https://unit-serow.github.io/categories/%E6%97%A0/"/>
    
      <category term="concept" scheme="https://unit-serow.github.io/categories/%E6%97%A0/concept/"/>
    
    
      <category term="随笔" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="C" scheme="https://unit-serow.github.io/tags/C/"/>
    
  </entry>
  
</feed>
