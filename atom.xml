<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>UNIT</title>
  
  <subtitle>道常无为而无不为</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://unit-serow.github.io/"/>
  <updated>2020-02-05T05:20:50.890Z</updated>
  <id>https://unit-serow.github.io/</id>
  
  <author>
    <name>serow</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>makedown流程图-flowchart</title>
    <link href="https://unit-serow.github.io/2020/02/05/flowchart/"/>
    <id>https://unit-serow.github.io/2020/02/05/flowchart/</id>
    <published>2020-02-05T05:15:51.000Z</published>
    <updated>2020-02-05T05:20:50.890Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Feb 05 2020 13:20:58 GMT+0800 (中国标准时间) --><h3 id="语法结构"><a href="#语法结构" class="headerlink" title="语法结构"></a>语法结构</h3><p><strong>概述:</strong></p><ul><li>流程图的语法大概可以分为两部分:定义元素与连接元素</li><li>定义变量所使用的语句大概结构是X=Y: Z</li><li>X是变量名，Y是操作模块名，Z是具体显示的文字内容，注意冒号后的空格，有空格的时候才能被识别</li></ul><p><strong>基本语法:</strong><br>由于渲染的问题，这里用&lt;.&gt;代替了&lt;`&gt;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">tag&#x3D;&gt;type: content:&gt;url</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">tag1(...)-&gt;tag2(...)-&gt;tag3(...)</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>括号内语句用逗号分隔</p><p><strong>定义元素语法:</strong></p><ul><li>tag=&gt;type: content:&gt;url</li><li>tag：标签，用于连接元素时使用</li><li>type：该标签的类型，共有6种类型如下</li><li>content：流程语句中放置的内容</li><li>type:与content之间有一个空格</li><li>url：链接，与流程语句绑定</li></ul><p><strong>连接元素语法:</strong></p><ul><li>使用-&gt;符号，-&gt;表示下一步要执行的操作：</li><li>st-&gt;in-&gt;op-&gt;cond</li><li>表示的是先从st转到in，然后再到op，最后到cond</li><li>可以连续写，也可以分开写</li></ul><p><strong>判断分支语法:</strong></p><ul><li>condition 是判断，可以取yes和no两种结果，对于不同结果可以有不同走向</li><li>cond(yes)-&gt;out 表示condition成立时转向out执行</li><li>cond(no)-&gt;op 表示condition不成立时转向op执行</li></ul><p><strong>操作模块说明:</strong><br>操作模块一共有以下六种:</p><table><thead><tr><th align="left">操作模块名</th><th align="left">表示含义说明</th></tr></thead><tbody><tr><td align="left">start</td><td align="left">开始</td></tr><tr><td align="left">end</td><td align="left">结束</td></tr><tr><td align="left">operation</td><td align="left">普通操作块</td></tr><tr><td align="left">subroutine</td><td align="left">子任务块</td></tr><tr><td align="left">condition</td><td align="left">判断块</td></tr><tr><td align="left">inputoutput</td><td align="left">输入输出块</td></tr></tbody></table><hr><p><strong>示例说明-1:</strong><br>竖向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-0" class="flow-chart"></div><hr><p>示例说明-2:<br>横向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line"></span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-1" class="flow-chart"></div><hr><p>实例说明-3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···flow   </span><br><span class="line">st&#x3D;&gt;start: 开始语句</span><br><span class="line">in&#x3D;&gt;inputoutput: 输入值</span><br><span class="line">e&#x3D;&gt;end: 结束语句</span><br><span class="line">op&#x3D;&gt;operation: 执行操作</span><br><span class="line">cond&#x3D;&gt;condition: 是否成立？</span><br><span class="line">out&#x3D;&gt;inputoutput: 输出值</span><br><span class="line"></span><br><span class="line">st-&gt;in-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;out</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">out-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-2" class="flow-chart"></div><hr><p>示例说明-4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start</span><br><span class="line">e&#x3D;&gt;end: Why are you worried?</span><br><span class="line">cond1&#x3D;&gt;condition: Do you have a problem?</span><br><span class="line">cond2&#x3D;&gt;condition: Can you solve it?</span><br><span class="line">op&#x3D;&gt;operation: Since you can&#39;t solve it,</span><br><span class="line"></span><br><span class="line">st-&gt;cond1</span><br><span class="line">cond1(yes)-&gt;cond2</span><br><span class="line">cond1(no)-&gt;e</span><br><span class="line">cond2(yes)-&gt;e</span><br><span class="line">cond2(no)-&gt;op-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-3" class="flow-chart"></div><hr><p><strong>示例说明-5:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">···flow</span><br><span class="line">st&#x3D;&gt;start: Start|past:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">e&#x3D;&gt;end: End:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">op1&#x3D;&gt;operation: My Operation|past</span><br><span class="line">op2&#x3D;&gt;operation: Stuff|current</span><br><span class="line">sub1&#x3D;&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?|approved:&gt;http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">c2&#x3D;&gt;condition: Good idea|rejected</span><br><span class="line">io&#x3D;&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br><span class="line">···</span><br></pre></td></tr></table></figure><div id="flowchart-4" class="flow-chart"></div><hr><p>参考资料:</p><p>参考资料:<a href="http://flowchart.js.org/" target="_blank" rel="noopener">跳转</a><br><code>http://flowchart.js.org/</code></p><p>获取方式:<br><code>npm install --save hexo-filter-flowchart</code></p><p>配置方式：<br>安装完成后进入根目录修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart: </span><br><span class="line">#raphael:#optional, the source url of raphael.js </span><br><span class="line">#flowchart:#optional, the source url of flowchart.js</span><br><span class="line">options:#options used for &#96;drawSVG&#96;</span><br></pre></td></tr></table></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.7/raphael.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/flowchart/1.6.5/flowchart.min.js"></script><textarea id="flowchart-0-code" style="display:none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st->op->condcond(yes)->io->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-0-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-0-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-0",options)</script><textarea id="flowchart-1-code" style="display:none">st=>start: 开始框op=>operation: 处理框cond=>condition: 判断框(是或否?)sub1=>subroutine: 子流程io=>inputoutput: 输入输出框e=>end: 结束框st(right)->op(right)->condcond(yes)->io(bottom)->econd(no)->sub1(right)->op</textarea><textarea id="flowchart-1-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-1-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-1-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-1",options)</script><textarea id="flowchart-2-code" style="display:none">st=>start: 开始语句in=>inputoutput: 输入值e=>end: 结束语句op=>operation: 执行操作cond=>condition: 是否成立？out=>inputoutput: 输出值st->in->op->condcond(yes)->outcond(no)->opout->e</textarea><textarea id="flowchart-2-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-2-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-2-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-2",options)</script><textarea id="flowchart-3-code" style="display:none">st=>start: Starte=>end: Why are you worried?cond1=>condition: Do you have a problem?cond2=>condition: Can you solve it?op=>operation: Since you can't solve it,st->cond1cond1(yes)->cond2cond1(no)->econd2(yes)->econd2(no)->op->e</textarea><textarea id="flowchart-3-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-3-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-3-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-3",options)</script><textarea id="flowchart-4-code" style="display:none">st=>start: Start|past:>http://www.baidu.come=>end: End:>http://www.baidu.comop1=>operation: My Operation|pastop2=>operation: Stuff|currentsub1=>subroutine: My Subroutine|invalidcond=>condition: Yes or No?|approved:>http://www.baidu.comc2=>condition: Good idea|rejectedio=>inputoutput: catch something...|requestst->op1(right)->condcond(yes, right)->c2cond(no)->sub1(left)->op1c2(yes)->io->ec2(no)->op2->e</textarea><textarea id="flowchart-4-options" style="display:none">{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12}</textarea><script>var code=document.getElementById("flowchart-4-code").value,options=JSON.parse(decodeURIComponent(document.getElementById("flowchart-4-options").value)),diagram=flowchart.parse(code);diagram.drawSVG("flowchart-4",options)</script><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Feb 05 2020 13:20:58 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;语法结构&quot;&gt;&lt;a href=&quot;#语法结构&quot; class=&quot;headerlink&quot; title=&quot;语法结构&quot;&gt;&lt;/a&gt;语法结构&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="杂项" scheme="https://unit-serow.github.io/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>分布式版本控制系统-Git-2</title>
    <link href="https://unit-serow.github.io/2020/02/04/Git-3/"/>
    <id>https://unit-serow.github.io/2020/02/04/Git-3/</id>
    <published>2020-02-04T06:13:34.000Z</published>
    <updated>2020-02-04T06:16:56.277Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第二章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第二章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第二章节"></a>分布式版本控制系统(Distributed Version Control) Git-第二章节</h3><p><strong>基本操作</strong></p><ul><li>上篇文章的末尾写了一点关于git创建新仓库和克隆项目的基本操作</li><li>这一章着重对暂存区内快照的管理与操作和分支的管理与操作进行说明</li><li>在<code>git init</code>后，在工作区的根目录会生成<code>.git</code>子目录，它就是本地主机的Git仓库，所有关于工作区项目的快照数据都存放在此目录下</li><li>Git主要工作就是创建和保存工作区中项目的快照及与其他时间段的快照进行对比</li></ul><ol><li><p><code>git add</code><br>用于将工作区修改或进行操作的任何文件添加到缓存目录，也就是暂存区<br><code>git add .</code><br>添加当前项目的所有文件</p></li><li><p><code>git status</code><br>用于查看工作区当前的状态，执行完<code>git status</code>就能看到工作区向暂存区进行的任何操作<br>可以添加参数，比如添加<code>-s参数</code>，以输出经过简化的结果<br><code>A/M filename</code>的意思是这个文件在添加到暂存区之后又有改动了</p></li><li><p><code>git diff</code><br>用以查看执行git status 输出结果的详细信息<br>参数信息</p></li></ol><ul><li><code>git diff</code>命令会输出暂存区以修改但尚未写入暂存区的改动的区别</li><li><code>git diff</code>尚未写入暂存区的改动</li><li><code>git diff --cached</code>查看已写如暂存区的改动</li><li><code>git diff HEAD</code>查看已写入暂存区的与未写入暂存区的所有改动</li><li><code>git diff --stat</code>输出简明的diff结果</li></ul><ol start="4"><li><p><code>git commit</code><br>将暂存区的内容添加到仓库中<br>因为每一次提交都要输入一次github的用户名和邮箱地址，所以可以先配置一下用户名和邮箱地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &#39;用户名&#39;</span><br><span class="line">git config --global user.email 邮箱地址</span><br></pre></td></tr></table></figure><p><code>参数-m</code>在命令行中提供提交注释，如果没有此参数，Git就会自动打开一个编辑器以填写提交信息<br><code>参数-a</code>可以跳过<code>git add</code>提交至暂存区</p></li><li><p><code>git reset HEAD filename</code><br><code>filename</code>是指已提交到暂存区的内容<br>用于取消已缓存的内容<br>执行<code>git reset HEAD</code>以取消之前的<code>git add</code>，并且不包含下一个提交完成后的暂存区快照</p></li><li><p><code>git rm</code><br>从工作区删除某个文件，需要从已跟踪文件的清单中移除，然后再去提交<br><code>git rm filename</code><br>如果该文件修改过并且已经提交到暂存区而还要删除的话，必须使用强制删除<code>参数-f</code><br><code>git rm -f filename</code><br>把文件从暂存区删除，或者说是从跟踪清单中删除，使用<code>--cached</code>参数<br><code>git rm --cached filename</code><br>使用<code>-r</code>参数用以递归删除，删除该目录下的所有文件和子目录<br><code>git rm -r</code>文件目录</p></li><li><p><code>git mv</code><br>用于移动或重命名一个文件夹，目录或软链接<br><code>git mv filename newfilename</code></p></li><li><p><code>git push</code><br>用于将本地工作区的最新消息推送到远端仓库</p></li><li><p><code>git pull</code><br>用于从远端仓库拉取最新的版本到本地工作区，并且自动与工作区内部的项目与数据自动合并(merge)</p></li><li><p><code>git fetch</code><br>用于是从远端仓库拉取最新版本到本地工作区，并且不会自动合并</p></li><li><p><code>git merge</code><br>用于从指定的分支合并到当前的分支，从而合并两个分支<br><code>git pull</code>相当于<code>git fetch + git merge</code></p></li></ol><hr><p><strong>Git查看提交日志</strong><br>12. <code>git log</code></p><ul><li><code>参数--oneline</code>查看简明版本</li><li><code>参数--graph</code>查看分支，合并等操作的日志，并显示拓扑图</li><li><code>参数--reverse</code>逆向输入所有日志</li><li><code>参数--author=用户名</code>查看指定用户的提交日志</li><li><code>参数--since，--before，--after，--until</code>查看指定日期<br>日志命令参考<a href="https://git-scm.com/docs/git-log" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/docs/git-log</code></li></ul><ol start="13"><li>git 标签<br><code>git tag -a 标签名</code><br>用于给当前快照打上标签</li></ol><hr><p><strong>使用Git连接远端的Github仓库</strong></p><p>添加一个新的远程仓库<br>14. <code>git remote add shortname url</code></p><p>查看当前的远程库<br>15. <code>git remote</code></p><p>拉取远程库<br>从远程仓库克隆新分支与数据<br>16. <code>git fetch alias</code><br>然后执行git merge 将远程分支到本地工作区所在的分支<br>17. <code>git merge alias/branch</code><br>从远端仓库提取更新数据并尝试合并到当前分支<br>一般执行完<code>git fetch</code>之后就会紧接着执行<code>git merge</code>，前者去对数据进行过滤，获取当前工作区没有的新数据，后者用于将新数据合并到本地工作区当前分支的项目</p><p>推送到远程仓库<br>18. <code>git push alias branch</code><br>将本地(branch)分支中的暂存区文件推到(alias)远端仓库上的(branch)分支<br>用于将本地暂存区的新数据推到某个远端仓库</p><p>删除远端仓库<br>19. <code>git remote rm [别名]</code></p><p><strong>生成ssh key</strong><br>20. * <code>ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</code></p><ul><li>会在<code>/root/.ssh</code>目录生成密匙文件，打开<code>id_rsa.pub</code>，复制里面的key</li><li>然后进入Github并登入Github，点击头像内的<code>setting</code>选项卡内的<code>SSH and GPG keys</code>中的<code>SSH Keys</code>选项卡</li><li>将文件里的key拷贝到key中，title随意，然后<code>add ssh key</code></li><li>验证是否成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line">Hi Unit-serow! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>具体可以参考一下<a href="https://help.github.com/articles/generating-ssh-keys" target="_blank" rel="noopener">跳转</a><br><code>https://help.github.com/articles/generating-ssh-keys</code></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;分布式版本控制系统-Distributed-Version-Control-Git-第二章节&quot;&gt;&lt;a href=&quot;#分布式版本控制系统-Di
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Git" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Git/"/>
    
    
      <category term="2.应用与拓展" scheme="https://unit-serow.github.io/tags/2-%E5%BA%94%E7%94%A8%E4%B8%8E%E6%8B%93%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>分布式版本控制系统-Git-1</title>
    <link href="https://unit-serow.github.io/2020/02/04/Git-2/"/>
    <id>https://unit-serow.github.io/2020/02/04/Git-2/</id>
    <published>2020-02-04T06:11:42.000Z</published>
    <updated>2020-02-04T06:15:23.087Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --><h3 id="分布式版本控制系统-Distributed-Version-Control-Git-第一章节"><a href="#分布式版本控制系统-Distributed-Version-Control-Git-第一章节" class="headerlink" title="分布式版本控制系统(Distributed Version Control) Git-第一章节"></a>分布式版本控制系统(Distributed Version Control) Git-第一章节</h3><p><strong>概述:</strong></p><ul><li>Git 是一个开源的分布式版本控制系统，用于帮助以群为单位的开发者们处理任何相同类型的项目(或称为同一项目)</li><li>Git 还可以指 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</li><li>Git 的性质使他不仅用于版本控制，还可用于内容管理 CMS 与工作管理等</li></ul><p><strong>关于 Git 的分布式</strong></p><ul><li>Git把内容按元数据的方式去存储，分布式的版本控制就是每个人都可以创建一个独立的代码仓库用于管理，各种版本的操作都可以再本地完成，每个人修改的代码都可以经过推送合并到另外一个代码仓库中，所以Git这种分布式的版本控制系统更适合个人的开发</li><li>因为分散式版本控制系统本质的关系，使得此类系统更重视对分支(branch)的支持，它们通常有较好的分支及合并的能力</li><li>在分散式版本控制系统中，开发者可以进行推(push)的动作，其意义是将自身档案库中的变更送至其他的档案库，也可以进行拉(pull)的动作，其意义是获取其他档案库的变更</li><li>处于分布式版本控制系统中的每个个体之间的关系是完全独立且自由的，他们完全自由并且完全可以参照自己的意愿来对远端的代码仓库进行实时的操作</li><li>学习Git时最重要的是对其分支管理系统的了解，这是它的本质与执行的逻辑核心</li></ul><p><strong>使用Git进行工作的通常流程</strong></p><ul><li>从远端仓库克隆代码到本地并作为工作目录</li><li>对克隆的资源进行操作</li><li>如果有人已经对其修改了，可以在本地更新资源</li><li>在提交前查看修改内容并提交修改内容</li><li>在修改完成后，如果发现错误，可以撤回并再次修改并提交</li></ul><hr><p><strong>最基本的使用</strong></p><p><code>git init</code><br>使用git init 创建或初始化一个仓库，通常是使用git的第一个命令<br>在执行完成git init命令后，git仓库会生成一个.git目录，该目录包含了所有资源的元数据，而其它项目的目录保持不变</p><p><code>git clone</code><br>从指定以存在的Git远端仓库中克隆项目<br><code>git clone repo(Git 仓库名)</code><br>还可以指定克隆的目录<br><code>git clone repo directory(本地目录)</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Feb 04 2020 14:17:01 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;分布式版本控制系统-Distributed-Version-Control-Git-第一章节&quot;&gt;&lt;a href=&quot;#分布式版本控制系统-Di
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="Git" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/Git/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客文件远端备份与恢复</title>
    <link href="https://unit-serow.github.io/2020/02/03/hexo%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/"/>
    <id>https://unit-serow.github.io/2020/02/03/hexo%E6%96%87%E4%BB%B6%E5%A4%87%E4%BB%BD/</id>
    <published>2020-02-03T12:47:37.000Z</published>
    <updated>2020-02-03T12:49:57.189Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Feb 03 2020 20:50:21 GMT+0800 (中国标准时间) --><h3 id="hexo博客文件远端备份与恢复"><a href="#hexo博客文件远端备份与恢复" class="headerlink" title="hexo博客文件远端备份与恢复"></a>hexo博客文件远端备份与恢复</h3><ul><li>其实就是将本地工作区的数据上传到远端仓库</li><li>因为再创建一个代码仓库有点浪费，所以用再原仓库内建立新分支的方法去备份博客</li><li>在创建新分支之前先确保博客内有默认主分支master</li></ul><p><strong>按顺序执行以下指令:</strong></p><ul><li><code>git init //创建一个新的Git仓库或初始化一个现有的仓库</code><br>该命令创建一个空的Git版本库和暂存区，基本上具有对象库，指针(HEAD)库和模板文件等等的隐藏目录.git<br>现有存储库中运行git init命令是安全的，所以不会覆盖已经存在的数据</li><li><code>git add .</code><br>将本地文件依次添加到暂存区</li><li><code>git commit -m &#39;hexo&#39;(需要进行备份的文件名，比如说hexo的根目录)</code><br>将文件数据提交至本地暂存区文件内，然后再将暂存区的改动提交到本地的版本库</li><li><code>git branch hexo</code><br>创建一个名为hexo的新分支</li><li><code>git checkout hexo</code><br>切换到hexo分支上</li><li><code>git remote add origin Github仓库地址</code><br>让仓库地址/URL实现本地与远程Github仓库的对接</li><li><code>git push origin hexo(推送文件目录)</code><br>推送本地工作区(仓库)内容到远程仓库的hexo分支，远程仓库的默认命名是origin</li></ul><p>创建新的仓库时会默认建立.gitignore文件，用于将不需要备份的文件屏蔽</p><p>以后备份的时候只需要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m &quot;Backname&quot;</span><br><span class="line">git push orgin hexo</span><br><span class="line">hexo g与hexo d</span><br></pre></td></tr></table></figure><hr><p><strong>恢复博客</strong></p><p>在本地机器上克隆博客文件的hexo分支<br><code>git clone https://github.com/yourgithubname/yourgithubname.github.io</code></p><p>分别执行以恢复博客</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><hr><p><strong>其他指令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to&#x3D;origin&#x2F;分支名称 &#x2F;&#x2F;在所选仓库内设置默认分支</span><br><span class="line">git remote &#x2F;&#x2F;查看所有远程仓库</span><br><span class="line">gir remote rm origin &#x2F;&#x2F;删除所关联的远程仓库地址</span><br><span class="line">git remote add origin 新仓库地址 &#x2F;&#x2F;添加新仓库地址</span><br><span class="line">git push orign master &#x2F;&#x2F;提交到新仓库中的默认分支</span><br><span class="line">git submodule init &#x2F;&#x2F;初始化本地配置文件</span><br><span class="line">git submodule update &#x2F;&#x2F;抓取所有数据并检出项目中列出的合适的提交</span><br><span class="line">git rm --cached file &#x2F;&#x2F;从暂存区删除文件，工作区不做出改变</span><br><span class="line">git checkout . &#x2F;&#x2F;重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件</span><br><span class="line">git pull 参数[options]  仓库名[repository]  分支名[refspec...] &#x2F;&#x2F;从一个仓库或者本地的分支拉取并合并代码，相当于 git fetch 跟着一个 git merge FETCH_HEAD</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Feb 03 2020 20:50:21 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;hexo博客文件远端备份与恢复&quot;&gt;&lt;a href=&quot;#hexo博客文件远端备份与恢复&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
    
      <category term="hexo" scheme="https://unit-serow.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>版本控制系统 Git-分支</title>
    <link href="https://unit-serow.github.io/2020/02/03/Git-1/"/>
    <id>https://unit-serow.github.io/2020/02/03/Git-1/</id>
    <published>2020-02-03T10:51:45.000Z</published>
    <updated>2020-02-03T12:50:16.129Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Feb 03 2020 20:50:21 GMT+0800 (中国标准时间) --><h2 id="Git-版本控制系统"><a href="#Git-版本控制系统" class="headerlink" title="Git 版本控制系统"></a>Git 版本控制系统</h2><h3 id="远端分支的上传与本地分支的处理的执行逻辑与原理"><a href="#远端分支的上传与本地分支的处理的执行逻辑与原理" class="headerlink" title="远端分支的上传与本地分支的处理的执行逻辑与原理"></a>远端分支的上传与本地分支的处理的执行逻辑与原理</h3><p><strong>远端分支</strong></p><ul><li>在本地进行任何连接Git远端服务器或远端服务器分支的操作时，远端服务器内会创建一个默认分支，之后在本地会生成一个对应该默认分支的分支</li><li>下文描述说明:服务器的分支被称为<code>origin/master</code>，而本地的分支被称为<code>master</code></li></ul><p><strong>执行原理:</strong></p><ul><li>在本地执行<code>git clone</code>命令克隆远端数据之后，git的clone会自动将所连接远端服务器命名为origin(执行该命令就是克隆URL所指定服务器内的所有数据)</li><li>同时在远端origin服务器内创建了指向它默认主分支(master)的指针，并在远端的服务器内为分支命名为<code>origin/master</code>(默认仓库名与此仓库内的默认分支名)</li><li>然后远端的git服务器也会给本地主机添加本地的master指针，该指针与远端服务器origin的master分支指向同的目标</li><li>从而从本地就可以操作远程服务器origin的分支了(origin的任何分支-这里指master分支)，进而实现数据推送</li></ul><p><strong>逻辑关系的链接表示:</strong></p><blockquote><p>-表示线性执行的逻辑关系<br>本地主机-远程仓库-远程仓库内的若干个分支(分支也可以拥有分支)<br>默认远程仓库被命名为origin，而其下默认分支被默认命名为master<br>一般情况下，远程仓库内拥有最少一个默认分支，并将其默认定义为主分支，对主分支的定义可以进行改动</p></blockquote><hr><p><strong>本地分支</strong></p><p><strong>工作区，暂存区与版本库的概念与其中的关系介绍:</strong></p><ul><li>工作区就是本地主机的文件文件目录</li><li>暂存区(stage或index)，一般存放在隐藏目录.git下的<code>index</code>文件中,暂存区也可以被叫做索引(index)</li><li>版本库 工作区内的隐藏目录<code>.git</code>就被称之为版本库，其中包含了暂存区文件，对象库，游标(HEAD)文件与本地分支等等</li><li>正常情况下的操作都是由工作区发出命令然后传于版本库内进行各级执行</li></ul><p><strong>逻辑关系表示:</strong></p><blockquote><p>工作区-[版本库-(暂存区-本地分支/对象库)]-远端服务器<br>这里的-用于表示包含，链接与单向执行逻辑</p></blockquote><p><strong>逻辑关系:</strong></p><ul><li>当工作区内修改或新增文件之后执行git add 命令之后，暂存区的目录会被更新</li><li>同时工作区修改或新增文件的内容也被写入对象库中的一个新的对象库中，而该对象的ID也被记录在暂存区的文件索引中</li><li>当执行提交操作<code>git commit</code>时，暂存区的目录树会写到版本库中的对象库中</li><li>之后默认分支master或设置的本地分支经由游标(HEAD)的指向会对所选分支作出相应的更新</li><li>默认分支master或设置的本地分支指向的目录树就是提交至远端时暂存区的目录树</li><li>进而推送暂存区的目录树(也就是本地存储于所选分支内暂存区的所有数据)至远端</li></ul><p><strong>命令原理与版本库内目录简要介绍:</strong></p><ul><li><p>执行<code>git reset HEAD(游标名)</code>命令时，更新暂存区操作，暂存区的目录会被重写，而被master分支的游标所指向的目录树所交换，工作区不受影响</p></li><li><p>执行<code>git rm --cached filename</code>命令时 ，从暂存区删除文件，而工作区不做出改变</p></li><li><p>执行<code>git checkout .</code>命令时重新指定本地分支，用暂存区全部或指定的文件替换工作区的文件，会清除工作区中未添加到暂存区的改动</p></li><li><p>执行<code>git checkout HEAD .</code>或<code>git checkout HEAD filename</code>命令时，会用游标(HEAD)指向的master分支中的全部或者部分文件替换暂存区和以及工作区中的文件，不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动</p></li><li><p>执行<code>git fetch origin</code>命令用于同步数据，原理就是从中抓取本地没有的数据并且更新本地数据，同时游标(HEAD)也会更新</p></li><li><p>对象库位于<code>.git/objects</code>目录下，里面包含了创建的各种对象及内容</p></li><li><p>暂存库位于<code>.git/index</code>目录下</p></li><li><p>游标位于<code>.git/HEAD</code>目录下</p></li></ul><p>本文所描述的游标，也可以称之为指针，用指针去理解会更简单</p><h2 id="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"><a href="#论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考" class="headerlink" title="论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考"></a>论题由Git的连接机制而引出，因为是完全性的主观理解，执行与结构的逻辑关系可能别有出入，仅供参考</h2><p>参考文案:</p><p>Git官网:<a href="https://git-scm.com/" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/</code></p><p>CN-Git 分支简介:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%AE%80%E4%BB%8B</code></p><p>CN-Git 分支使用:<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">跳转</a><br><code>https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Feb 03 2020 20:50:21 GMT+0800 (中国标准时间) --&gt;&lt;h2 id=&quot;Git-版本控制系统&quot;&gt;&lt;a href=&quot;#Git-版本控制系统&quot; class=&quot;headerlink&quot; title=&quot;Git 版本控制系统
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="版本控制系统" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Git" scheme="https://unit-serow.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>GNU Binary File Descriptor/BFD</title>
    <link href="https://unit-serow.github.io/2020/02/02/BFD/"/>
    <id>https://unit-serow.github.io/2020/02/02/BFD/</id>
    <published>2020-02-02T13:33:28.000Z</published>
    <updated>2020-02-02T13:40:59.170Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Binary-File-Descriptor"><a href="#GNU-Binary-File-Descriptor" class="headerlink" title="GNU Binary File Descriptor"></a>GNU Binary File Descriptor</h3><p><strong>GNU 二进制文件描述 BFD</strong></p><p><strong>概述:</strong></p><ul><li>目的是用于解决GNU项目中不同的目标文件的可移植性的主要机制</li><li>在GNU项目中对于不同目标文件可移植EFL<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>性问题的主要解决机制</li><li>BFD库还可以用来读取核心转储的结构化数据</li><li>截至至2003年，它支持25中不同体系结构的CPU上的大约50中文件格式</li></ul><p><strong>BFD的设计逻辑与执行逻辑:</strong></p><ul><li>BFD通过对目标文件<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>提供抽象视图来达成工作</li><li>BFD在内部将数据从抽象视图转到目标处理器所规定的文件格式所要求的节与数据结构/字节布局等细节</li><li>它关键的作用是处理字节序的差异<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>,包括寻址<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>算术等细节</li><li>BFD最初的设计目的是可以成为被各种工具所使用的通用库，但为了达成这一目的就需要频繁修补API来解决系统所带来的影响与容纳新系统的功能，从而限制了它的使用模式与功能</li><li>DFD的主要用户是<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GAS</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GDL</a>，<a href="https://unit-serow.github.io/2020/02/01/Binutils/">GNU Binutils</a>和<a href="https://unit-serow.github.io/2020/02/01/Debugger/">GDB</a>，因此BFD不单独发行，所以它通常包括在Binutils和GDB的发行之中</li></ul><hr><p><strong>参考资料:</strong></p><p>参考网站-BFD的历史与故事<a href="https://www.oreilly.com/openbook/opensources/book/tiemans.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.oreilly.com/openbook/opensources/book/tiemans.html</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">ELF-可执行与可链接格式，Executable and Linkable Format简称为ELF ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">目标文件的结构:有一个有描述信息的“头”，可变量目的“段”，每个段都有一个名字，一些属性和一块数据，一个符号表，一组重定位入口顶等等</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display:inline-block;vertical-align:top;padding-right:10px">3.</span><span style="display:inline-block;vertical-align:top">比如在小端序主机和大端序目标之间，在32-bit和64-bit数据之间的正确转换和重定位入口项所指定的寻址算术的细节</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display:inline-block;vertical-align:top;padding-right:10px">4.</span><span style="display:inline-block;vertical-align:top">寻址是每种计算机中央处理器的指令集架构中的一部分，各个指令集下有不同的寻址模式，寻址模式决定了此架构下计算机语言指令所对应的运算数</span><a href="#fnref:4" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Binary-File-Descriptor&quot;&gt;&lt;a href=&quot;#GNU-Binary-File-Descriptor&quot; clas
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU AutoGen</title>
    <link href="https://unit-serow.github.io/2020/02/02/AutoGen/"/>
    <id>https://unit-serow.github.io/2020/02/02/AutoGen/</id>
    <published>2020-02-02T09:10:25.000Z</published>
    <updated>2020-02-02T09:37:35.267Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-AutoGen"><a href="#GNU-AutoGen" class="headerlink" title="GNU AutoGen"></a>GNU AutoGen</h3><p><strong>GNU 代码维护工具</strong></p><p><strong>概述:</strong></p><ul><li>AutoGen用于简化包含大量重复文本，指令集与宏定义的程序的创建和维护，所以在必须完全保持多个文本块同步的程序中，它能发挥很大的作用</li><li>除了CGL数据与已有的AutoGen定义之外，AutoGen还可以自定义格式或将XML文件作为输入定义</li><li>它经常被用于创建和维护处理程序选项所需的代码，处理选项需要在程序之间的不同位置同时维护多个构造，所以对于选件的维护是没有尽头的</li><li>因此，autogen带有一个名为autoopts的附加软件包，它用于简化程序选项的维护和文档编制</li><li>已知autogen可在GNU/Linux，BSD，OS/X，等其他操作系统上工作</li><li>它的最终目的是在任何具有ANSI C编译器的现代UNIX系统上运行</li></ul><hr><p><strong>参考资料:</strong></p><p>源码获取:<a href="http://autogen.sourceforge.net/data/" target="_blank" rel="noopener">跳转</a><br><code>http://autogen.sourceforge.net/data/</code></p><p>手册<a href="https://www.gnu.org/software/autogen/manual/html_node/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/manual/html_node/autogen.html</code></p><p>快捷参考<a href="https://www.gnu.org/software/autogen/man1-autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/autogen/man1-autogen.html</code></p><p>autogen官网<a href="https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/savannah-checkouts/gnu/autogen/autogen.html</code></p><p>开发者社区<a href="http://savannah.gnu.org/projects/autogen" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/projects/autogen</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-AutoGen&quot;&gt;&lt;a href=&quot;#GNU-AutoGen&quot; class=&quot;headerlink&quot; title=&quot;GNU Auto
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Data Display Debugger</title>
    <link href="https://unit-serow.github.io/2020/02/02/DDD/"/>
    <id>https://unit-serow.github.io/2020/02/02/DDD/</id>
    <published>2020-02-02T08:25:37.000Z</published>
    <updated>2020-02-02T10:07:38.843Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Data-Display-Debugger"><a href="#GNU-Data-Display-Debugger" class="headerlink" title="GNU Data Display Debugger"></a>GNU Data Display Debugger</h3><p><strong>GNU 调试器前端 DDD</strong></p><p><strong>概述:</strong></p><p>DDD:</p><ul><li>DDD基于GPL许可证发行</li><li>DDD是GNU计划的一个重要的组成部分</li><li>DDD主要用于Unix系统,并且有许多开源插件对其使用性的补充</li><li>GNU DDD是一个用于数据显示的调试器前端(Debugger front-end)，它使用motif工具包实现GUI</li><li>应用于诸如GDB,DBX,JDB,XDB,多种语言调试器和bash等命令行调试器的调试器前端，也包括GNU Make调试器等用于调试器的调试器前端</li><li>DDD拥有GUI前端的功能，可以查看源文本及其交互式图形数据的显示，将数据结构以图形化显示</li></ul><p>GCL:</p><ul><li>调试器前端就是所指调试器所使用的命令行解释器/命令行界面(CLI)，这里所指的调试器前端就是DDD</li><li>一个好的CLI可以最大程度的提高可移植性并最大程度地减少资源消耗</li><li>而最让开发者们青睐的还得是具备GUI的CLI，所以有一些GUI调试器的前端被设计成与各种GLI相兼容，还有一些GUI则针对某一个特定的GLI</li></ul><hr><p><strong>参考资料:</strong></p><p>文档<a href="https://www.gnu.org/software/ddd/manual/html_mono/ddd.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/manual/html_mono/ddd.html</code></p><p>官网<a href="https://www.gnu.org/software/ddd/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/ddd/</code></p><p>社区<a href="http://savannah.gnu.org/svn/?group=ddd" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org/svn/?group=ddd</code></p><p><a href="https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html" target="_blank" rel="noopener">参考资料:</a><br><code>https://lists.gnu.org/archive/html/ddd/2009-02/msg00001.html</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Data-Display-Debugger&quot;&gt;&lt;a href=&quot;#GNU-Data-Display-Debugger&quot; class=
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Common Lisp</title>
    <link href="https://unit-serow.github.io/2020/02/02/GCL/"/>
    <id>https://unit-serow.github.io/2020/02/02/GCL/</id>
    <published>2020-02-02T07:40:09.000Z</published>
    <updated>2020-02-02T07:41:39.475Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Common-Lisp"><a href="#GNU-Common-Lisp" class="headerlink" title="GNU Common Lisp"></a>GNU Common Lisp</h3><p><strong>GNU Common Lisp编译器 GCL</strong></p><p><strong>概述:</strong></p><ul><li>不要与GNU CLISP和Common Lisp的概念混淆</li><li>GNU Common Lisp（GCL）是GNU计划中ANSI Common Lisp的编译器</li><li>它是Kyoto Common Lisp的演化版</li><li>它的执行过程通常是先生成C代码然后调用C的编译器来生成本机的目标代码</li><li>GCL是包括数学工具maxima，AXIOM,HOL88和ACL2在内的几个大型项目的首选实现</li><li>GCL可以在Linux或FreeBSD，microsoft windows等11种不同体系架构的系统下运行</li></ul><hr><p><strong>参考资料:</strong></p><p>FSF的GCL社区<a href="https://directory.fsf.org/wiki/Gcl" target="_blank" rel="noopener">跳转</a><br><code>https://directory.fsf.org/wiki/Gcl</code></p><p>官网社区<a href="https://www.gnu.org/software/gcl/gcl.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gcl/gcl.html</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Common-Lisp&quot;&gt;&lt;a href=&quot;#GNU-Common-Lisp&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU CLISP</title>
    <link href="https://unit-serow.github.io/2020/02/02/CLISP/"/>
    <id>https://unit-serow.github.io/2020/02/02/CLISP/</id>
    <published>2020-02-02T07:07:25.000Z</published>
    <updated>2020-02-02T07:11:52.367Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-ANSI-Common-Lisp"><a href="#GNU-ANSI-Common-Lisp" class="headerlink" title="GNU ANSI Common Lisp"></a>GNU ANSI Common Lisp</h3><p><strong>概述:</strong></p><p>摘要:</p><blockquote><p>用于实现 ANSI Common Lisp <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>中所描述的语言标准，并且拥有许多拓展<br>CLISP于大多数GNU与Unix系统上运行，还包括windows NT,ME等等，只需要4MB的RAM<br>common lisp是一种面向对象的通用高级编程语言<br>common lisp算是lisp语言的一种方言吧</p></blockquote><p>参考文献:<br>ANSI Common Lisp 中文翻译版<a href="https://acl.readthedocs.io/en/latest/" target="_blank" rel="noopener">跳转</a><br><code>https://acl.readthedocs.io/en/latest/</code></p><p>电子书版本<a href="https://web.archive.org/web/20020805060924/http://www.lisp.org/HyperSpec/FrontMatter/index.html" target="_blank" rel="noopener">跳转</a><br><code>https://web.archive.org/web/20020805060924/http://www.lisp.org/HyperSpec/FrontMatter/index.html</code></p><p>官方网站<a href="https://clisp.sourceforge.io/summary.html" target="_blank" rel="noopener">跳转</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;clisp.sourceforge.io&#x2F;summary.html</span><br><span class="line">https:&#x2F;&#x2F;www.gnu.org&#x2F;software&#x2F;clisp&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;clisp.sourceforge.io&#x2F;</span><br></pre></td></tr></table></figure><p>参考手册<a href="https://clisp.sourceforge.io/impnotes/clisp.html" target="_blank" rel="noopener">跳转</a><br><code>https://clisp.sourceforge.io/impnotes/clisp.html</code></p><p>获取:<br><a href="http/SF">跳转</a>/<a href="http://ftp.gnu.org/pub/gnu/clisp/" target="_blank" rel="noopener">跳转</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http&#x2F;SF</span><br><span class="line">http:&#x2F;&#x2F;ftp.gnu.org&#x2F;pub&#x2F;gnu&#x2F;clisp&#x2F;</span><br></pre></td></tr></table></figure><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">基于ANSI标准的common lisp语言的实现(编译器、调试器和解释器) ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-ANSI-Common-Lisp&quot;&gt;&lt;a href=&quot;#GNU-ANSI-Common-Lisp&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Gettext</title>
    <link href="https://unit-serow.github.io/2020/02/02/Gettext/"/>
    <id>https://unit-serow.github.io/2020/02/02/Gettext/</id>
    <published>2020-02-02T05:59:34.000Z</published>
    <updated>2020-02-02T06:11:48.627Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Gettext-第一章节"><a href="#GNU-Gettext-第一章节" class="headerlink" title="GNU Gettext 第一章节"></a>GNU Gettext 第一章节</h3><p><strong>GNU 国际化(i18n)库</strong></p><p><strong>概述:</strong></p><ul><li>国际化与本地化函数库</li><li>GNU gettext是GNU translation project中最重要的一步</li><li>GNU通用性翻译计划</li><li>这个项目的达成将会让GNU拥有更大的经济与用户结构，从而拥有更多的资本</li></ul><p><strong>引用自官方文档:</strong></p><blockquote><p>在以前，通常GNU内部或大量其它的自由软件中的程序源代码都是拿英文编写或记录的，并且在与用户交互的界面所使用的也是英语<br>当世界上所有的开发人员之间使用一种通用的语言去交流会让开发的过程变得极为方便<br>但是，在全世界范围内的大多数人对于英文的理解能力和学习深度远不如母语，所以它们更愿意使用母语进行日常工作<br>并且大多数人只是希望让屏幕上其它晦涩难懂的语言少一点，而自己的母语多一点<br>所以就有了GNU Gettext<br>该软件包为程序员，翻译人员与用户提供了一套完善的工具和文档集<br>更准确的说，gnu gettext所使用的程序是一组工具，提供了一个框架来帮助其他GNU软件包生成多语言的消息</p></blockquote><p><strong>这个工具包括了以下的一组程序:</strong></p><ul><li>一套如何编写程序，从而让消息目录支持的规则</li><li>一套如何为目录本身和文件命名的规则</li><li>一个运行时库，用于支持检索翻译后的消息</li><li>一些独立程序，以各种方式处理可翻译的字符串或已翻译字符串的集合</li></ul><p>GNU Emacs拥有实现这套程序的插件或拓展，感兴趣的可以去查询有关GNU Emacs的消息</p><hr><p>逻辑简述:<br>以下内容参考自:<a href="https://www.gnu.org/software/gettext/manual/html_node/Program-Index.html#Program-Index" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/manual/html_node/Program-Index.html#Program-Index</code></p><ul><li>xgettext程序从源代码生成.pot文件，作为源代码中序翻译内容的模板</li><li>而翻译者需要工作的对象是.po文件，它是有msginit程序从.pot模板文件生成的</li><li>翻译者用maginit初始化中文翻译文件时可以执行<code>msginit --locale=cn --input=name.pot</code></li><li>然后编辑所生成的.po文件</li><li>最后.po文件需要使用msgfmt编译为.mo文件以用作发布</li><li>使其运行需要使用UNIX操作系统中的用户需要修改环境变量中的<code>LC_MESSAGES</code>或<code>LANG</code>，程序将自动从相应的.mo文件中读取语言信息</li></ul><p>使用方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在使用gettext()方法的时候通常以标记别名_的形式使用</span><br><span class="line">如printf(gettext(&quot;name is %s. \n&quot;), first_name);</span><br><span class="line">可以写作printf(_(&quot;name is %s.\n&quot;), first_name);</span><br></pre></td></tr></table></figure><hr><p>参考资料:<br>官方网站<a href="https://www.gnu.org/software/gettext/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/</code><br>获取<a href="https://ftp.gnu.org/pub/gnu/gettext/gettext-0.20.1.tar.gz" target="_blank" rel="noopener">跳转</a><br><code>https://ftp.gnu.org/pub/gnu/gettext/gettext-0.20.1.tar.gz</code><br>社区<a href="https://savannah.gnu.org/projects/gettext/" target="_blank" rel="noopener">跳转</a><br><code>https://savannah.gnu.org/projects/gettext/</code><br>文档<a href="https://www.gnu.org/software/gettext/manual/gettext.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gettext/manual/gettext.html</code></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Gettext-第一章节&quot;&gt;&lt;a href=&quot;#GNU-Gettext-第一章节&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Portable Threads/Pth</title>
    <link href="https://unit-serow.github.io/2020/02/02/Pth/"/>
    <id>https://unit-serow.github.io/2020/02/02/Pth/</id>
    <published>2020-02-01T17:57:11.000Z</published>
    <updated>2020-02-01T18:09:26.821Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Portable-Threads-第一章节"><a href="#GNU-Portable-Threads-第一章节" class="headerlink" title="GNU Portable Threads 第一章节"></a>GNU Portable Threads 第一章节</h3><p><strong>GNU 可移植线程库 Pth</strong></p><p><strong>概述:</strong></p><ul><li>GNU计划重要的一部分</li><li>GNU Pth 是用于UNIX平台下基于POSIX与ANSI C的用户空间线程库</li><li>GNU Pth还包含了POSIX线程的API，以达成向后兼容的目的</li></ul><p>GNU Pth使用到内核空间线程的N:1映射，所以说调度完全将完全由GNU Pth库进行<br>内核将不会干涉用户空间中任何数量的线程，所以利用不到SMP<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>所拥有的机制，因为SMP必须由内核派遣</p><p><strong>存在目的:</strong></p><ul><li>GNU Pth的目的是针对任意线程的处理达到高度的可移植性</li><li>其次是为了让多线程应用提供基于优先级的调度</li></ul><hr><p><strong>参考资料:</strong></p><p>官方网站<a href="https://www.gnu.org/software/pth/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth</code></p><p>官方手册<a href="https://www.gnu.org/software/pth/pth-manual.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth/pth-manual.html</code></p><p>多线程库列表<a href="https://www.gnu.org/software/pth/related.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/pth/related.html</code></p><p><a href="https://www.gnu.org/software/pth/related.html" target="_blank" rel="noopener">多线程库文档，包含了Unix系统中所有对于已知多线程库的调用</a><br><code>https://www.gnu.org/software/pth/related.html</code></p><p>关于OSSP pth<a href="http://www.ossp.org/pkg/lib/pth/" target="_blank" rel="noopener">跳转</a><br><code>http://www.ossp.org/pkg/lib/pth</code></p><p>论文引用:<br><a href="http://heather.cs.ucdavis.edu/~matloff/pth.html" target="_blank" rel="noopener">对于GNU pth的使用与描述</a><br><code>http://heather.cs.ucdavis.edu/~matloff/pth.html</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">均衡多处理架构</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Portable-Threads-第一章节&quot;&gt;&lt;a href=&quot;#GNU-Portable-Threads-第一章节&quot; class=
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU C libary/Libc</title>
    <link href="https://unit-serow.github.io/2020/02/02/Libc/"/>
    <id>https://unit-serow.github.io/2020/02/02/Libc/</id>
    <published>2020-02-01T16:47:10.000Z</published>
    <updated>2020-02-01T17:10:47.552Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-C-Library-第一章节"><a href="#GNU-C-Library-第一章节" class="headerlink" title="GNU C Library 第一章节"></a>GNU C Library 第一章节</h3><p><strong>C 标准函数库 Libc</strong></p><p><strong>概述:</strong></p><ul><li>GNU/Linux操作系统一个重要的组成部分</li><li>FSF为GNU所写，作用是配合linux内核,是Linux下基于ANSI C<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>标准的GNU C<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>标准函数库</li></ul><p><strong>存在目的:</strong></p><ul><li>目的是为linux内核的操作系统提供核心库文件，库提供了关键的API，当然也包括Linux内核的API</li><li>虽说称为C的标准函数库，但还支持很多其他的程序语言</li></ul><hr><p><strong>其它C 标准库</strong></p><p>C POSIX library</p><ul><li>C 可移植标准接口库</li><li>包含了一些在C 标准库之外的函数，这里指ANSI所定制的C 标准库</li></ul><p>CRT/C Run-time Library</p><ul><li>C 运行时期库</li><li>C 程序运行时需要这些库中的函数</li><li>包含于程序运行时使用到的一些API集合，这里的API是预先编译后存放在linux系统中的二进制代码形式的文件</li><li>CRT通常作为C编译程序发布</li><li>CRT含有初始化代码，还有错误处理代码(例如divide by zero处理)</li></ul><hr><p><strong>其它资料:</strong><br>ANSI C库可以根据头文件划分为15个类别<br>其中包括:</p><ul><li>字符类型 ()</li><li>错误码()</li><li>浮点常数 ()</li><li>数学常数 ()</li><li>标准定义 ()</li><li>标准 I/O ()</li><li>工具函数 ()</li><li>字符串操作 ()</li><li>时间和日期 ()</li><li>可变参数表 ()</li><li>信号 ()</li><li>非局部跳转 ()</li><li>本地信息 ()</li><li>程序断言 () 等等</li><li>这在其他的C语言的IDE中都是有的</li></ul><h2 id="以上内容引用自百度百科条目"><a href="#以上内容引用自百度百科条目" class="headerlink" title="以上内容引用自百度百科条目"></a>以上内容引用自百度百科<a href="https://baike.baidu.com/item/libc" target="_blank" rel="noopener">条目</a></h2><p>参考资料:</p><p>GNU C Library连接<a href="https://www.gnu.org/software/libc/involved.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libc/involved.html</code></p><p>C POSIX库参考文献<a href="https://web.archive.org/web/20100724201155/http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/funcref.htm" target="_blank" rel="noopener">跳转</a><br><code>https://web.archive.org/web/20100724201155/http://www.space.unibe.ch/comp_doc/c_manual/C/FUNCTIONS/funcref.htm</code></p><p>C 标准函式库<a href="https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html" target="_blank" rel="noopener">跳转</a><br><code>https://pubs.opengroup.org/onlinepubs/9699919799/idx/head.html</code></p><p>C POSIX library-wiki<a href="https://zh.wikipedia.org/wiki/C_POSIX_library" target="_blank" rel="noopener">跳转</a><br><code>https://zh.wikipedia.org/wiki/C_POSIX_library</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">由美国国家标准局所制定的C语言发布标准-是最基本的C语言函数库，包含了C语言最基本的库函数并且是C语言最初的标准</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display:inline-block;vertical-align:top;padding-right:10px">2.</span><span style="display:inline-block;vertical-align:top">由LGPL许可协议发布的，自由的，公开源代码并且方便下载的C编译程序</span><a href="#fnref:2" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-C-Library-第一章节&quot;&gt;&lt;a href=&quot;#GNU-C-Library-第一章节&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Libtool</title>
    <link href="https://unit-serow.github.io/2020/02/01/Libtool/"/>
    <id>https://unit-serow.github.io/2020/02/01/Libtool/</id>
    <published>2020-02-01T14:58:21.000Z</published>
    <updated>2020-02-01T17:05:09.878Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-libtool-第一章节"><a href="#GNU-libtool-第一章节" class="headerlink" title="GNU libtool 第一章节"></a>GNU libtool 第一章节</h3><p><strong>GNU 构建系统</strong></p><p><strong>概述与解释:</strong></p><ul><li>GNU Libtool是一种属于<a href="https://unit-serow.github.io/2020/01/29/Autotools/">GNU构建系统</a>的GNU程序设计工具</li><li>GNU Libtool是一个用于支持通用库的脚本程序</li><li>用于解决在不同的操作系统中使用共享库进行代码移植的复杂性，在不同的系统中建立动态链接库，以隐藏不同系统之间的差异性</li><li>从而给开发人员提供一致的接口</li><li>但还是需要底层系统对所创建链接库的支持，所以libtool不能在不支持动态连接库的系统中创建动态链接库</li></ul><hr><p><strong>存在目的:</strong></p><ul><li>用于产生/建立便携式的库，它既可以建立动态链接库，也可以建立动态链接库，还可以包含两者</li><li>GNU libtool的目的是使每一个主机类型的完整功能都可以通过一个泛用接口来产生</li><li>GNU libtool的目标是使接口一致</li></ul><hr><p><strong>使用方法</strong><br>本章节不对应用进行过多阐述<br>libtool通常与GNU建构系统中的autoconf和automake这两个工具一起使用<br>需要参照系统手册（构建通用库所需要执行的命令）以及修改相应makefile的makefile.in或makefile.in文件<br>相关内容可查询<a href="https://www.gnu.org/software/libtool/manual/libtool.html" target="_blank" rel="noopener">libtool文档</a></p><hr><p>参考资料</p><p>GNU Libtool手册<a href="https://www.gnu.org/software/libtool/manual/libtool.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libtool/manual/libtool.html</code></p><p>使用GNU Libtoo创建库<a href="https://www.ibm.com/developerworks/cn/aix/library/1007_wuxh_libtool/index.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.ibm.com/developerworks/cn/aix/library/1007_wuxh_libtool/index.html</code></p><p>官方网站<a href="https://www.gnu.org/software/libtool/news.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/libtool/news.html</code></p><p>autobook<a href="http://www.sourceware.org/autobook/" target="_blank" rel="noopener">跳转</a><br><code>http://www.sourceware.org/autobook/</code></p><p>获取:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http: http:&#x2F;&#x2F;ftpmirror.gnu.org&#x2F;libtool&#x2F;</span><br><span class="line">ftp: ftp:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;libtool&#x2F; </span><br><span class="line">克隆: git clone git:&#x2F;&#x2F;git.savannah.gnu.org&#x2F;libtool.git</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-libtool-第一章节&quot;&gt;&lt;a href=&quot;#GNU-libtool-第一章节&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Binutils</title>
    <link href="https://unit-serow.github.io/2020/02/01/Binutils/"/>
    <id>https://unit-serow.github.io/2020/02/01/Binutils/</id>
    <published>2020-02-01T13:52:49.000Z</published>
    <updated>2020-02-01T14:13:23.508Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Binutils-第一部分"><a href="#GNU-Binutils-第一部分" class="headerlink" title="GNU Binutils 第一部分"></a>GNU Binutils 第一部分</h3><p><strong>GNU 二进制工具包</strong></p><p><strong>工具包内包含程序</strong><br>主要包含ld与as，分别是GNU链接器-GAS与GNU汇编器-GLD</p><p><strong>其他程序</strong></p><ul><li>ar-用于建立，修改，提取归档文件(archive)<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>/用于对归档/静态库做创建，修改和提取的操作</li><li>addr2line-将目标文件的虚拟地址转换为文件的行号或符号</li><li>c++filt-解码C++的符号</li><li>dlltool-用于构建与使用DLL文件，也就是创建windows动态库</li><li>gold-正在测试的功能，一个新型且效率更高的ELF的链接器</li><li>ELF是一种用于可执行文件，目标文件，共享库和核心转储的标准文件格式，可执行与可连接格式，ELF所产生的数据结构与工具不做阐述</li><li>gprof-用于显示性能的分析信息/性能分析工具</li><li>nlmconv-将目标代码转换为NetWare Loadable Module/NLM文件格式</li><li>nm-列出并显示目标文件中的符号</li><li>objcopy-复制并编译目标文件，其过程中可以修改</li><li>objdump-显示目标文件中的相关信息，可用于反汇编</li><li>ranlib-生成静态库索引</li><li>readelf-用于显示任何ELF格式文件的内容</li><li>size-列出对象总体或归档文件的节数/大小</li><li>strings-列出目标二进制文件中的可打印/可显示字符串</li><li>strip-从目标文件中移除符号</li><li>windmc-兼容windows消息的编译器，用于产生windows的消息资源</li><li>windres-windows资源文件的编译器</li></ul><hr><p><strong>杂项及存在意义</strong></p><ul><li>大部分的复杂代码都存于Binary File Descriptor library和libopcodes库内</li><li>所以它是一整套编程语言工具程序,用于处理许多格式的目标文件</li><li>这些程序大多数使用BFD-二进制文件描述库</li><li>主要的目的还是为GNU项目用于解决不同格式的目标文件的可移植性问题的主要机制</li></ul><hr><p><strong>参考:</strong></p><p>获取：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ftp.gnu.org&#x2F;gnu&#x2F;binutils</span><br><span class="line">http:&#x2F;&#x2F;ftpmirror.gnu.org&#x2F;binutils</span><br><span class="line">apt-get install binutils*</span><br><span class="line">克隆：git clone git:&#x2F;&#x2F;sourceware.org&#x2F;git&#x2F;binutils-gdb.git</span><br></pre></td></tr></table></figure><p>官网<a href="https://www.gnu.org/software/binutils/binutils.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/binutils/binutils.html</code></p><p>文档<a href="https://sourceware.org/binutils/docs-2.33.1/" target="_blank" rel="noopener">跳转</a><br><code>https://sourceware.org/binutils/docs-2.33.1/</code></p><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">archive是一个包含多个被包含文件的单一库文件,它可以保证从中检索到原始的被包含文件-mumber,而member用于保存archive的各种基本属性，当member被提取后，archive的属性将被还原到初始状态</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Binutils-第一部分&quot;&gt;&lt;a href=&quot;#GNU-Binutils-第一部分&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Make</title>
    <link href="https://unit-serow.github.io/2020/02/01/Make/"/>
    <id>https://unit-serow.github.io/2020/02/01/Make/</id>
    <published>2020-02-01T13:40:08.000Z</published>
    <updated>2020-02-01T13:49:41.013Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Make-第一部分"><a href="#GNU-Make-第一部分" class="headerlink" title="GNU Make 第一部分"></a>GNU Make 第一部分</h3><p><strong>GNU 自动化建构</strong></p><p><strong>概述:</strong></p><ul><li>在软件开发的过程中，make通常作为一个工具程序(unility software),经由makefile，从而实现自动化构建软件</li><li>在经由makefile时make工具会根据情况转换文件形式至target，转换的同时还会检查文件的依赖关系，检查依赖关系的方式本部分不做阐述</li><li>所以在编写软件时，应该先编写一个makefile，之后再让make去进行构建和安装</li></ul><p>或称为</p><ul><li><p>用于编译源代码，从而生成结果代码，然后将结果代码链接起来，最后生成可执行文件</p></li><li><p>其中名为makefile的文件用来确定某一target文件的以来关系，然后把生成target相关的命令转给机器的shell去执行</p></li><li><p>IDE通常包含了make，make多用于UNIX下的软件开发</p></li><li><p>本质如同UNIX底层的其他基本程序，批量执行生成目标的命令，同时检查文件的依赖关系</p></li></ul><hr><p>参考<br>官方网站<a href="https://www.gnu.org/software/make/make.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/make/make.html</code></p><p>获取<br><code>http: http://ftp.gnu.org/gnu/make/</code><br><code>ftp: ftp://ftp.gnu.org/gnu/make/</code></p><p>make手册<a href="https://www.gnu.org/software/make/manual/" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/make/manual/</code></p><p>makefile手册<a href="https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/prep/standards/html_node/Makefile-Conventions.html#Makefile-Conventions</code></p><p>make源码所在目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;share&#x2F;doc&#x2F;make&#x2F;</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;doc&#x2F;make&#x2F;</span><br></pre></td></tr></table></figure><p>make帮助指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make --help</span><br><span class="line">info make</span><br><span class="line">man make</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Make-第一部分&quot;&gt;&lt;a href=&quot;#GNU-Make-第一部分&quot; class=&quot;headerlink&quot; title=&quot;GNU 
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Compiler Collection</title>
    <link href="https://unit-serow.github.io/2020/02/01/GCC/"/>
    <id>https://unit-serow.github.io/2020/02/01/GCC/</id>
    <published>2020-02-01T13:30:29.000Z</published>
    <updated>2020-02-01T13:39:02.294Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Compiler-Collection-第一部分"><a href="#GNU-Compiler-Collection-第一部分" class="headerlink" title="GNU Compiler Collection 第一部分"></a>GNU Compiler Collection 第一部分</h3><p><strong>GNU 编译器套装 GCC</strong></p><p><strong>概述:</strong></p><ul><li>它是GNU计划中关键的一环</li><li>基于GPL与LGPL软件许可,并且为free software-自由软件</li><li>UNIX-like，Linux，BSD类的操作系统都采用GCC为标准编译器</li><li>其他的C编译器LLVM,Clang</li><li>GCC通常是跨平台编译器的首选</li></ul><hr><p><strong>GCC的执行逻辑与过程</strong><br>GCC的作用是将源代码生成可执行文件大体需要四个步骤:</p><ul><li>预处理/预编译-preprocessing</li><li>编译-compilation</li><li>汇编-assembly</li><li>连接-linking</li></ul><p><strong>由下至上的处理过程</strong></p><ul><li>GCC先调用cpp进行预处理-预处理的作用是对源码文件中的文件包含-include,预编译语句-宏定义define等进行分析,预处理的主要功能大概分为三个:宏定义,文件包含,条件编译</li><li>然后调用cc1进行编译,这个阶段根据输入文件生成以.i为后缀的目标文件</li><li>然后调用as进行汇编工作,一般的汇编语言源码由.s为后缀,s为后缀的汇编语言文件经由编译器和汇编之后会生成.o后缀的目标文件</li><li>当所有目标文件都生成后,GCC就调用ld来完成最后阶段的工作-连接</li><li>在连接阶段,所有目标文件被自动生成并同时分配依赖条件/文件应该所处的位置</li><li>最后,该程序内所用的库函数也会被链接到所对应的位置</li></ul><hr><p><strong>GCC语言编译器的结构</strong><br>语言编译器的结构-由下至上/底层到顶层</p><ul><li>GCC内置了大量语言的编译器,每个语言的编译器都是独立的程序</li><li>编译器的作用是处理输入的源码,从而输出组合语言码</li><li>全部的语言编译器都有共同的中介架构</li><li>语言编译器的结构分为三个部分:前端接口,中介接口以及后端接口</li><li>前端接口负责解析符合此语言的原始码,并产生一个抽象语法树以及翻译此语法树,使其成为GCC的暂存器转换语言-RTL的后端，GCC编译器最佳化与静态程序解码技术应用于此时程序的代码上</li><li>最后适应于硬件架构的组合语言经由某一不可知算法产出</li></ul><hr><p><strong>参考:</strong></p><p>官方网站<a href="https://gcc.gnu.org" target="_blank" rel="noopener">跳转</a><br><code>https://gcc.gnu.org/</code></p><p>获取<br><code>apt-get install gcc*</code></p><p>涉及编译器深层原理的内容此章节不做阐述</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Compiler-Collection-第一部分&quot;&gt;&lt;a href=&quot;#GNU-Compiler-Collection-第一部分&quot; 
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Debugger</title>
    <link href="https://unit-serow.github.io/2020/02/01/Debugger/"/>
    <id>https://unit-serow.github.io/2020/02/01/Debugger/</id>
    <published>2020-02-01T10:36:47.000Z</published>
    <updated>2020-02-01T10:50:35.510Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Debugger-第一部分"><a href="#GNU-Debugger-第一部分" class="headerlink" title="GNU Debugger 第一部分"></a>GNU Debugger 第一部分</h3><p><strong>GNU 调试工具 GDB</strong></p><p><strong>概述:</strong></p><p>存在的意义/作用:</p><ul><li>GDB大多数UNIX及UNIX-like下的调试工具</li><li>GDB可以根据自定义的要求启动所选程序</li><li>让被调试的程序在指定的调试断点停住，其断点可以是条件表达式，当程序被停住时可以去检查该程序中正在处理的事务</li><li>GDB还可以用于修改程序，以此来修复BUG所带来的影响</li><li>GDB相比于其他具有GUI的调式工具的优点就是具有修复网络断点以及恢复链接等功能</li><li>还可以把GDB理解为一个强大的命令行调试工具，命令行的优点就是可以形成一个完整的执行序列，以此来形成脚本程序<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li></ul><p><strong>使用方法简述:</strong></p><p><strong>启动</strong></p><ul><li>可以直接执行GDB以启动GDB命令行，<code>quit</code>退出GDB命令行</li><li>执行<code>gdb file name</code>来选中被调试的目标文件，并进入GDB命令行</li><li><code>run</code>用于执行程序，后面可以接GDB已有的缺省参数</li></ul><p><strong>断点</strong></p><ul><li>执行break命令，可以简写为b，用来给调试的程序中设置断点</li><li>从断电处继续运行执行continue命令</li><li>GDB还内置了断点的管理工具</li><li><code>info break</code> 用于显示当前GDB所有的断点信息</li><li><code>break breakpoint 编号</code> 用于删除指定编号的断点，如果不带编号将删除所有的断点</li><li><code>disable breakpoint 编号</code> 用于禁止使用指定编号的断点，同时info break的enb域变为n</li><li><code>enable breakpoint 编号</code> 允许指定断点，同时info break的enb域变为y</li></ul><p><strong>其他功能简述</strong></p><ul><li>单步执行：next不进入单步执行，step进入单步执行</li><li>函数调用：call function name调用和执行一个函数，执行finish结束当前的函数，如果有返回值就会显示其返回值</li><li>机器语言工具，信号处理与变量复制的检查</li></ul><hr><p><strong>参考资料:</strong></p><p>官方网站<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">跳转</a><br><a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">https://www.gnu.org/software/gdb/</a></p><p>GDB手册<a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">跳转</a><br><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="noopener">https://sourceware.org/gdb/current/onlinedocs/gdb/</a></p><p>深入GDB<a href="https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html" target="_blank" rel="noopener">跳转</a><br><a href="https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html" target="_blank" rel="noopener">https://web.archive.org/web/20080616054054/http://sources.redhat.com/gdb/current/onlinedocs/gdbint.html</a></p><p>开源程序的体系结构-GDB<a href="http://www.aosabook.org/en/gdb.html" target="_blank" rel="noopener">跳转</a><br><a href="http://www.aosabook.org/en/gdb.html" target="_blank" rel="noopener">http://www.aosabook.org/en/gdb.html</a><br><a href="http://www.aosabook.or" target="_blank" rel="noopener">http://www.aosabook.or</a></p><hr><div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none;padding-left:0"><li id="fn:1"><span style="display:inline-block;vertical-align:top;padding-right:10px">1.</span><span style="display:inline-block;vertical-align:top">因为UNIX下的软件基本上都是命令行的，所以它们具有天生的优势-可以很方便的把简单的已有工具的命令集成在一起，从而做出一个功能强大的程序 ---</span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Debugger-第一部分&quot;&gt;&lt;a href=&quot;#GNU-Debugger-第一部分&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>GNU Lib</title>
    <link href="https://unit-serow.github.io/2020/01/30/Lib/"/>
    <id>https://unit-serow.github.io/2020/01/30/Lib/</id>
    <published>2020-01-30T02:43:52.000Z</published>
    <updated>2020-01-30T03:06:57.145Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --><h3 id="GNU-Lib-第一部分"><a href="#GNU-Lib-第一部分" class="headerlink" title="GNU Lib 第一部分"></a>GNU Lib 第一部分</h3><p><strong>GNU 可移植性库</strong></p><p><strong>概述:</strong></p><ul><li>GNU Lib 存在的意义是实现所有gnu代码关于移植性问题处理方法的统一化</li><li>使任何基于GNU标准的软件，可以顺利的移植到任何其他的操作系统上，关于操作系统移植问题的方法统一化</li><li>所以可以把GNU Lib理解为所有基于GNU标准的软件的子程序，这些子程序将GNU软件互相链接，从而实现GNU软件包之间的完全共享</li><li>其中gcc因为libiberty库的原因，很难脱离GNU的构建树，但GNU Lib与其完全不同，构成它的子程序会实现资源等级的划分，使所有基于GNU协议的软件实现代码共享，从而解决移植性问题，而绝非去构建，安装或者链接库</li><li>因此GNU Lib没有发行版的概念，只需要将GNU Lib的源码复制到使用者的代码树中即可</li></ul><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>官网<a href="https://www.gnu.org/software/gnulib" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib</code></p><p>手册<a href="https://www.gnu.org/software/gnulib/manual" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib/manual</code></p><p>获取<br><code>git clone git: //git.savannah.gnu.org/gnulib.git</code></p><p>GNU Lib模块列表<a href="https://www.gnu.org/software/gnulib/MODULES.html" target="_blank" rel="noopener">跳转</a><br><code>https://www.gnu.org/software/gnulib/MODULES.html</code></p><p>社区<a href="http://git.savannah.gnu.org/gitweb/?=gnulib.get" target="_blank" rel="noopener">跳转</a><br><code>http://savannah.gnu.org</code><br><code>http://git.savannah.gnu.org/gitweb/?p=gnulib.get</code></p><p>帮助指令:<code>./gnulib-tool --help</code></p><hr><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Feb 02 2020 21:54:50 GMT+0800 (中国标准时间) --&gt;&lt;h3 id=&quot;GNU-Lib-第一部分&quot;&gt;&lt;a href=&quot;#GNU-Lib-第一部分&quot; class=&quot;headerlink&quot; title=&quot;GNU Li
      
    
    </summary>
    
    
      <category term="软件" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="GNU" scheme="https://unit-serow.github.io/categories/%E8%BD%AF%E4%BB%B6/GNU/"/>
    
    
      <category term="1.认识与概述" scheme="https://unit-serow.github.io/tags/1-%E8%AE%A4%E8%AF%86%E4%B8%8E%E6%A6%82%E8%BF%B0/"/>
    
      <category term="GNU/Linux" scheme="https://unit-serow.github.io/tags/GNU-Linux/"/>
    
  </entry>
  
  <entry>
    <title>随笔 2020-1.30 pm1.23</title>
    <link href="https://unit-serow.github.io/2020/01/30/%E5%AF%B9%E4%BA%8E%E8%87%AA%E8%BA%AB%E7%9A%84%E4%B8%BB%E8%A7%82%E6%80%A7%E8%AF%84%E4%BB%B7/"/>
    <id>https://unit-serow.github.io/2020/01/30/%E5%AF%B9%E4%BA%8E%E8%87%AA%E8%BA%AB%E7%9A%84%E4%B8%BB%E8%A7%82%E6%80%A7%E8%AF%84%E4%BB%B7/</id>
    <published>2020-01-29T17:15:38.000Z</published>
    <updated>2020-02-01T15:11:17.294Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">输入密码</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="3cadc86da932ea4da12b65f8db825a68786b3bf5045b4b90c43098f202e405ae">0267ec72f19b8c198697a4f72870a3a800f27aefe3d5b0c2e7584ef9e154647d2e59d536d4062b11ce869819d847994131103c2d7fbe674488f9d12506f6ff5801241eabed5f099872fd9cef3006898caae24ed806efdf4a1235ed77e5e77ffc1d8078390afb3005987ad7bc876ee11b4cfc2f0e953f8e7e4a457136393d6c215cbf6fa6bf62cfe1cadd4455c84458ee920c329f84ee8414272f75b506bec6b39f6681a396b4dc6e27d9f22877d8699f6028da7fa90b9eefea79b7313073460d77980bddfe53c45684d423953ad44f66654315105dc5774ddd4fc87fbb26dd8382ddc27a865c55a05e2c61c0d073c03d2102d8481bc6e7904d190ea985fb64e34620d623fb4340d74bddb9fe5fd6e4d09b1576625a66b4ea2282aa8ff6764f7b01ef6f554a6069a129fc7fbfc0cbe2b39c4f3053d2cab4b96543cc316010521ca239d41dfced01d2b0792826dad4ecc0eff5f1f3d4db6f81d2663eb508cb5020921e199ab576a04d6867ceb7cb4543545cbad1351459e1445bfedc2a1645a298116a633ce4371588ef97da44f5d4f4736794b533afc73a4f63d195efa64a44d71220dd7c7f27b8cfb7cd7a369225feccaca9c18cd0ec0a53e4b72316428ad8863c9a45b66badc698d1780dbafcae4a9b5ff9cbdc3aa078a893ff8152c1c1e79e2141ad199e6a02bcefa769338c1d6009c3a10d7572d5645a1b2c5c468f47f8c12aabfaeae03ed41715a479e434777821b4a40d4e1f3d1f76a60424b42434695f16c699753f90164a0cf4999fefdea7a0beddb915deff4e04bb423ef25ad6cc9a0da295b04de4bd5416638b780ddbe02a19da27e031fa3445e9d71ebcb1c74e0ce8b295c2a0c06c396a200dd5251e3ea80f5e1c089277f84e90e75f0edc8773344f49ceeb36d5ba8fce8751670d957ff0c828c3c722d4478639fc3c115d984ae77f50a397fd051321b39478485fcecde3aa67c099c6f7e38770248892174b134c5103717598431437eea9806095decf6069dcb37ab8acf296cda0fd79ae783e94a812939365b95ff35048a8b769f6a59ba35919c16a52b3c06ef2abe0085e31b16b066e391833b5ba4e888a1d0b31d5d02f24d5aae02c7e5060645e3d348db6ba9ccdbb328ac6c75f6aa157ea7ec30ac514088b80824ed821dfd4305388dbb1bc1a85939c5208a8e7bef5cf952ca37387c020fbb9a7ea94a611cd4fb53925e1f49591ca64bc4e3b751f82e0870646f1c977005561ea59182b3324e7f0d7d0b1f6064e9d4e39ed84e724794fcbfa0cff7be69eed26a2a209d0ce36906047274fb90bd8e08b16fd3658ab6300e738a667e0e6d7d8dfd282c408043af49c80feb25a81f12dfa0b89b2cc0cc76b3b7392df6e3af7354d9f98c41e3a7942121e64e9c568cc3ab528082a8175c47bc9dfddee57135150360a9ccab3c2fcbc86855b9b6b4cfb6c4adc688f04059eccef0176d725586e51b7d9a9ad3b66b46b632a3456192bcfddee9b20f504e52e1d76a45ceaf9fc44b97ca4a317338ede137ada12f127f76af34727bb6fce35e8ab9953adaef63f87cd684f21e4bb4303cb6fbd5e108057b0fde03a446b3c75f674c45f22aada83907d67cf997b38f23d911de0e99dd33f873cdbc2cdec00265e765759591e966e656de13c78bfea8ddb676cad858a47079a072305cc6989ef059271afc9bfb5363001772f6da4a99ef2d2e00d7e904dccbf7ca6870a87264450b8dba64e37b3e93589e17731cb91643937e94d715f9cac38184b3e28d27474457ee3cc16be5a1d0ab5a315314bd707c7370fa202dba756d0d9bc8ddf9eab65a748dd0a65de94dd8f4f38fa84e81cab6c0ed44a8efbad49872afc978ba70b64dcfe31331abdef125633ad7d61ad0346806c0ecc88fba771e0e0f7e8c7d6bdc72eae8f3140d17911ef70d11cd545adfc4ed85b5c9d4ffc730a73284db3d1f09200c9347a2c911e72175c479389df1d830c46b0e2166186934a4981048d780fdd8005027c352454b8d8f5ffa7c36a3c1a67a6c5b71228741168f70075b215a2591117fd7874c1bd140ae7748b99f8725b6792b41355c147a48dce5c596202937c30e0bea95c9801d3c6161fa48cbcdf1b19cb34f6dd571e6e06bd6234e2963f5299e8cb373f1f71305567b80000efff1785117366772f243c1ad65f8e180d4e5c067c9b20034e262fda6e3fd2f8a0926938a1fc4ac2cc215227d4012643f6e2a4c37711a069cb8a395c9b959beadc5f6323e0c96a960da0dff210de9bd4547ead6d68873a34e1a7349d25d3d2ffcbc82c0beda9a71a36c90d05d3a1785937a5046dd6133da4cc794b6718d03b81587818045a5ca4e25ca4ece95cac0e1b3ed9eaa440e163068eb7700320b3eee7098a71882cfd991954f3f0c01643ab18118ab233188863b0124017522bac948f678669e03fad49dae5b297550f59094e23ab459af1843b44b4100d3dd677e0ec9e812194b201862b5af54a2f39d7d00c1995bf95b98ca3698d8d9cce9f5fbac66178d2d1b7c253bc3db23f86a425f03ab65d3bcae156d86d263f0d656f72dd5abb4623a6b38a9b066a010e1b5d25cb594bb2b5773171f5dab46e0efb651b2713d28b6af7c68c0f47bf1ea322472829600c5b3a7af5add307f23a13b82e44fdc52f616c4658fb8fd586eed698a124fab96385146b747d4b874776935766627d0b4ce9924aa26f41664797fe137b8e2ca82d0e21c5f9b5f96f8dea2a1395b9cef612d6b8357e3bb9cb1b6b2125df73d171acfbf6c16f4fcf8af9e906a7e9352c0018486655ff6f3f520fff4a9b860ed23c09e1e2e350d46791de30644a830cda85fa843ffab9ae41e18015cb7531174a31198cef25f100aaeba975867919b9587142897f5e72b53cde7fd700497edb73987aa649e2d59ff10f8b54144f8ef5196be944d3d377fdff3b0036db0995b3eb7ee65b6a0cb7483a6bdc37681cf107a2a054bab199fb331e523adbee9aff435e8dcee20c6fab116433495ea883668b3eee98b4c0935b4e6238c9963c67da6c1b7d09307326c78b481ea5ad3957cbb78c3f93d014a1d87c6126560836867dbb1a14b58c33b63c024a7cf2c048c1474837c1e2eb8098e3e41a61ac56e4e990792bf8545e3ba8d780f7cf12f3a6cc83e7cb55adf028b12ce3b98da5c4247947ce3b6c6ff403f19ddc7c9739cc0ddba8d4759aa7021773271cf05e9ff09668442908269b01f8f8581845ea32250fa47e5aa53f156eca297bc1e5fb03ccfa8b1d1082654af858a1e1aaed9dbdb25a1d79b375aa8593197312982121c2ca0891a6e3e617dc1ec3b9c0a1ac9bc4c0aa7759eff63dbca371e64162924acdd7553a85c619c8416ce6b72cd536df50461cdbd904e7a64f91edee2be49237dc665e975824259f1606579835738ac5e6632aecc4d334a8b69a43b4c6cfdef2ca8825fdd4fa8ca0f476f53260bc92066f03956180b4a907ec43bab3b6595b873e0cf3c6ee4907f0c746a1fd4517df4393c3ccfc62aa9d7172112708d097452e0140ced355c78e2fda4d1153cd8087b0c12ccae9afc295ddfa4d84d8c517bccf12501fcb00a31bab2b8ec4865aef16faaa3c37b21a07586b2fe3099dc3147423c8747017526d898f47a8a605abc089c587338d2374386f88c42e3f1dfc01214f1f13af93f2f1604148fd33da4b279bfafa65fca064a68d04a20153e4865bf201790f8e90a6580d9d5aae443cedc63eb0e5500807f43192b38e5a493365c2474d3f1be7c5c175100cb46ce4b2270854abb6be0da2f54c6bce7ad0c03efe8b023c0ec1a6915f00c56ea7a2b475a0024f3e16dd682307d7d1eed87218990a7b96821c594f4655a026df19947df2fa2efa80e1c541a7e72e5937ead3b1a7b2ca056793f411df80a483c5e56323fc4028402de676487ee3e8f2066904b0876c4d06567bc1b5c4a6722048eedcdf4ad7b253c97909d5561c45d404207e7f9a45cc6e85e14d4eb16270847a2094b867a3f8c34ebaa7881b791b4f61869d12b192e8f29c488934bcfca1c06167e4c8de86b947d7b99fd8c2a549f125edf7268dcd53c9dda779c1f570f9a6fe8b2397df82248b0a2128ed2f71e17f68fe931eec0261fc7daaa8ae71f2c0fdfc498230d539feceda8ac7fc4048a61cb4d27329075ece0140168b2bbf788c5dcc93b6e28a64238ec47abc545dc009854b9306bf2081664c2691e53afbea14594941de91738848e93f892bb5d4ccd43d8a72dce67c6c88dae6de76a55a2804d0c12e54a1e78a57842531cde449f27ebb5b4df2475c3984814a56129c79dfaf10a3d5051a1a28de20859205f4024a21999e412e31c949fde9893550720ffab1bbb4389fdb171a7d5229f824f6bc27304dd1c86246d74d7657e5028d4e53b146da4370f72b4f0fc404d9b1efa8b88d487363419ec45f885e42c9fb3663b8409cb5d7fb958efbca1a9a18ce0c0c9ac8b9f1691925f2826d1e428198d9f562d384c2878ad5b349f2d52fb5e7095441799ea80bf79d3fc5585e9e150b45a1895137ae127100f82df7d84d6ae50e262b513ae650853a1c9c0740be6516627f5d3cf73b1bb5e03d4331113ebd39982a4aea6da945ecf7bd79e7efc41744ea529dcfcc9b75a6856dc3fada4225d4be83e863eeccbca7c25fa700493dd758f7b09a6252e29111448e9331f8502541f8fc6d65b281eac0ac816644cabcb82108b5f0695a082ad4b9b02203366bbafae2c3d291f16237dc4aca119297ba3533c885a9546b40e370865f27d18c8cab7d47b7a10ee62d9d5121fd190c4a2d5cd51947abf9f46085a035c5ba3c9128ad6c682f267e76b02e0223bf4f2fceafdfd3db28db32b5a18e3c8c5bea30143332a8ae2a05ba056eb40dc94313363e0943ce0aa7096954c1b0175c9f168531d9b46f601510b57de0da3be472e048ce4c378fb2b5eb156f281367ec7bca4b3e13aa1782c39120c478b008f260e7895be8f43aae60c8cb66ab5437c082de889501dd1fa93b471c05dcfdd94029836e84886f04d5f13b732c24f85b444b3ba580e731e519982179b20a73bdff5e36357c7decd2891dcbeed8d7a7c4484b7dee9c7fa8c12fbd584e9c1b37a6c831efce21e1632b619335fc41d9b79c27d6647000f66f55d45d8dc459e917370810b4a74714fc5d732ee0fc097d421ab27de1d66b7b2a6b1b93e8041aadd55a3c47ab54f8057e9a2d86d8673dd74f8e4f0ba0bd93ecd1700d070695601a64869c78284fa6eabefc8451ccac0f688d7889367a676bf8956700f57521ed7bface6061da493792c016dde4520df433567f769f80ebff9b1a755579c6b4b0af9262dcdf05131555936f527de7689c059db443948141fe7e410d12d916309e2be8d34620ab72bd9f649da2b13d9c69329e9cecff86584e2c8d7cc1</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      简易加密文案
    
    </summary>
    
    
    
      <category term="随笔，杂项" scheme="https://unit-serow.github.io/tags/%E9%9A%8F%E7%AC%94%EF%BC%8C%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
</feed>
