---
title: 数据类型-7
date: 2020-03-14 11:55:04
tags: [随笔,C]
categories: [软件,C/C++]
---

<center><strong>数据类型-语句/控制语句-3 </strong></center>

<!-- more -->

### 数据类型-7

* 条件选择语句(控制语句)
> if，if...else，else...if，switch，switch...break，switch...if...else语句
> continue...break
> goto

* 头文件及函数
> ctype.h，iso646.h
> getchar()，putchar()

* 其它概念

---

**涉及内容:**

* 条件选择语句-if/if...else
* getchar()与putchar()方法
* ctype.h头文件/iso646.h头文件
* 多重选择语句-else...if
* 选择语句配对规则
* 逻辑运算符及其优先级，求值顺序与范围
* 条件运算符-?:
* 循环辅助: continue语句和break语句
* 多重选择: switch语句和break语句
* 多重标签: switch语句和if...else语句
* 跳转标识符: goto
* 其它内容(补充内容/关键概念梳理/文章内涉及概念总结)
* 有可能会在数据结构-8内进行补充

---

### IF

* IF语句
* if语句被称为分支语句(branching statement)或选择语句(selection statement)
> 因为它相当于一个交叉点，程序要在两条分支中选择一条执行

* if语句的通用形式如下:
```
if ( expression )
statement
```

* 如果对expression求值为真(非0)，则执行statement
> 否则，跳过statement
* 与while循环一样，statement可以是一条简单语句或复合语句
* if语句的结构和while语句很相似
> 它们的主要区别是: 如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次

* 通常，expression是关系表达式
> 即比较两个量的大小(如，表达式 x > y 或 c == 6)
> 如果expression为真(即x大于y，或c == 6)，则执行statement
> 否则，忽略statement
* 概括地说，可以使用任意表达式，表达式的值为0则为假
* statement部分可以是一条简单语句或者是一条用花括号括起来的复合语句(或块)

---

### IF...ELSE

* 简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句
* C 还提供了if else形式，可以在两条语句之间作选择

* if else语句的通用形式是：
```
if ( expression )
   statement1
else
   statement2
```

* 如果expression为真(非0)，则执行statement1
> 如果expression为假或 0，则执行else后面的statement2
> statement1和statement2可以是一条简单语句或复合语句
> C并不要求一定要缩进，但这是标准风格
> 缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然

* 如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块
> 下面的代码结构违反了C语法，因为在if和else之间只允许有一 条语句(简单语句或复合语句):
```
if (x > 0)
   printf("Incrementing x:\n");
   x++;
else　　　// 将产生一个错误
   printf("x <= 0 \n");
```

* 编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句
> 它不是if语句的一部分
> 然后，编译器发现else并没有所属的if，这是错误的

* 上面的代码应该这样写:
```
if (x > 0)
{
   printf("Incrementing x:\n");
   x++;
}
   else
   printf("x <= 0 \n");
```

* if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择

* if语句和if else语句的执行逻辑示意图

<img src="/images/数据类型-7/IF语句1.png" width="30%" height="30%">

<img src="/images/数据类型-7/IF...ELSE语句-1.png" width="30%" height="30%">

---

**未完成**

---

### getchar()/putchar()

* 字符输入/输出函数getchar()和putchar()
> 同样可用作输入/输出的函数还有scanf()和printf()根据%c转换说明来进行对字符的读写

**getchar()**

* getchar()函数不带任何参数，它从输入队列中返回下一个字符
> 例如: ch=getchar();，它与scanf("%c", &ch);的作用相同

* putchar()函数用于打印它的参数
> 例如: putchar(ch);，该语句用于将之前赋给ch的值作为字符打印出来
> 该语句与printf("%c", ch);相同

* 由于这些函数只用于处理字符，所以它们比通用的scanf()和printf()函数更快，更简介
> 而且还有一点，getchar()和putchar()函数不需要进行转换说明，因为它们只处理字符
> 这两个函数通常定义在stdio.h头文件中(而且它们通常是预处理宏，而不是真正在宏观意义上的函数，这里先不对类似于宏的函数进行深入赘述)

* 语句putchar(ch + 1);
> 表示了字符实际上是作为整数而存储于内存之中的
> 为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()
> 该函数只根据最后一个字节确定显示哪个字符

---

### ctype.h系列的字符函数

* 斜杠字符对应的ASCII码比点号的ASCII码多1
> 如果程序 只转换字母，保留所有的非字母字符(不只是空格)会更好
* C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型
> 这些函数接受一个字符作为参数，如果该字符属于某特殊的类 别，就返回一个非零值(真)
> 否则，返回0(假)
> 例如，如果isalpha()函数的参数是一个字母，则返回一个非零值

* 有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具(例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为 123,45)
> 注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值

* ctype.h头文件中的字符测试函数列表和头文件中的字符映射函数这里不做赘述

---

**多重选择else...if**

* else if 是 if else 语句的变式
* else部分包含另一个if else语 句，该if else语句的else部分又包含另一个if else语句
> 第2个if else语句嵌套 在第 1个if else语句中
> 第3个if else语句嵌套在第2个if else语句中
* 对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌

---

**else...if的配对机制**

* 规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来

**图片说明:**

* if else匹配的规则:

<img src="/images/数据类型-7/if else匹配的规则-1.png" width="40%" height="40%">

<img src="/images/数据类型-7/if else匹配的规则-2.png" width="40%" height="40%">

* 注意: 要缩进"语句"，"语句"可以是一条简单语句或复合语句

---

**多层嵌套的if语句**

* if...else if...else序列是嵌套if的一种形式，从一系列选项中选 择一个执行
> 有时，选择一个特定选项后又引出其他选择，这种情况可以使 用另一种嵌套if

---

* 小结：用if语句进行选择
> 关键字：if，else

* 一般注解:
> 下面各形式中，statement可以是一条简单语句或复合语句
> 表达式为真说明其值是非零值

*  形式1:
```
if (expression)
statement
```
> 如果expression为真，则执行statement部分

* 形式2：
```
if (expression)
statement1
else
statement2
```
> 如果expression为真，执行statement1部分
> 否则，执行statement2部分

* 形式3:
```
if (expression1)
statement1
else if (expression2)
statement2
else
statement3
```

> 如果expression1为真，执行statement1部分
> 如果expression2为真，执行 statement2部分
> 否则，执行statement3部分

* 示例:

```
if (legs == 4)
   printf("It might be a horse.\n");
else if (legs > 4)
   printf("It is not a horse.\n");
else　　 // 如果legs < 4 
{
   legs++;
   printf("Now it has one more leg.\n");
}
```

---

### 补充内容-1

### 逻辑运算符

* if语句和while语句通常使用关系表达式作为测试条件
> 有时则需要将多个关系表示组合起来用，此时则需要使用逻辑运算符，并使用点符号`'.'`来标识句子的末尾

* 逻辑运算符两侧的条件必须都为真，整个表达式才为真
> 逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号

* C 内有三种逻辑运算符，如下表图片:

* 三种逻辑运算符:

<img src="/images/数据类型-7补充图片/三种逻辑运算符-1.png" width="40%" height="40%">

---

* 举例说明:
* 假设exp1和exp2是两个简单的关系表达式(如car > rat或debt == 1000)
> 那么:
> 当且仅当exp1和exp2都为真时，exp1 && exp2才为真
> 如果exp1或exp2为真，则exp1 || exp2为真
> 如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假

---

**iso646.h头文件**

* C 是在美国用标准美式键盘开发的语言，但在世界各地，并非所有键盘都有和美式键盘一样的符号
> 因此，C99标准增加了可代替逻辑运算符的拼写，并且将其定义于iso646.h头文件中
> 如果在程序中包含该头文件，便 可用and代替&&、or代替||、not代替!

* 逻辑运算符对应的拼写如下表图片:

* 逻辑运算符的备选拼写:

<img src="/images/数据类型-7补充图片/逻辑运算符的备选拼写-1.png" width="40%" height="40%">

* 在新增的C99和C11的标准ANSI C库内列出了一些其它运算符的备选拼写

* !运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低
* &&运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高
> 因此，表达式a > b && b > c || b > d相当于((a > b) && (b > c)) || (b > d)
> 也就是说，b介于a和c之间，或者b大于d
> 尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第2种写法
> 这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚

---

**有关求值顺序**

* 除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值

* 例如下面的语句，可能先对表达式5+3求值，也可能先对表达式9+6求值:
> `apples = (5 + 3) * (9 + 6);`

* C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计
> 但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右
> &&和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效
> 而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值
> 正是由于有这些规定，才能写出这样结构的代码:
> `while ((c = getchar()) != ' ' && c != '\n')`
> 如上代码所示，读取字符直至遇到第1个空格或换行符
> 第1 个子表达 式把读取的值赋给c，后面的子表达式会用到c的值
> 如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值

* 这里还有一个例子:
```
if (number != 0 && 12/number == 2)
printf("The number is 5 or 6.\n");
```
> 如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值
> 这样避免了把0作为除数
> 许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件
* 最后，考虑这个例子：
> `while ( x++ < 10 && x + y < 20)`
> 实际上，&&是一个序列点，这保证了在对&&右侧的表达式求值之前已经递增了x

---

**内容简述:**

* 逻辑表达式:
> 当且仅当expression1和expression2都为真，expression1 && expression2才为真
> 如果 expression1 或 expression2 为真，expression1 || expression2 为 真
> 如果expression为假，!expression则为真，反之亦然

* 求值顺序:
* 逻辑表达式的求值顺序是从左往右
> 一旦发现有使整个表达式为假的因 素，立即停止求值
* 示例：
> `6 > 2 && 3 == 3` 真
> `!(6 > 2 && 3 == 3)` 假
> `x != 0 && (20 / x) < 5` 只有当x不等于0时，才会对第2个表达式求值

* 有关范围问题:
> &&运算符与islower()函数可用于测试范围

---

### 条件运算符/三元运算符

* C 提供条件表达式(conditional expression)作为表达if else语句的一种便捷方式
* 该表达式使用`? :`条件运算符
> 该运算符分为两部分，需要三个运算对象
> 带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符
> 以此类推，带三个运算对象的运算符称为三元运算符
> 条件运算符是 C 中唯一的三元运算符

* 条件表达式的通用形式如下:
> `expression1 ? expression2 : expression3`
> 如果 expression1 为真(非 0)，那么整个条件表达式的值与 expression2 的值相同
> 如果expression1为假(0)，那么整个条件表达式的值与 expression3的值相同

* 需要把两个值中的一个赋给变量时，就可以用条件表达式
> 典型的例子是，把两个值中的最大值赋给变量:
> `max = (a > b) ? a : b;`
> 如果a大于b，那么将max设置为a
> 否则，设置为b
> 通常，条件运算符完成的任务用 if else 语句也可以完成
> 但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码

---

### 循环辅助-continue&break

* 一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句
* 而continue和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环

**continue语句**

* 3种循环都可以使用continue语句
> 执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代
> 如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环

* 有两种方法可以避免使用continue
> 一是省略continue，即为把剩余部分放在一个else块中
> 这种情况下，使用continue的好处是减少主语句组中的一级缩进
> 当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性
> 另一种方式是把if的测试条件的关系反过来便可避免使用continue
> 需要根据程序的实际情况而定

* continue还可用作占位符
> 例如将循环读取并丢弃输入的数据， 直至读到行末尾
> 当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便
> 问题是，一般很难注意到一个单独的分号
> 如果使用continue，可读性会更高
> 如果用了continue没有简化代码反而让代码更复杂，就不要使用continue

* 从何处开始继续循环:
> 以上介绍了continue语句让程序跳过循环体的余下部分
> 对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值

**break语句**

* 程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段
> 但如果break语句位于嵌套循环内，它只会影响包含它的当前循环

* 以下两张图片比较了break和continue

<img src="/images/数据类型-7补充图片/break和continue-1.png" width="40%" height="40%">
<img src="/images/数据类型-7补充图片/break和continue-2.png" width="40%" height="40%">

* break还可用于因其他原因退出循环的情况
* 和continue一样，如果用了break代码反而更复杂，就不要使用break
* break语句对于稍后讨论的switch语句而言至关重要
> 在for循环中的break和continue的情况不同
> 执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过
> 嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break

---

### 多重选择

* 使用条件运算符和 if else 语句很容易编写二选一的程序
> 然而，有时程序需要在多个选项中进行选择
> 可以用if else if...else来完成
>但是大多数情况下使用switch语句更方便

**switch的工作原理分析**

* 要对紧跟在关键字 switch 后圆括号中的表达式求值
> break语句让程序离开switch语句，跳至switch语 句后面的下一条语句
> 如果没有break语句，就会从匹配标签开始执行到switch末尾

* break语句可用于循环和switch语句中，但是continue只能用于循环中
> 尽管如此，如果switch语句在一个循环中，continue便可作为 switch语句的一部分
> 这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分

* switch语句和Pascal的case语句类似
> 它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句
> 另外，C 的case一般都指定一个值，不能使用一个范围

* switch在圆括号中的测试表达式的值应该是一个整数值(包括char类型)
* case标签必须是整数类型(包括char类型)的常量或整型常量表达式(即表达式中只包含整型常量)
> 不能用变量作为case标签

* switch的构造如下：
```
switch ( 整型表达式)
{
case 常量1:
语句	<--可选
case 常量2:
语句	<--可选
default :	<--可选
语句	<--可选
}
```

* 关于程序只读每行的首字符的情况这里不做多余赘述

---

**有关多重标签**

* 可以在switch语句中使用多重case标签
* 如果使用ctype.h系列的toupper()函数可以避免 使用多重标签

---

**有关switch和if else**

* 关于何时使用switch与何时使用if else
> 如果是根据浮 点类型的变量或表达式来选择，就无法使用 switch
> 如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦
> 这种情况用if就很方便:
> `if (integer < 1000 && integer > 2)`
* 使用switch要涵盖以上范围，需要为每个整数(3～999)设置case标签
> 但是，如果使用switch，程序通常运行快一些，生成的代码少一些

---

### goto

* 早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用
> 但 是C和其他两种语言不同，没有goto语句C程序也能运行良好
> Kernighan和 Ritchie提到goto语句"易被滥用"，并建议"谨慎使用，或者根本不用"

* goto语句有两部分: goto和标签名
* 标签的命名遵循变量命名规则如下所示:
> `goto part2;`
* 要让这条语句正常工作，函数还必须包含另一条标为part2的语句
> 该语句以标签名后紧跟一个冒号开始:
> `part2: printf("Refined analysis:\n");`

**避免使用goto**

* 原则上，根本不用在C程序中使用goto语句
> 但在FORTRAN或BASIC内，goto对这两种语言而言都必不可少，而且还会依赖用goto来编程
> 对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if
> 不能使用块或复合语句

* 跳转至循环末尾，并开始下一轮迭代
> C使用continue语句代替跳出循环
* C使用break语句
> 实际上，break和continue是goto的特殊形式
> 使用break和continue的好处是: 其名称已经表明它们的用法，而且这些语句不使用标签
> 所以不用担心把标签放错位置导致的危险
> 胡乱跳转至程序的不同部分
* 但是，C程序员可以接受一种goto的用法: 出现问题时从一组嵌套循环中跳出(一条break语句只能跳出当前循环)

* 不去使用goto的多个理由:
> 程序中使用其他形式比使用goto的条理更清晰
> 当多种情况混在一起时，这种差异更加明显
> 哪些goto语句可以帮助if 语句? 哪些可以模仿if else? 哪些控制循环? 
> 哪些是因为程序无路可走才不得已放在那里?
> 过度地使用goto语句，会让程序错综复杂
> 如果不熟悉goto语句，就不要使用它
> 如果已经习惯使用goto语句，试着改掉这个毛病
> 讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用
> 因为 C允许在标签中使用描述性的单词而不是数字

---

### 参考资料:

* CN/PDF-C Primer Plus【第6版】
> [美] Stephen Prata | 著/姜佑 | 译
> 截止至原书第七章末尾-496页(一共1635页)
> C 控制语句: 分支和跳转-7.10/7.12

* 数据类型-1~数据类型-7
> C11/ANSI C/ISO C

---

* 接下来的内容会以 C 冠名

---



